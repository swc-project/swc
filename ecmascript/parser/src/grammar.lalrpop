use ast::*;
use swc_common::{BytePos, Span};
use token::{Keyword, Token, BinOp, AssignOp, AssignOpToken, BinOpToken, Ident};
use {Error, Errors};

grammar(errors: &mut Errors);




// -------------------- Macros --------------------

// TODO: Use a trait like WithSpan

SpannedExpr<Rule>: Expr = 
    <l: @L> <node: Rule> <r: @R> => {
        Expr {
            span: Span { start: l, end: r },
            node,
        }
    };


SingleComma: () = {
    "," => (),
    // Necessar
    <!> => errors.push(<>.error)
};

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> SingleComma)*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };


// #############################################################################
// #############################################################################
// ############################## 12. Expressions ##############################
// #############################################################################
// #############################################################################



// ###############################################
// ###############################################
// ############### 12.1 Identifiers ##############
// ###############################################
// ###############################################

// normal identifiers
Ident: Ident = {
    <l: @L> <i: "ident"> <r: @R> => {
        let sym = match i {
            Token::Ident(ident) => ident,
            _ => unreachable!(),
        };
        Ident {
            sym,
            span: Span{ start: l, end: r },
        }
    },
};


// Yield - if non-empty, exclude yield.
// Await - if non-empty, exclude await.
IdentRef<Yield, Await>: Ident = {
    Ident,
    "yield" if Yield == "",
    "await" if Await == "",
};


BindingIdent<Yield, Await>: Ident = {
    Ident,
    "yield",
    "await",    
};

// Yield - if non-empty, exclude yield.
// Await - if non-empty, exclude await.
LabelIdent<Yield, Await>: Ident = {
    Ident,
    "yield" if Yield == "",
    "await" if Await == "",
};




// ###############################################
// ###############################################
// ########### 12.2 Primary Expression ###########
// ###############################################
// ###############################################

PrimaryExpr<Yield, Await>: ExprKind = {
    "this" => ExprKind::This,
    IdentRef<Yield, Await> => ExprKind::Ident(<>),
    Lit => ExprKind::Lit(<>),
    ArrayLit<Yield, Await>,
    ObjLit<Yield, Await>,
    FnExpr => ExprKind::Function(<>),
    ClassExpr<Yield, Await>,
    GeneratorExpr,
    AsyncFnExpr,
    Regex => ExprKind::Lit(Lit::Regex(<>)),
    TplLit<Yield, Await>,
    CoverParenthesizedExprAndArrowParams<Yield, Await>,
};

CoverParenthesizedExprAndArrowParams<Yield, Await>: ExprKind = {
    "(" <Expr<"In", Yield, Await>> ")" => unimplemented!(),
    "(" <Expr<"In", Yield, Await>> "," ")" => unimplemented!(),
    "(" ")" => unimplemented!(),
    "(" "..." <BindingIdent<Yield, Await>> ")" => unimplemented!(),
    "(" "..." <BindingPat<Yield, Await>> ")" => unimplemented!(),
    "(" <Expr<"In", Yield, Await>> "," "..." <BindingIdent<Yield, Await>> ")" => unimplemented!(),
    "(" <Expr<"In", Yield, Await>> "," "..." <BindingPat<Yield, Await>> ")" => unimplemented!(),
};


// ###############################################
// ###############################################
// ############### 12.2.4 Literals ###############
// ###############################################
// ###############################################

Lit: Lit = {
    "null" => Lit::Null,
    "true" => Lit::Bool(true),
    "false" => Lit::Bool(false),
    Num => Lit::Num(<>),
    Str => Lit::Str(<>),
};

Num: Num = {
    "number" => unimplemented!(),
};

Str: String = {
    "string" => unimplemented!(),
};

// ###############################################
// ###############################################
// ########## 12.2.5 Array Initializer ###########
// ###############################################
// ###############################################

ArrayLit<Yield, Await>: ExprKind = {
};



// ###############################################
// ###############################################
// ######### 12.2.6 Object Initializer ###########
// ###############################################
// ###############################################
ObjLit<Yield, Await>: ExprKind = {
    "{" Comma<Prop<Yield, Await>> "}" => {
        ExprKind::Object { props: <> }
    },
};

Prop<Yield, Await>: Prop = {
    IdentRef<Yield, Await> => unimplemented!(),
    CoverInitializedName<Yield, Await>,
    <prop_name: PropName<Yield, Await>> ":" <value: AssignmentExpr<"In", Yield, Await>> => {
        unimplemented!(),
    },
    MethodDef<Yield, Await> => unimplemented!(),
};

PropName<Yield, Await>: Expr = {
    LitPropName,
    ComputedPropName,
};

LitPropName: ExprKind = {
    Ident => ExprKind::Ident(<>),
    Str => ExprKind::Lit(Lit::Str(<>)),
    Num => ExprKind::Lit(Lit::Num(<>)),
};

ComputedPropName<Yield, Await>: ExprKind = {
    "["
        AssignmentExpr<"In", Yield, Await>
    "]" => unimplemented!(),
};

CoverInitializedName<Yield, Await>: Prop = {
    <i: IdentRef<Yield, Await>> <init: Initializer<"In", Yield, Await>> => unimplemented!(),
};

Initializer<In, Yield, Await>: Expr = {
    "=" AssignmentExpr<In, Yield, Await> => unimplemented!(),
};

// ###############################################
// ###############################################
// ##### 12.2.8 Regular Expression Literals ######
// ###############################################
// ###############################################

Regex: Regex = {
    "regex" => {
        match <> {
            Token::Regex(exp, flags) => Regex { exp, flags, },
            _ => unreachable!(),
        }
    },
};

// ###############################################
// ###############################################
// ########## 12.2.9 Template Literals ###########
// ###############################################
// ###############################################


TplLit<Yield, Await, Tagged>: ExprKind = {
};

// ###############################################
// ###############################################
// ####### 12.3 Left-Hand-Side Expressions #######
// ###############################################
// ###############################################
MemberExpr<Yield, Await>: ExprKind = {
    PrimaryExpr<Yield, Await>,

    MemberExpr<Yield, Await>
        "[" Expr<"In", Yield, Await> "]" => unimplemented!(),
    
    MemberExpr<Yield, Await>
        "." Ident => unimplemented!(),

    MemberExpr<Yield, Await> TplLit<Yield, Await, "Tagged"> => unimplemented!(),

    SuperProp<Yield, Await>,

    MetaProp,

    "new" MemberExpr<Yield, Await> Arguments<Yield, Await> => unimplemented!(),

};

SuperProp<Yield, Await>: ExprKind = {
    "super"
        "["
            Expr<"In", Yield, Await>
        "]" => unimplemented!(),
    
    "super" "." Ident => unimplemented!(),
};

MetaProp: ExprKind = {
    NewTarget,
};

NewTarget: ExprKind = {
    "new" "." "target" => unimplemented!(),
};

NewExpr<Yield, Await>: ExprKind = {
    MemberExpr<Yield, Await> => unimplemented!(),
    "new" NewExpr<Yield, Await> => unimplemented!(),
};


CallExpr<Yield, Await>: ExprKind = {
    // CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]
    // SuperCall[?Yield, ?Await]
    // CallExpression[?Yield, ?Await]Arguments[?Yield, ?Await]
    // CallExpression[?Yield, ?Await][Expression[+In, ?Yield, ?Await]]
    // CallExpression[?Yield, ?Await].IdentifierName
    // CallExpression[?Yield, ?Await]TemplateLiteral[?Yield, ?Await, +Tagged]
};

SuperCall<Yield, Await>: ExprKind = {
    "super" Arguments<Yield, Await> => unimplemented!(),
};

Arguments<Yield, Await>: ExprKind = {
    // ()
    // (ArgumentList[?Yield, ?Await])
    // (ArgumentList[?Yield, ?Await],)
};
// ArgumentList[Yield, Await]:
// AssignmentExpression[+In, ?Yield, ?Await]
// ...AssignmentExpression[+In, ?Yield, ?Await]
// ArgumentList[?Yield, ?Await],AssignmentExpression[+In, ?Yield, ?Await]
// ArgumentList[?Yield, ?Await],...AssignmentExpression[+In, ?Yield, ?Await]


LhsExpr<Yield, Await>: ExprKind = {
    NewExpr<Yield, Await>,
    CallExpr<Yield, Await>,
};



// ###############################################
// ###############################################
// ########### 12.4 Update Expressions ###########
// ###############################################
// ###############################################

UpdateExpr<Yield, Await>: ExprKind = {
    <LhsExpr<Yield, Await>> "++" => {
        ExprKind::Update {
            op: UpdateOp::PlusPlus,
            prefix: false,
            arg: box <>,
        }
    },
    <LhsExpr<Yield, Await>> "--" => {
        ExprKind::Update {
            op: UpdateOp::MinusMinus,
            prefix: false,
            arg: box <>,
        }
    },
    "++" <LhsExpr<Yield, Await>> => {
        ExprKind::Update {
            op: UpdateOp::PlusPlus,
            prefix: true,
            arg: box <>,
        }
    },
    "--" <LhsExpr<Yield, Await>> => {
        ExprKind::Update {
            op: UpdateOp::MinusMinus,
            prefix: true,
            arg: box <>,
        }
    },
    LhsExpr<Yield, Await>,
};

// ###############################################
// ###############################################
// ############ 12.5 Unary Operators #############
// ###############################################
// ###############################################
UnaryExpr<Yield, Await>: ExprKind = {
    UpdateExpr<Yield, Await>,
    
    <op: UnaryOp> <arg: SpannedExpr< UnaryExpr<Yield, Await> >> => {
        ExprKind::Unary {
            prefix: true,
            op,
            arg: box arg,
        }
    },

    ///
    AwaitExpr<Yield> if Await != "",
};

UnaryOp: UnaryOp = {
    "delete" => UnaryOp::Delete,
    "void" => UnaryOp::Void,
    "typeof" => UnaryOp::TypeOf,
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "~" => UnaryOp::Tilde,
    "!" => UnaryOp::Bang,
};


// ###############################################
// ###############################################
// ######## 12.6 Exponentiation Operator #########
// ###############################################
// ###############################################
ExponentExpr<Yield, Await>: ExprKind = {
    UnaryExpr<Yield, Await>,

    < up: UpdateExpr<Yield, Await> > "**" < exp: ExponentExpr<Yield, Await> > => {
        unimplemented!()
    },
};

// ###############################################
// ###############################################
// ######## 12.7 Multiplicative Operators ########
// ###############################################
// ###############################################
MultExpr<Yield, Await>: ExprKind = {
    ExponentExpr<Yield, Await>,

    < l: MultExpr<Yield, Await> > <op: MulOp> < r: ExponentExpr<Yield, Await> > => {
        unimplemented!()
    }
};

MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

// ###############################################
// ###############################################
// ########### 12.8 Additive Operators ###########
// ###############################################
// ###############################################
AdditiveExpr<Yield, Await>: ExprKind = {
    MultExpr<Yield, Await>,

    <l: AdditiveExpr<Yield, Await>> "+" <r: MultExpr<Yield, Await>> => { unimplemented!() },
    <l: AdditiveExpr<Yield, Await>> "-" <r: MultExpr<Yield, Await>> => { unimplemented!() },
};

// ###############################################
// ###############################################
// ######## 12.9 Bitwise Shift Operators #########
// ###############################################
// ###############################################

ShiftExpr<Yield, Await>: ExprKind = {
    AdditiveExpr<Yield, Await>,

    <l: ShiftExpr<Yield, Await>> <op: ShiftOp> <r: AdditiveExpr<Yield, Await>> => unimplemented!(),
};

ShiftOp: BinaryOp = {
    "<<" => BinaryOp::LShift,
    ">>" => BinaryOp::RShift,
    ">>>" => BinaryOp::ZeroFillRShift,
};


// ###############################################
// ###############################################
// ######### 12.10 Relational Operators ##########
// ###############################################
// ###############################################
RelExpr<In, Yield, Await>: ExprKind = {
    ShiftExpr<Yield, Await>,

    <l: RelExpr<In, Yield, Await>>
        <op: RelOp>
        <r: ShiftExpr<Yield, Await>> => unimplemented!(),

    /// Only available if In != ""
    <l: RelExpr<"In", Yield, Await>>
        "in"
        <r: ShiftExpr<Yield, Await>> if In != "" => unimplemented!(),
};

RelOp: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::LtEq,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::GtEq,
    "instanceof" => BinaryOp::InstanceOf,
};

// ###############################################
// ###############################################
// ########## 12.11 Equality Operators ###########
// ###############################################
// ###############################################
EqExpr<In, Yield, Await>: ExprKind = {
    RelExpr<In, Yield, Await>,

    <l: EqExpr<In, Yield, Await>>
        <op: EqOp>
        <r: RelExpr<In, Yield, Await>> => unimplemented!(),
};

EqOp: BinaryOp = {
    "==" => BinaryOp::EqEq,
    "!=" => BinaryOp::NotEq,
    "===" => BinaryOp::EqEqEq,
    "!==" => BinaryOp::NotEqEq,
};

// ###############################################
// ###############################################
// ######## 12.12 Binary Bitwise Operators #######
// ###############################################
// ###############################################

BitAndExpr<In, Yield, Await>: ExprKind = {
    EqExpr<In, Yield, Await>,

    <l: BitAndExpr<In, Yield, Await>> "&" <r: EqExpr<In, Yield, Await>> => unimplemented!(),
};

BitXorExpr<In, Yield, Await>: ExprKind = {
    BitAndExpr<In, Yield, Await>,

    <l: BitXorExpr<In, Yield, Await>> "^" <r: BitAndExpr<In, Yield, Await>> => unimplemented!(),
};

BitOrExpr<In, Yield, Await>: ExprKind = {
    BitXorExpr<In, Yield, Await>,

    <l: BitOrExpr<In, Yield, Await>> "|" <r: BitXorExpr<In, Yield, Await>> => unimplemented!(),
};

// ###############################################
// ###############################################
// ######## 12.13 Binary Logical Operators #######
// ###############################################
// ###############################################

LogicalAndExpr<In, Yield, Await>: ExprKind = {
    BitOrExpr<In, Yield, Await>,

    <l: LogicalAndExpr<In, Yield, Await>> "&&" <r: BitOrExpr<In, Yield, Await>> => unimplemented!(),
};

LogicalOrExpr<In, Yield, Await>: ExprKind = {
    LogicalAndExpr<In, Yield, Await>,

    <l: LogicalOrExpr<In, Yield, Await>> "||" <r: LogicalAndExpr<In, Yield, Await>> => unimplemented!(),
};

// ###############################################
// ###############################################
// ##### 12.14 Conditional Operator ( ? : ) ######
// ###############################################
// ###############################################

CondExpr<In, Yield, Await>: ExprKind = {
    LogicalOrExpr<In, Yield, Await>,

    <cond: LogicalOrExpr<In, Yield, Await>> 
        "?" <cons: AssignmentExpr<"In", Yield, Await>>
        ":" <alt: AssignmentExpr<In, Yield, Await>> => unimplemented!(),
};

// ###############################################
// ###############################################
// ######### 12.15 Assignment Operators ##########
// ###############################################
// ###############################################
AssignmentExpr<In, Yield, Await>: ExprKind = {
    CondExpr<In, Yield, Await>,

    YieldExpr<In, Await> if Yield != "",

    ArrowFunction<In, Yield, Await>,

    AsyncArrowFunction<In, Yield, Await>,

    <l: LhsExpr<Yield, Await>>
        <op: AssignOp>
        <r: AssignmentExpr<In, Yield, Await>> => unimplemented!(),
};

/// This returns AssignOp(AssignOpToken)
AssignOp: Token = {
    "=" , "*=", "/*", "+=", "-=",
     "<<=", ">>=", ">>>=", "&=", "^=", "|=", "**=",
    
};



// ###############################################
// ###############################################
// ######### 12.16 Comma Operator ( , ) ##########
// ###############################################
// ###############################################

Expr<In, Yield, Await>: ExprKind = {
    AssignmentExpr<In, Yield, Await>,

    Expr<In, Yield, Await> "," AssignmentExpr<In, Yield, Await> => unimplemented!(),
};



// #############################################################################
// #############################################################################
// ###################### 13 Statements and Declarations #######################
// #############################################################################
// #############################################################################

pub StmtKind<Yield, Await, Return>: StmtKind = {
    BlockStmt<Yield, Await, Return>,
    VarStmt<Yield, Await>,
    EmptyStmt,
    ExprStmt<Yield, Await>,
    IfStmt<Yield, Await, Return>,
    BreakableStmt<Yield, Await, Return>,
    ContinueStmt<Yield, Await>,
    BreakStmt<Yield, Await>,
    ReturnStmt<Yield, Await> if Return != "",
    WithStmt<Yield, Await, Return>,
    LabelledStmt<Yield, Await, Return>,
    ThrowStmt<Yield, Await>,
    TryStmt<Yield, Await, Return>,
    DebuggerStmt,
};

Decl<Yield, Await, Default>: Decl = {
    HoistableDecl<Yield, Await, "">,
    ClassDecl<Yield, Await, "">,
    LexicalDecl<"In", Yield, Await>,
};

HoistableDecl<Yield, Await, Default>: Decl = {
    FnDecl<Yield, Await, Default>,
    GeneratorDecl<Yield, Await, Default>,
    AsyncFnDecl<Yield, Await, Default>,
};

BreakableStmt<Yield, Await, Return>: StmtKind = {
    IterationStmt<Yield, Await, Return>,
    SwitchStmt<Yield, Await, Return>,
};


// ###############################################
// ###############################################
// ################# 13.2 Block ##################
// ###############################################
// ###############################################

BlockStmt<Yield, Await, Return>: BlockStmt = {
    Block<Yield, Await, Return>,
};

Block<Yield, Await, Return>: BlockStmt = {
    "{" <StmtListItem<Yield, Await, Return>*> "}",
};

StmtListItem<Yield, Await, Return>: Stmt = {
    Stmt<Yield, Await, Return>,
    Decl<Yield, Await>,
};

// ###############################################
// ###############################################
// # 13.3 Declarations and the Variable Statement 
// ###############################################
// ###############################################

LexicalDecl<In, Yield, Await>: Decl = {
    LetOrConst BindingList<In, Yield, Await>
        ";" => unimplemented!(),
};

LetOrConst: VarDeclKind = {
    "let" => VarDeclKind::Let,
    "const" => VarDeclKind::Const,
};

BindingList<In, Yield, Await>: Vec<VarDeclarator> = {
    <LexicalBinding<In, Yield, Await>+>,
};

LexicalBinding<In, Yield, Await>: VarDeclarator = {
    BindingIdent<Yield, Await> <Initializer<In, Yield, Await>?> => unimplemented!(),
    BindingPat<Yield, Await> Initializer<In, Yield, Await>,
};

// ###############################################
// ###############################################
// ############ 13.4 Empty Statement #############
// ###############################################
// ###############################################

EmptyStmt: StmtKind = {
    ";" => StmtKind::Empty,
};

// ###############################################
// ###############################################
// ########## 13.5 Expression Statement ##########
// ###############################################
// ###############################################

ExprStmt<Yield, Await>: StmtKind = {
    //WTF is this.. 
// [lookahead ∉ { {, function, async [no LineTerminator here] function, class, let [ }]
// Expression[+In, ?Yield, ?Await];
};



// ###############################################
// ###############################################
// ############## 13.6 If Statement ##############
// ###############################################
// ###############################################

IfStmt<Yield, Await, Return>: StmtKind = {
    "if" "(" <cond: Expr<"In", Yield, Await>> ")" 
        Stmt<Yield, Await, Return> 
    "else"
        Stmt<Yield, Await, Return> => unimplemented!(),

    "if" "(" <cond: Expr<"In", Yield, Await>> ")" 
        Stmt<Yield, Await, Return> => unimplemented!(),
};



// ###############################################
// ###############################################
// ########## 13.7 Iteration Statement ###########
// ###############################################
// ###############################################
IterationStmt<Yield, Await, Return>: StmtKind = {
    
};





FnExpr: FnExpr = {
    "function" <ident: Ident?> 
        "(" <params: FormalParams> ")"
        "{" <body: FnBody> "}" => {
        unimplemented!("FnExpr")
    },
};

FormalParams: Vec<Pat> = {
    
};

FnBody: Vec<Stmt> = {
    <FnStmtList>,
};

FnStmtList: Vec<Stmt> = {

};



ClassExpr: ExprKind = {
    "class" <ident: Ident?> <class: ClassTail> => {
        ExprKind::Class(ClassExpr { ident, class, })
    },
};

ClassHeritage: Expr = {
    // TODO: Expr<'lhs>
    "extends" <LhsExpr> => <>,
};

ClassTail: Class = {
    <super_class: ClassHeritage?> "{"
        <body: ClassElement*>
    "}" => {
        Class {
            super_class: super_class.map(Box::new),
            body,
        }
    },
};

ClassElement: Option<MethodDef> = {
    ";" => None,
    <s: "static"> <m: MethodDef> => {
        let mut m = m;
        m.is_static = true;
        Some(m)
    },
    <MethodDef> => Some(<>),
};


/// This doesn't check 'static'
MethodDef: MethodDef = {
};





GeneratorExpr: ExprKind = {
};

AsyncFnExpr: ExprKind = {
};














/// ---------- 15. Scripts and Modules ----------

pub Module: Module = {
    <l:@L> <body: ModuleItem*> <r:@R> => {
        Module {
            span: Span { start: l, end: r },
            body,
        }
    },
};

ModuleItem: ModuleItem = {
    <ImportDecl>,
    <ExportDecl>,
    <StmtListItem>,
};

ImportDecl: ModuleItem = {
    "import" <import: ImportClause> <from: FromClause> => unimplemented!(),
    "import" <ModuleSpecifier> => unimplemented!(),
};

ImportClause: () = {
    // 'import A from "mod.js"'
    <ImportedDefaultBinding> => unimplemented!(),
};

ImportedDefaultBinding: Ident = {
    <Ident>,
};

ModuleSpecifier: String = {
    <Str>,
};

FromClause: () = {

};

ExportDecl: ModuleItem = {

};






/// ---------- Code for custom lexer ----------
extern {
    type Location = BytePos;
    type Error = Error;

    enum Token {
        "string" => Token::Str(_),
        "regex" => Token::Regex(_, _),
        "number" => Token::Num(_),
        "ident" => Token::Ident(Ident::Normal(_)),

        "await" => Token::Ident(Ident::Await),
        "yield" => Token::Ident(Ident::Yield),



        "=>" => Token::Arrow,
        "@" => Token::At,
        "." => Token::Dot,
        "..." => Token::DotDotDot,
        "!" => Token::Bang,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ";" => Token::Semi,
        "," => Token::Comma,
        "`" => Token::BackQuote,        
        ":" => Token::Colon,        
        "::" => Token::ColonColon,
        "${" => Token::DollarLBrace,
        "?" => Token::QuestionMark,
        "++" => Token::PlusPlus,
        "--" => Token::MinusMinus,
        "~" => Token::Tilde,

        
        // --------------- Bin ops ---------------
        "==" => Token::BinOp(BinOpToken::EqEq),
        "!=" => Token::BinOp(BinOpToken::NotEq),
        "===" => Token::BinOp(BinOpToken::EqEqEq),
        "!==" => Token::BinOp(BinOpToken::NotEqEq),
        "<" => Token::BinOp(BinOpToken::Lt),
        "<=" => Token::BinOp(BinOpToken::LtEq),
        ">" => Token::BinOp(BinOpToken::Gt),
        ">=" => Token::BinOp(BinOpToken::GtEq),
        "<<" => Token::BinOp(BinOpToken::LShift),
        ">>" => Token::BinOp(BinOpToken::RShift),
        ">>>" => Token::BinOp(BinOpToken::ZeroFillRShift),        
        "+" => Token::BinOp(BinOpToken::Add),
        "-" => Token::BinOp(BinOpToken::Sub),
        "*" => Token::BinOp(BinOpToken::Mul),
        "/" => Token::BinOp(BinOpToken::Div),
        "%" => Token::BinOp(BinOpToken::Mod),
        "|" => Token::BinOp(BinOpToken::BitOr),
        "^" => Token::BinOp(BinOpToken::BitXor),
        "&" => Token::BinOp(BinOpToken::BitAnd),
        "**" => Token::BinOp(BinOpToken::Exp),
        "||" => Token::BinOp(BinOpToken::LogicalOr),
        "&&" => Token::BinOp(BinOpToken::LogicalAnd),

        // --------------- Assign ops ---------------
        "=" => Token::AssignOp(AssignOpToken::Assign),
        "*=" => Token::AssignOp(AssignOpToken::MulAssign),
        "/*" => Token::AssignOp(AssignOpToken::DivAssign),
        "+=" => Token::AssignOp(AssignOpToken::AddAssign),
        "-=" => Token::AssignOp(AssignOpToken::SubAssign),
        "<<=" => Token::AssignOp(AssignOpToken::LShiftAssign),
        ">>=" => Token::AssignOp(AssignOpToken::RShiftAssign),
        ">>>=" => Token::AssignOp(AssignOpToken::ZeroFillRShiftAssign),
        "&=" => Token::AssignOp(AssignOpToken::BitAndAssign),
        "^=" => Token::AssignOp(AssignOpToken::BitXorAssign),
        "|=" => Token::AssignOp(AssignOpToken::BitOrAssign),
        "**=" => Token::AssignOp(AssignOpToken::ExpAssign),


        // --------------- Keywords ---------------
        "break" => Token::Keyword(Keyword::Break),
        "case" => Token::Keyword(Keyword::Case),
        "catch" => Token::Keyword(Keyword::Catch),
        "continue" => Token::Keyword(Keyword::Continue),
        "debugger" => Token::Keyword(Keyword::Debugger),
        "default" => Token::Keyword(Keyword::Default),
        "do" => Token::Keyword(Keyword::Do),
        "else" => Token::Keyword(Keyword::Else),
        "finally" => Token::Keyword(Keyword::Finally),
        "for" => Token::Keyword(Keyword::For),
        "function" => Token::Keyword(Keyword::Function),
        "if" => Token::Keyword(Keyword::If),
        "return" => Token::Keyword(Keyword::Return),
        "switch" => Token::Keyword(Keyword::Switch),
        "throw" => Token::Keyword(Keyword::Throw),
        "try" => Token::Keyword(Keyword::Try),
        "var" => Token::Keyword(Keyword::Var),
        "while" => Token::Keyword(Keyword::While),
        "with" => Token::Keyword(Keyword::With),
        "null" => Token::Keyword(Keyword::Null),
        "true" => Token::Keyword(Keyword::True),
        "false" => Token::Keyword(Keyword::False),
        "instanceof" => Token::Keyword(Keyword::InstanceOf),
        "typeof" => Token::Keyword(Keyword::TypeOf),
        "void" => Token::Keyword(Keyword::Void),
        "delete" => Token::Keyword(Keyword::Delete),
        "new" => Token::Keyword(Keyword::New),
        "in" => Token::Keyword(Keyword::In),
        "this" => Token::Keyword(Keyword::This),
        "let" => Token::Keyword(Keyword::Let),
        "const" => Token::Keyword(Keyword::Const),
        "class" => Token::Keyword(Keyword::Class),
        "extends" => Token::Keyword(Keyword::Extends),
        "export" => Token::Keyword(Keyword::Export),
        "import" => Token::Keyword(Keyword::Import),
        "yield" => Token::Keyword(Keyword::Yield),
        "super" => Token::Keyword(Keyword::Super),
    }
}