{"version":3,"file":"esm.js","sourceRoot":"","sources":["../src/esm.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  register,\n  getExtensions,\n  RegisterOptions,\n  Service,\n  versionGteLt,\n} from './index';\nimport {\n  parse as parseUrl,\n  format as formatUrl,\n  UrlWithStringQuery,\n  fileURLToPath,\n  pathToFileURL,\n} from 'url';\nimport { extname } from 'path';\nimport * as assert from 'assert';\nimport { normalizeSlashes } from './util';\nconst {\n  createResolve,\n} = require('../dist-raw/node-esm-resolve-implementation');\nconst { defaultGetFormat } = require('../dist-raw/node-esm-default-get-format');\n\n// Note: On Windows, URLs look like this: file:///D:/dev/@TypeStrong/ts-node-examples/foo.ts\n\n// NOTE ABOUT MULTIPLE EXPERIMENTAL LOADER APIS\n//\n// At the time of writing, this file implements 2x different loader APIs.\n// Node made a breaking change to the loader API in https://github.com/nodejs/node/pull/37468\n//\n// We check the node version number and export either the *old* or the *new* API.\n//\n// Today, we are implementing the *new* API on top of our implementation of the *old* API,\n// which relies on copy-pasted code from the *old* hooks implementation in node.\n//\n// In the future, we will likely invert this: we will copy-paste the *new* API implementation\n// from node, build our implementation of the *new* API on top of it, and implement the *old*\n// hooks API as a shim to the *new* API.\n\nexport interface NodeLoaderHooksAPI1 {\n  resolve: NodeLoaderHooksAPI1.ResolveHook;\n  getFormat: NodeLoaderHooksAPI1.GetFormatHook;\n  transformSource: NodeLoaderHooksAPI1.TransformSourceHook;\n}\nexport namespace NodeLoaderHooksAPI1 {\n  export type ResolveHook = NodeLoaderHooksAPI2.ResolveHook;\n  export type GetFormatHook = (\n    url: string,\n    context: {},\n    defaultGetFormat: GetFormatHook\n  ) => Promise<{ format: NodeLoaderHooksFormat }>;\n  export type TransformSourceHook = (\n    source: string | Buffer,\n    context: { url: string; format: NodeLoaderHooksFormat },\n    defaultTransformSource: NodeLoaderHooksAPI1.TransformSourceHook\n  ) => Promise<{ source: string | Buffer }>;\n}\n\nexport interface NodeLoaderHooksAPI2 {\n  resolve: NodeLoaderHooksAPI2.ResolveHook;\n  load: NodeLoaderHooksAPI2.LoadHook;\n}\nexport namespace NodeLoaderHooksAPI2 {\n  export type ResolveHook = (\n    specifier: string,\n    context: {\n      conditions?: NodeImportConditions;\n      importAssertions?: NodeImportAssertions;\n      parentURL: string;\n    },\n    defaultResolve: ResolveHook\n  ) => Promise<{ url: string }>;\n  export type LoadHook = (\n    url: string,\n    context: {\n      format: NodeLoaderHooksFormat | null | undefined;\n      importAssertions?: NodeImportAssertions;\n    },\n    defaultLoad: NodeLoaderHooksAPI2['load']\n  ) => Promise<{\n    format: NodeLoaderHooksFormat;\n    source: string | Buffer | undefined;\n  }>;\n  export type NodeImportConditions = unknown;\n  export interface NodeImportAssertions {\n    type?: 'json';\n  }\n}\n\nexport type NodeLoaderHooksFormat =\n  | 'builtin'\n  | 'commonjs'\n  | 'dynamic'\n  | 'json'\n  | 'module'\n  | 'wasm';\n\n/** @internal */\nexport function registerAndCreateEsmHooks(opts?: RegisterOptions) {\n  // Automatically performs registration just like `-r ts-node/register`\n  const tsNodeInstance = register(opts);\n\n  return createEsmHooks(tsNodeInstance);\n}\n\nexport function createEsmHooks(tsNodeService: Service) {\n  tsNodeService.enableExperimentalEsmLoaderInterop();\n\n  // Custom implementation that considers additional file extensions and automatically adds file extensions\n  const nodeResolveImplementation = createResolve({\n    ...getExtensions(tsNodeService.config),\n    preferTsExts: tsNodeService.options.preferTsExts,\n  });\n\n  // The hooks API changed in node version X so we need to check for backwards compatibility.\n  // TODO: When the new API is backported to v12, v14, update these version checks accordingly.\n  const newHooksAPI =\n    versionGteLt(process.versions.node, '17.0.0') ||\n    versionGteLt(process.versions.node, '16.12.0', '17.0.0') ||\n    versionGteLt(process.versions.node, '14.999.999', '15.0.0') ||\n    versionGteLt(process.versions.node, '12.999.999', '13.0.0');\n\n  // Explicit return type to avoid TS's non-ideal inferred type\n  const hooksAPI: NodeLoaderHooksAPI1 | NodeLoaderHooksAPI2 = newHooksAPI\n    ? { resolve, load, getFormat: undefined, transformSource: undefined }\n    : { resolve, getFormat, transformSource, load: undefined };\n  return hooksAPI;\n\n  function isFileUrlOrNodeStyleSpecifier(parsed: UrlWithStringQuery) {\n    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n    const { protocol } = parsed;\n    return protocol === null || protocol === 'file:';\n  }\n\n  async function resolve(\n    specifier: string,\n    context: { parentURL: string },\n    defaultResolve: typeof resolve\n  ): Promise<{ url: string }> {\n    const defer = async () => {\n      const r = await defaultResolve(specifier, context, defaultResolve);\n      return r;\n    };\n\n    const parsed = parseUrl(specifier);\n    const { pathname, protocol, hostname } = parsed;\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n\n    if (protocol !== null && protocol !== 'file:') {\n      return defer();\n    }\n\n    // Malformed file:// URL?  We should always see `null` or `''`\n    if (hostname) {\n      // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n      return defer();\n    }\n\n    // pathname is the path to be resolved\n\n    return nodeResolveImplementation.defaultResolve(\n      specifier,\n      context,\n      defaultResolve\n    );\n  }\n\n  // `load` from new loader hook API (See description at the top of this file)\n  async function load(\n    url: string,\n    context: {\n      format: NodeLoaderHooksFormat | null | undefined;\n      importAssertions?: NodeLoaderHooksAPI2.NodeImportAssertions;\n    },\n    defaultLoad: typeof load\n  ): Promise<{\n    format: NodeLoaderHooksFormat;\n    source: string | Buffer | undefined;\n  }> {\n    // If we get a format hint from resolve() on the context then use it\n    // otherwise call the old getFormat() hook using node's old built-in defaultGetFormat() that ships with ts-node\n    const format =\n      context.format ??\n      (await getFormat(url, context, defaultGetFormat)).format;\n\n    let source = undefined;\n    if (format !== 'builtin' && format !== 'commonjs') {\n      // Call the new defaultLoad() to get the source\n      const { source: rawSource } = await defaultLoad(\n        url,\n        {\n          ...context,\n          format,\n        },\n        defaultLoad\n      );\n\n      if (rawSource === undefined || rawSource === null) {\n        throw new Error(\n          `Failed to load raw source: Format was '${format}' and url was '${url}''.`\n        );\n      }\n\n      // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook\n      const defaultTransformSource: typeof transformSource = async (\n        source,\n        _context,\n        _defaultTransformSource\n      ) => ({ source });\n\n      // Call the old hook\n      const { source: transformedSource } = await transformSource(\n        rawSource,\n        { url, format },\n        defaultTransformSource\n      );\n      source = transformedSource;\n    }\n\n    return { format, source };\n  }\n\n  async function getFormat(\n    url: string,\n    context: {},\n    defaultGetFormat: typeof getFormat\n  ): Promise<{ format: NodeLoaderHooksFormat }> {\n    const defer = (overrideUrl: string = url) =>\n      defaultGetFormat(overrideUrl, context, defaultGetFormat);\n\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n\n    const { pathname } = parsed;\n    assert(\n      pathname !== null,\n      'ESM getFormat() hook: URL should never have null pathname'\n    );\n\n    const nativePath = fileURLToPath(url);\n\n    // If file has .ts, .tsx, or .jsx extension, then ask node how it would treat this file if it were .js\n    const ext = extname(nativePath);\n    let nodeSays: { format: NodeLoaderHooksFormat };\n    if (ext !== '.js' && !tsNodeService.ignored(nativePath)) {\n      nodeSays = await defer(formatUrl(pathToFileURL(nativePath + '.js')));\n    } else {\n      nodeSays = await defer();\n    }\n    // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n    if (\n      !tsNodeService.ignored(nativePath) &&\n      (nodeSays.format === 'commonjs' || nodeSays.format === 'module')\n    ) {\n      const { moduleType } = tsNodeService.moduleTypeClassifier.classifyModule(\n        normalizeSlashes(nativePath)\n      );\n      if (moduleType === 'cjs') {\n        return { format: 'commonjs' };\n      } else if (moduleType === 'esm') {\n        return { format: 'module' };\n      }\n    }\n    return nodeSays;\n  }\n\n  async function transformSource(\n    source: string | Buffer,\n    context: { url: string; format: NodeLoaderHooksFormat },\n    defaultTransformSource: typeof transformSource\n  ): Promise<{ source: string | Buffer }> {\n    if (source === null || source === undefined) {\n      throw new Error('No source');\n    }\n\n    const defer = () =>\n      defaultTransformSource(source, context, defaultTransformSource);\n\n    const sourceAsString =\n      typeof source === 'string' ? source : source.toString('utf8');\n\n    const { url } = context;\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n    const nativePath = fileURLToPath(url);\n\n    if (tsNodeService.ignored(nativePath)) {\n      return defer();\n    }\n\n    const emittedJs = tsNodeService.compile(sourceAsString, nativePath);\n\n    return { source: emittedJs };\n  }\n}\n"]}