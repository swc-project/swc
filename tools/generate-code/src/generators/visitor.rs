use inflector::Inflector;
use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{
    parse_quote, Arm, Attribute, Expr, Field, Fields, File, GenericArgument, Ident, Item, Lit,
    LitInt, PathArguments, Stmt, TraitItem, Type,
};

pub fn generate(crate_name: &Ident, node_types: &[&Item]) -> File {
    let mut output = File {
        shebang: None,
        attrs: Vec::new(),
        items: Vec::new(),
    };

    output.attrs.push(parse_quote!(
        //! This file is generated by `tools/generate-code`. DO NOT MODIFY.
    ));

    output.items.push(parse_quote!(
        use #crate_name::*;
    ));

    for &kind in [TraitKind::Visit, TraitKind::VisitMut, TraitKind::Fold].iter() {
        for &variant in [Variant::Normal, Variant::AstPath].iter() {
            let g = Generator {
                crate_name: crate_name.clone(),
                kind,
                variant,
            };

            output.items.push(g.declare_visit_trait(node_types));

            output.items.extend(g.declare_visit_with_trait(node_types));

            output
                .items
                .extend(g.implement_visit_with_for_types(node_types));
        }
    }

    output.items.push(parse_quote!(
        #[cfg(feature = "path")]
        pub type AstKindPath = swc_visit::AstKindPath<AstParentKind>;
    ));
    output.items.push(parse_quote!(
        #[cfg(feature = "path")]
        pub type AstNodePath<'ast> = swc_visit::AstNodePath<AstParentNodeRef<'ast>>;
    ));
    output.items.extend(define_fields(node_types));

    output
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum TraitKind {
    Visit,
    VisitMut,
    Fold,
}

impl TraitKind {
    pub fn method_prefix(self) -> &'static str {
        match self {
            TraitKind::Visit => "visit",
            TraitKind::VisitMut => "visit_mut",
            TraitKind::Fold => "fold",
        }
    }

    pub fn trait_prefix(self) -> &'static str {
        match self {
            TraitKind::Visit => "Visit",
            TraitKind::VisitMut => "VisitMut",
            TraitKind::Fold => "Fold",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Variant {
    Normal,
    AstPath,
}

impl Variant {
    pub fn method_suffix(self, is_visitor_method: bool) -> &'static str {
        if self == Variant::Normal || is_visitor_method {
            ""
        } else {
            "_ast_path"
        }
    }
}

struct Generator {
    crate_name: Ident,
    kind: TraitKind,
    variant: Variant,
}

impl Generator {
    fn method_lifetime(&self) -> TokenStream {
        match self.kind {
            TraitKind::Visit => match self.variant {
                Variant::Normal => quote!(),
                Variant::AstPath => quote!(<'ast: 'r, 'r>),
            },
            TraitKind::VisitMut => quote!(),
            TraitKind::Fold => quote!(),
        }
    }

    fn parameter_type_token(&self, ty: TokenStream) -> TokenStream {
        match self.kind {
            TraitKind::Visit => match self.variant {
                Variant::Normal => quote!(&#ty),
                Variant::AstPath => quote!(&'ast #ty),
            },
            TraitKind::VisitMut => quote!(&mut #ty),
            TraitKind::Fold => ty,
        }
    }

    /// This includes `->`
    fn return_type_token(&self, ty: TokenStream) -> TokenStream {
        match self.kind {
            TraitKind::Visit => quote!(),
            TraitKind::VisitMut => quote!(),
            TraitKind::Fold => quote!(-> #ty),
        }
    }

    fn arg_extra_token(&self) -> TokenStream {
        match self.variant {
            Variant::Normal => quote!(),
            Variant::AstPath => quote!(, ast_path),
        }
    }

    fn param_extra_token(&self) -> TokenStream {
        match self.variant {
            Variant::Normal => quote!(),
            Variant::AstPath => match self.kind {
                TraitKind::Visit => {
                    quote!(, ast_path: &mut AstNodePath<'r>)
                }
                TraitKind::VisitMut | TraitKind::Fold => quote!(, ast_path: &mut AstKindPath),
            },
        }
    }

    fn trait_name(&self, with: bool) -> Ident {
        let name = self.kind.trait_prefix();

        let name = if with {
            format!("{}With", name)
        } else {
            name.to_string()
        };

        match self.variant {
            Variant::Normal => Ident::new(&name, Span::call_site()),
            Variant::AstPath => Ident::new(&format!("{}AstPath", name), Span::call_site()),
        }
    }

    fn base_trait_attrs(&self) -> Vec<Attribute> {
        let mut attrs = vec![];

        if self.variant == Variant::AstPath {
            attrs.push(parse_quote!(#[cfg(any(docsrs, feature = "path"))]));
            attrs.push(parse_quote!(#[cfg_attr(docsrs, doc(cfg(feature = "path")))]));
        }

        attrs
    }

    fn visit_method_name(&self, with: bool) -> Ident {
        let name = self.kind.method_prefix();

        let name = if with {
            format!("{}_with", name)
        } else {
            name.to_string()
        };

        if self.variant == Variant::AstPath {
            Ident::new(&format!("{}_ast_path", name), Span::call_site())
        } else {
            Ident::new(&name, Span::call_site())
        }
    }

    fn declare_visit_trait(&self, node_types: &[&Item]) -> Item {
        let lifetime = self.method_lifetime();
        let ast_path_arg = self.arg_extra_token();
        let ast_path_params = self.param_extra_token();
        let with_trait_name = self.trait_name(true);
        let trait_name = self.trait_name(false);
        let attrs = self.base_trait_attrs();
        let mut trait_methods: Vec<TraitItem> = vec![];

        for ty in node_types {
            let type_name = match ty {
                Item::Enum(data) => data.ident.clone(),
                Item::Struct(data) => data.ident.clone(),
                _ => continue,
            };

            let return_type = self.return_type_token(quote!(#type_name));
            let type_param = self.parameter_type_token(quote!(#type_name));

            let visit_method_name = Ident::new(
                &format!(
                    "{}_{}{}",
                    self.kind.method_prefix(),
                    type_name.to_string().to_snake_case(),
                    self.variant.method_suffix(true)
                ),
                Span::call_site(),
            );
            let visit_with_children_name = Ident::new(
                &format!(
                    "{}_children_with{}",
                    self.kind.method_prefix(),
                    self.variant.method_suffix(false)
                ),
                Span::call_site(),
            );

            let method_doc = doc(&format!(
                "Visit a node of type `{}`.\n\nBy default, this method calls \
                 [`{type_name}::{visit_with_children_name}`]. If you want to recurse, you need to \
                 call it manually.",
                type_name
            ));

            trait_methods.push(parse_quote!(
                #method_doc
                fn #visit_method_name #lifetime (&mut self, node: #type_param #ast_path_params) #return_type {
                    <#type_name as #with_trait_name>::#visit_with_children_name(node, self #ast_path_arg)
                }
            ));
        }

        parse_quote! {
            /// A visitor trait for traversing the AST.
            #(#attrs)*
            pub trait #trait_name {
                #(#trait_methods)*
            }
        }
    }

    fn declare_visit_with_trait(&self, node_types: &[&Item]) -> Vec<Item> {
        let visitor_trait_name = self.trait_name(false);
        let trait_name = self.trait_name(true);
        let attrs = self.base_trait_attrs();
        let mut visit_with_trait_methods: Vec<TraitItem> = vec![];

        {
            let lifetime = self.method_lifetime();
            let ast_path_extra = self.param_extra_token();
            let return_type = self.return_type_token(quote!(Self));
            let receiver = self.parameter_type_token(quote!(self));

            let visit_with_name = Ident::new(
                &format!(
                    "{}_with{}",
                    self.kind.method_prefix(),
                    self.variant.method_suffix(false)
                ),
                Span::call_site(),
            );
            let visit_with_children_name = Ident::new(
                &format!(
                    "{}_children_with{}",
                    self.kind.method_prefix(),
                    self.variant.method_suffix(false)
                ),
                Span::call_site(),
            );

            visit_with_trait_methods.push(parse_quote!(
                /// Calls a visitor method (visitor.fold_xxx) with self.
                fn #visit_with_name #lifetime (#receiver, visitor: &mut V #ast_path_extra) #return_type;
            ));

            visit_with_trait_methods.push(parse_quote!(
            /// Visit children nodes of `self`` with `visitor`.
            fn #visit_with_children_name #lifetime (#receiver, visitor: &mut V #ast_path_extra) #return_type;
        ));
        }

        let mut items: Vec<Item> = vec![];
        items.push(parse_quote!(
            /// A trait implemented for types that can be visited using a visitor.
            #(#attrs)*
            pub trait #trait_name<V: ?Sized + #visitor_trait_name> {
                #(#visit_with_trait_methods)*
            }
        ));

        items
    }

    fn implement_visit_with_for_types(&self, node_types: &[&Item]) -> Vec<Item> {
        let visitor_trait_name = self.trait_name(false);
        let trait_name = self.trait_name(true);
        let attrs = self.base_trait_attrs();

        let mut items: Vec<Item> = vec![];

        for node_type in node_types {
            let type_name = match node_type {
                Item::Enum(data) => data.ident.clone(),
                Item::Struct(data) => data.ident.clone(),
                _ => continue,
            };

            let lifetime = self.method_lifetime();
            let ast_path_arg = self.arg_extra_token();
            let ast_path_param = self.param_extra_token();
            let return_type = self.return_type_token(quote!(Self));

            let receiver = self.parameter_type_token(quote!(self));
            let visit_with_name = Ident::new(
                &format!(
                    "{}_with{}",
                    self.kind.method_prefix(),
                    self.variant.method_suffix(false)
                ),
                Span::call_site(),
            );
            let visit_with_children_name = Ident::new(
                &format!(
                    "{}_children_with{}",
                    self.kind.method_prefix(),
                    self.variant.method_suffix(false)
                ),
                Span::call_site(),
            );

            let visit_method_name = Ident::new(
                &format!(
                    "{}_{}{}",
                    self.kind.method_prefix(),
                    type_name.to_string().to_snake_case(),
                    self.variant.method_suffix(true)
                ),
                Span::call_site(),
            );

            let visit_with_doc = doc(&format!(
                "Calls [{visitor_trait_name}`::{}`] with `self`.",
                visit_method_name
            ));

            let default_body: Expr = match node_type {
                Item::Enum(data) => {
                    let name = &data.ident;
                    let mut match_arms = vec![];

                    for v in &data.variants {
                        let variant_name = &v.ident;

                        match_arms
                            .push(self.default_visit_body(quote!(#name::#variant_name), &v.fields));
                    }

                    parse_quote!(match self { #(#match_arms)* })
                }
                Item::Struct(data) => {
                    let name = &data.ident;

                    let arm = self.default_visit_body(quote!(#name), &data.fields);

                    parse_quote!(match self { #arm })
                }
                _ => continue,
            };

            items.push(parse_quote!(
                #(#attrs)*
                impl<V: ?Sized + #visitor_trait_name> #trait_name<V> for #type_name {
                    #visit_with_doc
                    fn #visit_with_name #lifetime (#receiver, visitor: &mut V #ast_path_param) #return_type {
                        <V as #visitor_trait_name>::#visit_method_name(visitor, self #ast_path_arg)
                    }

                    fn #visit_with_children_name #lifetime (#receiver, visitor: &mut V #ast_path_param) #return_type {
                        #default_body
                    }
                }
            )
        );
        }

        items
    }

    fn default_visit_body(&self, path: TokenStream, fields: &Fields) -> Arm {
        let ast_path_arg = self.arg_extra_token();

        let with_visitor_trait_name = self.trait_name(true);
        let visit_with_children_name = Ident::new(
            &format!(
                "{}_children_with{}",
                self.kind.method_prefix(),
                self.variant.method_suffix(false)
            ),
            Span::call_site(),
        );

        match fields {
            Fields::Named(n) => {
                let mut stmts: Vec<Stmt> = vec![];
                let mut bindings = vec![];
                let mut reconstruct = match self.kind {
                    TraitKind::Visit | TraitKind::VisitMut => None,
                    TraitKind::Fold => Some(Vec::<TokenStream>::new()),
                };

                for field in &n.named {
                    let field_name = field.ident.as_ref().unwrap();
                    let ty = &field.ty;

                    bindings.push(field_name.clone());

                    if let Some(reconstructor) = &mut reconstruct {
                        stmts.push(parse_quote!(
                            let #field_name = <#ty as #with_visitor_trait_name<V>>::#visit_with_children_name(#field_name, visitor #ast_path_arg);
                        ));

                        reconstructor.push(parse_quote!(#field_name));
                    } else {
                        stmts.push(parse_quote!(
                            <#ty as #with_visitor_trait_name<V>>::#visit_with_children_name(#field_name, visitor #ast_path_arg);
                        ));
                    }
                }

                match self.kind {
                    TraitKind::Visit | TraitKind::VisitMut => {
                        parse_quote!(#path { #(#bindings),* } => {
                            #(#stmts)*
                        })
                    }
                    TraitKind::Fold => {
                        let reconstruct = reconstruct.unwrap();

                        parse_quote!(#path { #(#bindings),* } => {
                            #(#stmts)*

                            #path {
                                #(#reconstruct),*
                            }
                        })
                    }
                }
            }
            Fields::Unnamed(u) => {
                let mut stmts: Vec<Stmt> = vec![];
                let mut bindings = Vec::<TokenStream>::new();
                let mut reconstruct = match self.kind {
                    TraitKind::Visit | TraitKind::VisitMut => None,
                    TraitKind::Fold => Some(Vec::<TokenStream>::new()),
                };

                for (idx, field) in u.unnamed.iter().enumerate() {
                    let field_name = Ident::new(&format!("_field_{}", idx), Span::call_site());
                    let ty = &field.ty;
                    let binding_idx = Lit::Int(LitInt::new(&idx.to_string(), Span::call_site()));
                    bindings.push(parse_quote!(#binding_idx: #field_name));

                    if let Some(reconstructor) = &mut reconstruct {
                        stmts.push(parse_quote!(
                            let #field_name = <#ty as #with_visitor_trait_name<V>>::#visit_with_children_name(#field_name, visitor #ast_path_arg);
                        ));

                        reconstructor.push(parse_quote!(#binding_idx: self.#field_name));
                    } else {
                        stmts.push(parse_quote!(
                            <#ty as #with_visitor_trait_name<V>>::#visit_with_children_name(#field_name, visitor #ast_path_arg);
                        ));
                    }
                }

                match self.kind {
                    TraitKind::Visit | TraitKind::VisitMut => {
                        parse_quote!(#path { #(#bindings),* }=> {
                            #(#stmts)*
                        })
                    }
                    TraitKind::Fold => {
                        let reconstruct = reconstruct.unwrap();

                        parse_quote!(#path { #(#bindings),* } => {
                            #(#stmts)*

                            #path{#(#reconstruct),*}
                        })
                    }
                }
            }
            Fields::Unit => {
                parse_quote!(#path => {},)
            }
        }
    }
}

fn doc(s: &str) -> Attribute {
    parse_quote!(#[doc = #s])
}

fn field_variant(type_name: &Ident, field: &Field) -> Option<TokenStream> {
    if let Some(field_name) = &field.ident {
        let variant_name = Ident::new(&field_name.to_string().to_pascal_case(), Span::call_site());
        let variant_doc = doc(&format!("Represents [`{type_name}::{field_name}`]"));

        if let Some(ty) = extract_vec(&field.ty) {
            return Some(quote!(
                #variant_doc
                #variant_name(usize)
            ));
        }

        return Some(quote!(
            #variant_doc
            #variant_name
        ));
    }

    None
}

fn extract_vec(ty: &Type) -> Option<&Type> {
    extract_generic("Vec", ty)
}

fn extract_generic<'a>(name: &str, ty: &'a Type) -> Option<&'a Type> {
    if let Type::Path(p) = ty {
        let last = p.path.segments.last().unwrap();

        if !last.arguments.is_empty() && last.ident == name {
            match &last.arguments {
                PathArguments::AngleBracketed(tps) => {
                    let arg = tps.args.first().unwrap();

                    match arg {
                        GenericArgument::Type(arg) => return Some(arg),
                        _ => unimplemented!("generic parameter other than type"),
                    }
                }
                _ => unimplemented!("Box() -> T or Box without a type parameter"),
            }
        }
    }

    if let Type::Reference(r) = ty {
        return extract_generic(name, &r.elem);
    }

    None
}
fn define_fields(node_types: &[&Item]) -> Vec<Item> {
    let mut items = Vec::<Item>::new();

    {
        let mut defs = Vec::<Item>::new();

        for ty in node_types {
            let type_name = match ty {
                Item::Enum(data) => data.ident.clone(),
                Item::Struct(data) => data.ident.clone(),
                _ => continue,
            };

            let enum_name = Ident::new(&format!("{type_name}Field"), Span::call_site());

            let mut variants = vec![];

            match ty {
                Item::Enum(data) => {
                    for variant in &data.variants {
                        let orig_ident = &variant.ident;
                        let variant_name = Ident::new(
                            &variant.ident.to_string().to_pascal_case(),
                            Span::call_site(),
                        );

                        let variant_doc = doc(&format!("Represents [`{type_name}::{orig_ident}`]"));
                        variants.push(quote!(
                            #variant_doc
                            #variant_name
                        ));
                    }
                }
                Item::Struct(data) => {
                    for field in &data.fields {
                        variants.extend(field_variant(&type_name, field));
                    }
                }
                _ => continue,
            }

            defs.push(parse_quote!(
                #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
                pub enum #enum_name {
                    #(#variants),*
                }
            ))
        }

        items.push(parse_quote!(
            #[cfg(feature = "path")]
            pub mod fields {
                #(#defs)*
            }
        ));
    }

    items
}
