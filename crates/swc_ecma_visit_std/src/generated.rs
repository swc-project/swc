#![doc = r" This file is generated by `tools/generate-code`. DO NOT MODIFY."]
#![allow(unused_variables)]
#![allow(clippy::all)]
pub use ::swc_visit::All;
use swc_ecma_ast::*;
#[doc = r" A visitor trait for traversing the AST."]
pub trait Visit {
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_array_lit(&mut self, node: &ArrayLit) {
        <ArrayLit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_array_pat(&mut self, node: &ArrayPat) {
        <ArrayPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        <ArrowExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        <AssignExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_assign_op(&mut self, node: &AssignOp) {
        <AssignOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_assign_pat(&mut self, node: &AssignPat) {
        <AssignPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        <AssignPatProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_assign_prop(&mut self, node: &AssignProp) {
        <AssignProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_assign_target(&mut self, node: &AssignTarget) {
        <AssignTarget as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        <AssignTargetPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        <swc_atoms::Atom as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        <AutoAccessor as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        <AwaitExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_big_int(&mut self, node: &BigInt) {
        <BigInt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        <BigIntValue as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_bin_expr(&mut self, node: &BinExpr) {
        <BinExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_binary_op(&mut self, node: &BinaryOp) {
        <BinaryOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        <BindingIdent as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        <BlockStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        <BlockStmtOrExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_bool(&mut self, node: &Bool) {
        <Bool as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        <BreakStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_call_expr(&mut self, node: &CallExpr) {
        <CallExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_callee(&mut self, node: &Callee) {
        <Callee as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_catch_clause(&mut self, node: &CatchClause) {
        <CatchClause as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_class(&mut self, node: &Class) {
        <Class as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_decl(&mut self, node: &ClassDecl) {
        <ClassDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_expr(&mut self, node: &ClassExpr) {
        <ClassExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_member(&mut self, node: &ClassMember) {
        <ClassMember as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_members(&mut self, node: &[ClassMember]) {
        <[ClassMember] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_method(&mut self, node: &ClassMethod) {
        <ClassMethod as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_prop(&mut self, node: &ClassProp) {
        <ClassProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        <ComputedPropName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_cond_expr(&mut self, node: &CondExpr) {
        <CondExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_constructor(&mut self, node: &Constructor) {
        <Constructor as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        <ContinueStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        <DebuggerStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_decl(&mut self, node: &Decl) {
        <Decl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_decorator(&mut self, node: &Decorator) {
        <Decorator as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_decorators(&mut self, node: &[Decorator]) {
        <[Decorator] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        <DefaultDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        <DoWhileStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        <EmptyStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_export_all(&mut self, node: &ExportAll) {
        <ExportAll as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_export_decl(&mut self, node: &ExportDecl) {
        <ExportDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        <ExportDefaultDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        <ExportDefaultExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        <ExportDefaultSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        <ExportNamedSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        <ExportNamespaceSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        <ExportSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        <[ExportSpecifier] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_expr(&mut self, node: &Expr) {
        <Expr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        <ExprOrSpread as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        <[ExprOrSpread] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        <ExprStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        <[Box<Expr>] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_fn_decl(&mut self, node: &FnDecl) {
        <FnDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_fn_expr(&mut self, node: &FnExpr) {
        <FnExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_for_head(&mut self, node: &ForHead) {
        <ForHead as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        <ForInStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        <ForOfStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_for_stmt(&mut self, node: &ForStmt) {
        <ForStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_function(&mut self, node: &Function) {
        <Function as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_getter_prop(&mut self, node: &GetterProp) {
        <GetterProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_ident(&mut self, node: &Ident) {
        <Ident as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_ident_name(&mut self, node: &IdentName) {
        <IdentName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_if_stmt(&mut self, node: &IfStmt) {
        <IfStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_import(&mut self, node: &Import) {
        <Import as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_import_decl(&mut self, node: &ImportDecl) {
        <ImportDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        <ImportDefaultSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        <ImportNamedSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_import_phase(&mut self, node: &ImportPhase) {
        <ImportPhase as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        <ImportSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        <[ImportSpecifier] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        <ImportStarAsSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_import_with(&mut self, node: &ImportWith) {
        <ImportWith as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        <ImportWithItem as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        <[ImportWithItem] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_invalid(&mut self, node: &Invalid) {
        <Invalid as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        <JSXAttr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        <JSXAttrName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        <JSXAttrOrSpread as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        <[JSXAttrOrSpread] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        <JSXAttrValue as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        <JSXClosingElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        <JSXClosingFragment as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_element(&mut self, node: &JSXElement) {
        <JSXElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        <JSXElementChild as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        <[JSXElementChild] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        <JSXElementName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        <JSXEmptyExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        <JSXExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        <JSXExprContainer as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        <JSXFragment as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        <JSXMemberExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        <JSXNamespacedName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_object(&mut self, node: &JSXObject) {
        <JSXObject as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        <JSXOpeningElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        <JSXOpeningFragment as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        <JSXSpreadChild as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_jsx_text(&mut self, node: &JSXText) {
        <JSXText as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_key(&mut self, node: &Key) {
        <Key as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        <KeyValuePatProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        <KeyValueProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        <LabeledStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_lit(&mut self, node: &Lit) {
        <Lit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_member_expr(&mut self, node: &MemberExpr) {
        <MemberExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_member_prop(&mut self, node: &MemberProp) {
        <MemberProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        <MetaPropExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        <MetaPropKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_method_kind(&mut self, node: &MethodKind) {
        <MethodKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_method_prop(&mut self, node: &MethodProp) {
        <MethodProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_module(&mut self, node: &Module) {
        <Module as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        <ModuleDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        <ModuleExportName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_module_item(&mut self, node: &ModuleItem) {
        <ModuleItem as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        <[ModuleItem] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_named_export(&mut self, node: &NamedExport) {
        <NamedExport as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_new_expr(&mut self, node: &NewExpr) {
        <NewExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_null(&mut self, node: &Null) {
        <Null as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_number(&mut self, node: &Number) {
        <Number as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_object_lit(&mut self, node: &ObjectLit) {
        <ObjectLit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_object_pat(&mut self, node: &ObjectPat) {
        <ObjectPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        <ObjectPatProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        <[ObjectPatProp] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        <Option<swc_atoms::Atom> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        <Option<BlockStmt> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_opt_call(&mut self, node: &OptCall) {
        <OptCall as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        <Option<CatchClause> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        <OptChainBase as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        <OptChainExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        <Option<Box<Expr>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        <Option<ExprOrSpread> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        <Option<Vec<ExprOrSpread>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        <Option<Ident> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        <Option<JSXAttrValue> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        <Option<JSXClosingElement> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        <Option<ModuleExportName> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        <Option<Box<ObjectLit>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        <Option<Pat> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_children_with`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        <Option<swc_common::Span> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        <Option<Box<Stmt>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        <Option<Box<Str>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        <Option<VarDeclOrExpr> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        <[Option<ExprOrSpread>] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        <[Option<Pat>] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_param(&mut self, node: &Param) {
        <Param as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        <ParamOrTsParamProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        <[ParamOrTsParamProp] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_params(&mut self, node: &[Param]) {
        <[Param] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        <ParenExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_pat(&mut self, node: &Pat) {
        <Pat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_pats(&mut self, node: &[Pat]) {
        <[Pat] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_private_method(&mut self, node: &PrivateMethod) {
        <PrivateMethod as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_private_name(&mut self, node: &PrivateName) {
        <PrivateName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_private_prop(&mut self, node: &PrivateProp) {
        <PrivateProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_program(&mut self, node: &Program) {
        <Program as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_prop(&mut self, node: &Prop) {
        <Prop as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_prop_name(&mut self, node: &PropName) {
        <PropName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        <PropOrSpread as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        <[PropOrSpread] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_regex(&mut self, node: &Regex) {
        <Regex as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_rest_pat(&mut self, node: &RestPat) {
        <RestPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        <ReturnStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_script(&mut self, node: &Script) {
        <Script as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        <SeqExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_setter_prop(&mut self, node: &SetterProp) {
        <SetterProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        <SimpleAssignTarget as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        <swc_common::Span as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_spread_element(&mut self, node: &SpreadElement) {
        <SpreadElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_static_block(&mut self, node: &StaticBlock) {
        <StaticBlock as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_stmt(&mut self, node: &Stmt) {
        <Stmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_stmts(&mut self, node: &[Stmt]) {
        <[Stmt] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_str(&mut self, node: &Str) {
        <Str as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_super(&mut self, node: &Super) {
        <Super as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_super_prop(&mut self, node: &SuperProp) {
        <SuperProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        <SuperPropExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_switch_case(&mut self, node: &SwitchCase) {
        <SwitchCase as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        <[SwitchCase] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        <SwitchStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        <swc_common::SyntaxContext as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        <TaggedTpl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_this_expr(&mut self, node: &ThisExpr) {
        <ThisExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        <ThrowStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_tpl(&mut self, node: &Tpl) {
        <Tpl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_tpl_element(&mut self, node: &TplElement) {
        <TplElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        <[TplElement] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        <TruePlusMinus as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_try_stmt(&mut self, node: &TryStmt) {
        <TryStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        <UnaryExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_unary_op(&mut self, node: &UnaryOp) {
        <UnaryOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        <UpdateExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_update_op(&mut self, node: &UpdateOp) {
        <UpdateOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_using_decl(&mut self, node: &UsingDecl) {
        <UsingDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_var_decl(&mut self, node: &VarDecl) {
        <VarDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        <VarDeclKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        <VarDeclOrExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        <VarDeclarator as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        <[VarDeclarator] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        <WhileStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_with_stmt(&mut self, node: &WithStmt) {
        <WithStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        <YieldExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
}
impl<V> Visit for &mut V
where
    V: ?Sized + Visit,
{
    #[inline]
    fn visit_array_lit(&mut self, node: &ArrayLit) {
        <V as Visit>::visit_array_lit(&mut **self, node)
    }

    #[inline]
    fn visit_array_pat(&mut self, node: &ArrayPat) {
        <V as Visit>::visit_array_pat(&mut **self, node)
    }

    #[inline]
    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        <V as Visit>::visit_arrow_expr(&mut **self, node)
    }

    #[inline]
    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        <V as Visit>::visit_assign_expr(&mut **self, node)
    }

    #[inline]
    fn visit_assign_op(&mut self, node: &AssignOp) {
        <V as Visit>::visit_assign_op(&mut **self, node)
    }

    #[inline]
    fn visit_assign_pat(&mut self, node: &AssignPat) {
        <V as Visit>::visit_assign_pat(&mut **self, node)
    }

    #[inline]
    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        <V as Visit>::visit_assign_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_assign_prop(&mut self, node: &AssignProp) {
        <V as Visit>::visit_assign_prop(&mut **self, node)
    }

    #[inline]
    fn visit_assign_target(&mut self, node: &AssignTarget) {
        <V as Visit>::visit_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        <V as Visit>::visit_assign_target_pat(&mut **self, node)
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        <V as Visit>::visit_atom(&mut **self, node)
    }

    #[inline]
    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        <V as Visit>::visit_auto_accessor(&mut **self, node)
    }

    #[inline]
    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        <V as Visit>::visit_await_expr(&mut **self, node)
    }

    #[inline]
    fn visit_big_int(&mut self, node: &BigInt) {
        <V as Visit>::visit_big_int(&mut **self, node)
    }

    #[inline]
    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        <V as Visit>::visit_big_int_value(&mut **self, node)
    }

    #[inline]
    fn visit_bin_expr(&mut self, node: &BinExpr) {
        <V as Visit>::visit_bin_expr(&mut **self, node)
    }

    #[inline]
    fn visit_binary_op(&mut self, node: &BinaryOp) {
        <V as Visit>::visit_binary_op(&mut **self, node)
    }

    #[inline]
    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        <V as Visit>::visit_binding_ident(&mut **self, node)
    }

    #[inline]
    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        <V as Visit>::visit_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        <V as Visit>::visit_block_stmt_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_bool(&mut self, node: &Bool) {
        <V as Visit>::visit_bool(&mut **self, node)
    }

    #[inline]
    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        <V as Visit>::visit_break_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_call_expr(&mut self, node: &CallExpr) {
        <V as Visit>::visit_call_expr(&mut **self, node)
    }

    #[inline]
    fn visit_callee(&mut self, node: &Callee) {
        <V as Visit>::visit_callee(&mut **self, node)
    }

    #[inline]
    fn visit_catch_clause(&mut self, node: &CatchClause) {
        <V as Visit>::visit_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_class(&mut self, node: &Class) {
        <V as Visit>::visit_class(&mut **self, node)
    }

    #[inline]
    fn visit_class_decl(&mut self, node: &ClassDecl) {
        <V as Visit>::visit_class_decl(&mut **self, node)
    }

    #[inline]
    fn visit_class_expr(&mut self, node: &ClassExpr) {
        <V as Visit>::visit_class_expr(&mut **self, node)
    }

    #[inline]
    fn visit_class_member(&mut self, node: &ClassMember) {
        <V as Visit>::visit_class_member(&mut **self, node)
    }

    #[inline]
    fn visit_class_members(&mut self, node: &[ClassMember]) {
        <V as Visit>::visit_class_members(&mut **self, node)
    }

    #[inline]
    fn visit_class_method(&mut self, node: &ClassMethod) {
        <V as Visit>::visit_class_method(&mut **self, node)
    }

    #[inline]
    fn visit_class_prop(&mut self, node: &ClassProp) {
        <V as Visit>::visit_class_prop(&mut **self, node)
    }

    #[inline]
    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        <V as Visit>::visit_computed_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_cond_expr(&mut self, node: &CondExpr) {
        <V as Visit>::visit_cond_expr(&mut **self, node)
    }

    #[inline]
    fn visit_constructor(&mut self, node: &Constructor) {
        <V as Visit>::visit_constructor(&mut **self, node)
    }

    #[inline]
    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        <V as Visit>::visit_continue_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        <V as Visit>::visit_debugger_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_decl(&mut self, node: &Decl) {
        <V as Visit>::visit_decl(&mut **self, node)
    }

    #[inline]
    fn visit_decorator(&mut self, node: &Decorator) {
        <V as Visit>::visit_decorator(&mut **self, node)
    }

    #[inline]
    fn visit_decorators(&mut self, node: &[Decorator]) {
        <V as Visit>::visit_decorators(&mut **self, node)
    }

    #[inline]
    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        <V as Visit>::visit_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        <V as Visit>::visit_do_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        <V as Visit>::visit_empty_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_export_all(&mut self, node: &ExportAll) {
        <V as Visit>::visit_export_all(&mut **self, node)
    }

    #[inline]
    fn visit_export_decl(&mut self, node: &ExportDecl) {
        <V as Visit>::visit_export_decl(&mut **self, node)
    }

    #[inline]
    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        <V as Visit>::visit_export_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        <V as Visit>::visit_export_default_expr(&mut **self, node)
    }

    #[inline]
    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        <V as Visit>::visit_export_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        <V as Visit>::visit_export_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        <V as Visit>::visit_export_namespace_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        <V as Visit>::visit_export_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        <V as Visit>::visit_export_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_expr(&mut self, node: &Expr) {
        <V as Visit>::visit_expr(&mut **self, node)
    }

    #[inline]
    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        <V as Visit>::visit_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        <V as Visit>::visit_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        <V as Visit>::visit_expr_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        <V as Visit>::visit_exprs(&mut **self, node)
    }

    #[inline]
    fn visit_fn_decl(&mut self, node: &FnDecl) {
        <V as Visit>::visit_fn_decl(&mut **self, node)
    }

    #[inline]
    fn visit_fn_expr(&mut self, node: &FnExpr) {
        <V as Visit>::visit_fn_expr(&mut **self, node)
    }

    #[inline]
    fn visit_for_head(&mut self, node: &ForHead) {
        <V as Visit>::visit_for_head(&mut **self, node)
    }

    #[inline]
    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        <V as Visit>::visit_for_in_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        <V as Visit>::visit_for_of_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_for_stmt(&mut self, node: &ForStmt) {
        <V as Visit>::visit_for_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_function(&mut self, node: &Function) {
        <V as Visit>::visit_function(&mut **self, node)
    }

    #[inline]
    fn visit_getter_prop(&mut self, node: &GetterProp) {
        <V as Visit>::visit_getter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_ident(&mut self, node: &Ident) {
        <V as Visit>::visit_ident(&mut **self, node)
    }

    #[inline]
    fn visit_ident_name(&mut self, node: &IdentName) {
        <V as Visit>::visit_ident_name(&mut **self, node)
    }

    #[inline]
    fn visit_if_stmt(&mut self, node: &IfStmt) {
        <V as Visit>::visit_if_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_import(&mut self, node: &Import) {
        <V as Visit>::visit_import(&mut **self, node)
    }

    #[inline]
    fn visit_import_decl(&mut self, node: &ImportDecl) {
        <V as Visit>::visit_import_decl(&mut **self, node)
    }

    #[inline]
    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        <V as Visit>::visit_import_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        <V as Visit>::visit_import_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_phase(&mut self, node: &ImportPhase) {
        <V as Visit>::visit_import_phase(&mut **self, node)
    }

    #[inline]
    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        <V as Visit>::visit_import_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        <V as Visit>::visit_import_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        <V as Visit>::visit_import_star_as_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_with(&mut self, node: &ImportWith) {
        <V as Visit>::visit_import_with(&mut **self, node)
    }

    #[inline]
    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        <V as Visit>::visit_import_with_item(&mut **self, node)
    }

    #[inline]
    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        <V as Visit>::visit_import_with_items(&mut **self, node)
    }

    #[inline]
    fn visit_invalid(&mut self, node: &Invalid) {
        <V as Visit>::visit_invalid(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        <V as Visit>::visit_jsx_attr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        <V as Visit>::visit_jsx_attr_name(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        <V as Visit>::visit_jsx_attr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        <V as Visit>::visit_jsx_attr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        <V as Visit>::visit_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        <V as Visit>::visit_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        <V as Visit>::visit_jsx_closing_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element(&mut self, node: &JSXElement) {
        <V as Visit>::visit_jsx_element(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        <V as Visit>::visit_jsx_element_child(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        <V as Visit>::visit_jsx_element_childs(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        <V as Visit>::visit_jsx_element_name(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        <V as Visit>::visit_jsx_empty_expr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        <V as Visit>::visit_jsx_expr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        <V as Visit>::visit_jsx_expr_container(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        <V as Visit>::visit_jsx_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        <V as Visit>::visit_jsx_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        <V as Visit>::visit_jsx_namespaced_name(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_object(&mut self, node: &JSXObject) {
        <V as Visit>::visit_jsx_object(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        <V as Visit>::visit_jsx_opening_element(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        <V as Visit>::visit_jsx_opening_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        <V as Visit>::visit_jsx_spread_child(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_text(&mut self, node: &JSXText) {
        <V as Visit>::visit_jsx_text(&mut **self, node)
    }

    #[inline]
    fn visit_key(&mut self, node: &Key) {
        <V as Visit>::visit_key(&mut **self, node)
    }

    #[inline]
    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        <V as Visit>::visit_key_value_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        <V as Visit>::visit_key_value_prop(&mut **self, node)
    }

    #[inline]
    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        <V as Visit>::visit_labeled_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_lit(&mut self, node: &Lit) {
        <V as Visit>::visit_lit(&mut **self, node)
    }

    #[inline]
    fn visit_member_expr(&mut self, node: &MemberExpr) {
        <V as Visit>::visit_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_member_prop(&mut self, node: &MemberProp) {
        <V as Visit>::visit_member_prop(&mut **self, node)
    }

    #[inline]
    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        <V as Visit>::visit_meta_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        <V as Visit>::visit_meta_prop_kind(&mut **self, node)
    }

    #[inline]
    fn visit_method_kind(&mut self, node: &MethodKind) {
        <V as Visit>::visit_method_kind(&mut **self, node)
    }

    #[inline]
    fn visit_method_prop(&mut self, node: &MethodProp) {
        <V as Visit>::visit_method_prop(&mut **self, node)
    }

    #[inline]
    fn visit_module(&mut self, node: &Module) {
        <V as Visit>::visit_module(&mut **self, node)
    }

    #[inline]
    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        <V as Visit>::visit_module_decl(&mut **self, node)
    }

    #[inline]
    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        <V as Visit>::visit_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_module_item(&mut self, node: &ModuleItem) {
        <V as Visit>::visit_module_item(&mut **self, node)
    }

    #[inline]
    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        <V as Visit>::visit_module_items(&mut **self, node)
    }

    #[inline]
    fn visit_named_export(&mut self, node: &NamedExport) {
        <V as Visit>::visit_named_export(&mut **self, node)
    }

    #[inline]
    fn visit_new_expr(&mut self, node: &NewExpr) {
        <V as Visit>::visit_new_expr(&mut **self, node)
    }

    #[inline]
    fn visit_null(&mut self, node: &Null) {
        <V as Visit>::visit_null(&mut **self, node)
    }

    #[inline]
    fn visit_number(&mut self, node: &Number) {
        <V as Visit>::visit_number(&mut **self, node)
    }

    #[inline]
    fn visit_object_lit(&mut self, node: &ObjectLit) {
        <V as Visit>::visit_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_object_pat(&mut self, node: &ObjectPat) {
        <V as Visit>::visit_object_pat(&mut **self, node)
    }

    #[inline]
    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        <V as Visit>::visit_object_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        <V as Visit>::visit_object_pat_props(&mut **self, node)
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        <V as Visit>::visit_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        <V as Visit>::visit_opt_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_opt_call(&mut self, node: &OptCall) {
        <V as Visit>::visit_opt_call(&mut **self, node)
    }

    #[inline]
    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        <V as Visit>::visit_opt_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        <V as Visit>::visit_opt_chain_base(&mut **self, node)
    }

    #[inline]
    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        <V as Visit>::visit_opt_chain_expr(&mut **self, node)
    }

    #[inline]
    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        <V as Visit>::visit_opt_expr(&mut **self, node)
    }

    #[inline]
    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        <V as Visit>::visit_opt_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        <V as Visit>::visit_opt_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        <V as Visit>::visit_opt_ident(&mut **self, node)
    }

    #[inline]
    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        <V as Visit>::visit_opt_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        <V as Visit>::visit_opt_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        <V as Visit>::visit_opt_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        <V as Visit>::visit_opt_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        <V as Visit>::visit_opt_pat(&mut **self, node)
    }

    #[inline]
    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        <V as Visit>::visit_opt_span(&mut **self, node)
    }

    #[inline]
    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        <V as Visit>::visit_opt_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        <V as Visit>::visit_opt_str(&mut **self, node)
    }

    #[inline]
    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        <V as Visit>::visit_opt_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        <V as Visit>::visit_opt_vec_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        <V as Visit>::visit_opt_vec_pats(&mut **self, node)
    }

    #[inline]
    fn visit_param(&mut self, node: &Param) {
        <V as Visit>::visit_param(&mut **self, node)
    }

    #[inline]
    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        <V as Visit>::visit_param_or_ts_param_prop(&mut **self, node)
    }

    #[inline]
    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        <V as Visit>::visit_param_or_ts_param_props(&mut **self, node)
    }

    #[inline]
    fn visit_params(&mut self, node: &[Param]) {
        <V as Visit>::visit_params(&mut **self, node)
    }

    #[inline]
    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        <V as Visit>::visit_paren_expr(&mut **self, node)
    }

    #[inline]
    fn visit_pat(&mut self, node: &Pat) {
        <V as Visit>::visit_pat(&mut **self, node)
    }

    #[inline]
    fn visit_pats(&mut self, node: &[Pat]) {
        <V as Visit>::visit_pats(&mut **self, node)
    }

    #[inline]
    fn visit_private_method(&mut self, node: &PrivateMethod) {
        <V as Visit>::visit_private_method(&mut **self, node)
    }

    #[inline]
    fn visit_private_name(&mut self, node: &PrivateName) {
        <V as Visit>::visit_private_name(&mut **self, node)
    }

    #[inline]
    fn visit_private_prop(&mut self, node: &PrivateProp) {
        <V as Visit>::visit_private_prop(&mut **self, node)
    }

    #[inline]
    fn visit_program(&mut self, node: &Program) {
        <V as Visit>::visit_program(&mut **self, node)
    }

    #[inline]
    fn visit_prop(&mut self, node: &Prop) {
        <V as Visit>::visit_prop(&mut **self, node)
    }

    #[inline]
    fn visit_prop_name(&mut self, node: &PropName) {
        <V as Visit>::visit_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        <V as Visit>::visit_prop_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        <V as Visit>::visit_prop_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_regex(&mut self, node: &Regex) {
        <V as Visit>::visit_regex(&mut **self, node)
    }

    #[inline]
    fn visit_rest_pat(&mut self, node: &RestPat) {
        <V as Visit>::visit_rest_pat(&mut **self, node)
    }

    #[inline]
    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        <V as Visit>::visit_return_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_script(&mut self, node: &Script) {
        <V as Visit>::visit_script(&mut **self, node)
    }

    #[inline]
    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        <V as Visit>::visit_seq_expr(&mut **self, node)
    }

    #[inline]
    fn visit_setter_prop(&mut self, node: &SetterProp) {
        <V as Visit>::visit_setter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        <V as Visit>::visit_simple_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        <V as Visit>::visit_span(&mut **self, node)
    }

    #[inline]
    fn visit_spread_element(&mut self, node: &SpreadElement) {
        <V as Visit>::visit_spread_element(&mut **self, node)
    }

    #[inline]
    fn visit_static_block(&mut self, node: &StaticBlock) {
        <V as Visit>::visit_static_block(&mut **self, node)
    }

    #[inline]
    fn visit_stmt(&mut self, node: &Stmt) {
        <V as Visit>::visit_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_stmts(&mut self, node: &[Stmt]) {
        <V as Visit>::visit_stmts(&mut **self, node)
    }

    #[inline]
    fn visit_str(&mut self, node: &Str) {
        <V as Visit>::visit_str(&mut **self, node)
    }

    #[inline]
    fn visit_super(&mut self, node: &Super) {
        <V as Visit>::visit_super(&mut **self, node)
    }

    #[inline]
    fn visit_super_prop(&mut self, node: &SuperProp) {
        <V as Visit>::visit_super_prop(&mut **self, node)
    }

    #[inline]
    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        <V as Visit>::visit_super_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_switch_case(&mut self, node: &SwitchCase) {
        <V as Visit>::visit_switch_case(&mut **self, node)
    }

    #[inline]
    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        <V as Visit>::visit_switch_cases(&mut **self, node)
    }

    #[inline]
    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        <V as Visit>::visit_switch_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        <V as Visit>::visit_syntax_context(&mut **self, node)
    }

    #[inline]
    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        <V as Visit>::visit_tagged_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_this_expr(&mut self, node: &ThisExpr) {
        <V as Visit>::visit_this_expr(&mut **self, node)
    }

    #[inline]
    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        <V as Visit>::visit_throw_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_tpl(&mut self, node: &Tpl) {
        <V as Visit>::visit_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_tpl_element(&mut self, node: &TplElement) {
        <V as Visit>::visit_tpl_element(&mut **self, node)
    }

    #[inline]
    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        <V as Visit>::visit_tpl_elements(&mut **self, node)
    }

    #[inline]
    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        <V as Visit>::visit_true_plus_minus(&mut **self, node)
    }

    #[inline]
    fn visit_try_stmt(&mut self, node: &TryStmt) {
        <V as Visit>::visit_try_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        <V as Visit>::visit_unary_expr(&mut **self, node)
    }

    #[inline]
    fn visit_unary_op(&mut self, node: &UnaryOp) {
        <V as Visit>::visit_unary_op(&mut **self, node)
    }

    #[inline]
    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        <V as Visit>::visit_update_expr(&mut **self, node)
    }

    #[inline]
    fn visit_update_op(&mut self, node: &UpdateOp) {
        <V as Visit>::visit_update_op(&mut **self, node)
    }

    #[inline]
    fn visit_using_decl(&mut self, node: &UsingDecl) {
        <V as Visit>::visit_using_decl(&mut **self, node)
    }

    #[inline]
    fn visit_var_decl(&mut self, node: &VarDecl) {
        <V as Visit>::visit_var_decl(&mut **self, node)
    }

    #[inline]
    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        <V as Visit>::visit_var_decl_kind(&mut **self, node)
    }

    #[inline]
    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        <V as Visit>::visit_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        <V as Visit>::visit_var_declarator(&mut **self, node)
    }

    #[inline]
    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        <V as Visit>::visit_var_declarators(&mut **self, node)
    }

    #[inline]
    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        <V as Visit>::visit_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_with_stmt(&mut self, node: &WithStmt) {
        <V as Visit>::visit_with_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        <V as Visit>::visit_yield_expr(&mut **self, node)
    }
}
impl<V> Visit for Box<V>
where
    V: ?Sized + Visit,
{
    #[inline]
    fn visit_array_lit(&mut self, node: &ArrayLit) {
        <V as Visit>::visit_array_lit(&mut **self, node)
    }

    #[inline]
    fn visit_array_pat(&mut self, node: &ArrayPat) {
        <V as Visit>::visit_array_pat(&mut **self, node)
    }

    #[inline]
    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        <V as Visit>::visit_arrow_expr(&mut **self, node)
    }

    #[inline]
    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        <V as Visit>::visit_assign_expr(&mut **self, node)
    }

    #[inline]
    fn visit_assign_op(&mut self, node: &AssignOp) {
        <V as Visit>::visit_assign_op(&mut **self, node)
    }

    #[inline]
    fn visit_assign_pat(&mut self, node: &AssignPat) {
        <V as Visit>::visit_assign_pat(&mut **self, node)
    }

    #[inline]
    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        <V as Visit>::visit_assign_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_assign_prop(&mut self, node: &AssignProp) {
        <V as Visit>::visit_assign_prop(&mut **self, node)
    }

    #[inline]
    fn visit_assign_target(&mut self, node: &AssignTarget) {
        <V as Visit>::visit_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        <V as Visit>::visit_assign_target_pat(&mut **self, node)
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        <V as Visit>::visit_atom(&mut **self, node)
    }

    #[inline]
    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        <V as Visit>::visit_auto_accessor(&mut **self, node)
    }

    #[inline]
    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        <V as Visit>::visit_await_expr(&mut **self, node)
    }

    #[inline]
    fn visit_big_int(&mut self, node: &BigInt) {
        <V as Visit>::visit_big_int(&mut **self, node)
    }

    #[inline]
    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        <V as Visit>::visit_big_int_value(&mut **self, node)
    }

    #[inline]
    fn visit_bin_expr(&mut self, node: &BinExpr) {
        <V as Visit>::visit_bin_expr(&mut **self, node)
    }

    #[inline]
    fn visit_binary_op(&mut self, node: &BinaryOp) {
        <V as Visit>::visit_binary_op(&mut **self, node)
    }

    #[inline]
    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        <V as Visit>::visit_binding_ident(&mut **self, node)
    }

    #[inline]
    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        <V as Visit>::visit_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        <V as Visit>::visit_block_stmt_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_bool(&mut self, node: &Bool) {
        <V as Visit>::visit_bool(&mut **self, node)
    }

    #[inline]
    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        <V as Visit>::visit_break_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_call_expr(&mut self, node: &CallExpr) {
        <V as Visit>::visit_call_expr(&mut **self, node)
    }

    #[inline]
    fn visit_callee(&mut self, node: &Callee) {
        <V as Visit>::visit_callee(&mut **self, node)
    }

    #[inline]
    fn visit_catch_clause(&mut self, node: &CatchClause) {
        <V as Visit>::visit_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_class(&mut self, node: &Class) {
        <V as Visit>::visit_class(&mut **self, node)
    }

    #[inline]
    fn visit_class_decl(&mut self, node: &ClassDecl) {
        <V as Visit>::visit_class_decl(&mut **self, node)
    }

    #[inline]
    fn visit_class_expr(&mut self, node: &ClassExpr) {
        <V as Visit>::visit_class_expr(&mut **self, node)
    }

    #[inline]
    fn visit_class_member(&mut self, node: &ClassMember) {
        <V as Visit>::visit_class_member(&mut **self, node)
    }

    #[inline]
    fn visit_class_members(&mut self, node: &[ClassMember]) {
        <V as Visit>::visit_class_members(&mut **self, node)
    }

    #[inline]
    fn visit_class_method(&mut self, node: &ClassMethod) {
        <V as Visit>::visit_class_method(&mut **self, node)
    }

    #[inline]
    fn visit_class_prop(&mut self, node: &ClassProp) {
        <V as Visit>::visit_class_prop(&mut **self, node)
    }

    #[inline]
    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        <V as Visit>::visit_computed_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_cond_expr(&mut self, node: &CondExpr) {
        <V as Visit>::visit_cond_expr(&mut **self, node)
    }

    #[inline]
    fn visit_constructor(&mut self, node: &Constructor) {
        <V as Visit>::visit_constructor(&mut **self, node)
    }

    #[inline]
    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        <V as Visit>::visit_continue_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        <V as Visit>::visit_debugger_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_decl(&mut self, node: &Decl) {
        <V as Visit>::visit_decl(&mut **self, node)
    }

    #[inline]
    fn visit_decorator(&mut self, node: &Decorator) {
        <V as Visit>::visit_decorator(&mut **self, node)
    }

    #[inline]
    fn visit_decorators(&mut self, node: &[Decorator]) {
        <V as Visit>::visit_decorators(&mut **self, node)
    }

    #[inline]
    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        <V as Visit>::visit_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        <V as Visit>::visit_do_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        <V as Visit>::visit_empty_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_export_all(&mut self, node: &ExportAll) {
        <V as Visit>::visit_export_all(&mut **self, node)
    }

    #[inline]
    fn visit_export_decl(&mut self, node: &ExportDecl) {
        <V as Visit>::visit_export_decl(&mut **self, node)
    }

    #[inline]
    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        <V as Visit>::visit_export_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        <V as Visit>::visit_export_default_expr(&mut **self, node)
    }

    #[inline]
    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        <V as Visit>::visit_export_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        <V as Visit>::visit_export_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        <V as Visit>::visit_export_namespace_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        <V as Visit>::visit_export_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        <V as Visit>::visit_export_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_expr(&mut self, node: &Expr) {
        <V as Visit>::visit_expr(&mut **self, node)
    }

    #[inline]
    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        <V as Visit>::visit_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        <V as Visit>::visit_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        <V as Visit>::visit_expr_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        <V as Visit>::visit_exprs(&mut **self, node)
    }

    #[inline]
    fn visit_fn_decl(&mut self, node: &FnDecl) {
        <V as Visit>::visit_fn_decl(&mut **self, node)
    }

    #[inline]
    fn visit_fn_expr(&mut self, node: &FnExpr) {
        <V as Visit>::visit_fn_expr(&mut **self, node)
    }

    #[inline]
    fn visit_for_head(&mut self, node: &ForHead) {
        <V as Visit>::visit_for_head(&mut **self, node)
    }

    #[inline]
    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        <V as Visit>::visit_for_in_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        <V as Visit>::visit_for_of_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_for_stmt(&mut self, node: &ForStmt) {
        <V as Visit>::visit_for_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_function(&mut self, node: &Function) {
        <V as Visit>::visit_function(&mut **self, node)
    }

    #[inline]
    fn visit_getter_prop(&mut self, node: &GetterProp) {
        <V as Visit>::visit_getter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_ident(&mut self, node: &Ident) {
        <V as Visit>::visit_ident(&mut **self, node)
    }

    #[inline]
    fn visit_ident_name(&mut self, node: &IdentName) {
        <V as Visit>::visit_ident_name(&mut **self, node)
    }

    #[inline]
    fn visit_if_stmt(&mut self, node: &IfStmt) {
        <V as Visit>::visit_if_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_import(&mut self, node: &Import) {
        <V as Visit>::visit_import(&mut **self, node)
    }

    #[inline]
    fn visit_import_decl(&mut self, node: &ImportDecl) {
        <V as Visit>::visit_import_decl(&mut **self, node)
    }

    #[inline]
    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        <V as Visit>::visit_import_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        <V as Visit>::visit_import_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_phase(&mut self, node: &ImportPhase) {
        <V as Visit>::visit_import_phase(&mut **self, node)
    }

    #[inline]
    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        <V as Visit>::visit_import_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        <V as Visit>::visit_import_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        <V as Visit>::visit_import_star_as_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_import_with(&mut self, node: &ImportWith) {
        <V as Visit>::visit_import_with(&mut **self, node)
    }

    #[inline]
    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        <V as Visit>::visit_import_with_item(&mut **self, node)
    }

    #[inline]
    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        <V as Visit>::visit_import_with_items(&mut **self, node)
    }

    #[inline]
    fn visit_invalid(&mut self, node: &Invalid) {
        <V as Visit>::visit_invalid(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        <V as Visit>::visit_jsx_attr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        <V as Visit>::visit_jsx_attr_name(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        <V as Visit>::visit_jsx_attr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        <V as Visit>::visit_jsx_attr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        <V as Visit>::visit_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        <V as Visit>::visit_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        <V as Visit>::visit_jsx_closing_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element(&mut self, node: &JSXElement) {
        <V as Visit>::visit_jsx_element(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        <V as Visit>::visit_jsx_element_child(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        <V as Visit>::visit_jsx_element_childs(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        <V as Visit>::visit_jsx_element_name(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        <V as Visit>::visit_jsx_empty_expr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        <V as Visit>::visit_jsx_expr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        <V as Visit>::visit_jsx_expr_container(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        <V as Visit>::visit_jsx_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        <V as Visit>::visit_jsx_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        <V as Visit>::visit_jsx_namespaced_name(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_object(&mut self, node: &JSXObject) {
        <V as Visit>::visit_jsx_object(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        <V as Visit>::visit_jsx_opening_element(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        <V as Visit>::visit_jsx_opening_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        <V as Visit>::visit_jsx_spread_child(&mut **self, node)
    }

    #[inline]
    fn visit_jsx_text(&mut self, node: &JSXText) {
        <V as Visit>::visit_jsx_text(&mut **self, node)
    }

    #[inline]
    fn visit_key(&mut self, node: &Key) {
        <V as Visit>::visit_key(&mut **self, node)
    }

    #[inline]
    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        <V as Visit>::visit_key_value_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        <V as Visit>::visit_key_value_prop(&mut **self, node)
    }

    #[inline]
    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        <V as Visit>::visit_labeled_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_lit(&mut self, node: &Lit) {
        <V as Visit>::visit_lit(&mut **self, node)
    }

    #[inline]
    fn visit_member_expr(&mut self, node: &MemberExpr) {
        <V as Visit>::visit_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_member_prop(&mut self, node: &MemberProp) {
        <V as Visit>::visit_member_prop(&mut **self, node)
    }

    #[inline]
    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        <V as Visit>::visit_meta_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        <V as Visit>::visit_meta_prop_kind(&mut **self, node)
    }

    #[inline]
    fn visit_method_kind(&mut self, node: &MethodKind) {
        <V as Visit>::visit_method_kind(&mut **self, node)
    }

    #[inline]
    fn visit_method_prop(&mut self, node: &MethodProp) {
        <V as Visit>::visit_method_prop(&mut **self, node)
    }

    #[inline]
    fn visit_module(&mut self, node: &Module) {
        <V as Visit>::visit_module(&mut **self, node)
    }

    #[inline]
    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        <V as Visit>::visit_module_decl(&mut **self, node)
    }

    #[inline]
    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        <V as Visit>::visit_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_module_item(&mut self, node: &ModuleItem) {
        <V as Visit>::visit_module_item(&mut **self, node)
    }

    #[inline]
    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        <V as Visit>::visit_module_items(&mut **self, node)
    }

    #[inline]
    fn visit_named_export(&mut self, node: &NamedExport) {
        <V as Visit>::visit_named_export(&mut **self, node)
    }

    #[inline]
    fn visit_new_expr(&mut self, node: &NewExpr) {
        <V as Visit>::visit_new_expr(&mut **self, node)
    }

    #[inline]
    fn visit_null(&mut self, node: &Null) {
        <V as Visit>::visit_null(&mut **self, node)
    }

    #[inline]
    fn visit_number(&mut self, node: &Number) {
        <V as Visit>::visit_number(&mut **self, node)
    }

    #[inline]
    fn visit_object_lit(&mut self, node: &ObjectLit) {
        <V as Visit>::visit_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_object_pat(&mut self, node: &ObjectPat) {
        <V as Visit>::visit_object_pat(&mut **self, node)
    }

    #[inline]
    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        <V as Visit>::visit_object_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        <V as Visit>::visit_object_pat_props(&mut **self, node)
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        <V as Visit>::visit_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        <V as Visit>::visit_opt_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_opt_call(&mut self, node: &OptCall) {
        <V as Visit>::visit_opt_call(&mut **self, node)
    }

    #[inline]
    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        <V as Visit>::visit_opt_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        <V as Visit>::visit_opt_chain_base(&mut **self, node)
    }

    #[inline]
    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        <V as Visit>::visit_opt_chain_expr(&mut **self, node)
    }

    #[inline]
    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        <V as Visit>::visit_opt_expr(&mut **self, node)
    }

    #[inline]
    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        <V as Visit>::visit_opt_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        <V as Visit>::visit_opt_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        <V as Visit>::visit_opt_ident(&mut **self, node)
    }

    #[inline]
    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        <V as Visit>::visit_opt_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        <V as Visit>::visit_opt_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        <V as Visit>::visit_opt_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        <V as Visit>::visit_opt_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        <V as Visit>::visit_opt_pat(&mut **self, node)
    }

    #[inline]
    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        <V as Visit>::visit_opt_span(&mut **self, node)
    }

    #[inline]
    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        <V as Visit>::visit_opt_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        <V as Visit>::visit_opt_str(&mut **self, node)
    }

    #[inline]
    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        <V as Visit>::visit_opt_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        <V as Visit>::visit_opt_vec_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        <V as Visit>::visit_opt_vec_pats(&mut **self, node)
    }

    #[inline]
    fn visit_param(&mut self, node: &Param) {
        <V as Visit>::visit_param(&mut **self, node)
    }

    #[inline]
    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        <V as Visit>::visit_param_or_ts_param_prop(&mut **self, node)
    }

    #[inline]
    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        <V as Visit>::visit_param_or_ts_param_props(&mut **self, node)
    }

    #[inline]
    fn visit_params(&mut self, node: &[Param]) {
        <V as Visit>::visit_params(&mut **self, node)
    }

    #[inline]
    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        <V as Visit>::visit_paren_expr(&mut **self, node)
    }

    #[inline]
    fn visit_pat(&mut self, node: &Pat) {
        <V as Visit>::visit_pat(&mut **self, node)
    }

    #[inline]
    fn visit_pats(&mut self, node: &[Pat]) {
        <V as Visit>::visit_pats(&mut **self, node)
    }

    #[inline]
    fn visit_private_method(&mut self, node: &PrivateMethod) {
        <V as Visit>::visit_private_method(&mut **self, node)
    }

    #[inline]
    fn visit_private_name(&mut self, node: &PrivateName) {
        <V as Visit>::visit_private_name(&mut **self, node)
    }

    #[inline]
    fn visit_private_prop(&mut self, node: &PrivateProp) {
        <V as Visit>::visit_private_prop(&mut **self, node)
    }

    #[inline]
    fn visit_program(&mut self, node: &Program) {
        <V as Visit>::visit_program(&mut **self, node)
    }

    #[inline]
    fn visit_prop(&mut self, node: &Prop) {
        <V as Visit>::visit_prop(&mut **self, node)
    }

    #[inline]
    fn visit_prop_name(&mut self, node: &PropName) {
        <V as Visit>::visit_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        <V as Visit>::visit_prop_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        <V as Visit>::visit_prop_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_regex(&mut self, node: &Regex) {
        <V as Visit>::visit_regex(&mut **self, node)
    }

    #[inline]
    fn visit_rest_pat(&mut self, node: &RestPat) {
        <V as Visit>::visit_rest_pat(&mut **self, node)
    }

    #[inline]
    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        <V as Visit>::visit_return_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_script(&mut self, node: &Script) {
        <V as Visit>::visit_script(&mut **self, node)
    }

    #[inline]
    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        <V as Visit>::visit_seq_expr(&mut **self, node)
    }

    #[inline]
    fn visit_setter_prop(&mut self, node: &SetterProp) {
        <V as Visit>::visit_setter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        <V as Visit>::visit_simple_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        <V as Visit>::visit_span(&mut **self, node)
    }

    #[inline]
    fn visit_spread_element(&mut self, node: &SpreadElement) {
        <V as Visit>::visit_spread_element(&mut **self, node)
    }

    #[inline]
    fn visit_static_block(&mut self, node: &StaticBlock) {
        <V as Visit>::visit_static_block(&mut **self, node)
    }

    #[inline]
    fn visit_stmt(&mut self, node: &Stmt) {
        <V as Visit>::visit_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_stmts(&mut self, node: &[Stmt]) {
        <V as Visit>::visit_stmts(&mut **self, node)
    }

    #[inline]
    fn visit_str(&mut self, node: &Str) {
        <V as Visit>::visit_str(&mut **self, node)
    }

    #[inline]
    fn visit_super(&mut self, node: &Super) {
        <V as Visit>::visit_super(&mut **self, node)
    }

    #[inline]
    fn visit_super_prop(&mut self, node: &SuperProp) {
        <V as Visit>::visit_super_prop(&mut **self, node)
    }

    #[inline]
    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        <V as Visit>::visit_super_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_switch_case(&mut self, node: &SwitchCase) {
        <V as Visit>::visit_switch_case(&mut **self, node)
    }

    #[inline]
    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        <V as Visit>::visit_switch_cases(&mut **self, node)
    }

    #[inline]
    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        <V as Visit>::visit_switch_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        <V as Visit>::visit_syntax_context(&mut **self, node)
    }

    #[inline]
    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        <V as Visit>::visit_tagged_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_this_expr(&mut self, node: &ThisExpr) {
        <V as Visit>::visit_this_expr(&mut **self, node)
    }

    #[inline]
    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        <V as Visit>::visit_throw_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_tpl(&mut self, node: &Tpl) {
        <V as Visit>::visit_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_tpl_element(&mut self, node: &TplElement) {
        <V as Visit>::visit_tpl_element(&mut **self, node)
    }

    #[inline]
    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        <V as Visit>::visit_tpl_elements(&mut **self, node)
    }

    #[inline]
    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        <V as Visit>::visit_true_plus_minus(&mut **self, node)
    }

    #[inline]
    fn visit_try_stmt(&mut self, node: &TryStmt) {
        <V as Visit>::visit_try_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        <V as Visit>::visit_unary_expr(&mut **self, node)
    }

    #[inline]
    fn visit_unary_op(&mut self, node: &UnaryOp) {
        <V as Visit>::visit_unary_op(&mut **self, node)
    }

    #[inline]
    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        <V as Visit>::visit_update_expr(&mut **self, node)
    }

    #[inline]
    fn visit_update_op(&mut self, node: &UpdateOp) {
        <V as Visit>::visit_update_op(&mut **self, node)
    }

    #[inline]
    fn visit_using_decl(&mut self, node: &UsingDecl) {
        <V as Visit>::visit_using_decl(&mut **self, node)
    }

    #[inline]
    fn visit_var_decl(&mut self, node: &VarDecl) {
        <V as Visit>::visit_var_decl(&mut **self, node)
    }

    #[inline]
    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        <V as Visit>::visit_var_decl_kind(&mut **self, node)
    }

    #[inline]
    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        <V as Visit>::visit_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        <V as Visit>::visit_var_declarator(&mut **self, node)
    }

    #[inline]
    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        <V as Visit>::visit_var_declarators(&mut **self, node)
    }

    #[inline]
    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        <V as Visit>::visit_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_with_stmt(&mut self, node: &WithStmt) {
        <V as Visit>::visit_with_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        <V as Visit>::visit_yield_expr(&mut **self, node)
    }
}
impl<A, B> Visit for ::swc_visit::Either<A, B>
where
    A: Visit,
    B: Visit,
{
    #[inline]
    fn visit_array_lit(&mut self, node: &ArrayLit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_array_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_array_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_array_pat(&mut self, node: &ArrayPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_array_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_array_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_arrow_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_arrow_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_assign_op(&mut self, node: &AssignOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_op(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_op(visitor, node),
        }
    }

    #[inline]
    fn visit_assign_pat(&mut self, node: &AssignPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_assign_prop(&mut self, node: &AssignProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_assign_target(&mut self, node: &AssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_target(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_target(visitor, node),
        }
    }

    #[inline]
    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_target_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_target_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_auto_accessor(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_auto_accessor(visitor, node),
        }
    }

    #[inline]
    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_await_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_await_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_big_int(&mut self, node: &BigInt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_big_int(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_big_int(visitor, node),
        }
    }

    #[inline]
    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_big_int_value(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_big_int_value(visitor, node),
        }
    }

    #[inline]
    fn visit_bin_expr(&mut self, node: &BinExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_bin_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_bin_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_binary_op(&mut self, node: &BinaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_binary_op(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_binary_op(visitor, node),
        }
    }

    #[inline]
    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_binding_ident(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_binding_ident(visitor, node),
        }
    }

    #[inline]
    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_block_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_block_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_block_stmt_or_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_block_stmt_or_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_bool(&mut self, node: &Bool) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_bool(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_bool(visitor, node),
        }
    }

    #[inline]
    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_break_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_break_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_call_expr(&mut self, node: &CallExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_call_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_call_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_callee(&mut self, node: &Callee) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_callee(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_callee(visitor, node),
        }
    }

    #[inline]
    fn visit_catch_clause(&mut self, node: &CatchClause) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_catch_clause(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_catch_clause(visitor, node),
        }
    }

    #[inline]
    fn visit_class(&mut self, node: &Class) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class(visitor, node),
        }
    }

    #[inline]
    fn visit_class_decl(&mut self, node: &ClassDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_class_expr(&mut self, node: &ClassExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_class_member(&mut self, node: &ClassMember) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_member(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_member(visitor, node),
        }
    }

    #[inline]
    fn visit_class_members(&mut self, node: &[ClassMember]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_members(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_members(visitor, node),
        }
    }

    #[inline]
    fn visit_class_method(&mut self, node: &ClassMethod) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_method(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_method(visitor, node),
        }
    }

    #[inline]
    fn visit_class_prop(&mut self, node: &ClassProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_computed_prop_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_computed_prop_name(visitor, node),
        }
    }

    #[inline]
    fn visit_cond_expr(&mut self, node: &CondExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_cond_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_cond_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_constructor(&mut self, node: &Constructor) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_constructor(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_constructor(visitor, node),
        }
    }

    #[inline]
    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_continue_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_continue_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_debugger_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_debugger_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_decl(&mut self, node: &Decl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_decorator(&mut self, node: &Decorator) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_decorator(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_decorator(visitor, node),
        }
    }

    #[inline]
    fn visit_decorators(&mut self, node: &[Decorator]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_decorators(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_decorators(visitor, node),
        }
    }

    #[inline]
    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_default_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_default_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_do_while_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_do_while_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_empty_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_empty_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_export_all(&mut self, node: &ExportAll) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_all(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_all(visitor, node),
        }
    }

    #[inline]
    fn visit_export_decl(&mut self, node: &ExportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_default_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_default_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_default_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_default_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_export_default_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_export_default_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_named_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_named_specifier(visitor, node),
        }
    }

    #[inline]
    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_export_namespace_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_export_namespace_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_specifier(visitor, node),
        }
    }

    #[inline]
    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_specifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_specifiers(visitor, node),
        }
    }

    #[inline]
    fn visit_expr(&mut self, node: &Expr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr_or_spread(visitor, node),
        }
    }

    #[inline]
    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_exprs(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_exprs(visitor, node),
        }
    }

    #[inline]
    fn visit_fn_decl(&mut self, node: &FnDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_fn_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_fn_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_fn_expr(&mut self, node: &FnExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_fn_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_fn_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_for_head(&mut self, node: &ForHead) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_head(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_head(visitor, node),
        }
    }

    #[inline]
    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_in_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_in_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_of_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_of_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_for_stmt(&mut self, node: &ForStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_function(&mut self, node: &Function) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_function(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_function(visitor, node),
        }
    }

    #[inline]
    fn visit_getter_prop(&mut self, node: &GetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_getter_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_getter_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_ident(&mut self, node: &Ident) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ident(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ident(visitor, node),
        }
    }

    #[inline]
    fn visit_ident_name(&mut self, node: &IdentName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ident_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ident_name(visitor, node),
        }
    }

    #[inline]
    fn visit_if_stmt(&mut self, node: &IfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_if_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_if_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_import(&mut self, node: &Import) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import(visitor, node),
        }
    }

    #[inline]
    fn visit_import_decl(&mut self, node: &ImportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_import_default_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_import_default_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_named_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_named_specifier(visitor, node),
        }
    }

    #[inline]
    fn visit_import_phase(&mut self, node: &ImportPhase) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_phase(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_phase(visitor, node),
        }
    }

    #[inline]
    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_specifier(visitor, node),
        }
    }

    #[inline]
    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_specifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_specifiers(visitor, node),
        }
    }

    #[inline]
    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_import_star_as_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_import_star_as_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_import_with(&mut self, node: &ImportWith) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_with(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_with(visitor, node),
        }
    }

    #[inline]
    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_with_item(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_with_item(visitor, node),
        }
    }

    #[inline]
    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_with_items(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_with_items(visitor, node),
        }
    }

    #[inline]
    fn visit_invalid(&mut self, node: &Invalid) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_invalid(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_invalid(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_name(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_or_spread(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_value(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_value(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_closing_element(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_closing_element(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_closing_fragment(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_closing_fragment(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_element(&mut self, node: &JSXElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element_child(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element_child(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element_childs(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element_childs(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element_name(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_empty_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_empty_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_expr_container(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_expr_container(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_fragment(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_fragment(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_member_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_member_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_namespaced_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_namespaced_name(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_object(&mut self, node: &JSXObject) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_object(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_object(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_opening_element(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_opening_element(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_opening_fragment(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_opening_fragment(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_spread_child(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_spread_child(visitor, node),
        }
    }

    #[inline]
    fn visit_jsx_text(&mut self, node: &JSXText) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_text(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_text(visitor, node),
        }
    }

    #[inline]
    fn visit_key(&mut self, node: &Key) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_key(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_key(visitor, node),
        }
    }

    #[inline]
    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_key_value_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_key_value_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_key_value_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_key_value_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_labeled_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_labeled_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_lit(&mut self, node: &Lit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_member_expr(&mut self, node: &MemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_member_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_member_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_member_prop(&mut self, node: &MemberProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_member_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_member_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_meta_prop_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_meta_prop_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_meta_prop_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_meta_prop_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_method_kind(&mut self, node: &MethodKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_method_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_method_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_method_prop(&mut self, node: &MethodProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_method_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_method_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_module(&mut self, node: &Module) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module(visitor, node),
        }
    }

    #[inline]
    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_export_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_export_name(visitor, node),
        }
    }

    #[inline]
    fn visit_module_item(&mut self, node: &ModuleItem) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_item(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_item(visitor, node),
        }
    }

    #[inline]
    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_items(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_items(visitor, node),
        }
    }

    #[inline]
    fn visit_named_export(&mut self, node: &NamedExport) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_named_export(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_named_export(visitor, node),
        }
    }

    #[inline]
    fn visit_new_expr(&mut self, node: &NewExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_new_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_new_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_null(&mut self, node: &Null) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_null(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_null(visitor, node),
        }
    }

    #[inline]
    fn visit_number(&mut self, node: &Number) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_number(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_number(visitor, node),
        }
    }

    #[inline]
    fn visit_object_lit(&mut self, node: &ObjectLit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_object_pat(&mut self, node: &ObjectPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_pat_props(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_pat_props(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_block_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_block_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_call(&mut self, node: &OptCall) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_call(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_call(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_catch_clause(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_catch_clause(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_chain_base(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_chain_base(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_chain_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_chain_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_expr_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_expr_or_spread(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_expr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_expr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_ident(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_ident(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_jsx_attr_value(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_jsx_attr_value(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_jsx_closing_element(visitor, node),
            swc_visit::Either::Right(visitor) => {
                Visit::visit_opt_jsx_closing_element(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_module_export_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_module_export_name(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_object_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_object_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_span(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_span(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_str(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_str(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_var_decl_or_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_var_decl_or_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_vec_expr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => {
                Visit::visit_opt_vec_expr_or_spreads(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_vec_pats(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_vec_pats(visitor, node),
        }
    }

    #[inline]
    fn visit_param(&mut self, node: &Param) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_param(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_param(visitor, node),
        }
    }

    #[inline]
    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_param_or_ts_param_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_param_or_ts_param_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_param_or_ts_param_props(visitor, node),
            swc_visit::Either::Right(visitor) => {
                Visit::visit_param_or_ts_param_props(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_params(&mut self, node: &[Param]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_params(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_params(visitor, node),
        }
    }

    #[inline]
    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_paren_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_paren_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_pat(&mut self, node: &Pat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_pats(&mut self, node: &[Pat]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_pats(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_pats(visitor, node),
        }
    }

    #[inline]
    fn visit_private_method(&mut self, node: &PrivateMethod) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_private_method(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_private_method(visitor, node),
        }
    }

    #[inline]
    fn visit_private_name(&mut self, node: &PrivateName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_private_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_private_name(visitor, node),
        }
    }

    #[inline]
    fn visit_private_prop(&mut self, node: &PrivateProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_private_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_private_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_program(&mut self, node: &Program) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_program(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_program(visitor, node),
        }
    }

    #[inline]
    fn visit_prop(&mut self, node: &Prop) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_prop_name(&mut self, node: &PropName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop_name(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop_name(visitor, node),
        }
    }

    #[inline]
    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop_or_spread(visitor, node),
        }
    }

    #[inline]
    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn visit_regex(&mut self, node: &Regex) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_regex(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_regex(visitor, node),
        }
    }

    #[inline]
    fn visit_rest_pat(&mut self, node: &RestPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_rest_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_rest_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_return_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_return_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_script(&mut self, node: &Script) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_script(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_script(visitor, node),
        }
    }

    #[inline]
    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_seq_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_seq_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_setter_prop(&mut self, node: &SetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_setter_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_setter_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_simple_assign_target(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_simple_assign_target(visitor, node),
        }
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_span(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_span(visitor, node),
        }
    }

    #[inline]
    fn visit_spread_element(&mut self, node: &SpreadElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_spread_element(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_spread_element(visitor, node),
        }
    }

    #[inline]
    fn visit_static_block(&mut self, node: &StaticBlock) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_static_block(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_static_block(visitor, node),
        }
    }

    #[inline]
    fn visit_stmt(&mut self, node: &Stmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_stmts(&mut self, node: &[Stmt]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_stmts(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_stmts(visitor, node),
        }
    }

    #[inline]
    fn visit_str(&mut self, node: &Str) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_str(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_str(visitor, node),
        }
    }

    #[inline]
    fn visit_super(&mut self, node: &Super) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_super(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_super(visitor, node),
        }
    }

    #[inline]
    fn visit_super_prop(&mut self, node: &SuperProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_super_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_super_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_super_prop_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_super_prop_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_switch_case(&mut self, node: &SwitchCase) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_switch_case(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_switch_case(visitor, node),
        }
    }

    #[inline]
    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_switch_cases(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_switch_cases(visitor, node),
        }
    }

    #[inline]
    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_switch_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_switch_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_syntax_context(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_syntax_context(visitor, node),
        }
    }

    #[inline]
    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tagged_tpl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tagged_tpl(visitor, node),
        }
    }

    #[inline]
    fn visit_this_expr(&mut self, node: &ThisExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_this_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_this_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_throw_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_throw_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_tpl(&mut self, node: &Tpl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tpl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tpl(visitor, node),
        }
    }

    #[inline]
    fn visit_tpl_element(&mut self, node: &TplElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tpl_element(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tpl_element(visitor, node),
        }
    }

    #[inline]
    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tpl_elements(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tpl_elements(visitor, node),
        }
    }

    #[inline]
    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_true_plus_minus(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_true_plus_minus(visitor, node),
        }
    }

    #[inline]
    fn visit_try_stmt(&mut self, node: &TryStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_try_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_try_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_unary_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_unary_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_unary_op(&mut self, node: &UnaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_unary_op(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_unary_op(visitor, node),
        }
    }

    #[inline]
    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_update_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_update_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_update_op(&mut self, node: &UpdateOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_update_op(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_update_op(visitor, node),
        }
    }

    #[inline]
    fn visit_using_decl(&mut self, node: &UsingDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_using_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_using_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_var_decl(&mut self, node: &VarDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_decl_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_decl_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_decl_or_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_decl_or_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_declarator(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_declarator(visitor, node),
        }
    }

    #[inline]
    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_declarators(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_declarators(visitor, node),
        }
    }

    #[inline]
    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_while_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_while_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_with_stmt(&mut self, node: &WithStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_with_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_with_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_yield_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_yield_expr(visitor, node),
        }
    }
}
impl<V> Visit for ::swc_visit::Optional<V>
where
    V: Visit,
{
    #[inline]
    fn visit_array_lit(&mut self, node: &ArrayLit) {
        if self.enabled {
            <V as Visit>::visit_array_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_array_pat(&mut self, node: &ArrayPat) {
        if self.enabled {
            <V as Visit>::visit_array_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        if self.enabled {
            <V as Visit>::visit_arrow_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        if self.enabled {
            <V as Visit>::visit_assign_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_assign_op(&mut self, node: &AssignOp) {
        if self.enabled {
            <V as Visit>::visit_assign_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_assign_pat(&mut self, node: &AssignPat) {
        if self.enabled {
            <V as Visit>::visit_assign_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        if self.enabled {
            <V as Visit>::visit_assign_pat_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_assign_prop(&mut self, node: &AssignProp) {
        if self.enabled {
            <V as Visit>::visit_assign_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_assign_target(&mut self, node: &AssignTarget) {
        if self.enabled {
            <V as Visit>::visit_assign_target(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        if self.enabled {
            <V as Visit>::visit_assign_target_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        if self.enabled {
            <V as Visit>::visit_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        if self.enabled {
            <V as Visit>::visit_auto_accessor(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        if self.enabled {
            <V as Visit>::visit_await_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_big_int(&mut self, node: &BigInt) {
        if self.enabled {
            <V as Visit>::visit_big_int(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        if self.enabled {
            <V as Visit>::visit_big_int_value(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_bin_expr(&mut self, node: &BinExpr) {
        if self.enabled {
            <V as Visit>::visit_bin_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_binary_op(&mut self, node: &BinaryOp) {
        if self.enabled {
            <V as Visit>::visit_binary_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        if self.enabled {
            <V as Visit>::visit_binding_ident(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        if self.enabled {
            <V as Visit>::visit_block_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        if self.enabled {
            <V as Visit>::visit_block_stmt_or_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_bool(&mut self, node: &Bool) {
        if self.enabled {
            <V as Visit>::visit_bool(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        if self.enabled {
            <V as Visit>::visit_break_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_call_expr(&mut self, node: &CallExpr) {
        if self.enabled {
            <V as Visit>::visit_call_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_callee(&mut self, node: &Callee) {
        if self.enabled {
            <V as Visit>::visit_callee(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_catch_clause(&mut self, node: &CatchClause) {
        if self.enabled {
            <V as Visit>::visit_catch_clause(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class(&mut self, node: &Class) {
        if self.enabled {
            <V as Visit>::visit_class(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_decl(&mut self, node: &ClassDecl) {
        if self.enabled {
            <V as Visit>::visit_class_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_expr(&mut self, node: &ClassExpr) {
        if self.enabled {
            <V as Visit>::visit_class_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_member(&mut self, node: &ClassMember) {
        if self.enabled {
            <V as Visit>::visit_class_member(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_members(&mut self, node: &[ClassMember]) {
        if self.enabled {
            <V as Visit>::visit_class_members(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_method(&mut self, node: &ClassMethod) {
        if self.enabled {
            <V as Visit>::visit_class_method(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_prop(&mut self, node: &ClassProp) {
        if self.enabled {
            <V as Visit>::visit_class_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        if self.enabled {
            <V as Visit>::visit_computed_prop_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_cond_expr(&mut self, node: &CondExpr) {
        if self.enabled {
            <V as Visit>::visit_cond_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_constructor(&mut self, node: &Constructor) {
        if self.enabled {
            <V as Visit>::visit_constructor(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        if self.enabled {
            <V as Visit>::visit_continue_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        if self.enabled {
            <V as Visit>::visit_debugger_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_decl(&mut self, node: &Decl) {
        if self.enabled {
            <V as Visit>::visit_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_decorator(&mut self, node: &Decorator) {
        if self.enabled {
            <V as Visit>::visit_decorator(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_decorators(&mut self, node: &[Decorator]) {
        if self.enabled {
            <V as Visit>::visit_decorators(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        if self.enabled {
            <V as Visit>::visit_default_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        if self.enabled {
            <V as Visit>::visit_do_while_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        if self.enabled {
            <V as Visit>::visit_empty_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_all(&mut self, node: &ExportAll) {
        if self.enabled {
            <V as Visit>::visit_export_all(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_decl(&mut self, node: &ExportDecl) {
        if self.enabled {
            <V as Visit>::visit_export_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        if self.enabled {
            <V as Visit>::visit_export_default_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        if self.enabled {
            <V as Visit>::visit_export_default_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        if self.enabled {
            <V as Visit>::visit_export_default_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        if self.enabled {
            <V as Visit>::visit_export_named_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        if self.enabled {
            <V as Visit>::visit_export_namespace_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        if self.enabled {
            <V as Visit>::visit_export_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        if self.enabled {
            <V as Visit>::visit_export_specifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_expr(&mut self, node: &Expr) {
        if self.enabled {
            <V as Visit>::visit_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        if self.enabled {
            <V as Visit>::visit_expr_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        if self.enabled {
            <V as Visit>::visit_expr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        if self.enabled {
            <V as Visit>::visit_expr_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        if self.enabled {
            <V as Visit>::visit_exprs(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_fn_decl(&mut self, node: &FnDecl) {
        if self.enabled {
            <V as Visit>::visit_fn_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_fn_expr(&mut self, node: &FnExpr) {
        if self.enabled {
            <V as Visit>::visit_fn_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_for_head(&mut self, node: &ForHead) {
        if self.enabled {
            <V as Visit>::visit_for_head(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        if self.enabled {
            <V as Visit>::visit_for_in_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        if self.enabled {
            <V as Visit>::visit_for_of_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_for_stmt(&mut self, node: &ForStmt) {
        if self.enabled {
            <V as Visit>::visit_for_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_function(&mut self, node: &Function) {
        if self.enabled {
            <V as Visit>::visit_function(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_getter_prop(&mut self, node: &GetterProp) {
        if self.enabled {
            <V as Visit>::visit_getter_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_ident(&mut self, node: &Ident) {
        if self.enabled {
            <V as Visit>::visit_ident(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_ident_name(&mut self, node: &IdentName) {
        if self.enabled {
            <V as Visit>::visit_ident_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_if_stmt(&mut self, node: &IfStmt) {
        if self.enabled {
            <V as Visit>::visit_if_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import(&mut self, node: &Import) {
        if self.enabled {
            <V as Visit>::visit_import(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_decl(&mut self, node: &ImportDecl) {
        if self.enabled {
            <V as Visit>::visit_import_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        if self.enabled {
            <V as Visit>::visit_import_default_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        if self.enabled {
            <V as Visit>::visit_import_named_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_phase(&mut self, node: &ImportPhase) {
        if self.enabled {
            <V as Visit>::visit_import_phase(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        if self.enabled {
            <V as Visit>::visit_import_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        if self.enabled {
            <V as Visit>::visit_import_specifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        if self.enabled {
            <V as Visit>::visit_import_star_as_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_with(&mut self, node: &ImportWith) {
        if self.enabled {
            <V as Visit>::visit_import_with(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        if self.enabled {
            <V as Visit>::visit_import_with_item(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        if self.enabled {
            <V as Visit>::visit_import_with_items(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_invalid(&mut self, node: &Invalid) {
        if self.enabled {
            <V as Visit>::visit_invalid(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        if self.enabled {
            <V as Visit>::visit_jsx_attr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        if self.enabled {
            <V as Visit>::visit_jsx_attr_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        if self.enabled {
            <V as Visit>::visit_jsx_attr_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        if self.enabled {
            <V as Visit>::visit_jsx_attr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        if self.enabled {
            <V as Visit>::visit_jsx_attr_value(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        if self.enabled {
            <V as Visit>::visit_jsx_closing_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        if self.enabled {
            <V as Visit>::visit_jsx_closing_fragment(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element(&mut self, node: &JSXElement) {
        if self.enabled {
            <V as Visit>::visit_jsx_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        if self.enabled {
            <V as Visit>::visit_jsx_element_child(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        if self.enabled {
            <V as Visit>::visit_jsx_element_childs(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        if self.enabled {
            <V as Visit>::visit_jsx_element_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        if self.enabled {
            <V as Visit>::visit_jsx_empty_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        if self.enabled {
            <V as Visit>::visit_jsx_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        if self.enabled {
            <V as Visit>::visit_jsx_expr_container(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        if self.enabled {
            <V as Visit>::visit_jsx_fragment(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        if self.enabled {
            <V as Visit>::visit_jsx_member_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        if self.enabled {
            <V as Visit>::visit_jsx_namespaced_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_object(&mut self, node: &JSXObject) {
        if self.enabled {
            <V as Visit>::visit_jsx_object(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        if self.enabled {
            <V as Visit>::visit_jsx_opening_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        if self.enabled {
            <V as Visit>::visit_jsx_opening_fragment(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        if self.enabled {
            <V as Visit>::visit_jsx_spread_child(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_text(&mut self, node: &JSXText) {
        if self.enabled {
            <V as Visit>::visit_jsx_text(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_key(&mut self, node: &Key) {
        if self.enabled {
            <V as Visit>::visit_key(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        if self.enabled {
            <V as Visit>::visit_key_value_pat_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        if self.enabled {
            <V as Visit>::visit_key_value_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        if self.enabled {
            <V as Visit>::visit_labeled_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_lit(&mut self, node: &Lit) {
        if self.enabled {
            <V as Visit>::visit_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_member_expr(&mut self, node: &MemberExpr) {
        if self.enabled {
            <V as Visit>::visit_member_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_member_prop(&mut self, node: &MemberProp) {
        if self.enabled {
            <V as Visit>::visit_member_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        if self.enabled {
            <V as Visit>::visit_meta_prop_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        if self.enabled {
            <V as Visit>::visit_meta_prop_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_method_kind(&mut self, node: &MethodKind) {
        if self.enabled {
            <V as Visit>::visit_method_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_method_prop(&mut self, node: &MethodProp) {
        if self.enabled {
            <V as Visit>::visit_method_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_module(&mut self, node: &Module) {
        if self.enabled {
            <V as Visit>::visit_module(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        if self.enabled {
            <V as Visit>::visit_module_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        if self.enabled {
            <V as Visit>::visit_module_export_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_module_item(&mut self, node: &ModuleItem) {
        if self.enabled {
            <V as Visit>::visit_module_item(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        if self.enabled {
            <V as Visit>::visit_module_items(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_named_export(&mut self, node: &NamedExport) {
        if self.enabled {
            <V as Visit>::visit_named_export(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_new_expr(&mut self, node: &NewExpr) {
        if self.enabled {
            <V as Visit>::visit_new_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_null(&mut self, node: &Null) {
        if self.enabled {
            <V as Visit>::visit_null(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_number(&mut self, node: &Number) {
        if self.enabled {
            <V as Visit>::visit_number(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_object_lit(&mut self, node: &ObjectLit) {
        if self.enabled {
            <V as Visit>::visit_object_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_object_pat(&mut self, node: &ObjectPat) {
        if self.enabled {
            <V as Visit>::visit_object_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        if self.enabled {
            <V as Visit>::visit_object_pat_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        if self.enabled {
            <V as Visit>::visit_object_pat_props(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        if self.enabled {
            <V as Visit>::visit_opt_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        if self.enabled {
            <V as Visit>::visit_opt_block_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_call(&mut self, node: &OptCall) {
        if self.enabled {
            <V as Visit>::visit_opt_call(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        if self.enabled {
            <V as Visit>::visit_opt_catch_clause(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        if self.enabled {
            <V as Visit>::visit_opt_chain_base(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        if self.enabled {
            <V as Visit>::visit_opt_chain_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        if self.enabled {
            <V as Visit>::visit_opt_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        if self.enabled {
            <V as Visit>::visit_opt_expr_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        if self.enabled {
            <V as Visit>::visit_opt_expr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        if self.enabled {
            <V as Visit>::visit_opt_ident(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        if self.enabled {
            <V as Visit>::visit_opt_jsx_attr_value(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        if self.enabled {
            <V as Visit>::visit_opt_jsx_closing_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        if self.enabled {
            <V as Visit>::visit_opt_module_export_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        if self.enabled {
            <V as Visit>::visit_opt_object_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        if self.enabled {
            <V as Visit>::visit_opt_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        if self.enabled {
            <V as Visit>::visit_opt_span(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        if self.enabled {
            <V as Visit>::visit_opt_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        if self.enabled {
            <V as Visit>::visit_opt_str(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        if self.enabled {
            <V as Visit>::visit_opt_var_decl_or_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        if self.enabled {
            <V as Visit>::visit_opt_vec_expr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        if self.enabled {
            <V as Visit>::visit_opt_vec_pats(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_param(&mut self, node: &Param) {
        if self.enabled {
            <V as Visit>::visit_param(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        if self.enabled {
            <V as Visit>::visit_param_or_ts_param_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        if self.enabled {
            <V as Visit>::visit_param_or_ts_param_props(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_params(&mut self, node: &[Param]) {
        if self.enabled {
            <V as Visit>::visit_params(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        if self.enabled {
            <V as Visit>::visit_paren_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_pat(&mut self, node: &Pat) {
        if self.enabled {
            <V as Visit>::visit_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_pats(&mut self, node: &[Pat]) {
        if self.enabled {
            <V as Visit>::visit_pats(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_private_method(&mut self, node: &PrivateMethod) {
        if self.enabled {
            <V as Visit>::visit_private_method(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_private_name(&mut self, node: &PrivateName) {
        if self.enabled {
            <V as Visit>::visit_private_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_private_prop(&mut self, node: &PrivateProp) {
        if self.enabled {
            <V as Visit>::visit_private_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_program(&mut self, node: &Program) {
        if self.enabled {
            <V as Visit>::visit_program(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_prop(&mut self, node: &Prop) {
        if self.enabled {
            <V as Visit>::visit_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_prop_name(&mut self, node: &PropName) {
        if self.enabled {
            <V as Visit>::visit_prop_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        if self.enabled {
            <V as Visit>::visit_prop_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        if self.enabled {
            <V as Visit>::visit_prop_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_regex(&mut self, node: &Regex) {
        if self.enabled {
            <V as Visit>::visit_regex(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_rest_pat(&mut self, node: &RestPat) {
        if self.enabled {
            <V as Visit>::visit_rest_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        if self.enabled {
            <V as Visit>::visit_return_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_script(&mut self, node: &Script) {
        if self.enabled {
            <V as Visit>::visit_script(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        if self.enabled {
            <V as Visit>::visit_seq_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_setter_prop(&mut self, node: &SetterProp) {
        if self.enabled {
            <V as Visit>::visit_setter_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        if self.enabled {
            <V as Visit>::visit_simple_assign_target(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        if self.enabled {
            <V as Visit>::visit_span(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_spread_element(&mut self, node: &SpreadElement) {
        if self.enabled {
            <V as Visit>::visit_spread_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_static_block(&mut self, node: &StaticBlock) {
        if self.enabled {
            <V as Visit>::visit_static_block(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_stmt(&mut self, node: &Stmt) {
        if self.enabled {
            <V as Visit>::visit_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_stmts(&mut self, node: &[Stmt]) {
        if self.enabled {
            <V as Visit>::visit_stmts(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_str(&mut self, node: &Str) {
        if self.enabled {
            <V as Visit>::visit_str(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_super(&mut self, node: &Super) {
        if self.enabled {
            <V as Visit>::visit_super(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_super_prop(&mut self, node: &SuperProp) {
        if self.enabled {
            <V as Visit>::visit_super_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        if self.enabled {
            <V as Visit>::visit_super_prop_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_switch_case(&mut self, node: &SwitchCase) {
        if self.enabled {
            <V as Visit>::visit_switch_case(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        if self.enabled {
            <V as Visit>::visit_switch_cases(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        if self.enabled {
            <V as Visit>::visit_switch_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        if self.enabled {
            <V as Visit>::visit_syntax_context(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        if self.enabled {
            <V as Visit>::visit_tagged_tpl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_this_expr(&mut self, node: &ThisExpr) {
        if self.enabled {
            <V as Visit>::visit_this_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        if self.enabled {
            <V as Visit>::visit_throw_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_tpl(&mut self, node: &Tpl) {
        if self.enabled {
            <V as Visit>::visit_tpl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_tpl_element(&mut self, node: &TplElement) {
        if self.enabled {
            <V as Visit>::visit_tpl_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        if self.enabled {
            <V as Visit>::visit_tpl_elements(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        if self.enabled {
            <V as Visit>::visit_true_plus_minus(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_try_stmt(&mut self, node: &TryStmt) {
        if self.enabled {
            <V as Visit>::visit_try_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        if self.enabled {
            <V as Visit>::visit_unary_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_unary_op(&mut self, node: &UnaryOp) {
        if self.enabled {
            <V as Visit>::visit_unary_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        if self.enabled {
            <V as Visit>::visit_update_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_update_op(&mut self, node: &UpdateOp) {
        if self.enabled {
            <V as Visit>::visit_update_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_using_decl(&mut self, node: &UsingDecl) {
        if self.enabled {
            <V as Visit>::visit_using_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_var_decl(&mut self, node: &VarDecl) {
        if self.enabled {
            <V as Visit>::visit_var_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        if self.enabled {
            <V as Visit>::visit_var_decl_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        if self.enabled {
            <V as Visit>::visit_var_decl_or_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        if self.enabled {
            <V as Visit>::visit_var_declarator(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        if self.enabled {
            <V as Visit>::visit_var_declarators(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        if self.enabled {
            <V as Visit>::visit_while_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_with_stmt(&mut self, node: &WithStmt) {
        if self.enabled {
            <V as Visit>::visit_with_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        if self.enabled {
            <V as Visit>::visit_yield_expr(&mut self.visitor, node)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait VisitWith<V: ?Sized + Visit> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_with(&self, visitor: &mut V);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_children_with(&self, visitor: &mut V);
}
impl<V: ?Sized + Visit> VisitWith<V> for ArrayLit {
    #[doc = "Calls [Visit`::visit_array_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_array_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ArrayLit { span, elems } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Option<ExprOrSpread>> as VisitWith<V>>::visit_with(elems, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ArrayPat {
    #[doc = "Calls [Visit`::visit_array_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_array_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Option<Pat>> as VisitWith<V>>::visit_with(elems, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ArrowExpr {
    #[doc = "Calls [Visit`::visit_arrow_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_arrow_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Vec<Pat> as VisitWith<V>>::visit_with(params, visitor)
                };
                {
                    <Box<BlockStmtOrExpr> as VisitWith<V>>::visit_with(body, visitor)
                };
                {
                    <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(return_type, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignExpr {
    #[doc = "Calls [Visit`::visit_assign_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <AssignOp as VisitWith<V>>::visit_with(op, visitor)
                };
                {
                    <AssignTarget as VisitWith<V>>::visit_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(right, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignOp {
    #[doc = "Calls [Visit`::visit_assign_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignPat {
    #[doc = "Calls [Visit`::visit_assign_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignPat { span, left, right } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Pat> as VisitWith<V>>::visit_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(right, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignPatProp {
    #[doc = "Calls [Visit`::visit_assign_pat_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_pat_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignPatProp { span, key, value } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <BindingIdent as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignProp {
    #[doc = "Calls [Visit`::visit_assign_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignProp { span, key, value } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Ident as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignTarget {
    #[doc = "Calls [Visit`::visit_assign_target`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_target(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                <SimpleAssignTarget as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            AssignTarget::Pat { 0: _field_0 } => {
                <AssignTargetPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignTargetPat {
    #[doc = "Calls [Visit`::visit_assign_target_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_target_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                <ArrayPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                <ObjectPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AutoAccessor {
    #[doc = "Calls [Visit`::visit_auto_accessor`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_auto_accessor(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Key as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
                {
                    <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor)
                };
                {
                    <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AwaitExpr {
    #[doc = "Calls [Visit`::visit_await_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_await_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AwaitExpr { span, arg } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BigInt {
    #[doc = "Calls [Visit`::visit_big_int`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_big_int(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BigInt { span, value, raw } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<BigIntValue> as VisitWith<V>>::visit_with(value, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BinExpr {
    #[doc = "Calls [Visit`::visit_bin_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_bin_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <BinaryOp as VisitWith<V>>::visit_with(op, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(right, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BinaryOp {
    #[doc = "Calls [Visit`::visit_binary_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_binary_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BindingIdent {
    #[doc = "Calls [Visit`::visit_binding_ident`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_binding_ident(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BindingIdent { id, type_ann } => {
                {
                    <Ident as VisitWith<V>>::visit_with(id, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BlockStmt {
    #[doc = "Calls [Visit`::visit_block_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_block_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Vec<Stmt> as VisitWith<V>>::visit_with(stmts, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BlockStmtOrExpr {
    #[doc = "Calls [Visit`::visit_block_stmt_or_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_block_stmt_or_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                <BlockStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Bool {
    #[doc = "Calls [Visit`::visit_bool`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_bool(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Bool { span, value } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BreakStmt {
    #[doc = "Calls [Visit`::visit_break_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_break_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BreakStmt { span, label } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<Ident> as VisitWith<V>>::visit_with(label, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CallExpr {
    #[doc = "Calls [Visit`::visit_call_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_call_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Callee as VisitWith<V>>::visit_with(callee, visitor)
                };
                {
                    <Vec<ExprOrSpread> as VisitWith<V>>::visit_with(args, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Callee {
    #[doc = "Calls [Visit`::visit_callee`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_callee(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Callee::Super { 0: _field_0 } => {
                <Super as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Callee::Import { 0: _field_0 } => {
                <Import as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Callee::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CatchClause {
    #[doc = "Calls [Visit`::visit_catch_clause`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_catch_clause(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CatchClause { span, param, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<Pat> as VisitWith<V>>::visit_with(param, visitor)
                };
                {
                    <BlockStmt as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Class {
    #[doc = "Calls [Visit`::visit_class`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor)
                };
                {
                    <Vec<ClassMember> as VisitWith<V>>::visit_with(body, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(super_class, visitor)
                };
                {
                    <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                        super_type_params,
                        visitor,
                    )
                };
                {
                    <Vec<TsExprWithTypeArgs> as VisitWith<V>>::visit_with(implements, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassDecl {
    #[doc = "Calls [Visit`::visit_class_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                {
                    <Ident as VisitWith<V>>::visit_with(ident, visitor)
                };
                {
                    <Box<Class> as VisitWith<V>>::visit_with(class, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassExpr {
    #[doc = "Calls [Visit`::visit_class_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassExpr { ident, class } => {
                {
                    <Option<Ident> as VisitWith<V>>::visit_with(ident, visitor)
                };
                {
                    <Box<Class> as VisitWith<V>>::visit_with(class, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassMember {
    #[doc = "Calls [Visit`::visit_class_member`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_member(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                <Constructor as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::Method { 0: _field_0 } => {
                <ClassMethod as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::PrivateMethod { 0: _field_0 } => {
                <PrivateMethod as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                <ClassProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                <PrivateProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                <StaticBlock as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                <AutoAccessor as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassMethod {
    #[doc = "Calls [Visit`::visit_class_method`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_method(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Box<Function> as VisitWith<V>>::visit_with(function, visitor)
                };
                {
                    <MethodKind as VisitWith<V>>::visit_with(kind, visitor)
                };
                {
                    <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassProp {
    #[doc = "Calls [Visit`::visit_class_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
                {
                    <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor)
                };
                {
                    <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ComputedPropName {
    #[doc = "Calls [Visit`::visit_computed_prop_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_computed_prop_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ComputedPropName { span, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CondExpr {
    #[doc = "Calls [Visit`::visit_cond_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_cond_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(test, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(cons, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(alt, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Constructor {
    #[doc = "Calls [Visit`::visit_constructor`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_constructor(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Vec<ParamOrTsParamProp> as VisitWith<V>>::visit_with(params, visitor)
                };
                {
                    <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor)
                };
                {
                    <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ContinueStmt {
    #[doc = "Calls [Visit`::visit_continue_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_continue_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ContinueStmt { span, label } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<Ident> as VisitWith<V>>::visit_with(label, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for DebuggerStmt {
    #[doc = "Calls [Visit`::visit_debugger_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_debugger_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            DebuggerStmt { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Decl {
    #[doc = "Calls [Visit`::visit_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Decl::Class { 0: _field_0 } => {
                <ClassDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::Fn { 0: _field_0 } => {
                <FnDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::Var { 0: _field_0 } => {
                <Box<VarDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::Using { 0: _field_0 } => {
                <Box<UsingDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsInterface { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                <Box<TsTypeAliasDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsEnum { 0: _field_0 } => {
                <Box<TsEnumDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsModule { 0: _field_0 } => {
                <Box<TsModuleDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Decorator {
    #[doc = "Calls [Visit`::visit_decorator`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_decorator(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Decorator { span, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for DefaultDecl {
    #[doc = "Calls [Visit`::visit_default_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_default_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                <ClassExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                <FnExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for DoWhileStmt {
    #[doc = "Calls [Visit`::visit_do_while_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_do_while_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            DoWhileStmt { span, test, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(test, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for EmptyStmt {
    #[doc = "Calls [Visit`::visit_empty_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_empty_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            EmptyStmt { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportAll {
    #[doc = "Calls [Visit`::visit_export_all`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_all(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Str> as VisitWith<V>>::visit_with(src, visitor)
                };
                {
                    <Option<Box<ObjectLit>> as VisitWith<V>>::visit_with(with, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDecl {
    #[doc = "Calls [Visit`::visit_export_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDecl { span, decl } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Decl as VisitWith<V>>::visit_with(decl, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDefaultDecl {
    #[doc = "Calls [Visit`::visit_export_default_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_default_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDefaultDecl { span, decl } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <DefaultDecl as VisitWith<V>>::visit_with(decl, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDefaultExpr {
    #[doc = "Calls [Visit`::visit_export_default_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_default_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDefaultExpr { span, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDefaultSpecifier {
    #[doc = "Calls [Visit`::visit_export_default_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_default_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDefaultSpecifier { exported } => {
                {
                    <Ident as VisitWith<V>>::visit_with(exported, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportNamedSpecifier {
    #[doc = "Calls [Visit`::visit_export_named_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_named_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <ModuleExportName as VisitWith<V>>::visit_with(orig, visitor)
                };
                {
                    <Option<ModuleExportName> as VisitWith<V>>::visit_with(exported, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [Visit`::visit_export_namespace_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_namespace_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <ModuleExportName as VisitWith<V>>::visit_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportSpecifier {
    #[doc = "Calls [Visit`::visit_export_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                <ExportNamespaceSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                <ExportDefaultSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                <ExportNamedSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Expr {
    #[doc = "Calls [Visit`::visit_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Expr::This { 0: _field_0 } => {
                <ThisExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Array { 0: _field_0 } => {
                <ArrayLit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Object { 0: _field_0 } => {
                <ObjectLit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Fn { 0: _field_0 } => {
                <FnExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Unary { 0: _field_0 } => {
                <UnaryExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Update { 0: _field_0 } => {
                <UpdateExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Bin { 0: _field_0 } => {
                <BinExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Assign { 0: _field_0 } => {
                <AssignExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Member { 0: _field_0 } => {
                <MemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Cond { 0: _field_0 } => {
                <CondExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Call { 0: _field_0 } => {
                <CallExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::New { 0: _field_0 } => {
                <NewExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Seq { 0: _field_0 } => {
                <SeqExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Lit { 0: _field_0 } => {
                <Lit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Tpl { 0: _field_0 } => {
                <Tpl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                <TaggedTpl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Arrow { 0: _field_0 } => {
                <ArrowExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Class { 0: _field_0 } => {
                <ClassExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Yield { 0: _field_0 } => {
                <YieldExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::MetaProp { 0: _field_0 } => {
                <MetaPropExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Await { 0: _field_0 } => {
                <AwaitExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Paren { 0: _field_0 } => {
                <ParenExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXMember { 0: _field_0 } => {
                <JSXMemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                <JSXEmptyExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                <TsConstAssertion as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExprOrSpread {
    #[doc = "Calls [Visit`::visit_expr_or_spread`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr_or_spread(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExprOrSpread { spread, expr } => {
                {
                    <Option<swc_common::Span> as VisitWith<V>>::visit_with(spread, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExprStmt {
    #[doc = "Calls [Visit`::visit_expr_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExprStmt { span, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for FnDecl {
    #[doc = "Calls [Visit`::visit_fn_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_fn_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                {
                    <Ident as VisitWith<V>>::visit_with(ident, visitor)
                };
                {
                    <Box<Function> as VisitWith<V>>::visit_with(function, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for FnExpr {
    #[doc = "Calls [Visit`::visit_fn_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_fn_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            FnExpr { ident, function } => {
                {
                    <Option<Ident> as VisitWith<V>>::visit_with(ident, visitor)
                };
                {
                    <Box<Function> as VisitWith<V>>::visit_with(function, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForHead {
    #[doc = "Calls [Visit`::visit_for_head`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_head(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                <Box<UsingDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ForHead::Pat { 0: _field_0 } => {
                <Box<Pat> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForInStmt {
    #[doc = "Calls [Visit`::visit_for_in_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_in_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <ForHead as VisitWith<V>>::visit_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(right, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForOfStmt {
    #[doc = "Calls [Visit`::visit_for_of_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_of_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <ForHead as VisitWith<V>>::visit_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(right, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForStmt {
    #[doc = "Calls [Visit`::visit_for_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<VarDeclOrExpr> as VisitWith<V>>::visit_with(init, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(test, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(update, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Function {
    #[doc = "Calls [Visit`::visit_function`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_function(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                {
                    <Vec<Param> as VisitWith<V>>::visit_with(params, visitor)
                };
                {
                    <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor)
                };
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor)
                };
                {
                    <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(return_type, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for GetterProp {
    #[doc = "Calls [Visit`::visit_getter_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_getter_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
                {
                    <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Ident {
    #[doc = "Calls [Visit`::visit_ident`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ident(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(sym, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for IdentName {
    #[doc = "Calls [Visit`::visit_ident_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ident_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            IdentName { span, sym } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(sym, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for IfStmt {
    #[doc = "Calls [Visit`::visit_if_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_if_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(test, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(cons, visitor)
                };
                {
                    <Option<Box<Stmt>> as VisitWith<V>>::visit_with(alt, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Import {
    #[doc = "Calls [Visit`::visit_import`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Import { span, phase } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <ImportPhase as VisitWith<V>>::visit_with(phase, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportDecl {
    #[doc = "Calls [Visit`::visit_import_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<ImportSpecifier> as VisitWith<V>>::visit_with(specifiers, visitor)
                };
                {
                    <Box<Str> as VisitWith<V>>::visit_with(src, visitor)
                };
                {
                    <Option<Box<ObjectLit>> as VisitWith<V>>::visit_with(with, visitor)
                };
                {
                    <ImportPhase as VisitWith<V>>::visit_with(phase, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportDefaultSpecifier {
    #[doc = "Calls [Visit`::visit_import_default_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_default_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Ident as VisitWith<V>>::visit_with(local, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportNamedSpecifier {
    #[doc = "Calls [Visit`::visit_import_named_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_named_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Ident as VisitWith<V>>::visit_with(local, visitor)
                };
                {
                    <Option<ModuleExportName> as VisitWith<V>>::visit_with(imported, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportPhase {
    #[doc = "Calls [Visit`::visit_import_phase`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_phase(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportSpecifier {
    #[doc = "Calls [Visit`::visit_import_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                <ImportNamedSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                <ImportDefaultSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                <ImportStarAsSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportStarAsSpecifier {
    #[doc = "Calls [Visit`::visit_import_star_as_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_star_as_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Ident as VisitWith<V>>::visit_with(local, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportWith {
    #[doc = "Calls [Visit`::visit_import_with`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_with(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportWith { span, values } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<ImportWithItem> as VisitWith<V>>::visit_with(values, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportWithItem {
    #[doc = "Calls [Visit`::visit_import_with_item`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_with_item(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportWithItem { key, value } => {
                {
                    <IdentName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Str as VisitWith<V>>::visit_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Invalid {
    #[doc = "Calls [Visit`::visit_invalid`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_invalid(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Invalid { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttr {
    #[doc = "Calls [Visit`::visit_jsx_attr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttr { span, name, value } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <JSXAttrName as VisitWith<V>>::visit_with(name, visitor)
                };
                {
                    <Option<JSXAttrValue> as VisitWith<V>>::visit_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttrName {
    #[doc = "Calls [Visit`::visit_jsx_attr_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttrOrSpread {
    #[doc = "Calls [Visit`::visit_jsx_attr_or_spread`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_or_spread(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                <JSXAttr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                <SpreadElement as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttrValue {
    #[doc = "Calls [Visit`::visit_jsx_attr_value`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_value(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                <Lit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXClosingElement {
    #[doc = "Calls [Visit`::visit_jsx_closing_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_closing_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXClosingElement { span, name } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <JSXElementName as VisitWith<V>>::visit_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXClosingFragment {
    #[doc = "Calls [Visit`::visit_jsx_closing_fragment`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_closing_fragment(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXClosingFragment { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXElement {
    #[doc = "Calls [Visit`::visit_jsx_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <JSXOpeningElement as VisitWith<V>>::visit_with(opening, visitor)
                };
                {
                    <Vec<JSXElementChild> as VisitWith<V>>::visit_with(children, visitor)
                };
                {
                    <Option<JSXClosingElement> as VisitWith<V>>::visit_with(closing, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXElementChild {
    #[doc = "Calls [Visit`::visit_jsx_element_child`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element_child(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                <JSXText as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                <JSXSpreadChild as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXElementName {
    #[doc = "Calls [Visit`::visit_jsx_element_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                <JSXMemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXEmptyExpr {
    #[doc = "Calls [Visit`::visit_jsx_empty_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_empty_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXEmptyExpr { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXExpr {
    #[doc = "Calls [Visit`::visit_jsx_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                <JSXEmptyExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXExprContainer {
    #[doc = "Calls [Visit`::visit_jsx_expr_container`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_expr_container(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXExprContainer { span, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <JSXExpr as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXFragment {
    #[doc = "Calls [Visit`::visit_jsx_fragment`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_fragment(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <JSXOpeningFragment as VisitWith<V>>::visit_with(opening, visitor)
                };
                {
                    <Vec<JSXElementChild> as VisitWith<V>>::visit_with(children, visitor)
                };
                {
                    <JSXClosingFragment as VisitWith<V>>::visit_with(closing, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXMemberExpr {
    #[doc = "Calls [Visit`::visit_jsx_member_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_member_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <JSXObject as VisitWith<V>>::visit_with(obj, visitor)
                };
                {
                    <IdentName as VisitWith<V>>::visit_with(prop, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXNamespacedName {
    #[doc = "Calls [Visit`::visit_jsx_namespaced_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_namespaced_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <IdentName as VisitWith<V>>::visit_with(ns, visitor)
                };
                {
                    <IdentName as VisitWith<V>>::visit_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXObject {
    #[doc = "Calls [Visit`::visit_jsx_object`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_object(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                <Box<JSXMemberExpr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXObject::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXOpeningElement {
    #[doc = "Calls [Visit`::visit_jsx_opening_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_opening_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                {
                    <JSXElementName as VisitWith<V>>::visit_with(name, visitor)
                };
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<JSXAttrOrSpread> as VisitWith<V>>::visit_with(attrs, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXOpeningFragment {
    #[doc = "Calls [Visit`::visit_jsx_opening_fragment`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_opening_fragment(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXOpeningFragment { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXSpreadChild {
    #[doc = "Calls [Visit`::visit_jsx_spread_child`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_spread_child(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXSpreadChild { span, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXText {
    #[doc = "Calls [Visit`::visit_jsx_text`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_text(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXText { span, value, raw } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(value, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Key {
    #[doc = "Calls [Visit`::visit_key`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_key(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Key::Private { 0: _field_0 } => {
                <PrivateName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Key::Public { 0: _field_0 } => {
                <PropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for KeyValuePatProp {
    #[doc = "Calls [Visit`::visit_key_value_pat_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_key_value_pat_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            KeyValuePatProp { key, value } => {
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Box<Pat> as VisitWith<V>>::visit_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for KeyValueProp {
    #[doc = "Calls [Visit`::visit_key_value_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_key_value_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            KeyValueProp { key, value } => {
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for LabeledStmt {
    #[doc = "Calls [Visit`::visit_labeled_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_labeled_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            LabeledStmt { span, label, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Ident as VisitWith<V>>::visit_with(label, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Lit {
    #[doc = "Calls [Visit`::visit_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Lit::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Bool { 0: _field_0 } => {
                <Bool as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Null { 0: _field_0 } => {
                <Null as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Num { 0: _field_0 } => {
                <Number as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::BigInt { 0: _field_0 } => {
                <BigInt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Regex { 0: _field_0 } => {
                <Regex as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::JSXText { 0: _field_0 } => {
                <JSXText as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MemberExpr {
    #[doc = "Calls [Visit`::visit_member_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_member_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MemberExpr { span, obj, prop } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(obj, visitor)
                };
                {
                    <MemberProp as VisitWith<V>>::visit_with(prop, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MemberProp {
    #[doc = "Calls [Visit`::visit_member_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_member_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            MemberProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MetaPropExpr {
    #[doc = "Calls [Visit`::visit_meta_prop_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_meta_prop_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MetaPropExpr { span, kind } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <MetaPropKind as VisitWith<V>>::visit_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MetaPropKind {
    #[doc = "Calls [Visit`::visit_meta_prop_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_meta_prop_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MethodKind {
    #[doc = "Calls [Visit`::visit_method_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_method_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MethodProp {
    #[doc = "Calls [Visit`::visit_method_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_method_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MethodProp { key, function } => {
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Box<Function> as VisitWith<V>>::visit_with(function, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Module {
    #[doc = "Calls [Visit`::visit_module`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<ModuleItem> as VisitWith<V>>::visit_with(body, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(shebang, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ModuleDecl {
    #[doc = "Calls [Visit`::visit_module_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                <ImportDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                <ExportDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                <NamedExport as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                <ExportDefaultDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                <ExportDefaultExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                <ExportAll as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                <Box<TsImportEqualsDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                <TsExportAssignment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                <TsNamespaceExportDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ModuleExportName {
    #[doc = "Calls [Visit`::visit_module_export_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_export_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleExportName::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ModuleItem {
    #[doc = "Calls [Visit`::visit_module_item`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_item(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                <ModuleDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                <Stmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for NamedExport {
    #[doc = "Calls [Visit`::visit_named_export`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_named_export(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<ExportSpecifier> as VisitWith<V>>::visit_with(specifiers, visitor)
                };
                {
                    <Option<Box<Str>> as VisitWith<V>>::visit_with(src, visitor)
                };
                {
                    <Option<Box<ObjectLit>> as VisitWith<V>>::visit_with(with, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for NewExpr {
    #[doc = "Calls [Visit`::visit_new_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_new_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(callee, visitor)
                };
                {
                    <Option<Vec<ExprOrSpread>> as VisitWith<V>>::visit_with(args, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Null {
    #[doc = "Calls [Visit`::visit_null`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_null(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Null { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Number {
    #[doc = "Calls [Visit`::visit_number`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_number(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Number { span, value, raw } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ObjectLit {
    #[doc = "Calls [Visit`::visit_object_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ObjectLit { span, props } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<PropOrSpread> as VisitWith<V>>::visit_with(props, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ObjectPat {
    #[doc = "Calls [Visit`::visit_object_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<ObjectPatProp> as VisitWith<V>>::visit_with(props, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ObjectPatProp {
    #[doc = "Calls [Visit`::visit_object_pat_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_pat_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                <KeyValuePatProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                <AssignPatProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                <RestPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for OptCall {
    #[doc = "Calls [Visit`::visit_opt_call`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_call(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(callee, visitor)
                };
                {
                    <Vec<ExprOrSpread> as VisitWith<V>>::visit_with(args, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for OptChainBase {
    #[doc = "Calls [Visit`::visit_opt_chain_base`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_chain_base(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                <MemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            OptChainBase::Call { 0: _field_0 } => {
                <OptCall as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for OptChainExpr {
    #[doc = "Calls [Visit`::visit_opt_chain_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_chain_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<OptChainBase> as VisitWith<V>>::visit_with(base, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Param {
    #[doc = "Calls [Visit`::visit_param`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_param(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor)
                };
                {
                    <Pat as VisitWith<V>>::visit_with(pat, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ParamOrTsParamProp {
    #[doc = "Calls [Visit`::visit_param_or_ts_param_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_param_or_ts_param_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                <TsParamProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                <Param as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ParenExpr {
    #[doc = "Calls [Visit`::visit_paren_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_paren_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ParenExpr { span, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Pat {
    #[doc = "Calls [Visit`::visit_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Array { 0: _field_0 } => {
                <ArrayPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Rest { 0: _field_0 } => {
                <RestPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Object { 0: _field_0 } => {
                <ObjectPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Assign { 0: _field_0 } => {
                <AssignPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PrivateMethod {
    #[doc = "Calls [Visit`::visit_private_method`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_private_method(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <PrivateName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Box<Function> as VisitWith<V>>::visit_with(function, visitor)
                };
                {
                    <MethodKind as VisitWith<V>>::visit_with(kind, visitor)
                };
                {
                    <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PrivateName {
    #[doc = "Calls [Visit`::visit_private_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_private_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PrivateName { span, name } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PrivateProp {
    #[doc = "Calls [Visit`::visit_private_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_private_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <PrivateName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
                {
                    <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor)
                };
                {
                    <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Program {
    #[doc = "Calls [Visit`::visit_program`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_program(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Program::Module { 0: _field_0 } => {
                <Module as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Program::Script { 0: _field_0 } => {
                <Script as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Prop {
    #[doc = "Calls [Visit`::visit_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::KeyValue { 0: _field_0 } => {
                <KeyValueProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Assign { 0: _field_0 } => {
                <AssignProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Getter { 0: _field_0 } => {
                <GetterProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Setter { 0: _field_0 } => {
                <SetterProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Method { 0: _field_0 } => {
                <MethodProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PropName {
    #[doc = "Calls [Visit`::visit_prop_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::Num { 0: _field_0 } => {
                <Number as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::BigInt { 0: _field_0 } => {
                <BigInt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PropOrSpread {
    #[doc = "Calls [Visit`::visit_prop_or_spread`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop_or_spread(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                <SpreadElement as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                <Box<Prop> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Regex {
    #[doc = "Calls [Visit`::visit_regex`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_regex(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Regex { span, exp, flags } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(exp, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(flags, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for RestPat {
    #[doc = "Calls [Visit`::visit_rest_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_rest_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(dot3_token, visitor)
                };
                {
                    <Box<Pat> as VisitWith<V>>::visit_with(arg, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ReturnStmt {
    #[doc = "Calls [Visit`::visit_return_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_return_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ReturnStmt { span, arg } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Script {
    #[doc = "Calls [Visit`::visit_script`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_script(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(shebang, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SeqExpr {
    #[doc = "Calls [Visit`::visit_seq_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_seq_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SeqExpr { span, exprs } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Box<Expr>> as VisitWith<V>>::visit_with(exprs, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SetterProp {
    #[doc = "Calls [Visit`::visit_setter_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_setter_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <PropName as VisitWith<V>>::visit_with(key, visitor)
                };
                {
                    <Option<Pat> as VisitWith<V>>::visit_with(this_param, visitor)
                };
                {
                    <Box<Pat> as VisitWith<V>>::visit_with(param, visitor)
                };
                {
                    <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SimpleAssignTarget {
    #[doc = "Calls [Visit`::visit_simple_assign_target`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_simple_assign_target(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                <MemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                <ParenExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SpreadElement {
    #[doc = "Calls [Visit`::visit_spread_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_spread_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SpreadElement { dot3_token, expr } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(dot3_token, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for StaticBlock {
    #[doc = "Calls [Visit`::visit_static_block`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_static_block(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            StaticBlock { span, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <BlockStmt as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Stmt {
    #[doc = "Calls [Visit`::visit_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                <BlockStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Debugger { 0: _field_0 } => {
                <DebuggerStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::With { 0: _field_0 } => {
                <WithStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Return { 0: _field_0 } => {
                <ReturnStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Labeled { 0: _field_0 } => {
                <LabeledStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Break { 0: _field_0 } => {
                <BreakStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Continue { 0: _field_0 } => {
                <ContinueStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::If { 0: _field_0 } => {
                <IfStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Switch { 0: _field_0 } => {
                <SwitchStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Throw { 0: _field_0 } => {
                <ThrowStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Try { 0: _field_0 } => {
                <Box<TryStmt> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::While { 0: _field_0 } => {
                <WhileStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::DoWhile { 0: _field_0 } => {
                <DoWhileStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::For { 0: _field_0 } => {
                <ForStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::ForIn { 0: _field_0 } => {
                <ForInStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::ForOf { 0: _field_0 } => {
                <ForOfStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Decl { 0: _field_0 } => {
                <Decl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Expr { 0: _field_0 } => {
                <ExprStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Str {
    #[doc = "Calls [Visit`::visit_str`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_str(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Str { span, value, raw } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(value, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Super {
    #[doc = "Calls [Visit`::visit_super`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_super(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Super { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SuperProp {
    #[doc = "Calls [Visit`::visit_super_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_super_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SuperProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SuperPropExpr {
    #[doc = "Calls [Visit`::visit_super_prop_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_super_prop_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Super as VisitWith<V>>::visit_with(obj, visitor)
                };
                {
                    <SuperProp as VisitWith<V>>::visit_with(prop, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SwitchCase {
    #[doc = "Calls [Visit`::visit_switch_case`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_switch_case(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SwitchCase { span, test, cons } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(test, visitor)
                };
                {
                    <Vec<Stmt> as VisitWith<V>>::visit_with(cons, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SwitchStmt {
    #[doc = "Calls [Visit`::visit_switch_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_switch_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(discriminant, visitor)
                };
                {
                    <Vec<SwitchCase> as VisitWith<V>>::visit_with(cases, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TaggedTpl {
    #[doc = "Calls [Visit`::visit_tagged_tpl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tagged_tpl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(tag, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                        type_params,
                        visitor,
                    )
                };
                {
                    <Box<Tpl> as VisitWith<V>>::visit_with(tpl, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ThisExpr {
    #[doc = "Calls [Visit`::visit_this_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_this_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ThisExpr { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ThrowStmt {
    #[doc = "Calls [Visit`::visit_throw_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_throw_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ThrowStmt { span, arg } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Tpl {
    #[doc = "Calls [Visit`::visit_tpl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tpl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Box<Expr>> as VisitWith<V>>::visit_with(exprs, visitor)
                };
                {
                    <Vec<TplElement> as VisitWith<V>>::visit_with(quasis, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TplElement {
    #[doc = "Calls [Visit`::visit_tpl_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tpl_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(cooked, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TruePlusMinus {
    #[doc = "Calls [Visit`::visit_true_plus_minus`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_true_plus_minus(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TryStmt {
    #[doc = "Calls [Visit`::visit_try_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_try_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <BlockStmt as VisitWith<V>>::visit_with(block, visitor)
                };
                {
                    <Option<CatchClause> as VisitWith<V>>::visit_with(handler, visitor)
                };
                {
                    <Option<BlockStmt> as VisitWith<V>>::visit_with(finalizer, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UnaryExpr {
    #[doc = "Calls [Visit`::visit_unary_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_unary_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UnaryExpr { span, op, arg } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <UnaryOp as VisitWith<V>>::visit_with(op, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UnaryOp {
    #[doc = "Calls [Visit`::visit_unary_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_unary_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UpdateExpr {
    #[doc = "Calls [Visit`::visit_update_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_update_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <UpdateOp as VisitWith<V>>::visit_with(op, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UpdateOp {
    #[doc = "Calls [Visit`::visit_update_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_update_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UsingDecl {
    #[doc = "Calls [Visit`::visit_using_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_using_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<VarDeclarator> as VisitWith<V>>::visit_with(decls, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDecl {
    #[doc = "Calls [Visit`::visit_var_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitWith<V>>::visit_with(ctxt, visitor)
                };
                {
                    <VarDeclKind as VisitWith<V>>::visit_with(kind, visitor)
                };
                {
                    <Vec<VarDeclarator> as VisitWith<V>>::visit_with(decls, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDeclKind {
    #[doc = "Calls [Visit`::visit_var_decl_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_decl_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDeclOrExpr {
    #[doc = "Calls [Visit`::visit_var_decl_or_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_decl_or_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDeclarator {
    #[doc = "Calls [Visit`::visit_var_declarator`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_declarator(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Pat as VisitWith<V>>::visit_with(name, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(init, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for WhileStmt {
    #[doc = "Calls [Visit`::visit_while_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_while_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            WhileStmt { span, test, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(test, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for WithStmt {
    #[doc = "Calls [Visit`::visit_with_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_with_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            WithStmt { span, obj, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitWith<V>>::visit_with(obj, visitor)
                };
                {
                    <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for YieldExpr {
    #[doc = "Calls [Visit`::visit_yield_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_yield_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitWith<V>>::visit_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_atoms::Atom {
    #[doc = "Calls [Visit`::visit_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_atom(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BigIntValue {
    #[doc = "Calls [Visit`::visit_big_int_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_big_int_value(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ClassMember] {
    #[doc = "Calls [Visit`::visit_class_members`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_members(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ClassMember as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Decorator] {
    #[doc = "Calls [Visit`::visit_decorators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_decorators(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Decorator as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ExportSpecifier] {
    #[doc = "Calls [Visit`::visit_export_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_specifiers(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ExportSpecifier as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ExprOrSpread] {
    #[doc = "Calls [Visit`::visit_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ExprOrSpread as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Box<Expr>] {
    #[doc = "Calls [Visit`::visit_exprs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_exprs(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Box<Expr> as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ImportSpecifier] {
    #[doc = "Calls [Visit`::visit_import_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_specifiers(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ImportSpecifier as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ImportWithItem] {
    #[doc = "Calls [Visit`::visit_import_with_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_with_items(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ImportWithItem as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [JSXAttrOrSpread] {
    #[doc = "Calls [Visit`::visit_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <JSXAttrOrSpread as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [JSXElementChild] {
    #[doc = "Calls [Visit`::visit_jsx_element_childs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element_childs(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <JSXElementChild as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ModuleItem] {
    #[doc = "Calls [Visit`::visit_module_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_items(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ModuleItem as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ObjectPatProp] {
    #[doc = "Calls [Visit`::visit_object_pat_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_pat_props(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ObjectPatProp as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [Visit`::visit_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_atom(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<BlockStmt> {
    #[doc = "Calls [Visit`::visit_opt_block_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_block_stmt(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <BlockStmt as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<CatchClause> {
    #[doc = "Calls [Visit`::visit_opt_catch_clause`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_catch_clause(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <CatchClause as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<Expr>> {
    #[doc = "Calls [Visit`::visit_opt_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_expr(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Expr> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<ExprOrSpread> {
    #[doc = "Calls [Visit`::visit_opt_expr_or_spread`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_expr_or_spread(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <ExprOrSpread as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [Visit`::visit_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Vec<ExprOrSpread> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Ident> {
    #[doc = "Calls [Visit`::visit_opt_ident`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ident(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Ident as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<JSXAttrValue> {
    #[doc = "Calls [Visit`::visit_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_jsx_attr_value(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXAttrValue as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<JSXClosingElement> {
    #[doc = "Calls [Visit`::visit_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_jsx_closing_element(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXClosingElement as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<ModuleExportName> {
    #[doc = "Calls [Visit`::visit_opt_module_export_name`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_module_export_name(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <ModuleExportName as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [Visit`::visit_opt_object_lit`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_object_lit(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<ObjectLit> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Pat> {
    #[doc = "Calls [Visit`::visit_opt_pat`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_pat(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Pat as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<swc_common::Span> {
    #[doc = "Calls [Visit`::visit_opt_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_span(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_common::Span as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<Stmt>> {
    #[doc = "Calls [Visit`::visit_opt_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_stmt(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Stmt> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<Str>> {
    #[doc = "Calls [Visit`::visit_opt_str`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_str(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Str> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [Visit`::visit_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_var_decl_or_expr(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <VarDeclOrExpr as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Option<ExprOrSpread>] {
    #[doc = "Calls [Visit`::visit_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_vec_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Option<ExprOrSpread> as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Option<Pat>] {
    #[doc = "Calls [Visit`::visit_opt_vec_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_vec_pats(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Option<Pat> as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ParamOrTsParamProp] {
    #[doc = "Calls [Visit`::visit_param_or_ts_param_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_param_or_ts_param_props(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ParamOrTsParamProp as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Param] {
    #[doc = "Calls [Visit`::visit_params`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_params(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Param as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Pat] {
    #[doc = "Calls [Visit`::visit_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_pats(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Pat as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [PropOrSpread] {
    #[doc = "Calls [Visit`::visit_prop_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <PropOrSpread as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_common::Span {
    #[doc = "Calls [Visit`::visit_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_span(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Stmt] {
    #[doc = "Calls [Visit`::visit_stmts`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_stmts(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Stmt as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [SwitchCase] {
    #[doc = "Calls [Visit`::visit_switch_cases`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_switch_cases(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <SwitchCase as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_common::SyntaxContext {
    #[doc = "Calls [Visit`::visit_syntax_context`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_syntax_context(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TplElement] {
    #[doc = "Calls [Visit`::visit_tpl_elements`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tpl_elements(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TplElement as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [VarDeclarator] {
    #[doc = "Calls [Visit`::visit_var_declarators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_declarators(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <VarDeclarator as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V, T> VisitWith<V> for std::boxed::Box<T>
where
    V: ?Sized + Visit,
    T: VisitWith<V>,
{
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        let v = <T as VisitWith<V>>::visit_with(&**self, visitor);
        v
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        let v = <T as VisitWith<V>>::visit_children_with(&**self, visitor);
        v
    }
}
impl<V, T> VisitWith<V> for std::vec::Vec<T>
where
    V: ?Sized + Visit,
    [T]: VisitWith<V>,
{
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        let v = <[T] as VisitWith<V>>::visit_with(self, visitor);
        v
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        let v = <[T] as VisitWith<V>>::visit_children_with(self, visitor);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitAstPath {
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ArrayLit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ArrayPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ArrowExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignPatProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignTarget as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignTargetPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_atoms::Atom as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AutoAccessor as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <AwaitExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_big_int<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigInt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BigInt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BigIntValue as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BinExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BinaryOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BindingIdent as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BlockStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BlockStmtOrExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, __ast_path: &mut AstNodePath<'r>) {
        <Bool as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BreakStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CallExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, __ast_path: &mut AstNodePath<'r>) {
        <Callee as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CatchClause as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, __ast_path: &mut AstNodePath<'r>) {
        <Class as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassMember as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ClassMember] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassMethod as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ComputedPropName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CondExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Constructor as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ContinueStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <DebuggerStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, __ast_path: &mut AstNodePath<'r>) {
        <Decl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Decorator as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[Decorator] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <DefaultDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <DoWhileStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <EmptyStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportAll as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDefaultDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDefaultExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDefaultSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportNamedSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportNamespaceSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ExportSpecifier] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, __ast_path: &mut AstNodePath<'r>) {
        <Expr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExprOrSpread as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ExprOrSpread] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ExprStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[Box<Expr>] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_fn_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <FnDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_fn_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <FnExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ForHead as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ForInStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ForOfStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ForStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Function as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <GetterProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, __ast_path: &mut AstNodePath<'r>) {
        <Ident as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <IdentName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_if_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <IfStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, __ast_path: &mut AstNodePath<'r>) {
        <Import as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportDefaultSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportNamedSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportPhase as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ImportSpecifier] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportStarAsSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportWith as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportWithItem as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ImportWithItem] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_invalid<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Invalid,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Invalid as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttrName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttrOrSpread as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[JSXAttrOrSpread] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttrValue as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXClosingElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXClosingFragment as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXElementChild as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[JSXElementChild] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXElementName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXEmptyExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXExprContainer as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXFragment as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXMemberExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXNamespacedName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXObject as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXOpeningElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXOpeningFragment as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXSpreadChild as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXText as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, __ast_path: &mut AstNodePath<'r>) {
        <Key as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <KeyValuePatProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <KeyValueProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <LabeledStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, __ast_path: &mut AstNodePath<'r>) {
        <Lit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <MemberExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <MemberProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <MetaPropExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <MetaPropKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <MethodKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <MethodProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, __ast_path: &mut AstNodePath<'r>) {
        <Module as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ModuleDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ModuleExportName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ModuleItem as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ModuleItem] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <NamedExport as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <NewExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, __ast_path: &mut AstNodePath<'r>) {
        <Null as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, __ast_path: &mut AstNodePath<'r>) {
        <Number as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ObjectLit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ObjectPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ObjectPatProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ObjectPatProp] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<swc_atoms::Atom> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<BlockStmt> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <OptCall as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<CatchClause> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <OptChainBase as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <OptChainExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<Expr>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<ExprOrSpread> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Vec<ExprOrSpread>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Ident> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<JSXAttrValue> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<JSXClosingElement> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<ModuleExportName> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<ObjectLit>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Pat> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<swc_common::Span> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<Stmt>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<Str>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<VarDeclOrExpr> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[Option<ExprOrSpread>] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[Option<Pat>] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, __ast_path: &mut AstNodePath<'r>) {
        <Param as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ParamOrTsParamProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ParamOrTsParamProp] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Param],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[Param] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ParenExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, __ast_path: &mut AstNodePath<'r>) {
        <Pat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], __ast_path: &mut AstNodePath<'r>) {
        <[Pat] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <PrivateMethod as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <PrivateName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <PrivateProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_program<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Program,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Program as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, __ast_path: &mut AstNodePath<'r>) {
        <Prop as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <PropName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <PropOrSpread as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[PropOrSpread] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, __ast_path: &mut AstNodePath<'r>) {
        <Regex as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <RestPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ReturnStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, __ast_path: &mut AstNodePath<'r>) {
        <Script as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SeqExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SetterProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SimpleAssignTarget as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_common::Span as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SpreadElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <StaticBlock as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, __ast_path: &mut AstNodePath<'r>) {
        <Stmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], __ast_path: &mut AstNodePath<'r>) {
        <[Stmt] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, __ast_path: &mut AstNodePath<'r>) {
        <Str as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, __ast_path: &mut AstNodePath<'r>) {
        <Super as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SuperProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SuperPropExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SwitchCase as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[SwitchCase] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <SwitchStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_common::SyntaxContext as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <TaggedTpl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ThisExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ThrowStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, __ast_path: &mut AstNodePath<'r>) {
        <Tpl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <TplElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[TplElement] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <TruePlusMinus as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <TryStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <UnaryExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <UnaryOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <UpdateExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <UpdateOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <UsingDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDeclKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDeclOrExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDeclarator as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[VarDeclarator] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <WhileStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <WithStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <YieldExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for &mut V
where
    V: ?Sized + VisitAstPath,
{
    #[inline]
    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_arrow_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_auto_accessor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_await_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_big_int<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigInt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_bin_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binding_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_bool(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_break_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_call_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_callee(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_member(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_members(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_computed_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_cond_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_constructor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_continue_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_debugger_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_do_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_empty_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_all(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_namespace_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_exprs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_fn_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_fn_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_head(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_in_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_of_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_function(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_getter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ident_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_if_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_if_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_import(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_phase(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_star_as_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_invalid<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Invalid,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_invalid(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_childs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_empty_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr_container(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_namespaced_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_object(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_spread_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_text(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_key(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_labeled_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_module(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_named_export(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_new_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_null(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_number(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_call(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_base(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_param(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Param],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_params(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_paren_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_program<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Program,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_program(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_regex(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_rest_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_return_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_script(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_seq_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_setter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_simple_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_spread_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_static_block(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_stmts(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_super(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_case(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_cases(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_syntax_context(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tagged_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_this_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_throw_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_elements(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_true_plus_minus(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_try_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_using_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_with_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_yield_expr(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for Box<V>
where
    V: ?Sized + VisitAstPath,
{
    #[inline]
    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_arrow_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_auto_accessor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_await_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_big_int<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigInt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_bin_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binding_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_bool(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_break_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_call_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_callee(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_member(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_members(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_computed_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_cond_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_constructor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_continue_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_debugger_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_do_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_empty_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_all(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_namespace_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_exprs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_fn_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_fn_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_head(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_in_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_of_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_function(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_getter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ident_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_if_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_if_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_import(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_phase(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_star_as_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_invalid<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Invalid,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_invalid(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_childs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_empty_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr_container(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_namespaced_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_object(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_spread_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_text(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_key(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_labeled_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_module(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_named_export(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_new_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_null(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_number(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_call(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_base(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_param(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Param],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_params(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_paren_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_program<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Program,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_program(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_regex(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_rest_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_return_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_script(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_seq_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_setter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_simple_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_spread_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_static_block(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_stmts(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_super(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_case(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_cases(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_syntax_context(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tagged_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_this_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_throw_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_elements(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_true_plus_minus(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_try_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_using_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_with_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_yield_expr(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> VisitAstPath for ::swc_visit::Either<A, B>
where
    A: VisitAstPath,
    B: VisitAstPath,
{
    #[inline]
    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_array_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_array_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_array_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_array_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_arrow_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_arrow_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_target(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_target(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_target_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_target_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_atom(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_auto_accessor(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_auto_accessor(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_await_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_await_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_big_int<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigInt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_big_int(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_big_int(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_big_int_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_big_int_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_bin_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_bin_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_binary_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_binary_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_binding_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_binding_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_block_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_block_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_block_stmt_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_block_stmt_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_bool(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_bool(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_break_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_break_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_call_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_call_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_callee(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_callee(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_catch_clause(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_catch_clause(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_member(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_member(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_members(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_members(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_method(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_method(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_computed_prop_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_computed_prop_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_cond_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_cond_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_constructor(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_constructor(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_continue_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_continue_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_debugger_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_debugger_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_decl(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_decorator(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_decorator(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_decorators(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_decorators(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_default_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_default_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_do_while_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_do_while_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_empty_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_empty_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_all(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_all(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_default_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_default_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_default_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_default_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_default_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_default_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_named_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_named_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_namespace_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_namespace_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_specifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_specifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_expr(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_expr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_expr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_expr_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_expr_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_exprs(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_exprs(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_fn_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_fn_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_fn_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_fn_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_fn_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_fn_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_for_head(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_for_head(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_for_in_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_for_in_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_for_of_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_for_of_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_for_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_for_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_function(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_function(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_getter_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_getter_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ident_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ident_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_if_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_if_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_if_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_default_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_default_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_named_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_named_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_phase(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_phase(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_specifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_specifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_star_as_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_star_as_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_with(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_with(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_with_item(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_with_item(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_with_items(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_with_items(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_invalid<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Invalid,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_invalid(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_invalid(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_closing_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_closing_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_closing_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_closing_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element_child(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element_child(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element_childs(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element_childs(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_empty_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_empty_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_expr_container(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_expr_container(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_member_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_member_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_namespaced_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_namespaced_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_object(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_object(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_opening_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_opening_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_opening_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_opening_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_spread_child(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_spread_child(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_text(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_text(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_key(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_key(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_key_value_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_key_value_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_key_value_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_key_value_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_labeled_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_labeled_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_lit(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_lit(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_member_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_member_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_member_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_member_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_meta_prop_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_meta_prop_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_meta_prop_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_meta_prop_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_method_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_method_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_method_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_method_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_export_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_export_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_item(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_item(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_items(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_items(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_named_export(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_named_export(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_new_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_new_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_null(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_null(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_number(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_number(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_pat_props(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_pat_props(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_block_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_block_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_call(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_call(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_catch_clause(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_catch_clause(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_chain_base(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_chain_base(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_chain_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_chain_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_expr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_expr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_jsx_attr_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_jsx_attr_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_jsx_closing_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_jsx_closing_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_module_export_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_module_export_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_object_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_object_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_span(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_span(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_str(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_str(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_var_decl_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_var_decl_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_vec_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_vec_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_vec_pats(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_vec_pats(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_param(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_param(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_param_or_ts_param_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_param_or_ts_param_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_param_or_ts_param_props(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_param_or_ts_param_props(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Param],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_params(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_params(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_paren_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_paren_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_pat(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_pat(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_pats(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_pats(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_private_method(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_private_method(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_private_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_private_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_private_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_private_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_program<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Program,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_program(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_program(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_prop(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_prop_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_prop_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_prop_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_prop_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_prop_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_prop_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_regex(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_regex(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_rest_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_rest_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_return_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_return_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_script(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_script(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_seq_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_seq_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_setter_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_setter_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_simple_assign_target(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_simple_assign_target(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_span(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_span(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_spread_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_spread_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_static_block(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_static_block(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_stmt(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_stmts(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_stmts(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_str(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_str(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_super(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_super(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_super_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_super_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_super_prop_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_super_prop_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_switch_case(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_switch_case(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_switch_cases(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_switch_cases(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_switch_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_switch_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_syntax_context(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_syntax_context(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_tagged_tpl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_tagged_tpl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_this_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_this_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_throw_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_throw_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_tpl(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_tpl(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_tpl_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_tpl_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_tpl_elements(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_tpl_elements(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_true_plus_minus(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_true_plus_minus(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_try_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_try_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_unary_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_unary_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_unary_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_unary_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_update_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_update_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_update_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_update_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_using_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_using_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_decl_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_decl_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_decl_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_decl_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_declarator(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_declarator(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_declarators(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_declarators(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_while_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_while_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_with_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_with_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_yield_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_yield_expr(visitor, node, __ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for ::swc_visit::Optional<V>
where
    V: VisitAstPath,
{
    #[inline]
    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_array_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_array_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_arrow_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_assign_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_assign_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_assign_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_assign_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_assign_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_assign_target(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_assign_target_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_auto_accessor(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_await_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_big_int<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigInt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_big_int(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_big_int_value(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_bin_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_binary_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_binding_ident(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_block_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_block_stmt_or_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_bool(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_break_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_call_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_callee(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_catch_clause(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_class(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_member(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_members(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_method(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_computed_prop_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_cond_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_constructor(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_continue_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_debugger_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_decorator(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_decorators(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_default_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_do_while_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_empty_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_all(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_default_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_default_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_default_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_named_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_namespace_specifier(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_export_specifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_expr_or_spread(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_expr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_expr_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_exprs(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_fn_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_fn_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_fn_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast FnExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_fn_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_for_head(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_for_in_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_for_of_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_for_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_function(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_getter_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_ident(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_ident_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_if_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IfStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_if_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_import(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_default_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_named_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_phase(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_specifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_star_as_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_with(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_with_item(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_import_with_items(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_invalid<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Invalid,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_invalid(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_attr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_attr_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_attr_or_spread(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_attr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_attr_value(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_closing_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_closing_fragment(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_element_child(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_element_childs(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_element_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_empty_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_expr_container(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_fragment(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_member_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_namespaced_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_object(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_opening_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_opening_fragment(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_spread_child(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_jsx_text(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_key(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_key_value_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_key_value_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_labeled_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_member_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_member_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_meta_prop_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_meta_prop_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_method_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_method_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_module(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_module_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_module_export_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_module_item(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_module_items(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_named_export(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_new_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_null(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_number(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_object_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_object_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_object_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_object_pat_props(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_block_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_call(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_catch_clause(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_chain_base(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_chain_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_expr_or_spread(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_expr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_ident(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_jsx_attr_value(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_jsx_closing_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_module_export_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_object_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_span(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_str(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_var_decl_or_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_vec_expr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_vec_pats(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_param(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_param_or_ts_param_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_param_or_ts_param_props(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Param],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_params(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_paren_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_pats(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_private_method(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_private_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_private_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_program<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Program,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_program(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_prop_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_prop_or_spread(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_prop_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_regex(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_rest_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_return_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_script(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_seq_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_setter_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_simple_assign_target(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_span(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_spread_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_static_block(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_stmts(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_str(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_super(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_super_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_super_prop_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_switch_case(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_switch_cases(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_switch_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_syntax_context(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_tagged_tpl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_this_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_throw_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_tpl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_tpl_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_tpl_elements(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_true_plus_minus(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_try_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_unary_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_unary_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_update_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_update_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_using_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_var_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_var_decl_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_var_decl_or_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_var_declarator(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_var_declarators(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_while_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_with_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_yield_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitWithAstPath<V: ?Sized + VisitAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    );
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    );
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ArrayLit {
    #[doc = "Calls [VisitAstPath`::visit_array_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_lit(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ArrayLit { span, elems } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrayLit(
                        self,
                        self::fields::ArrayLitField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrayLit(
                        self,
                        self::fields::ArrayLitField::Elems(usize::MAX),
                    ));
                    <Vec<Option<ExprOrSpread>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        elems,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ArrayPat {
    #[doc = "Calls [VisitAstPath`::visit_array_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_pat(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrayPat(
                        self,
                        self::fields::ArrayPatField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrayPat(
                        self,
                        self::fields::ArrayPatField::Elems(usize::MAX),
                    ));
                    <Vec<Option<Pat>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        elems,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrayPat(
                        self,
                        self::fields::ArrayPatField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ArrowExpr {
    #[doc = "Calls [VisitAstPath`::visit_arrow_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_arrow_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrowExpr(
                        self,
                        self::fields::ArrowExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrowExpr(
                        self,
                        self::fields::ArrowExprField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrowExpr(
                        self,
                        self::fields::ArrowExprField::Params(usize::MAX),
                    ));
                    <Vec<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrowExpr(
                        self,
                        self::fields::ArrowExprField::Body,
                    ));
                    <Box<BlockStmtOrExpr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrowExpr(
                        self,
                        self::fields::ArrowExprField::TypeParams,
                    ));
                    <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ArrowExpr(
                        self,
                        self::fields::ArrowExprField::ReturnType,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        return_type,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignExpr {
    #[doc = "Calls [VisitAstPath`::visit_assign_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignExpr(
                        self,
                        self::fields::AssignExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignExpr(
                        self,
                        self::fields::AssignExprField::Op,
                    ));
                    <AssignOp as VisitWithAstPath<V>>::visit_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignExpr(
                        self,
                        self::fields::AssignExprField::Left,
                    ));
                    <AssignTarget as VisitWithAstPath<V>>::visit_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignExpr(
                        self,
                        self::fields::AssignExprField::Right,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignOp {
    #[doc = "Calls [VisitAstPath`::visit_assign_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_op(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignPat {
    #[doc = "Calls [VisitAstPath`::visit_assign_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignPat { span, left, right } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignPat(
                        self,
                        self::fields::AssignPatField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignPat(
                        self,
                        self::fields::AssignPatField::Left,
                    ));
                    <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignPat(
                        self,
                        self::fields::AssignPatField::Right,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignPatProp {
    #[doc = "Calls [VisitAstPath`::visit_assign_pat_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignPatProp { span, key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignPatProp(
                        self,
                        self::fields::AssignPatPropField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignPatProp(
                        self,
                        self::fields::AssignPatPropField::Key,
                    ));
                    <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignPatProp(
                        self,
                        self::fields::AssignPatPropField::Value,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignProp {
    #[doc = "Calls [VisitAstPath`::visit_assign_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignProp { span, key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignProp(
                        self,
                        self::fields::AssignPropField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignProp(
                        self,
                        self::fields::AssignPropField::Key,
                    ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignProp(
                        self,
                        self::fields::AssignPropField::Value,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignTarget {
    #[doc = "Calls [VisitAstPath`::visit_assign_target`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignTarget(
                    self,
                    self::fields::AssignTargetField::Simple,
                ));
                <SimpleAssignTarget as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            AssignTarget::Pat { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignTarget(
                    self,
                    self::fields::AssignTargetField::Pat,
                ));
                <AssignTargetPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignTargetPat {
    #[doc = "Calls [VisitAstPath`::visit_assign_target_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target_pat(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignTargetPat(
                    self,
                    self::fields::AssignTargetPatField::Array,
                ));
                <ArrayPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignTargetPat(
                    self,
                    self::fields::AssignTargetPatField::Object,
                ));
                <ObjectPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AssignTargetPat(
                    self,
                    self::fields::AssignTargetPatField::Invalid,
                ));
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AutoAccessor {
    #[doc = "Calls [VisitAstPath`::visit_auto_accessor`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_auto_accessor(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AutoAccessor(
                        self,
                        self::fields::AutoAccessorField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AutoAccessor(
                        self,
                        self::fields::AutoAccessorField::Key,
                    ));
                    <Key as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AutoAccessor(
                        self,
                        self::fields::AutoAccessorField::Value,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AutoAccessor(
                        self,
                        self::fields::AutoAccessorField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AutoAccessor(
                        self,
                        self::fields::AutoAccessorField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AutoAccessor(
                        self,
                        self::fields::AutoAccessorField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AwaitExpr {
    #[doc = "Calls [VisitAstPath`::visit_await_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_await_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AwaitExpr { span, arg } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AwaitExpr(
                        self,
                        self::fields::AwaitExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::AwaitExpr(
                        self,
                        self::fields::AwaitExprField::Arg,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BigInt {
    #[doc = "Calls [VisitAstPath`::visit_big_int`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BigInt { span, value, raw } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BigInt(
                        self,
                        self::fields::BigIntField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BigInt(
                        self,
                        self::fields::BigIntField::Value,
                    ));
                    <Box<BigIntValue> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BigInt(
                        self,
                        self::fields::BigIntField::Raw,
                    ));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BinExpr {
    #[doc = "Calls [VisitAstPath`::visit_bin_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_bin_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BinExpr(
                        self,
                        self::fields::BinExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BinExpr(
                        self,
                        self::fields::BinExprField::Op,
                    ));
                    <BinaryOp as VisitWithAstPath<V>>::visit_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BinExpr(
                        self,
                        self::fields::BinExprField::Left,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BinExpr(
                        self,
                        self::fields::BinExprField::Right,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BinaryOp {
    #[doc = "Calls [VisitAstPath`::visit_binary_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binary_op(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BindingIdent {
    #[doc = "Calls [VisitAstPath`::visit_binding_ident`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binding_ident(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BindingIdent { id, type_ann } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BindingIdent(
                        self,
                        self::fields::BindingIdentField::Id,
                    ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        id,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BindingIdent(
                        self,
                        self::fields::BindingIdentField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BlockStmt {
    #[doc = "Calls [VisitAstPath`::visit_block_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BlockStmt(
                        self,
                        self::fields::BlockStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BlockStmt(
                        self,
                        self::fields::BlockStmtField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BlockStmt(
                        self,
                        self::fields::BlockStmtField::Stmts(usize::MAX),
                    ));
                    <Vec<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        stmts,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BlockStmtOrExpr {
    #[doc = "Calls [VisitAstPath`::visit_block_stmt_or_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt_or_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BlockStmtOrExpr(
                    self,
                    self::fields::BlockStmtOrExprField::BlockStmt,
                ));
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BlockStmtOrExpr(
                    self,
                    self::fields::BlockStmtOrExprField::Expr,
                ));
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Bool {
    #[doc = "Calls [VisitAstPath`::visit_bool`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_bool(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Bool { span, value } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Bool(self, self::fields::BoolField::Span));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BreakStmt {
    #[doc = "Calls [VisitAstPath`::visit_break_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_break_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BreakStmt { span, label } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BreakStmt(
                        self,
                        self::fields::BreakStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::BreakStmt(
                        self,
                        self::fields::BreakStmtField::Label,
                    ));
                    <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CallExpr {
    #[doc = "Calls [VisitAstPath`::visit_call_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_call_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CallExpr(
                        self,
                        self::fields::CallExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CallExpr(
                        self,
                        self::fields::CallExprField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CallExpr(
                        self,
                        self::fields::CallExprField::Callee,
                    ));
                    <Callee as VisitWithAstPath<V>>::visit_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CallExpr(
                        self,
                        self::fields::CallExprField::Args(usize::MAX),
                    ));
                    <Vec<ExprOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CallExpr(
                        self,
                        self::fields::CallExprField::TypeArgs,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitWithAstPath < V > > :: visit_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Callee {
    #[doc = "Calls [VisitAstPath`::visit_callee`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_callee(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Callee::Super { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Callee(
                    self,
                    self::fields::CalleeField::Super,
                ));
                <Super as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Callee::Import { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Callee(
                    self,
                    self::fields::CalleeField::Import,
                ));
                <Import as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Callee::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Callee(
                    self,
                    self::fields::CalleeField::Expr,
                ));
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CatchClause {
    #[doc = "Calls [VisitAstPath`::visit_catch_clause`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_catch_clause(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CatchClause { span, param, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CatchClause(
                        self,
                        self::fields::CatchClauseField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CatchClause(
                        self,
                        self::fields::CatchClauseField::Param,
                    ));
                    <Option<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                        param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CatchClause(
                        self,
                        self::fields::CatchClauseField::Body,
                    ));
                    <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Class {
    #[doc = "Calls [VisitAstPath`::visit_class`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::Body(usize::MAX),
                    ));
                    <Vec<ClassMember> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::SuperClass,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        super_class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::TypeParams,
                    ));
                    <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::SuperTypeParams,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitWithAstPath < V > > :: visit_with_ast_path (super_type_params , visitor , & mut * __ast_path)
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Class(
                        self,
                        self::fields::ClassField::Implements(usize::MAX),
                    ));
                    <Vec<TsExprWithTypeArgs> as VisitWithAstPath<V>>::visit_with_ast_path(
                        implements,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassDecl {
    #[doc = "Calls [VisitAstPath`::visit_class_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassDecl(
                        self,
                        self::fields::ClassDeclField::Ident,
                    ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassDecl(
                        self,
                        self::fields::ClassDeclField::Class,
                    ));
                    <Box<Class> as VisitWithAstPath<V>>::visit_with_ast_path(
                        class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassExpr {
    #[doc = "Calls [VisitAstPath`::visit_class_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassExpr { ident, class } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassExpr(
                        self,
                        self::fields::ClassExprField::Ident,
                    ));
                    <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassExpr(
                        self,
                        self::fields::ClassExprField::Class,
                    ));
                    <Box<Class> as VisitWithAstPath<V>>::visit_with_ast_path(
                        class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassMember {
    #[doc = "Calls [VisitAstPath`::visit_class_member`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_member(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::Constructor,
                ));
                <Constructor as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::Method { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::Method,
                ));
                <ClassMethod as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::PrivateMethod { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::PrivateMethod,
                ));
                <PrivateMethod as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::ClassProp,
                ));
                <ClassProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::PrivateProp,
                ));
                <PrivateProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::TsIndexSignature,
                ));
                <TsIndexSignature as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::Empty { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::Empty,
                ));
                <EmptyStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::StaticBlock,
                ));
                <StaticBlock as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMember(
                    self,
                    self::fields::ClassMemberField::AutoAccessor,
                ));
                <AutoAccessor as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassMethod {
    #[doc = "Calls [VisitAstPath`::visit_class_method`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_method(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMethod(
                        self,
                        self::fields::ClassMethodField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMethod(
                        self,
                        self::fields::ClassMethodField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMethod(
                        self,
                        self::fields::ClassMethodField::Function,
                    ));
                    <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMethod(
                        self,
                        self::fields::ClassMethodField::Kind,
                    ));
                    <MethodKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassMethod(
                        self,
                        self::fields::ClassMethodField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassProp {
    #[doc = "Calls [VisitAstPath`::visit_class_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassProp(
                        self,
                        self::fields::ClassPropField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassProp(
                        self,
                        self::fields::ClassPropField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassProp(
                        self,
                        self::fields::ClassPropField::Value,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassProp(
                        self,
                        self::fields::ClassPropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassProp(
                        self,
                        self::fields::ClassPropField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassProp(
                        self,
                        self::fields::ClassPropField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ComputedPropName {
    #[doc = "Calls [VisitAstPath`::visit_computed_prop_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_computed_prop_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ComputedPropName { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ComputedPropName(
                        self,
                        self::fields::ComputedPropNameField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ComputedPropName(
                        self,
                        self::fields::ComputedPropNameField::Expr,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CondExpr {
    #[doc = "Calls [VisitAstPath`::visit_cond_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_cond_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CondExpr(
                        self,
                        self::fields::CondExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CondExpr(
                        self,
                        self::fields::CondExprField::Test,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CondExpr(
                        self,
                        self::fields::CondExprField::Cons,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CondExpr(
                        self,
                        self::fields::CondExprField::Alt,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        alt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Constructor {
    #[doc = "Calls [VisitAstPath`::visit_constructor`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_constructor(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Constructor(
                        self,
                        self::fields::ConstructorField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Constructor(
                        self,
                        self::fields::ConstructorField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Constructor(
                        self,
                        self::fields::ConstructorField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Constructor(
                        self,
                        self::fields::ConstructorField::Params(usize::MAX),
                    ));
                    <Vec<ParamOrTsParamProp> as VisitWithAstPath<V>>::visit_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Constructor(
                        self,
                        self::fields::ConstructorField::Body,
                    ));
                    <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Constructor(
                        self,
                        self::fields::ConstructorField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ContinueStmt {
    #[doc = "Calls [VisitAstPath`::visit_continue_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_continue_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ContinueStmt { span, label } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ContinueStmt(
                        self,
                        self::fields::ContinueStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ContinueStmt(
                        self,
                        self::fields::ContinueStmtField::Label,
                    ));
                    <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for DebuggerStmt {
    #[doc = "Calls [VisitAstPath`::visit_debugger_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_debugger_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            DebuggerStmt { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::DebuggerStmt(
                        self,
                        self::fields::DebuggerStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Decl {
    #[doc = "Calls [VisitAstPath`::visit_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Decl::Class { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Decl(self, self::fields::DeclField::Class));
                <ClassDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::Fn { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Decl(self, self::fields::DeclField::Fn));
                <FnDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::Var { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Decl(self, self::fields::DeclField::Var));
                <Box<VarDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::Using { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Decl(self, self::fields::DeclField::Using));
                <Box<UsingDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsInterface { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Decl(
                    self,
                    self::fields::DeclField::TsInterface,
                ));
                <Box<TsInterfaceDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Decl(
                    self,
                    self::fields::DeclField::TsTypeAlias,
                ));
                <Box<TsTypeAliasDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsEnum { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Decl(
                    self,
                    self::fields::DeclField::TsEnum,
                ));
                <Box<TsEnumDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsModule { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Decl(
                    self,
                    self::fields::DeclField::TsModule,
                ));
                <Box<TsModuleDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Decorator {
    #[doc = "Calls [VisitAstPath`::visit_decorator`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorator(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Decorator { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Decorator(
                        self,
                        self::fields::DecoratorField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Decorator(
                        self,
                        self::fields::DecoratorField::Expr,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for DefaultDecl {
    #[doc = "Calls [VisitAstPath`::visit_default_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_default_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::DefaultDecl(
                    self,
                    self::fields::DefaultDeclField::Class,
                ));
                <ClassExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::DefaultDecl(
                    self,
                    self::fields::DefaultDeclField::Fn,
                ));
                <FnExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::DefaultDecl(
                    self,
                    self::fields::DefaultDeclField::TsInterfaceDecl,
                ));
                <Box<TsInterfaceDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for DoWhileStmt {
    #[doc = "Calls [VisitAstPath`::visit_do_while_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_do_while_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            DoWhileStmt { span, test, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::DoWhileStmt(
                        self,
                        self::fields::DoWhileStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::DoWhileStmt(
                        self,
                        self::fields::DoWhileStmtField::Test,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::DoWhileStmt(
                        self,
                        self::fields::DoWhileStmtField::Body,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for EmptyStmt {
    #[doc = "Calls [VisitAstPath`::visit_empty_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_empty_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            EmptyStmt { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::EmptyStmt(
                        self,
                        self::fields::EmptyStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportAll {
    #[doc = "Calls [VisitAstPath`::visit_export_all`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_all(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportAll(
                        self,
                        self::fields::ExportAllField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportAll(
                        self,
                        self::fields::ExportAllField::Src,
                    ));
                    <Box<Str> as VisitWithAstPath<V>>::visit_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportAll(
                        self,
                        self::fields::ExportAllField::With,
                    ));
                    <Option<Box<ObjectLit>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDecl {
    #[doc = "Calls [VisitAstPath`::visit_export_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDecl { span, decl } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportDecl(
                        self,
                        self::fields::ExportDeclField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportDecl(
                        self,
                        self::fields::ExportDeclField::Decl,
                    ));
                    <Decl as VisitWithAstPath<V>>::visit_with_ast_path(
                        decl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDefaultDecl {
    #[doc = "Calls [VisitAstPath`::visit_export_default_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDefaultDecl { span, decl } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportDefaultDecl(
                            self,
                            self::fields::ExportDefaultDeclField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportDefaultDecl(
                            self,
                            self::fields::ExportDefaultDeclField::Decl,
                        ));
                    <DefaultDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                        decl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDefaultExpr {
    #[doc = "Calls [VisitAstPath`::visit_export_default_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDefaultExpr { span, expr } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportDefaultExpr(
                            self,
                            self::fields::ExportDefaultExprField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportDefaultExpr(
                            self,
                            self::fields::ExportDefaultExprField::Expr,
                        ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDefaultSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_default_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDefaultSpecifier { exported } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportDefaultSpecifier(
                            self,
                            self::fields::ExportDefaultSpecifierField::Exported,
                        ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        exported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportNamedSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_named_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_named_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportNamedSpecifier(
                            self,
                            self::fields::ExportNamedSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportNamedSpecifier(
                            self,
                            self::fields::ExportNamedSpecifierField::Orig,
                        ));
                    <ModuleExportName as VisitWithAstPath<V>>::visit_with_ast_path(
                        orig,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportNamedSpecifier(
                            self,
                            self::fields::ExportNamedSpecifierField::Exported,
                        ));
                    <Option<ModuleExportName> as VisitWithAstPath<V>>::visit_with_ast_path(
                        exported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_namespace_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_namespace_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportNamespaceSpecifier(
                            self,
                            self::fields::ExportNamespaceSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ExportNamespaceSpecifier(
                            self,
                            self::fields::ExportNamespaceSpecifierField::Name,
                        ));
                    <ModuleExportName as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportSpecifier(
                    self,
                    self::fields::ExportSpecifierField::Namespace,
                ));
                <ExportNamespaceSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportSpecifier(
                    self,
                    self::fields::ExportSpecifierField::Default,
                ));
                <ExportDefaultSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExportSpecifier(
                    self,
                    self::fields::ExportSpecifierField::Named,
                ));
                <ExportNamedSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Expr {
    #[doc = "Calls [VisitAstPath`::visit_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Expr::This { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::This));
                <ThisExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Array { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Array));
                <ArrayLit as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Object { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Object,
                ));
                <ObjectLit as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Fn { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Fn));
                <FnExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Unary { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Unary));
                <UnaryExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Update { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Update,
                ));
                <UpdateExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Bin { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Bin));
                <BinExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Assign { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Assign,
                ));
                <AssignExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Member { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Member,
                ));
                <MemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::SuperProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::SuperProp,
                ));
                <SuperPropExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Cond { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Cond));
                <CondExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Call { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Call));
                <CallExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::New { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::New));
                <NewExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Seq { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Seq));
                <SeqExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Ident));
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Lit { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Lit));
                <Lit as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Tpl { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Tpl));
                <Tpl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::TaggedTpl,
                ));
                <TaggedTpl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Arrow { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Arrow));
                <ArrowExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Class { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Class));
                <ClassExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Yield { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Yield));
                <YieldExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::MetaProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::MetaProp,
                ));
                <MetaPropExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Await { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Await));
                <AwaitExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Paren { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::Paren));
                <ParenExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXMember { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Jsxmember,
                ));
                <JSXMemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::JsxnamespacedName,
                ));
                <JSXNamespacedName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Jsxempty,
                ));
                <JSXEmptyExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Jsxelement,
                ));
                <Box<JSXElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Jsxfragment,
                ));
                <JSXFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::TsTypeAssertion,
                ));
                <TsTypeAssertion as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::TsConstAssertion,
                ));
                <TsConstAssertion as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsNonNull { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::TsNonNull,
                ));
                <TsNonNullExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsAs { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Expr(self, self::fields::ExprField::TsAs));
                <TsAsExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::TsInstantiation,
                ));
                <TsInstantiation as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::TsSatisfies,
                ));
                <TsSatisfiesExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::PrivateName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::PrivateName,
                ));
                <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::OptChain { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::OptChain,
                ));
                <OptChainExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Expr(
                    self,
                    self::fields::ExprField::Invalid,
                ));
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExprOrSpread {
    #[doc = "Calls [VisitAstPath`::visit_expr_or_spread`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spread(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExprOrSpread { spread, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExprOrSpread(
                        self,
                        self::fields::ExprOrSpreadField::Spread,
                    ));
                    <Option<swc_common::Span> as VisitWithAstPath<V>>::visit_with_ast_path(
                        spread,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExprOrSpread(
                        self,
                        self::fields::ExprOrSpreadField::Expr,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExprStmt {
    #[doc = "Calls [VisitAstPath`::visit_expr_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExprStmt { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExprStmt(
                        self,
                        self::fields::ExprStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ExprStmt(
                        self,
                        self::fields::ExprStmtField::Expr,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for FnDecl {
    #[doc = "Calls [VisitAstPath`::visit_fn_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::FnDecl(
                        self,
                        self::fields::FnDeclField::Ident,
                    ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::FnDecl(
                        self,
                        self::fields::FnDeclField::Function,
                    ));
                    <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for FnExpr {
    #[doc = "Calls [VisitAstPath`::visit_fn_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            FnExpr { ident, function } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::FnExpr(
                        self,
                        self::fields::FnExprField::Ident,
                    ));
                    <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::FnExpr(
                        self,
                        self::fields::FnExprField::Function,
                    ));
                    <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForHead {
    #[doc = "Calls [VisitAstPath`::visit_for_head`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_head(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForHead(
                    self,
                    self::fields::ForHeadField::VarDecl,
                ));
                <Box<VarDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForHead(
                    self,
                    self::fields::ForHeadField::UsingDecl,
                ));
                <Box<UsingDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ForHead::Pat { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForHead(
                    self,
                    self::fields::ForHeadField::Pat,
                ));
                <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForInStmt {
    #[doc = "Calls [VisitAstPath`::visit_for_in_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_in_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForInStmt(
                        self,
                        self::fields::ForInStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForInStmt(
                        self,
                        self::fields::ForInStmtField::Left,
                    ));
                    <ForHead as VisitWithAstPath<V>>::visit_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForInStmt(
                        self,
                        self::fields::ForInStmtField::Right,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForInStmt(
                        self,
                        self::fields::ForInStmtField::Body,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForOfStmt {
    #[doc = "Calls [VisitAstPath`::visit_for_of_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_of_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForOfStmt(
                        self,
                        self::fields::ForOfStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForOfStmt(
                        self,
                        self::fields::ForOfStmtField::Left,
                    ));
                    <ForHead as VisitWithAstPath<V>>::visit_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForOfStmt(
                        self,
                        self::fields::ForOfStmtField::Right,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForOfStmt(
                        self,
                        self::fields::ForOfStmtField::Body,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForStmt {
    #[doc = "Calls [VisitAstPath`::visit_for_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForStmt(
                        self,
                        self::fields::ForStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForStmt(
                        self,
                        self::fields::ForStmtField::Init,
                    ));
                    <Option<VarDeclOrExpr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        init,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForStmt(
                        self,
                        self::fields::ForStmtField::Test,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForStmt(
                        self,
                        self::fields::ForStmtField::Update,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        update,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ForStmt(
                        self,
                        self::fields::ForStmtField::Body,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Function {
    #[doc = "Calls [VisitAstPath`::visit_function`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_function(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Function(
                        self,
                        self::fields::FunctionField::Params(usize::MAX),
                    ));
                    <Vec<Param> as VisitWithAstPath<V>>::visit_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Function(
                        self,
                        self::fields::FunctionField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Function(
                        self,
                        self::fields::FunctionField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Function(
                        self,
                        self::fields::FunctionField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Function(
                        self,
                        self::fields::FunctionField::Body,
                    ));
                    <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Function(
                        self,
                        self::fields::FunctionField::TypeParams,
                    ));
                    <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Function(
                        self,
                        self::fields::FunctionField::ReturnType,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        return_type,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for GetterProp {
    #[doc = "Calls [VisitAstPath`::visit_getter_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_getter_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::GetterProp(
                        self,
                        self::fields::GetterPropField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::GetterProp(
                        self,
                        self::fields::GetterPropField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::GetterProp(
                        self,
                        self::fields::GetterPropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::GetterProp(
                        self,
                        self::fields::GetterPropField::Body,
                    ));
                    <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Ident {
    #[doc = "Calls [VisitAstPath`::visit_ident`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ident(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Ident(
                        self,
                        self::fields::IdentField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Ident(
                        self,
                        self::fields::IdentField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Ident(self, self::fields::IdentField::Sym));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        sym,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for IdentName {
    #[doc = "Calls [VisitAstPath`::visit_ident_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ident_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            IdentName { span, sym } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IdentName(
                        self,
                        self::fields::IdentNameField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IdentName(
                        self,
                        self::fields::IdentNameField::Sym,
                    ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        sym,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for IfStmt {
    #[doc = "Calls [VisitAstPath`::visit_if_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_if_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IfStmt(
                        self,
                        self::fields::IfStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IfStmt(
                        self,
                        self::fields::IfStmtField::Test,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IfStmt(
                        self,
                        self::fields::IfStmtField::Cons,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IfStmt(
                        self,
                        self::fields::IfStmtField::Alt,
                    ));
                    <Option<Box<Stmt>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        alt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Import {
    #[doc = "Calls [VisitAstPath`::visit_import`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Import { span, phase } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Import(
                        self,
                        self::fields::ImportField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Import(
                        self,
                        self::fields::ImportField::Phase,
                    ));
                    <ImportPhase as VisitWithAstPath<V>>::visit_with_ast_path(
                        phase,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportDecl {
    #[doc = "Calls [VisitAstPath`::visit_import_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportDecl(
                        self,
                        self::fields::ImportDeclField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportDecl(
                        self,
                        self::fields::ImportDeclField::Specifiers(usize::MAX),
                    ));
                    <Vec<ImportSpecifier> as VisitWithAstPath<V>>::visit_with_ast_path(
                        specifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportDecl(
                        self,
                        self::fields::ImportDeclField::Src,
                    ));
                    <Box<Str> as VisitWithAstPath<V>>::visit_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportDecl(
                        self,
                        self::fields::ImportDeclField::With,
                    ));
                    <Option<Box<ObjectLit>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportDecl(
                        self,
                        self::fields::ImportDeclField::Phase,
                    ));
                    <ImportPhase as VisitWithAstPath<V>>::visit_with_ast_path(
                        phase,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportDefaultSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_default_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_default_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ImportDefaultSpecifier(
                            self,
                            self::fields::ImportDefaultSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ImportDefaultSpecifier(
                            self,
                            self::fields::ImportDefaultSpecifierField::Local,
                        ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportNamedSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_named_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_named_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ImportNamedSpecifier(
                            self,
                            self::fields::ImportNamedSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ImportNamedSpecifier(
                            self,
                            self::fields::ImportNamedSpecifierField::Local,
                        ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ImportNamedSpecifier(
                            self,
                            self::fields::ImportNamedSpecifierField::Imported,
                        ));
                    <Option<ModuleExportName> as VisitWithAstPath<V>>::visit_with_ast_path(
                        imported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportPhase {
    #[doc = "Calls [VisitAstPath`::visit_import_phase`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_phase(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportSpecifier(
                    self,
                    self::fields::ImportSpecifierField::Named,
                ));
                <ImportNamedSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportSpecifier(
                    self,
                    self::fields::ImportSpecifierField::Default,
                ));
                <ImportDefaultSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportSpecifier(
                    self,
                    self::fields::ImportSpecifierField::Namespace,
                ));
                <ImportStarAsSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportStarAsSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_star_as_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_star_as_specifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ImportStarAsSpecifier(
                            self,
                            self::fields::ImportStarAsSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ImportStarAsSpecifier(
                            self,
                            self::fields::ImportStarAsSpecifierField::Local,
                        ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportWith {
    #[doc = "Calls [VisitAstPath`::visit_import_with`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportWith { span, values } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportWith(
                        self,
                        self::fields::ImportWithField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportWith(
                        self,
                        self::fields::ImportWithField::Values(usize::MAX),
                    ));
                    <Vec<ImportWithItem> as VisitWithAstPath<V>>::visit_with_ast_path(
                        values,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportWithItem {
    #[doc = "Calls [VisitAstPath`::visit_import_with_item`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_item(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportWithItem { key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportWithItem(
                        self,
                        self::fields::ImportWithItemField::Key,
                    ));
                    <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ImportWithItem(
                        self,
                        self::fields::ImportWithItemField::Value,
                    ));
                    <Str as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Invalid {
    #[doc = "Calls [VisitAstPath`::visit_invalid`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_invalid(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Invalid { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Invalid(
                        self,
                        self::fields::InvalidField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttr { span, name, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttr(
                        self,
                        self::fields::JSXAttrField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttr(
                        self,
                        self::fields::JSXAttrField::Name,
                    ));
                    <JSXAttrName as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttr(
                        self,
                        self::fields::JSXAttrField::Value,
                    ));
                    <Option<JSXAttrValue> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttrName {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrName(
                    self,
                    self::fields::JSXAttrNameField::Ident,
                ));
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrName(
                    self,
                    self::fields::JSXAttrNameField::JsxnamespacedName,
                ));
                <JSXNamespacedName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttrOrSpread {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_or_spread`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spread(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrOrSpread(
                    self,
                    self::fields::JSXAttrOrSpreadField::Jsxattr,
                ));
                <JSXAttr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrOrSpread(
                    self,
                    self::fields::JSXAttrOrSpreadField::SpreadElement,
                ));
                <SpreadElement as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttrValue {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_value`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_value(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrValue(
                    self,
                    self::fields::JSXAttrValueField::Lit,
                ));
                <Lit as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrValue(
                    self,
                    self::fields::JSXAttrValueField::JsxexprContainer,
                ));
                <JSXExprContainer as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrValue(
                    self,
                    self::fields::JSXAttrValueField::Jsxelement,
                ));
                <Box<JSXElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXAttrValue(
                    self,
                    self::fields::JSXAttrValueField::Jsxfragment,
                ));
                <JSXFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXClosingElement {
    #[doc = "Calls [VisitAstPath`::visit_jsx_closing_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_element(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXClosingElement { span, name } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXClosingElement(
                            self,
                            self::fields::JSXClosingElementField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXClosingElement(
                            self,
                            self::fields::JSXClosingElementField::Name,
                        ));
                    <JSXElementName as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXClosingFragment {
    #[doc = "Calls [VisitAstPath`::visit_jsx_closing_fragment`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_fragment(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXClosingFragment { span } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXClosingFragment(
                            self,
                            self::fields::JSXClosingFragmentField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXElement {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElement(
                        self,
                        self::fields::JSXElementField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElement(
                        self,
                        self::fields::JSXElementField::Opening,
                    ));
                    <JSXOpeningElement as VisitWithAstPath<V>>::visit_with_ast_path(
                        opening,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElement(
                        self,
                        self::fields::JSXElementField::Children(usize::MAX),
                    ));
                    <Vec<JSXElementChild> as VisitWithAstPath<V>>::visit_with_ast_path(
                        children,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElement(
                        self,
                        self::fields::JSXElementField::Closing,
                    ));
                    <Option<JSXClosingElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                        closing,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXElementChild {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element_child`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_child(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementChild(
                    self,
                    self::fields::JSXElementChildField::Jsxtext,
                ));
                <JSXText as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementChild(
                    self,
                    self::fields::JSXElementChildField::JsxexprContainer,
                ));
                <JSXExprContainer as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementChild(
                    self,
                    self::fields::JSXElementChildField::JsxspreadChild,
                ));
                <JSXSpreadChild as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementChild(
                    self,
                    self::fields::JSXElementChildField::Jsxelement,
                ));
                <Box<JSXElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementChild(
                    self,
                    self::fields::JSXElementChildField::Jsxfragment,
                ));
                <JSXFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXElementName {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementName(
                    self,
                    self::fields::JSXElementNameField::Ident,
                ));
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementName(
                    self,
                    self::fields::JSXElementNameField::JsxmemberExpr,
                ));
                <JSXMemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXElementName(
                    self,
                    self::fields::JSXElementNameField::JsxnamespacedName,
                ));
                <JSXNamespacedName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXEmptyExpr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_empty_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_empty_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXEmptyExpr { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXEmptyExpr(
                        self,
                        self::fields::JSXEmptyExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXExpr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXExpr(
                    self,
                    self::fields::JSXExprField::JsxemptyExpr,
                ));
                <JSXEmptyExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXExpr::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXExpr(
                    self,
                    self::fields::JSXExprField::Expr,
                ));
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXExprContainer {
    #[doc = "Calls [VisitAstPath`::visit_jsx_expr_container`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr_container(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXExprContainer { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXExprContainer(
                        self,
                        self::fields::JSXExprContainerField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXExprContainer(
                        self,
                        self::fields::JSXExprContainerField::Expr,
                    ));
                    <JSXExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXFragment {
    #[doc = "Calls [VisitAstPath`::visit_jsx_fragment`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_fragment(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXFragment(
                        self,
                        self::fields::JSXFragmentField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXFragment(
                        self,
                        self::fields::JSXFragmentField::Opening,
                    ));
                    <JSXOpeningFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                        opening,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXFragment(
                        self,
                        self::fields::JSXFragmentField::Children(usize::MAX),
                    ));
                    <Vec<JSXElementChild> as VisitWithAstPath<V>>::visit_with_ast_path(
                        children,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXFragment(
                        self,
                        self::fields::JSXFragmentField::Closing,
                    ));
                    <JSXClosingFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                        closing,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXMemberExpr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_member_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_member_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXMemberExpr(
                        self,
                        self::fields::JSXMemberExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXMemberExpr(
                        self,
                        self::fields::JSXMemberExprField::Obj,
                    ));
                    <JSXObject as VisitWithAstPath<V>>::visit_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXMemberExpr(
                        self,
                        self::fields::JSXMemberExprField::Prop,
                    ));
                    <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXNamespacedName {
    #[doc = "Calls [VisitAstPath`::visit_jsx_namespaced_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_namespaced_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXNamespacedName(
                            self,
                            self::fields::JSXNamespacedNameField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXNamespacedName(
                            self,
                            self::fields::JSXNamespacedNameField::Ns,
                        ));
                    <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                        ns,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXNamespacedName(
                            self,
                            self::fields::JSXNamespacedNameField::Name,
                        ));
                    <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXObject {
    #[doc = "Calls [VisitAstPath`::visit_jsx_object`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_object(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXObject(
                    self,
                    self::fields::JSXObjectField::JsxmemberExpr,
                ));
                <Box<JSXMemberExpr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXObject::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXObject(
                    self,
                    self::fields::JSXObjectField::Ident,
                ));
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXOpeningElement {
    #[doc = "Calls [VisitAstPath`::visit_jsx_opening_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_element(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXOpeningElement(
                            self,
                            self::fields::JSXOpeningElementField::Name,
                        ));
                    <JSXElementName as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXOpeningElement(
                            self,
                            self::fields::JSXOpeningElementField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXOpeningElement(
                            self,
                            self::fields::JSXOpeningElementField::Attrs(usize::MAX),
                        ));
                    <Vec<JSXAttrOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                        attrs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXOpeningElement(
                            self,
                            self::fields::JSXOpeningElementField::TypeArgs,
                        ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitWithAstPath < V > > :: visit_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXOpeningFragment {
    #[doc = "Calls [VisitAstPath`::visit_jsx_opening_fragment`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_fragment(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXOpeningFragment { span } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::JSXOpeningFragment(
                            self,
                            self::fields::JSXOpeningFragmentField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXSpreadChild {
    #[doc = "Calls [VisitAstPath`::visit_jsx_spread_child`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_spread_child(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXSpreadChild { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXSpreadChild(
                        self,
                        self::fields::JSXSpreadChildField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXSpreadChild(
                        self,
                        self::fields::JSXSpreadChildField::Expr,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXText {
    #[doc = "Calls [VisitAstPath`::visit_jsx_text`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_text(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXText { span, value, raw } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXText(
                        self,
                        self::fields::JSXTextField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXText(
                        self,
                        self::fields::JSXTextField::Value,
                    ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::JSXText(
                        self,
                        self::fields::JSXTextField::Raw,
                    ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Key {
    #[doc = "Calls [VisitAstPath`::visit_key`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Key::Private { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Key(self, self::fields::KeyField::Private));
                <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Key::Public { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Key(self, self::fields::KeyField::Public));
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for KeyValuePatProp {
    #[doc = "Calls [VisitAstPath`::visit_key_value_pat_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_pat_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            KeyValuePatProp { key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::KeyValuePatProp(
                        self,
                        self::fields::KeyValuePatPropField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::KeyValuePatProp(
                        self,
                        self::fields::KeyValuePatPropField::Value,
                    ));
                    <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for KeyValueProp {
    #[doc = "Calls [VisitAstPath`::visit_key_value_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            KeyValueProp { key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::KeyValueProp(
                        self,
                        self::fields::KeyValuePropField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::KeyValueProp(
                        self,
                        self::fields::KeyValuePropField::Value,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for LabeledStmt {
    #[doc = "Calls [VisitAstPath`::visit_labeled_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_labeled_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            LabeledStmt { span, label, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::LabeledStmt(
                        self,
                        self::fields::LabeledStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::LabeledStmt(
                        self,
                        self::fields::LabeledStmtField::Label,
                    ));
                    <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::LabeledStmt(
                        self,
                        self::fields::LabeledStmtField::Body,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Lit {
    #[doc = "Calls [VisitAstPath`::visit_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_lit(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Lit::Str { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::Lit(self, self::fields::LitField::Str));
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Bool { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Lit(self, self::fields::LitField::Bool));
                <Bool as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Null { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Lit(self, self::fields::LitField::Null));
                <Null as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Num { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::Lit(self, self::fields::LitField::Num));
                <Number as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::BigInt { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Lit(self, self::fields::LitField::BigInt));
                <BigInt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Regex { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Lit(self, self::fields::LitField::Regex));
                <Regex as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::JSXText { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Lit(self, self::fields::LitField::Jsxtext));
                <JSXText as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MemberExpr {
    #[doc = "Calls [VisitAstPath`::visit_member_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MemberExpr { span, obj, prop } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MemberExpr(
                        self,
                        self::fields::MemberExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MemberExpr(
                        self,
                        self::fields::MemberExprField::Obj,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MemberExpr(
                        self,
                        self::fields::MemberExprField::Prop,
                    ));
                    <MemberProp as VisitWithAstPath<V>>::visit_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MemberProp {
    #[doc = "Calls [VisitAstPath`::visit_member_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MemberProp(
                    self,
                    self::fields::MemberPropField::Ident,
                ));
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MemberProp(
                    self,
                    self::fields::MemberPropField::PrivateName,
                ));
                <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            MemberProp::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MemberProp(
                    self,
                    self::fields::MemberPropField::Computed,
                ));
                <ComputedPropName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MetaPropExpr {
    #[doc = "Calls [VisitAstPath`::visit_meta_prop_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MetaPropExpr { span, kind } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MetaPropExpr(
                        self,
                        self::fields::MetaPropExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MetaPropExpr(
                        self,
                        self::fields::MetaPropExprField::Kind,
                    ));
                    <MetaPropKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MetaPropKind {
    #[doc = "Calls [VisitAstPath`::visit_meta_prop_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MethodKind {
    #[doc = "Calls [VisitAstPath`::visit_method_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MethodProp {
    #[doc = "Calls [VisitAstPath`::visit_method_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MethodProp { key, function } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MethodProp(
                        self,
                        self::fields::MethodPropField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::MethodProp(
                        self,
                        self::fields::MethodPropField::Function,
                    ));
                    <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Module {
    #[doc = "Calls [VisitAstPath`::visit_module`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Module(
                        self,
                        self::fields::ModuleField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Module(
                        self,
                        self::fields::ModuleField::Body(usize::MAX),
                    ));
                    <Vec<ModuleItem> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Module(
                        self,
                        self::fields::ModuleField::Shebang,
                    ));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        shebang,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ModuleDecl {
    #[doc = "Calls [VisitAstPath`::visit_module_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::Import,
                ));
                <ImportDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::ExportDecl,
                ));
                <ExportDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::ExportNamed,
                ));
                <NamedExport as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::ExportDefaultDecl,
                ));
                <ExportDefaultDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::ExportDefaultExpr,
                ));
                <ExportDefaultExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::ExportAll,
                ));
                <ExportAll as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::TsImportEquals,
                ));
                <Box<TsImportEqualsDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::TsExportAssignment,
                ));
                <TsExportAssignment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleDecl(
                    self,
                    self::fields::ModuleDeclField::TsNamespaceExport,
                ));
                <TsNamespaceExportDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ModuleExportName {
    #[doc = "Calls [VisitAstPath`::visit_module_export_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_export_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleExportName(
                    self,
                    self::fields::ModuleExportNameField::Ident,
                ));
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleExportName::Str { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleExportName(
                    self,
                    self::fields::ModuleExportNameField::Str,
                ));
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ModuleItem {
    #[doc = "Calls [VisitAstPath`::visit_module_item`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_item(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleItem(
                    self,
                    self::fields::ModuleItemField::ModuleDecl,
                ));
                <ModuleDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ModuleItem(
                    self,
                    self::fields::ModuleItemField::Stmt,
                ));
                <Stmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for NamedExport {
    #[doc = "Calls [VisitAstPath`::visit_named_export`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_named_export(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NamedExport(
                        self,
                        self::fields::NamedExportField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NamedExport(
                        self,
                        self::fields::NamedExportField::Specifiers(usize::MAX),
                    ));
                    <Vec<ExportSpecifier> as VisitWithAstPath<V>>::visit_with_ast_path(
                        specifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NamedExport(
                        self,
                        self::fields::NamedExportField::Src,
                    ));
                    <Option<Box<Str>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NamedExport(
                        self,
                        self::fields::NamedExportField::With,
                    ));
                    <Option<Box<ObjectLit>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for NewExpr {
    #[doc = "Calls [VisitAstPath`::visit_new_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_new_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NewExpr(
                        self,
                        self::fields::NewExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NewExpr(
                        self,
                        self::fields::NewExprField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NewExpr(
                        self,
                        self::fields::NewExprField::Callee,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NewExpr(
                        self,
                        self::fields::NewExprField::Args(usize::MAX),
                    ));
                    <Option<Vec<ExprOrSpread>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NewExpr(
                        self,
                        self::fields::NewExprField::TypeArgs,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitWithAstPath < V > > :: visit_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Null {
    #[doc = "Calls [VisitAstPath`::visit_null`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_null(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Null { span } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Null(self, self::fields::NullField::Span));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Number {
    #[doc = "Calls [VisitAstPath`::visit_number`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_number(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Number { span, value, raw } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Number(
                        self,
                        self::fields::NumberField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Number(
                        self,
                        self::fields::NumberField::Raw,
                    ));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ObjectLit {
    #[doc = "Calls [VisitAstPath`::visit_object_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_lit(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ObjectLit { span, props } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectLit(
                        self,
                        self::fields::ObjectLitField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectLit(
                        self,
                        self::fields::ObjectLitField::Props(usize::MAX),
                    ));
                    <Vec<PropOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                        props,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ObjectPat {
    #[doc = "Calls [VisitAstPath`::visit_object_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectPat(
                        self,
                        self::fields::ObjectPatField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectPat(
                        self,
                        self::fields::ObjectPatField::Props(usize::MAX),
                    ));
                    <Vec<ObjectPatProp> as VisitWithAstPath<V>>::visit_with_ast_path(
                        props,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectPat(
                        self,
                        self::fields::ObjectPatField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ObjectPatProp {
    #[doc = "Calls [VisitAstPath`::visit_object_pat_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectPatProp(
                    self,
                    self::fields::ObjectPatPropField::KeyValue,
                ));
                <KeyValuePatProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectPatProp(
                    self,
                    self::fields::ObjectPatPropField::Assign,
                ));
                <AssignPatProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ObjectPatProp(
                    self,
                    self::fields::ObjectPatPropField::Rest,
                ));
                <RestPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for OptCall {
    #[doc = "Calls [VisitAstPath`::visit_opt_call`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_call(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptCall(
                        self,
                        self::fields::OptCallField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptCall(
                        self,
                        self::fields::OptCallField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptCall(
                        self,
                        self::fields::OptCallField::Callee,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptCall(
                        self,
                        self::fields::OptCallField::Args(usize::MAX),
                    ));
                    <Vec<ExprOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptCall(
                        self,
                        self::fields::OptCallField::TypeArgs,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitWithAstPath < V > > :: visit_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for OptChainBase {
    #[doc = "Calls [VisitAstPath`::visit_opt_chain_base`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_base(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptChainBase(
                    self,
                    self::fields::OptChainBaseField::Member,
                ));
                <MemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            OptChainBase::Call { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptChainBase(
                    self,
                    self::fields::OptChainBaseField::Call,
                ));
                <OptCall as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for OptChainExpr {
    #[doc = "Calls [VisitAstPath`::visit_opt_chain_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptChainExpr(
                        self,
                        self::fields::OptChainExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::OptChainExpr(
                        self,
                        self::fields::OptChainExprField::Base,
                    ));
                    <Box<OptChainBase> as VisitWithAstPath<V>>::visit_with_ast_path(
                        base,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Param {
    #[doc = "Calls [VisitAstPath`::visit_param`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Param(
                        self,
                        self::fields::ParamField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Param(
                        self,
                        self::fields::ParamField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Param(self, self::fields::ParamField::Pat));
                    <Pat as VisitWithAstPath<V>>::visit_with_ast_path(
                        pat,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ParamOrTsParamProp {
    #[doc = "Calls [VisitAstPath`::visit_param_or_ts_param_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ParamOrTsParamProp(
                    self,
                    self::fields::ParamOrTsParamPropField::TsParamProp,
                ));
                <TsParamProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ParamOrTsParamProp(
                    self,
                    self::fields::ParamOrTsParamPropField::Param,
                ));
                <Param as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ParenExpr {
    #[doc = "Calls [VisitAstPath`::visit_paren_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_paren_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ParenExpr { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ParenExpr(
                        self,
                        self::fields::ParenExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ParenExpr(
                        self,
                        self::fields::ParenExprField::Expr,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Pat {
    #[doc = "Calls [VisitAstPath`::visit_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_pat(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Pat(self, self::fields::PatField::Ident));
                <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Array { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Pat(self, self::fields::PatField::Array));
                <ArrayPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Rest { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Pat(self, self::fields::PatField::Rest));
                <RestPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Object { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Pat(self, self::fields::PatField::Object));
                <ObjectPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Assign { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Pat(self, self::fields::PatField::Assign));
                <AssignPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Pat(self, self::fields::PatField::Invalid));
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Pat(self, self::fields::PatField::Expr));
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PrivateMethod {
    #[doc = "Calls [VisitAstPath`::visit_private_method`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_method(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateMethod(
                        self,
                        self::fields::PrivateMethodField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateMethod(
                        self,
                        self::fields::PrivateMethodField::Key,
                    ));
                    <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateMethod(
                        self,
                        self::fields::PrivateMethodField::Function,
                    ));
                    <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateMethod(
                        self,
                        self::fields::PrivateMethodField::Kind,
                    ));
                    <MethodKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateMethod(
                        self,
                        self::fields::PrivateMethodField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PrivateName {
    #[doc = "Calls [VisitAstPath`::visit_private_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PrivateName { span, name } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateName(
                        self,
                        self::fields::PrivateNameField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateName(
                        self,
                        self::fields::PrivateNameField::Name,
                    ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PrivateProp {
    #[doc = "Calls [VisitAstPath`::visit_private_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateProp(
                        self,
                        self::fields::PrivatePropField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateProp(
                        self,
                        self::fields::PrivatePropField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateProp(
                        self,
                        self::fields::PrivatePropField::Key,
                    ));
                    <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateProp(
                        self,
                        self::fields::PrivatePropField::Value,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateProp(
                        self,
                        self::fields::PrivatePropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateProp(
                        self,
                        self::fields::PrivatePropField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PrivateProp(
                        self,
                        self::fields::PrivatePropField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Program {
    #[doc = "Calls [VisitAstPath`::visit_program`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_program(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Program::Module { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Program(
                    self,
                    self::fields::ProgramField::Module,
                ));
                <Module as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Program::Script { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Program(
                    self,
                    self::fields::ProgramField::Script,
                ));
                <Script as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Prop {
    #[doc = "Calls [VisitAstPath`::visit_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Prop(
                    self,
                    self::fields::PropField::Shorthand,
                ));
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::KeyValue { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Prop(
                    self,
                    self::fields::PropField::KeyValue,
                ));
                <KeyValueProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Assign { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Prop(
                    self,
                    self::fields::PropField::Assign,
                ));
                <AssignProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Getter { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Prop(
                    self,
                    self::fields::PropField::Getter,
                ));
                <GetterProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Setter { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Prop(
                    self,
                    self::fields::PropField::Setter,
                ));
                <SetterProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Method { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Prop(
                    self,
                    self::fields::PropField::Method,
                ));
                <MethodProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PropName {
    #[doc = "Calls [VisitAstPath`::visit_prop_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_name(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PropName(
                    self,
                    self::fields::PropNameField::Ident,
                ));
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::Str { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PropName(
                    self,
                    self::fields::PropNameField::Str,
                ));
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::Num { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PropName(
                    self,
                    self::fields::PropNameField::Num,
                ));
                <Number as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PropName(
                    self,
                    self::fields::PropNameField::Computed,
                ));
                <ComputedPropName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::BigInt { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PropName(
                    self,
                    self::fields::PropNameField::BigInt,
                ));
                <BigInt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PropOrSpread {
    #[doc = "Calls [VisitAstPath`::visit_prop_or_spread`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spread(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PropOrSpread(
                    self,
                    self::fields::PropOrSpreadField::Spread,
                ));
                <SpreadElement as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::PropOrSpread(
                    self,
                    self::fields::PropOrSpreadField::Prop,
                ));
                <Box<Prop> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Regex {
    #[doc = "Calls [VisitAstPath`::visit_regex`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_regex(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Regex { span, exp, flags } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Regex(
                        self,
                        self::fields::RegexField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Regex(self, self::fields::RegexField::Exp));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        exp,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Regex(
                        self,
                        self::fields::RegexField::Flags,
                    ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        flags,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for RestPat {
    #[doc = "Calls [VisitAstPath`::visit_rest_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_rest_pat(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::RestPat(
                        self,
                        self::fields::RestPatField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::RestPat(
                        self,
                        self::fields::RestPatField::Dot3Token,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        dot3_token,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::RestPat(
                        self,
                        self::fields::RestPatField::Arg,
                    ));
                    <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::RestPat(
                        self,
                        self::fields::RestPatField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ReturnStmt {
    #[doc = "Calls [VisitAstPath`::visit_return_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_return_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ReturnStmt { span, arg } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ReturnStmt(
                        self,
                        self::fields::ReturnStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ReturnStmt(
                        self,
                        self::fields::ReturnStmtField::Arg,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Script {
    #[doc = "Calls [VisitAstPath`::visit_script`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_script(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Script(
                        self,
                        self::fields::ScriptField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Script(
                        self,
                        self::fields::ScriptField::Body(usize::MAX),
                    ));
                    <Vec<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Script(
                        self,
                        self::fields::ScriptField::Shebang,
                    ));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        shebang,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SeqExpr {
    #[doc = "Calls [VisitAstPath`::visit_seq_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_seq_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SeqExpr { span, exprs } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SeqExpr(
                        self,
                        self::fields::SeqExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SeqExpr(
                        self,
                        self::fields::SeqExprField::Exprs(usize::MAX),
                    ));
                    <Vec<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        exprs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SetterProp {
    #[doc = "Calls [VisitAstPath`::visit_setter_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_setter_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SetterProp(
                        self,
                        self::fields::SetterPropField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SetterProp(
                        self,
                        self::fields::SetterPropField::Key,
                    ));
                    <PropName as VisitWithAstPath<V>>::visit_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SetterProp(
                        self,
                        self::fields::SetterPropField::ThisParam,
                    ));
                    <Option<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                        this_param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SetterProp(
                        self,
                        self::fields::SetterPropField::Param,
                    ));
                    <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                        param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SetterProp(
                        self,
                        self::fields::SetterPropField::Body,
                    ));
                    <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SimpleAssignTarget {
    #[doc = "Calls [VisitAstPath`::visit_simple_assign_target`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_simple_assign_target(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::Ident,
                ));
                <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::Member,
                ));
                <MemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::SuperProp,
                ));
                <SuperPropExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::Paren,
                ));
                <ParenExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::OptChain,
                ));
                <OptChainExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::TsAs,
                ));
                <TsAsExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::TsSatisfies,
                ));
                <TsSatisfiesExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::TsNonNull,
                ));
                <TsNonNullExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::TsTypeAssertion,
                ));
                <TsTypeAssertion as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::TsInstantiation,
                ));
                <TsInstantiation as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SimpleAssignTarget(
                    self,
                    self::fields::SimpleAssignTargetField::Invalid,
                ));
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SpreadElement {
    #[doc = "Calls [VisitAstPath`::visit_spread_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_spread_element(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SpreadElement { dot3_token, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SpreadElement(
                        self,
                        self::fields::SpreadElementField::Dot3Token,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        dot3_token,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SpreadElement(
                        self,
                        self::fields::SpreadElementField::Expr,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for StaticBlock {
    #[doc = "Calls [VisitAstPath`::visit_static_block`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_static_block(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            StaticBlock { span, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::StaticBlock(
                        self,
                        self::fields::StaticBlockField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::StaticBlock(
                        self,
                        self::fields::StaticBlockField::Body,
                    ));
                    <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Stmt {
    #[doc = "Calls [VisitAstPath`::visit_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::Block));
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Empty { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::Empty));
                <EmptyStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Debugger { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Stmt(
                    self,
                    self::fields::StmtField::Debugger,
                ));
                <DebuggerStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::With { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::With));
                <WithStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Return { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Stmt(
                    self,
                    self::fields::StmtField::Return,
                ));
                <ReturnStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Labeled { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Stmt(
                    self,
                    self::fields::StmtField::Labeled,
                ));
                <LabeledStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Break { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::Break));
                <BreakStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Continue { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Stmt(
                    self,
                    self::fields::StmtField::Continue,
                ));
                <ContinueStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::If { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::If));
                <IfStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Switch { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Stmt(
                    self,
                    self::fields::StmtField::Switch,
                ));
                <SwitchStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Throw { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::Throw));
                <ThrowStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Try { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::Try));
                <Box<TryStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::While { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::While));
                <WhileStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::DoWhile { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Stmt(
                    self,
                    self::fields::StmtField::DoWhile,
                ));
                <DoWhileStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::For { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::For));
                <ForStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::ForIn { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::ForIn));
                <ForInStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::ForOf { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::ForOf));
                <ForOfStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Decl { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::Decl));
                <Decl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Stmt(self, self::fields::StmtField::Expr));
                <ExprStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Str {
    #[doc = "Calls [VisitAstPath`::visit_str`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_str(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Str { span, value, raw } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Str(self, self::fields::StrField::Span));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Str(self, self::fields::StrField::Value));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Str(self, self::fields::StrField::Raw));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Super {
    #[doc = "Calls [VisitAstPath`::visit_super`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Super { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Super(
                        self,
                        self::fields::SuperField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SuperProp {
    #[doc = "Calls [VisitAstPath`::visit_super_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SuperProp(
                    self,
                    self::fields::SuperPropField::Ident,
                ));
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SuperProp::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SuperProp(
                    self,
                    self::fields::SuperPropField::Computed,
                ));
                <ComputedPropName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SuperPropExpr {
    #[doc = "Calls [VisitAstPath`::visit_super_prop_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SuperPropExpr(
                        self,
                        self::fields::SuperPropExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SuperPropExpr(
                        self,
                        self::fields::SuperPropExprField::Obj,
                    ));
                    <Super as VisitWithAstPath<V>>::visit_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SuperPropExpr(
                        self,
                        self::fields::SuperPropExprField::Prop,
                    ));
                    <SuperProp as VisitWithAstPath<V>>::visit_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SwitchCase {
    #[doc = "Calls [VisitAstPath`::visit_switch_case`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_case(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SwitchCase { span, test, cons } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SwitchCase(
                        self,
                        self::fields::SwitchCaseField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SwitchCase(
                        self,
                        self::fields::SwitchCaseField::Test,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SwitchCase(
                        self,
                        self::fields::SwitchCaseField::Cons(usize::MAX),
                    ));
                    <Vec<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SwitchStmt {
    #[doc = "Calls [VisitAstPath`::visit_switch_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SwitchStmt(
                        self,
                        self::fields::SwitchStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SwitchStmt(
                        self,
                        self::fields::SwitchStmtField::Discriminant,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        discriminant,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::SwitchStmt(
                        self,
                        self::fields::SwitchStmtField::Cases(usize::MAX),
                    ));
                    <Vec<SwitchCase> as VisitWithAstPath<V>>::visit_with_ast_path(
                        cases,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TaggedTpl {
    #[doc = "Calls [VisitAstPath`::visit_tagged_tpl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tagged_tpl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TaggedTpl(
                        self,
                        self::fields::TaggedTplField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TaggedTpl(
                        self,
                        self::fields::TaggedTplField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TaggedTpl(
                        self,
                        self::fields::TaggedTplField::Tag,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        tag,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TaggedTpl(
                        self,
                        self::fields::TaggedTplField::TypeParams,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitWithAstPath < V > > :: visit_with_ast_path (type_params , visitor , & mut * __ast_path)
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TaggedTpl(
                        self,
                        self::fields::TaggedTplField::Tpl,
                    ));
                    <Box<Tpl> as VisitWithAstPath<V>>::visit_with_ast_path(
                        tpl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ThisExpr {
    #[doc = "Calls [VisitAstPath`::visit_this_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_this_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ThisExpr { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ThisExpr(
                        self,
                        self::fields::ThisExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ThrowStmt {
    #[doc = "Calls [VisitAstPath`::visit_throw_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_throw_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ThrowStmt { span, arg } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ThrowStmt(
                        self,
                        self::fields::ThrowStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ThrowStmt(
                        self,
                        self::fields::ThrowStmtField::Arg,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Tpl {
    #[doc = "Calls [VisitAstPath`::visit_tpl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Tpl(self, self::fields::TplField::Span));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Tpl(
                        self,
                        self::fields::TplField::Exprs(usize::MAX),
                    ));
                    <Vec<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        exprs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Tpl(
                        self,
                        self::fields::TplField::Quasis(usize::MAX),
                    ));
                    <Vec<TplElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                        quasis,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TplElement {
    #[doc = "Calls [VisitAstPath`::visit_tpl_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_element(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TplElement(
                        self,
                        self::fields::TplElementField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TplElement(
                        self,
                        self::fields::TplElementField::Cooked,
                    ));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        cooked,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TplElement(
                        self,
                        self::fields::TplElementField::Raw,
                    ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TruePlusMinus {
    #[doc = "Calls [VisitAstPath`::visit_true_plus_minus`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_true_plus_minus(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TryStmt {
    #[doc = "Calls [VisitAstPath`::visit_try_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_try_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TryStmt(
                        self,
                        self::fields::TryStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TryStmt(
                        self,
                        self::fields::TryStmtField::Block,
                    ));
                    <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                        block,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TryStmt(
                        self,
                        self::fields::TryStmtField::Handler,
                    ));
                    <Option<CatchClause> as VisitWithAstPath<V>>::visit_with_ast_path(
                        handler,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::TryStmt(
                        self,
                        self::fields::TryStmtField::Finalizer,
                    ));
                    <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        finalizer,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UnaryExpr {
    #[doc = "Calls [VisitAstPath`::visit_unary_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UnaryExpr { span, op, arg } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UnaryExpr(
                        self,
                        self::fields::UnaryExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UnaryExpr(
                        self,
                        self::fields::UnaryExprField::Op,
                    ));
                    <UnaryOp as VisitWithAstPath<V>>::visit_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UnaryExpr(
                        self,
                        self::fields::UnaryExprField::Arg,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UnaryOp {
    #[doc = "Calls [VisitAstPath`::visit_unary_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_op(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UpdateExpr {
    #[doc = "Calls [VisitAstPath`::visit_update_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UpdateExpr(
                        self,
                        self::fields::UpdateExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UpdateExpr(
                        self,
                        self::fields::UpdateExprField::Op,
                    ));
                    <UpdateOp as VisitWithAstPath<V>>::visit_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UpdateExpr(
                        self,
                        self::fields::UpdateExprField::Arg,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UpdateOp {
    #[doc = "Calls [VisitAstPath`::visit_update_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_op(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UsingDecl {
    #[doc = "Calls [VisitAstPath`::visit_using_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_using_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UsingDecl(
                        self,
                        self::fields::UsingDeclField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::UsingDecl(
                        self,
                        self::fields::UsingDeclField::Decls(usize::MAX),
                    ));
                    <Vec<VarDeclarator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decls,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDecl {
    #[doc = "Calls [VisitAstPath`::visit_var_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDecl(
                        self,
                        self::fields::VarDeclField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDecl(
                        self,
                        self::fields::VarDeclField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitWithAstPath<V>>::visit_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDecl(
                        self,
                        self::fields::VarDeclField::Kind,
                    ));
                    <VarDeclKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDecl(
                        self,
                        self::fields::VarDeclField::Decls(usize::MAX),
                    ));
                    <Vec<VarDeclarator> as VisitWithAstPath<V>>::visit_with_ast_path(
                        decls,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDeclKind {
    #[doc = "Calls [VisitAstPath`::visit_var_decl_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDeclOrExpr {
    #[doc = "Calls [VisitAstPath`::visit_var_decl_or_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_or_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDeclOrExpr(
                    self,
                    self::fields::VarDeclOrExprField::VarDecl,
                ));
                <Box<VarDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDeclOrExpr(
                    self,
                    self::fields::VarDeclOrExprField::Expr,
                ));
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDeclarator {
    #[doc = "Calls [VisitAstPath`::visit_var_declarator`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarator(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDeclarator(
                        self,
                        self::fields::VarDeclaratorField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDeclarator(
                        self,
                        self::fields::VarDeclaratorField::Name,
                    ));
                    <Pat as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::VarDeclarator(
                        self,
                        self::fields::VarDeclaratorField::Init,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        init,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for WhileStmt {
    #[doc = "Calls [VisitAstPath`::visit_while_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_while_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            WhileStmt { span, test, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::WhileStmt(
                        self,
                        self::fields::WhileStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::WhileStmt(
                        self,
                        self::fields::WhileStmtField::Test,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::WhileStmt(
                        self,
                        self::fields::WhileStmtField::Body,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for WithStmt {
    #[doc = "Calls [VisitAstPath`::visit_with_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_with_stmt(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            WithStmt { span, obj, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::WithStmt(
                        self,
                        self::fields::WithStmtField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::WithStmt(
                        self,
                        self::fields::WithStmtField::Obj,
                    ));
                    <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::WithStmt(
                        self,
                        self::fields::WithStmtField::Body,
                    ));
                    <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for YieldExpr {
    #[doc = "Calls [VisitAstPath`::visit_yield_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_yield_expr(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::YieldExpr(
                        self,
                        self::fields::YieldExprField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::YieldExpr(
                        self,
                        self::fields::YieldExprField::Arg,
                    ));
                    <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitAstPath`::visit_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BigIntValue {
    #[doc = "Calls [VisitAstPath`::visit_big_int_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int_value(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ClassMember] {
    #[doc = "Calls [VisitAstPath`::visit_class_members`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_members(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ClassMember as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Decorator] {
    #[doc = "Calls [VisitAstPath`::visit_decorators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorators(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Decorator as VisitWithAstPath<V>>::visit_with_ast_path(item, visitor, &mut *__ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ExportSpecifier] {
    #[doc = "Calls [VisitAstPath`::visit_export_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ExportSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ExprOrSpread] {
    #[doc = "Calls [VisitAstPath`::visit_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ExprOrSpread as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Box<Expr>] {
    #[doc = "Calls [VisitAstPath`::visit_exprs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_exprs(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(item, visitor, &mut *__ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ImportSpecifier] {
    #[doc = "Calls [VisitAstPath`::visit_import_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ImportSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ImportWithItem] {
    #[doc = "Calls [VisitAstPath`::visit_import_with_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_items(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ImportWithItem as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [JSXAttrOrSpread] {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <JSXAttrOrSpread as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [JSXElementChild] {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element_childs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_childs(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <JSXElementChild as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ModuleItem] {
    #[doc = "Calls [VisitAstPath`::visit_module_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_items(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ModuleItem as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ObjectPatProp] {
    #[doc = "Calls [VisitAstPath`::visit_object_pat_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_props(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ObjectPatProp as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitAstPath`::visit_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<BlockStmt> {
    #[doc = "Calls [VisitAstPath`::visit_opt_block_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_block_stmt(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<CatchClause> {
    #[doc = "Calls [VisitAstPath`::visit_opt_catch_clause`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_catch_clause(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <CatchClause as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<Expr>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<ExprOrSpread> {
    #[doc = "Calls [VisitAstPath`::visit_opt_expr_or_spread`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spread(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <ExprOrSpread as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Vec<ExprOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Ident> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ident`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ident(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<JSXAttrValue> {
    #[doc = "Calls [VisitAstPath`::visit_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_attr_value(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <JSXAttrValue as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<JSXClosingElement> {
    #[doc = "Calls [VisitAstPath`::visit_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_closing_element(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <JSXClosingElement as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<ModuleExportName> {
    #[doc = "Calls [VisitAstPath`::visit_opt_module_export_name`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_module_export_name(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <ModuleExportName as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_object_lit`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_object_lit(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Box<ObjectLit> as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Pat> {
    #[doc = "Calls [VisitAstPath`::visit_opt_pat`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_pat(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Pat as VisitWithAstPath<V>>::visit_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<swc_common::Span> {
    #[doc = "Calls [VisitAstPath`::visit_opt_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_span(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<Stmt>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_stmt(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<Str>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_str`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_str(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Box<Str> as VisitWithAstPath<V>>::visit_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [VisitAstPath`::visit_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_var_decl_or_expr(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <VarDeclOrExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Option<ExprOrSpread>] {
    #[doc = "Calls [VisitAstPath`::visit_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Option<ExprOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Option<Pat>] {
    #[doc = "Calls [VisitAstPath`::visit_opt_vec_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_pats(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Option<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ParamOrTsParamProp] {
    #[doc = "Calls [VisitAstPath`::visit_param_or_ts_param_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_props(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ParamOrTsParamProp as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Param] {
    #[doc = "Calls [VisitAstPath`::visit_params`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_params(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Param as VisitWithAstPath<V>>::visit_with_ast_path(item, visitor, &mut *__ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Pat] {
    #[doc = "Calls [VisitAstPath`::visit_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_pats(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Pat as VisitWithAstPath<V>>::visit_with_ast_path(item, visitor, &mut *__ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [PropOrSpread] {
    #[doc = "Calls [VisitAstPath`::visit_prop_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <PropOrSpread as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [VisitAstPath`::visit_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_span(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Stmt] {
    #[doc = "Calls [VisitAstPath`::visit_stmts`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_stmts(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Stmt as VisitWithAstPath<V>>::visit_with_ast_path(item, visitor, &mut *__ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [SwitchCase] {
    #[doc = "Calls [VisitAstPath`::visit_switch_cases`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_cases(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <SwitchCase as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_common::SyntaxContext {
    #[doc = "Calls [VisitAstPath`::visit_syntax_context`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_syntax_context(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TplElement] {
    #[doc = "Calls [VisitAstPath`::visit_tpl_elements`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_elements(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <TplElement as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [VarDeclarator] {
    #[doc = "Calls [VisitAstPath`::visit_var_declarators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarators(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <VarDeclarator as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitAstPath,
    T: VisitWithAstPath<V>,
{
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v = <T as VisitWithAstPath<V>>::visit_with_ast_path(&**self, visitor, __ast_path);
        v
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v =
            <T as VisitWithAstPath<V>>::visit_children_with_ast_path(&**self, visitor, __ast_path);
        v
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitWithAstPath<V> for std::vec::Vec<T>
where
    V: ?Sized + VisitAstPath,
    [T]: VisitWithAstPath<V>,
{
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v = <[T] as VisitWithAstPath<V>>::visit_with_ast_path(self, visitor, __ast_path);
        v
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v =
            <[T] as VisitWithAstPath<V>>::visit_children_with_ast_path(self, visitor, __ast_path);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
pub trait VisitMut {
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        <ArrayLit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        <ArrayPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        <ArrowExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        <AssignExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        <AssignOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        <AssignPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        <AssignPatProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        <AssignProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        <AssignTarget as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        <AssignTargetPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        <swc_atoms::Atom as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        <AutoAccessor as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        <AwaitExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        <BigInt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        <BigIntValue as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        <BinExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        <BinaryOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        <BindingIdent as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        <BlockStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        <BlockStmtOrExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool) {
        <Bool as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        <BreakStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        <CallExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee) {
        <Callee as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        <CatchClause as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class) {
        <Class as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        <ClassDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        <ClassExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        <ClassMember as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        <Vec<ClassMember> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        <ClassMethod as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        <ClassProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        <ComputedPropName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        <CondExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        <Constructor as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        <ContinueStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        <DebuggerStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl) {
        <Decl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        <Decorator as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        <Vec<Decorator> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        <DefaultDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        <DoWhileStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        <EmptyStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        <ExportAll as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        <ExportDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        <ExportDefaultDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        <ExportDefaultExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        <ExportDefaultSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        <ExportNamedSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        <ExportNamespaceSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        <ExportSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        <Vec<ExportSpecifier> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr) {
        <Expr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        <ExprOrSpread as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        <Vec<ExprOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        <ExprStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        <Vec<Box<Expr>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        <FnDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        <FnExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        <ForHead as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        <ForInStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        <ForOfStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        <ForStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function) {
        <Function as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        <GetterProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident) {
        <Ident as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        <IdentName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        <IfStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import) {
        <Import as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        <ImportDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        <ImportDefaultSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        <ImportNamedSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        <ImportPhase as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        <ImportSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        <Vec<ImportSpecifier> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        <ImportStarAsSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        <ImportWith as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        <ImportWithItem as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        <Vec<ImportWithItem> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        <Invalid as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        <JSXAttr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        <JSXAttrName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        <JSXAttrOrSpread as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        <Vec<JSXAttrOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        <JSXAttrValue as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        <JSXClosingElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        <JSXClosingFragment as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        <JSXElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        <JSXElementChild as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        <Vec<JSXElementChild> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        <JSXElementName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        <JSXEmptyExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        <JSXExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        <JSXExprContainer as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        <JSXFragment as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        <JSXMemberExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        <JSXNamespacedName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        <JSXObject as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        <JSXOpeningElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        <JSXOpeningFragment as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        <JSXSpreadChild as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        <JSXText as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key) {
        <Key as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        <KeyValuePatProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        <KeyValueProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        <LabeledStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit) {
        <Lit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        <MemberExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        <MemberProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        <MetaPropExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        <MetaPropKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        <MethodKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        <MethodProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module) {
        <Module as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        <ModuleDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        <ModuleExportName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        <ModuleItem as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        <Vec<ModuleItem> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        <NamedExport as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        <NewExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null) {
        <Null as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number) {
        <Number as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        <ObjectLit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        <ObjectPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        <ObjectPatProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        <Vec<ObjectPatProp> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        <Option<swc_atoms::Atom> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        <Option<BlockStmt> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        <OptCall as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        <Option<CatchClause> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        <OptChainBase as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        <OptChainExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        <Option<Box<Expr>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        <Option<ExprOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        <Option<Vec<ExprOrSpread>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        <Option<Ident> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        <Option<JSXAttrValue> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        <Option<JSXClosingElement> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        <Option<ModuleExportName> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        <Option<Box<ObjectLit>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        <Option<Pat> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        <Option<swc_common::Span> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        <Option<Box<Stmt>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        <Option<Box<Str>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        <Option<VarDeclOrExpr> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        <Vec<Option<ExprOrSpread>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        <Vec<Option<Pat>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param) {
        <Param as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        <ParamOrTsParamProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        <Vec<ParamOrTsParamProp> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        <Vec<Param> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        <ParenExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat) {
        <Pat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        <Vec<Pat> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        <PrivateMethod as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        <PrivateName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        <PrivateProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program) {
        <Program as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop) {
        <Prop as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        <PropName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        <PropOrSpread as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        <Vec<PropOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex) {
        <Regex as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        <RestPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        <ReturnStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script) {
        <Script as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        <SeqExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        <SetterProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        <SimpleAssignTarget as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        <swc_common::Span as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        <SpreadElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        <StaticBlock as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        <Stmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        <Vec<Stmt> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str) {
        <Str as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super) {
        <Super as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        <SuperProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        <SuperPropExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        <SwitchCase as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        <Vec<SwitchCase> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        <SwitchStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        <swc_common::SyntaxContext as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        <TaggedTpl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        <ThisExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        <ThrowStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        <Tpl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        <TplElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        <Vec<TplElement> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        <TruePlusMinus as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        <TryStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        <UnaryExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        <UnaryOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        <UpdateExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        <UpdateOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        <UsingDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        <VarDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        <VarDeclKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        <VarDeclOrExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        <VarDeclarator as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        <Vec<VarDeclarator> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        <WhileStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        <WithStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        <YieldExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
}
impl<V> VisitMut for &mut V
where
    V: ?Sized + VisitMut,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        <V as VisitMut>::visit_mut_array_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        <V as VisitMut>::visit_mut_array_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        <V as VisitMut>::visit_mut_arrow_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        <V as VisitMut>::visit_mut_assign_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        <V as VisitMut>::visit_mut_assign_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        <V as VisitMut>::visit_mut_assign_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        <V as VisitMut>::visit_mut_assign_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        <V as VisitMut>::visit_mut_assign_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        <V as VisitMut>::visit_mut_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        <V as VisitMut>::visit_mut_assign_target_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        <V as VisitMut>::visit_mut_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        <V as VisitMut>::visit_mut_auto_accessor(&mut **self, node)
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        <V as VisitMut>::visit_mut_await_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        <V as VisitMut>::visit_mut_big_int(&mut **self, node)
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        <V as VisitMut>::visit_mut_big_int_value(&mut **self, node)
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        <V as VisitMut>::visit_mut_bin_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        <V as VisitMut>::visit_mut_binary_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        <V as VisitMut>::visit_mut_binding_ident(&mut **self, node)
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        <V as VisitMut>::visit_mut_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        <V as VisitMut>::visit_mut_block_stmt_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool) {
        <V as VisitMut>::visit_mut_bool(&mut **self, node)
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        <V as VisitMut>::visit_mut_break_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        <V as VisitMut>::visit_mut_call_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee) {
        <V as VisitMut>::visit_mut_callee(&mut **self, node)
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        <V as VisitMut>::visit_mut_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class) {
        <V as VisitMut>::visit_mut_class(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        <V as VisitMut>::visit_mut_class_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        <V as VisitMut>::visit_mut_class_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        <V as VisitMut>::visit_mut_class_member(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        <V as VisitMut>::visit_mut_class_members(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        <V as VisitMut>::visit_mut_class_method(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        <V as VisitMut>::visit_mut_class_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        <V as VisitMut>::visit_mut_computed_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        <V as VisitMut>::visit_mut_cond_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        <V as VisitMut>::visit_mut_constructor(&mut **self, node)
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        <V as VisitMut>::visit_mut_continue_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        <V as VisitMut>::visit_mut_debugger_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl) {
        <V as VisitMut>::visit_mut_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        <V as VisitMut>::visit_mut_decorator(&mut **self, node)
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        <V as VisitMut>::visit_mut_decorators(&mut **self, node)
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        <V as VisitMut>::visit_mut_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        <V as VisitMut>::visit_mut_do_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        <V as VisitMut>::visit_mut_empty_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        <V as VisitMut>::visit_mut_export_all(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        <V as VisitMut>::visit_mut_export_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        <V as VisitMut>::visit_mut_export_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        <V as VisitMut>::visit_mut_export_default_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        <V as VisitMut>::visit_mut_export_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        <V as VisitMut>::visit_mut_export_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        <V as VisitMut>::visit_mut_export_namespace_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        <V as VisitMut>::visit_mut_export_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        <V as VisitMut>::visit_mut_export_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr) {
        <V as VisitMut>::visit_mut_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        <V as VisitMut>::visit_mut_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        <V as VisitMut>::visit_mut_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        <V as VisitMut>::visit_mut_expr_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        <V as VisitMut>::visit_mut_exprs(&mut **self, node)
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        <V as VisitMut>::visit_mut_fn_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        <V as VisitMut>::visit_mut_fn_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        <V as VisitMut>::visit_mut_for_head(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        <V as VisitMut>::visit_mut_for_in_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        <V as VisitMut>::visit_mut_for_of_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        <V as VisitMut>::visit_mut_for_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function) {
        <V as VisitMut>::visit_mut_function(&mut **self, node)
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        <V as VisitMut>::visit_mut_getter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident) {
        <V as VisitMut>::visit_mut_ident(&mut **self, node)
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        <V as VisitMut>::visit_mut_ident_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        <V as VisitMut>::visit_mut_if_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import) {
        <V as VisitMut>::visit_mut_import(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        <V as VisitMut>::visit_mut_import_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        <V as VisitMut>::visit_mut_import_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        <V as VisitMut>::visit_mut_import_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        <V as VisitMut>::visit_mut_import_phase(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        <V as VisitMut>::visit_mut_import_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        <V as VisitMut>::visit_mut_import_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        <V as VisitMut>::visit_mut_import_star_as_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        <V as VisitMut>::visit_mut_import_with(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        <V as VisitMut>::visit_mut_import_with_item(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        <V as VisitMut>::visit_mut_import_with_items(&mut **self, node)
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        <V as VisitMut>::visit_mut_invalid(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        <V as VisitMut>::visit_mut_jsx_attr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        <V as VisitMut>::visit_mut_jsx_attr_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        <V as VisitMut>::visit_mut_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        <V as VisitMut>::visit_mut_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        <V as VisitMut>::visit_mut_jsx_closing_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        <V as VisitMut>::visit_mut_jsx_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        <V as VisitMut>::visit_mut_jsx_element_child(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        <V as VisitMut>::visit_mut_jsx_element_childs(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        <V as VisitMut>::visit_mut_jsx_element_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        <V as VisitMut>::visit_mut_jsx_empty_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        <V as VisitMut>::visit_mut_jsx_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        <V as VisitMut>::visit_mut_jsx_expr_container(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        <V as VisitMut>::visit_mut_jsx_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        <V as VisitMut>::visit_mut_jsx_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        <V as VisitMut>::visit_mut_jsx_namespaced_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        <V as VisitMut>::visit_mut_jsx_object(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        <V as VisitMut>::visit_mut_jsx_opening_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        <V as VisitMut>::visit_mut_jsx_opening_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        <V as VisitMut>::visit_mut_jsx_spread_child(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        <V as VisitMut>::visit_mut_jsx_text(&mut **self, node)
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key) {
        <V as VisitMut>::visit_mut_key(&mut **self, node)
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        <V as VisitMut>::visit_mut_key_value_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        <V as VisitMut>::visit_mut_key_value_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        <V as VisitMut>::visit_mut_labeled_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit) {
        <V as VisitMut>::visit_mut_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        <V as VisitMut>::visit_mut_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        <V as VisitMut>::visit_mut_member_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        <V as VisitMut>::visit_mut_meta_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        <V as VisitMut>::visit_mut_meta_prop_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        <V as VisitMut>::visit_mut_method_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        <V as VisitMut>::visit_mut_method_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module) {
        <V as VisitMut>::visit_mut_module(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        <V as VisitMut>::visit_mut_module_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        <V as VisitMut>::visit_mut_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        <V as VisitMut>::visit_mut_module_item(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        <V as VisitMut>::visit_mut_module_items(&mut **self, node)
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        <V as VisitMut>::visit_mut_named_export(&mut **self, node)
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        <V as VisitMut>::visit_mut_new_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null) {
        <V as VisitMut>::visit_mut_null(&mut **self, node)
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number) {
        <V as VisitMut>::visit_mut_number(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        <V as VisitMut>::visit_mut_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        <V as VisitMut>::visit_mut_object_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        <V as VisitMut>::visit_mut_object_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        <V as VisitMut>::visit_mut_object_pat_props(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        <V as VisitMut>::visit_mut_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        <V as VisitMut>::visit_mut_opt_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        <V as VisitMut>::visit_mut_opt_call(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        <V as VisitMut>::visit_mut_opt_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        <V as VisitMut>::visit_mut_opt_chain_base(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        <V as VisitMut>::visit_mut_opt_chain_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        <V as VisitMut>::visit_mut_opt_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        <V as VisitMut>::visit_mut_opt_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        <V as VisitMut>::visit_mut_opt_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        <V as VisitMut>::visit_mut_opt_ident(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        <V as VisitMut>::visit_mut_opt_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        <V as VisitMut>::visit_mut_opt_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        <V as VisitMut>::visit_mut_opt_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        <V as VisitMut>::visit_mut_opt_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        <V as VisitMut>::visit_mut_opt_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        <V as VisitMut>::visit_mut_opt_span(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        <V as VisitMut>::visit_mut_opt_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        <V as VisitMut>::visit_mut_opt_str(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        <V as VisitMut>::visit_mut_opt_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        <V as VisitMut>::visit_mut_opt_vec_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        <V as VisitMut>::visit_mut_opt_vec_pats(&mut **self, node)
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param) {
        <V as VisitMut>::visit_mut_param(&mut **self, node)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        <V as VisitMut>::visit_mut_param_or_ts_param_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        <V as VisitMut>::visit_mut_param_or_ts_param_props(&mut **self, node)
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        <V as VisitMut>::visit_mut_params(&mut **self, node)
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        <V as VisitMut>::visit_mut_paren_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat) {
        <V as VisitMut>::visit_mut_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        <V as VisitMut>::visit_mut_pats(&mut **self, node)
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        <V as VisitMut>::visit_mut_private_method(&mut **self, node)
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        <V as VisitMut>::visit_mut_private_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        <V as VisitMut>::visit_mut_private_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program) {
        <V as VisitMut>::visit_mut_program(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop) {
        <V as VisitMut>::visit_mut_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        <V as VisitMut>::visit_mut_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        <V as VisitMut>::visit_mut_prop_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        <V as VisitMut>::visit_mut_prop_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex) {
        <V as VisitMut>::visit_mut_regex(&mut **self, node)
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        <V as VisitMut>::visit_mut_rest_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        <V as VisitMut>::visit_mut_return_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script) {
        <V as VisitMut>::visit_mut_script(&mut **self, node)
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        <V as VisitMut>::visit_mut_seq_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        <V as VisitMut>::visit_mut_setter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        <V as VisitMut>::visit_mut_simple_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        <V as VisitMut>::visit_mut_span(&mut **self, node)
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        <V as VisitMut>::visit_mut_spread_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        <V as VisitMut>::visit_mut_static_block(&mut **self, node)
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        <V as VisitMut>::visit_mut_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        <V as VisitMut>::visit_mut_stmts(&mut **self, node)
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str) {
        <V as VisitMut>::visit_mut_str(&mut **self, node)
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super) {
        <V as VisitMut>::visit_mut_super(&mut **self, node)
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        <V as VisitMut>::visit_mut_super_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        <V as VisitMut>::visit_mut_super_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        <V as VisitMut>::visit_mut_switch_case(&mut **self, node)
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        <V as VisitMut>::visit_mut_switch_cases(&mut **self, node)
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        <V as VisitMut>::visit_mut_switch_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        <V as VisitMut>::visit_mut_syntax_context(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        <V as VisitMut>::visit_mut_tagged_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        <V as VisitMut>::visit_mut_this_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        <V as VisitMut>::visit_mut_throw_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        <V as VisitMut>::visit_mut_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        <V as VisitMut>::visit_mut_tpl_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        <V as VisitMut>::visit_mut_tpl_elements(&mut **self, node)
    }

    #[inline]
    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        <V as VisitMut>::visit_mut_true_plus_minus(&mut **self, node)
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        <V as VisitMut>::visit_mut_try_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        <V as VisitMut>::visit_mut_unary_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        <V as VisitMut>::visit_mut_unary_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        <V as VisitMut>::visit_mut_update_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        <V as VisitMut>::visit_mut_update_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        <V as VisitMut>::visit_mut_using_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        <V as VisitMut>::visit_mut_var_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        <V as VisitMut>::visit_mut_var_decl_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        <V as VisitMut>::visit_mut_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        <V as VisitMut>::visit_mut_var_declarator(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        <V as VisitMut>::visit_mut_var_declarators(&mut **self, node)
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        <V as VisitMut>::visit_mut_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        <V as VisitMut>::visit_mut_with_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        <V as VisitMut>::visit_mut_yield_expr(&mut **self, node)
    }
}
impl<V> VisitMut for Box<V>
where
    V: ?Sized + VisitMut,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        <V as VisitMut>::visit_mut_array_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        <V as VisitMut>::visit_mut_array_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        <V as VisitMut>::visit_mut_arrow_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        <V as VisitMut>::visit_mut_assign_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        <V as VisitMut>::visit_mut_assign_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        <V as VisitMut>::visit_mut_assign_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        <V as VisitMut>::visit_mut_assign_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        <V as VisitMut>::visit_mut_assign_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        <V as VisitMut>::visit_mut_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        <V as VisitMut>::visit_mut_assign_target_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        <V as VisitMut>::visit_mut_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        <V as VisitMut>::visit_mut_auto_accessor(&mut **self, node)
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        <V as VisitMut>::visit_mut_await_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        <V as VisitMut>::visit_mut_big_int(&mut **self, node)
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        <V as VisitMut>::visit_mut_big_int_value(&mut **self, node)
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        <V as VisitMut>::visit_mut_bin_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        <V as VisitMut>::visit_mut_binary_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        <V as VisitMut>::visit_mut_binding_ident(&mut **self, node)
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        <V as VisitMut>::visit_mut_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        <V as VisitMut>::visit_mut_block_stmt_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool) {
        <V as VisitMut>::visit_mut_bool(&mut **self, node)
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        <V as VisitMut>::visit_mut_break_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        <V as VisitMut>::visit_mut_call_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee) {
        <V as VisitMut>::visit_mut_callee(&mut **self, node)
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        <V as VisitMut>::visit_mut_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class) {
        <V as VisitMut>::visit_mut_class(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        <V as VisitMut>::visit_mut_class_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        <V as VisitMut>::visit_mut_class_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        <V as VisitMut>::visit_mut_class_member(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        <V as VisitMut>::visit_mut_class_members(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        <V as VisitMut>::visit_mut_class_method(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        <V as VisitMut>::visit_mut_class_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        <V as VisitMut>::visit_mut_computed_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        <V as VisitMut>::visit_mut_cond_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        <V as VisitMut>::visit_mut_constructor(&mut **self, node)
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        <V as VisitMut>::visit_mut_continue_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        <V as VisitMut>::visit_mut_debugger_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl) {
        <V as VisitMut>::visit_mut_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        <V as VisitMut>::visit_mut_decorator(&mut **self, node)
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        <V as VisitMut>::visit_mut_decorators(&mut **self, node)
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        <V as VisitMut>::visit_mut_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        <V as VisitMut>::visit_mut_do_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        <V as VisitMut>::visit_mut_empty_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        <V as VisitMut>::visit_mut_export_all(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        <V as VisitMut>::visit_mut_export_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        <V as VisitMut>::visit_mut_export_default_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        <V as VisitMut>::visit_mut_export_default_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        <V as VisitMut>::visit_mut_export_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        <V as VisitMut>::visit_mut_export_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        <V as VisitMut>::visit_mut_export_namespace_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        <V as VisitMut>::visit_mut_export_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        <V as VisitMut>::visit_mut_export_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr) {
        <V as VisitMut>::visit_mut_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        <V as VisitMut>::visit_mut_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        <V as VisitMut>::visit_mut_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        <V as VisitMut>::visit_mut_expr_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        <V as VisitMut>::visit_mut_exprs(&mut **self, node)
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        <V as VisitMut>::visit_mut_fn_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        <V as VisitMut>::visit_mut_fn_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        <V as VisitMut>::visit_mut_for_head(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        <V as VisitMut>::visit_mut_for_in_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        <V as VisitMut>::visit_mut_for_of_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        <V as VisitMut>::visit_mut_for_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function) {
        <V as VisitMut>::visit_mut_function(&mut **self, node)
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        <V as VisitMut>::visit_mut_getter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident) {
        <V as VisitMut>::visit_mut_ident(&mut **self, node)
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        <V as VisitMut>::visit_mut_ident_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        <V as VisitMut>::visit_mut_if_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import) {
        <V as VisitMut>::visit_mut_import(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        <V as VisitMut>::visit_mut_import_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        <V as VisitMut>::visit_mut_import_default_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        <V as VisitMut>::visit_mut_import_named_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        <V as VisitMut>::visit_mut_import_phase(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        <V as VisitMut>::visit_mut_import_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        <V as VisitMut>::visit_mut_import_specifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        <V as VisitMut>::visit_mut_import_star_as_specifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        <V as VisitMut>::visit_mut_import_with(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        <V as VisitMut>::visit_mut_import_with_item(&mut **self, node)
    }

    #[inline]
    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        <V as VisitMut>::visit_mut_import_with_items(&mut **self, node)
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        <V as VisitMut>::visit_mut_invalid(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        <V as VisitMut>::visit_mut_jsx_attr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        <V as VisitMut>::visit_mut_jsx_attr_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        <V as VisitMut>::visit_mut_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        <V as VisitMut>::visit_mut_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        <V as VisitMut>::visit_mut_jsx_closing_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        <V as VisitMut>::visit_mut_jsx_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        <V as VisitMut>::visit_mut_jsx_element_child(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        <V as VisitMut>::visit_mut_jsx_element_childs(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        <V as VisitMut>::visit_mut_jsx_element_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        <V as VisitMut>::visit_mut_jsx_empty_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        <V as VisitMut>::visit_mut_jsx_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        <V as VisitMut>::visit_mut_jsx_expr_container(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        <V as VisitMut>::visit_mut_jsx_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        <V as VisitMut>::visit_mut_jsx_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        <V as VisitMut>::visit_mut_jsx_namespaced_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        <V as VisitMut>::visit_mut_jsx_object(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        <V as VisitMut>::visit_mut_jsx_opening_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        <V as VisitMut>::visit_mut_jsx_opening_fragment(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        <V as VisitMut>::visit_mut_jsx_spread_child(&mut **self, node)
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        <V as VisitMut>::visit_mut_jsx_text(&mut **self, node)
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key) {
        <V as VisitMut>::visit_mut_key(&mut **self, node)
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        <V as VisitMut>::visit_mut_key_value_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        <V as VisitMut>::visit_mut_key_value_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        <V as VisitMut>::visit_mut_labeled_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit) {
        <V as VisitMut>::visit_mut_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        <V as VisitMut>::visit_mut_member_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        <V as VisitMut>::visit_mut_member_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        <V as VisitMut>::visit_mut_meta_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        <V as VisitMut>::visit_mut_meta_prop_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        <V as VisitMut>::visit_mut_method_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        <V as VisitMut>::visit_mut_method_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module) {
        <V as VisitMut>::visit_mut_module(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        <V as VisitMut>::visit_mut_module_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        <V as VisitMut>::visit_mut_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        <V as VisitMut>::visit_mut_module_item(&mut **self, node)
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        <V as VisitMut>::visit_mut_module_items(&mut **self, node)
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        <V as VisitMut>::visit_mut_named_export(&mut **self, node)
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        <V as VisitMut>::visit_mut_new_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null) {
        <V as VisitMut>::visit_mut_null(&mut **self, node)
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number) {
        <V as VisitMut>::visit_mut_number(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        <V as VisitMut>::visit_mut_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        <V as VisitMut>::visit_mut_object_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        <V as VisitMut>::visit_mut_object_pat_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        <V as VisitMut>::visit_mut_object_pat_props(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        <V as VisitMut>::visit_mut_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        <V as VisitMut>::visit_mut_opt_block_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        <V as VisitMut>::visit_mut_opt_call(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        <V as VisitMut>::visit_mut_opt_catch_clause(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        <V as VisitMut>::visit_mut_opt_chain_base(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        <V as VisitMut>::visit_mut_opt_chain_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        <V as VisitMut>::visit_mut_opt_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        <V as VisitMut>::visit_mut_opt_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        <V as VisitMut>::visit_mut_opt_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        <V as VisitMut>::visit_mut_opt_ident(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        <V as VisitMut>::visit_mut_opt_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        <V as VisitMut>::visit_mut_opt_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        <V as VisitMut>::visit_mut_opt_module_export_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        <V as VisitMut>::visit_mut_opt_object_lit(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        <V as VisitMut>::visit_mut_opt_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        <V as VisitMut>::visit_mut_opt_span(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        <V as VisitMut>::visit_mut_opt_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        <V as VisitMut>::visit_mut_opt_str(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        <V as VisitMut>::visit_mut_opt_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        <V as VisitMut>::visit_mut_opt_vec_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        <V as VisitMut>::visit_mut_opt_vec_pats(&mut **self, node)
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param) {
        <V as VisitMut>::visit_mut_param(&mut **self, node)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        <V as VisitMut>::visit_mut_param_or_ts_param_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        <V as VisitMut>::visit_mut_param_or_ts_param_props(&mut **self, node)
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        <V as VisitMut>::visit_mut_params(&mut **self, node)
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        <V as VisitMut>::visit_mut_paren_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat) {
        <V as VisitMut>::visit_mut_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        <V as VisitMut>::visit_mut_pats(&mut **self, node)
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        <V as VisitMut>::visit_mut_private_method(&mut **self, node)
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        <V as VisitMut>::visit_mut_private_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        <V as VisitMut>::visit_mut_private_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program) {
        <V as VisitMut>::visit_mut_program(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop) {
        <V as VisitMut>::visit_mut_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        <V as VisitMut>::visit_mut_prop_name(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        <V as VisitMut>::visit_mut_prop_or_spread(&mut **self, node)
    }

    #[inline]
    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        <V as VisitMut>::visit_mut_prop_or_spreads(&mut **self, node)
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex) {
        <V as VisitMut>::visit_mut_regex(&mut **self, node)
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        <V as VisitMut>::visit_mut_rest_pat(&mut **self, node)
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        <V as VisitMut>::visit_mut_return_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script) {
        <V as VisitMut>::visit_mut_script(&mut **self, node)
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        <V as VisitMut>::visit_mut_seq_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        <V as VisitMut>::visit_mut_setter_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        <V as VisitMut>::visit_mut_simple_assign_target(&mut **self, node)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        <V as VisitMut>::visit_mut_span(&mut **self, node)
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        <V as VisitMut>::visit_mut_spread_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        <V as VisitMut>::visit_mut_static_block(&mut **self, node)
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        <V as VisitMut>::visit_mut_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        <V as VisitMut>::visit_mut_stmts(&mut **self, node)
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str) {
        <V as VisitMut>::visit_mut_str(&mut **self, node)
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super) {
        <V as VisitMut>::visit_mut_super(&mut **self, node)
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        <V as VisitMut>::visit_mut_super_prop(&mut **self, node)
    }

    #[inline]
    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        <V as VisitMut>::visit_mut_super_prop_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        <V as VisitMut>::visit_mut_switch_case(&mut **self, node)
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        <V as VisitMut>::visit_mut_switch_cases(&mut **self, node)
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        <V as VisitMut>::visit_mut_switch_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        <V as VisitMut>::visit_mut_syntax_context(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        <V as VisitMut>::visit_mut_tagged_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        <V as VisitMut>::visit_mut_this_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        <V as VisitMut>::visit_mut_throw_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        <V as VisitMut>::visit_mut_tpl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        <V as VisitMut>::visit_mut_tpl_element(&mut **self, node)
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        <V as VisitMut>::visit_mut_tpl_elements(&mut **self, node)
    }

    #[inline]
    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        <V as VisitMut>::visit_mut_true_plus_minus(&mut **self, node)
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        <V as VisitMut>::visit_mut_try_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        <V as VisitMut>::visit_mut_unary_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        <V as VisitMut>::visit_mut_unary_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        <V as VisitMut>::visit_mut_update_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        <V as VisitMut>::visit_mut_update_op(&mut **self, node)
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        <V as VisitMut>::visit_mut_using_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        <V as VisitMut>::visit_mut_var_decl(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        <V as VisitMut>::visit_mut_var_decl_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        <V as VisitMut>::visit_mut_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        <V as VisitMut>::visit_mut_var_declarator(&mut **self, node)
    }

    #[inline]
    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        <V as VisitMut>::visit_mut_var_declarators(&mut **self, node)
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        <V as VisitMut>::visit_mut_while_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        <V as VisitMut>::visit_mut_with_stmt(&mut **self, node)
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        <V as VisitMut>::visit_mut_yield_expr(&mut **self, node)
    }
}
impl<A, B> VisitMut for ::swc_visit::Either<A, B>
where
    A: VisitMut,
    B: VisitMut,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_array_lit(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_array_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_array_pat(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_array_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_arrow_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_arrow_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_op(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_op(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_pat(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_target(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_target(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_assign_target_pat(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_assign_target_pat(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_atom(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_auto_accessor(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_auto_accessor(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_await_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_await_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_big_int(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_big_int(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_big_int_value(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_big_int_value(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_bin_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_bin_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_binary_op(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_binary_op(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_binding_ident(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_binding_ident(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_block_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_block_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_block_stmt_or_expr(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_block_stmt_or_expr(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_bool(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_bool(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_break_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_break_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_call_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_call_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_callee(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_callee(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_catch_clause(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_catch_clause(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_member(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_member(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_members(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_members(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_method(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_method(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_computed_prop_name(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_computed_prop_name(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_cond_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_cond_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_constructor(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_constructor(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_continue_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_continue_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_debugger_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_debugger_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_decorator(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_decorator(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_decorators(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_decorators(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_default_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_default_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_do_while_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_do_while_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_empty_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_empty_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_all(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_export_all(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_export_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_default_decl(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_default_decl(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_default_expr(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_default_expr(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_default_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_default_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_named_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_named_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_namespace_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_namespace_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_specifiers(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_specifiers(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr_or_spread(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_exprs(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_exprs(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_fn_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_fn_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_fn_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_fn_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_head(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_head(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_in_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_in_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_of_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_of_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_function(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_function(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_getter_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_getter_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ident(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ident(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ident_name(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ident_name(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_if_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_if_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_default_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_default_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_named_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_named_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_phase(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_phase(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_specifiers(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_specifiers(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_star_as_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_star_as_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_with(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_with(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_with_item(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_with_item(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_with_items(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_with_items(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_invalid(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_invalid(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_attr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr_name(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_attr_name(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_attr_or_spread(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_attr_or_spread(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_attr_or_spreads(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_attr_or_spreads(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr_value(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_attr_value(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_closing_element(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_closing_element(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_closing_fragment(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_closing_fragment(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_element(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_element(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_element_child(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_element_child(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_element_childs(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_element_childs(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_element_name(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_element_name(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_empty_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_empty_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_expr_container(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_expr_container(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_fragment(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_fragment(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_member_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_member_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_namespaced_name(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_namespaced_name(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_object(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_object(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_opening_element(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_opening_element(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_opening_fragment(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_opening_fragment(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_spread_child(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_spread_child(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_text(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_text(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_key(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_key(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_key_value_pat_prop(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_key_value_pat_prop(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_key_value_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_key_value_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_labeled_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_labeled_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_lit(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_member_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_member_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_member_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_member_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_meta_prop_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_meta_prop_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_meta_prop_kind(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_meta_prop_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_method_kind(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_method_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_method_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_method_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_module_export_name(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_module_export_name(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module_item(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module_item(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module_items(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module_items(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_named_export(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_named_export(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_new_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_new_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_null(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_null(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_number(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_number(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_lit(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_object_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_pat(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_object_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_object_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_pat_props(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_object_pat_props(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_atom(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_block_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_block_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_call(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_call(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_catch_clause(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_catch_clause(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_chain_base(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_chain_base(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_chain_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_chain_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_expr_or_spread(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_expr_or_spread(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_expr_or_spreads(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_expr_or_spreads(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_ident(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_ident(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_jsx_attr_value(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_jsx_attr_value(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_jsx_closing_element(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_jsx_closing_element(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_module_export_name(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_module_export_name(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_object_lit(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_object_lit(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_pat(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_span(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_span(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_str(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_str(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_var_decl_or_expr(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_var_decl_or_expr(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_vec_expr_or_spreads(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_vec_expr_or_spreads(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_vec_pats(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_vec_pats(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_param(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_param(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_prop(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_prop(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_props(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_props(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_params(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_params(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_paren_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_paren_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_pat(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_pats(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_pats(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_private_method(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_private_method(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_private_name(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_private_name(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_private_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_private_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_program(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_program(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop_name(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop_name(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop_or_spread(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_regex(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_regex(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_rest_pat(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_rest_pat(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_return_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_return_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_script(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_script(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_seq_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_seq_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_setter_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_setter_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_simple_assign_target(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_simple_assign_target(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_span(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_span(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_spread_element(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_spread_element(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_static_block(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_static_block(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_stmts(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_stmts(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_str(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_str(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_super(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_super(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_super_prop(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_super_prop(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_super_prop_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_super_prop_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_switch_case(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_switch_case(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_switch_cases(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_switch_cases(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_switch_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_switch_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_syntax_context(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_syntax_context(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tagged_tpl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tagged_tpl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_this_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_this_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_throw_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_throw_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tpl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tpl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tpl_element(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tpl_element(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tpl_elements(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tpl_elements(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_true_plus_minus(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_true_plus_minus(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_try_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_try_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_unary_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_unary_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_unary_op(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_unary_op(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_update_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_update_expr(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_update_op(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_update_op(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_using_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_using_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_decl(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_decl(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_decl_kind(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_decl_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_decl_or_expr(visitor, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_var_decl_or_expr(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_declarator(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_declarator(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_declarators(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_declarators(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_while_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_while_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_with_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_with_stmt(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_yield_expr(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_yield_expr(visitor, node),
        }
    }
}
impl<V> VisitMut for ::swc_visit::Optional<V>
where
    V: VisitMut,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        if self.enabled {
            <V as VisitMut>::visit_mut_array_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        if self.enabled {
            <V as VisitMut>::visit_mut_array_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_arrow_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_assign_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_assign_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        if self.enabled {
            <V as VisitMut>::visit_mut_assign_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_assign_pat_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_assign_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        if self.enabled {
            <V as VisitMut>::visit_mut_assign_target(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        if self.enabled {
            <V as VisitMut>::visit_mut_assign_target_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        if self.enabled {
            <V as VisitMut>::visit_mut_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        if self.enabled {
            <V as VisitMut>::visit_mut_auto_accessor(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_await_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_big_int(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        if self.enabled {
            <V as VisitMut>::visit_mut_big_int_value(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_bin_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_binary_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        if self.enabled {
            <V as VisitMut>::visit_mut_binding_ident(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_block_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_block_stmt_or_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool) {
        if self.enabled {
            <V as VisitMut>::visit_mut_bool(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_break_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_call_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee) {
        if self.enabled {
            <V as VisitMut>::visit_mut_callee(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        if self.enabled {
            <V as VisitMut>::visit_mut_catch_clause(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_member(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_members(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_method(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_computed_prop_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_cond_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        if self.enabled {
            <V as VisitMut>::visit_mut_constructor(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_continue_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_debugger_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        if self.enabled {
            <V as VisitMut>::visit_mut_decorator(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_decorators(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_default_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_do_while_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_empty_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_all(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_default_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_default_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_default_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_named_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_namespace_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_export_specifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        if self.enabled {
            <V as VisitMut>::visit_mut_expr_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_expr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_expr_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_exprs(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_fn_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_fn_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        if self.enabled {
            <V as VisitMut>::visit_mut_for_head(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_for_in_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_for_of_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_for_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function) {
        if self.enabled {
            <V as VisitMut>::visit_mut_function(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_getter_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident) {
        if self.enabled {
            <V as VisitMut>::visit_mut_ident(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_ident_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_if_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_default_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_named_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_phase(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_specifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_star_as_specifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_with(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_with_item(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_import_with_items(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        if self.enabled {
            <V as VisitMut>::visit_mut_invalid(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_attr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_attr_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_attr_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_attr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_attr_value(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_closing_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_closing_fragment(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_element_child(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_element_childs(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_element_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_empty_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_expr_container(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_fragment(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_member_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_namespaced_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_object(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_opening_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_opening_fragment(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_spread_child(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        if self.enabled {
            <V as VisitMut>::visit_mut_jsx_text(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key) {
        if self.enabled {
            <V as VisitMut>::visit_mut_key(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_key_value_pat_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_key_value_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_labeled_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit) {
        if self.enabled {
            <V as VisitMut>::visit_mut_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_member_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_member_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_meta_prop_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_meta_prop_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_method_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_method_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module) {
        if self.enabled {
            <V as VisitMut>::visit_mut_module(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_module_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_module_export_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        if self.enabled {
            <V as VisitMut>::visit_mut_module_item(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_module_items(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        if self.enabled {
            <V as VisitMut>::visit_mut_named_export(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_new_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null) {
        if self.enabled {
            <V as VisitMut>::visit_mut_null(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number) {
        if self.enabled {
            <V as VisitMut>::visit_mut_number(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        if self.enabled {
            <V as VisitMut>::visit_mut_object_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        if self.enabled {
            <V as VisitMut>::visit_mut_object_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_object_pat_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_object_pat_props(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_block_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_call(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_catch_clause(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_chain_base(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_chain_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_expr_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_expr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_ident(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_jsx_attr_value(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_jsx_closing_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_module_export_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_object_lit(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_span(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_str(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_var_decl_or_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_vec_expr_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_vec_pats(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param) {
        if self.enabled {
            <V as VisitMut>::visit_mut_param(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_param_or_ts_param_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_param_or_ts_param_props(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_params(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_paren_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat) {
        if self.enabled {
            <V as VisitMut>::visit_mut_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_pats(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        if self.enabled {
            <V as VisitMut>::visit_mut_private_method(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_private_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_private_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program) {
        if self.enabled {
            <V as VisitMut>::visit_mut_program(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop) {
        if self.enabled {
            <V as VisitMut>::visit_mut_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        if self.enabled {
            <V as VisitMut>::visit_mut_prop_name(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        if self.enabled {
            <V as VisitMut>::visit_mut_prop_or_spread(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_prop_or_spreads(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex) {
        if self.enabled {
            <V as VisitMut>::visit_mut_regex(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        if self.enabled {
            <V as VisitMut>::visit_mut_rest_pat(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_return_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script) {
        if self.enabled {
            <V as VisitMut>::visit_mut_script(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_seq_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_setter_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        if self.enabled {
            <V as VisitMut>::visit_mut_simple_assign_target(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        if self.enabled {
            <V as VisitMut>::visit_mut_span(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        if self.enabled {
            <V as VisitMut>::visit_mut_spread_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        if self.enabled {
            <V as VisitMut>::visit_mut_static_block(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_stmts(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str) {
        if self.enabled {
            <V as VisitMut>::visit_mut_str(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super) {
        if self.enabled {
            <V as VisitMut>::visit_mut_super(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_super_prop(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_super_prop_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        if self.enabled {
            <V as VisitMut>::visit_mut_switch_case(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_switch_cases(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_switch_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        if self.enabled {
            <V as VisitMut>::visit_mut_syntax_context(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_tagged_tpl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_this_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_throw_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_tpl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        if self.enabled {
            <V as VisitMut>::visit_mut_tpl_element(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_tpl_elements(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        if self.enabled {
            <V as VisitMut>::visit_mut_true_plus_minus(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_try_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_unary_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_unary_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_update_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        if self.enabled {
            <V as VisitMut>::visit_mut_update_op(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_using_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        if self.enabled {
            <V as VisitMut>::visit_mut_var_decl(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_var_decl_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_var_decl_or_expr(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        if self.enabled {
            <V as VisitMut>::visit_mut_var_declarator(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_var_declarators(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_while_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        if self.enabled {
            <V as VisitMut>::visit_mut_with_stmt(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        if self.enabled {
            <V as VisitMut>::visit_mut_yield_expr(&mut self.visitor, node)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait VisitMutWith<V: ?Sized + VisitMut> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_mut_with(&mut self, visitor: &mut V);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_mut_children_with(&mut self, visitor: &mut V);
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ArrayLit {
    #[doc = "Calls [VisitMut`::visit_mut_array_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_array_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ArrayLit { span, elems } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Option<ExprOrSpread>> as VisitMutWith<V>>::visit_mut_with(elems, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ArrayPat {
    #[doc = "Calls [VisitMut`::visit_mut_array_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_array_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Option<Pat>> as VisitMutWith<V>>::visit_mut_with(elems, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ArrowExpr {
    #[doc = "Calls [VisitMut`::visit_mut_arrow_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_arrow_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Vec<Pat> as VisitMutWith<V>>::visit_mut_with(params, visitor)
                };
                {
                    <Box<BlockStmtOrExpr> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
                {
                    <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                        type_params,
                        visitor,
                    )
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(
                        return_type,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignExpr {
    #[doc = "Calls [VisitMut`::visit_mut_assign_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <AssignOp as VisitMutWith<V>>::visit_mut_with(op, visitor)
                };
                {
                    <AssignTarget as VisitMutWith<V>>::visit_mut_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignOp {
    #[doc = "Calls [VisitMut`::visit_mut_assign_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignPat {
    #[doc = "Calls [VisitMut`::visit_mut_assign_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignPat { span, left, right } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Pat> as VisitMutWith<V>>::visit_mut_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignPatProp {
    #[doc = "Calls [VisitMut`::visit_mut_assign_pat_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_pat_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignPatProp { span, key, value } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <BindingIdent as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignProp {
    #[doc = "Calls [VisitMut`::visit_mut_assign_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignProp { span, key, value } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignTarget {
    #[doc = "Calls [VisitMut`::visit_mut_assign_target`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_target(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                <SimpleAssignTarget as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            AssignTarget::Pat { 0: _field_0 } => {
                <AssignTargetPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignTargetPat {
    #[doc = "Calls [VisitMut`::visit_mut_assign_target_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_target_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AutoAccessor {
    #[doc = "Calls [VisitMut`::visit_mut_auto_accessor`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_auto_accessor(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Key as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
                {
                    <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor)
                };
                {
                    <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(
                        accessibility,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AwaitExpr {
    #[doc = "Calls [VisitMut`::visit_mut_await_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_await_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AwaitExpr { span, arg } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BigInt {
    #[doc = "Calls [VisitMut`::visit_mut_big_int`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_big_int(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BigInt { span, value, raw } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<BigIntValue> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BinExpr {
    #[doc = "Calls [VisitMut`::visit_mut_bin_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_bin_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <BinaryOp as VisitMutWith<V>>::visit_mut_with(op, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BinaryOp {
    #[doc = "Calls [VisitMut`::visit_mut_binary_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_binary_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BindingIdent {
    #[doc = "Calls [VisitMut`::visit_mut_binding_ident`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_binding_ident(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BindingIdent { id, type_ann } => {
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BlockStmt {
    #[doc = "Calls [VisitMut`::visit_mut_block_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_block_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Vec<Stmt> as VisitMutWith<V>>::visit_mut_with(stmts, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BlockStmtOrExpr {
    #[doc = "Calls [VisitMut`::visit_mut_block_stmt_or_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_block_stmt_or_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                <BlockStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Bool {
    #[doc = "Calls [VisitMut`::visit_mut_bool`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_bool(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Bool { span, value } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BreakStmt {
    #[doc = "Calls [VisitMut`::visit_mut_break_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_break_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BreakStmt { span, label } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<Ident> as VisitMutWith<V>>::visit_mut_with(label, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CallExpr {
    #[doc = "Calls [VisitMut`::visit_mut_call_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_call_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Callee as VisitMutWith<V>>::visit_mut_with(callee, visitor)
                };
                {
                    <Vec<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(args, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Callee {
    #[doc = "Calls [VisitMut`::visit_mut_callee`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_callee(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Callee::Super { 0: _field_0 } => {
                <Super as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Callee::Import { 0: _field_0 } => {
                <Import as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Callee::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CatchClause {
    #[doc = "Calls [VisitMut`::visit_mut_catch_clause`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_catch_clause(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CatchClause { span, param, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<Pat> as VisitMutWith<V>>::visit_mut_with(param, visitor)
                };
                {
                    <BlockStmt as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Class {
    #[doc = "Calls [VisitMut`::visit_mut_class`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor)
                };
                {
                    <Vec<ClassMember> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(super_class, visitor)
                };
                {
                    <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                        type_params,
                        visitor,
                    )
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                        super_type_params,
                        visitor,
                    )
                };
                {
                    <Vec<TsExprWithTypeArgs> as VisitMutWith<V>>::visit_mut_with(
                        implements, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassDecl {
    #[doc = "Calls [VisitMut`::visit_mut_class_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(ident, visitor)
                };
                {
                    <Box<Class> as VisitMutWith<V>>::visit_mut_with(class, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassExpr {
    #[doc = "Calls [VisitMut`::visit_mut_class_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassExpr { ident, class } => {
                {
                    <Option<Ident> as VisitMutWith<V>>::visit_mut_with(ident, visitor)
                };
                {
                    <Box<Class> as VisitMutWith<V>>::visit_mut_with(class, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassMember {
    #[doc = "Calls [VisitMut`::visit_mut_class_member`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_member(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                <Constructor as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::Method { 0: _field_0 } => {
                <ClassMethod as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::PrivateMethod { 0: _field_0 } => {
                <PrivateMethod as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                <ClassProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                <PrivateProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                <StaticBlock as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                <AutoAccessor as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassMethod {
    #[doc = "Calls [VisitMut`::visit_mut_class_method`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_method(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor)
                };
                {
                    <MethodKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
                {
                    <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(
                        accessibility,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassProp {
    #[doc = "Calls [VisitMut`::visit_mut_class_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
                {
                    <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor)
                };
                {
                    <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(
                        accessibility,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ComputedPropName {
    #[doc = "Calls [VisitMut`::visit_mut_computed_prop_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_computed_prop_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ComputedPropName { span, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CondExpr {
    #[doc = "Calls [VisitMut`::visit_mut_cond_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_cond_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(cons, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(alt, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Constructor {
    #[doc = "Calls [VisitMut`::visit_mut_constructor`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_constructor(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Vec<ParamOrTsParamProp> as VisitMutWith<V>>::visit_mut_with(params, visitor)
                };
                {
                    <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
                {
                    <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(
                        accessibility,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ContinueStmt {
    #[doc = "Calls [VisitMut`::visit_mut_continue_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_continue_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ContinueStmt { span, label } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<Ident> as VisitMutWith<V>>::visit_mut_with(label, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for DebuggerStmt {
    #[doc = "Calls [VisitMut`::visit_mut_debugger_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_debugger_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            DebuggerStmt { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Decl {
    #[doc = "Calls [VisitMut`::visit_mut_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Decl::Class { 0: _field_0 } => {
                <ClassDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::Fn { 0: _field_0 } => {
                <FnDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::Var { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::Using { 0: _field_0 } => {
                <Box<UsingDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsInterface { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                <Box<TsTypeAliasDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsEnum { 0: _field_0 } => {
                <Box<TsEnumDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsModule { 0: _field_0 } => {
                <Box<TsModuleDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Decorator {
    #[doc = "Calls [VisitMut`::visit_mut_decorator`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_decorator(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Decorator { span, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for DefaultDecl {
    #[doc = "Calls [VisitMut`::visit_mut_default_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_default_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                <ClassExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                <FnExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for DoWhileStmt {
    #[doc = "Calls [VisitMut`::visit_mut_do_while_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_do_while_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            DoWhileStmt { span, test, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for EmptyStmt {
    #[doc = "Calls [VisitMut`::visit_mut_empty_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_empty_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            EmptyStmt { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportAll {
    #[doc = "Calls [VisitMut`::visit_mut_export_all`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_all(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Str> as VisitMutWith<V>>::visit_mut_with(src, visitor)
                };
                {
                    <Option<Box<ObjectLit>> as VisitMutWith<V>>::visit_mut_with(with, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDecl {
    #[doc = "Calls [VisitMut`::visit_mut_export_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDecl { span, decl } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Decl as VisitMutWith<V>>::visit_mut_with(decl, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDefaultDecl {
    #[doc = "Calls [VisitMut`::visit_mut_export_default_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_default_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDefaultDecl { span, decl } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <DefaultDecl as VisitMutWith<V>>::visit_mut_with(decl, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDefaultExpr {
    #[doc = "Calls [VisitMut`::visit_mut_export_default_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_default_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDefaultExpr { span, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDefaultSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_default_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_default_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDefaultSpecifier { exported } => {
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(exported, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportNamedSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_named_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_named_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <ModuleExportName as VisitMutWith<V>>::visit_mut_with(orig, visitor)
                };
                {
                    <Option<ModuleExportName> as VisitMutWith<V>>::visit_mut_with(exported, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_namespace_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_namespace_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <ModuleExportName as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                <ExportNamespaceSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                <ExportDefaultSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                <ExportNamedSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Expr {
    #[doc = "Calls [VisitMut`::visit_mut_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Expr::This { 0: _field_0 } => {
                <ThisExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Array { 0: _field_0 } => {
                <ArrayLit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Object { 0: _field_0 } => {
                <ObjectLit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Fn { 0: _field_0 } => {
                <FnExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Unary { 0: _field_0 } => {
                <UnaryExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Update { 0: _field_0 } => {
                <UpdateExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Bin { 0: _field_0 } => {
                <BinExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Assign { 0: _field_0 } => {
                <AssignExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Cond { 0: _field_0 } => {
                <CondExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Call { 0: _field_0 } => {
                <CallExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::New { 0: _field_0 } => {
                <NewExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Seq { 0: _field_0 } => {
                <SeqExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Lit { 0: _field_0 } => {
                <Lit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Tpl { 0: _field_0 } => {
                <Tpl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                <TaggedTpl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Arrow { 0: _field_0 } => {
                <ArrowExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Class { 0: _field_0 } => {
                <ClassExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Yield { 0: _field_0 } => {
                <YieldExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::MetaProp { 0: _field_0 } => {
                <MetaPropExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Await { 0: _field_0 } => {
                <AwaitExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Paren { 0: _field_0 } => {
                <ParenExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXMember { 0: _field_0 } => {
                <JSXMemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                <JSXEmptyExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                <TsConstAssertion as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExprOrSpread {
    #[doc = "Calls [VisitMut`::visit_mut_expr_or_spread`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr_or_spread(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExprOrSpread { spread, expr } => {
                {
                    <Option<swc_common::Span> as VisitMutWith<V>>::visit_mut_with(spread, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExprStmt {
    #[doc = "Calls [VisitMut`::visit_mut_expr_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExprStmt { span, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for FnDecl {
    #[doc = "Calls [VisitMut`::visit_mut_fn_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_fn_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(ident, visitor)
                };
                {
                    <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for FnExpr {
    #[doc = "Calls [VisitMut`::visit_mut_fn_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_fn_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            FnExpr { ident, function } => {
                {
                    <Option<Ident> as VisitMutWith<V>>::visit_mut_with(ident, visitor)
                };
                {
                    <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForHead {
    #[doc = "Calls [VisitMut`::visit_mut_for_head`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_head(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                <Box<UsingDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ForHead::Pat { 0: _field_0 } => {
                <Box<Pat> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForInStmt {
    #[doc = "Calls [VisitMut`::visit_mut_for_in_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_in_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <ForHead as VisitMutWith<V>>::visit_mut_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForOfStmt {
    #[doc = "Calls [VisitMut`::visit_mut_for_of_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_of_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <ForHead as VisitMutWith<V>>::visit_mut_with(left, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForStmt {
    #[doc = "Calls [VisitMut`::visit_mut_for_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<VarDeclOrExpr> as VisitMutWith<V>>::visit_mut_with(init, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(test, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(update, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Function {
    #[doc = "Calls [VisitMut`::visit_mut_function`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_function(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                {
                    <Vec<Param> as VisitMutWith<V>>::visit_mut_with(params, visitor)
                };
                {
                    <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor)
                };
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
                {
                    <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                        type_params,
                        visitor,
                    )
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(
                        return_type,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for GetterProp {
    #[doc = "Calls [VisitMut`::visit_mut_getter_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_getter_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
                {
                    <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Ident {
    #[doc = "Calls [VisitMut`::visit_mut_ident`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ident(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(sym, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for IdentName {
    #[doc = "Calls [VisitMut`::visit_mut_ident_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ident_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            IdentName { span, sym } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(sym, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for IfStmt {
    #[doc = "Calls [VisitMut`::visit_mut_if_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_if_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(cons, visitor)
                };
                {
                    <Option<Box<Stmt>> as VisitMutWith<V>>::visit_mut_with(alt, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Import {
    #[doc = "Calls [VisitMut`::visit_mut_import`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Import { span, phase } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <ImportPhase as VisitMutWith<V>>::visit_mut_with(phase, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportDecl {
    #[doc = "Calls [VisitMut`::visit_mut_import_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<ImportSpecifier> as VisitMutWith<V>>::visit_mut_with(specifiers, visitor)
                };
                {
                    <Box<Str> as VisitMutWith<V>>::visit_mut_with(src, visitor)
                };
                {
                    <Option<Box<ObjectLit>> as VisitMutWith<V>>::visit_mut_with(with, visitor)
                };
                {
                    <ImportPhase as VisitMutWith<V>>::visit_mut_with(phase, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportDefaultSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_default_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_default_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(local, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportNamedSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_named_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_named_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(local, visitor)
                };
                {
                    <Option<ModuleExportName> as VisitMutWith<V>>::visit_mut_with(imported, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportPhase {
    #[doc = "Calls [VisitMut`::visit_mut_import_phase`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_phase(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                <ImportNamedSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                <ImportDefaultSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                <ImportStarAsSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportStarAsSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_star_as_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_star_as_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(local, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportWith {
    #[doc = "Calls [VisitMut`::visit_mut_import_with`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_with(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportWith { span, values } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<ImportWithItem> as VisitMutWith<V>>::visit_mut_with(values, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportWithItem {
    #[doc = "Calls [VisitMut`::visit_mut_import_with_item`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_with_item(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportWithItem { key, value } => {
                {
                    <IdentName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Str as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Invalid {
    #[doc = "Calls [VisitMut`::visit_mut_invalid`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_invalid(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Invalid { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttr { span, name, value } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <JSXAttrName as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
                {
                    <Option<JSXAttrValue> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttrName {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttrOrSpread {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_or_spread`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spread(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                <JSXAttr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                <SpreadElement as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttrValue {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_value`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_value(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                <Lit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXClosingElement {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_closing_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_closing_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXClosingElement { span, name } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <JSXElementName as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXClosingFragment {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_closing_fragment`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_closing_fragment(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXClosingFragment { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXElement {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <JSXOpeningElement as VisitMutWith<V>>::visit_mut_with(opening, visitor)
                };
                {
                    <Vec<JSXElementChild> as VisitMutWith<V>>::visit_mut_with(children, visitor)
                };
                {
                    <Option<JSXClosingElement> as VisitMutWith<V>>::visit_mut_with(closing, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXElementChild {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element_child`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element_child(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                <JSXText as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                <JSXSpreadChild as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXElementName {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                <JSXMemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXEmptyExpr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_empty_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_empty_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXEmptyExpr { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXExpr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                <JSXEmptyExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXExprContainer {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_expr_container`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_expr_container(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXExprContainer { span, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <JSXExpr as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXFragment {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_fragment`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_fragment(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <JSXOpeningFragment as VisitMutWith<V>>::visit_mut_with(opening, visitor)
                };
                {
                    <Vec<JSXElementChild> as VisitMutWith<V>>::visit_mut_with(children, visitor)
                };
                {
                    <JSXClosingFragment as VisitMutWith<V>>::visit_mut_with(closing, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXMemberExpr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_member_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_member_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <JSXObject as VisitMutWith<V>>::visit_mut_with(obj, visitor)
                };
                {
                    <IdentName as VisitMutWith<V>>::visit_mut_with(prop, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXNamespacedName {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_namespaced_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_namespaced_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <IdentName as VisitMutWith<V>>::visit_mut_with(ns, visitor)
                };
                {
                    <IdentName as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXObject {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_object`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_object(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                <Box<JSXMemberExpr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXObject::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXOpeningElement {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_opening_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_opening_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                {
                    <JSXElementName as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<JSXAttrOrSpread> as VisitMutWith<V>>::visit_mut_with(attrs, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXOpeningFragment {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_opening_fragment`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_opening_fragment(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXOpeningFragment { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXSpreadChild {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_spread_child`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_spread_child(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXSpreadChild { span, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXText {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_text`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_text(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXText { span, value, raw } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Key {
    #[doc = "Calls [VisitMut`::visit_mut_key`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_key(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Key::Private { 0: _field_0 } => {
                <PrivateName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Key::Public { 0: _field_0 } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for KeyValuePatProp {
    #[doc = "Calls [VisitMut`::visit_mut_key_value_pat_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_key_value_pat_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            KeyValuePatProp { key, value } => {
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Box<Pat> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for KeyValueProp {
    #[doc = "Calls [VisitMut`::visit_mut_key_value_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_key_value_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            KeyValueProp { key, value } => {
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for LabeledStmt {
    #[doc = "Calls [VisitMut`::visit_mut_labeled_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_labeled_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            LabeledStmt { span, label, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Ident as VisitMutWith<V>>::visit_mut_with(label, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Lit {
    #[doc = "Calls [VisitMut`::visit_mut_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Lit::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Bool { 0: _field_0 } => {
                <Bool as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Null { 0: _field_0 } => {
                <Null as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Num { 0: _field_0 } => {
                <Number as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Regex { 0: _field_0 } => {
                <Regex as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::JSXText { 0: _field_0 } => {
                <JSXText as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MemberExpr {
    #[doc = "Calls [VisitMut`::visit_mut_member_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_member_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MemberExpr { span, obj, prop } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(obj, visitor)
                };
                {
                    <MemberProp as VisitMutWith<V>>::visit_mut_with(prop, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MemberProp {
    #[doc = "Calls [VisitMut`::visit_mut_member_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_member_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            MemberProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MetaPropExpr {
    #[doc = "Calls [VisitMut`::visit_mut_meta_prop_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_meta_prop_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MetaPropExpr { span, kind } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <MetaPropKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MetaPropKind {
    #[doc = "Calls [VisitMut`::visit_mut_meta_prop_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_meta_prop_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MethodKind {
    #[doc = "Calls [VisitMut`::visit_mut_method_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_method_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MethodProp {
    #[doc = "Calls [VisitMut`::visit_mut_method_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_method_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MethodProp { key, function } => {
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Module {
    #[doc = "Calls [VisitMut`::visit_mut_module`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<ModuleItem> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(shebang, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ModuleDecl {
    #[doc = "Calls [VisitMut`::visit_mut_module_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                <ImportDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                <ExportDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                <NamedExport as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                <ExportDefaultDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                <ExportDefaultExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                <ExportAll as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                <Box<TsImportEqualsDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                <TsExportAssignment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                <TsNamespaceExportDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ModuleExportName {
    #[doc = "Calls [VisitMut`::visit_mut_module_export_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_export_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleExportName::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ModuleItem {
    #[doc = "Calls [VisitMut`::visit_mut_module_item`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_item(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                <ModuleDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                <Stmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for NamedExport {
    #[doc = "Calls [VisitMut`::visit_mut_named_export`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_named_export(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<ExportSpecifier> as VisitMutWith<V>>::visit_mut_with(specifiers, visitor)
                };
                {
                    <Option<Box<Str>> as VisitMutWith<V>>::visit_mut_with(src, visitor)
                };
                {
                    <Option<Box<ObjectLit>> as VisitMutWith<V>>::visit_mut_with(with, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for NewExpr {
    #[doc = "Calls [VisitMut`::visit_mut_new_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_new_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(callee, visitor)
                };
                {
                    <Option<Vec<ExprOrSpread>> as VisitMutWith<V>>::visit_mut_with(args, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Null {
    #[doc = "Calls [VisitMut`::visit_mut_null`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_null(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Null { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Number {
    #[doc = "Calls [VisitMut`::visit_mut_number`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_number(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Number { span, value, raw } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ObjectLit {
    #[doc = "Calls [VisitMut`::visit_mut_object_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ObjectLit { span, props } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<PropOrSpread> as VisitMutWith<V>>::visit_mut_with(props, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ObjectPat {
    #[doc = "Calls [VisitMut`::visit_mut_object_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<ObjectPatProp> as VisitMutWith<V>>::visit_mut_with(props, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ObjectPatProp {
    #[doc = "Calls [VisitMut`::visit_mut_object_pat_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_pat_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                <KeyValuePatProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                <AssignPatProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for OptCall {
    #[doc = "Calls [VisitMut`::visit_mut_opt_call`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_call(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(callee, visitor)
                };
                {
                    <Vec<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(args, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                        type_args, visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for OptChainBase {
    #[doc = "Calls [VisitMut`::visit_mut_opt_chain_base`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_chain_base(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            OptChainBase::Call { 0: _field_0 } => {
                <OptCall as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for OptChainExpr {
    #[doc = "Calls [VisitMut`::visit_mut_opt_chain_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_chain_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<OptChainBase> as VisitMutWith<V>>::visit_mut_with(base, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Param {
    #[doc = "Calls [VisitMut`::visit_mut_param`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_param(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor)
                };
                {
                    <Pat as VisitMutWith<V>>::visit_mut_with(pat, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ParamOrTsParamProp {
    #[doc = "Calls [VisitMut`::visit_mut_param_or_ts_param_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_param_or_ts_param_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                <TsParamProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                <Param as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ParenExpr {
    #[doc = "Calls [VisitMut`::visit_mut_paren_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_paren_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ParenExpr { span, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Pat {
    #[doc = "Calls [VisitMut`::visit_mut_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Assign { 0: _field_0 } => {
                <AssignPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PrivateMethod {
    #[doc = "Calls [VisitMut`::visit_mut_private_method`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_private_method(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <PrivateName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor)
                };
                {
                    <MethodKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
                {
                    <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(
                        accessibility,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PrivateName {
    #[doc = "Calls [VisitMut`::visit_mut_private_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_private_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PrivateName { span, name } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PrivateProp {
    #[doc = "Calls [VisitMut`::visit_mut_private_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_private_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <PrivateName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
                {
                    <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor)
                };
                {
                    <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(
                        accessibility,
                        visitor,
                    )
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Program {
    #[doc = "Calls [VisitMut`::visit_mut_program`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_program(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Program::Module { 0: _field_0 } => {
                <Module as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Program::Script { 0: _field_0 } => {
                <Script as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Prop {
    #[doc = "Calls [VisitMut`::visit_mut_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::KeyValue { 0: _field_0 } => {
                <KeyValueProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Assign { 0: _field_0 } => {
                <AssignProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Getter { 0: _field_0 } => {
                <GetterProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Setter { 0: _field_0 } => {
                <SetterProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Method { 0: _field_0 } => {
                <MethodProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PropName {
    #[doc = "Calls [VisitMut`::visit_mut_prop_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::Num { 0: _field_0 } => {
                <Number as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PropOrSpread {
    #[doc = "Calls [VisitMut`::visit_mut_prop_or_spread`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop_or_spread(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                <SpreadElement as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                <Box<Prop> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Regex {
    #[doc = "Calls [VisitMut`::visit_mut_regex`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_regex(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Regex { span, exp, flags } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(exp, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(flags, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for RestPat {
    #[doc = "Calls [VisitMut`::visit_mut_rest_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_rest_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(dot3_token, visitor)
                };
                {
                    <Box<Pat> as VisitMutWith<V>>::visit_mut_with(arg, visitor)
                };
                {
                    <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ReturnStmt {
    #[doc = "Calls [VisitMut`::visit_mut_return_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_return_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ReturnStmt { span, arg } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Script {
    #[doc = "Calls [VisitMut`::visit_mut_script`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_script(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(shebang, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SeqExpr {
    #[doc = "Calls [VisitMut`::visit_mut_seq_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_seq_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SeqExpr { span, exprs } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(exprs, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SetterProp {
    #[doc = "Calls [VisitMut`::visit_mut_setter_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_setter_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor)
                };
                {
                    <Option<Pat> as VisitMutWith<V>>::visit_mut_with(this_param, visitor)
                };
                {
                    <Box<Pat> as VisitMutWith<V>>::visit_mut_with(param, visitor)
                };
                {
                    <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SimpleAssignTarget {
    #[doc = "Calls [VisitMut`::visit_mut_simple_assign_target`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_simple_assign_target(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                <ParenExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SpreadElement {
    #[doc = "Calls [VisitMut`::visit_mut_spread_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_spread_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SpreadElement { dot3_token, expr } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(dot3_token, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for StaticBlock {
    #[doc = "Calls [VisitMut`::visit_mut_static_block`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_static_block(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            StaticBlock { span, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <BlockStmt as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Stmt {
    #[doc = "Calls [VisitMut`::visit_mut_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                <BlockStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Debugger { 0: _field_0 } => {
                <DebuggerStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::With { 0: _field_0 } => {
                <WithStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Return { 0: _field_0 } => {
                <ReturnStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Labeled { 0: _field_0 } => {
                <LabeledStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Break { 0: _field_0 } => {
                <BreakStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Continue { 0: _field_0 } => {
                <ContinueStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::If { 0: _field_0 } => {
                <IfStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Switch { 0: _field_0 } => {
                <SwitchStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Throw { 0: _field_0 } => {
                <ThrowStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Try { 0: _field_0 } => {
                <Box<TryStmt> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::While { 0: _field_0 } => {
                <WhileStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::DoWhile { 0: _field_0 } => {
                <DoWhileStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::For { 0: _field_0 } => {
                <ForStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::ForIn { 0: _field_0 } => {
                <ForInStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::ForOf { 0: _field_0 } => {
                <ForOfStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Decl { 0: _field_0 } => {
                <Decl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Expr { 0: _field_0 } => {
                <ExprStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Str {
    #[doc = "Calls [VisitMut`::visit_mut_str`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_str(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Str { span, value, raw } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Super {
    #[doc = "Calls [VisitMut`::visit_mut_super`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_super(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Super { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SuperProp {
    #[doc = "Calls [VisitMut`::visit_mut_super_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_super_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SuperProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SuperPropExpr {
    #[doc = "Calls [VisitMut`::visit_mut_super_prop_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_super_prop_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Super as VisitMutWith<V>>::visit_mut_with(obj, visitor)
                };
                {
                    <SuperProp as VisitMutWith<V>>::visit_mut_with(prop, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SwitchCase {
    #[doc = "Calls [VisitMut`::visit_mut_switch_case`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_switch_case(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SwitchCase { span, test, cons } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(test, visitor)
                };
                {
                    <Vec<Stmt> as VisitMutWith<V>>::visit_mut_with(cons, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SwitchStmt {
    #[doc = "Calls [VisitMut`::visit_mut_switch_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_switch_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(discriminant, visitor)
                };
                {
                    <Vec<SwitchCase> as VisitMutWith<V>>::visit_mut_with(cases, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TaggedTpl {
    #[doc = "Calls [VisitMut`::visit_mut_tagged_tpl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tagged_tpl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(tag, visitor)
                };
                {
                    <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                        type_params,
                        visitor,
                    )
                };
                {
                    <Box<Tpl> as VisitMutWith<V>>::visit_mut_with(tpl, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ThisExpr {
    #[doc = "Calls [VisitMut`::visit_mut_this_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_this_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ThisExpr { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ThrowStmt {
    #[doc = "Calls [VisitMut`::visit_mut_throw_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_throw_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ThrowStmt { span, arg } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Tpl {
    #[doc = "Calls [VisitMut`::visit_mut_tpl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tpl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(exprs, visitor)
                };
                {
                    <Vec<TplElement> as VisitMutWith<V>>::visit_mut_with(quasis, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TplElement {
    #[doc = "Calls [VisitMut`::visit_mut_tpl_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tpl_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(cooked, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(raw, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TruePlusMinus {
    #[doc = "Calls [VisitMut`::visit_mut_true_plus_minus`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_true_plus_minus(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TryStmt {
    #[doc = "Calls [VisitMut`::visit_mut_try_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_try_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <BlockStmt as VisitMutWith<V>>::visit_mut_with(block, visitor)
                };
                {
                    <Option<CatchClause> as VisitMutWith<V>>::visit_mut_with(handler, visitor)
                };
                {
                    <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(finalizer, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UnaryExpr {
    #[doc = "Calls [VisitMut`::visit_mut_unary_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_unary_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UnaryExpr { span, op, arg } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <UnaryOp as VisitMutWith<V>>::visit_mut_with(op, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UnaryOp {
    #[doc = "Calls [VisitMut`::visit_mut_unary_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_unary_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UpdateExpr {
    #[doc = "Calls [VisitMut`::visit_mut_update_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_update_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <UpdateOp as VisitMutWith<V>>::visit_mut_with(op, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UpdateOp {
    #[doc = "Calls [VisitMut`::visit_mut_update_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_update_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UsingDecl {
    #[doc = "Calls [VisitMut`::visit_mut_using_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_using_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<VarDeclarator> as VisitMutWith<V>>::visit_mut_with(decls, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDecl {
    #[doc = "Calls [VisitMut`::visit_mut_var_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_common::SyntaxContext as VisitMutWith<V>>::visit_mut_with(ctxt, visitor)
                };
                {
                    <VarDeclKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
                {
                    <Vec<VarDeclarator> as VisitMutWith<V>>::visit_mut_with(decls, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDeclKind {
    #[doc = "Calls [VisitMut`::visit_mut_var_decl_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_decl_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDeclOrExpr {
    #[doc = "Calls [VisitMut`::visit_mut_var_decl_or_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_decl_or_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDeclarator {
    #[doc = "Calls [VisitMut`::visit_mut_var_declarator`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_declarator(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Pat as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(init, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for WhileStmt {
    #[doc = "Calls [VisitMut`::visit_mut_while_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_while_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            WhileStmt { span, test, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for WithStmt {
    #[doc = "Calls [VisitMut`::visit_mut_with_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_with_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            WithStmt { span, obj, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Box<Expr> as VisitMutWith<V>>::visit_mut_with(obj, visitor)
                };
                {
                    <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for YieldExpr {
    #[doc = "Calls [VisitMut`::visit_mut_yield_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_yield_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(arg, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitMut`::visit_mut_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_atom(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BigIntValue {
    #[doc = "Calls [VisitMut`::visit_mut_big_int_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_big_int_value(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ClassMember> {
    #[doc = "Calls [VisitMut`::visit_mut_class_members`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_members(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ClassMember as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Decorator> {
    #[doc = "Calls [VisitMut`::visit_mut_decorators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_decorators(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Decorator as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [VisitMut`::visit_mut_export_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_specifiers(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ExportSpecifier as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ExprOrSpread as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Box<Expr>> {
    #[doc = "Calls [VisitMut`::visit_mut_exprs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_exprs(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Box<Expr> as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [VisitMut`::visit_mut_import_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_specifiers(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ImportSpecifier as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ImportWithItem> {
    #[doc = "Calls [VisitMut`::visit_mut_import_with_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_with_items(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ImportWithItem as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <JSXAttrOrSpread as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<JSXElementChild> {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element_childs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element_childs(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <JSXElementChild as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ModuleItem> {
    #[doc = "Calls [VisitMut`::visit_mut_module_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_items(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ModuleItem as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [VisitMut`::visit_mut_object_pat_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_pat_props(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ObjectPatProp as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_atom(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<BlockStmt> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_block_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_block_stmt(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <BlockStmt as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<CatchClause> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_catch_clause`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_catch_clause(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <CatchClause as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<Expr>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_expr(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Expr> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<ExprOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_expr_or_spread`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_expr_or_spread(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <ExprOrSpread as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Vec<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Ident> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ident`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ident(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Ident as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<JSXAttrValue> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_jsx_attr_value(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXAttrValue as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<JSXClosingElement> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_jsx_closing_element(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXClosingElement as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<ModuleExportName> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_module_export_name`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_module_export_name(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <ModuleExportName as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_object_lit`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_object_lit(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<ObjectLit> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Pat> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_pat`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_pat(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Pat as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<swc_common::Span> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_span(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_common::Span as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<Stmt>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_stmt(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<Str>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_str`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_str(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Str> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_var_decl_or_expr(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <VarDeclOrExpr as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_vec_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut().for_each(|item| {
            <Option<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(item, visitor)
        })
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Option<Pat>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_vec_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_vec_pats(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Option<Pat> as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [VisitMut`::visit_mut_param_or_ts_param_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_param_or_ts_param_props(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ParamOrTsParamProp as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Param> {
    #[doc = "Calls [VisitMut`::visit_mut_params`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_params(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Param as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Pat> {
    #[doc = "Calls [VisitMut`::visit_mut_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_pats(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Pat as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<PropOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_prop_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop_or_spreads(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <PropOrSpread as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_common::Span {
    #[doc = "Calls [VisitMut`::visit_mut_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_span(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Stmt> {
    #[doc = "Calls [VisitMut`::visit_mut_stmts`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_stmts(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Stmt as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<SwitchCase> {
    #[doc = "Calls [VisitMut`::visit_mut_switch_cases`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_switch_cases(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <SwitchCase as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_common::SyntaxContext {
    #[doc = "Calls [VisitMut`::visit_mut_syntax_context`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_syntax_context(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TplElement> {
    #[doc = "Calls [VisitMut`::visit_mut_tpl_elements`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tpl_elements(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TplElement as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<VarDeclarator> {
    #[doc = "Calls [VisitMut`::visit_mut_var_declarators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_declarators(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <VarDeclarator as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V, T> VisitMutWith<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitMut,
    T: VisitMutWith<V>,
{
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        let v = <T as VisitMutWith<V>>::visit_mut_with(&mut **self, visitor);
        v
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        let v = <T as VisitMutWith<V>>::visit_mut_children_with(&mut **self, visitor);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitMutAstPath {
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, __ast_path: &mut AstKindPath) {
        <ArrayLit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, __ast_path: &mut AstKindPath) {
        <ArrayPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, __ast_path: &mut AstKindPath) {
        <ArrowExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, __ast_path: &mut AstKindPath) {
        <AssignExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, __ast_path: &mut AstKindPath) {
        <AssignOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, __ast_path: &mut AstKindPath) {
        <AssignPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_assign_pat_prop(
        &mut self,
        node: &mut AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <AssignPatProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, __ast_path: &mut AstKindPath) {
        <AssignProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, __ast_path: &mut AstKindPath) {
        <AssignTarget as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) {
        <AssignTargetPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        <swc_atoms::Atom as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, __ast_path: &mut AstKindPath) {
        <AutoAccessor as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, __ast_path: &mut AstKindPath) {
        <AwaitExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt, __ast_path: &mut AstKindPath) {
        <BigInt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, __ast_path: &mut AstKindPath) {
        <BigIntValue as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, __ast_path: &mut AstKindPath) {
        <BinExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, __ast_path: &mut AstKindPath) {
        <BinaryOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, __ast_path: &mut AstKindPath) {
        <BindingIdent as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, __ast_path: &mut AstKindPath) {
        <BlockStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <BlockStmtOrExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool, __ast_path: &mut AstKindPath) {
        <Bool as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, __ast_path: &mut AstKindPath) {
        <BreakStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, __ast_path: &mut AstKindPath) {
        <CallExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee, __ast_path: &mut AstKindPath) {
        <Callee as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, __ast_path: &mut AstKindPath) {
        <CatchClause as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class, __ast_path: &mut AstKindPath) {
        <Class as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, __ast_path: &mut AstKindPath) {
        <ClassDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, __ast_path: &mut AstKindPath) {
        <ClassExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember, __ast_path: &mut AstKindPath) {
        <ClassMember as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_class_members(
        &mut self,
        node: &mut Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ClassMember> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, __ast_path: &mut AstKindPath) {
        <ClassMethod as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, __ast_path: &mut AstKindPath) {
        <ClassProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) {
        <ComputedPropName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, __ast_path: &mut AstKindPath) {
        <CondExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor, __ast_path: &mut AstKindPath) {
        <Constructor as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, __ast_path: &mut AstKindPath) {
        <ContinueStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, __ast_path: &mut AstKindPath) {
        <DebuggerStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl, __ast_path: &mut AstKindPath) {
        <Decl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator, __ast_path: &mut AstKindPath) {
        <Decorator as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, __ast_path: &mut AstKindPath) {
        <Vec<Decorator> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, __ast_path: &mut AstKindPath) {
        <DefaultDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, __ast_path: &mut AstKindPath) {
        <DoWhileStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, __ast_path: &mut AstKindPath) {
        <EmptyStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll, __ast_path: &mut AstKindPath) {
        <ExportAll as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, __ast_path: &mut AstKindPath) {
        <ExportDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) {
        <ExportDefaultDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <ExportDefaultExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ExportDefaultSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ExportNamedSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ExportNamespaceSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ExportSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ExportSpecifier> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr, __ast_path: &mut AstKindPath) {
        <Expr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, __ast_path: &mut AstKindPath) {
        <ExprOrSpread as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ExprOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, __ast_path: &mut AstKindPath) {
        <ExprStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, __ast_path: &mut AstKindPath) {
        <Vec<Box<Expr>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, __ast_path: &mut AstKindPath) {
        <FnDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, __ast_path: &mut AstKindPath) {
        <FnExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead, __ast_path: &mut AstKindPath) {
        <ForHead as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, __ast_path: &mut AstKindPath) {
        <ForInStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, __ast_path: &mut AstKindPath) {
        <ForOfStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, __ast_path: &mut AstKindPath) {
        <ForStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function, __ast_path: &mut AstKindPath) {
        <Function as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, __ast_path: &mut AstKindPath) {
        <GetterProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident, __ast_path: &mut AstKindPath) {
        <Ident as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName, __ast_path: &mut AstKindPath) {
        <IdentName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, __ast_path: &mut AstKindPath) {
        <IfStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import, __ast_path: &mut AstKindPath) {
        <Import as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, __ast_path: &mut AstKindPath) {
        <ImportDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ImportDefaultSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ImportNamedSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, __ast_path: &mut AstKindPath) {
        <ImportPhase as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ImportSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ImportSpecifier> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <ImportStarAsSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith, __ast_path: &mut AstKindPath) {
        <ImportWith as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) {
        <ImportWithItem as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ImportWithItem> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid, __ast_path: &mut AstKindPath) {
        <Invalid as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, __ast_path: &mut AstKindPath) {
        <JSXAttr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, __ast_path: &mut AstKindPath) {
        <JSXAttrName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXAttrOrSpread as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<JSXAttrOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, __ast_path: &mut AstKindPath) {
        <JSXAttrValue as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXClosingElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXClosingFragment as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, __ast_path: &mut AstKindPath) {
        <JSXElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXElementChild as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<JSXElementChild> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXElementName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, __ast_path: &mut AstKindPath) {
        <JSXEmptyExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, __ast_path: &mut AstKindPath) {
        <JSXExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXExprContainer as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, __ast_path: &mut AstKindPath) {
        <JSXFragment as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_jsx_member_expr(
        &mut self,
        node: &mut JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXMemberExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXNamespacedName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, __ast_path: &mut AstKindPath) {
        <JSXObject as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXOpeningElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXOpeningFragment as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) {
        <JSXSpreadChild as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, __ast_path: &mut AstKindPath) {
        <JSXText as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key, __ast_path: &mut AstKindPath) {
        <Key as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <KeyValuePatProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, __ast_path: &mut AstKindPath) {
        <KeyValueProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, __ast_path: &mut AstKindPath) {
        <LabeledStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit, __ast_path: &mut AstKindPath) {
        <Lit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, __ast_path: &mut AstKindPath) {
        <MemberExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, __ast_path: &mut AstKindPath) {
        <MemberProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, __ast_path: &mut AstKindPath) {
        <MetaPropExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, __ast_path: &mut AstKindPath) {
        <MetaPropKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, __ast_path: &mut AstKindPath) {
        <MethodKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, __ast_path: &mut AstKindPath) {
        <MethodProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module, __ast_path: &mut AstKindPath) {
        <Module as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, __ast_path: &mut AstKindPath) {
        <ModuleDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) {
        <ModuleExportName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, __ast_path: &mut AstKindPath) {
        <ModuleItem as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, __ast_path: &mut AstKindPath) {
        <Vec<ModuleItem> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport, __ast_path: &mut AstKindPath) {
        <NamedExport as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, __ast_path: &mut AstKindPath) {
        <NewExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null, __ast_path: &mut AstKindPath) {
        <Null as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number, __ast_path: &mut AstKindPath) {
        <Number as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, __ast_path: &mut AstKindPath) {
        <ObjectLit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, __ast_path: &mut AstKindPath) {
        <ObjectPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_object_pat_prop(
        &mut self,
        node: &mut ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <ObjectPatProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ObjectPatProp> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<swc_atoms::Atom> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<BlockStmt> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall, __ast_path: &mut AstKindPath) {
        <OptCall as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<CatchClause> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, __ast_path: &mut AstKindPath) {
        <OptChainBase as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, __ast_path: &mut AstKindPath) {
        <OptChainExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, __ast_path: &mut AstKindPath) {
        <Option<Box<Expr>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<ExprOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<Vec<ExprOrSpread>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, __ast_path: &mut AstKindPath) {
        <Option<Ident> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<JSXAttrValue> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<JSXClosingElement> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<ModuleExportName> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<Box<ObjectLit>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, __ast_path: &mut AstKindPath) {
        <Option<Pat> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<swc_common::Span> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, __ast_path: &mut AstKindPath) {
        <Option<Box<Stmt>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, __ast_path: &mut AstKindPath) {
        <Option<Box<Str>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<VarDeclOrExpr> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<Option<ExprOrSpread>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_opt_vec_pats(
        &mut self,
        node: &mut Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<Option<Pat>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param, __ast_path: &mut AstKindPath) {
        <Param as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) {
        <ParamOrTsParamProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ParamOrTsParamProp> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>, __ast_path: &mut AstKindPath) {
        <Vec<Param> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, __ast_path: &mut AstKindPath) {
        <ParenExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat, __ast_path: &mut AstKindPath) {
        <Pat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, __ast_path: &mut AstKindPath) {
        <Vec<Pat> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, __ast_path: &mut AstKindPath) {
        <PrivateMethod as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName, __ast_path: &mut AstKindPath) {
        <PrivateName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, __ast_path: &mut AstKindPath) {
        <PrivateProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program, __ast_path: &mut AstKindPath) {
        <Program as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop, __ast_path: &mut AstKindPath) {
        <Prop as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName, __ast_path: &mut AstKindPath) {
        <PropName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, __ast_path: &mut AstKindPath) {
        <PropOrSpread as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<PropOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex, __ast_path: &mut AstKindPath) {
        <Regex as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, __ast_path: &mut AstKindPath) {
        <RestPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, __ast_path: &mut AstKindPath) {
        <ReturnStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script, __ast_path: &mut AstKindPath) {
        <Script as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, __ast_path: &mut AstKindPath) {
        <SeqExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, __ast_path: &mut AstKindPath) {
        <SetterProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) {
        <SimpleAssignTarget as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        <swc_common::Span as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, __ast_path: &mut AstKindPath) {
        <SpreadElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, __ast_path: &mut AstKindPath) {
        <StaticBlock as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt, __ast_path: &mut AstKindPath) {
        <Stmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, __ast_path: &mut AstKindPath) {
        <Vec<Stmt> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str, __ast_path: &mut AstKindPath) {
        <Str as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super, __ast_path: &mut AstKindPath) {
        <Super as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, __ast_path: &mut AstKindPath) {
        <SuperProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_super_prop_expr(
        &mut self,
        node: &mut SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <SuperPropExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, __ast_path: &mut AstKindPath) {
        <SwitchCase as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, __ast_path: &mut AstKindPath) {
        <Vec<SwitchCase> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, __ast_path: &mut AstKindPath) {
        <SwitchStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) {
        <swc_common::SyntaxContext as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, __ast_path: &mut AstKindPath) {
        <TaggedTpl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, __ast_path: &mut AstKindPath) {
        <ThisExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, __ast_path: &mut AstKindPath) {
        <ThrowStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl, __ast_path: &mut AstKindPath) {
        <Tpl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, __ast_path: &mut AstKindPath) {
        <TplElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, __ast_path: &mut AstKindPath) {
        <Vec<TplElement> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_true_plus_minus(
        &mut self,
        node: &mut TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) {
        <TruePlusMinus as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, __ast_path: &mut AstKindPath) {
        <TryStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, __ast_path: &mut AstKindPath) {
        <UnaryExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, __ast_path: &mut AstKindPath) {
        <UnaryOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, __ast_path: &mut AstKindPath) {
        <UpdateExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, __ast_path: &mut AstKindPath) {
        <UpdateOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, __ast_path: &mut AstKindPath) {
        <UsingDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, __ast_path: &mut AstKindPath) {
        <VarDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, __ast_path: &mut AstKindPath) {
        <VarDeclKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_var_decl_or_expr(
        &mut self,
        node: &mut VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <VarDeclOrExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, __ast_path: &mut AstKindPath) {
        <VarDeclarator as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<VarDeclarator> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, __ast_path: &mut AstKindPath) {
        <WhileStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, __ast_path: &mut AstKindPath) {
        <WithStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, __ast_path: &mut AstKindPath) {
        <YieldExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for &mut V
where
    V: ?Sized + VisitMutAstPath,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_arrow_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_pat_prop(
        &mut self,
        node: &mut AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_assign_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_assign_target_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_auto_accessor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_await_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bin_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binding_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_block_stmt_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bool(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_break_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_call_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_callee(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_member(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_members(
        &mut self,
        node: &mut Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_class_members(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_computed_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_cond_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_constructor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_continue_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_debugger_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_do_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_empty_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_all(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_default_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_namespace_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_exprs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_head(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_in_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_of_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_function(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_getter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_if_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_phase(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_star_as_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_with_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_with_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_invalid(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_childs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_empty_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr_container(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_member_expr(
        &mut self,
        node: &mut JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_namespaced_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_object(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_spread_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_text(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_key_value_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key_value_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_labeled_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_named_export(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_new_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_null(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_number(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_pat_prop(
        &mut self,
        node: &mut ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_object_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_object_pat_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_call(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_base(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_vec_pats(
        &mut self,
        node: &mut Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_params(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_paren_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_program(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_regex(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_rest_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_return_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_script(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_seq_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_setter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_simple_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_spread_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_static_block(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmts(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_super_prop_expr(
        &mut self,
        node: &mut SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_super_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_case(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_cases(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_syntax_context(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tagged_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_this_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_throw_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_elements(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_true_plus_minus(
        &mut self,
        node: &mut TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_true_plus_minus(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_try_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_using_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(
        &mut self,
        node: &mut VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_declarator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_var_declarators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_with_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_yield_expr(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for Box<V>
where
    V: ?Sized + VisitMutAstPath,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_arrow_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_pat_prop(
        &mut self,
        node: &mut AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_assign_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_assign_target_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_auto_accessor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_await_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bin_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binding_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_block_stmt_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bool(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_break_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_call_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_callee(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_member(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_members(
        &mut self,
        node: &mut Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_class_members(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_computed_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_cond_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_constructor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_continue_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_debugger_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_do_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_empty_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_all(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_default_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_namespace_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_export_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_exprs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_head(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_in_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_of_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_function(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_getter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_if_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_phase(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_star_as_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_with_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_import_with_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_invalid(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_childs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_empty_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr_container(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_member_expr(
        &mut self,
        node: &mut JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_namespaced_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_object(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_jsx_spread_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_text(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_key_value_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key_value_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_labeled_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_named_export(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_new_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_null(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_number(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_pat_prop(
        &mut self,
        node: &mut ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_object_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_object_pat_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_call(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_base(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_vec_pats(
        &mut self,
        node: &mut Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_params(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_paren_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_program(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_regex(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_rest_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_return_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_script(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_seq_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_setter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_simple_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_spread_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_static_block(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmts(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_super_prop_expr(
        &mut self,
        node: &mut SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_super_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_case(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_cases(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_syntax_context(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tagged_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_this_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_throw_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_elements(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_true_plus_minus(
        &mut self,
        node: &mut TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_true_plus_minus(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_try_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_using_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(
        &mut self,
        node: &mut VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_declarator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_var_declarators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_with_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_yield_expr(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> VisitMutAstPath for ::swc_visit::Either<A, B>
where
    A: VisitMutAstPath,
    B: VisitMutAstPath,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_array_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_array_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_array_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_array_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_arrow_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_arrow_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_assign_pat_prop(
        &mut self,
        node: &mut AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_target(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_target(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_target_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_target_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_auto_accessor(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_auto_accessor(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_await_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_await_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_big_int(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_big_int(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_big_int_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_big_int_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_bin_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_bin_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_binary_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_binary_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_binding_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_binding_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_bool(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_bool(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_break_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_break_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_call_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_call_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_callee(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_callee(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_catch_clause(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_catch_clause(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_member(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_member(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_members(
        &mut self,
        node: &mut Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_members(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_members(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_method(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_method(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_computed_prop_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_computed_prop_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_cond_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_cond_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_constructor(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_constructor(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_continue_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_continue_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_debugger_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_debugger_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_decorator(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_decorator(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_decorators(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_decorators(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_default_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_default_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_do_while_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_do_while_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_empty_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_empty_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_all(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_all(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_default_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_default_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_default_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_default_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_default_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_default_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_named_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_named_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_namespace_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_namespace_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_specifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_specifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_exprs(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_exprs(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_fn_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_fn_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_fn_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_fn_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_head(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_head(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_in_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_in_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_of_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_of_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_function(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_function(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_getter_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_getter_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ident_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ident_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_if_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_if_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_default_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_default_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_named_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_named_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_phase(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_phase(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_specifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_specifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_star_as_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_star_as_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_with(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_with(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_with_item(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_with_item(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_with_items(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_with_items(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_invalid(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_invalid(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_child(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_child(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_childs(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_childs(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_empty_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_empty_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr_container(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr_container(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_member_expr(
        &mut self,
        node: &mut JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_member_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_member_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_namespaced_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_namespaced_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_object(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_object(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_spread_child(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_spread_child(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_text(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_text(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_key(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_key(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_key_value_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_key_value_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_key_value_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_key_value_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_labeled_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_labeled_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_member_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_member_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_member_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_member_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_method_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_method_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_method_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_method_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_export_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_export_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_item(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_item(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_items(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_items(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_named_export(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_named_export(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_new_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_new_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_null(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_null(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_number(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_number(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_object_pat_prop(
        &mut self,
        node: &mut ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_props(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_props(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_block_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_block_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_call(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_call(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_catch_clause(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_catch_clause(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_base(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_base(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_attr_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_attr_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_closing_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_closing_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_module_export_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_module_export_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_object_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_object_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_span(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_span(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_str(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_str(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_var_decl_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_var_decl_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_vec_pats(
        &mut self,
        node: &mut Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_pats(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_pats(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_param(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_param(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_props(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_props(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_params(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_params(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_paren_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_paren_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_pats(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_pats(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_private_method(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_private_method(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_private_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_private_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_private_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_private_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_program(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_program(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_regex(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_regex(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_rest_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_rest_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_return_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_return_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_script(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_script(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_seq_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_seq_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_setter_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_setter_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_simple_assign_target(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_simple_assign_target(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_span(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_span(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_spread_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_spread_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_static_block(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_static_block(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_stmts(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_stmts(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_str(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_str(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_super(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_super(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_super_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_super_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_super_prop_expr(
        &mut self,
        node: &mut SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_super_prop_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_super_prop_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_switch_case(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_switch_case(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_switch_cases(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_switch_cases(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_switch_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_switch_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_syntax_context(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_syntax_context(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tagged_tpl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tagged_tpl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_this_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_this_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_throw_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_throw_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tpl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tpl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tpl_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tpl_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tpl_elements(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tpl_elements(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_true_plus_minus(
        &mut self,
        node: &mut TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_true_plus_minus(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_true_plus_minus(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_try_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_try_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_unary_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_unary_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_unary_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_unary_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_update_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_update_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_update_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_update_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_using_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_using_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(
        &mut self,
        node: &mut VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_declarator(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_declarator(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_declarators(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_declarators(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_while_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_while_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_with_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_with_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_yield_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_yield_expr(visitor, node, __ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for ::swc_visit::Optional<V>
where
    V: VisitMutAstPath,
{
    #[inline]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_array_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_array_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_arrow_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_assign_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_assign_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_assign_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_pat_prop(
        &mut self,
        node: &mut AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_assign_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_assign_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_assign_target(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_assign_target_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_auto_accessor(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_await_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_big_int(&mut self, node: &mut BigInt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_big_int(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_big_int_value(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_bin_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_binary_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_binding_ident(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_block_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_block_stmt_or_expr(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_bool(&mut self, node: &mut Bool, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_bool(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_break_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_call_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_callee(&mut self, node: &mut Callee, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_callee(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_catch_clause(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class(&mut self, node: &mut Class, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_member(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_members(
        &mut self,
        node: &mut Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_members(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_method(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_computed_prop_name(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_cond_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_constructor(&mut self, node: &mut Constructor, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_constructor(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_continue_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_debugger_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_decl(&mut self, node: &mut Decl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_decorator(&mut self, node: &mut Decorator, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_decorator(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_decorators(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_default_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_do_while_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_empty_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_all(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_default_decl(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_default_expr(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_default_specifier(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_named_specifier(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_namespace_specifier(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_export_specifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr(&mut self, node: &mut Expr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_expr_or_spread(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_expr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_expr_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_exprs(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_fn_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_fn_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_head(&mut self, node: &mut ForHead, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_for_head(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_for_in_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_for_of_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_for_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_function(&mut self, node: &mut Function, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_function(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_getter_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_ident(&mut self, node: &mut Ident, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_ident(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_ident_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_if_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import(&mut self, node: &mut Import, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_default_specifier(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_named_specifier(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_phase(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_specifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_specifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_star_as_specifier(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_with(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_with_item(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_import_with_items(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_invalid(&mut self, node: &mut Invalid, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_invalid(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_attr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_attr_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spread(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spreads(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_attr_value(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_closing_element(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_closing_fragment(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_element_child(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_element_childs(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_element_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_empty_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_expr_container(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_fragment(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_member_expr(
        &mut self,
        node: &mut JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_member_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_namespaced_name(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_object(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_opening_element(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_opening_fragment(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_spread_child(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_jsx_text(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_key(&mut self, node: &mut Key, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_key(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_key_value_pat_prop(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_key_value_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_labeled_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_lit(&mut self, node: &mut Lit, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_member_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_member_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_meta_prop_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_meta_prop_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_method_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_method_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module(&mut self, node: &mut Module, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_module(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_module_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_module_export_name(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_module_item(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_module_items(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_named_export(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_new_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_null(&mut self, node: &mut Null, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_null(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_number(&mut self, node: &mut Number, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_number(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_object_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_object_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_pat_prop(
        &mut self,
        node: &mut ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_object_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_object_pat_props(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_block_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_call(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_catch_clause(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_chain_base(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_chain_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_expr_or_spread(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_expr_or_spreads(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_ident(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_jsx_attr_value(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_jsx_closing_element(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_module_export_name(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_object_lit(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_span(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_str(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_var_decl_or_expr(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_vec_expr_or_spreads(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_vec_pats(
        &mut self,
        node: &mut Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_vec_pats(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_param(&mut self, node: &mut Param, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_param(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_param_or_ts_param_prop(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_param_or_ts_param_props(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_params(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_paren_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_pat(&mut self, node: &mut Pat, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_pats(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_private_method(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_private_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_private_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_program(&mut self, node: &mut Program, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_program(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop(&mut self, node: &mut Prop, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop_name(&mut self, node: &mut PropName, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_prop_name(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_prop_or_spread(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_prop_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_regex(&mut self, node: &mut Regex, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_regex(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_rest_pat(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_return_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_script(&mut self, node: &mut Script, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_script(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_seq_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_setter_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_simple_assign_target(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_span(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_spread_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_static_block(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_stmt(&mut self, node: &mut Stmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_stmts(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_str(&mut self, node: &mut Str, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_str(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_super(&mut self, node: &mut Super, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_super(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_super_prop(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_super_prop_expr(
        &mut self,
        node: &mut SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_super_prop_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_switch_case(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_switch_cases(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_switch_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_syntax_context(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_tagged_tpl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_this_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_throw_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tpl(&mut self, node: &mut Tpl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_tpl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_tpl_element(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_tpl_elements(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_true_plus_minus(
        &mut self,
        node: &mut TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_true_plus_minus(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_try_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_unary_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_unary_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_update_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_update_op(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_using_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_var_decl(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_var_decl_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_decl_or_expr(
        &mut self,
        node: &mut VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_var_decl_or_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_var_declarator(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_var_declarators(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_while_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_with_stmt(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_yield_expr(&mut self.visitor, node, __ast_path)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitMutWithAstPath<V: ?Sized + VisitMutAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath);
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ArrayLit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_array_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_lit(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ArrayLit { span, elems } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrayLit(self::fields::ArrayLitField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrayLit(
                        self::fields::ArrayLitField::Elems(usize::MAX),
                    ));
                    <Vec<Option<ExprOrSpread>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        elems,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ArrayPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_array_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_pat(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrayPat(self::fields::ArrayPatField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrayPat(
                        self::fields::ArrayPatField::Elems(usize::MAX),
                    ));
                    <Vec<Option<Pat>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        elems,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrayPat(
                        self::fields::ArrayPatField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ArrowExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_arrow_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_arrow_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrowExpr(self::fields::ArrowExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrowExpr(self::fields::ArrowExprField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrowExpr(
                        self::fields::ArrowExprField::Params(usize::MAX),
                    ));
                    <Vec<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrowExpr(self::fields::ArrowExprField::Body));
                    <Box<BlockStmtOrExpr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrowExpr(
                        self::fields::ArrowExprField::TypeParams,
                    ));
                    < Option < Box < TsTypeParamDecl > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_params , visitor , & mut * __ast_path)
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrowExpr(
                        self::fields::ArrowExprField::ReturnType,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        return_type,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignExpr(
                        self::fields::AssignExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AssignExpr(self::fields::AssignExprField::Op));
                    <AssignOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignExpr(
                        self::fields::AssignExprField::Left,
                    ));
                    <AssignTarget as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignExpr(
                        self::fields::AssignExprField::Right,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_op(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_pat(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AssignPat { span, left, right } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AssignPat(self::fields::AssignPatField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AssignPat(self::fields::AssignPatField::Left));
                    <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPat(
                        self::fields::AssignPatField::Right,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignPatProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_pat_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_pat_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AssignPatProp { span, key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPatProp(
                        self::fields::AssignPatPropField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPatProp(
                        self::fields::AssignPatPropField::Key,
                    ));
                    <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPatProp(
                        self::fields::AssignPatPropField::Value,
                    ));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AssignProp { span, key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignProp(
                        self::fields::AssignPropField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignProp(
                        self::fields::AssignPropField::Key,
                    ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignProp(
                        self::fields::AssignPropField::Value,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignTarget {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_target`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_target(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTarget(
                    self::fields::AssignTargetField::Simple,
                ));
                <SimpleAssignTarget as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            AssignTarget::Pat { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTarget(
                    self::fields::AssignTargetField::Pat,
                ));
                <AssignTargetPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignTargetPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_target_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_target_pat(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTargetPat(
                    self::fields::AssignTargetPatField::Array,
                ));
                <ArrayPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTargetPat(
                    self::fields::AssignTargetPatField::Object,
                ));
                <ObjectPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTargetPat(
                    self::fields::AssignTargetPatField::Invalid,
                ));
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AutoAccessor {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_auto_accessor`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_auto_accessor(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Key,
                    ));
                    <Key as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Value,
                    ));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AwaitExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_await_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_await_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            AwaitExpr { span, arg } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AwaitExpr(self::fields::AwaitExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AwaitExpr(self::fields::AwaitExprField::Arg));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BigInt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_big_int`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BigInt { span, value, raw } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BigInt(self::fields::BigIntField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BigInt(self::fields::BigIntField::Value));
                    <Box<BigIntValue> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BigInt(self::fields::BigIntField::Raw));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BinExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_bin_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bin_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Op));
                    <BinaryOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Left));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Right));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BinaryOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_binary_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binary_op(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BindingIdent {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_binding_ident`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binding_ident(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BindingIdent { id, type_ann } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BindingIdent(
                        self::fields::BindingIdentField::Id,
                    ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        id,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BindingIdent(
                        self::fields::BindingIdentField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BlockStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_block_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_block_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BlockStmt(self::fields::BlockStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BlockStmt(self::fields::BlockStmtField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BlockStmt(
                        self::fields::BlockStmtField::Stmts(usize::MAX),
                    ));
                    <Vec<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        stmts,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BlockStmtOrExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_block_stmt_or_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_block_stmt_or_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::BlockStmtOrExpr(
                    self::fields::BlockStmtOrExprField::BlockStmt,
                ));
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::BlockStmtOrExpr(
                    self::fields::BlockStmtOrExprField::Expr,
                ));
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Bool {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_bool`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bool(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Bool { span, value } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Bool(self::fields::BoolField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BreakStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_break_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_break_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BreakStmt { span, label } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BreakStmt(self::fields::BreakStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BreakStmt(
                        self::fields::BreakStmtField::Label,
                    ));
                    <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CallExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_call_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_call_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CallExpr(self::fields::CallExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CallExpr(self::fields::CallExprField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CallExpr(self::fields::CallExprField::Callee));
                    <Callee as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CallExpr(
                        self::fields::CallExprField::Args(usize::MAX),
                    ));
                    <Vec<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CallExpr(
                        self::fields::CallExprField::TypeArgs,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Callee {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_callee`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_callee(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Callee::Super { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Callee(self::fields::CalleeField::Super));
                <Super as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Callee::Import { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Callee(self::fields::CalleeField::Import));
                <Import as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Callee::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Callee(self::fields::CalleeField::Expr));
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CatchClause {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_catch_clause`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_catch_clause(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CatchClause { span, param, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CatchClause(
                        self::fields::CatchClauseField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CatchClause(
                        self::fields::CatchClauseField::Param,
                    ));
                    <Option<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CatchClause(
                        self::fields::CatchClauseField::Body,
                    ));
                    <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Class {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Class(self::fields::ClassField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Class(self::fields::ClassField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::Body(usize::MAX),
                    ));
                    <Vec<ClassMember> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Class(self::fields::ClassField::SuperClass));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        super_class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Class(self::fields::ClassField::TypeParams));
                    < Option < Box < TsTypeParamDecl > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_params , visitor , & mut * __ast_path)
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::SuperTypeParams,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (super_type_params , visitor , & mut * __ast_path)
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::Implements(usize::MAX),
                    ));
                    <Vec<TsExprWithTypeArgs> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        implements,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassDecl(
                        self::fields::ClassDeclField::Ident,
                    ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassDecl(
                        self::fields::ClassDeclField::Class,
                    ));
                    <Box<Class> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ClassExpr { ident, class } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassExpr(
                        self::fields::ClassExprField::Ident,
                    ));
                    <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassExpr(
                        self::fields::ClassExprField::Class,
                    ));
                    <Box<Class> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassMember {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_member`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_member(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::Constructor,
                ));
                <Constructor as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::Method { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::Method,
                ));
                <ClassMethod as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::PrivateMethod { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::PrivateMethod,
                ));
                <PrivateMethod as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::ClassProp,
                ));
                <ClassProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::PrivateProp,
                ));
                <PrivateProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::TsIndexSignature,
                ));
                <TsIndexSignature as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::Empty { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::Empty,
                ));
                <EmptyStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::StaticBlock,
                ));
                <StaticBlock as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::AutoAccessor,
                ));
                <AutoAccessor as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassMethod {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_method`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_method(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Key,
                    ));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Function,
                    ));
                    <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Kind,
                    ));
                    <MethodKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ClassProp(self::fields::ClassPropField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ClassProp(self::fields::ClassPropField::Key));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::Value,
                    ));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ComputedPropName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_computed_prop_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_computed_prop_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ComputedPropName { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ComputedPropName(
                        self::fields::ComputedPropNameField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ComputedPropName(
                        self::fields::ComputedPropNameField::Expr,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CondExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_cond_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_cond_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Test));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Cons));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Alt));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        alt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Constructor {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_constructor`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_constructor(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Key,
                    ));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Params(usize::MAX),
                    ));
                    <Vec<ParamOrTsParamProp> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Body,
                    ));
                    <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ContinueStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_continue_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_continue_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ContinueStmt { span, label } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ContinueStmt(
                        self::fields::ContinueStmtField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ContinueStmt(
                        self::fields::ContinueStmtField::Label,
                    ));
                    <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for DebuggerStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_debugger_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_debugger_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            DebuggerStmt { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DebuggerStmt(
                        self::fields::DebuggerStmtField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Decl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Decl::Class { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Class));
                <ClassDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::Fn { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Fn));
                <FnDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::Var { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Var));
                <Box<VarDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::Using { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Using));
                <Box<UsingDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsInterface { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Decl(self::fields::DeclField::TsInterface));
                <Box<TsInterfaceDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Decl(self::fields::DeclField::TsTypeAlias));
                <Box<TsTypeAliasDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsEnum { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::TsEnum));
                <Box<TsEnumDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Decl::TsModule { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::TsModule));
                <Box<TsModuleDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Decorator {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_decorator`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorator(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Decorator { span, expr } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Decorator(self::fields::DecoratorField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Decorator(self::fields::DecoratorField::Expr));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for DefaultDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_default_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_default_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::DefaultDecl(
                    self::fields::DefaultDeclField::Class,
                ));
                <ClassExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::DefaultDecl(
                    self::fields::DefaultDeclField::Fn,
                ));
                <FnExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::DefaultDecl(
                    self::fields::DefaultDeclField::TsInterfaceDecl,
                ));
                <Box<TsInterfaceDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for DoWhileStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_do_while_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_do_while_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            DoWhileStmt { span, test, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DoWhileStmt(
                        self::fields::DoWhileStmtField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DoWhileStmt(
                        self::fields::DoWhileStmtField::Test,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DoWhileStmt(
                        self::fields::DoWhileStmtField::Body,
                    ));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for EmptyStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_empty_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_empty_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            EmptyStmt { span } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::EmptyStmt(self::fields::EmptyStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportAll {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_all`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_all(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExportAll(self::fields::ExportAllField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExportAll(self::fields::ExportAllField::Src));
                    <Box<Str> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExportAll(self::fields::ExportAllField::With));
                    <Option<Box<ObjectLit>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportDecl { span, decl } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDecl(
                        self::fields::ExportDeclField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDecl(
                        self::fields::ExportDeclField::Decl,
                    ));
                    <Decl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDefaultDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_default_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_default_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportDefaultDecl { span, decl } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultDecl(
                        self::fields::ExportDefaultDeclField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultDecl(
                        self::fields::ExportDefaultDeclField::Decl,
                    ));
                    <DefaultDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDefaultExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_default_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_default_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportDefaultExpr { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultExpr(
                        self::fields::ExportDefaultExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultExpr(
                        self::fields::ExportDefaultExprField::Expr,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDefaultSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_default_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_default_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportDefaultSpecifier { exported } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportDefaultSpecifier(
                            self::fields::ExportDefaultSpecifierField::Exported,
                        ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        exported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportNamedSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_named_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_named_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamedSpecifier(
                            self::fields::ExportNamedSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamedSpecifier(
                            self::fields::ExportNamedSpecifierField::Orig,
                        ));
                    <ModuleExportName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        orig,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamedSpecifier(
                            self::fields::ExportNamedSpecifierField::Exported,
                        ));
                    <Option<ModuleExportName> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        exported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_namespace_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_namespace_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamespaceSpecifier(
                            self::fields::ExportNamespaceSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamespaceSpecifier(
                            self::fields::ExportNamespaceSpecifierField::Name,
                        ));
                    <ModuleExportName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportSpecifier(
                    self::fields::ExportSpecifierField::Namespace,
                ));
                <ExportNamespaceSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportSpecifier(
                    self::fields::ExportSpecifierField::Default,
                ));
                <ExportDefaultSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportSpecifier(
                    self::fields::ExportSpecifierField::Named,
                ));
                <ExportNamedSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Expr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Expr::This { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::This));
                <ThisExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Array { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Array));
                <ArrayLit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Object { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Object));
                <ObjectLit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Fn { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Fn));
                <FnExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Unary { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Unary));
                <UnaryExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Update { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Update));
                <UpdateExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Bin { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Bin));
                <BinExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Assign { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Assign));
                <AssignExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Member { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Member));
                <MemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::SuperProp { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::SuperProp));
                <SuperPropExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Cond { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Cond));
                <CondExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Call { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Call));
                <CallExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::New { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::New));
                <NewExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Seq { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Seq));
                <SeqExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Ident { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Ident));
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Lit { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Lit));
                <Lit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Tpl { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Tpl));
                <Tpl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::TaggedTpl));
                <TaggedTpl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Arrow { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Arrow));
                <ArrowExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Class { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Class));
                <ClassExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Yield { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Yield));
                <YieldExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::MetaProp { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::MetaProp));
                <MetaPropExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Await { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Await));
                <AwaitExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Paren { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Paren));
                <ParenExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXMember { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxmember));
                <JSXMemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::JsxnamespacedName,
                ));
                <JSXNamespacedName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxempty));
                <JSXEmptyExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXElement { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxelement));
                <Box<JSXElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxfragment));
                <JSXFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::TsTypeAssertion,
                ));
                <TsTypeAssertion as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::TsConstAssertion,
                ));
                <TsConstAssertion as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsNonNull { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::TsNonNull));
                <TsNonNullExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsAs { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::TsAs));
                <TsAsExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::TsInstantiation,
                ));
                <TsInstantiation as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Expr(self::fields::ExprField::TsSatisfies));
                <TsSatisfiesExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::PrivateName { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Expr(self::fields::ExprField::PrivateName));
                <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::OptChain { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::OptChain));
                <OptChainExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Expr::Invalid { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Invalid));
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExprOrSpread {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr_or_spread`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spread(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExprOrSpread { spread, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExprOrSpread(
                        self::fields::ExprOrSpreadField::Spread,
                    ));
                    <Option<swc_common::Span> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        spread,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExprOrSpread(
                        self::fields::ExprOrSpreadField::Expr,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExprStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ExprStmt { span, expr } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExprStmt(self::fields::ExprStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExprStmt(self::fields::ExprStmtField::Expr));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for FnDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_fn_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnDecl(self::fields::FnDeclField::Ident));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnDecl(self::fields::FnDeclField::Function));
                    <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for FnExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_fn_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            FnExpr { ident, function } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnExpr(self::fields::FnExprField::Ident));
                    <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnExpr(self::fields::FnExprField::Function));
                    <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForHead {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_head`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_head(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::ForHead(self::fields::ForHeadField::VarDecl));
                <Box<VarDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ForHead(
                    self::fields::ForHeadField::UsingDecl,
                ));
                <Box<UsingDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ForHead::Pat { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::ForHead(self::fields::ForHeadField::Pat));
                <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForInStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_in_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_in_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForInStmt(self::fields::ForInStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForInStmt(self::fields::ForInStmtField::Left));
                    <ForHead as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ForInStmt(
                        self::fields::ForInStmtField::Right,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForInStmt(self::fields::ForInStmtField::Body));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForOfStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_of_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_of_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForOfStmt(self::fields::ForOfStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForOfStmt(self::fields::ForOfStmtField::Left));
                    <ForHead as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ForOfStmt(
                        self::fields::ForOfStmtField::Right,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForOfStmt(self::fields::ForOfStmtField::Body));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Init));
                    <Option<VarDeclOrExpr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        init,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Test));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Update));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        update,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Body));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Function {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_function`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_function(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::Params(usize::MAX),
                    ));
                    <Vec<Param> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Function(self::fields::FunctionField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Function(self::fields::FunctionField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Function(self::fields::FunctionField::Body));
                    <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::TypeParams,
                    ));
                    < Option < Box < TsTypeParamDecl > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_params , visitor , & mut * __ast_path)
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::ReturnType,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        return_type,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for GetterProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_getter_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_getter_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::Key,
                    ));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::Body,
                    ));
                    <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Ident {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ident`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Ident(self::fields::IdentField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Ident(self::fields::IdentField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Ident(self::fields::IdentField::Sym));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        sym,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for IdentName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ident_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            IdentName { span, sym } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IdentName(self::fields::IdentNameField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IdentName(self::fields::IdentNameField::Sym));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        sym,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for IfStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_if_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_if_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Test));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Cons));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Alt));
                    <Option<Box<Stmt>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        alt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Import {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Import { span, phase } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Import(self::fields::ImportField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Import(self::fields::ImportField::Phase));
                    <ImportPhase as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        phase,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Specifiers(usize::MAX),
                    ));
                    <Vec<ImportSpecifier> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        specifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Src,
                    ));
                    <Box<Str> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::With,
                    ));
                    <Option<Box<ObjectLit>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Phase,
                    ));
                    <ImportPhase as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        phase,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportDefaultSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_default_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_default_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportDefaultSpecifier(
                            self::fields::ImportDefaultSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportDefaultSpecifier(
                            self::fields::ImportDefaultSpecifierField::Local,
                        ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportNamedSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_named_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_named_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportNamedSpecifier(
                            self::fields::ImportNamedSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportNamedSpecifier(
                            self::fields::ImportNamedSpecifierField::Local,
                        ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportNamedSpecifier(
                            self::fields::ImportNamedSpecifierField::Imported,
                        ));
                    <Option<ModuleExportName> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        imported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportPhase {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_phase`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_phase(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportSpecifier(
                    self::fields::ImportSpecifierField::Named,
                ));
                <ImportNamedSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportSpecifier(
                    self::fields::ImportSpecifierField::Default,
                ));
                <ImportDefaultSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportSpecifier(
                    self::fields::ImportSpecifierField::Namespace,
                ));
                <ImportStarAsSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportStarAsSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_star_as_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_star_as_specifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportStarAsSpecifier(
                            self::fields::ImportStarAsSpecifierField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportStarAsSpecifier(
                            self::fields::ImportStarAsSpecifierField::Local,
                        ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportWith {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_with`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportWith { span, values } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWith(
                        self::fields::ImportWithField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWith(
                        self::fields::ImportWithField::Values(usize::MAX),
                    ));
                    <Vec<ImportWithItem> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        values,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportWithItem {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_with_item`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with_item(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ImportWithItem { key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWithItem(
                        self::fields::ImportWithItemField::Key,
                    ));
                    <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWithItem(
                        self::fields::ImportWithItemField::Value,
                    ));
                    <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Invalid {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_invalid`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_invalid(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Invalid { span } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Invalid(self::fields::InvalidField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXAttr { span, name, value } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXAttr(self::fields::JSXAttrField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXAttr(self::fields::JSXAttrField::Name));
                    <JSXAttrName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXAttr(self::fields::JSXAttrField::Value));
                    <Option<JSXAttrValue> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttrName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrName(
                    self::fields::JSXAttrNameField::Ident,
                ));
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrName(
                    self::fields::JSXAttrNameField::JsxnamespacedName,
                ));
                <JSXNamespacedName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttrOrSpread {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_or_spread`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spread(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrOrSpread(
                    self::fields::JSXAttrOrSpreadField::Jsxattr,
                ));
                <JSXAttr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrOrSpread(
                    self::fields::JSXAttrOrSpreadField::SpreadElement,
                ));
                <SpreadElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttrValue {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_value`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_value(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::Lit,
                ));
                <Lit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::JsxexprContainer,
                ));
                <JSXExprContainer as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::Jsxelement,
                ));
                <Box<JSXElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::Jsxfragment,
                ));
                <JSXFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXClosingElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_closing_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_element(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXClosingElement { span, name } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXClosingElement(
                        self::fields::JSXClosingElementField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXClosingElement(
                        self::fields::JSXClosingElementField::Name,
                    ));
                    <JSXElementName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXClosingFragment {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_closing_fragment`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_fragment(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXClosingFragment { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXClosingFragment(
                        self::fields::JSXClosingFragmentField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Opening,
                    ));
                    <JSXOpeningElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        opening,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Children(usize::MAX),
                    ));
                    <Vec<JSXElementChild> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        children,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Closing,
                    ));
                    <Option<JSXClosingElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        closing,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXElementChild {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element_child`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_child(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::Jsxtext,
                ));
                <JSXText as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::JsxexprContainer,
                ));
                <JSXExprContainer as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::JsxspreadChild,
                ));
                <JSXSpreadChild as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::Jsxelement,
                ));
                <Box<JSXElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::Jsxfragment,
                ));
                <JSXFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXElementName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementName(
                    self::fields::JSXElementNameField::Ident,
                ));
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementName(
                    self::fields::JSXElementNameField::JsxmemberExpr,
                ));
                <JSXMemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementName(
                    self::fields::JSXElementNameField::JsxnamespacedName,
                ));
                <JSXNamespacedName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXEmptyExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_empty_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_empty_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXEmptyExpr { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXEmptyExpr(
                        self::fields::JSXEmptyExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXExpr(
                    self::fields::JSXExprField::JsxemptyExpr,
                ));
                <JSXEmptyExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXExpr::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::JSXExpr(self::fields::JSXExprField::Expr));
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXExprContainer {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_expr_container`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr_container(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXExprContainer { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXExprContainer(
                        self::fields::JSXExprContainerField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXExprContainer(
                        self::fields::JSXExprContainerField::Expr,
                    ));
                    <JSXExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXFragment {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_fragment`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_fragment(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Opening,
                    ));
                    <JSXOpeningFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        opening,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Children(usize::MAX),
                    ));
                    <Vec<JSXElementChild> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        children,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Closing,
                    ));
                    <JSXClosingFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        closing,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXMemberExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_member_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_member_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXMemberExpr(
                        self::fields::JSXMemberExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXMemberExpr(
                        self::fields::JSXMemberExprField::Obj,
                    ));
                    <JSXObject as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXMemberExpr(
                        self::fields::JSXMemberExprField::Prop,
                    ));
                    <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXNamespacedName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_namespaced_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_namespaced_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXNamespacedName(
                        self::fields::JSXNamespacedNameField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXNamespacedName(
                        self::fields::JSXNamespacedNameField::Ns,
                    ));
                    <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ns,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXNamespacedName(
                        self::fields::JSXNamespacedNameField::Name,
                    ));
                    <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXObject {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_object`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_object(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXObject(
                    self::fields::JSXObjectField::JsxmemberExpr,
                ));
                <Box<JSXMemberExpr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            JSXObject::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXObject(
                    self::fields::JSXObjectField::Ident,
                ));
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXOpeningElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_opening_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_element(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::Name,
                    ));
                    <JSXElementName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::Attrs(usize::MAX),
                    ));
                    <Vec<JSXAttrOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        attrs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::TypeArgs,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXOpeningFragment {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_opening_fragment`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_fragment(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXOpeningFragment { span } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningFragment(
                        self::fields::JSXOpeningFragmentField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXSpreadChild {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_spread_child`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_spread_child(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXSpreadChild { span, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXSpreadChild(
                        self::fields::JSXSpreadChildField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXSpreadChild(
                        self::fields::JSXSpreadChildField::Expr,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXText {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_text`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_text(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            JSXText { span, value, raw } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXText(self::fields::JSXTextField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXText(self::fields::JSXTextField::Value));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXText(self::fields::JSXTextField::Raw));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Key {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_key`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Key::Private { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Key(self::fields::KeyField::Private));
                <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Key::Public { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Key(self::fields::KeyField::Public));
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for KeyValuePatProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_key_value_pat_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key_value_pat_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            KeyValuePatProp { key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValuePatProp(
                        self::fields::KeyValuePatPropField::Key,
                    ));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValuePatProp(
                        self::fields::KeyValuePatPropField::Value,
                    ));
                    <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for KeyValueProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_key_value_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key_value_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            KeyValueProp { key, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValueProp(
                        self::fields::KeyValuePropField::Key,
                    ));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValueProp(
                        self::fields::KeyValuePropField::Value,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for LabeledStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_labeled_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_labeled_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            LabeledStmt { span, label, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LabeledStmt(
                        self::fields::LabeledStmtField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LabeledStmt(
                        self::fields::LabeledStmtField::Label,
                    ));
                    <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LabeledStmt(
                        self::fields::LabeledStmtField::Body,
                    ));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Lit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_lit(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Lit::Str { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Str));
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Bool { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Bool));
                <Bool as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Null { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Null));
                <Null as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Num { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Num));
                <Number as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::BigInt { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::BigInt));
                <BigInt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::Regex { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Regex));
                <Regex as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Lit::JSXText { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Jsxtext));
                <JSXText as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MemberExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_member_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            MemberExpr { span, obj, prop } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberExpr(
                        self::fields::MemberExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberExpr(
                        self::fields::MemberExprField::Obj,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberExpr(
                        self::fields::MemberExprField::Prop,
                    ));
                    <MemberProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MemberProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_member_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberProp(
                    self::fields::MemberPropField::Ident,
                ));
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberProp(
                    self::fields::MemberPropField::PrivateName,
                ));
                <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            MemberProp::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberProp(
                    self::fields::MemberPropField::Computed,
                ));
                <ComputedPropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MetaPropExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_meta_prop_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            MetaPropExpr { span, kind } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MetaPropExpr(
                        self::fields::MetaPropExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MetaPropExpr(
                        self::fields::MetaPropExprField::Kind,
                    ));
                    <MetaPropKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MetaPropKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_meta_prop_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MethodKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_method_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MethodProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_method_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            MethodProp { key, function } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MethodProp(
                        self::fields::MethodPropField::Key,
                    ));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MethodProp(
                        self::fields::MethodPropField::Function,
                    ));
                    <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Module {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Module(self::fields::ModuleField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Module(
                        self::fields::ModuleField::Body(usize::MAX),
                    ));
                    <Vec<ModuleItem> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Module(self::fields::ModuleField::Shebang));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        shebang,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ModuleDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::Import,
                ));
                <ImportDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportDecl,
                ));
                <ExportDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportNamed,
                ));
                <NamedExport as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportDefaultDecl,
                ));
                <ExportDefaultDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportDefaultExpr,
                ));
                <ExportDefaultExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportAll,
                ));
                <ExportAll as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::TsImportEquals,
                ));
                <Box<TsImportEqualsDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::TsExportAssignment,
                ));
                <TsExportAssignment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::TsNamespaceExport,
                ));
                <TsNamespaceExportDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ModuleExportName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_export_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_export_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleExportName(
                    self::fields::ModuleExportNameField::Ident,
                ));
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleExportName::Str { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleExportName(
                    self::fields::ModuleExportNameField::Str,
                ));
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ModuleItem {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_item`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_item(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleItem(
                    self::fields::ModuleItemField::ModuleDecl,
                ));
                <ModuleDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleItem(
                    self::fields::ModuleItemField::Stmt,
                ));
                <Stmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for NamedExport {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_named_export`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_named_export(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::Specifiers(usize::MAX),
                    ));
                    <Vec<ExportSpecifier> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        specifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::Src,
                    ));
                    <Option<Box<Str>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::With,
                    ));
                    <Option<Box<ObjectLit>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for NewExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_new_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_new_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::Callee));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NewExpr(
                        self::fields::NewExprField::Args(usize::MAX),
                    ));
                    <Option<Vec<ExprOrSpread>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::TypeArgs));
                    < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Null {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_null`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_null(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Null { span } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Null(self::fields::NullField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Number {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_number`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_number(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Number { span, value, raw } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Number(self::fields::NumberField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Number(self::fields::NumberField::Raw));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ObjectLit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_lit(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ObjectLit { span, props } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ObjectLit(self::fields::ObjectLitField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectLit(
                        self::fields::ObjectLitField::Props(usize::MAX),
                    ));
                    <Vec<PropOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        props,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ObjectPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ObjectPat(self::fields::ObjectPatField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPat(
                        self::fields::ObjectPatField::Props(usize::MAX),
                    ));
                    <Vec<ObjectPatProp> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        props,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPat(
                        self::fields::ObjectPatField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ObjectPatProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_pat_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPatProp(
                    self::fields::ObjectPatPropField::KeyValue,
                ));
                <KeyValuePatProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPatProp(
                    self::fields::ObjectPatPropField::Assign,
                ));
                <AssignPatProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPatProp(
                    self::fields::ObjectPatPropField::Rest,
                ));
                <RestPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for OptCall {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_call`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_call(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::Callee));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::OptCall(
                        self::fields::OptCallField::Args(usize::MAX),
                    ));
                    <Vec<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::TypeArgs));
                    < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for OptChainBase {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_chain_base`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_base(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainBase(
                    self::fields::OptChainBaseField::Member,
                ));
                <MemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            OptChainBase::Call { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainBase(
                    self::fields::OptChainBaseField::Call,
                ));
                <OptCall as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for OptChainExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_chain_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainExpr(
                        self::fields::OptChainExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainExpr(
                        self::fields::OptChainExprField::Base,
                    ));
                    <Box<OptChainBase> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        base,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Param {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_param`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Param(self::fields::ParamField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Param(
                        self::fields::ParamField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Param(self::fields::ParamField::Pat));
                    <Pat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        pat,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ParamOrTsParamProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_param_or_ts_param_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ParamOrTsParamProp(
                    self::fields::ParamOrTsParamPropField::TsParamProp,
                ));
                <TsParamProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ParamOrTsParamProp(
                    self::fields::ParamOrTsParamPropField::Param,
                ));
                <Param as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ParenExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_paren_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_paren_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ParenExpr { span, expr } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ParenExpr(self::fields::ParenExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ParenExpr(self::fields::ParenExprField::Expr));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Pat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pat(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Ident));
                <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Array { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Array));
                <ArrayPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Rest { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Rest));
                <RestPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Object { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Object));
                <ObjectPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Assign { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Assign));
                <AssignPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Invalid { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Invalid));
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Pat::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Expr));
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PrivateMethod {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_private_method`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_method(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Key,
                    ));
                    <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Function,
                    ));
                    <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Kind,
                    ));
                    <MethodKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PrivateName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_private_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            PrivateName { span, name } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateName(
                        self::fields::PrivateNameField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateName(
                        self::fields::PrivateNameField::Name,
                    ));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PrivateProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_private_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Key,
                    ));
                    <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Value,
                    ));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Accessibility,
                    ));
                    <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Program {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_program`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_program(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Program::Module { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Program(self::fields::ProgramField::Module));
                <Module as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Program::Script { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Program(self::fields::ProgramField::Script));
                <Script as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Prop {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Shorthand));
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::KeyValue { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::KeyValue));
                <KeyValueProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Assign { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Assign));
                <AssignProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Getter { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Getter));
                <GetterProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Setter { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Setter));
                <SetterProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Prop::Method { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Method));
                <MethodProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PropName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_name(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::Ident));
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::Str { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::Str));
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::Num { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::Num));
                <Number as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::PropName(
                    self::fields::PropNameField::Computed,
                ));
                <ComputedPropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropName::BigInt { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::BigInt));
                <BigInt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PropOrSpread {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop_or_spread`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spread(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::PropOrSpread(
                    self::fields::PropOrSpreadField::Spread,
                ));
                <SpreadElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::PropOrSpread(
                    self::fields::PropOrSpreadField::Prop,
                ));
                <Box<Prop> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Regex {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_regex`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_regex(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Regex { span, exp, flags } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Regex(self::fields::RegexField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Regex(self::fields::RegexField::Exp));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        exp,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Regex(self::fields::RegexField::Flags));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        flags,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for RestPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_rest_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_rest_pat(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::RestPat(self::fields::RestPatField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::RestPat(
                        self::fields::RestPatField::Dot3Token,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        dot3_token,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::RestPat(self::fields::RestPatField::Arg));
                    <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::RestPat(self::fields::RestPatField::TypeAnn));
                    <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ReturnStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_return_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_return_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ReturnStmt { span, arg } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ReturnStmt(
                        self::fields::ReturnStmtField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ReturnStmt(
                        self::fields::ReturnStmtField::Arg,
                    ));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Script {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_script`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_script(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Script(self::fields::ScriptField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Script(
                        self::fields::ScriptField::Body(usize::MAX),
                    ));
                    <Vec<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Script(self::fields::ScriptField::Shebang));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        shebang,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SeqExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_seq_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_seq_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SeqExpr { span, exprs } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::SeqExpr(self::fields::SeqExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SeqExpr(
                        self::fields::SeqExprField::Exprs(usize::MAX),
                    ));
                    <Vec<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        exprs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SetterProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_setter_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_setter_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Key,
                    ));
                    <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::ThisParam,
                    ));
                    <Option<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        this_param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Param,
                    ));
                    <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Body,
                    ));
                    <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SimpleAssignTarget {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_simple_assign_target`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_simple_assign_target(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Ident,
                ));
                <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Member,
                ));
                <MemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::SuperProp,
                ));
                <SuperPropExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Paren,
                ));
                <ParenExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::OptChain,
                ));
                <OptChainExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsAs,
                ));
                <TsAsExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsSatisfies,
                ));
                <TsSatisfiesExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsNonNull,
                ));
                <TsNonNullExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsTypeAssertion,
                ));
                <TsTypeAssertion as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsInstantiation,
                ));
                <TsInstantiation as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Invalid,
                ));
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SpreadElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_spread_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_spread_element(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SpreadElement { dot3_token, expr } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SpreadElement(
                        self::fields::SpreadElementField::Dot3Token,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        dot3_token,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SpreadElement(
                        self::fields::SpreadElementField::Expr,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for StaticBlock {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_static_block`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_static_block(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            StaticBlock { span, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::StaticBlock(
                        self::fields::StaticBlockField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::StaticBlock(
                        self::fields::StaticBlockField::Body,
                    ));
                    <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Stmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Block));
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Empty { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Empty));
                <EmptyStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Debugger { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Debugger));
                <DebuggerStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::With { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::With));
                <WithStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Return { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Return));
                <ReturnStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Labeled { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Labeled));
                <LabeledStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Break { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Break));
                <BreakStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Continue { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Continue));
                <ContinueStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::If { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::If));
                <IfStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Switch { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Switch));
                <SwitchStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Throw { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Throw));
                <ThrowStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Try { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Try));
                <Box<TryStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::While { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::While));
                <WhileStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::DoWhile { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::DoWhile));
                <DoWhileStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::For { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::For));
                <ForStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::ForIn { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::ForIn));
                <ForInStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::ForOf { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::ForOf));
                <ForOfStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Decl { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Decl));
                <Decl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Stmt::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Expr));
                <ExprStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Str {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_str`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_str(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Str { span, value, raw } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Str(self::fields::StrField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Str(self::fields::StrField::Value));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Str(self::fields::StrField::Raw));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Super {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_super`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Super { span } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Super(self::fields::SuperField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SuperProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_super_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super_prop(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperProp(
                    self::fields::SuperPropField::Ident,
                ));
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            SuperProp::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperProp(
                    self::fields::SuperPropField::Computed,
                ));
                <ComputedPropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SuperPropExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_super_prop_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super_prop_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperPropExpr(
                        self::fields::SuperPropExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperPropExpr(
                        self::fields::SuperPropExprField::Obj,
                    ));
                    <Super as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperPropExpr(
                        self::fields::SuperPropExprField::Prop,
                    ));
                    <SuperProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SwitchCase {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_switch_case`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_case(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SwitchCase { span, test, cons } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchCase(
                        self::fields::SwitchCaseField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchCase(
                        self::fields::SwitchCaseField::Test,
                    ));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchCase(
                        self::fields::SwitchCaseField::Cons(usize::MAX),
                    ));
                    <Vec<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SwitchStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_switch_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchStmt(
                        self::fields::SwitchStmtField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchStmt(
                        self::fields::SwitchStmtField::Discriminant,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        discriminant,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchStmt(
                        self::fields::SwitchStmtField::Cases(usize::MAX),
                    ));
                    <Vec<SwitchCase> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        cases,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TaggedTpl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tagged_tpl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tagged_tpl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Tag));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        tag,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TaggedTpl(
                        self::fields::TaggedTplField::TypeParams,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_params , visitor , & mut * __ast_path)
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Tpl));
                    <Box<Tpl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        tpl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ThisExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_this_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_this_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ThisExpr { span } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ThisExpr(self::fields::ThisExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ThrowStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_throw_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_throw_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ThrowStmt { span, arg } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ThrowStmt(self::fields::ThrowStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ThrowStmt(self::fields::ThrowStmtField::Arg));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Tpl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tpl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Tpl(self::fields::TplField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Tpl(
                        self::fields::TplField::Exprs(usize::MAX),
                    ));
                    <Vec<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        exprs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Tpl(
                        self::fields::TplField::Quasis(usize::MAX),
                    ));
                    <Vec<TplElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        quasis,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TplElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tpl_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_element(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TplElement(
                        self::fields::TplElementField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TplElement(
                        self::fields::TplElementField::Cooked,
                    ));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        cooked,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TplElement(
                        self::fields::TplElementField::Raw,
                    ));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TruePlusMinus {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_true_plus_minus`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_true_plus_minus(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TryStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_try_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_try_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TryStmt(self::fields::TryStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TryStmt(self::fields::TryStmtField::Block));
                    <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        block,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TryStmt(self::fields::TryStmtField::Handler));
                    <Option<CatchClause> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        handler,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TryStmt(
                        self::fields::TryStmtField::Finalizer,
                    ));
                    <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        finalizer,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UnaryExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_unary_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            UnaryExpr { span, op, arg } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UnaryExpr(self::fields::UnaryExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UnaryExpr(self::fields::UnaryExprField::Op));
                    <UnaryOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UnaryExpr(self::fields::UnaryExprField::Arg));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UnaryOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_unary_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_op(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UpdateExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_update_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::UpdateExpr(
                        self::fields::UpdateExprField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UpdateExpr(self::fields::UpdateExprField::Op));
                    <UpdateOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::UpdateExpr(
                        self::fields::UpdateExprField::Arg,
                    ));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UpdateOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_update_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_op(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UsingDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_using_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_using_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UsingDecl(self::fields::UsingDeclField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::UsingDecl(
                        self::fields::UsingDeclField::Decls(usize::MAX),
                    ));
                    <Vec<VarDeclarator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decls,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::VarDecl(self::fields::VarDeclField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::VarDecl(self::fields::VarDeclField::Ctxt));
                    <swc_common::SyntaxContext as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::VarDecl(self::fields::VarDeclField::Kind));
                    <VarDeclKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDecl(
                        self::fields::VarDeclField::Decls(usize::MAX),
                    ));
                    <Vec<VarDeclarator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        decls,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDeclKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_decl_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDeclOrExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_decl_or_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl_or_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclOrExpr(
                    self::fields::VarDeclOrExprField::VarDecl,
                ));
                <Box<VarDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclOrExpr(
                    self::fields::VarDeclOrExprField::Expr,
                ));
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDeclarator {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_declarator`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_declarator(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclarator(
                        self::fields::VarDeclaratorField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclarator(
                        self::fields::VarDeclaratorField::Name,
                    ));
                    <Pat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclarator(
                        self::fields::VarDeclaratorField::Init,
                    ));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        init,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for WhileStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_while_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_while_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            WhileStmt { span, test, body } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WhileStmt(self::fields::WhileStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WhileStmt(self::fields::WhileStmtField::Test));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WhileStmt(self::fields::WhileStmtField::Body));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for WithStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_with_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_with_stmt(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            WithStmt { span, obj, body } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WithStmt(self::fields::WithStmtField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WithStmt(self::fields::WithStmtField::Obj));
                    <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WithStmt(self::fields::WithStmtField::Body));
                    <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for YieldExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_yield_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_yield_expr(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::YieldExpr(self::fields::YieldExprField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::YieldExpr(self::fields::YieldExprField::Arg));
                    <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BigIntValue {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_big_int_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int_value(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ClassMember> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_members`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_members(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ClassMember as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Decorator> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_decorators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorators(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Decorator as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_specifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ExportSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ExprOrSpread as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Box<Expr>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_exprs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_exprs(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_specifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ImportSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ImportWithItem> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_with_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with_items(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ImportWithItem as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <JSXAttrOrSpread as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<JSXElementChild> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element_childs`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_childs(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <JSXElementChild as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ModuleItem> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_items`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_items(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ModuleItem as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_pat_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat_props(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ObjectPatProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<BlockStmt> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_block_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_block_stmt(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<CatchClause> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_catch_clause`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_catch_clause(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <CatchClause as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<Expr>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<ExprOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_expr_or_spread`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spread(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <ExprOrSpread as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Vec<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Ident> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ident`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ident(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<JSXAttrValue> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_attr_value(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <JSXAttrValue as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<JSXClosingElement> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_closing_element(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <JSXClosingElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<ModuleExportName> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_module_export_name`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_module_export_name(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <ModuleExportName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_object_lit`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_object_lit(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Box<ObjectLit> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Pat> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_pat`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_pat(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Pat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<swc_common::Span> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_span(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<Stmt>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_stmt(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<Str>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_str`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_str(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Box<Str> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_var_decl_or_expr(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <VarDeclOrExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Option<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Option<Pat>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_vec_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_pats(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Option<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_param_or_ts_param_props`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_props(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ParamOrTsParamProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Param> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_params`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_params(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Param as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Pat> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pats(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Pat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<PropOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <PropOrSpread as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_span(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Stmt> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_stmts`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmts(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Stmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<SwitchCase> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_switch_cases`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_cases(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <SwitchCase as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_common::SyntaxContext {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_syntax_context`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_syntax_context(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TplElement> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tpl_elements`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_elements(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <TplElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<VarDeclarator> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_declarators`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_declarators(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <VarDeclarator as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitMutWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitMutAstPath,
    T: VisitMutWithAstPath<V>,
{
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        let v = <T as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
            &mut **self,
            visitor,
            __ast_path,
        );
        v
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        let v = <T as VisitMutWithAstPath<V>>::visit_mut_children_with_ast_path(
            &mut **self,
            visitor,
            __ast_path,
        );
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
pub trait Fold {
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        <ArrayLit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        <ArrayPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        <ArrowExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        <AssignExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        <AssignOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        <AssignPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        <AssignPatProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        <AssignProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        <AssignTarget as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        <AssignTargetPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        <swc_atoms::Atom as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        <AutoAccessor as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        <AwaitExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        <BigInt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        <BigIntValue as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        <BinExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        <BinaryOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        <BindingIdent as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        <BlockStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        <BlockStmtOrExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_bool(&mut self, node: Bool) -> Bool {
        <Bool as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        <BreakStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        <CallExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_callee(&mut self, node: Callee) -> Callee {
        <Callee as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        <CatchClause as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_class(&mut self, node: Class) -> Class {
        <Class as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        <ClassDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        <ClassExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        <ClassMember as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        <Vec<ClassMember> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        <ClassMethod as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        <ClassProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        <ComputedPropName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        <CondExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        <Constructor as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        <ContinueStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        <DebuggerStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_decl(&mut self, node: Decl) -> Decl {
        <Decl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        <Decorator as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        <Vec<Decorator> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        <DefaultDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        <DoWhileStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        <EmptyStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        <ExportAll as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        <ExportDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        <ExportDefaultDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        <ExportDefaultExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        <ExportDefaultSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        <ExportNamedSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        <ExportNamespaceSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        <ExportSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        <Vec<ExportSpecifier> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_expr(&mut self, node: Expr) -> Expr {
        <Expr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        <ExprOrSpread as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        <Vec<ExprOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        <ExprStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        <Vec<Box<Expr>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        <FnDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        <FnExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        <ForHead as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        <ForInStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        <ForOfStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        <ForStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_function(&mut self, node: Function) -> Function {
        <Function as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        <GetterProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_ident(&mut self, node: Ident) -> Ident {
        <Ident as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        <IdentName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        <IfStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_import(&mut self, node: Import) -> Import {
        <Import as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        <ImportDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        <ImportDefaultSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        <ImportNamedSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        <ImportPhase as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        <ImportSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        <Vec<ImportSpecifier> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        <ImportStarAsSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        <ImportWith as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        <ImportWithItem as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        <Vec<ImportWithItem> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        <Invalid as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        <JSXAttr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        <JSXAttrName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        <JSXAttrOrSpread as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        <Vec<JSXAttrOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        <JSXAttrValue as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        <JSXClosingElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        <JSXClosingFragment as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        <JSXElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        <JSXElementChild as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        <Vec<JSXElementChild> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        <JSXElementName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        <JSXEmptyExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        <JSXExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        <JSXExprContainer as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        <JSXFragment as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        <JSXMemberExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        <JSXNamespacedName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        <JSXObject as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        <JSXOpeningElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        <JSXOpeningFragment as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        <JSXSpreadChild as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        <JSXText as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_key(&mut self, node: Key) -> Key {
        <Key as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        <KeyValuePatProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        <KeyValueProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        <LabeledStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_lit(&mut self, node: Lit) -> Lit {
        <Lit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        <MemberExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        <MemberProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        <MetaPropExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        <MetaPropKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        <MethodKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        <MethodProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_module(&mut self, node: Module) -> Module {
        <Module as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        <ModuleDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        <ModuleExportName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        <ModuleItem as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        <Vec<ModuleItem> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        <NamedExport as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        <NewExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_null(&mut self, node: Null) -> Null {
        <Null as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_number(&mut self, node: Number) -> Number {
        <Number as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        <ObjectLit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        <ObjectPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        <ObjectPatProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        <Vec<ObjectPatProp> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        <Option<swc_atoms::Atom> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        <Option<BlockStmt> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        <OptCall as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        <Option<CatchClause> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        <OptChainBase as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        <OptChainExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        <Option<Box<Expr>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        <Option<ExprOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::fold_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        <Option<Vec<ExprOrSpread>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        <Option<Ident> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        <Option<JSXAttrValue> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        <Option<JSXClosingElement> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        <Option<ModuleExportName> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        <Option<Box<ObjectLit>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        <Option<Pat> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::fold_children_with`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        <Option<swc_common::Span> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        <Option<Box<Stmt>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        <Option<Box<Str>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        <Option<VarDeclOrExpr> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::fold_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        <Vec<Option<ExprOrSpread>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        <Vec<Option<Pat>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_param(&mut self, node: Param) -> Param {
        <Param as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        <ParamOrTsParamProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        <Vec<ParamOrTsParamProp> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        <Vec<Param> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        <ParenExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_pat(&mut self, node: Pat) -> Pat {
        <Pat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        <Vec<Pat> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        <PrivateMethod as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        <PrivateName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        <PrivateProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_program(&mut self, node: Program) -> Program {
        <Program as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_prop(&mut self, node: Prop) -> Prop {
        <Prop as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        <PropName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        <PropOrSpread as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        <Vec<PropOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_regex(&mut self, node: Regex) -> Regex {
        <Regex as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        <RestPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        <ReturnStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_script(&mut self, node: Script) -> Script {
        <Script as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        <SeqExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        <SetterProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        <SimpleAssignTarget as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        <swc_common::Span as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        <SpreadElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        <StaticBlock as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        <Stmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        <Vec<Stmt> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_str(&mut self, node: Str) -> Str {
        <Str as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_super(&mut self, node: Super) -> Super {
        <Super as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        <SuperProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        <SuperPropExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        <SwitchCase as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        <Vec<SwitchCase> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        <SwitchStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        <swc_common::SyntaxContext as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        <TaggedTpl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        <ThisExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        <ThrowStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        <Tpl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        <TplElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        <Vec<TplElement> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        <TruePlusMinus as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        <TryStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        <UnaryExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        <UnaryOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        <UpdateExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        <UpdateOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        <UsingDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        <VarDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        <VarDeclKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        <VarDeclOrExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        <VarDeclarator as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        <Vec<VarDeclarator> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        <WhileStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        <WithStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        <YieldExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
}
impl<V> Fold for &mut V
where
    V: ?Sized + Fold,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        <V as Fold>::fold_array_lit(&mut **self, node)
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        <V as Fold>::fold_array_pat(&mut **self, node)
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        <V as Fold>::fold_arrow_expr(&mut **self, node)
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        <V as Fold>::fold_assign_expr(&mut **self, node)
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        <V as Fold>::fold_assign_op(&mut **self, node)
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        <V as Fold>::fold_assign_pat(&mut **self, node)
    }

    #[inline]
    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        <V as Fold>::fold_assign_pat_prop(&mut **self, node)
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        <V as Fold>::fold_assign_prop(&mut **self, node)
    }

    #[inline]
    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        <V as Fold>::fold_assign_target(&mut **self, node)
    }

    #[inline]
    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        <V as Fold>::fold_assign_target_pat(&mut **self, node)
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        <V as Fold>::fold_atom(&mut **self, node)
    }

    #[inline]
    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        <V as Fold>::fold_auto_accessor(&mut **self, node)
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        <V as Fold>::fold_await_expr(&mut **self, node)
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        <V as Fold>::fold_big_int(&mut **self, node)
    }

    #[inline]
    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        <V as Fold>::fold_big_int_value(&mut **self, node)
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        <V as Fold>::fold_bin_expr(&mut **self, node)
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        <V as Fold>::fold_binary_op(&mut **self, node)
    }

    #[inline]
    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        <V as Fold>::fold_binding_ident(&mut **self, node)
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        <V as Fold>::fold_block_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        <V as Fold>::fold_block_stmt_or_expr(&mut **self, node)
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool) -> Bool {
        <V as Fold>::fold_bool(&mut **self, node)
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        <V as Fold>::fold_break_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        <V as Fold>::fold_call_expr(&mut **self, node)
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee) -> Callee {
        <V as Fold>::fold_callee(&mut **self, node)
    }

    #[inline]
    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        <V as Fold>::fold_catch_clause(&mut **self, node)
    }

    #[inline]
    fn fold_class(&mut self, node: Class) -> Class {
        <V as Fold>::fold_class(&mut **self, node)
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        <V as Fold>::fold_class_decl(&mut **self, node)
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        <V as Fold>::fold_class_expr(&mut **self, node)
    }

    #[inline]
    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        <V as Fold>::fold_class_member(&mut **self, node)
    }

    #[inline]
    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        <V as Fold>::fold_class_members(&mut **self, node)
    }

    #[inline]
    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        <V as Fold>::fold_class_method(&mut **self, node)
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        <V as Fold>::fold_class_prop(&mut **self, node)
    }

    #[inline]
    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        <V as Fold>::fold_computed_prop_name(&mut **self, node)
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        <V as Fold>::fold_cond_expr(&mut **self, node)
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        <V as Fold>::fold_constructor(&mut **self, node)
    }

    #[inline]
    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        <V as Fold>::fold_continue_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        <V as Fold>::fold_debugger_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl) -> Decl {
        <V as Fold>::fold_decl(&mut **self, node)
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        <V as Fold>::fold_decorator(&mut **self, node)
    }

    #[inline]
    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        <V as Fold>::fold_decorators(&mut **self, node)
    }

    #[inline]
    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        <V as Fold>::fold_default_decl(&mut **self, node)
    }

    #[inline]
    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        <V as Fold>::fold_do_while_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        <V as Fold>::fold_empty_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        <V as Fold>::fold_export_all(&mut **self, node)
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        <V as Fold>::fold_export_decl(&mut **self, node)
    }

    #[inline]
    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        <V as Fold>::fold_export_default_decl(&mut **self, node)
    }

    #[inline]
    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        <V as Fold>::fold_export_default_expr(&mut **self, node)
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        <V as Fold>::fold_export_default_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        <V as Fold>::fold_export_named_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        <V as Fold>::fold_export_namespace_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        <V as Fold>::fold_export_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        <V as Fold>::fold_export_specifiers(&mut **self, node)
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr) -> Expr {
        <V as Fold>::fold_expr(&mut **self, node)
    }

    #[inline]
    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        <V as Fold>::fold_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        <V as Fold>::fold_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        <V as Fold>::fold_expr_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        <V as Fold>::fold_exprs(&mut **self, node)
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        <V as Fold>::fold_fn_decl(&mut **self, node)
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        <V as Fold>::fold_fn_expr(&mut **self, node)
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        <V as Fold>::fold_for_head(&mut **self, node)
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        <V as Fold>::fold_for_in_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        <V as Fold>::fold_for_of_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        <V as Fold>::fold_for_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_function(&mut self, node: Function) -> Function {
        <V as Fold>::fold_function(&mut **self, node)
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        <V as Fold>::fold_getter_prop(&mut **self, node)
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident) -> Ident {
        <V as Fold>::fold_ident(&mut **self, node)
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        <V as Fold>::fold_ident_name(&mut **self, node)
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        <V as Fold>::fold_if_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_import(&mut self, node: Import) -> Import {
        <V as Fold>::fold_import(&mut **self, node)
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        <V as Fold>::fold_import_decl(&mut **self, node)
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        <V as Fold>::fold_import_default_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        <V as Fold>::fold_import_named_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        <V as Fold>::fold_import_phase(&mut **self, node)
    }

    #[inline]
    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        <V as Fold>::fold_import_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        <V as Fold>::fold_import_specifiers(&mut **self, node)
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        <V as Fold>::fold_import_star_as_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        <V as Fold>::fold_import_with(&mut **self, node)
    }

    #[inline]
    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        <V as Fold>::fold_import_with_item(&mut **self, node)
    }

    #[inline]
    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        <V as Fold>::fold_import_with_items(&mut **self, node)
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        <V as Fold>::fold_invalid(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        <V as Fold>::fold_jsx_attr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        <V as Fold>::fold_jsx_attr_name(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        <V as Fold>::fold_jsx_attr_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        <V as Fold>::fold_jsx_attr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        <V as Fold>::fold_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        <V as Fold>::fold_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        <V as Fold>::fold_jsx_closing_fragment(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        <V as Fold>::fold_jsx_element(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        <V as Fold>::fold_jsx_element_child(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        <V as Fold>::fold_jsx_element_childs(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        <V as Fold>::fold_jsx_element_name(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        <V as Fold>::fold_jsx_empty_expr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        <V as Fold>::fold_jsx_expr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        <V as Fold>::fold_jsx_expr_container(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        <V as Fold>::fold_jsx_fragment(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        <V as Fold>::fold_jsx_member_expr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        <V as Fold>::fold_jsx_namespaced_name(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        <V as Fold>::fold_jsx_object(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        <V as Fold>::fold_jsx_opening_element(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        <V as Fold>::fold_jsx_opening_fragment(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        <V as Fold>::fold_jsx_spread_child(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        <V as Fold>::fold_jsx_text(&mut **self, node)
    }

    #[inline]
    fn fold_key(&mut self, node: Key) -> Key {
        <V as Fold>::fold_key(&mut **self, node)
    }

    #[inline]
    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        <V as Fold>::fold_key_value_pat_prop(&mut **self, node)
    }

    #[inline]
    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        <V as Fold>::fold_key_value_prop(&mut **self, node)
    }

    #[inline]
    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        <V as Fold>::fold_labeled_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit) -> Lit {
        <V as Fold>::fold_lit(&mut **self, node)
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        <V as Fold>::fold_member_expr(&mut **self, node)
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        <V as Fold>::fold_member_prop(&mut **self, node)
    }

    #[inline]
    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        <V as Fold>::fold_meta_prop_expr(&mut **self, node)
    }

    #[inline]
    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        <V as Fold>::fold_meta_prop_kind(&mut **self, node)
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        <V as Fold>::fold_method_kind(&mut **self, node)
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        <V as Fold>::fold_method_prop(&mut **self, node)
    }

    #[inline]
    fn fold_module(&mut self, node: Module) -> Module {
        <V as Fold>::fold_module(&mut **self, node)
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        <V as Fold>::fold_module_decl(&mut **self, node)
    }

    #[inline]
    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        <V as Fold>::fold_module_export_name(&mut **self, node)
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        <V as Fold>::fold_module_item(&mut **self, node)
    }

    #[inline]
    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        <V as Fold>::fold_module_items(&mut **self, node)
    }

    #[inline]
    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        <V as Fold>::fold_named_export(&mut **self, node)
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        <V as Fold>::fold_new_expr(&mut **self, node)
    }

    #[inline]
    fn fold_null(&mut self, node: Null) -> Null {
        <V as Fold>::fold_null(&mut **self, node)
    }

    #[inline]
    fn fold_number(&mut self, node: Number) -> Number {
        <V as Fold>::fold_number(&mut **self, node)
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        <V as Fold>::fold_object_lit(&mut **self, node)
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        <V as Fold>::fold_object_pat(&mut **self, node)
    }

    #[inline]
    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        <V as Fold>::fold_object_pat_prop(&mut **self, node)
    }

    #[inline]
    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        <V as Fold>::fold_object_pat_props(&mut **self, node)
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        <V as Fold>::fold_opt_atom(&mut **self, node)
    }

    #[inline]
    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        <V as Fold>::fold_opt_block_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        <V as Fold>::fold_opt_call(&mut **self, node)
    }

    #[inline]
    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        <V as Fold>::fold_opt_catch_clause(&mut **self, node)
    }

    #[inline]
    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        <V as Fold>::fold_opt_chain_base(&mut **self, node)
    }

    #[inline]
    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        <V as Fold>::fold_opt_chain_expr(&mut **self, node)
    }

    #[inline]
    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        <V as Fold>::fold_opt_expr(&mut **self, node)
    }

    #[inline]
    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        <V as Fold>::fold_opt_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        <V as Fold>::fold_opt_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        <V as Fold>::fold_opt_ident(&mut **self, node)
    }

    #[inline]
    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        <V as Fold>::fold_opt_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        <V as Fold>::fold_opt_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        <V as Fold>::fold_opt_module_export_name(&mut **self, node)
    }

    #[inline]
    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        <V as Fold>::fold_opt_object_lit(&mut **self, node)
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        <V as Fold>::fold_opt_pat(&mut **self, node)
    }

    #[inline]
    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        <V as Fold>::fold_opt_span(&mut **self, node)
    }

    #[inline]
    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        <V as Fold>::fold_opt_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        <V as Fold>::fold_opt_str(&mut **self, node)
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        <V as Fold>::fold_opt_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        <V as Fold>::fold_opt_vec_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        <V as Fold>::fold_opt_vec_pats(&mut **self, node)
    }

    #[inline]
    fn fold_param(&mut self, node: Param) -> Param {
        <V as Fold>::fold_param(&mut **self, node)
    }

    #[inline]
    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        <V as Fold>::fold_param_or_ts_param_prop(&mut **self, node)
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        <V as Fold>::fold_param_or_ts_param_props(&mut **self, node)
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        <V as Fold>::fold_params(&mut **self, node)
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        <V as Fold>::fold_paren_expr(&mut **self, node)
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat) -> Pat {
        <V as Fold>::fold_pat(&mut **self, node)
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        <V as Fold>::fold_pats(&mut **self, node)
    }

    #[inline]
    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        <V as Fold>::fold_private_method(&mut **self, node)
    }

    #[inline]
    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        <V as Fold>::fold_private_name(&mut **self, node)
    }

    #[inline]
    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        <V as Fold>::fold_private_prop(&mut **self, node)
    }

    #[inline]
    fn fold_program(&mut self, node: Program) -> Program {
        <V as Fold>::fold_program(&mut **self, node)
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop) -> Prop {
        <V as Fold>::fold_prop(&mut **self, node)
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        <V as Fold>::fold_prop_name(&mut **self, node)
    }

    #[inline]
    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        <V as Fold>::fold_prop_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        <V as Fold>::fold_prop_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex) -> Regex {
        <V as Fold>::fold_regex(&mut **self, node)
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        <V as Fold>::fold_rest_pat(&mut **self, node)
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        <V as Fold>::fold_return_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_script(&mut self, node: Script) -> Script {
        <V as Fold>::fold_script(&mut **self, node)
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        <V as Fold>::fold_seq_expr(&mut **self, node)
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        <V as Fold>::fold_setter_prop(&mut **self, node)
    }

    #[inline]
    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        <V as Fold>::fold_simple_assign_target(&mut **self, node)
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        <V as Fold>::fold_span(&mut **self, node)
    }

    #[inline]
    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        <V as Fold>::fold_spread_element(&mut **self, node)
    }

    #[inline]
    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        <V as Fold>::fold_static_block(&mut **self, node)
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        <V as Fold>::fold_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        <V as Fold>::fold_stmts(&mut **self, node)
    }

    #[inline]
    fn fold_str(&mut self, node: Str) -> Str {
        <V as Fold>::fold_str(&mut **self, node)
    }

    #[inline]
    fn fold_super(&mut self, node: Super) -> Super {
        <V as Fold>::fold_super(&mut **self, node)
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        <V as Fold>::fold_super_prop(&mut **self, node)
    }

    #[inline]
    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        <V as Fold>::fold_super_prop_expr(&mut **self, node)
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        <V as Fold>::fold_switch_case(&mut **self, node)
    }

    #[inline]
    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        <V as Fold>::fold_switch_cases(&mut **self, node)
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        <V as Fold>::fold_switch_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        <V as Fold>::fold_syntax_context(&mut **self, node)
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        <V as Fold>::fold_tagged_tpl(&mut **self, node)
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        <V as Fold>::fold_this_expr(&mut **self, node)
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        <V as Fold>::fold_throw_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        <V as Fold>::fold_tpl(&mut **self, node)
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        <V as Fold>::fold_tpl_element(&mut **self, node)
    }

    #[inline]
    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        <V as Fold>::fold_tpl_elements(&mut **self, node)
    }

    #[inline]
    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        <V as Fold>::fold_true_plus_minus(&mut **self, node)
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        <V as Fold>::fold_try_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        <V as Fold>::fold_unary_expr(&mut **self, node)
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        <V as Fold>::fold_unary_op(&mut **self, node)
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        <V as Fold>::fold_update_expr(&mut **self, node)
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        <V as Fold>::fold_update_op(&mut **self, node)
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        <V as Fold>::fold_using_decl(&mut **self, node)
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        <V as Fold>::fold_var_decl(&mut **self, node)
    }

    #[inline]
    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        <V as Fold>::fold_var_decl_kind(&mut **self, node)
    }

    #[inline]
    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        <V as Fold>::fold_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        <V as Fold>::fold_var_declarator(&mut **self, node)
    }

    #[inline]
    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        <V as Fold>::fold_var_declarators(&mut **self, node)
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        <V as Fold>::fold_while_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        <V as Fold>::fold_with_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        <V as Fold>::fold_yield_expr(&mut **self, node)
    }
}
impl<V> Fold for Box<V>
where
    V: ?Sized + Fold,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        <V as Fold>::fold_array_lit(&mut **self, node)
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        <V as Fold>::fold_array_pat(&mut **self, node)
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        <V as Fold>::fold_arrow_expr(&mut **self, node)
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        <V as Fold>::fold_assign_expr(&mut **self, node)
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        <V as Fold>::fold_assign_op(&mut **self, node)
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        <V as Fold>::fold_assign_pat(&mut **self, node)
    }

    #[inline]
    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        <V as Fold>::fold_assign_pat_prop(&mut **self, node)
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        <V as Fold>::fold_assign_prop(&mut **self, node)
    }

    #[inline]
    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        <V as Fold>::fold_assign_target(&mut **self, node)
    }

    #[inline]
    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        <V as Fold>::fold_assign_target_pat(&mut **self, node)
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        <V as Fold>::fold_atom(&mut **self, node)
    }

    #[inline]
    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        <V as Fold>::fold_auto_accessor(&mut **self, node)
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        <V as Fold>::fold_await_expr(&mut **self, node)
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        <V as Fold>::fold_big_int(&mut **self, node)
    }

    #[inline]
    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        <V as Fold>::fold_big_int_value(&mut **self, node)
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        <V as Fold>::fold_bin_expr(&mut **self, node)
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        <V as Fold>::fold_binary_op(&mut **self, node)
    }

    #[inline]
    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        <V as Fold>::fold_binding_ident(&mut **self, node)
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        <V as Fold>::fold_block_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        <V as Fold>::fold_block_stmt_or_expr(&mut **self, node)
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool) -> Bool {
        <V as Fold>::fold_bool(&mut **self, node)
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        <V as Fold>::fold_break_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        <V as Fold>::fold_call_expr(&mut **self, node)
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee) -> Callee {
        <V as Fold>::fold_callee(&mut **self, node)
    }

    #[inline]
    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        <V as Fold>::fold_catch_clause(&mut **self, node)
    }

    #[inline]
    fn fold_class(&mut self, node: Class) -> Class {
        <V as Fold>::fold_class(&mut **self, node)
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        <V as Fold>::fold_class_decl(&mut **self, node)
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        <V as Fold>::fold_class_expr(&mut **self, node)
    }

    #[inline]
    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        <V as Fold>::fold_class_member(&mut **self, node)
    }

    #[inline]
    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        <V as Fold>::fold_class_members(&mut **self, node)
    }

    #[inline]
    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        <V as Fold>::fold_class_method(&mut **self, node)
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        <V as Fold>::fold_class_prop(&mut **self, node)
    }

    #[inline]
    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        <V as Fold>::fold_computed_prop_name(&mut **self, node)
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        <V as Fold>::fold_cond_expr(&mut **self, node)
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        <V as Fold>::fold_constructor(&mut **self, node)
    }

    #[inline]
    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        <V as Fold>::fold_continue_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        <V as Fold>::fold_debugger_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl) -> Decl {
        <V as Fold>::fold_decl(&mut **self, node)
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        <V as Fold>::fold_decorator(&mut **self, node)
    }

    #[inline]
    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        <V as Fold>::fold_decorators(&mut **self, node)
    }

    #[inline]
    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        <V as Fold>::fold_default_decl(&mut **self, node)
    }

    #[inline]
    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        <V as Fold>::fold_do_while_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        <V as Fold>::fold_empty_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        <V as Fold>::fold_export_all(&mut **self, node)
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        <V as Fold>::fold_export_decl(&mut **self, node)
    }

    #[inline]
    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        <V as Fold>::fold_export_default_decl(&mut **self, node)
    }

    #[inline]
    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        <V as Fold>::fold_export_default_expr(&mut **self, node)
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        <V as Fold>::fold_export_default_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        <V as Fold>::fold_export_named_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        <V as Fold>::fold_export_namespace_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        <V as Fold>::fold_export_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        <V as Fold>::fold_export_specifiers(&mut **self, node)
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr) -> Expr {
        <V as Fold>::fold_expr(&mut **self, node)
    }

    #[inline]
    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        <V as Fold>::fold_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        <V as Fold>::fold_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        <V as Fold>::fold_expr_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        <V as Fold>::fold_exprs(&mut **self, node)
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        <V as Fold>::fold_fn_decl(&mut **self, node)
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        <V as Fold>::fold_fn_expr(&mut **self, node)
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        <V as Fold>::fold_for_head(&mut **self, node)
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        <V as Fold>::fold_for_in_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        <V as Fold>::fold_for_of_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        <V as Fold>::fold_for_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_function(&mut self, node: Function) -> Function {
        <V as Fold>::fold_function(&mut **self, node)
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        <V as Fold>::fold_getter_prop(&mut **self, node)
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident) -> Ident {
        <V as Fold>::fold_ident(&mut **self, node)
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        <V as Fold>::fold_ident_name(&mut **self, node)
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        <V as Fold>::fold_if_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_import(&mut self, node: Import) -> Import {
        <V as Fold>::fold_import(&mut **self, node)
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        <V as Fold>::fold_import_decl(&mut **self, node)
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        <V as Fold>::fold_import_default_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        <V as Fold>::fold_import_named_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        <V as Fold>::fold_import_phase(&mut **self, node)
    }

    #[inline]
    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        <V as Fold>::fold_import_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        <V as Fold>::fold_import_specifiers(&mut **self, node)
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        <V as Fold>::fold_import_star_as_specifier(&mut **self, node)
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        <V as Fold>::fold_import_with(&mut **self, node)
    }

    #[inline]
    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        <V as Fold>::fold_import_with_item(&mut **self, node)
    }

    #[inline]
    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        <V as Fold>::fold_import_with_items(&mut **self, node)
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        <V as Fold>::fold_invalid(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        <V as Fold>::fold_jsx_attr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        <V as Fold>::fold_jsx_attr_name(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        <V as Fold>::fold_jsx_attr_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        <V as Fold>::fold_jsx_attr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        <V as Fold>::fold_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        <V as Fold>::fold_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        <V as Fold>::fold_jsx_closing_fragment(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        <V as Fold>::fold_jsx_element(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        <V as Fold>::fold_jsx_element_child(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        <V as Fold>::fold_jsx_element_childs(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        <V as Fold>::fold_jsx_element_name(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        <V as Fold>::fold_jsx_empty_expr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        <V as Fold>::fold_jsx_expr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        <V as Fold>::fold_jsx_expr_container(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        <V as Fold>::fold_jsx_fragment(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        <V as Fold>::fold_jsx_member_expr(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        <V as Fold>::fold_jsx_namespaced_name(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        <V as Fold>::fold_jsx_object(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        <V as Fold>::fold_jsx_opening_element(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        <V as Fold>::fold_jsx_opening_fragment(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        <V as Fold>::fold_jsx_spread_child(&mut **self, node)
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        <V as Fold>::fold_jsx_text(&mut **self, node)
    }

    #[inline]
    fn fold_key(&mut self, node: Key) -> Key {
        <V as Fold>::fold_key(&mut **self, node)
    }

    #[inline]
    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        <V as Fold>::fold_key_value_pat_prop(&mut **self, node)
    }

    #[inline]
    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        <V as Fold>::fold_key_value_prop(&mut **self, node)
    }

    #[inline]
    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        <V as Fold>::fold_labeled_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit) -> Lit {
        <V as Fold>::fold_lit(&mut **self, node)
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        <V as Fold>::fold_member_expr(&mut **self, node)
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        <V as Fold>::fold_member_prop(&mut **self, node)
    }

    #[inline]
    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        <V as Fold>::fold_meta_prop_expr(&mut **self, node)
    }

    #[inline]
    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        <V as Fold>::fold_meta_prop_kind(&mut **self, node)
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        <V as Fold>::fold_method_kind(&mut **self, node)
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        <V as Fold>::fold_method_prop(&mut **self, node)
    }

    #[inline]
    fn fold_module(&mut self, node: Module) -> Module {
        <V as Fold>::fold_module(&mut **self, node)
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        <V as Fold>::fold_module_decl(&mut **self, node)
    }

    #[inline]
    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        <V as Fold>::fold_module_export_name(&mut **self, node)
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        <V as Fold>::fold_module_item(&mut **self, node)
    }

    #[inline]
    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        <V as Fold>::fold_module_items(&mut **self, node)
    }

    #[inline]
    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        <V as Fold>::fold_named_export(&mut **self, node)
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        <V as Fold>::fold_new_expr(&mut **self, node)
    }

    #[inline]
    fn fold_null(&mut self, node: Null) -> Null {
        <V as Fold>::fold_null(&mut **self, node)
    }

    #[inline]
    fn fold_number(&mut self, node: Number) -> Number {
        <V as Fold>::fold_number(&mut **self, node)
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        <V as Fold>::fold_object_lit(&mut **self, node)
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        <V as Fold>::fold_object_pat(&mut **self, node)
    }

    #[inline]
    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        <V as Fold>::fold_object_pat_prop(&mut **self, node)
    }

    #[inline]
    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        <V as Fold>::fold_object_pat_props(&mut **self, node)
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        <V as Fold>::fold_opt_atom(&mut **self, node)
    }

    #[inline]
    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        <V as Fold>::fold_opt_block_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        <V as Fold>::fold_opt_call(&mut **self, node)
    }

    #[inline]
    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        <V as Fold>::fold_opt_catch_clause(&mut **self, node)
    }

    #[inline]
    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        <V as Fold>::fold_opt_chain_base(&mut **self, node)
    }

    #[inline]
    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        <V as Fold>::fold_opt_chain_expr(&mut **self, node)
    }

    #[inline]
    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        <V as Fold>::fold_opt_expr(&mut **self, node)
    }

    #[inline]
    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        <V as Fold>::fold_opt_expr_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        <V as Fold>::fold_opt_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        <V as Fold>::fold_opt_ident(&mut **self, node)
    }

    #[inline]
    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        <V as Fold>::fold_opt_jsx_attr_value(&mut **self, node)
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        <V as Fold>::fold_opt_jsx_closing_element(&mut **self, node)
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        <V as Fold>::fold_opt_module_export_name(&mut **self, node)
    }

    #[inline]
    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        <V as Fold>::fold_opt_object_lit(&mut **self, node)
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        <V as Fold>::fold_opt_pat(&mut **self, node)
    }

    #[inline]
    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        <V as Fold>::fold_opt_span(&mut **self, node)
    }

    #[inline]
    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        <V as Fold>::fold_opt_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        <V as Fold>::fold_opt_str(&mut **self, node)
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        <V as Fold>::fold_opt_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        <V as Fold>::fold_opt_vec_expr_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        <V as Fold>::fold_opt_vec_pats(&mut **self, node)
    }

    #[inline]
    fn fold_param(&mut self, node: Param) -> Param {
        <V as Fold>::fold_param(&mut **self, node)
    }

    #[inline]
    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        <V as Fold>::fold_param_or_ts_param_prop(&mut **self, node)
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        <V as Fold>::fold_param_or_ts_param_props(&mut **self, node)
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        <V as Fold>::fold_params(&mut **self, node)
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        <V as Fold>::fold_paren_expr(&mut **self, node)
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat) -> Pat {
        <V as Fold>::fold_pat(&mut **self, node)
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        <V as Fold>::fold_pats(&mut **self, node)
    }

    #[inline]
    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        <V as Fold>::fold_private_method(&mut **self, node)
    }

    #[inline]
    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        <V as Fold>::fold_private_name(&mut **self, node)
    }

    #[inline]
    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        <V as Fold>::fold_private_prop(&mut **self, node)
    }

    #[inline]
    fn fold_program(&mut self, node: Program) -> Program {
        <V as Fold>::fold_program(&mut **self, node)
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop) -> Prop {
        <V as Fold>::fold_prop(&mut **self, node)
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        <V as Fold>::fold_prop_name(&mut **self, node)
    }

    #[inline]
    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        <V as Fold>::fold_prop_or_spread(&mut **self, node)
    }

    #[inline]
    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        <V as Fold>::fold_prop_or_spreads(&mut **self, node)
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex) -> Regex {
        <V as Fold>::fold_regex(&mut **self, node)
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        <V as Fold>::fold_rest_pat(&mut **self, node)
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        <V as Fold>::fold_return_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_script(&mut self, node: Script) -> Script {
        <V as Fold>::fold_script(&mut **self, node)
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        <V as Fold>::fold_seq_expr(&mut **self, node)
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        <V as Fold>::fold_setter_prop(&mut **self, node)
    }

    #[inline]
    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        <V as Fold>::fold_simple_assign_target(&mut **self, node)
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        <V as Fold>::fold_span(&mut **self, node)
    }

    #[inline]
    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        <V as Fold>::fold_spread_element(&mut **self, node)
    }

    #[inline]
    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        <V as Fold>::fold_static_block(&mut **self, node)
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        <V as Fold>::fold_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        <V as Fold>::fold_stmts(&mut **self, node)
    }

    #[inline]
    fn fold_str(&mut self, node: Str) -> Str {
        <V as Fold>::fold_str(&mut **self, node)
    }

    #[inline]
    fn fold_super(&mut self, node: Super) -> Super {
        <V as Fold>::fold_super(&mut **self, node)
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        <V as Fold>::fold_super_prop(&mut **self, node)
    }

    #[inline]
    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        <V as Fold>::fold_super_prop_expr(&mut **self, node)
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        <V as Fold>::fold_switch_case(&mut **self, node)
    }

    #[inline]
    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        <V as Fold>::fold_switch_cases(&mut **self, node)
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        <V as Fold>::fold_switch_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        <V as Fold>::fold_syntax_context(&mut **self, node)
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        <V as Fold>::fold_tagged_tpl(&mut **self, node)
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        <V as Fold>::fold_this_expr(&mut **self, node)
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        <V as Fold>::fold_throw_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        <V as Fold>::fold_tpl(&mut **self, node)
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        <V as Fold>::fold_tpl_element(&mut **self, node)
    }

    #[inline]
    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        <V as Fold>::fold_tpl_elements(&mut **self, node)
    }

    #[inline]
    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        <V as Fold>::fold_true_plus_minus(&mut **self, node)
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        <V as Fold>::fold_try_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        <V as Fold>::fold_unary_expr(&mut **self, node)
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        <V as Fold>::fold_unary_op(&mut **self, node)
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        <V as Fold>::fold_update_expr(&mut **self, node)
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        <V as Fold>::fold_update_op(&mut **self, node)
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        <V as Fold>::fold_using_decl(&mut **self, node)
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        <V as Fold>::fold_var_decl(&mut **self, node)
    }

    #[inline]
    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        <V as Fold>::fold_var_decl_kind(&mut **self, node)
    }

    #[inline]
    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        <V as Fold>::fold_var_decl_or_expr(&mut **self, node)
    }

    #[inline]
    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        <V as Fold>::fold_var_declarator(&mut **self, node)
    }

    #[inline]
    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        <V as Fold>::fold_var_declarators(&mut **self, node)
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        <V as Fold>::fold_while_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        <V as Fold>::fold_with_stmt(&mut **self, node)
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        <V as Fold>::fold_yield_expr(&mut **self, node)
    }
}
impl<A, B> Fold for ::swc_visit::Either<A, B>
where
    A: Fold,
    B: Fold,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_array_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_array_lit(visitor, node),
        }
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_array_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_array_pat(visitor, node),
        }
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_arrow_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_arrow_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_op(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_op(visitor, node),
        }
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_pat(visitor, node),
        }
    }

    #[inline]
    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_target(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_target(visitor, node),
        }
    }

    #[inline]
    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_target_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_target_pat(visitor, node),
        }
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_atom(visitor, node),
        }
    }

    #[inline]
    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_auto_accessor(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_auto_accessor(visitor, node),
        }
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_await_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_await_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_big_int(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_big_int(visitor, node),
        }
    }

    #[inline]
    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_big_int_value(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_big_int_value(visitor, node),
        }
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_bin_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_bin_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_binary_op(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_binary_op(visitor, node),
        }
    }

    #[inline]
    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_binding_ident(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_binding_ident(visitor, node),
        }
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_block_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_block_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_block_stmt_or_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_block_stmt_or_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool) -> Bool {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_bool(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_bool(visitor, node),
        }
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_break_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_break_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_call_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_call_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee) -> Callee {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_callee(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_callee(visitor, node),
        }
    }

    #[inline]
    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_catch_clause(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_catch_clause(visitor, node),
        }
    }

    #[inline]
    fn fold_class(&mut self, node: Class) -> Class {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class(visitor, node),
        }
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_member(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_member(visitor, node),
        }
    }

    #[inline]
    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_members(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_members(visitor, node),
        }
    }

    #[inline]
    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_method(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_method(visitor, node),
        }
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_computed_prop_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_computed_prop_name(visitor, node),
        }
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_cond_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_cond_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_constructor(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_constructor(visitor, node),
        }
    }

    #[inline]
    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_continue_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_continue_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_debugger_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_debugger_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl) -> Decl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_decorator(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_decorator(visitor, node),
        }
    }

    #[inline]
    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_decorators(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_decorators(visitor, node),
        }
    }

    #[inline]
    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_default_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_default_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_do_while_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_do_while_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_empty_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_empty_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_all(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_all(visitor, node),
        }
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_default_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_default_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_default_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_default_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_default_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_default_specifier(visitor, node),
        }
    }

    #[inline]
    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_named_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_named_specifier(visitor, node),
        }
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                Fold::fold_export_namespace_specifier(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Fold::fold_export_namespace_specifier(visitor, node)
            }
        }
    }

    #[inline]
    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_specifier(visitor, node),
        }
    }

    #[inline]
    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_specifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_specifiers(visitor, node),
        }
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr) -> Expr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr_or_spread(visitor, node),
        }
    }

    #[inline]
    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_exprs(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_exprs(visitor, node),
        }
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_fn_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_fn_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_fn_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_fn_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_head(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_head(visitor, node),
        }
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_in_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_in_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_of_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_of_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_function(&mut self, node: Function) -> Function {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_function(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_function(visitor, node),
        }
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_getter_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_getter_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident) -> Ident {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ident(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ident(visitor, node),
        }
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ident_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ident_name(visitor, node),
        }
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_if_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_if_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_import(&mut self, node: Import) -> Import {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import(visitor, node),
        }
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_default_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_default_specifier(visitor, node),
        }
    }

    #[inline]
    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_named_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_named_specifier(visitor, node),
        }
    }

    #[inline]
    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_phase(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_phase(visitor, node),
        }
    }

    #[inline]
    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_specifier(visitor, node),
        }
    }

    #[inline]
    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_specifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_specifiers(visitor, node),
        }
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_star_as_specifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_star_as_specifier(visitor, node),
        }
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_with(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_with(visitor, node),
        }
    }

    #[inline]
    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_with_item(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_with_item(visitor, node),
        }
    }

    #[inline]
    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_with_items(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_with_items(visitor, node),
        }
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_invalid(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_invalid(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_name(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_or_spread(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_value(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_value(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_closing_element(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_closing_element(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_closing_fragment(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_closing_fragment(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element_child(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element_child(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element_childs(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element_childs(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element_name(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_empty_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_empty_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_expr_container(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_expr_container(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_fragment(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_fragment(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_member_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_member_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_namespaced_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_namespaced_name(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_object(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_object(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_opening_element(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_opening_element(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_opening_fragment(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_opening_fragment(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_spread_child(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_spread_child(visitor, node),
        }
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_text(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_text(visitor, node),
        }
    }

    #[inline]
    fn fold_key(&mut self, node: Key) -> Key {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_key(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_key(visitor, node),
        }
    }

    #[inline]
    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_key_value_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_key_value_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_key_value_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_key_value_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_labeled_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_labeled_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit) -> Lit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_lit(visitor, node),
        }
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_member_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_member_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_member_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_member_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_meta_prop_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_meta_prop_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_meta_prop_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_meta_prop_kind(visitor, node),
        }
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_method_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_method_kind(visitor, node),
        }
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_method_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_method_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_module(&mut self, node: Module) -> Module {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module(visitor, node),
        }
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_export_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_export_name(visitor, node),
        }
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_item(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_item(visitor, node),
        }
    }

    #[inline]
    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_items(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_items(visitor, node),
        }
    }

    #[inline]
    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_named_export(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_named_export(visitor, node),
        }
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_new_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_new_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_null(&mut self, node: Null) -> Null {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_null(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_null(visitor, node),
        }
    }

    #[inline]
    fn fold_number(&mut self, node: Number) -> Number {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_number(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_number(visitor, node),
        }
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_lit(visitor, node),
        }
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_pat(visitor, node),
        }
    }

    #[inline]
    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_pat_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_pat_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_pat_props(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_pat_props(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_atom(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_block_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_block_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_call(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_call(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_catch_clause(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_catch_clause(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_chain_base(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_chain_base(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_chain_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_chain_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_expr_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_expr_or_spread(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_expr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_expr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_ident(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_ident(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_jsx_attr_value(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_jsx_attr_value(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_jsx_closing_element(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_jsx_closing_element(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_module_export_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_module_export_name(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_object_lit(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_object_lit(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_pat(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_span(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_span(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_str(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_str(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_var_decl_or_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_var_decl_or_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_vec_expr_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_vec_expr_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_vec_pats(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_vec_pats(visitor, node),
        }
    }

    #[inline]
    fn fold_param(&mut self, node: Param) -> Param {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_param(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_param(visitor, node),
        }
    }

    #[inline]
    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_param_or_ts_param_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_param_or_ts_param_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_param_or_ts_param_props(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_param_or_ts_param_props(visitor, node),
        }
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_params(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_params(visitor, node),
        }
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_paren_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_paren_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat) -> Pat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_pat(visitor, node),
        }
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_pats(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_pats(visitor, node),
        }
    }

    #[inline]
    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_private_method(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_private_method(visitor, node),
        }
    }

    #[inline]
    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_private_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_private_name(visitor, node),
        }
    }

    #[inline]
    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_private_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_private_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_program(&mut self, node: Program) -> Program {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_program(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_program(visitor, node),
        }
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop) -> Prop {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop_name(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop_name(visitor, node),
        }
    }

    #[inline]
    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop_or_spread(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop_or_spread(visitor, node),
        }
    }

    #[inline]
    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop_or_spreads(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop_or_spreads(visitor, node),
        }
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex) -> Regex {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_regex(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_regex(visitor, node),
        }
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_rest_pat(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_rest_pat(visitor, node),
        }
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_return_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_return_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_script(&mut self, node: Script) -> Script {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_script(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_script(visitor, node),
        }
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_seq_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_seq_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_setter_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_setter_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_simple_assign_target(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_simple_assign_target(visitor, node),
        }
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_span(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_span(visitor, node),
        }
    }

    #[inline]
    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_spread_element(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_spread_element(visitor, node),
        }
    }

    #[inline]
    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_static_block(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_static_block(visitor, node),
        }
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_stmts(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_stmts(visitor, node),
        }
    }

    #[inline]
    fn fold_str(&mut self, node: Str) -> Str {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_str(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_str(visitor, node),
        }
    }

    #[inline]
    fn fold_super(&mut self, node: Super) -> Super {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_super(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_super(visitor, node),
        }
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_super_prop(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_super_prop(visitor, node),
        }
    }

    #[inline]
    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_super_prop_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_super_prop_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_switch_case(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_switch_case(visitor, node),
        }
    }

    #[inline]
    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_switch_cases(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_switch_cases(visitor, node),
        }
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_switch_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_switch_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_syntax_context(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_syntax_context(visitor, node),
        }
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tagged_tpl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tagged_tpl(visitor, node),
        }
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_this_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_this_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_throw_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_throw_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tpl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tpl(visitor, node),
        }
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tpl_element(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tpl_element(visitor, node),
        }
    }

    #[inline]
    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tpl_elements(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tpl_elements(visitor, node),
        }
    }

    #[inline]
    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_true_plus_minus(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_true_plus_minus(visitor, node),
        }
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_try_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_try_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_unary_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_unary_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_unary_op(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_unary_op(visitor, node),
        }
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_update_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_update_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_update_op(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_update_op(visitor, node),
        }
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_using_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_using_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_decl(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_decl(visitor, node),
        }
    }

    #[inline]
    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_decl_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_decl_kind(visitor, node),
        }
    }

    #[inline]
    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_decl_or_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_decl_or_expr(visitor, node),
        }
    }

    #[inline]
    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_declarator(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_declarator(visitor, node),
        }
    }

    #[inline]
    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_declarators(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_declarators(visitor, node),
        }
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_while_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_while_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_with_stmt(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_with_stmt(visitor, node),
        }
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_yield_expr(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_yield_expr(visitor, node),
        }
    }
}
impl<V> Fold for ::swc_visit::Optional<V>
where
    V: Fold,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        if self.enabled {
            <V as Fold>::fold_array_lit(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        if self.enabled {
            <V as Fold>::fold_array_pat(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        if self.enabled {
            <V as Fold>::fold_arrow_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        if self.enabled {
            <V as Fold>::fold_assign_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        if self.enabled {
            <V as Fold>::fold_assign_op(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        if self.enabled {
            <V as Fold>::fold_assign_pat(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        if self.enabled {
            <V as Fold>::fold_assign_pat_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        if self.enabled {
            <V as Fold>::fold_assign_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        if self.enabled {
            <V as Fold>::fold_assign_target(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        if self.enabled {
            <V as Fold>::fold_assign_target_pat(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        if self.enabled {
            <V as Fold>::fold_atom(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        if self.enabled {
            <V as Fold>::fold_auto_accessor(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        if self.enabled {
            <V as Fold>::fold_await_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        if self.enabled {
            <V as Fold>::fold_big_int(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        if self.enabled {
            <V as Fold>::fold_big_int_value(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        if self.enabled {
            <V as Fold>::fold_bin_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        if self.enabled {
            <V as Fold>::fold_binary_op(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        if self.enabled {
            <V as Fold>::fold_binding_ident(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        if self.enabled {
            <V as Fold>::fold_block_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        if self.enabled {
            <V as Fold>::fold_block_stmt_or_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool) -> Bool {
        if self.enabled {
            <V as Fold>::fold_bool(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        if self.enabled {
            <V as Fold>::fold_break_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        if self.enabled {
            <V as Fold>::fold_call_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee) -> Callee {
        if self.enabled {
            <V as Fold>::fold_callee(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        if self.enabled {
            <V as Fold>::fold_catch_clause(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class(&mut self, node: Class) -> Class {
        if self.enabled {
            <V as Fold>::fold_class(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        if self.enabled {
            <V as Fold>::fold_class_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        if self.enabled {
            <V as Fold>::fold_class_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        if self.enabled {
            <V as Fold>::fold_class_member(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        if self.enabled {
            <V as Fold>::fold_class_members(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        if self.enabled {
            <V as Fold>::fold_class_method(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        if self.enabled {
            <V as Fold>::fold_class_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        if self.enabled {
            <V as Fold>::fold_computed_prop_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        if self.enabled {
            <V as Fold>::fold_cond_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        if self.enabled {
            <V as Fold>::fold_constructor(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        if self.enabled {
            <V as Fold>::fold_continue_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        if self.enabled {
            <V as Fold>::fold_debugger_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl) -> Decl {
        if self.enabled {
            <V as Fold>::fold_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        if self.enabled {
            <V as Fold>::fold_decorator(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        if self.enabled {
            <V as Fold>::fold_decorators(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        if self.enabled {
            <V as Fold>::fold_default_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        if self.enabled {
            <V as Fold>::fold_do_while_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        if self.enabled {
            <V as Fold>::fold_empty_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        if self.enabled {
            <V as Fold>::fold_export_all(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        if self.enabled {
            <V as Fold>::fold_export_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        if self.enabled {
            <V as Fold>::fold_export_default_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        if self.enabled {
            <V as Fold>::fold_export_default_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        if self.enabled {
            <V as Fold>::fold_export_default_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        if self.enabled {
            <V as Fold>::fold_export_named_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        if self.enabled {
            <V as Fold>::fold_export_namespace_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        if self.enabled {
            <V as Fold>::fold_export_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        if self.enabled {
            <V as Fold>::fold_export_specifiers(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr) -> Expr {
        if self.enabled {
            <V as Fold>::fold_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        if self.enabled {
            <V as Fold>::fold_expr_or_spread(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        if self.enabled {
            <V as Fold>::fold_expr_or_spreads(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        if self.enabled {
            <V as Fold>::fold_expr_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        if self.enabled {
            <V as Fold>::fold_exprs(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        if self.enabled {
            <V as Fold>::fold_fn_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        if self.enabled {
            <V as Fold>::fold_fn_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        if self.enabled {
            <V as Fold>::fold_for_head(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        if self.enabled {
            <V as Fold>::fold_for_in_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        if self.enabled {
            <V as Fold>::fold_for_of_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        if self.enabled {
            <V as Fold>::fold_for_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_function(&mut self, node: Function) -> Function {
        if self.enabled {
            <V as Fold>::fold_function(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        if self.enabled {
            <V as Fold>::fold_getter_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident) -> Ident {
        if self.enabled {
            <V as Fold>::fold_ident(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        if self.enabled {
            <V as Fold>::fold_ident_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        if self.enabled {
            <V as Fold>::fold_if_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import(&mut self, node: Import) -> Import {
        if self.enabled {
            <V as Fold>::fold_import(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        if self.enabled {
            <V as Fold>::fold_import_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        if self.enabled {
            <V as Fold>::fold_import_default_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        if self.enabled {
            <V as Fold>::fold_import_named_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        if self.enabled {
            <V as Fold>::fold_import_phase(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        if self.enabled {
            <V as Fold>::fold_import_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        if self.enabled {
            <V as Fold>::fold_import_specifiers(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        if self.enabled {
            <V as Fold>::fold_import_star_as_specifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        if self.enabled {
            <V as Fold>::fold_import_with(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        if self.enabled {
            <V as Fold>::fold_import_with_item(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        if self.enabled {
            <V as Fold>::fold_import_with_items(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        if self.enabled {
            <V as Fold>::fold_invalid(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        if self.enabled {
            <V as Fold>::fold_jsx_attr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        if self.enabled {
            <V as Fold>::fold_jsx_attr_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        if self.enabled {
            <V as Fold>::fold_jsx_attr_or_spread(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        if self.enabled {
            <V as Fold>::fold_jsx_attr_or_spreads(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        if self.enabled {
            <V as Fold>::fold_jsx_attr_value(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        if self.enabled {
            <V as Fold>::fold_jsx_closing_element(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        if self.enabled {
            <V as Fold>::fold_jsx_closing_fragment(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        if self.enabled {
            <V as Fold>::fold_jsx_element(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        if self.enabled {
            <V as Fold>::fold_jsx_element_child(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        if self.enabled {
            <V as Fold>::fold_jsx_element_childs(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        if self.enabled {
            <V as Fold>::fold_jsx_element_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        if self.enabled {
            <V as Fold>::fold_jsx_empty_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        if self.enabled {
            <V as Fold>::fold_jsx_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        if self.enabled {
            <V as Fold>::fold_jsx_expr_container(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        if self.enabled {
            <V as Fold>::fold_jsx_fragment(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        if self.enabled {
            <V as Fold>::fold_jsx_member_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        if self.enabled {
            <V as Fold>::fold_jsx_namespaced_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        if self.enabled {
            <V as Fold>::fold_jsx_object(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        if self.enabled {
            <V as Fold>::fold_jsx_opening_element(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        if self.enabled {
            <V as Fold>::fold_jsx_opening_fragment(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        if self.enabled {
            <V as Fold>::fold_jsx_spread_child(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        if self.enabled {
            <V as Fold>::fold_jsx_text(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_key(&mut self, node: Key) -> Key {
        if self.enabled {
            <V as Fold>::fold_key(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        if self.enabled {
            <V as Fold>::fold_key_value_pat_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        if self.enabled {
            <V as Fold>::fold_key_value_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        if self.enabled {
            <V as Fold>::fold_labeled_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit) -> Lit {
        if self.enabled {
            <V as Fold>::fold_lit(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        if self.enabled {
            <V as Fold>::fold_member_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        if self.enabled {
            <V as Fold>::fold_member_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        if self.enabled {
            <V as Fold>::fold_meta_prop_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        if self.enabled {
            <V as Fold>::fold_meta_prop_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        if self.enabled {
            <V as Fold>::fold_method_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        if self.enabled {
            <V as Fold>::fold_method_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module(&mut self, node: Module) -> Module {
        if self.enabled {
            <V as Fold>::fold_module(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        if self.enabled {
            <V as Fold>::fold_module_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        if self.enabled {
            <V as Fold>::fold_module_export_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        if self.enabled {
            <V as Fold>::fold_module_item(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        if self.enabled {
            <V as Fold>::fold_module_items(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        if self.enabled {
            <V as Fold>::fold_named_export(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        if self.enabled {
            <V as Fold>::fold_new_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_null(&mut self, node: Null) -> Null {
        if self.enabled {
            <V as Fold>::fold_null(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_number(&mut self, node: Number) -> Number {
        if self.enabled {
            <V as Fold>::fold_number(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        if self.enabled {
            <V as Fold>::fold_object_lit(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        if self.enabled {
            <V as Fold>::fold_object_pat(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        if self.enabled {
            <V as Fold>::fold_object_pat_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        if self.enabled {
            <V as Fold>::fold_object_pat_props(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        if self.enabled {
            <V as Fold>::fold_opt_atom(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        if self.enabled {
            <V as Fold>::fold_opt_block_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        if self.enabled {
            <V as Fold>::fold_opt_call(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        if self.enabled {
            <V as Fold>::fold_opt_catch_clause(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        if self.enabled {
            <V as Fold>::fold_opt_chain_base(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        if self.enabled {
            <V as Fold>::fold_opt_chain_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        if self.enabled {
            <V as Fold>::fold_opt_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        if self.enabled {
            <V as Fold>::fold_opt_expr_or_spread(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        if self.enabled {
            <V as Fold>::fold_opt_expr_or_spreads(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        if self.enabled {
            <V as Fold>::fold_opt_ident(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        if self.enabled {
            <V as Fold>::fold_opt_jsx_attr_value(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        if self.enabled {
            <V as Fold>::fold_opt_jsx_closing_element(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        if self.enabled {
            <V as Fold>::fold_opt_module_export_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        if self.enabled {
            <V as Fold>::fold_opt_object_lit(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        if self.enabled {
            <V as Fold>::fold_opt_pat(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        if self.enabled {
            <V as Fold>::fold_opt_span(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        if self.enabled {
            <V as Fold>::fold_opt_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        if self.enabled {
            <V as Fold>::fold_opt_str(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        if self.enabled {
            <V as Fold>::fold_opt_var_decl_or_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        if self.enabled {
            <V as Fold>::fold_opt_vec_expr_or_spreads(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        if self.enabled {
            <V as Fold>::fold_opt_vec_pats(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_param(&mut self, node: Param) -> Param {
        if self.enabled {
            <V as Fold>::fold_param(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        if self.enabled {
            <V as Fold>::fold_param_or_ts_param_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        if self.enabled {
            <V as Fold>::fold_param_or_ts_param_props(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        if self.enabled {
            <V as Fold>::fold_params(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        if self.enabled {
            <V as Fold>::fold_paren_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat) -> Pat {
        if self.enabled {
            <V as Fold>::fold_pat(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        if self.enabled {
            <V as Fold>::fold_pats(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        if self.enabled {
            <V as Fold>::fold_private_method(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        if self.enabled {
            <V as Fold>::fold_private_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        if self.enabled {
            <V as Fold>::fold_private_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_program(&mut self, node: Program) -> Program {
        if self.enabled {
            <V as Fold>::fold_program(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop) -> Prop {
        if self.enabled {
            <V as Fold>::fold_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        if self.enabled {
            <V as Fold>::fold_prop_name(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        if self.enabled {
            <V as Fold>::fold_prop_or_spread(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        if self.enabled {
            <V as Fold>::fold_prop_or_spreads(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex) -> Regex {
        if self.enabled {
            <V as Fold>::fold_regex(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        if self.enabled {
            <V as Fold>::fold_rest_pat(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        if self.enabled {
            <V as Fold>::fold_return_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_script(&mut self, node: Script) -> Script {
        if self.enabled {
            <V as Fold>::fold_script(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        if self.enabled {
            <V as Fold>::fold_seq_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        if self.enabled {
            <V as Fold>::fold_setter_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        if self.enabled {
            <V as Fold>::fold_simple_assign_target(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        if self.enabled {
            <V as Fold>::fold_span(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        if self.enabled {
            <V as Fold>::fold_spread_element(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        if self.enabled {
            <V as Fold>::fold_static_block(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        if self.enabled {
            <V as Fold>::fold_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        if self.enabled {
            <V as Fold>::fold_stmts(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_str(&mut self, node: Str) -> Str {
        if self.enabled {
            <V as Fold>::fold_str(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_super(&mut self, node: Super) -> Super {
        if self.enabled {
            <V as Fold>::fold_super(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        if self.enabled {
            <V as Fold>::fold_super_prop(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        if self.enabled {
            <V as Fold>::fold_super_prop_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        if self.enabled {
            <V as Fold>::fold_switch_case(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        if self.enabled {
            <V as Fold>::fold_switch_cases(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        if self.enabled {
            <V as Fold>::fold_switch_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        if self.enabled {
            <V as Fold>::fold_syntax_context(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        if self.enabled {
            <V as Fold>::fold_tagged_tpl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        if self.enabled {
            <V as Fold>::fold_this_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        if self.enabled {
            <V as Fold>::fold_throw_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        if self.enabled {
            <V as Fold>::fold_tpl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        if self.enabled {
            <V as Fold>::fold_tpl_element(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        if self.enabled {
            <V as Fold>::fold_tpl_elements(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        if self.enabled {
            <V as Fold>::fold_true_plus_minus(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        if self.enabled {
            <V as Fold>::fold_try_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        if self.enabled {
            <V as Fold>::fold_unary_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        if self.enabled {
            <V as Fold>::fold_unary_op(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        if self.enabled {
            <V as Fold>::fold_update_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        if self.enabled {
            <V as Fold>::fold_update_op(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        if self.enabled {
            <V as Fold>::fold_using_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        if self.enabled {
            <V as Fold>::fold_var_decl(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        if self.enabled {
            <V as Fold>::fold_var_decl_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        if self.enabled {
            <V as Fold>::fold_var_decl_or_expr(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        if self.enabled {
            <V as Fold>::fold_var_declarator(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        if self.enabled {
            <V as Fold>::fold_var_declarators(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        if self.enabled {
            <V as Fold>::fold_while_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        if self.enabled {
            <V as Fold>::fold_with_stmt(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        if self.enabled {
            <V as Fold>::fold_yield_expr(&mut self.visitor, node)
        } else {
            node
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait FoldWith<V: ?Sized + Fold> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn fold_with(self, visitor: &mut V) -> Self;
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn fold_children_with(self, visitor: &mut V) -> Self;
}
impl<V: ?Sized + Fold> FoldWith<V> for ArrayLit {
    #[doc = "Calls [Fold`::fold_array_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_array_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ArrayLit { span, elems } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let elems =
                    { <Vec<Option<ExprOrSpread>> as FoldWith<V>>::fold_with(elems, visitor) };
                ArrayLit { span, elems }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ArrayPat {
    #[doc = "Calls [Fold`::fold_array_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_array_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let elems = { <Vec<Option<Pat>> as FoldWith<V>>::fold_with(elems, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                ArrayPat {
                    span,
                    elems,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ArrowExpr {
    #[doc = "Calls [Fold`::fold_arrow_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_arrow_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let params = { <Vec<Pat> as FoldWith<V>>::fold_with(params, visitor) };
                let body = { <Box<BlockStmtOrExpr> as FoldWith<V>>::fold_with(body, visitor) };
                let type_params = {
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor)
                };
                let return_type =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(return_type, visitor) };
                ArrowExpr {
                    span,
                    ctxt,
                    params,
                    body,
                    is_async,
                    is_generator,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignExpr {
    #[doc = "Calls [Fold`::fold_assign_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let op = { <AssignOp as FoldWith<V>>::fold_with(op, visitor) };
                let left = { <AssignTarget as FoldWith<V>>::fold_with(left, visitor) };
                let right = { <Box<Expr> as FoldWith<V>>::fold_with(right, visitor) };
                AssignExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignOp {
    #[doc = "Calls [Fold`::fold_assign_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignOp::Assign => AssignOp::Assign,
            AssignOp::AddAssign => AssignOp::AddAssign,
            AssignOp::SubAssign => AssignOp::SubAssign,
            AssignOp::MulAssign => AssignOp::MulAssign,
            AssignOp::DivAssign => AssignOp::DivAssign,
            AssignOp::ModAssign => AssignOp::ModAssign,
            AssignOp::LShiftAssign => AssignOp::LShiftAssign,
            AssignOp::RShiftAssign => AssignOp::RShiftAssign,
            AssignOp::ZeroFillRShiftAssign => AssignOp::ZeroFillRShiftAssign,
            AssignOp::BitOrAssign => AssignOp::BitOrAssign,
            AssignOp::BitXorAssign => AssignOp::BitXorAssign,
            AssignOp::BitAndAssign => AssignOp::BitAndAssign,
            AssignOp::ExpAssign => AssignOp::ExpAssign,
            AssignOp::AndAssign => AssignOp::AndAssign,
            AssignOp::OrAssign => AssignOp::OrAssign,
            AssignOp::NullishAssign => AssignOp::NullishAssign,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignPat {
    #[doc = "Calls [Fold`::fold_assign_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignPat { span, left, right } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let left = { <Box<Pat> as FoldWith<V>>::fold_with(left, visitor) };
                let right = { <Box<Expr> as FoldWith<V>>::fold_with(right, visitor) };
                AssignPat { span, left, right }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignPatProp {
    #[doc = "Calls [Fold`::fold_assign_pat_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_pat_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignPatProp { span, key, value } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <BindingIdent as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor) };
                AssignPatProp { span, key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignProp {
    #[doc = "Calls [Fold`::fold_assign_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignProp { span, key, value } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <Ident as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Box<Expr> as FoldWith<V>>::fold_with(value, visitor) };
                AssignProp { span, key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignTarget {
    #[doc = "Calls [Fold`::fold_assign_target`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_target(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                let _field_0 = <SimpleAssignTarget as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTarget::Simple { 0: _field_0 }
            }
            AssignTarget::Pat { 0: _field_0 } => {
                let _field_0 = <AssignTargetPat as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTarget::Pat { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignTargetPat {
    #[doc = "Calls [Fold`::fold_assign_target_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_target_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTargetPat::Array { 0: _field_0 }
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTargetPat::Object { 0: _field_0 }
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTargetPat::Invalid { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AutoAccessor {
    #[doc = "Calls [Fold`::fold_auto_accessor`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_auto_accessor(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <Key as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                let decorators =
                    { <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor) };
                let accessibility =
                    { <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor) };
                AutoAccessor {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_override,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AwaitExpr {
    #[doc = "Calls [Fold`::fold_await_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_await_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AwaitExpr { span, arg } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let arg = { <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor) };
                AwaitExpr { span, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BigInt {
    #[doc = "Calls [Fold`::fold_big_int`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_big_int(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BigInt { span, value, raw } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let value = { <Box<BigIntValue> as FoldWith<V>>::fold_with(value, visitor) };
                let raw = { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(raw, visitor) };
                BigInt { span, value, raw }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BinExpr {
    #[doc = "Calls [Fold`::fold_bin_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_bin_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let op = { <BinaryOp as FoldWith<V>>::fold_with(op, visitor) };
                let left = { <Box<Expr> as FoldWith<V>>::fold_with(left, visitor) };
                let right = { <Box<Expr> as FoldWith<V>>::fold_with(right, visitor) };
                BinExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BinaryOp {
    #[doc = "Calls [Fold`::fold_binary_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_binary_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BinaryOp::EqEq => BinaryOp::EqEq,
            BinaryOp::NotEq => BinaryOp::NotEq,
            BinaryOp::EqEqEq => BinaryOp::EqEqEq,
            BinaryOp::NotEqEq => BinaryOp::NotEqEq,
            BinaryOp::Lt => BinaryOp::Lt,
            BinaryOp::LtEq => BinaryOp::LtEq,
            BinaryOp::Gt => BinaryOp::Gt,
            BinaryOp::GtEq => BinaryOp::GtEq,
            BinaryOp::LShift => BinaryOp::LShift,
            BinaryOp::RShift => BinaryOp::RShift,
            BinaryOp::ZeroFillRShift => BinaryOp::ZeroFillRShift,
            BinaryOp::Add => BinaryOp::Add,
            BinaryOp::Sub => BinaryOp::Sub,
            BinaryOp::Mul => BinaryOp::Mul,
            BinaryOp::Div => BinaryOp::Div,
            BinaryOp::Mod => BinaryOp::Mod,
            BinaryOp::BitOr => BinaryOp::BitOr,
            BinaryOp::BitXor => BinaryOp::BitXor,
            BinaryOp::BitAnd => BinaryOp::BitAnd,
            BinaryOp::LogicalOr => BinaryOp::LogicalOr,
            BinaryOp::LogicalAnd => BinaryOp::LogicalAnd,
            BinaryOp::In => BinaryOp::In,
            BinaryOp::InstanceOf => BinaryOp::InstanceOf,
            BinaryOp::Exp => BinaryOp::Exp,
            BinaryOp::NullishCoalescing => BinaryOp::NullishCoalescing,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BindingIdent {
    #[doc = "Calls [Fold`::fold_binding_ident`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_binding_ident(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BindingIdent { id, type_ann } => {
                let id = { <Ident as FoldWith<V>>::fold_with(id, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                BindingIdent { id, type_ann }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BlockStmt {
    #[doc = "Calls [Fold`::fold_block_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_block_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let stmts = { <Vec<Stmt> as FoldWith<V>>::fold_with(stmts, visitor) };
                BlockStmt { span, ctxt, stmts }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BlockStmtOrExpr {
    #[doc = "Calls [Fold`::fold_block_stmt_or_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_block_stmt_or_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                let _field_0 = <BlockStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                BlockStmtOrExpr::BlockStmt { 0: _field_0 }
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                BlockStmtOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Bool {
    #[doc = "Calls [Fold`::fold_bool`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_bool(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Bool { span, value } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                Bool { span, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BreakStmt {
    #[doc = "Calls [Fold`::fold_break_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_break_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BreakStmt { span, label } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let label = { <Option<Ident> as FoldWith<V>>::fold_with(label, visitor) };
                BreakStmt { span, label }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CallExpr {
    #[doc = "Calls [Fold`::fold_call_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_call_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let callee = { <Callee as FoldWith<V>>::fold_with(callee, visitor) };
                let args = { <Vec<ExprOrSpread> as FoldWith<V>>::fold_with(args, visitor) };
                let type_args = {
                    <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                        type_args, visitor,
                    )
                };
                CallExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Callee {
    #[doc = "Calls [Fold`::fold_callee`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_callee(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Callee::Super { 0: _field_0 } => {
                let _field_0 = <Super as FoldWith<V>>::fold_with(_field_0, visitor);
                Callee::Super { 0: _field_0 }
            }
            Callee::Import { 0: _field_0 } => {
                let _field_0 = <Import as FoldWith<V>>::fold_with(_field_0, visitor);
                Callee::Import { 0: _field_0 }
            }
            Callee::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                Callee::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CatchClause {
    #[doc = "Calls [Fold`::fold_catch_clause`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_catch_clause(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CatchClause { span, param, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let param = { <Option<Pat> as FoldWith<V>>::fold_with(param, visitor) };
                let body = { <BlockStmt as FoldWith<V>>::fold_with(body, visitor) };
                CatchClause { span, param, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Class {
    #[doc = "Calls [Fold`::fold_class`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let decorators =
                    { <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor) };
                let body = { <Vec<ClassMember> as FoldWith<V>>::fold_with(body, visitor) };
                let super_class =
                    { <Option<Box<Expr>> as FoldWith<V>>::fold_with(super_class, visitor) };
                let type_params = {
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor)
                };
                let super_type_params = {
                    <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                        super_type_params,
                        visitor,
                    )
                };
                let implements =
                    { <Vec<TsExprWithTypeArgs> as FoldWith<V>>::fold_with(implements, visitor) };
                Class {
                    span,
                    ctxt,
                    decorators,
                    body,
                    super_class,
                    is_abstract,
                    type_params,
                    super_type_params,
                    implements,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassDecl {
    #[doc = "Calls [Fold`::fold_class_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                let ident = { <Ident as FoldWith<V>>::fold_with(ident, visitor) };
                let class = { <Box<Class> as FoldWith<V>>::fold_with(class, visitor) };
                ClassDecl {
                    ident,
                    declare,
                    class,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassExpr {
    #[doc = "Calls [Fold`::fold_class_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassExpr { ident, class } => {
                let ident = { <Option<Ident> as FoldWith<V>>::fold_with(ident, visitor) };
                let class = { <Box<Class> as FoldWith<V>>::fold_with(class, visitor) };
                ClassExpr { ident, class }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassMember {
    #[doc = "Calls [Fold`::fold_class_member`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_member(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                let _field_0 = <Constructor as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::Constructor { 0: _field_0 }
            }
            ClassMember::Method { 0: _field_0 } => {
                let _field_0 = <ClassMethod as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::Method { 0: _field_0 }
            }
            ClassMember::PrivateMethod { 0: _field_0 } => {
                let _field_0 = <PrivateMethod as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::PrivateMethod { 0: _field_0 }
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                let _field_0 = <ClassProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::ClassProp { 0: _field_0 }
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                let _field_0 = <PrivateProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::PrivateProp { 0: _field_0 }
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                let _field_0 = <TsIndexSignature as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::TsIndexSignature { 0: _field_0 }
            }
            ClassMember::Empty { 0: _field_0 } => {
                let _field_0 = <EmptyStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::Empty { 0: _field_0 }
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                let _field_0 = <StaticBlock as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::StaticBlock { 0: _field_0 }
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                let _field_0 = <AutoAccessor as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::AutoAccessor { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassMethod {
    #[doc = "Calls [Fold`::fold_class_method`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_method(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let function = { <Box<Function> as FoldWith<V>>::fold_with(function, visitor) };
                let kind = { <MethodKind as FoldWith<V>>::fold_with(kind, visitor) };
                let accessibility =
                    { <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor) };
                ClassMethod {
                    span,
                    key,
                    function,
                    kind,
                    is_static,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassProp {
    #[doc = "Calls [Fold`::fold_class_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                let decorators =
                    { <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor) };
                let accessibility =
                    { <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor) };
                ClassProp {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                    readonly,
                    declare,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ComputedPropName {
    #[doc = "Calls [Fold`::fold_computed_prop_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_computed_prop_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ComputedPropName { span, expr } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                ComputedPropName { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CondExpr {
    #[doc = "Calls [Fold`::fold_cond_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_cond_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let test = { <Box<Expr> as FoldWith<V>>::fold_with(test, visitor) };
                let cons = { <Box<Expr> as FoldWith<V>>::fold_with(cons, visitor) };
                let alt = { <Box<Expr> as FoldWith<V>>::fold_with(alt, visitor) };
                CondExpr {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Constructor {
    #[doc = "Calls [Fold`::fold_constructor`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_constructor(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let params =
                    { <Vec<ParamOrTsParamProp> as FoldWith<V>>::fold_with(params, visitor) };
                let body = { <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor) };
                let accessibility =
                    { <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor) };
                Constructor {
                    span,
                    ctxt,
                    key,
                    params,
                    body,
                    accessibility,
                    is_optional,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ContinueStmt {
    #[doc = "Calls [Fold`::fold_continue_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_continue_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ContinueStmt { span, label } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let label = { <Option<Ident> as FoldWith<V>>::fold_with(label, visitor) };
                ContinueStmt { span, label }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for DebuggerStmt {
    #[doc = "Calls [Fold`::fold_debugger_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_debugger_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            DebuggerStmt { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                DebuggerStmt { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Decl {
    #[doc = "Calls [Fold`::fold_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Decl::Class { 0: _field_0 } => {
                let _field_0 = <ClassDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Class { 0: _field_0 }
            }
            Decl::Fn { 0: _field_0 } => {
                let _field_0 = <FnDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Fn { 0: _field_0 }
            }
            Decl::Var { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Var { 0: _field_0 }
            }
            Decl::Using { 0: _field_0 } => {
                let _field_0 = <Box<UsingDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Using { 0: _field_0 }
            }
            Decl::TsInterface { 0: _field_0 } => {
                let _field_0 = <Box<TsInterfaceDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsInterface { 0: _field_0 }
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                let _field_0 = <Box<TsTypeAliasDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsTypeAlias { 0: _field_0 }
            }
            Decl::TsEnum { 0: _field_0 } => {
                let _field_0 = <Box<TsEnumDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsEnum { 0: _field_0 }
            }
            Decl::TsModule { 0: _field_0 } => {
                let _field_0 = <Box<TsModuleDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsModule { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Decorator {
    #[doc = "Calls [Fold`::fold_decorator`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_decorator(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Decorator { span, expr } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                Decorator { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for DefaultDecl {
    #[doc = "Calls [Fold`::fold_default_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_default_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                let _field_0 = <ClassExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                DefaultDecl::Class { 0: _field_0 }
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                let _field_0 = <FnExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                DefaultDecl::Fn { 0: _field_0 }
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                let _field_0 = <Box<TsInterfaceDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                DefaultDecl::TsInterfaceDecl { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for DoWhileStmt {
    #[doc = "Calls [Fold`::fold_do_while_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_do_while_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            DoWhileStmt { span, test, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let test = { <Box<Expr> as FoldWith<V>>::fold_with(test, visitor) };
                let body = { <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                DoWhileStmt { span, test, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for EmptyStmt {
    #[doc = "Calls [Fold`::fold_empty_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_empty_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            EmptyStmt { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                EmptyStmt { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportAll {
    #[doc = "Calls [Fold`::fold_export_all`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_all(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let src = { <Box<Str> as FoldWith<V>>::fold_with(src, visitor) };
                let with = { <Option<Box<ObjectLit>> as FoldWith<V>>::fold_with(with, visitor) };
                ExportAll {
                    span,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDecl {
    #[doc = "Calls [Fold`::fold_export_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDecl { span, decl } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let decl = { <Decl as FoldWith<V>>::fold_with(decl, visitor) };
                ExportDecl { span, decl }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDefaultDecl {
    #[doc = "Calls [Fold`::fold_export_default_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_default_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDefaultDecl { span, decl } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let decl = { <DefaultDecl as FoldWith<V>>::fold_with(decl, visitor) };
                ExportDefaultDecl { span, decl }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDefaultExpr {
    #[doc = "Calls [Fold`::fold_export_default_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_default_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDefaultExpr { span, expr } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                ExportDefaultExpr { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDefaultSpecifier {
    #[doc = "Calls [Fold`::fold_export_default_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_default_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDefaultSpecifier { exported } => {
                let exported = { <Ident as FoldWith<V>>::fold_with(exported, visitor) };
                ExportDefaultSpecifier { exported }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportNamedSpecifier {
    #[doc = "Calls [Fold`::fold_export_named_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_named_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let orig = { <ModuleExportName as FoldWith<V>>::fold_with(orig, visitor) };
                let exported =
                    { <Option<ModuleExportName> as FoldWith<V>>::fold_with(exported, visitor) };
                ExportNamedSpecifier {
                    span,
                    orig,
                    exported,
                    is_type_only,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [Fold`::fold_export_namespace_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_namespace_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <ModuleExportName as FoldWith<V>>::fold_with(name, visitor) };
                ExportNamespaceSpecifier { span, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportSpecifier {
    #[doc = "Calls [Fold`::fold_export_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                let _field_0 =
                    <ExportNamespaceSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ExportSpecifier::Namespace { 0: _field_0 }
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                let _field_0 =
                    <ExportDefaultSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ExportSpecifier::Default { 0: _field_0 }
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                let _field_0 = <ExportNamedSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ExportSpecifier::Named { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Expr {
    #[doc = "Calls [Fold`::fold_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Expr::This { 0: _field_0 } => {
                let _field_0 = <ThisExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::This { 0: _field_0 }
            }
            Expr::Array { 0: _field_0 } => {
                let _field_0 = <ArrayLit as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Array { 0: _field_0 }
            }
            Expr::Object { 0: _field_0 } => {
                let _field_0 = <ObjectLit as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Object { 0: _field_0 }
            }
            Expr::Fn { 0: _field_0 } => {
                let _field_0 = <FnExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Fn { 0: _field_0 }
            }
            Expr::Unary { 0: _field_0 } => {
                let _field_0 = <UnaryExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Unary { 0: _field_0 }
            }
            Expr::Update { 0: _field_0 } => {
                let _field_0 = <UpdateExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Update { 0: _field_0 }
            }
            Expr::Bin { 0: _field_0 } => {
                let _field_0 = <BinExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Bin { 0: _field_0 }
            }
            Expr::Assign { 0: _field_0 } => {
                let _field_0 = <AssignExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Assign { 0: _field_0 }
            }
            Expr::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Member { 0: _field_0 }
            }
            Expr::SuperProp { 0: _field_0 } => {
                let _field_0 = <SuperPropExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::SuperProp { 0: _field_0 }
            }
            Expr::Cond { 0: _field_0 } => {
                let _field_0 = <CondExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Cond { 0: _field_0 }
            }
            Expr::Call { 0: _field_0 } => {
                let _field_0 = <CallExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Call { 0: _field_0 }
            }
            Expr::New { 0: _field_0 } => {
                let _field_0 = <NewExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::New { 0: _field_0 }
            }
            Expr::Seq { 0: _field_0 } => {
                let _field_0 = <SeqExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Seq { 0: _field_0 }
            }
            Expr::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Ident { 0: _field_0 }
            }
            Expr::Lit { 0: _field_0 } => {
                let _field_0 = <Lit as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Lit { 0: _field_0 }
            }
            Expr::Tpl { 0: _field_0 } => {
                let _field_0 = <Tpl as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Tpl { 0: _field_0 }
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                let _field_0 = <TaggedTpl as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TaggedTpl { 0: _field_0 }
            }
            Expr::Arrow { 0: _field_0 } => {
                let _field_0 = <ArrowExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Arrow { 0: _field_0 }
            }
            Expr::Class { 0: _field_0 } => {
                let _field_0 = <ClassExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Class { 0: _field_0 }
            }
            Expr::Yield { 0: _field_0 } => {
                let _field_0 = <YieldExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Yield { 0: _field_0 }
            }
            Expr::MetaProp { 0: _field_0 } => {
                let _field_0 = <MetaPropExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::MetaProp { 0: _field_0 }
            }
            Expr::Await { 0: _field_0 } => {
                let _field_0 = <AwaitExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Await { 0: _field_0 }
            }
            Expr::Paren { 0: _field_0 } => {
                let _field_0 = <ParenExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Paren { 0: _field_0 }
            }
            Expr::JSXMember { 0: _field_0 } => {
                let _field_0 = <JSXMemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXMember { 0: _field_0 }
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXNamespacedName { 0: _field_0 }
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                let _field_0 = <JSXEmptyExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXEmpty { 0: _field_0 }
            }
            Expr::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXElement { 0: _field_0 }
            }
            Expr::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXFragment { 0: _field_0 }
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                let _field_0 = <TsTypeAssertion as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsTypeAssertion { 0: _field_0 }
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                let _field_0 = <TsConstAssertion as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsConstAssertion { 0: _field_0 }
            }
            Expr::TsNonNull { 0: _field_0 } => {
                let _field_0 = <TsNonNullExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsNonNull { 0: _field_0 }
            }
            Expr::TsAs { 0: _field_0 } => {
                let _field_0 = <TsAsExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsAs { 0: _field_0 }
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                let _field_0 = <TsInstantiation as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsInstantiation { 0: _field_0 }
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                let _field_0 = <TsSatisfiesExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsSatisfies { 0: _field_0 }
            }
            Expr::PrivateName { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::PrivateName { 0: _field_0 }
            }
            Expr::OptChain { 0: _field_0 } => {
                let _field_0 = <OptChainExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::OptChain { 0: _field_0 }
            }
            Expr::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Invalid { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExprOrSpread {
    #[doc = "Calls [Fold`::fold_expr_or_spread`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr_or_spread(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExprOrSpread { spread, expr } => {
                let spread =
                    { <Option<swc_common::Span> as FoldWith<V>>::fold_with(spread, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                ExprOrSpread { spread, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExprStmt {
    #[doc = "Calls [Fold`::fold_expr_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExprStmt { span, expr } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                ExprStmt { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for FnDecl {
    #[doc = "Calls [Fold`::fold_fn_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_fn_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                let ident = { <Ident as FoldWith<V>>::fold_with(ident, visitor) };
                let function = { <Box<Function> as FoldWith<V>>::fold_with(function, visitor) };
                FnDecl {
                    ident,
                    declare,
                    function,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for FnExpr {
    #[doc = "Calls [Fold`::fold_fn_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_fn_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            FnExpr { ident, function } => {
                let ident = { <Option<Ident> as FoldWith<V>>::fold_with(ident, visitor) };
                let function = { <Box<Function> as FoldWith<V>>::fold_with(function, visitor) };
                FnExpr { ident, function }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForHead {
    #[doc = "Calls [Fold`::fold_for_head`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_head(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                ForHead::VarDecl { 0: _field_0 }
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                let _field_0 = <Box<UsingDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                ForHead::UsingDecl { 0: _field_0 }
            }
            ForHead::Pat { 0: _field_0 } => {
                let _field_0 = <Box<Pat> as FoldWith<V>>::fold_with(_field_0, visitor);
                ForHead::Pat { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForInStmt {
    #[doc = "Calls [Fold`::fold_for_in_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_in_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let left = { <ForHead as FoldWith<V>>::fold_with(left, visitor) };
                let right = { <Box<Expr> as FoldWith<V>>::fold_with(right, visitor) };
                let body = { <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                ForInStmt {
                    span,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForOfStmt {
    #[doc = "Calls [Fold`::fold_for_of_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_of_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let left = { <ForHead as FoldWith<V>>::fold_with(left, visitor) };
                let right = { <Box<Expr> as FoldWith<V>>::fold_with(right, visitor) };
                let body = { <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                ForOfStmt {
                    span,
                    is_await,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForStmt {
    #[doc = "Calls [Fold`::fold_for_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let init = { <Option<VarDeclOrExpr> as FoldWith<V>>::fold_with(init, visitor) };
                let test = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(test, visitor) };
                let update = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(update, visitor) };
                let body = { <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                ForStmt {
                    span,
                    init,
                    test,
                    update,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Function {
    #[doc = "Calls [Fold`::fold_function`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_function(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                let params = { <Vec<Param> as FoldWith<V>>::fold_with(params, visitor) };
                let decorators =
                    { <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor) };
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let body = { <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor) };
                let type_params = {
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor)
                };
                let return_type =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(return_type, visitor) };
                Function {
                    params,
                    decorators,
                    span,
                    ctxt,
                    body,
                    is_generator,
                    is_async,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for GetterProp {
    #[doc = "Calls [Fold`::fold_getter_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_getter_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                let body = { <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor) };
                GetterProp {
                    span,
                    key,
                    type_ann,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Ident {
    #[doc = "Calls [Fold`::fold_ident`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ident(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let sym = { <swc_atoms::Atom as FoldWith<V>>::fold_with(sym, visitor) };
                Ident {
                    span,
                    ctxt,
                    sym,
                    optional,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for IdentName {
    #[doc = "Calls [Fold`::fold_ident_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ident_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            IdentName { span, sym } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let sym = { <swc_atoms::Atom as FoldWith<V>>::fold_with(sym, visitor) };
                IdentName { span, sym }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for IfStmt {
    #[doc = "Calls [Fold`::fold_if_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_if_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let test = { <Box<Expr> as FoldWith<V>>::fold_with(test, visitor) };
                let cons = { <Box<Stmt> as FoldWith<V>>::fold_with(cons, visitor) };
                let alt = { <Option<Box<Stmt>> as FoldWith<V>>::fold_with(alt, visitor) };
                IfStmt {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Import {
    #[doc = "Calls [Fold`::fold_import`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Import { span, phase } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let phase = { <ImportPhase as FoldWith<V>>::fold_with(phase, visitor) };
                Import { span, phase }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportDecl {
    #[doc = "Calls [Fold`::fold_import_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let specifiers =
                    { <Vec<ImportSpecifier> as FoldWith<V>>::fold_with(specifiers, visitor) };
                let src = { <Box<Str> as FoldWith<V>>::fold_with(src, visitor) };
                let with = { <Option<Box<ObjectLit>> as FoldWith<V>>::fold_with(with, visitor) };
                let phase = { <ImportPhase as FoldWith<V>>::fold_with(phase, visitor) };
                ImportDecl {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                    phase,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportDefaultSpecifier {
    #[doc = "Calls [Fold`::fold_import_default_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_default_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportDefaultSpecifier { span, local } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let local = { <Ident as FoldWith<V>>::fold_with(local, visitor) };
                ImportDefaultSpecifier { span, local }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportNamedSpecifier {
    #[doc = "Calls [Fold`::fold_import_named_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_named_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let local = { <Ident as FoldWith<V>>::fold_with(local, visitor) };
                let imported =
                    { <Option<ModuleExportName> as FoldWith<V>>::fold_with(imported, visitor) };
                ImportNamedSpecifier {
                    span,
                    local,
                    imported,
                    is_type_only,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportPhase {
    #[doc = "Calls [Fold`::fold_import_phase`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_phase(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportPhase::Evaluation => ImportPhase::Evaluation,
            ImportPhase::Source => ImportPhase::Source,
            ImportPhase::Defer => ImportPhase::Defer,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportSpecifier {
    #[doc = "Calls [Fold`::fold_import_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                let _field_0 = <ImportNamedSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ImportSpecifier::Named { 0: _field_0 }
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                let _field_0 =
                    <ImportDefaultSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ImportSpecifier::Default { 0: _field_0 }
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                let _field_0 = <ImportStarAsSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ImportSpecifier::Namespace { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportStarAsSpecifier {
    #[doc = "Calls [Fold`::fold_import_star_as_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_star_as_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportStarAsSpecifier { span, local } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let local = { <Ident as FoldWith<V>>::fold_with(local, visitor) };
                ImportStarAsSpecifier { span, local }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportWith {
    #[doc = "Calls [Fold`::fold_import_with`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_with(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportWith { span, values } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let values = { <Vec<ImportWithItem> as FoldWith<V>>::fold_with(values, visitor) };
                ImportWith { span, values }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportWithItem {
    #[doc = "Calls [Fold`::fold_import_with_item`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_with_item(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportWithItem { key, value } => {
                let key = { <IdentName as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Str as FoldWith<V>>::fold_with(value, visitor) };
                ImportWithItem { key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Invalid {
    #[doc = "Calls [Fold`::fold_invalid`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_invalid(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Invalid { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                Invalid { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttr {
    #[doc = "Calls [Fold`::fold_jsx_attr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttr { span, name, value } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <JSXAttrName as FoldWith<V>>::fold_with(name, visitor) };
                let value = { <Option<JSXAttrValue> as FoldWith<V>>::fold_with(value, visitor) };
                JSXAttr { span, name, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttrName {
    #[doc = "Calls [Fold`::fold_jsx_attr_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrName::Ident { 0: _field_0 }
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttrOrSpread {
    #[doc = "Calls [Fold`::fold_jsx_attr_or_spread`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_or_spread(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                let _field_0 = <JSXAttr as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrOrSpread::JSXAttr { 0: _field_0 }
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                let _field_0 = <SpreadElement as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrOrSpread::SpreadElement { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttrValue {
    #[doc = "Calls [Fold`::fold_jsx_attr_value`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_value(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                let _field_0 = <Lit as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::Lit { 0: _field_0 }
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                let _field_0 = <JSXExprContainer as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::JSXExprContainer { 0: _field_0 }
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::JSXElement { 0: _field_0 }
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::JSXFragment { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXClosingElement {
    #[doc = "Calls [Fold`::fold_jsx_closing_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_closing_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXClosingElement { span, name } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <JSXElementName as FoldWith<V>>::fold_with(name, visitor) };
                JSXClosingElement { span, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXClosingFragment {
    #[doc = "Calls [Fold`::fold_jsx_closing_fragment`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_closing_fragment(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXClosingFragment { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                JSXClosingFragment { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXElement {
    #[doc = "Calls [Fold`::fold_jsx_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let opening = { <JSXOpeningElement as FoldWith<V>>::fold_with(opening, visitor) };
                let children =
                    { <Vec<JSXElementChild> as FoldWith<V>>::fold_with(children, visitor) };
                let closing =
                    { <Option<JSXClosingElement> as FoldWith<V>>::fold_with(closing, visitor) };
                JSXElement {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXElementChild {
    #[doc = "Calls [Fold`::fold_jsx_element_child`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element_child(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                let _field_0 = <JSXText as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXText { 0: _field_0 }
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                let _field_0 = <JSXExprContainer as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXExprContainer { 0: _field_0 }
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                let _field_0 = <JSXSpreadChild as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXSpreadChild { 0: _field_0 }
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXElement { 0: _field_0 }
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXFragment { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXElementName {
    #[doc = "Calls [Fold`::fold_jsx_element_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementName::Ident { 0: _field_0 }
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                let _field_0 = <JSXMemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementName::JSXMemberExpr { 0: _field_0 }
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXEmptyExpr {
    #[doc = "Calls [Fold`::fold_jsx_empty_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_empty_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXEmptyExpr { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                JSXEmptyExpr { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXExpr {
    #[doc = "Calls [Fold`::fold_jsx_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                let _field_0 = <JSXEmptyExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXExpr::JSXEmptyExpr { 0: _field_0 }
            }
            JSXExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXExpr::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXExprContainer {
    #[doc = "Calls [Fold`::fold_jsx_expr_container`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_expr_container(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXExprContainer { span, expr } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let expr = { <JSXExpr as FoldWith<V>>::fold_with(expr, visitor) };
                JSXExprContainer { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXFragment {
    #[doc = "Calls [Fold`::fold_jsx_fragment`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_fragment(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let opening = { <JSXOpeningFragment as FoldWith<V>>::fold_with(opening, visitor) };
                let children =
                    { <Vec<JSXElementChild> as FoldWith<V>>::fold_with(children, visitor) };
                let closing = { <JSXClosingFragment as FoldWith<V>>::fold_with(closing, visitor) };
                JSXFragment {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXMemberExpr {
    #[doc = "Calls [Fold`::fold_jsx_member_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_member_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let obj = { <JSXObject as FoldWith<V>>::fold_with(obj, visitor) };
                let prop = { <IdentName as FoldWith<V>>::fold_with(prop, visitor) };
                JSXMemberExpr { span, obj, prop }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXNamespacedName {
    #[doc = "Calls [Fold`::fold_jsx_namespaced_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_namespaced_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXNamespacedName { span, ns, name } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ns = { <IdentName as FoldWith<V>>::fold_with(ns, visitor) };
                let name = { <IdentName as FoldWith<V>>::fold_with(name, visitor) };
                JSXNamespacedName { span, ns, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXObject {
    #[doc = "Calls [Fold`::fold_jsx_object`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_object(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                let _field_0 = <Box<JSXMemberExpr> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXObject::JSXMemberExpr { 0: _field_0 }
            }
            JSXObject::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXObject::Ident { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXOpeningElement {
    #[doc = "Calls [Fold`::fold_jsx_opening_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_opening_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                let name = { <JSXElementName as FoldWith<V>>::fold_with(name, visitor) };
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let attrs = { <Vec<JSXAttrOrSpread> as FoldWith<V>>::fold_with(attrs, visitor) };
                let type_args = {
                    <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                        type_args, visitor,
                    )
                };
                JSXOpeningElement {
                    name,
                    span,
                    attrs,
                    self_closing,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXOpeningFragment {
    #[doc = "Calls [Fold`::fold_jsx_opening_fragment`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_opening_fragment(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXOpeningFragment { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                JSXOpeningFragment { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXSpreadChild {
    #[doc = "Calls [Fold`::fold_jsx_spread_child`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_spread_child(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXSpreadChild { span, expr } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                JSXSpreadChild { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXText {
    #[doc = "Calls [Fold`::fold_jsx_text`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_text(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXText { span, value, raw } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let value = { <swc_atoms::Atom as FoldWith<V>>::fold_with(value, visitor) };
                let raw = { <swc_atoms::Atom as FoldWith<V>>::fold_with(raw, visitor) };
                JSXText { span, value, raw }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Key {
    #[doc = "Calls [Fold`::fold_key`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_key(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Key::Private { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWith<V>>::fold_with(_field_0, visitor);
                Key::Private { 0: _field_0 }
            }
            Key::Public { 0: _field_0 } => {
                let _field_0 = <PropName as FoldWith<V>>::fold_with(_field_0, visitor);
                Key::Public { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for KeyValuePatProp {
    #[doc = "Calls [Fold`::fold_key_value_pat_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_key_value_pat_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            KeyValuePatProp { key, value } => {
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Box<Pat> as FoldWith<V>>::fold_with(value, visitor) };
                KeyValuePatProp { key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for KeyValueProp {
    #[doc = "Calls [Fold`::fold_key_value_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_key_value_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            KeyValueProp { key, value } => {
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Box<Expr> as FoldWith<V>>::fold_with(value, visitor) };
                KeyValueProp { key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for LabeledStmt {
    #[doc = "Calls [Fold`::fold_labeled_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_labeled_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            LabeledStmt { span, label, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let label = { <Ident as FoldWith<V>>::fold_with(label, visitor) };
                let body = { <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                LabeledStmt { span, label, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Lit {
    #[doc = "Calls [Fold`::fold_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Lit::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Str { 0: _field_0 }
            }
            Lit::Bool { 0: _field_0 } => {
                let _field_0 = <Bool as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Bool { 0: _field_0 }
            }
            Lit::Null { 0: _field_0 } => {
                let _field_0 = <Null as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Null { 0: _field_0 }
            }
            Lit::Num { 0: _field_0 } => {
                let _field_0 = <Number as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Num { 0: _field_0 }
            }
            Lit::BigInt { 0: _field_0 } => {
                let _field_0 = <BigInt as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::BigInt { 0: _field_0 }
            }
            Lit::Regex { 0: _field_0 } => {
                let _field_0 = <Regex as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Regex { 0: _field_0 }
            }
            Lit::JSXText { 0: _field_0 } => {
                let _field_0 = <JSXText as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::JSXText { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MemberExpr {
    #[doc = "Calls [Fold`::fold_member_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_member_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MemberExpr { span, obj, prop } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let obj = { <Box<Expr> as FoldWith<V>>::fold_with(obj, visitor) };
                let prop = { <MemberProp as FoldWith<V>>::fold_with(prop, visitor) };
                MemberExpr { span, obj, prop }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MemberProp {
    #[doc = "Calls [Fold`::fold_member_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_member_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                MemberProp::Ident { 0: _field_0 }
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWith<V>>::fold_with(_field_0, visitor);
                MemberProp::PrivateName { 0: _field_0 }
            }
            MemberProp::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWith<V>>::fold_with(_field_0, visitor);
                MemberProp::Computed { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MetaPropExpr {
    #[doc = "Calls [Fold`::fold_meta_prop_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_meta_prop_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MetaPropExpr { span, kind } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let kind = { <MetaPropKind as FoldWith<V>>::fold_with(kind, visitor) };
                MetaPropExpr { span, kind }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MetaPropKind {
    #[doc = "Calls [Fold`::fold_meta_prop_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_meta_prop_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MetaPropKind::NewTarget => MetaPropKind::NewTarget,
            MetaPropKind::ImportMeta => MetaPropKind::ImportMeta,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MethodKind {
    #[doc = "Calls [Fold`::fold_method_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_method_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MethodKind::Method => MethodKind::Method,
            MethodKind::Getter => MethodKind::Getter,
            MethodKind::Setter => MethodKind::Setter,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MethodProp {
    #[doc = "Calls [Fold`::fold_method_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_method_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MethodProp { key, function } => {
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let function = { <Box<Function> as FoldWith<V>>::fold_with(function, visitor) };
                MethodProp { key, function }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Module {
    #[doc = "Calls [Fold`::fold_module`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Vec<ModuleItem> as FoldWith<V>>::fold_with(body, visitor) };
                let shebang =
                    { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(shebang, visitor) };
                Module {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ModuleDecl {
    #[doc = "Calls [Fold`::fold_module_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                let _field_0 = <ImportDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::Import { 0: _field_0 }
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                let _field_0 = <ExportDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportDecl { 0: _field_0 }
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                let _field_0 = <NamedExport as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportNamed { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                let _field_0 = <ExportDefaultDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportDefaultDecl { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                let _field_0 = <ExportDefaultExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportDefaultExpr { 0: _field_0 }
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                let _field_0 = <ExportAll as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportAll { 0: _field_0 }
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                let _field_0 =
                    <Box<TsImportEqualsDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::TsImportEquals { 0: _field_0 }
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                let _field_0 = <TsExportAssignment as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::TsExportAssignment { 0: _field_0 }
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                let _field_0 = <TsNamespaceExportDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::TsNamespaceExport { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ModuleExportName {
    #[doc = "Calls [Fold`::fold_module_export_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_export_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleExportName::Ident { 0: _field_0 }
            }
            ModuleExportName::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleExportName::Str { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ModuleItem {
    #[doc = "Calls [Fold`::fold_module_item`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_item(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                let _field_0 = <ModuleDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleItem::ModuleDecl { 0: _field_0 }
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                let _field_0 = <Stmt as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleItem::Stmt { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for NamedExport {
    #[doc = "Calls [Fold`::fold_named_export`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_named_export(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let specifiers =
                    { <Vec<ExportSpecifier> as FoldWith<V>>::fold_with(specifiers, visitor) };
                let src = { <Option<Box<Str>> as FoldWith<V>>::fold_with(src, visitor) };
                let with = { <Option<Box<ObjectLit>> as FoldWith<V>>::fold_with(with, visitor) };
                NamedExport {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for NewExpr {
    #[doc = "Calls [Fold`::fold_new_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_new_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let callee = { <Box<Expr> as FoldWith<V>>::fold_with(callee, visitor) };
                let args = { <Option<Vec<ExprOrSpread>> as FoldWith<V>>::fold_with(args, visitor) };
                let type_args = {
                    <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                        type_args, visitor,
                    )
                };
                NewExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Null {
    #[doc = "Calls [Fold`::fold_null`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_null(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Null { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                Null { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Number {
    #[doc = "Calls [Fold`::fold_number`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_number(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Number { span, value, raw } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let raw = { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(raw, visitor) };
                Number { span, value, raw }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ObjectLit {
    #[doc = "Calls [Fold`::fold_object_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ObjectLit { span, props } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let props = { <Vec<PropOrSpread> as FoldWith<V>>::fold_with(props, visitor) };
                ObjectLit { span, props }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ObjectPat {
    #[doc = "Calls [Fold`::fold_object_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let props = { <Vec<ObjectPatProp> as FoldWith<V>>::fold_with(props, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                ObjectPat {
                    span,
                    props,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ObjectPatProp {
    #[doc = "Calls [Fold`::fold_object_pat_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_pat_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                let _field_0 = <KeyValuePatProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ObjectPatProp::KeyValue { 0: _field_0 }
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPatProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ObjectPatProp::Assign { 0: _field_0 }
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWith<V>>::fold_with(_field_0, visitor);
                ObjectPatProp::Rest { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for OptCall {
    #[doc = "Calls [Fold`::fold_opt_call`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_call(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let callee = { <Box<Expr> as FoldWith<V>>::fold_with(callee, visitor) };
                let args = { <Vec<ExprOrSpread> as FoldWith<V>>::fold_with(args, visitor) };
                let type_args = {
                    <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                        type_args, visitor,
                    )
                };
                OptCall {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for OptChainBase {
    #[doc = "Calls [Fold`::fold_opt_chain_base`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_chain_base(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                OptChainBase::Member { 0: _field_0 }
            }
            OptChainBase::Call { 0: _field_0 } => {
                let _field_0 = <OptCall as FoldWith<V>>::fold_with(_field_0, visitor);
                OptChainBase::Call { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for OptChainExpr {
    #[doc = "Calls [Fold`::fold_opt_chain_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_chain_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let base = { <Box<OptChainBase> as FoldWith<V>>::fold_with(base, visitor) };
                OptChainExpr {
                    span,
                    optional,
                    base,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Param {
    #[doc = "Calls [Fold`::fold_param`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_param(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let decorators =
                    { <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor) };
                let pat = { <Pat as FoldWith<V>>::fold_with(pat, visitor) };
                Param {
                    span,
                    decorators,
                    pat,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ParamOrTsParamProp {
    #[doc = "Calls [Fold`::fold_param_or_ts_param_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_param_or_ts_param_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                let _field_0 = <TsParamProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ParamOrTsParamProp::TsParamProp { 0: _field_0 }
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                let _field_0 = <Param as FoldWith<V>>::fold_with(_field_0, visitor);
                ParamOrTsParamProp::Param { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ParenExpr {
    #[doc = "Calls [Fold`::fold_paren_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_paren_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ParenExpr { span, expr } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                ParenExpr { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Pat {
    #[doc = "Calls [Fold`::fold_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Pat::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Ident { 0: _field_0 }
            }
            Pat::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Array { 0: _field_0 }
            }
            Pat::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Rest { 0: _field_0 }
            }
            Pat::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Object { 0: _field_0 }
            }
            Pat::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Assign { 0: _field_0 }
            }
            Pat::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Invalid { 0: _field_0 }
            }
            Pat::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PrivateMethod {
    #[doc = "Calls [Fold`::fold_private_method`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_private_method(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <PrivateName as FoldWith<V>>::fold_with(key, visitor) };
                let function = { <Box<Function> as FoldWith<V>>::fold_with(function, visitor) };
                let kind = { <MethodKind as FoldWith<V>>::fold_with(kind, visitor) };
                let accessibility =
                    { <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor) };
                PrivateMethod {
                    span,
                    key,
                    function,
                    kind,
                    is_static,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PrivateName {
    #[doc = "Calls [Fold`::fold_private_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_private_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PrivateName { span, name } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <swc_atoms::Atom as FoldWith<V>>::fold_with(name, visitor) };
                PrivateName { span, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PrivateProp {
    #[doc = "Calls [Fold`::fold_private_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_private_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let key = { <PrivateName as FoldWith<V>>::fold_with(key, visitor) };
                let value = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                let decorators =
                    { <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor) };
                let accessibility =
                    { <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor) };
                PrivateProp {
                    span,
                    ctxt,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_optional,
                    is_override,
                    readonly,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Program {
    #[doc = "Calls [Fold`::fold_program`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_program(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Program::Module { 0: _field_0 } => {
                let _field_0 = <Module as FoldWith<V>>::fold_with(_field_0, visitor);
                Program::Module { 0: _field_0 }
            }
            Program::Script { 0: _field_0 } => {
                let _field_0 = <Script as FoldWith<V>>::fold_with(_field_0, visitor);
                Program::Script { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Prop {
    #[doc = "Calls [Fold`::fold_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Shorthand { 0: _field_0 }
            }
            Prop::KeyValue { 0: _field_0 } => {
                let _field_0 = <KeyValueProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::KeyValue { 0: _field_0 }
            }
            Prop::Assign { 0: _field_0 } => {
                let _field_0 = <AssignProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Assign { 0: _field_0 }
            }
            Prop::Getter { 0: _field_0 } => {
                let _field_0 = <GetterProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Getter { 0: _field_0 }
            }
            Prop::Setter { 0: _field_0 } => {
                let _field_0 = <SetterProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Setter { 0: _field_0 }
            }
            Prop::Method { 0: _field_0 } => {
                let _field_0 = <MethodProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Method { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PropName {
    #[doc = "Calls [Fold`::fold_prop_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PropName::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Ident { 0: _field_0 }
            }
            PropName::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Str { 0: _field_0 }
            }
            PropName::Num { 0: _field_0 } => {
                let _field_0 = <Number as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Num { 0: _field_0 }
            }
            PropName::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Computed { 0: _field_0 }
            }
            PropName::BigInt { 0: _field_0 } => {
                let _field_0 = <BigInt as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::BigInt { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PropOrSpread {
    #[doc = "Calls [Fold`::fold_prop_or_spread`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop_or_spread(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                let _field_0 = <SpreadElement as FoldWith<V>>::fold_with(_field_0, visitor);
                PropOrSpread::Spread { 0: _field_0 }
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                let _field_0 = <Box<Prop> as FoldWith<V>>::fold_with(_field_0, visitor);
                PropOrSpread::Prop { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Regex {
    #[doc = "Calls [Fold`::fold_regex`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_regex(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Regex { span, exp, flags } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let exp = { <swc_atoms::Atom as FoldWith<V>>::fold_with(exp, visitor) };
                let flags = { <swc_atoms::Atom as FoldWith<V>>::fold_with(flags, visitor) };
                Regex { span, exp, flags }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for RestPat {
    #[doc = "Calls [Fold`::fold_rest_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_rest_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let dot3_token =
                    { <swc_common::Span as FoldWith<V>>::fold_with(dot3_token, visitor) };
                let arg = { <Box<Pat> as FoldWith<V>>::fold_with(arg, visitor) };
                let type_ann =
                    { <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor) };
                RestPat {
                    span,
                    dot3_token,
                    arg,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ReturnStmt {
    #[doc = "Calls [Fold`::fold_return_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_return_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ReturnStmt { span, arg } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let arg = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(arg, visitor) };
                ReturnStmt { span, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Script {
    #[doc = "Calls [Fold`::fold_script`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_script(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Vec<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                let shebang =
                    { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(shebang, visitor) };
                Script {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SeqExpr {
    #[doc = "Calls [Fold`::fold_seq_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_seq_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SeqExpr { span, exprs } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let exprs = { <Vec<Box<Expr>> as FoldWith<V>>::fold_with(exprs, visitor) };
                SeqExpr { span, exprs }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SetterProp {
    #[doc = "Calls [Fold`::fold_setter_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_setter_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let key = { <PropName as FoldWith<V>>::fold_with(key, visitor) };
                let this_param = { <Option<Pat> as FoldWith<V>>::fold_with(this_param, visitor) };
                let param = { <Box<Pat> as FoldWith<V>>::fold_with(param, visitor) };
                let body = { <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor) };
                SetterProp {
                    span,
                    key,
                    this_param,
                    param,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SimpleAssignTarget {
    #[doc = "Calls [Fold`::fold_simple_assign_target`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_simple_assign_target(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Ident { 0: _field_0 }
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Member { 0: _field_0 }
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                let _field_0 = <SuperPropExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::SuperProp { 0: _field_0 }
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                let _field_0 = <ParenExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Paren { 0: _field_0 }
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                let _field_0 = <OptChainExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::OptChain { 0: _field_0 }
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                let _field_0 = <TsAsExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsAs { 0: _field_0 }
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                let _field_0 = <TsSatisfiesExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsSatisfies { 0: _field_0 }
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                let _field_0 = <TsNonNullExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsNonNull { 0: _field_0 }
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                let _field_0 = <TsTypeAssertion as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsTypeAssertion { 0: _field_0 }
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                let _field_0 = <TsInstantiation as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsInstantiation { 0: _field_0 }
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Invalid { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SpreadElement {
    #[doc = "Calls [Fold`::fold_spread_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_spread_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SpreadElement { dot3_token, expr } => {
                let dot3_token =
                    { <swc_common::Span as FoldWith<V>>::fold_with(dot3_token, visitor) };
                let expr = { <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor) };
                SpreadElement { dot3_token, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for StaticBlock {
    #[doc = "Calls [Fold`::fold_static_block`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_static_block(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            StaticBlock { span, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <BlockStmt as FoldWith<V>>::fold_with(body, visitor) };
                StaticBlock { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Stmt {
    #[doc = "Calls [Fold`::fold_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Stmt::Block { 0: _field_0 } => {
                let _field_0 = <BlockStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Block { 0: _field_0 }
            }
            Stmt::Empty { 0: _field_0 } => {
                let _field_0 = <EmptyStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Empty { 0: _field_0 }
            }
            Stmt::Debugger { 0: _field_0 } => {
                let _field_0 = <DebuggerStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Debugger { 0: _field_0 }
            }
            Stmt::With { 0: _field_0 } => {
                let _field_0 = <WithStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::With { 0: _field_0 }
            }
            Stmt::Return { 0: _field_0 } => {
                let _field_0 = <ReturnStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Return { 0: _field_0 }
            }
            Stmt::Labeled { 0: _field_0 } => {
                let _field_0 = <LabeledStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Labeled { 0: _field_0 }
            }
            Stmt::Break { 0: _field_0 } => {
                let _field_0 = <BreakStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Break { 0: _field_0 }
            }
            Stmt::Continue { 0: _field_0 } => {
                let _field_0 = <ContinueStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Continue { 0: _field_0 }
            }
            Stmt::If { 0: _field_0 } => {
                let _field_0 = <IfStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::If { 0: _field_0 }
            }
            Stmt::Switch { 0: _field_0 } => {
                let _field_0 = <SwitchStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Switch { 0: _field_0 }
            }
            Stmt::Throw { 0: _field_0 } => {
                let _field_0 = <ThrowStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Throw { 0: _field_0 }
            }
            Stmt::Try { 0: _field_0 } => {
                let _field_0 = <Box<TryStmt> as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Try { 0: _field_0 }
            }
            Stmt::While { 0: _field_0 } => {
                let _field_0 = <WhileStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::While { 0: _field_0 }
            }
            Stmt::DoWhile { 0: _field_0 } => {
                let _field_0 = <DoWhileStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::DoWhile { 0: _field_0 }
            }
            Stmt::For { 0: _field_0 } => {
                let _field_0 = <ForStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::For { 0: _field_0 }
            }
            Stmt::ForIn { 0: _field_0 } => {
                let _field_0 = <ForInStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::ForIn { 0: _field_0 }
            }
            Stmt::ForOf { 0: _field_0 } => {
                let _field_0 = <ForOfStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::ForOf { 0: _field_0 }
            }
            Stmt::Decl { 0: _field_0 } => {
                let _field_0 = <Decl as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Decl { 0: _field_0 }
            }
            Stmt::Expr { 0: _field_0 } => {
                let _field_0 = <ExprStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Str {
    #[doc = "Calls [Fold`::fold_str`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_str(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Str { span, value, raw } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let value = { <swc_atoms::Atom as FoldWith<V>>::fold_with(value, visitor) };
                let raw = { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(raw, visitor) };
                Str { span, value, raw }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Super {
    #[doc = "Calls [Fold`::fold_super`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_super(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Super { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                Super { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SuperProp {
    #[doc = "Calls [Fold`::fold_super_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_super_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                SuperProp::Ident { 0: _field_0 }
            }
            SuperProp::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWith<V>>::fold_with(_field_0, visitor);
                SuperProp::Computed { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SuperPropExpr {
    #[doc = "Calls [Fold`::fold_super_prop_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_super_prop_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SuperPropExpr { span, obj, prop } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let obj = { <Super as FoldWith<V>>::fold_with(obj, visitor) };
                let prop = { <SuperProp as FoldWith<V>>::fold_with(prop, visitor) };
                SuperPropExpr { span, obj, prop }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SwitchCase {
    #[doc = "Calls [Fold`::fold_switch_case`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_switch_case(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SwitchCase { span, test, cons } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let test = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(test, visitor) };
                let cons = { <Vec<Stmt> as FoldWith<V>>::fold_with(cons, visitor) };
                SwitchCase { span, test, cons }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SwitchStmt {
    #[doc = "Calls [Fold`::fold_switch_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_switch_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let discriminant = { <Box<Expr> as FoldWith<V>>::fold_with(discriminant, visitor) };
                let cases = { <Vec<SwitchCase> as FoldWith<V>>::fold_with(cases, visitor) };
                SwitchStmt {
                    span,
                    discriminant,
                    cases,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TaggedTpl {
    #[doc = "Calls [Fold`::fold_tagged_tpl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tagged_tpl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let tag = { <Box<Expr> as FoldWith<V>>::fold_with(tag, visitor) };
                let type_params = {
                    <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                        type_params,
                        visitor,
                    )
                };
                let tpl = { <Box<Tpl> as FoldWith<V>>::fold_with(tpl, visitor) };
                TaggedTpl {
                    span,
                    ctxt,
                    tag,
                    type_params,
                    tpl,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ThisExpr {
    #[doc = "Calls [Fold`::fold_this_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_this_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ThisExpr { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                ThisExpr { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ThrowStmt {
    #[doc = "Calls [Fold`::fold_throw_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_throw_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ThrowStmt { span, arg } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let arg = { <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor) };
                ThrowStmt { span, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Tpl {
    #[doc = "Calls [Fold`::fold_tpl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tpl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let exprs = { <Vec<Box<Expr>> as FoldWith<V>>::fold_with(exprs, visitor) };
                let quasis = { <Vec<TplElement> as FoldWith<V>>::fold_with(quasis, visitor) };
                Tpl {
                    span,
                    exprs,
                    quasis,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TplElement {
    #[doc = "Calls [Fold`::fold_tpl_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tpl_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let cooked =
                    { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(cooked, visitor) };
                let raw = { <swc_atoms::Atom as FoldWith<V>>::fold_with(raw, visitor) };
                TplElement {
                    span,
                    tail,
                    cooked,
                    raw,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TruePlusMinus {
    #[doc = "Calls [Fold`::fold_true_plus_minus`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_true_plus_minus(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TruePlusMinus::True => TruePlusMinus::True,
            TruePlusMinus::Plus => TruePlusMinus::Plus,
            TruePlusMinus::Minus => TruePlusMinus::Minus,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TryStmt {
    #[doc = "Calls [Fold`::fold_try_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_try_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let block = { <BlockStmt as FoldWith<V>>::fold_with(block, visitor) };
                let handler = { <Option<CatchClause> as FoldWith<V>>::fold_with(handler, visitor) };
                let finalizer =
                    { <Option<BlockStmt> as FoldWith<V>>::fold_with(finalizer, visitor) };
                TryStmt {
                    span,
                    block,
                    handler,
                    finalizer,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UnaryExpr {
    #[doc = "Calls [Fold`::fold_unary_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_unary_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UnaryExpr { span, op, arg } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let op = { <UnaryOp as FoldWith<V>>::fold_with(op, visitor) };
                let arg = { <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor) };
                UnaryExpr { span, op, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UnaryOp {
    #[doc = "Calls [Fold`::fold_unary_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_unary_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UnaryOp::Minus => UnaryOp::Minus,
            UnaryOp::Plus => UnaryOp::Plus,
            UnaryOp::Bang => UnaryOp::Bang,
            UnaryOp::Tilde => UnaryOp::Tilde,
            UnaryOp::TypeOf => UnaryOp::TypeOf,
            UnaryOp::Void => UnaryOp::Void,
            UnaryOp::Delete => UnaryOp::Delete,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UpdateExpr {
    #[doc = "Calls [Fold`::fold_update_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_update_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let op = { <UpdateOp as FoldWith<V>>::fold_with(op, visitor) };
                let arg = { <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor) };
                UpdateExpr {
                    span,
                    op,
                    prefix,
                    arg,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UpdateOp {
    #[doc = "Calls [Fold`::fold_update_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_update_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UpdateOp::PlusPlus => UpdateOp::PlusPlus,
            UpdateOp::MinusMinus => UpdateOp::MinusMinus,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UsingDecl {
    #[doc = "Calls [Fold`::fold_using_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_using_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let decls = { <Vec<VarDeclarator> as FoldWith<V>>::fold_with(decls, visitor) };
                UsingDecl {
                    span,
                    is_await,
                    decls,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDecl {
    #[doc = "Calls [Fold`::fold_var_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let ctxt = { <swc_common::SyntaxContext as FoldWith<V>>::fold_with(ctxt, visitor) };
                let kind = { <VarDeclKind as FoldWith<V>>::fold_with(kind, visitor) };
                let decls = { <Vec<VarDeclarator> as FoldWith<V>>::fold_with(decls, visitor) };
                VarDecl {
                    span,
                    ctxt,
                    kind,
                    declare,
                    decls,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDeclKind {
    #[doc = "Calls [Fold`::fold_var_decl_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_decl_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDeclKind::Var => VarDeclKind::Var,
            VarDeclKind::Let => VarDeclKind::Let,
            VarDeclKind::Const => VarDeclKind::Const,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDeclOrExpr {
    #[doc = "Calls [Fold`::fold_var_decl_or_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_decl_or_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                VarDeclOrExpr::VarDecl { 0: _field_0 }
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                VarDeclOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDeclarator {
    #[doc = "Calls [Fold`::fold_var_declarator`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_declarator(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <Pat as FoldWith<V>>::fold_with(name, visitor) };
                let init = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(init, visitor) };
                VarDeclarator {
                    span,
                    name,
                    init,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for WhileStmt {
    #[doc = "Calls [Fold`::fold_while_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_while_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            WhileStmt { span, test, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let test = { <Box<Expr> as FoldWith<V>>::fold_with(test, visitor) };
                let body = { <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                WhileStmt { span, test, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for WithStmt {
    #[doc = "Calls [Fold`::fold_with_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_with_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            WithStmt { span, obj, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let obj = { <Box<Expr> as FoldWith<V>>::fold_with(obj, visitor) };
                let body = { <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor) };
                WithStmt { span, obj, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for YieldExpr {
    #[doc = "Calls [Fold`::fold_yield_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_yield_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let arg = { <Option<Box<Expr>> as FoldWith<V>>::fold_with(arg, visitor) };
                YieldExpr {
                    span,
                    arg,
                    delegate,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_atoms::Atom {
    #[doc = "Calls [Fold`::fold_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_atom(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BigIntValue {
    #[doc = "Calls [Fold`::fold_big_int_value`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_big_int_value(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ClassMember> {
    #[doc = "Calls [Fold`::fold_class_members`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_members(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ClassMember as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Decorator> {
    #[doc = "Calls [Fold`::fold_decorators`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_decorators(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Decorator as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [Fold`::fold_export_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_specifiers(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ExportSpecifier as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [Fold`::fold_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ExprOrSpread as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Box<Expr>> {
    #[doc = "Calls [Fold`::fold_exprs`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_exprs(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Box<Expr> as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [Fold`::fold_import_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_specifiers(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ImportSpecifier as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ImportWithItem> {
    #[doc = "Calls [Fold`::fold_import_with_items`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_with_items(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ImportWithItem as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [Fold`::fold_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_or_spreads(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <JSXAttrOrSpread as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<JSXElementChild> {
    #[doc = "Calls [Fold`::fold_jsx_element_childs`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element_childs(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <JSXElementChild as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ModuleItem> {
    #[doc = "Calls [Fold`::fold_module_items`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_items(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ModuleItem as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [Fold`::fold_object_pat_props`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_pat_props(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ObjectPatProp as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [Fold`::fold_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_atom(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <swc_atoms::Atom as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<BlockStmt> {
    #[doc = "Calls [Fold`::fold_opt_block_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_block_stmt(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <BlockStmt as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<CatchClause> {
    #[doc = "Calls [Fold`::fold_opt_catch_clause`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_catch_clause(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <CatchClause as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<Expr>> {
    #[doc = "Calls [Fold`::fold_opt_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_expr(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<Expr> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<ExprOrSpread> {
    #[doc = "Calls [Fold`::fold_opt_expr_or_spread`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_expr_or_spread(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <ExprOrSpread as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [Fold`::fold_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Vec<ExprOrSpread> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Ident> {
    #[doc = "Calls [Fold`::fold_opt_ident`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ident(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Ident as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<JSXAttrValue> {
    #[doc = "Calls [Fold`::fold_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_jsx_attr_value(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <JSXAttrValue as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<JSXClosingElement> {
    #[doc = "Calls [Fold`::fold_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_jsx_closing_element(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <JSXClosingElement as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<ModuleExportName> {
    #[doc = "Calls [Fold`::fold_opt_module_export_name`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_module_export_name(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <ModuleExportName as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [Fold`::fold_opt_object_lit`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_object_lit(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<ObjectLit> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Pat> {
    #[doc = "Calls [Fold`::fold_opt_pat`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_pat(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Pat as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<swc_common::Span> {
    #[doc = "Calls [Fold`::fold_opt_span`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_span(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <swc_common::Span as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<Stmt>> {
    #[doc = "Calls [Fold`::fold_opt_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_stmt(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<Stmt> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<Str>> {
    #[doc = "Calls [Fold`::fold_opt_str`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_str(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<Str> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [Fold`::fold_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_var_decl_or_expr(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <VarDeclOrExpr as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [Fold`::fold_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_vec_expr_or_spreads(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Option<ExprOrSpread> as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Option<Pat>> {
    #[doc = "Calls [Fold`::fold_opt_vec_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_vec_pats(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Option<Pat> as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [Fold`::fold_param_or_ts_param_props`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_param_or_ts_param_props(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ParamOrTsParamProp as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Param> {
    #[doc = "Calls [Fold`::fold_params`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_params(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Param as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Pat> {
    #[doc = "Calls [Fold`::fold_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_pats(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Pat as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<PropOrSpread> {
    #[doc = "Calls [Fold`::fold_prop_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop_or_spreads(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <PropOrSpread as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_common::Span {
    #[doc = "Calls [Fold`::fold_span`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_span(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Stmt> {
    #[doc = "Calls [Fold`::fold_stmts`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_stmts(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Stmt as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<SwitchCase> {
    #[doc = "Calls [Fold`::fold_switch_cases`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_switch_cases(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <SwitchCase as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_common::SyntaxContext {
    #[doc = "Calls [Fold`::fold_syntax_context`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_syntax_context(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TplElement> {
    #[doc = "Calls [Fold`::fold_tpl_elements`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tpl_elements(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <TplElement as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<VarDeclarator> {
    #[doc = "Calls [Fold`::fold_var_declarators`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_declarators(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <VarDeclarator as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V, T> FoldWith<V> for std::boxed::Box<T>
where
    V: ?Sized + Fold,
    T: FoldWith<V>,
{
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        swc_visit::util::map::Map::map(self, |inner| <T as FoldWith<V>>::fold_with(inner, visitor))
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::map::Map::map(self, |inner| {
            <T as FoldWith<V>>::fold_children_with(inner, visitor)
        })
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait FoldAstPath {
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit, __ast_path: &mut AstKindPath) -> ArrayLit {
        <ArrayLit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat, __ast_path: &mut AstKindPath) -> ArrayPat {
        <ArrayPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr, __ast_path: &mut AstKindPath) -> ArrowExpr {
        <ArrowExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr, __ast_path: &mut AstKindPath) -> AssignExpr {
        <AssignExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp, __ast_path: &mut AstKindPath) -> AssignOp {
        <AssignOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat, __ast_path: &mut AstKindPath) -> AssignPat {
        <AssignPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        <AssignPatProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp, __ast_path: &mut AstKindPath) -> AssignProp {
        <AssignProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        <AssignTarget as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        <AssignTargetPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        <swc_atoms::Atom as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        __ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        <AutoAccessor as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr, __ast_path: &mut AstKindPath) -> AwaitExpr {
        <AwaitExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_big_int(&mut self, node: BigInt, __ast_path: &mut AstKindPath) -> BigInt {
        <BigInt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_big_int_value(
        &mut self,
        node: BigIntValue,
        __ast_path: &mut AstKindPath,
    ) -> BigIntValue {
        <BigIntValue as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr, __ast_path: &mut AstKindPath) -> BinExpr {
        <BinExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp, __ast_path: &mut AstKindPath) -> BinaryOp {
        <BinaryOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        __ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        <BindingIdent as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt, __ast_path: &mut AstKindPath) -> BlockStmt {
        <BlockStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        <BlockStmtOrExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_bool(&mut self, node: Bool, __ast_path: &mut AstKindPath) -> Bool {
        <Bool as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt, __ast_path: &mut AstKindPath) -> BreakStmt {
        <BreakStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr, __ast_path: &mut AstKindPath) -> CallExpr {
        <CallExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_callee(&mut self, node: Callee, __ast_path: &mut AstKindPath) -> Callee {
        <Callee as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_catch_clause(
        &mut self,
        node: CatchClause,
        __ast_path: &mut AstKindPath,
    ) -> CatchClause {
        <CatchClause as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class(&mut self, node: Class, __ast_path: &mut AstKindPath) -> Class {
        <Class as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl, __ast_path: &mut AstKindPath) -> ClassDecl {
        <ClassDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr, __ast_path: &mut AstKindPath) -> ClassExpr {
        <ClassExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_class_member(
        &mut self,
        node: ClassMember,
        __ast_path: &mut AstKindPath,
    ) -> ClassMember {
        <ClassMember as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        <Vec<ClassMember> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_class_method(
        &mut self,
        node: ClassMethod,
        __ast_path: &mut AstKindPath,
    ) -> ClassMethod {
        <ClassMethod as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp, __ast_path: &mut AstKindPath) -> ClassProp {
        <ClassProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        <ComputedPropName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr, __ast_path: &mut AstKindPath) -> CondExpr {
        <CondExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_constructor(&mut self, node: Constructor, __ast_path: &mut AstKindPath) -> Constructor {
        <Constructor as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        __ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        <ContinueStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        __ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        <DebuggerStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_decl(&mut self, node: Decl, __ast_path: &mut AstKindPath) -> Decl {
        <Decl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_decorator(&mut self, node: Decorator, __ast_path: &mut AstKindPath) -> Decorator {
        <Decorator as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        <Vec<Decorator> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_default_decl(
        &mut self,
        node: DefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> DefaultDecl {
        <DefaultDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_do_while_stmt(
        &mut self,
        node: DoWhileStmt,
        __ast_path: &mut AstKindPath,
    ) -> DoWhileStmt {
        <DoWhileStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt, __ast_path: &mut AstKindPath) -> EmptyStmt {
        <EmptyStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_export_all(&mut self, node: ExportAll, __ast_path: &mut AstKindPath) -> ExportAll {
        <ExportAll as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl, __ast_path: &mut AstKindPath) -> ExportDecl {
        <ExportDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        <ExportDefaultDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        <ExportDefaultExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        <ExportDefaultSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        <ExportNamedSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        <ExportNamespaceSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        <ExportSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        <Vec<ExportSpecifier> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_expr(&mut self, node: Expr, __ast_path: &mut AstKindPath) -> Expr {
        <Expr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        <ExprOrSpread as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        <Vec<ExprOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt, __ast_path: &mut AstKindPath) -> ExprStmt {
        <ExprStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, __ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        <Vec<Box<Expr>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl, __ast_path: &mut AstKindPath) -> FnDecl {
        <FnDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr, __ast_path: &mut AstKindPath) -> FnExpr {
        <FnExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_for_head(&mut self, node: ForHead, __ast_path: &mut AstKindPath) -> ForHead {
        <ForHead as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt, __ast_path: &mut AstKindPath) -> ForInStmt {
        <ForInStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt, __ast_path: &mut AstKindPath) -> ForOfStmt {
        <ForOfStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt, __ast_path: &mut AstKindPath) -> ForStmt {
        <ForStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_function(&mut self, node: Function, __ast_path: &mut AstKindPath) -> Function {
        <Function as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp, __ast_path: &mut AstKindPath) -> GetterProp {
        <GetterProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_ident(&mut self, node: Ident, __ast_path: &mut AstKindPath) -> Ident {
        <Ident as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_ident_name(&mut self, node: IdentName, __ast_path: &mut AstKindPath) -> IdentName {
        <IdentName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt, __ast_path: &mut AstKindPath) -> IfStmt {
        <IfStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_import(&mut self, node: Import, __ast_path: &mut AstKindPath) -> Import {
        <Import as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl, __ast_path: &mut AstKindPath) -> ImportDecl {
        <ImportDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        <ImportDefaultSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        <ImportNamedSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_import_phase(
        &mut self,
        node: ImportPhase,
        __ast_path: &mut AstKindPath,
    ) -> ImportPhase {
        <ImportPhase as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        <ImportSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        <Vec<ImportSpecifier> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        <ImportStarAsSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_import_with(&mut self, node: ImportWith, __ast_path: &mut AstKindPath) -> ImportWith {
        <ImportWith as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        <ImportWithItem as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        <Vec<ImportWithItem> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_invalid(&mut self, node: Invalid, __ast_path: &mut AstKindPath) -> Invalid {
        <Invalid as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr, __ast_path: &mut AstKindPath) -> JSXAttr {
        <JSXAttr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_attr_name(
        &mut self,
        node: JSXAttrName,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrName {
        <JSXAttrName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        <JSXAttrOrSpread as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        <Vec<JSXAttrOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        <JSXAttrValue as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        <JSXClosingElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        <JSXClosingFragment as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement, __ast_path: &mut AstKindPath) -> JSXElement {
        <JSXElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        <JSXElementChild as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        <Vec<JSXElementChild> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        <JSXElementName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        <JSXEmptyExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr, __ast_path: &mut AstKindPath) -> JSXExpr {
        <JSXExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        <JSXExprContainer as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_fragment(
        &mut self,
        node: JSXFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXFragment {
        <JSXFragment as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        <JSXMemberExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        <JSXNamespacedName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject, __ast_path: &mut AstKindPath) -> JSXObject {
        <JSXObject as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        <JSXOpeningElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        <JSXOpeningFragment as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        <JSXSpreadChild as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText, __ast_path: &mut AstKindPath) -> JSXText {
        <JSXText as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_key(&mut self, node: Key, __ast_path: &mut AstKindPath) -> Key {
        <Key as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        <KeyValuePatProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        <KeyValueProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_labeled_stmt(
        &mut self,
        node: LabeledStmt,
        __ast_path: &mut AstKindPath,
    ) -> LabeledStmt {
        <LabeledStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_lit(&mut self, node: Lit, __ast_path: &mut AstKindPath) -> Lit {
        <Lit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr, __ast_path: &mut AstKindPath) -> MemberExpr {
        <MemberExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp, __ast_path: &mut AstKindPath) -> MemberProp {
        <MemberProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        <MetaPropExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        <MetaPropKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind, __ast_path: &mut AstKindPath) -> MethodKind {
        <MethodKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp, __ast_path: &mut AstKindPath) -> MethodProp {
        <MethodProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_module(&mut self, node: Module, __ast_path: &mut AstKindPath) -> Module {
        <Module as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl, __ast_path: &mut AstKindPath) -> ModuleDecl {
        <ModuleDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        <ModuleExportName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem, __ast_path: &mut AstKindPath) -> ModuleItem {
        <ModuleItem as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        <Vec<ModuleItem> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_named_export(
        &mut self,
        node: NamedExport,
        __ast_path: &mut AstKindPath,
    ) -> NamedExport {
        <NamedExport as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr, __ast_path: &mut AstKindPath) -> NewExpr {
        <NewExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_null(&mut self, node: Null, __ast_path: &mut AstKindPath) -> Null {
        <Null as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_number(&mut self, node: Number, __ast_path: &mut AstKindPath) -> Number {
        <Number as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit, __ast_path: &mut AstKindPath) -> ObjectLit {
        <ObjectLit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat, __ast_path: &mut AstKindPath) -> ObjectPat {
        <ObjectPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        <ObjectPatProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        <Vec<ObjectPatProp> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        <Option<swc_atoms::Atom> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        <Option<BlockStmt> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_opt_call(&mut self, node: OptCall, __ast_path: &mut AstKindPath) -> OptCall {
        <OptCall as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        <Option<CatchClause> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        __ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        <OptChainBase as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        __ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        <OptChainExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        <Option<Box<Expr>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        <Option<ExprOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::fold_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        <Option<Vec<ExprOrSpread>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_opt_ident(
        &mut self,
        node: Option<Ident>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Ident> {
        <Option<Ident> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        <Option<JSXAttrValue> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        <Option<JSXClosingElement> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        <Option<ModuleExportName> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        <Option<Box<ObjectLit>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>, __ast_path: &mut AstKindPath) -> Option<Pat> {
        <Option<Pat> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        <Option<swc_common::Span> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        <Option<Box<Stmt>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        <Option<Box<Str>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        <Option<VarDeclOrExpr> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::fold_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        <Vec<Option<ExprOrSpread>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        <Vec<Option<Pat>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_param(&mut self, node: Param, __ast_path: &mut AstKindPath) -> Param {
        <Param as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        <ParamOrTsParamProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        <Vec<ParamOrTsParamProp> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_params(&mut self, node: Vec<Param>, __ast_path: &mut AstKindPath) -> Vec<Param> {
        <Vec<Param> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr, __ast_path: &mut AstKindPath) -> ParenExpr {
        <ParenExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_pat(&mut self, node: Pat, __ast_path: &mut AstKindPath) -> Pat {
        <Pat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>, __ast_path: &mut AstKindPath) -> Vec<Pat> {
        <Vec<Pat> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        __ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        <PrivateMethod as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_private_name(
        &mut self,
        node: PrivateName,
        __ast_path: &mut AstKindPath,
    ) -> PrivateName {
        <PrivateName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_private_prop(
        &mut self,
        node: PrivateProp,
        __ast_path: &mut AstKindPath,
    ) -> PrivateProp {
        <PrivateProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_program(&mut self, node: Program, __ast_path: &mut AstKindPath) -> Program {
        <Program as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_prop(&mut self, node: Prop, __ast_path: &mut AstKindPath) -> Prop {
        <Prop as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_prop_name(&mut self, node: PropName, __ast_path: &mut AstKindPath) -> PropName {
        <PropName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        <PropOrSpread as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        <Vec<PropOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_regex(&mut self, node: Regex, __ast_path: &mut AstKindPath) -> Regex {
        <Regex as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat, __ast_path: &mut AstKindPath) -> RestPat {
        <RestPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt, __ast_path: &mut AstKindPath) -> ReturnStmt {
        <ReturnStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_script(&mut self, node: Script, __ast_path: &mut AstKindPath) -> Script {
        <Script as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr, __ast_path: &mut AstKindPath) -> SeqExpr {
        <SeqExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp, __ast_path: &mut AstKindPath) -> SetterProp {
        <SetterProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        <SimpleAssignTarget as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        <swc_common::Span as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        __ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        <SpreadElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_static_block(
        &mut self,
        node: StaticBlock,
        __ast_path: &mut AstKindPath,
    ) -> StaticBlock {
        <StaticBlock as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_stmt(&mut self, node: Stmt, __ast_path: &mut AstKindPath) -> Stmt {
        <Stmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>, __ast_path: &mut AstKindPath) -> Vec<Stmt> {
        <Vec<Stmt> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_str(&mut self, node: Str, __ast_path: &mut AstKindPath) -> Str {
        <Str as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_super(&mut self, node: Super, __ast_path: &mut AstKindPath) -> Super {
        <Super as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp, __ast_path: &mut AstKindPath) -> SuperProp {
        <SuperProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        <SuperPropExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase, __ast_path: &mut AstKindPath) -> SwitchCase {
        <SwitchCase as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        <Vec<SwitchCase> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt, __ast_path: &mut AstKindPath) -> SwitchStmt {
        <SwitchStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        <swc_common::SyntaxContext as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl, __ast_path: &mut AstKindPath) -> TaggedTpl {
        <TaggedTpl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr, __ast_path: &mut AstKindPath) -> ThisExpr {
        <ThisExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt, __ast_path: &mut AstKindPath) -> ThrowStmt {
        <ThrowStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_tpl(&mut self, node: Tpl, __ast_path: &mut AstKindPath) -> Tpl {
        <Tpl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement, __ast_path: &mut AstKindPath) -> TplElement {
        <TplElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        <Vec<TplElement> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        <TruePlusMinus as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt, __ast_path: &mut AstKindPath) -> TryStmt {
        <TryStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr, __ast_path: &mut AstKindPath) -> UnaryExpr {
        <UnaryExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp, __ast_path: &mut AstKindPath) -> UnaryOp {
        <UnaryOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr, __ast_path: &mut AstKindPath) -> UpdateExpr {
        <UpdateExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp, __ast_path: &mut AstKindPath) -> UpdateOp {
        <UpdateOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl, __ast_path: &mut AstKindPath) -> UsingDecl {
        <UsingDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl, __ast_path: &mut AstKindPath) -> VarDecl {
        <VarDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_var_decl_kind(
        &mut self,
        node: VarDeclKind,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclKind {
        <VarDeclKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        <VarDeclOrExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        <VarDeclarator as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        <Vec<VarDeclarator> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt, __ast_path: &mut AstKindPath) -> WhileStmt {
        <WhileStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt, __ast_path: &mut AstKindPath) -> WithStmt {
        <WithStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr, __ast_path: &mut AstKindPath) -> YieldExpr {
        <YieldExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for &mut V
where
    V: ?Sized + FoldAstPath,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit, __ast_path: &mut AstKindPath) -> ArrayLit {
        <V as FoldAstPath>::fold_array_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat, __ast_path: &mut AstKindPath) -> ArrayPat {
        <V as FoldAstPath>::fold_array_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr, __ast_path: &mut AstKindPath) -> ArrowExpr {
        <V as FoldAstPath>::fold_arrow_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr, __ast_path: &mut AstKindPath) -> AssignExpr {
        <V as FoldAstPath>::fold_assign_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp, __ast_path: &mut AstKindPath) -> AssignOp {
        <V as FoldAstPath>::fold_assign_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat, __ast_path: &mut AstKindPath) -> AssignPat {
        <V as FoldAstPath>::fold_assign_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        <V as FoldAstPath>::fold_assign_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp, __ast_path: &mut AstKindPath) -> AssignProp {
        <V as FoldAstPath>::fold_assign_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        <V as FoldAstPath>::fold_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        <V as FoldAstPath>::fold_assign_target_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        <V as FoldAstPath>::fold_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        __ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        <V as FoldAstPath>::fold_auto_accessor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr, __ast_path: &mut AstKindPath) -> AwaitExpr {
        <V as FoldAstPath>::fold_await_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt, __ast_path: &mut AstKindPath) -> BigInt {
        <V as FoldAstPath>::fold_big_int(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_big_int_value(
        &mut self,
        node: BigIntValue,
        __ast_path: &mut AstKindPath,
    ) -> BigIntValue {
        <V as FoldAstPath>::fold_big_int_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr, __ast_path: &mut AstKindPath) -> BinExpr {
        <V as FoldAstPath>::fold_bin_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp, __ast_path: &mut AstKindPath) -> BinaryOp {
        <V as FoldAstPath>::fold_binary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        __ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        <V as FoldAstPath>::fold_binding_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt, __ast_path: &mut AstKindPath) -> BlockStmt {
        <V as FoldAstPath>::fold_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        <V as FoldAstPath>::fold_block_stmt_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool, __ast_path: &mut AstKindPath) -> Bool {
        <V as FoldAstPath>::fold_bool(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt, __ast_path: &mut AstKindPath) -> BreakStmt {
        <V as FoldAstPath>::fold_break_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr, __ast_path: &mut AstKindPath) -> CallExpr {
        <V as FoldAstPath>::fold_call_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee, __ast_path: &mut AstKindPath) -> Callee {
        <V as FoldAstPath>::fold_callee(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_catch_clause(
        &mut self,
        node: CatchClause,
        __ast_path: &mut AstKindPath,
    ) -> CatchClause {
        <V as FoldAstPath>::fold_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class(&mut self, node: Class, __ast_path: &mut AstKindPath) -> Class {
        <V as FoldAstPath>::fold_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl, __ast_path: &mut AstKindPath) -> ClassDecl {
        <V as FoldAstPath>::fold_class_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr, __ast_path: &mut AstKindPath) -> ClassExpr {
        <V as FoldAstPath>::fold_class_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_member(
        &mut self,
        node: ClassMember,
        __ast_path: &mut AstKindPath,
    ) -> ClassMember {
        <V as FoldAstPath>::fold_class_member(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        <V as FoldAstPath>::fold_class_members(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_method(
        &mut self,
        node: ClassMethod,
        __ast_path: &mut AstKindPath,
    ) -> ClassMethod {
        <V as FoldAstPath>::fold_class_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp, __ast_path: &mut AstKindPath) -> ClassProp {
        <V as FoldAstPath>::fold_class_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        <V as FoldAstPath>::fold_computed_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr, __ast_path: &mut AstKindPath) -> CondExpr {
        <V as FoldAstPath>::fold_cond_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor, __ast_path: &mut AstKindPath) -> Constructor {
        <V as FoldAstPath>::fold_constructor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        __ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        <V as FoldAstPath>::fold_continue_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        __ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        <V as FoldAstPath>::fold_debugger_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl, __ast_path: &mut AstKindPath) -> Decl {
        <V as FoldAstPath>::fold_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator, __ast_path: &mut AstKindPath) -> Decorator {
        <V as FoldAstPath>::fold_decorator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        <V as FoldAstPath>::fold_decorators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_default_decl(
        &mut self,
        node: DefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> DefaultDecl {
        <V as FoldAstPath>::fold_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_do_while_stmt(
        &mut self,
        node: DoWhileStmt,
        __ast_path: &mut AstKindPath,
    ) -> DoWhileStmt {
        <V as FoldAstPath>::fold_do_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt, __ast_path: &mut AstKindPath) -> EmptyStmt {
        <V as FoldAstPath>::fold_empty_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll, __ast_path: &mut AstKindPath) -> ExportAll {
        <V as FoldAstPath>::fold_export_all(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl, __ast_path: &mut AstKindPath) -> ExportDecl {
        <V as FoldAstPath>::fold_export_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        <V as FoldAstPath>::fold_export_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        <V as FoldAstPath>::fold_export_default_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        <V as FoldAstPath>::fold_export_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        <V as FoldAstPath>::fold_export_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        <V as FoldAstPath>::fold_export_namespace_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        <V as FoldAstPath>::fold_export_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        <V as FoldAstPath>::fold_export_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr, __ast_path: &mut AstKindPath) -> Expr {
        <V as FoldAstPath>::fold_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        <V as FoldAstPath>::fold_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        <V as FoldAstPath>::fold_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt, __ast_path: &mut AstKindPath) -> ExprStmt {
        <V as FoldAstPath>::fold_expr_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, __ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        <V as FoldAstPath>::fold_exprs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl, __ast_path: &mut AstKindPath) -> FnDecl {
        <V as FoldAstPath>::fold_fn_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr, __ast_path: &mut AstKindPath) -> FnExpr {
        <V as FoldAstPath>::fold_fn_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead, __ast_path: &mut AstKindPath) -> ForHead {
        <V as FoldAstPath>::fold_for_head(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt, __ast_path: &mut AstKindPath) -> ForInStmt {
        <V as FoldAstPath>::fold_for_in_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt, __ast_path: &mut AstKindPath) -> ForOfStmt {
        <V as FoldAstPath>::fold_for_of_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt, __ast_path: &mut AstKindPath) -> ForStmt {
        <V as FoldAstPath>::fold_for_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_function(&mut self, node: Function, __ast_path: &mut AstKindPath) -> Function {
        <V as FoldAstPath>::fold_function(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp, __ast_path: &mut AstKindPath) -> GetterProp {
        <V as FoldAstPath>::fold_getter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident, __ast_path: &mut AstKindPath) -> Ident {
        <V as FoldAstPath>::fold_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName, __ast_path: &mut AstKindPath) -> IdentName {
        <V as FoldAstPath>::fold_ident_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt, __ast_path: &mut AstKindPath) -> IfStmt {
        <V as FoldAstPath>::fold_if_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import(&mut self, node: Import, __ast_path: &mut AstKindPath) -> Import {
        <V as FoldAstPath>::fold_import(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl, __ast_path: &mut AstKindPath) -> ImportDecl {
        <V as FoldAstPath>::fold_import_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        <V as FoldAstPath>::fold_import_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        <V as FoldAstPath>::fold_import_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_phase(
        &mut self,
        node: ImportPhase,
        __ast_path: &mut AstKindPath,
    ) -> ImportPhase {
        <V as FoldAstPath>::fold_import_phase(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        <V as FoldAstPath>::fold_import_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        <V as FoldAstPath>::fold_import_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        <V as FoldAstPath>::fold_import_star_as_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith, __ast_path: &mut AstKindPath) -> ImportWith {
        <V as FoldAstPath>::fold_import_with(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        <V as FoldAstPath>::fold_import_with_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        <V as FoldAstPath>::fold_import_with_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid, __ast_path: &mut AstKindPath) -> Invalid {
        <V as FoldAstPath>::fold_invalid(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr, __ast_path: &mut AstKindPath) -> JSXAttr {
        <V as FoldAstPath>::fold_jsx_attr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_name(
        &mut self,
        node: JSXAttrName,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrName {
        <V as FoldAstPath>::fold_jsx_attr_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        <V as FoldAstPath>::fold_jsx_attr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        <V as FoldAstPath>::fold_jsx_attr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        <V as FoldAstPath>::fold_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        <V as FoldAstPath>::fold_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        <V as FoldAstPath>::fold_jsx_closing_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement, __ast_path: &mut AstKindPath) -> JSXElement {
        <V as FoldAstPath>::fold_jsx_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        <V as FoldAstPath>::fold_jsx_element_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        <V as FoldAstPath>::fold_jsx_element_childs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        <V as FoldAstPath>::fold_jsx_element_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        <V as FoldAstPath>::fold_jsx_empty_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr, __ast_path: &mut AstKindPath) -> JSXExpr {
        <V as FoldAstPath>::fold_jsx_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        <V as FoldAstPath>::fold_jsx_expr_container(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_fragment(
        &mut self,
        node: JSXFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXFragment {
        <V as FoldAstPath>::fold_jsx_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        <V as FoldAstPath>::fold_jsx_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        <V as FoldAstPath>::fold_jsx_namespaced_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject, __ast_path: &mut AstKindPath) -> JSXObject {
        <V as FoldAstPath>::fold_jsx_object(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        <V as FoldAstPath>::fold_jsx_opening_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        <V as FoldAstPath>::fold_jsx_opening_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        <V as FoldAstPath>::fold_jsx_spread_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText, __ast_path: &mut AstKindPath) -> JSXText {
        <V as FoldAstPath>::fold_jsx_text(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_key(&mut self, node: Key, __ast_path: &mut AstKindPath) -> Key {
        <V as FoldAstPath>::fold_key(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        <V as FoldAstPath>::fold_key_value_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        <V as FoldAstPath>::fold_key_value_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_labeled_stmt(
        &mut self,
        node: LabeledStmt,
        __ast_path: &mut AstKindPath,
    ) -> LabeledStmt {
        <V as FoldAstPath>::fold_labeled_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit, __ast_path: &mut AstKindPath) -> Lit {
        <V as FoldAstPath>::fold_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr, __ast_path: &mut AstKindPath) -> MemberExpr {
        <V as FoldAstPath>::fold_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp, __ast_path: &mut AstKindPath) -> MemberProp {
        <V as FoldAstPath>::fold_member_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        <V as FoldAstPath>::fold_meta_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        <V as FoldAstPath>::fold_meta_prop_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind, __ast_path: &mut AstKindPath) -> MethodKind {
        <V as FoldAstPath>::fold_method_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp, __ast_path: &mut AstKindPath) -> MethodProp {
        <V as FoldAstPath>::fold_method_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module(&mut self, node: Module, __ast_path: &mut AstKindPath) -> Module {
        <V as FoldAstPath>::fold_module(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl, __ast_path: &mut AstKindPath) -> ModuleDecl {
        <V as FoldAstPath>::fold_module_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        <V as FoldAstPath>::fold_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem, __ast_path: &mut AstKindPath) -> ModuleItem {
        <V as FoldAstPath>::fold_module_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        <V as FoldAstPath>::fold_module_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_named_export(
        &mut self,
        node: NamedExport,
        __ast_path: &mut AstKindPath,
    ) -> NamedExport {
        <V as FoldAstPath>::fold_named_export(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr, __ast_path: &mut AstKindPath) -> NewExpr {
        <V as FoldAstPath>::fold_new_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_null(&mut self, node: Null, __ast_path: &mut AstKindPath) -> Null {
        <V as FoldAstPath>::fold_null(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_number(&mut self, node: Number, __ast_path: &mut AstKindPath) -> Number {
        <V as FoldAstPath>::fold_number(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit, __ast_path: &mut AstKindPath) -> ObjectLit {
        <V as FoldAstPath>::fold_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat, __ast_path: &mut AstKindPath) -> ObjectPat {
        <V as FoldAstPath>::fold_object_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        <V as FoldAstPath>::fold_object_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        <V as FoldAstPath>::fold_object_pat_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        <V as FoldAstPath>::fold_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        <V as FoldAstPath>::fold_opt_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall, __ast_path: &mut AstKindPath) -> OptCall {
        <V as FoldAstPath>::fold_opt_call(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        <V as FoldAstPath>::fold_opt_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        __ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        <V as FoldAstPath>::fold_opt_chain_base(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        __ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        <V as FoldAstPath>::fold_opt_chain_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        <V as FoldAstPath>::fold_opt_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        <V as FoldAstPath>::fold_opt_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        <V as FoldAstPath>::fold_opt_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_ident(
        &mut self,
        node: Option<Ident>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Ident> {
        <V as FoldAstPath>::fold_opt_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        <V as FoldAstPath>::fold_opt_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        <V as FoldAstPath>::fold_opt_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        <V as FoldAstPath>::fold_opt_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        <V as FoldAstPath>::fold_opt_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>, __ast_path: &mut AstKindPath) -> Option<Pat> {
        <V as FoldAstPath>::fold_opt_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        <V as FoldAstPath>::fold_opt_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        <V as FoldAstPath>::fold_opt_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        <V as FoldAstPath>::fold_opt_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        <V as FoldAstPath>::fold_opt_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        <V as FoldAstPath>::fold_opt_vec_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        <V as FoldAstPath>::fold_opt_vec_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_param(&mut self, node: Param, __ast_path: &mut AstKindPath) -> Param {
        <V as FoldAstPath>::fold_param(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        <V as FoldAstPath>::fold_param_or_ts_param_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        <V as FoldAstPath>::fold_param_or_ts_param_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>, __ast_path: &mut AstKindPath) -> Vec<Param> {
        <V as FoldAstPath>::fold_params(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr, __ast_path: &mut AstKindPath) -> ParenExpr {
        <V as FoldAstPath>::fold_paren_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat, __ast_path: &mut AstKindPath) -> Pat {
        <V as FoldAstPath>::fold_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>, __ast_path: &mut AstKindPath) -> Vec<Pat> {
        <V as FoldAstPath>::fold_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        __ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        <V as FoldAstPath>::fold_private_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_private_name(
        &mut self,
        node: PrivateName,
        __ast_path: &mut AstKindPath,
    ) -> PrivateName {
        <V as FoldAstPath>::fold_private_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_private_prop(
        &mut self,
        node: PrivateProp,
        __ast_path: &mut AstKindPath,
    ) -> PrivateProp {
        <V as FoldAstPath>::fold_private_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_program(&mut self, node: Program, __ast_path: &mut AstKindPath) -> Program {
        <V as FoldAstPath>::fold_program(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop, __ast_path: &mut AstKindPath) -> Prop {
        <V as FoldAstPath>::fold_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName, __ast_path: &mut AstKindPath) -> PropName {
        <V as FoldAstPath>::fold_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        <V as FoldAstPath>::fold_prop_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        <V as FoldAstPath>::fold_prop_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex, __ast_path: &mut AstKindPath) -> Regex {
        <V as FoldAstPath>::fold_regex(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat, __ast_path: &mut AstKindPath) -> RestPat {
        <V as FoldAstPath>::fold_rest_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt, __ast_path: &mut AstKindPath) -> ReturnStmt {
        <V as FoldAstPath>::fold_return_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_script(&mut self, node: Script, __ast_path: &mut AstKindPath) -> Script {
        <V as FoldAstPath>::fold_script(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr, __ast_path: &mut AstKindPath) -> SeqExpr {
        <V as FoldAstPath>::fold_seq_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp, __ast_path: &mut AstKindPath) -> SetterProp {
        <V as FoldAstPath>::fold_setter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        <V as FoldAstPath>::fold_simple_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        <V as FoldAstPath>::fold_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        __ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        <V as FoldAstPath>::fold_spread_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_static_block(
        &mut self,
        node: StaticBlock,
        __ast_path: &mut AstKindPath,
    ) -> StaticBlock {
        <V as FoldAstPath>::fold_static_block(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt, __ast_path: &mut AstKindPath) -> Stmt {
        <V as FoldAstPath>::fold_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>, __ast_path: &mut AstKindPath) -> Vec<Stmt> {
        <V as FoldAstPath>::fold_stmts(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_str(&mut self, node: Str, __ast_path: &mut AstKindPath) -> Str {
        <V as FoldAstPath>::fold_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_super(&mut self, node: Super, __ast_path: &mut AstKindPath) -> Super {
        <V as FoldAstPath>::fold_super(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp, __ast_path: &mut AstKindPath) -> SuperProp {
        <V as FoldAstPath>::fold_super_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        <V as FoldAstPath>::fold_super_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase, __ast_path: &mut AstKindPath) -> SwitchCase {
        <V as FoldAstPath>::fold_switch_case(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        <V as FoldAstPath>::fold_switch_cases(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt, __ast_path: &mut AstKindPath) -> SwitchStmt {
        <V as FoldAstPath>::fold_switch_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        <V as FoldAstPath>::fold_syntax_context(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl, __ast_path: &mut AstKindPath) -> TaggedTpl {
        <V as FoldAstPath>::fold_tagged_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr, __ast_path: &mut AstKindPath) -> ThisExpr {
        <V as FoldAstPath>::fold_this_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt, __ast_path: &mut AstKindPath) -> ThrowStmt {
        <V as FoldAstPath>::fold_throw_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl, __ast_path: &mut AstKindPath) -> Tpl {
        <V as FoldAstPath>::fold_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement, __ast_path: &mut AstKindPath) -> TplElement {
        <V as FoldAstPath>::fold_tpl_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        <V as FoldAstPath>::fold_tpl_elements(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        <V as FoldAstPath>::fold_true_plus_minus(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt, __ast_path: &mut AstKindPath) -> TryStmt {
        <V as FoldAstPath>::fold_try_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr, __ast_path: &mut AstKindPath) -> UnaryExpr {
        <V as FoldAstPath>::fold_unary_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp, __ast_path: &mut AstKindPath) -> UnaryOp {
        <V as FoldAstPath>::fold_unary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr, __ast_path: &mut AstKindPath) -> UpdateExpr {
        <V as FoldAstPath>::fold_update_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp, __ast_path: &mut AstKindPath) -> UpdateOp {
        <V as FoldAstPath>::fold_update_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl, __ast_path: &mut AstKindPath) -> UsingDecl {
        <V as FoldAstPath>::fold_using_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl, __ast_path: &mut AstKindPath) -> VarDecl {
        <V as FoldAstPath>::fold_var_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_decl_kind(
        &mut self,
        node: VarDeclKind,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclKind {
        <V as FoldAstPath>::fold_var_decl_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        <V as FoldAstPath>::fold_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        <V as FoldAstPath>::fold_var_declarator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        <V as FoldAstPath>::fold_var_declarators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt, __ast_path: &mut AstKindPath) -> WhileStmt {
        <V as FoldAstPath>::fold_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt, __ast_path: &mut AstKindPath) -> WithStmt {
        <V as FoldAstPath>::fold_with_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr, __ast_path: &mut AstKindPath) -> YieldExpr {
        <V as FoldAstPath>::fold_yield_expr(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for Box<V>
where
    V: ?Sized + FoldAstPath,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit, __ast_path: &mut AstKindPath) -> ArrayLit {
        <V as FoldAstPath>::fold_array_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat, __ast_path: &mut AstKindPath) -> ArrayPat {
        <V as FoldAstPath>::fold_array_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr, __ast_path: &mut AstKindPath) -> ArrowExpr {
        <V as FoldAstPath>::fold_arrow_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr, __ast_path: &mut AstKindPath) -> AssignExpr {
        <V as FoldAstPath>::fold_assign_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp, __ast_path: &mut AstKindPath) -> AssignOp {
        <V as FoldAstPath>::fold_assign_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat, __ast_path: &mut AstKindPath) -> AssignPat {
        <V as FoldAstPath>::fold_assign_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        <V as FoldAstPath>::fold_assign_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp, __ast_path: &mut AstKindPath) -> AssignProp {
        <V as FoldAstPath>::fold_assign_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        <V as FoldAstPath>::fold_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        <V as FoldAstPath>::fold_assign_target_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        <V as FoldAstPath>::fold_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        __ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        <V as FoldAstPath>::fold_auto_accessor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr, __ast_path: &mut AstKindPath) -> AwaitExpr {
        <V as FoldAstPath>::fold_await_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt, __ast_path: &mut AstKindPath) -> BigInt {
        <V as FoldAstPath>::fold_big_int(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_big_int_value(
        &mut self,
        node: BigIntValue,
        __ast_path: &mut AstKindPath,
    ) -> BigIntValue {
        <V as FoldAstPath>::fold_big_int_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr, __ast_path: &mut AstKindPath) -> BinExpr {
        <V as FoldAstPath>::fold_bin_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp, __ast_path: &mut AstKindPath) -> BinaryOp {
        <V as FoldAstPath>::fold_binary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        __ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        <V as FoldAstPath>::fold_binding_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt, __ast_path: &mut AstKindPath) -> BlockStmt {
        <V as FoldAstPath>::fold_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        <V as FoldAstPath>::fold_block_stmt_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool, __ast_path: &mut AstKindPath) -> Bool {
        <V as FoldAstPath>::fold_bool(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt, __ast_path: &mut AstKindPath) -> BreakStmt {
        <V as FoldAstPath>::fold_break_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr, __ast_path: &mut AstKindPath) -> CallExpr {
        <V as FoldAstPath>::fold_call_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee, __ast_path: &mut AstKindPath) -> Callee {
        <V as FoldAstPath>::fold_callee(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_catch_clause(
        &mut self,
        node: CatchClause,
        __ast_path: &mut AstKindPath,
    ) -> CatchClause {
        <V as FoldAstPath>::fold_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class(&mut self, node: Class, __ast_path: &mut AstKindPath) -> Class {
        <V as FoldAstPath>::fold_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl, __ast_path: &mut AstKindPath) -> ClassDecl {
        <V as FoldAstPath>::fold_class_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr, __ast_path: &mut AstKindPath) -> ClassExpr {
        <V as FoldAstPath>::fold_class_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_member(
        &mut self,
        node: ClassMember,
        __ast_path: &mut AstKindPath,
    ) -> ClassMember {
        <V as FoldAstPath>::fold_class_member(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        <V as FoldAstPath>::fold_class_members(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_method(
        &mut self,
        node: ClassMethod,
        __ast_path: &mut AstKindPath,
    ) -> ClassMethod {
        <V as FoldAstPath>::fold_class_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp, __ast_path: &mut AstKindPath) -> ClassProp {
        <V as FoldAstPath>::fold_class_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        <V as FoldAstPath>::fold_computed_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr, __ast_path: &mut AstKindPath) -> CondExpr {
        <V as FoldAstPath>::fold_cond_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor, __ast_path: &mut AstKindPath) -> Constructor {
        <V as FoldAstPath>::fold_constructor(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        __ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        <V as FoldAstPath>::fold_continue_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        __ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        <V as FoldAstPath>::fold_debugger_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl, __ast_path: &mut AstKindPath) -> Decl {
        <V as FoldAstPath>::fold_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator, __ast_path: &mut AstKindPath) -> Decorator {
        <V as FoldAstPath>::fold_decorator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        <V as FoldAstPath>::fold_decorators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_default_decl(
        &mut self,
        node: DefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> DefaultDecl {
        <V as FoldAstPath>::fold_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_do_while_stmt(
        &mut self,
        node: DoWhileStmt,
        __ast_path: &mut AstKindPath,
    ) -> DoWhileStmt {
        <V as FoldAstPath>::fold_do_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt, __ast_path: &mut AstKindPath) -> EmptyStmt {
        <V as FoldAstPath>::fold_empty_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll, __ast_path: &mut AstKindPath) -> ExportAll {
        <V as FoldAstPath>::fold_export_all(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl, __ast_path: &mut AstKindPath) -> ExportDecl {
        <V as FoldAstPath>::fold_export_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        <V as FoldAstPath>::fold_export_default_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        <V as FoldAstPath>::fold_export_default_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        <V as FoldAstPath>::fold_export_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        <V as FoldAstPath>::fold_export_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        <V as FoldAstPath>::fold_export_namespace_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        <V as FoldAstPath>::fold_export_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        <V as FoldAstPath>::fold_export_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr, __ast_path: &mut AstKindPath) -> Expr {
        <V as FoldAstPath>::fold_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        <V as FoldAstPath>::fold_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        <V as FoldAstPath>::fold_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt, __ast_path: &mut AstKindPath) -> ExprStmt {
        <V as FoldAstPath>::fold_expr_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, __ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        <V as FoldAstPath>::fold_exprs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl, __ast_path: &mut AstKindPath) -> FnDecl {
        <V as FoldAstPath>::fold_fn_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr, __ast_path: &mut AstKindPath) -> FnExpr {
        <V as FoldAstPath>::fold_fn_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead, __ast_path: &mut AstKindPath) -> ForHead {
        <V as FoldAstPath>::fold_for_head(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt, __ast_path: &mut AstKindPath) -> ForInStmt {
        <V as FoldAstPath>::fold_for_in_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt, __ast_path: &mut AstKindPath) -> ForOfStmt {
        <V as FoldAstPath>::fold_for_of_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt, __ast_path: &mut AstKindPath) -> ForStmt {
        <V as FoldAstPath>::fold_for_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_function(&mut self, node: Function, __ast_path: &mut AstKindPath) -> Function {
        <V as FoldAstPath>::fold_function(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp, __ast_path: &mut AstKindPath) -> GetterProp {
        <V as FoldAstPath>::fold_getter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident, __ast_path: &mut AstKindPath) -> Ident {
        <V as FoldAstPath>::fold_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName, __ast_path: &mut AstKindPath) -> IdentName {
        <V as FoldAstPath>::fold_ident_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt, __ast_path: &mut AstKindPath) -> IfStmt {
        <V as FoldAstPath>::fold_if_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import(&mut self, node: Import, __ast_path: &mut AstKindPath) -> Import {
        <V as FoldAstPath>::fold_import(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl, __ast_path: &mut AstKindPath) -> ImportDecl {
        <V as FoldAstPath>::fold_import_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        <V as FoldAstPath>::fold_import_default_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        <V as FoldAstPath>::fold_import_named_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_phase(
        &mut self,
        node: ImportPhase,
        __ast_path: &mut AstKindPath,
    ) -> ImportPhase {
        <V as FoldAstPath>::fold_import_phase(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        <V as FoldAstPath>::fold_import_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        <V as FoldAstPath>::fold_import_specifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        <V as FoldAstPath>::fold_import_star_as_specifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith, __ast_path: &mut AstKindPath) -> ImportWith {
        <V as FoldAstPath>::fold_import_with(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        <V as FoldAstPath>::fold_import_with_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        <V as FoldAstPath>::fold_import_with_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid, __ast_path: &mut AstKindPath) -> Invalid {
        <V as FoldAstPath>::fold_invalid(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr, __ast_path: &mut AstKindPath) -> JSXAttr {
        <V as FoldAstPath>::fold_jsx_attr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_name(
        &mut self,
        node: JSXAttrName,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrName {
        <V as FoldAstPath>::fold_jsx_attr_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        <V as FoldAstPath>::fold_jsx_attr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        <V as FoldAstPath>::fold_jsx_attr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        <V as FoldAstPath>::fold_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        <V as FoldAstPath>::fold_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        <V as FoldAstPath>::fold_jsx_closing_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement, __ast_path: &mut AstKindPath) -> JSXElement {
        <V as FoldAstPath>::fold_jsx_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        <V as FoldAstPath>::fold_jsx_element_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        <V as FoldAstPath>::fold_jsx_element_childs(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        <V as FoldAstPath>::fold_jsx_element_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        <V as FoldAstPath>::fold_jsx_empty_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr, __ast_path: &mut AstKindPath) -> JSXExpr {
        <V as FoldAstPath>::fold_jsx_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        <V as FoldAstPath>::fold_jsx_expr_container(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_fragment(
        &mut self,
        node: JSXFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXFragment {
        <V as FoldAstPath>::fold_jsx_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        <V as FoldAstPath>::fold_jsx_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        <V as FoldAstPath>::fold_jsx_namespaced_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject, __ast_path: &mut AstKindPath) -> JSXObject {
        <V as FoldAstPath>::fold_jsx_object(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        <V as FoldAstPath>::fold_jsx_opening_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        <V as FoldAstPath>::fold_jsx_opening_fragment(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        <V as FoldAstPath>::fold_jsx_spread_child(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText, __ast_path: &mut AstKindPath) -> JSXText {
        <V as FoldAstPath>::fold_jsx_text(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_key(&mut self, node: Key, __ast_path: &mut AstKindPath) -> Key {
        <V as FoldAstPath>::fold_key(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        <V as FoldAstPath>::fold_key_value_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        <V as FoldAstPath>::fold_key_value_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_labeled_stmt(
        &mut self,
        node: LabeledStmt,
        __ast_path: &mut AstKindPath,
    ) -> LabeledStmt {
        <V as FoldAstPath>::fold_labeled_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit, __ast_path: &mut AstKindPath) -> Lit {
        <V as FoldAstPath>::fold_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr, __ast_path: &mut AstKindPath) -> MemberExpr {
        <V as FoldAstPath>::fold_member_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp, __ast_path: &mut AstKindPath) -> MemberProp {
        <V as FoldAstPath>::fold_member_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        <V as FoldAstPath>::fold_meta_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        <V as FoldAstPath>::fold_meta_prop_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind, __ast_path: &mut AstKindPath) -> MethodKind {
        <V as FoldAstPath>::fold_method_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp, __ast_path: &mut AstKindPath) -> MethodProp {
        <V as FoldAstPath>::fold_method_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module(&mut self, node: Module, __ast_path: &mut AstKindPath) -> Module {
        <V as FoldAstPath>::fold_module(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl, __ast_path: &mut AstKindPath) -> ModuleDecl {
        <V as FoldAstPath>::fold_module_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        <V as FoldAstPath>::fold_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem, __ast_path: &mut AstKindPath) -> ModuleItem {
        <V as FoldAstPath>::fold_module_item(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        <V as FoldAstPath>::fold_module_items(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_named_export(
        &mut self,
        node: NamedExport,
        __ast_path: &mut AstKindPath,
    ) -> NamedExport {
        <V as FoldAstPath>::fold_named_export(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr, __ast_path: &mut AstKindPath) -> NewExpr {
        <V as FoldAstPath>::fold_new_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_null(&mut self, node: Null, __ast_path: &mut AstKindPath) -> Null {
        <V as FoldAstPath>::fold_null(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_number(&mut self, node: Number, __ast_path: &mut AstKindPath) -> Number {
        <V as FoldAstPath>::fold_number(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit, __ast_path: &mut AstKindPath) -> ObjectLit {
        <V as FoldAstPath>::fold_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat, __ast_path: &mut AstKindPath) -> ObjectPat {
        <V as FoldAstPath>::fold_object_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        <V as FoldAstPath>::fold_object_pat_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        <V as FoldAstPath>::fold_object_pat_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        <V as FoldAstPath>::fold_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        <V as FoldAstPath>::fold_opt_block_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall, __ast_path: &mut AstKindPath) -> OptCall {
        <V as FoldAstPath>::fold_opt_call(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        <V as FoldAstPath>::fold_opt_catch_clause(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        __ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        <V as FoldAstPath>::fold_opt_chain_base(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        __ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        <V as FoldAstPath>::fold_opt_chain_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        <V as FoldAstPath>::fold_opt_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        <V as FoldAstPath>::fold_opt_expr_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        <V as FoldAstPath>::fold_opt_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_ident(
        &mut self,
        node: Option<Ident>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Ident> {
        <V as FoldAstPath>::fold_opt_ident(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        <V as FoldAstPath>::fold_opt_jsx_attr_value(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        <V as FoldAstPath>::fold_opt_jsx_closing_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        <V as FoldAstPath>::fold_opt_module_export_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        <V as FoldAstPath>::fold_opt_object_lit(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>, __ast_path: &mut AstKindPath) -> Option<Pat> {
        <V as FoldAstPath>::fold_opt_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        <V as FoldAstPath>::fold_opt_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        <V as FoldAstPath>::fold_opt_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        <V as FoldAstPath>::fold_opt_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        <V as FoldAstPath>::fold_opt_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        <V as FoldAstPath>::fold_opt_vec_expr_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        <V as FoldAstPath>::fold_opt_vec_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_param(&mut self, node: Param, __ast_path: &mut AstKindPath) -> Param {
        <V as FoldAstPath>::fold_param(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        <V as FoldAstPath>::fold_param_or_ts_param_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        <V as FoldAstPath>::fold_param_or_ts_param_props(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>, __ast_path: &mut AstKindPath) -> Vec<Param> {
        <V as FoldAstPath>::fold_params(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr, __ast_path: &mut AstKindPath) -> ParenExpr {
        <V as FoldAstPath>::fold_paren_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat, __ast_path: &mut AstKindPath) -> Pat {
        <V as FoldAstPath>::fold_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>, __ast_path: &mut AstKindPath) -> Vec<Pat> {
        <V as FoldAstPath>::fold_pats(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        __ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        <V as FoldAstPath>::fold_private_method(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_private_name(
        &mut self,
        node: PrivateName,
        __ast_path: &mut AstKindPath,
    ) -> PrivateName {
        <V as FoldAstPath>::fold_private_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_private_prop(
        &mut self,
        node: PrivateProp,
        __ast_path: &mut AstKindPath,
    ) -> PrivateProp {
        <V as FoldAstPath>::fold_private_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_program(&mut self, node: Program, __ast_path: &mut AstKindPath) -> Program {
        <V as FoldAstPath>::fold_program(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop, __ast_path: &mut AstKindPath) -> Prop {
        <V as FoldAstPath>::fold_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName, __ast_path: &mut AstKindPath) -> PropName {
        <V as FoldAstPath>::fold_prop_name(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        <V as FoldAstPath>::fold_prop_or_spread(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        <V as FoldAstPath>::fold_prop_or_spreads(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex, __ast_path: &mut AstKindPath) -> Regex {
        <V as FoldAstPath>::fold_regex(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat, __ast_path: &mut AstKindPath) -> RestPat {
        <V as FoldAstPath>::fold_rest_pat(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt, __ast_path: &mut AstKindPath) -> ReturnStmt {
        <V as FoldAstPath>::fold_return_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_script(&mut self, node: Script, __ast_path: &mut AstKindPath) -> Script {
        <V as FoldAstPath>::fold_script(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr, __ast_path: &mut AstKindPath) -> SeqExpr {
        <V as FoldAstPath>::fold_seq_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp, __ast_path: &mut AstKindPath) -> SetterProp {
        <V as FoldAstPath>::fold_setter_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        <V as FoldAstPath>::fold_simple_assign_target(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        <V as FoldAstPath>::fold_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        __ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        <V as FoldAstPath>::fold_spread_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_static_block(
        &mut self,
        node: StaticBlock,
        __ast_path: &mut AstKindPath,
    ) -> StaticBlock {
        <V as FoldAstPath>::fold_static_block(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt, __ast_path: &mut AstKindPath) -> Stmt {
        <V as FoldAstPath>::fold_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>, __ast_path: &mut AstKindPath) -> Vec<Stmt> {
        <V as FoldAstPath>::fold_stmts(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_str(&mut self, node: Str, __ast_path: &mut AstKindPath) -> Str {
        <V as FoldAstPath>::fold_str(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_super(&mut self, node: Super, __ast_path: &mut AstKindPath) -> Super {
        <V as FoldAstPath>::fold_super(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp, __ast_path: &mut AstKindPath) -> SuperProp {
        <V as FoldAstPath>::fold_super_prop(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        <V as FoldAstPath>::fold_super_prop_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase, __ast_path: &mut AstKindPath) -> SwitchCase {
        <V as FoldAstPath>::fold_switch_case(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        <V as FoldAstPath>::fold_switch_cases(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt, __ast_path: &mut AstKindPath) -> SwitchStmt {
        <V as FoldAstPath>::fold_switch_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        <V as FoldAstPath>::fold_syntax_context(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl, __ast_path: &mut AstKindPath) -> TaggedTpl {
        <V as FoldAstPath>::fold_tagged_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr, __ast_path: &mut AstKindPath) -> ThisExpr {
        <V as FoldAstPath>::fold_this_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt, __ast_path: &mut AstKindPath) -> ThrowStmt {
        <V as FoldAstPath>::fold_throw_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl, __ast_path: &mut AstKindPath) -> Tpl {
        <V as FoldAstPath>::fold_tpl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement, __ast_path: &mut AstKindPath) -> TplElement {
        <V as FoldAstPath>::fold_tpl_element(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        <V as FoldAstPath>::fold_tpl_elements(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        <V as FoldAstPath>::fold_true_plus_minus(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt, __ast_path: &mut AstKindPath) -> TryStmt {
        <V as FoldAstPath>::fold_try_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr, __ast_path: &mut AstKindPath) -> UnaryExpr {
        <V as FoldAstPath>::fold_unary_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp, __ast_path: &mut AstKindPath) -> UnaryOp {
        <V as FoldAstPath>::fold_unary_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr, __ast_path: &mut AstKindPath) -> UpdateExpr {
        <V as FoldAstPath>::fold_update_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp, __ast_path: &mut AstKindPath) -> UpdateOp {
        <V as FoldAstPath>::fold_update_op(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl, __ast_path: &mut AstKindPath) -> UsingDecl {
        <V as FoldAstPath>::fold_using_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl, __ast_path: &mut AstKindPath) -> VarDecl {
        <V as FoldAstPath>::fold_var_decl(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_decl_kind(
        &mut self,
        node: VarDeclKind,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclKind {
        <V as FoldAstPath>::fold_var_decl_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        <V as FoldAstPath>::fold_var_decl_or_expr(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        <V as FoldAstPath>::fold_var_declarator(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        <V as FoldAstPath>::fold_var_declarators(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt, __ast_path: &mut AstKindPath) -> WhileStmt {
        <V as FoldAstPath>::fold_while_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt, __ast_path: &mut AstKindPath) -> WithStmt {
        <V as FoldAstPath>::fold_with_stmt(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr, __ast_path: &mut AstKindPath) -> YieldExpr {
        <V as FoldAstPath>::fold_yield_expr(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> FoldAstPath for ::swc_visit::Either<A, B>
where
    A: FoldAstPath,
    B: FoldAstPath,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit, __ast_path: &mut AstKindPath) -> ArrayLit {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_array_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_array_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat, __ast_path: &mut AstKindPath) -> ArrayPat {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_array_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_array_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr, __ast_path: &mut AstKindPath) -> ArrowExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_arrow_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_arrow_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr, __ast_path: &mut AstKindPath) -> AssignExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp, __ast_path: &mut AstKindPath) -> AssignOp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat, __ast_path: &mut AstKindPath) -> AssignPat {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp, __ast_path: &mut AstKindPath) -> AssignProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_target(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_target(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_target_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_target_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_atom(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_atom(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        __ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_auto_accessor(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_auto_accessor(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr, __ast_path: &mut AstKindPath) -> AwaitExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_await_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_await_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt, __ast_path: &mut AstKindPath) -> BigInt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_big_int(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_big_int(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_big_int_value(
        &mut self,
        node: BigIntValue,
        __ast_path: &mut AstKindPath,
    ) -> BigIntValue {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_big_int_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_big_int_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr, __ast_path: &mut AstKindPath) -> BinExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_bin_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_bin_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp, __ast_path: &mut AstKindPath) -> BinaryOp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_binary_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_binary_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        __ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_binding_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_binding_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt, __ast_path: &mut AstKindPath) -> BlockStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_block_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_block_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_block_stmt_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_block_stmt_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool, __ast_path: &mut AstKindPath) -> Bool {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_bool(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_bool(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt, __ast_path: &mut AstKindPath) -> BreakStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_break_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_break_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr, __ast_path: &mut AstKindPath) -> CallExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_call_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_call_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee, __ast_path: &mut AstKindPath) -> Callee {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_callee(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_callee(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_catch_clause(
        &mut self,
        node: CatchClause,
        __ast_path: &mut AstKindPath,
    ) -> CatchClause {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_catch_clause(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_catch_clause(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class(&mut self, node: Class, __ast_path: &mut AstKindPath) -> Class {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_class(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_class(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl, __ast_path: &mut AstKindPath) -> ClassDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr, __ast_path: &mut AstKindPath) -> ClassExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_member(
        &mut self,
        node: ClassMember,
        __ast_path: &mut AstKindPath,
    ) -> ClassMember {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_member(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_member(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_members(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_members(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_method(
        &mut self,
        node: ClassMethod,
        __ast_path: &mut AstKindPath,
    ) -> ClassMethod {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_method(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_method(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp, __ast_path: &mut AstKindPath) -> ClassProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_computed_prop_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_computed_prop_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr, __ast_path: &mut AstKindPath) -> CondExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_cond_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_cond_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor, __ast_path: &mut AstKindPath) -> Constructor {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_constructor(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_constructor(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        __ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_continue_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_continue_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        __ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_debugger_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_debugger_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl, __ast_path: &mut AstKindPath) -> Decl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_decl(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_decl(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator, __ast_path: &mut AstKindPath) -> Decorator {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_decorator(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_decorator(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_decorators(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_decorators(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_default_decl(
        &mut self,
        node: DefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> DefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_default_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_default_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_do_while_stmt(
        &mut self,
        node: DoWhileStmt,
        __ast_path: &mut AstKindPath,
    ) -> DoWhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_do_while_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_do_while_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt, __ast_path: &mut AstKindPath) -> EmptyStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_empty_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_empty_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll, __ast_path: &mut AstKindPath) -> ExportAll {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_all(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_all(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl, __ast_path: &mut AstKindPath) -> ExportDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_default_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_default_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_default_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_default_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_default_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_default_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_named_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_named_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_namespace_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_namespace_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_specifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_specifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr, __ast_path: &mut AstKindPath) -> Expr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_expr(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_expr(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_expr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_expr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt, __ast_path: &mut AstKindPath) -> ExprStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_expr_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_expr_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, __ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_exprs(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_exprs(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl, __ast_path: &mut AstKindPath) -> FnDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_fn_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_fn_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr, __ast_path: &mut AstKindPath) -> FnExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_fn_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_fn_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead, __ast_path: &mut AstKindPath) -> ForHead {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_for_head(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_for_head(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt, __ast_path: &mut AstKindPath) -> ForInStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_for_in_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_for_in_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt, __ast_path: &mut AstKindPath) -> ForOfStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_for_of_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_for_of_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt, __ast_path: &mut AstKindPath) -> ForStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_for_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_for_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_function(&mut self, node: Function, __ast_path: &mut AstKindPath) -> Function {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_function(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_function(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp, __ast_path: &mut AstKindPath) -> GetterProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_getter_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_getter_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident, __ast_path: &mut AstKindPath) -> Ident {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ident(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ident(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName, __ast_path: &mut AstKindPath) -> IdentName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ident_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ident_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt, __ast_path: &mut AstKindPath) -> IfStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_if_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_if_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import(&mut self, node: Import, __ast_path: &mut AstKindPath) -> Import {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_import(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl, __ast_path: &mut AstKindPath) -> ImportDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_default_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_default_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_named_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_named_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_phase(
        &mut self,
        node: ImportPhase,
        __ast_path: &mut AstKindPath,
    ) -> ImportPhase {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_phase(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_phase(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_specifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_specifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_star_as_specifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_star_as_specifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith, __ast_path: &mut AstKindPath) -> ImportWith {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_with(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_with(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_with_item(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_with_item(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_with_items(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_with_items(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid, __ast_path: &mut AstKindPath) -> Invalid {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_invalid(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_invalid(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr, __ast_path: &mut AstKindPath) -> JSXAttr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_attr_name(
        &mut self,
        node: JSXAttrName,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_closing_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_closing_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_closing_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_closing_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement, __ast_path: &mut AstKindPath) -> JSXElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_element_child(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element_child(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_element_childs(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element_childs(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_element_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_empty_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_empty_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr, __ast_path: &mut AstKindPath) -> JSXExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_expr_container(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_expr_container(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_fragment(
        &mut self,
        node: JSXFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXFragment {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_member_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_member_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_namespaced_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_namespaced_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject, __ast_path: &mut AstKindPath) -> JSXObject {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_object(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_object(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_opening_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_opening_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_opening_fragment(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_opening_fragment(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_spread_child(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_spread_child(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText, __ast_path: &mut AstKindPath) -> JSXText {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_text(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_text(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_key(&mut self, node: Key, __ast_path: &mut AstKindPath) -> Key {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_key(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_key(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_key_value_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_key_value_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_key_value_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_key_value_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_labeled_stmt(
        &mut self,
        node: LabeledStmt,
        __ast_path: &mut AstKindPath,
    ) -> LabeledStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_labeled_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_labeled_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit, __ast_path: &mut AstKindPath) -> Lit {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_lit(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_lit(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr, __ast_path: &mut AstKindPath) -> MemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_member_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_member_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp, __ast_path: &mut AstKindPath) -> MemberProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_member_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_member_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_meta_prop_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_meta_prop_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_meta_prop_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_meta_prop_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind, __ast_path: &mut AstKindPath) -> MethodKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_method_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_method_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp, __ast_path: &mut AstKindPath) -> MethodProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_method_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_method_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_module(&mut self, node: Module, __ast_path: &mut AstKindPath) -> Module {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_module(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl, __ast_path: &mut AstKindPath) -> ModuleDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_module_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_module_export_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_export_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem, __ast_path: &mut AstKindPath) -> ModuleItem {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_module_item(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_item(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_module_items(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_items(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_named_export(
        &mut self,
        node: NamedExport,
        __ast_path: &mut AstKindPath,
    ) -> NamedExport {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_named_export(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_named_export(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr, __ast_path: &mut AstKindPath) -> NewExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_new_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_new_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_null(&mut self, node: Null, __ast_path: &mut AstKindPath) -> Null {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_null(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_null(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_number(&mut self, node: Number, __ast_path: &mut AstKindPath) -> Number {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_number(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_number(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit, __ast_path: &mut AstKindPath) -> ObjectLit {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_object_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_object_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat, __ast_path: &mut AstKindPath) -> ObjectPat {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_object_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_object_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_object_pat_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_object_pat_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_object_pat_props(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_object_pat_props(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_block_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_block_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall, __ast_path: &mut AstKindPath) -> OptCall {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_call(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_call(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_catch_clause(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_catch_clause(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        __ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_chain_base(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_chain_base(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        __ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_chain_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_chain_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_expr_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_expr_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_ident(
        &mut self,
        node: Option<Ident>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Ident> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_ident(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_ident(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_jsx_attr_value(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_jsx_attr_value(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_jsx_closing_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_jsx_closing_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_module_export_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_module_export_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_object_lit(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_object_lit(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>, __ast_path: &mut AstKindPath) -> Option<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_span(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_span(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_str(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_str(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_var_decl_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_var_decl_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_vec_expr_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_vec_expr_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_vec_pats(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_vec_pats(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_param(&mut self, node: Param, __ast_path: &mut AstKindPath) -> Param {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_param(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_param(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_param_or_ts_param_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_param_or_ts_param_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_param_or_ts_param_props(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_param_or_ts_param_props(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>, __ast_path: &mut AstKindPath) -> Vec<Param> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_params(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_params(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr, __ast_path: &mut AstKindPath) -> ParenExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_paren_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_paren_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat, __ast_path: &mut AstKindPath) -> Pat {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_pat(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_pat(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>, __ast_path: &mut AstKindPath) -> Vec<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_pats(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_pats(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        __ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_private_method(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_private_method(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_private_name(
        &mut self,
        node: PrivateName,
        __ast_path: &mut AstKindPath,
    ) -> PrivateName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_private_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_private_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_private_prop(
        &mut self,
        node: PrivateProp,
        __ast_path: &mut AstKindPath,
    ) -> PrivateProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_private_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_private_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_program(&mut self, node: Program, __ast_path: &mut AstKindPath) -> Program {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_program(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_program(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop, __ast_path: &mut AstKindPath) -> Prop {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_prop(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_prop(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName, __ast_path: &mut AstKindPath) -> PropName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_prop_name(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_prop_name(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_prop_or_spread(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_prop_or_spread(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_prop_or_spreads(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_prop_or_spreads(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex, __ast_path: &mut AstKindPath) -> Regex {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_regex(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_regex(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat, __ast_path: &mut AstKindPath) -> RestPat {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_rest_pat(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_rest_pat(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt, __ast_path: &mut AstKindPath) -> ReturnStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_return_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_return_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_script(&mut self, node: Script, __ast_path: &mut AstKindPath) -> Script {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_script(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_script(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr, __ast_path: &mut AstKindPath) -> SeqExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_seq_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_seq_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp, __ast_path: &mut AstKindPath) -> SetterProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_setter_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_setter_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_simple_assign_target(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_simple_assign_target(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_span(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_span(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        __ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_spread_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_spread_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_static_block(
        &mut self,
        node: StaticBlock,
        __ast_path: &mut AstKindPath,
    ) -> StaticBlock {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_static_block(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_static_block(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt, __ast_path: &mut AstKindPath) -> Stmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_stmt(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_stmt(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>, __ast_path: &mut AstKindPath) -> Vec<Stmt> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_stmts(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_stmts(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_str(&mut self, node: Str, __ast_path: &mut AstKindPath) -> Str {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_str(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_str(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_super(&mut self, node: Super, __ast_path: &mut AstKindPath) -> Super {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_super(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_super(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp, __ast_path: &mut AstKindPath) -> SuperProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_super_prop(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_super_prop(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_super_prop_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_super_prop_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase, __ast_path: &mut AstKindPath) -> SwitchCase {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_switch_case(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_switch_case(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_switch_cases(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_switch_cases(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt, __ast_path: &mut AstKindPath) -> SwitchStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_switch_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_switch_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_syntax_context(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_syntax_context(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl, __ast_path: &mut AstKindPath) -> TaggedTpl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_tagged_tpl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_tagged_tpl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr, __ast_path: &mut AstKindPath) -> ThisExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_this_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_this_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt, __ast_path: &mut AstKindPath) -> ThrowStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_throw_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_throw_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl, __ast_path: &mut AstKindPath) -> Tpl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_tpl(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_tpl(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement, __ast_path: &mut AstKindPath) -> TplElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_tpl_element(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_tpl_element(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_tpl_elements(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_tpl_elements(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_true_plus_minus(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_true_plus_minus(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt, __ast_path: &mut AstKindPath) -> TryStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_try_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_try_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr, __ast_path: &mut AstKindPath) -> UnaryExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_unary_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_unary_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp, __ast_path: &mut AstKindPath) -> UnaryOp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_unary_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_unary_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr, __ast_path: &mut AstKindPath) -> UpdateExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_update_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_update_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp, __ast_path: &mut AstKindPath) -> UpdateOp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_update_op(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_update_op(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl, __ast_path: &mut AstKindPath) -> UsingDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_using_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_using_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl, __ast_path: &mut AstKindPath) -> VarDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_decl(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_decl(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_var_decl_kind(
        &mut self,
        node: VarDeclKind,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_decl_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_decl_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_decl_or_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_decl_or_expr(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_declarator(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_declarator(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_declarators(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_declarators(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt, __ast_path: &mut AstKindPath) -> WhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_while_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_while_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt, __ast_path: &mut AstKindPath) -> WithStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_with_stmt(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_with_stmt(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr, __ast_path: &mut AstKindPath) -> YieldExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_yield_expr(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_yield_expr(visitor, node, __ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for ::swc_visit::Optional<V>
where
    V: FoldAstPath,
{
    #[inline]
    fn fold_array_lit(&mut self, node: ArrayLit, __ast_path: &mut AstKindPath) -> ArrayLit {
        if self.enabled {
            <V as FoldAstPath>::fold_array_lit(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_array_pat(&mut self, node: ArrayPat, __ast_path: &mut AstKindPath) -> ArrayPat {
        if self.enabled {
            <V as FoldAstPath>::fold_array_pat(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_arrow_expr(&mut self, node: ArrowExpr, __ast_path: &mut AstKindPath) -> ArrowExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_arrow_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_expr(&mut self, node: AssignExpr, __ast_path: &mut AstKindPath) -> AssignExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_assign_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_op(&mut self, node: AssignOp, __ast_path: &mut AstKindPath) -> AssignOp {
        if self.enabled {
            <V as FoldAstPath>::fold_assign_op(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_pat(&mut self, node: AssignPat, __ast_path: &mut AstKindPath) -> AssignPat {
        if self.enabled {
            <V as FoldAstPath>::fold_assign_pat(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        __ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        if self.enabled {
            <V as FoldAstPath>::fold_assign_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_prop(&mut self, node: AssignProp, __ast_path: &mut AstKindPath) -> AssignProp {
        if self.enabled {
            <V as FoldAstPath>::fold_assign_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        if self.enabled {
            <V as FoldAstPath>::fold_assign_target(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        __ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        if self.enabled {
            <V as FoldAstPath>::fold_assign_target_pat(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        if self.enabled {
            <V as FoldAstPath>::fold_atom(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        __ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        if self.enabled {
            <V as FoldAstPath>::fold_auto_accessor(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_await_expr(&mut self, node: AwaitExpr, __ast_path: &mut AstKindPath) -> AwaitExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_await_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_big_int(&mut self, node: BigInt, __ast_path: &mut AstKindPath) -> BigInt {
        if self.enabled {
            <V as FoldAstPath>::fold_big_int(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_big_int_value(
        &mut self,
        node: BigIntValue,
        __ast_path: &mut AstKindPath,
    ) -> BigIntValue {
        if self.enabled {
            <V as FoldAstPath>::fold_big_int_value(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_bin_expr(&mut self, node: BinExpr, __ast_path: &mut AstKindPath) -> BinExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_bin_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_binary_op(&mut self, node: BinaryOp, __ast_path: &mut AstKindPath) -> BinaryOp {
        if self.enabled {
            <V as FoldAstPath>::fold_binary_op(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        __ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        if self.enabled {
            <V as FoldAstPath>::fold_binding_ident(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_block_stmt(&mut self, node: BlockStmt, __ast_path: &mut AstKindPath) -> BlockStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_block_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_block_stmt_or_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_bool(&mut self, node: Bool, __ast_path: &mut AstKindPath) -> Bool {
        if self.enabled {
            <V as FoldAstPath>::fold_bool(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_break_stmt(&mut self, node: BreakStmt, __ast_path: &mut AstKindPath) -> BreakStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_break_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_call_expr(&mut self, node: CallExpr, __ast_path: &mut AstKindPath) -> CallExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_call_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_callee(&mut self, node: Callee, __ast_path: &mut AstKindPath) -> Callee {
        if self.enabled {
            <V as FoldAstPath>::fold_callee(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_catch_clause(
        &mut self,
        node: CatchClause,
        __ast_path: &mut AstKindPath,
    ) -> CatchClause {
        if self.enabled {
            <V as FoldAstPath>::fold_catch_clause(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class(&mut self, node: Class, __ast_path: &mut AstKindPath) -> Class {
        if self.enabled {
            <V as FoldAstPath>::fold_class(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_decl(&mut self, node: ClassDecl, __ast_path: &mut AstKindPath) -> ClassDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_class_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_expr(&mut self, node: ClassExpr, __ast_path: &mut AstKindPath) -> ClassExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_class_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_member(
        &mut self,
        node: ClassMember,
        __ast_path: &mut AstKindPath,
    ) -> ClassMember {
        if self.enabled {
            <V as FoldAstPath>::fold_class_member(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        if self.enabled {
            <V as FoldAstPath>::fold_class_members(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_method(
        &mut self,
        node: ClassMethod,
        __ast_path: &mut AstKindPath,
    ) -> ClassMethod {
        if self.enabled {
            <V as FoldAstPath>::fold_class_method(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_prop(&mut self, node: ClassProp, __ast_path: &mut AstKindPath) -> ClassProp {
        if self.enabled {
            <V as FoldAstPath>::fold_class_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        __ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        if self.enabled {
            <V as FoldAstPath>::fold_computed_prop_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_cond_expr(&mut self, node: CondExpr, __ast_path: &mut AstKindPath) -> CondExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_cond_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_constructor(&mut self, node: Constructor, __ast_path: &mut AstKindPath) -> Constructor {
        if self.enabled {
            <V as FoldAstPath>::fold_constructor(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        __ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_continue_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        __ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_debugger_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_decl(&mut self, node: Decl, __ast_path: &mut AstKindPath) -> Decl {
        if self.enabled {
            <V as FoldAstPath>::fold_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_decorator(&mut self, node: Decorator, __ast_path: &mut AstKindPath) -> Decorator {
        if self.enabled {
            <V as FoldAstPath>::fold_decorator(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        if self.enabled {
            <V as FoldAstPath>::fold_decorators(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_default_decl(
        &mut self,
        node: DefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> DefaultDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_default_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_do_while_stmt(
        &mut self,
        node: DoWhileStmt,
        __ast_path: &mut AstKindPath,
    ) -> DoWhileStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_do_while_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_empty_stmt(&mut self, node: EmptyStmt, __ast_path: &mut AstKindPath) -> EmptyStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_empty_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_all(&mut self, node: ExportAll, __ast_path: &mut AstKindPath) -> ExportAll {
        if self.enabled {
            <V as FoldAstPath>::fold_export_all(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_decl(&mut self, node: ExportDecl, __ast_path: &mut AstKindPath) -> ExportDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_export_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_export_default_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_export_default_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_export_default_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_export_named_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_export_namespace_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_export_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        if self.enabled {
            <V as FoldAstPath>::fold_export_specifiers(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr(&mut self, node: Expr, __ast_path: &mut AstKindPath) -> Expr {
        if self.enabled {
            <V as FoldAstPath>::fold_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        if self.enabled {
            <V as FoldAstPath>::fold_expr_or_spread(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        if self.enabled {
            <V as FoldAstPath>::fold_expr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_expr_stmt(&mut self, node: ExprStmt, __ast_path: &mut AstKindPath) -> ExprStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_expr_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, __ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        if self.enabled {
            <V as FoldAstPath>::fold_exprs(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_fn_decl(&mut self, node: FnDecl, __ast_path: &mut AstKindPath) -> FnDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_fn_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_fn_expr(&mut self, node: FnExpr, __ast_path: &mut AstKindPath) -> FnExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_fn_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_head(&mut self, node: ForHead, __ast_path: &mut AstKindPath) -> ForHead {
        if self.enabled {
            <V as FoldAstPath>::fold_for_head(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_in_stmt(&mut self, node: ForInStmt, __ast_path: &mut AstKindPath) -> ForInStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_for_in_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt, __ast_path: &mut AstKindPath) -> ForOfStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_for_of_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_for_stmt(&mut self, node: ForStmt, __ast_path: &mut AstKindPath) -> ForStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_for_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_function(&mut self, node: Function, __ast_path: &mut AstKindPath) -> Function {
        if self.enabled {
            <V as FoldAstPath>::fold_function(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_getter_prop(&mut self, node: GetterProp, __ast_path: &mut AstKindPath) -> GetterProp {
        if self.enabled {
            <V as FoldAstPath>::fold_getter_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_ident(&mut self, node: Ident, __ast_path: &mut AstKindPath) -> Ident {
        if self.enabled {
            <V as FoldAstPath>::fold_ident(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_ident_name(&mut self, node: IdentName, __ast_path: &mut AstKindPath) -> IdentName {
        if self.enabled {
            <V as FoldAstPath>::fold_ident_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_if_stmt(&mut self, node: IfStmt, __ast_path: &mut AstKindPath) -> IfStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_if_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import(&mut self, node: Import, __ast_path: &mut AstKindPath) -> Import {
        if self.enabled {
            <V as FoldAstPath>::fold_import(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_decl(&mut self, node: ImportDecl, __ast_path: &mut AstKindPath) -> ImportDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_import_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_import_default_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_import_named_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_phase(
        &mut self,
        node: ImportPhase,
        __ast_path: &mut AstKindPath,
    ) -> ImportPhase {
        if self.enabled {
            <V as FoldAstPath>::fold_import_phase(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_import_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        if self.enabled {
            <V as FoldAstPath>::fold_import_specifiers(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        __ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        if self.enabled {
            <V as FoldAstPath>::fold_import_star_as_specifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_with(&mut self, node: ImportWith, __ast_path: &mut AstKindPath) -> ImportWith {
        if self.enabled {
            <V as FoldAstPath>::fold_import_with(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        __ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        if self.enabled {
            <V as FoldAstPath>::fold_import_with_item(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        if self.enabled {
            <V as FoldAstPath>::fold_import_with_items(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_invalid(&mut self, node: Invalid, __ast_path: &mut AstKindPath) -> Invalid {
        if self.enabled {
            <V as FoldAstPath>::fold_invalid(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr(&mut self, node: JSXAttr, __ast_path: &mut AstKindPath) -> JSXAttr {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_attr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_name(
        &mut self,
        node: JSXAttrName,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrName {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_attr_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_attr_or_spread(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_attr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        __ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_attr_value(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_closing_element(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_closing_fragment(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element(&mut self, node: JSXElement, __ast_path: &mut AstKindPath) -> JSXElement {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_element(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_element_child(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_element_childs(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        __ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_element_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_empty_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_expr(&mut self, node: JSXExpr, __ast_path: &mut AstKindPath) -> JSXExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        __ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_expr_container(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_fragment(
        &mut self,
        node: JSXFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXFragment {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_fragment(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        __ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_member_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        __ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_namespaced_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_object(&mut self, node: JSXObject, __ast_path: &mut AstKindPath) -> JSXObject {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_object(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_opening_element(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        __ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_opening_fragment(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        __ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_spread_child(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_jsx_text(&mut self, node: JSXText, __ast_path: &mut AstKindPath) -> JSXText {
        if self.enabled {
            <V as FoldAstPath>::fold_jsx_text(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_key(&mut self, node: Key, __ast_path: &mut AstKindPath) -> Key {
        if self.enabled {
            <V as FoldAstPath>::fold_key(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        if self.enabled {
            <V as FoldAstPath>::fold_key_value_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        __ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        if self.enabled {
            <V as FoldAstPath>::fold_key_value_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_labeled_stmt(
        &mut self,
        node: LabeledStmt,
        __ast_path: &mut AstKindPath,
    ) -> LabeledStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_labeled_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_lit(&mut self, node: Lit, __ast_path: &mut AstKindPath) -> Lit {
        if self.enabled {
            <V as FoldAstPath>::fold_lit(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_member_expr(&mut self, node: MemberExpr, __ast_path: &mut AstKindPath) -> MemberExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_member_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_member_prop(&mut self, node: MemberProp, __ast_path: &mut AstKindPath) -> MemberProp {
        if self.enabled {
            <V as FoldAstPath>::fold_member_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_meta_prop_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        __ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        if self.enabled {
            <V as FoldAstPath>::fold_meta_prop_kind(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_method_kind(&mut self, node: MethodKind, __ast_path: &mut AstKindPath) -> MethodKind {
        if self.enabled {
            <V as FoldAstPath>::fold_method_kind(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_method_prop(&mut self, node: MethodProp, __ast_path: &mut AstKindPath) -> MethodProp {
        if self.enabled {
            <V as FoldAstPath>::fold_method_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module(&mut self, node: Module, __ast_path: &mut AstKindPath) -> Module {
        if self.enabled {
            <V as FoldAstPath>::fold_module(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_decl(&mut self, node: ModuleDecl, __ast_path: &mut AstKindPath) -> ModuleDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_module_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        __ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        if self.enabled {
            <V as FoldAstPath>::fold_module_export_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_item(&mut self, node: ModuleItem, __ast_path: &mut AstKindPath) -> ModuleItem {
        if self.enabled {
            <V as FoldAstPath>::fold_module_item(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        if self.enabled {
            <V as FoldAstPath>::fold_module_items(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_named_export(
        &mut self,
        node: NamedExport,
        __ast_path: &mut AstKindPath,
    ) -> NamedExport {
        if self.enabled {
            <V as FoldAstPath>::fold_named_export(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_new_expr(&mut self, node: NewExpr, __ast_path: &mut AstKindPath) -> NewExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_new_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_null(&mut self, node: Null, __ast_path: &mut AstKindPath) -> Null {
        if self.enabled {
            <V as FoldAstPath>::fold_null(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_number(&mut self, node: Number, __ast_path: &mut AstKindPath) -> Number {
        if self.enabled {
            <V as FoldAstPath>::fold_number(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_lit(&mut self, node: ObjectLit, __ast_path: &mut AstKindPath) -> ObjectLit {
        if self.enabled {
            <V as FoldAstPath>::fold_object_lit(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_pat(&mut self, node: ObjectPat, __ast_path: &mut AstKindPath) -> ObjectPat {
        if self.enabled {
            <V as FoldAstPath>::fold_object_pat(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        __ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        if self.enabled {
            <V as FoldAstPath>::fold_object_pat_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        if self.enabled {
            <V as FoldAstPath>::fold_object_pat_props(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_atom(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        __ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_block_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_call(&mut self, node: OptCall, __ast_path: &mut AstKindPath) -> OptCall {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_call(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        __ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_catch_clause(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        __ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_chain_base(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        __ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_chain_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_expr_or_spread(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_expr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_ident(
        &mut self,
        node: Option<Ident>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Ident> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_ident(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_jsx_attr_value(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        __ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_jsx_closing_element(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        __ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_module_export_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_object_lit(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_pat(&mut self, node: Option<Pat>, __ast_path: &mut AstKindPath) -> Option<Pat> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_pat(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_span(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_str(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        __ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_var_decl_or_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_vec_expr_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_vec_pats(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_param(&mut self, node: Param, __ast_path: &mut AstKindPath) -> Param {
        if self.enabled {
            <V as FoldAstPath>::fold_param(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        __ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        if self.enabled {
            <V as FoldAstPath>::fold_param_or_ts_param_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        if self.enabled {
            <V as FoldAstPath>::fold_param_or_ts_param_props(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_params(&mut self, node: Vec<Param>, __ast_path: &mut AstKindPath) -> Vec<Param> {
        if self.enabled {
            <V as FoldAstPath>::fold_params(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_paren_expr(&mut self, node: ParenExpr, __ast_path: &mut AstKindPath) -> ParenExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_paren_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_pat(&mut self, node: Pat, __ast_path: &mut AstKindPath) -> Pat {
        if self.enabled {
            <V as FoldAstPath>::fold_pat(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_pats(&mut self, node: Vec<Pat>, __ast_path: &mut AstKindPath) -> Vec<Pat> {
        if self.enabled {
            <V as FoldAstPath>::fold_pats(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        __ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        if self.enabled {
            <V as FoldAstPath>::fold_private_method(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_private_name(
        &mut self,
        node: PrivateName,
        __ast_path: &mut AstKindPath,
    ) -> PrivateName {
        if self.enabled {
            <V as FoldAstPath>::fold_private_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_private_prop(
        &mut self,
        node: PrivateProp,
        __ast_path: &mut AstKindPath,
    ) -> PrivateProp {
        if self.enabled {
            <V as FoldAstPath>::fold_private_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_program(&mut self, node: Program, __ast_path: &mut AstKindPath) -> Program {
        if self.enabled {
            <V as FoldAstPath>::fold_program(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop(&mut self, node: Prop, __ast_path: &mut AstKindPath) -> Prop {
        if self.enabled {
            <V as FoldAstPath>::fold_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop_name(&mut self, node: PropName, __ast_path: &mut AstKindPath) -> PropName {
        if self.enabled {
            <V as FoldAstPath>::fold_prop_name(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        __ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        if self.enabled {
            <V as FoldAstPath>::fold_prop_or_spread(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        if self.enabled {
            <V as FoldAstPath>::fold_prop_or_spreads(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_regex(&mut self, node: Regex, __ast_path: &mut AstKindPath) -> Regex {
        if self.enabled {
            <V as FoldAstPath>::fold_regex(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_rest_pat(&mut self, node: RestPat, __ast_path: &mut AstKindPath) -> RestPat {
        if self.enabled {
            <V as FoldAstPath>::fold_rest_pat(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_return_stmt(&mut self, node: ReturnStmt, __ast_path: &mut AstKindPath) -> ReturnStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_return_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_script(&mut self, node: Script, __ast_path: &mut AstKindPath) -> Script {
        if self.enabled {
            <V as FoldAstPath>::fold_script(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_seq_expr(&mut self, node: SeqExpr, __ast_path: &mut AstKindPath) -> SeqExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_seq_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_setter_prop(&mut self, node: SetterProp, __ast_path: &mut AstKindPath) -> SetterProp {
        if self.enabled {
            <V as FoldAstPath>::fold_setter_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        __ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        if self.enabled {
            <V as FoldAstPath>::fold_simple_assign_target(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        if self.enabled {
            <V as FoldAstPath>::fold_span(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        __ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        if self.enabled {
            <V as FoldAstPath>::fold_spread_element(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_static_block(
        &mut self,
        node: StaticBlock,
        __ast_path: &mut AstKindPath,
    ) -> StaticBlock {
        if self.enabled {
            <V as FoldAstPath>::fold_static_block(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_stmt(&mut self, node: Stmt, __ast_path: &mut AstKindPath) -> Stmt {
        if self.enabled {
            <V as FoldAstPath>::fold_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_stmts(&mut self, node: Vec<Stmt>, __ast_path: &mut AstKindPath) -> Vec<Stmt> {
        if self.enabled {
            <V as FoldAstPath>::fold_stmts(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_str(&mut self, node: Str, __ast_path: &mut AstKindPath) -> Str {
        if self.enabled {
            <V as FoldAstPath>::fold_str(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_super(&mut self, node: Super, __ast_path: &mut AstKindPath) -> Super {
        if self.enabled {
            <V as FoldAstPath>::fold_super(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_super_prop(&mut self, node: SuperProp, __ast_path: &mut AstKindPath) -> SuperProp {
        if self.enabled {
            <V as FoldAstPath>::fold_super_prop(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        __ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_super_prop_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_switch_case(&mut self, node: SwitchCase, __ast_path: &mut AstKindPath) -> SwitchCase {
        if self.enabled {
            <V as FoldAstPath>::fold_switch_case(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        if self.enabled {
            <V as FoldAstPath>::fold_switch_cases(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_switch_stmt(&mut self, node: SwitchStmt, __ast_path: &mut AstKindPath) -> SwitchStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_switch_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        if self.enabled {
            <V as FoldAstPath>::fold_syntax_context(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl, __ast_path: &mut AstKindPath) -> TaggedTpl {
        if self.enabled {
            <V as FoldAstPath>::fold_tagged_tpl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_this_expr(&mut self, node: ThisExpr, __ast_path: &mut AstKindPath) -> ThisExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_this_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_throw_stmt(&mut self, node: ThrowStmt, __ast_path: &mut AstKindPath) -> ThrowStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_throw_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tpl(&mut self, node: Tpl, __ast_path: &mut AstKindPath) -> Tpl {
        if self.enabled {
            <V as FoldAstPath>::fold_tpl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tpl_element(&mut self, node: TplElement, __ast_path: &mut AstKindPath) -> TplElement {
        if self.enabled {
            <V as FoldAstPath>::fold_tpl_element(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        if self.enabled {
            <V as FoldAstPath>::fold_tpl_elements(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        __ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        if self.enabled {
            <V as FoldAstPath>::fold_true_plus_minus(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_try_stmt(&mut self, node: TryStmt, __ast_path: &mut AstKindPath) -> TryStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_try_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_unary_expr(&mut self, node: UnaryExpr, __ast_path: &mut AstKindPath) -> UnaryExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_unary_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_unary_op(&mut self, node: UnaryOp, __ast_path: &mut AstKindPath) -> UnaryOp {
        if self.enabled {
            <V as FoldAstPath>::fold_unary_op(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_update_expr(&mut self, node: UpdateExpr, __ast_path: &mut AstKindPath) -> UpdateExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_update_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_update_op(&mut self, node: UpdateOp, __ast_path: &mut AstKindPath) -> UpdateOp {
        if self.enabled {
            <V as FoldAstPath>::fold_update_op(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_using_decl(&mut self, node: UsingDecl, __ast_path: &mut AstKindPath) -> UsingDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_using_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_decl(&mut self, node: VarDecl, __ast_path: &mut AstKindPath) -> VarDecl {
        if self.enabled {
            <V as FoldAstPath>::fold_var_decl(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_decl_kind(
        &mut self,
        node: VarDeclKind,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclKind {
        if self.enabled {
            <V as FoldAstPath>::fold_var_decl_kind(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_var_decl_or_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        __ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        if self.enabled {
            <V as FoldAstPath>::fold_var_declarator(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        if self.enabled {
            <V as FoldAstPath>::fold_var_declarators(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_while_stmt(&mut self, node: WhileStmt, __ast_path: &mut AstKindPath) -> WhileStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_while_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_with_stmt(&mut self, node: WithStmt, __ast_path: &mut AstKindPath) -> WithStmt {
        if self.enabled {
            <V as FoldAstPath>::fold_with_stmt(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_yield_expr(&mut self, node: YieldExpr, __ast_path: &mut AstKindPath) -> YieldExpr {
        if self.enabled {
            <V as FoldAstPath>::fold_yield_expr(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait FoldWithAstPath<V: ?Sized + FoldAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self;
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self;
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ArrayLit {
    #[doc = "Calls [FoldAstPath`::fold_array_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_array_lit(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ArrayLit { span, elems } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrayLit(self::fields::ArrayLitField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let elems = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrayLit(
                        self::fields::ArrayLitField::Elems(usize::MAX),
                    ));
                    <Vec<Option<ExprOrSpread>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        elems,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ArrayLit { span, elems }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ArrayPat {
    #[doc = "Calls [FoldAstPath`::fold_array_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_array_pat(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrayPat(self::fields::ArrayPatField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let elems = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrayPat(
                        self::fields::ArrayPatField::Elems(usize::MAX),
                    ));
                    <Vec<Option<Pat>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        elems,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_ann = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrayPat(
                        self::fields::ArrayPatField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ArrayPat {
                    span,
                    elems,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ArrowExpr {
    #[doc = "Calls [FoldAstPath`::fold_arrow_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_arrow_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrowExpr(self::fields::ArrowExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrowExpr(self::fields::ArrowExprField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let params = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrowExpr(
                        self::fields::ArrowExprField::Params(usize::MAX),
                    ));
                    <Vec<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ArrowExpr(self::fields::ArrowExprField::Body));
                    <Box<BlockStmtOrExpr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_params = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrowExpr(
                        self::fields::ArrowExprField::TypeParams,
                    ));
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let return_type = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ArrowExpr(
                        self::fields::ArrowExprField::ReturnType,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        return_type,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ArrowExpr {
                    span,
                    ctxt,
                    params,
                    body,
                    is_async,
                    is_generator,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignExpr {
    #[doc = "Calls [FoldAstPath`::fold_assign_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignExpr(
                        self::fields::AssignExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let op = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AssignExpr(self::fields::AssignExprField::Op));
                    <AssignOp as FoldWithAstPath<V>>::fold_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let left = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignExpr(
                        self::fields::AssignExprField::Left,
                    ));
                    <AssignTarget as FoldWithAstPath<V>>::fold_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let right = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignExpr(
                        self::fields::AssignExprField::Right,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                AssignExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignOp {
    #[doc = "Calls [FoldAstPath`::fold_assign_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_op(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignOp::Assign => AssignOp::Assign,
            AssignOp::AddAssign => AssignOp::AddAssign,
            AssignOp::SubAssign => AssignOp::SubAssign,
            AssignOp::MulAssign => AssignOp::MulAssign,
            AssignOp::DivAssign => AssignOp::DivAssign,
            AssignOp::ModAssign => AssignOp::ModAssign,
            AssignOp::LShiftAssign => AssignOp::LShiftAssign,
            AssignOp::RShiftAssign => AssignOp::RShiftAssign,
            AssignOp::ZeroFillRShiftAssign => AssignOp::ZeroFillRShiftAssign,
            AssignOp::BitOrAssign => AssignOp::BitOrAssign,
            AssignOp::BitXorAssign => AssignOp::BitXorAssign,
            AssignOp::BitAndAssign => AssignOp::BitAndAssign,
            AssignOp::ExpAssign => AssignOp::ExpAssign,
            AssignOp::AndAssign => AssignOp::AndAssign,
            AssignOp::OrAssign => AssignOp::OrAssign,
            AssignOp::NullishAssign => AssignOp::NullishAssign,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignPat {
    #[doc = "Calls [FoldAstPath`::fold_assign_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_pat(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignPat { span, left, right } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AssignPat(self::fields::AssignPatField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let left = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AssignPat(self::fields::AssignPatField::Left));
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let right = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPat(
                        self::fields::AssignPatField::Right,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                AssignPat { span, left, right }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignPatProp {
    #[doc = "Calls [FoldAstPath`::fold_assign_pat_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_pat_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignPatProp { span, key, value } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPatProp(
                        self::fields::AssignPatPropField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPatProp(
                        self::fields::AssignPatPropField::Key,
                    ));
                    <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignPatProp(
                        self::fields::AssignPatPropField::Value,
                    ));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                AssignPatProp { span, key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignProp {
    #[doc = "Calls [FoldAstPath`::fold_assign_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignProp { span, key, value } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignProp(
                        self::fields::AssignPropField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignProp(
                        self::fields::AssignPropField::Key,
                    ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignProp(
                        self::fields::AssignPropField::Value,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                AssignProp { span, key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignTarget {
    #[doc = "Calls [FoldAstPath`::fold_assign_target`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_target(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTarget(
                    self::fields::AssignTargetField::Simple,
                ));
                let _field_0 = <SimpleAssignTarget as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                AssignTarget::Simple { 0: _field_0 }
            }
            AssignTarget::Pat { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTarget(
                    self::fields::AssignTargetField::Pat,
                ));
                let _field_0 = <AssignTargetPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                AssignTarget::Pat { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignTargetPat {
    #[doc = "Calls [FoldAstPath`::fold_assign_target_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_target_pat(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTargetPat(
                    self::fields::AssignTargetPatField::Array,
                ));
                let _field_0 = <ArrayPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                AssignTargetPat::Array { 0: _field_0 }
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTargetPat(
                    self::fields::AssignTargetPatField::Object,
                ));
                let _field_0 = <ObjectPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                AssignTargetPat::Object { 0: _field_0 }
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::AssignTargetPat(
                    self::fields::AssignTargetPatField::Invalid,
                ));
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                AssignTargetPat::Invalid { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AutoAccessor {
    #[doc = "Calls [FoldAstPath`::fold_auto_accessor`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_auto_accessor(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Key,
                    ));
                    <Key as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, &mut *__ast_path)
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Value,
                    ));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_ann = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decorators = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let accessibility = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::AutoAccessor(
                        self::fields::AutoAccessorField::Accessibility,
                    ));
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                AutoAccessor {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_override,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AwaitExpr {
    #[doc = "Calls [FoldAstPath`::fold_await_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_await_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            AwaitExpr { span, arg } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AwaitExpr(self::fields::AwaitExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let arg = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::AwaitExpr(self::fields::AwaitExprField::Arg));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                AwaitExpr { span, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BigInt {
    #[doc = "Calls [FoldAstPath`::fold_big_int`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_big_int(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BigInt { span, value, raw } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BigInt(self::fields::BigIntField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BigInt(self::fields::BigIntField::Value));
                    <Box<BigIntValue> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let raw = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BigInt(self::fields::BigIntField::Raw));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                BigInt { span, value, raw }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BinExpr {
    #[doc = "Calls [FoldAstPath`::fold_bin_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_bin_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let op = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Op));
                    <BinaryOp as FoldWithAstPath<V>>::fold_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let left = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Left));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let right = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BinExpr(self::fields::BinExprField::Right));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                BinExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BinaryOp {
    #[doc = "Calls [FoldAstPath`::fold_binary_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_binary_op(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BinaryOp::EqEq => BinaryOp::EqEq,
            BinaryOp::NotEq => BinaryOp::NotEq,
            BinaryOp::EqEqEq => BinaryOp::EqEqEq,
            BinaryOp::NotEqEq => BinaryOp::NotEqEq,
            BinaryOp::Lt => BinaryOp::Lt,
            BinaryOp::LtEq => BinaryOp::LtEq,
            BinaryOp::Gt => BinaryOp::Gt,
            BinaryOp::GtEq => BinaryOp::GtEq,
            BinaryOp::LShift => BinaryOp::LShift,
            BinaryOp::RShift => BinaryOp::RShift,
            BinaryOp::ZeroFillRShift => BinaryOp::ZeroFillRShift,
            BinaryOp::Add => BinaryOp::Add,
            BinaryOp::Sub => BinaryOp::Sub,
            BinaryOp::Mul => BinaryOp::Mul,
            BinaryOp::Div => BinaryOp::Div,
            BinaryOp::Mod => BinaryOp::Mod,
            BinaryOp::BitOr => BinaryOp::BitOr,
            BinaryOp::BitXor => BinaryOp::BitXor,
            BinaryOp::BitAnd => BinaryOp::BitAnd,
            BinaryOp::LogicalOr => BinaryOp::LogicalOr,
            BinaryOp::LogicalAnd => BinaryOp::LogicalAnd,
            BinaryOp::In => BinaryOp::In,
            BinaryOp::InstanceOf => BinaryOp::InstanceOf,
            BinaryOp::Exp => BinaryOp::Exp,
            BinaryOp::NullishCoalescing => BinaryOp::NullishCoalescing,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BindingIdent {
    #[doc = "Calls [FoldAstPath`::fold_binding_ident`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_binding_ident(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BindingIdent { id, type_ann } => {
                let id = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BindingIdent(
                        self::fields::BindingIdentField::Id,
                    ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, &mut *__ast_path)
                };
                let type_ann = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BindingIdent(
                        self::fields::BindingIdentField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                BindingIdent { id, type_ann }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BlockStmt {
    #[doc = "Calls [FoldAstPath`::fold_block_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_block_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BlockStmt(self::fields::BlockStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BlockStmt(self::fields::BlockStmtField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let stmts = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BlockStmt(
                        self::fields::BlockStmtField::Stmts(usize::MAX),
                    ));
                    <Vec<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        stmts,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                BlockStmt { span, ctxt, stmts }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BlockStmtOrExpr {
    #[doc = "Calls [FoldAstPath`::fold_block_stmt_or_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_block_stmt_or_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::BlockStmtOrExpr(
                    self::fields::BlockStmtOrExprField::BlockStmt,
                ));
                let _field_0 = <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                BlockStmtOrExpr::BlockStmt { 0: _field_0 }
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::BlockStmtOrExpr(
                    self::fields::BlockStmtOrExprField::Expr,
                ));
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                BlockStmtOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Bool {
    #[doc = "Calls [FoldAstPath`::fold_bool`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_bool(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Bool { span, value } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Bool(self::fields::BoolField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Bool { span, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BreakStmt {
    #[doc = "Calls [FoldAstPath`::fold_break_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_break_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BreakStmt { span, label } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::BreakStmt(self::fields::BreakStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let label = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BreakStmt(
                        self::fields::BreakStmtField::Label,
                    ));
                    <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                BreakStmt { span, label }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CallExpr {
    #[doc = "Calls [FoldAstPath`::fold_call_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_call_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CallExpr(self::fields::CallExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CallExpr(self::fields::CallExprField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let callee = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CallExpr(self::fields::CallExprField::Callee));
                    <Callee as FoldWithAstPath<V>>::fold_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let args = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CallExpr(
                        self::fields::CallExprField::Args(usize::MAX),
                    ));
                    <Vec<ExprOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_args = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CallExpr(
                        self::fields::CallExprField::TypeArgs,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
                CallExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Callee {
    #[doc = "Calls [FoldAstPath`::fold_callee`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_callee(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Callee::Super { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Callee(self::fields::CalleeField::Super));
                let _field_0 = <Super as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Callee::Super { 0: _field_0 }
            }
            Callee::Import { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Callee(self::fields::CalleeField::Import));
                let _field_0 = <Import as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Callee::Import { 0: _field_0 }
            }
            Callee::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Callee(self::fields::CalleeField::Expr));
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Callee::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CatchClause {
    #[doc = "Calls [FoldAstPath`::fold_catch_clause`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_catch_clause(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CatchClause { span, param, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CatchClause(
                        self::fields::CatchClauseField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let param = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CatchClause(
                        self::fields::CatchClauseField::Param,
                    ));
                    <Option<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                        param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CatchClause(
                        self::fields::CatchClauseField::Body,
                    ));
                    <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                CatchClause { span, param, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Class {
    #[doc = "Calls [FoldAstPath`::fold_class`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Class(self::fields::ClassField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Class(self::fields::ClassField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decorators = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::Body(usize::MAX),
                    ));
                    <Vec<ClassMember> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let super_class = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Class(self::fields::ClassField::SuperClass));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        super_class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_params = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Class(self::fields::ClassField::TypeParams));
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let super_type_params = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::SuperTypeParams,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (super_type_params , visitor , & mut * __ast_path)
                };
                let implements = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Class(
                        self::fields::ClassField::Implements(usize::MAX),
                    ));
                    <Vec<TsExprWithTypeArgs> as FoldWithAstPath<V>>::fold_with_ast_path(
                        implements,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Class {
                    span,
                    ctxt,
                    decorators,
                    body,
                    super_class,
                    is_abstract,
                    type_params,
                    super_type_params,
                    implements,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassDecl {
    #[doc = "Calls [FoldAstPath`::fold_class_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                let ident = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassDecl(
                        self::fields::ClassDeclField::Ident,
                    ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let class = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassDecl(
                        self::fields::ClassDeclField::Class,
                    ));
                    <Box<Class> as FoldWithAstPath<V>>::fold_with_ast_path(
                        class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ClassDecl {
                    ident,
                    declare,
                    class,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassExpr {
    #[doc = "Calls [FoldAstPath`::fold_class_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassExpr { ident, class } => {
                let ident = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassExpr(
                        self::fields::ClassExprField::Ident,
                    ));
                    <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let class = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassExpr(
                        self::fields::ClassExprField::Class,
                    ));
                    <Box<Class> as FoldWithAstPath<V>>::fold_with_ast_path(
                        class,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ClassExpr { ident, class }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassMember {
    #[doc = "Calls [FoldAstPath`::fold_class_member`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_member(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::Constructor,
                ));
                let _field_0 = <Constructor as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::Constructor { 0: _field_0 }
            }
            ClassMember::Method { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::Method,
                ));
                let _field_0 = <ClassMethod as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::Method { 0: _field_0 }
            }
            ClassMember::PrivateMethod { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::PrivateMethod,
                ));
                let _field_0 = <PrivateMethod as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::PrivateMethod { 0: _field_0 }
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::ClassProp,
                ));
                let _field_0 = <ClassProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::ClassProp { 0: _field_0 }
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::PrivateProp,
                ));
                let _field_0 = <PrivateProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::PrivateProp { 0: _field_0 }
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::TsIndexSignature,
                ));
                let _field_0 = <TsIndexSignature as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::TsIndexSignature { 0: _field_0 }
            }
            ClassMember::Empty { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::Empty,
                ));
                let _field_0 = <EmptyStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::Empty { 0: _field_0 }
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::StaticBlock,
                ));
                let _field_0 = <StaticBlock as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::StaticBlock { 0: _field_0 }
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMember(
                    self::fields::ClassMemberField::AutoAccessor,
                ));
                let _field_0 = <AutoAccessor as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ClassMember::AutoAccessor { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassMethod {
    #[doc = "Calls [FoldAstPath`::fold_class_method`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_method(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Key,
                    ));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let function = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Function,
                    ));
                    <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Kind,
                    ));
                    <MethodKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let accessibility = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassMethod(
                        self::fields::ClassMethodField::Accessibility,
                    ));
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ClassMethod {
                    span,
                    key,
                    function,
                    kind,
                    is_static,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassProp {
    #[doc = "Calls [FoldAstPath`::fold_class_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ClassProp(self::fields::ClassPropField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ClassProp(self::fields::ClassPropField::Key));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::Value,
                    ));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_ann = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decorators = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let accessibility = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassProp(
                        self::fields::ClassPropField::Accessibility,
                    ));
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ClassProp {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                    readonly,
                    declare,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ComputedPropName {
    #[doc = "Calls [FoldAstPath`::fold_computed_prop_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_computed_prop_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ComputedPropName { span, expr } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ComputedPropName(
                        self::fields::ComputedPropNameField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ComputedPropName(
                        self::fields::ComputedPropNameField::Expr,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ComputedPropName { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CondExpr {
    #[doc = "Calls [FoldAstPath`::fold_cond_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_cond_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let test = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Test));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let cons = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Cons));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let alt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::CondExpr(self::fields::CondExprField::Alt));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        alt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                CondExpr {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Constructor {
    #[doc = "Calls [FoldAstPath`::fold_constructor`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_constructor(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Key,
                    ));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let params = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Params(usize::MAX),
                    ));
                    <Vec<ParamOrTsParamProp> as FoldWithAstPath<V>>::fold_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Body,
                    ));
                    <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let accessibility = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Constructor(
                        self::fields::ConstructorField::Accessibility,
                    ));
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Constructor {
                    span,
                    ctxt,
                    key,
                    params,
                    body,
                    accessibility,
                    is_optional,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ContinueStmt {
    #[doc = "Calls [FoldAstPath`::fold_continue_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_continue_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ContinueStmt { span, label } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ContinueStmt(
                        self::fields::ContinueStmtField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let label = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ContinueStmt(
                        self::fields::ContinueStmtField::Label,
                    ));
                    <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ContinueStmt { span, label }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for DebuggerStmt {
    #[doc = "Calls [FoldAstPath`::fold_debugger_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_debugger_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            DebuggerStmt { span } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DebuggerStmt(
                        self::fields::DebuggerStmtField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                DebuggerStmt { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Decl {
    #[doc = "Calls [FoldAstPath`::fold_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Decl::Class { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Class));
                let _field_0 = <ClassDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::Class { 0: _field_0 }
            }
            Decl::Fn { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Fn));
                let _field_0 = <FnDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::Fn { 0: _field_0 }
            }
            Decl::Var { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Var));
                let _field_0 = <Box<VarDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::Var { 0: _field_0 }
            }
            Decl::Using { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::Using));
                let _field_0 = <Box<UsingDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::Using { 0: _field_0 }
            }
            Decl::TsInterface { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Decl(self::fields::DeclField::TsInterface));
                let _field_0 = <Box<TsInterfaceDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::TsInterface { 0: _field_0 }
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Decl(self::fields::DeclField::TsTypeAlias));
                let _field_0 = <Box<TsTypeAliasDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::TsTypeAlias { 0: _field_0 }
            }
            Decl::TsEnum { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::TsEnum));
                let _field_0 = <Box<TsEnumDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::TsEnum { 0: _field_0 }
            }
            Decl::TsModule { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Decl(self::fields::DeclField::TsModule));
                let _field_0 = <Box<TsModuleDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Decl::TsModule { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Decorator {
    #[doc = "Calls [FoldAstPath`::fold_decorator`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_decorator(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Decorator { span, expr } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Decorator(self::fields::DecoratorField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Decorator(self::fields::DecoratorField::Expr));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Decorator { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for DefaultDecl {
    #[doc = "Calls [FoldAstPath`::fold_default_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_default_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::DefaultDecl(
                    self::fields::DefaultDeclField::Class,
                ));
                let _field_0 = <ClassExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                DefaultDecl::Class { 0: _field_0 }
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::DefaultDecl(
                    self::fields::DefaultDeclField::Fn,
                ));
                let _field_0 = <FnExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                DefaultDecl::Fn { 0: _field_0 }
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::DefaultDecl(
                    self::fields::DefaultDeclField::TsInterfaceDecl,
                ));
                let _field_0 = <Box<TsInterfaceDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                DefaultDecl::TsInterfaceDecl { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for DoWhileStmt {
    #[doc = "Calls [FoldAstPath`::fold_do_while_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_do_while_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            DoWhileStmt { span, test, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DoWhileStmt(
                        self::fields::DoWhileStmtField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let test = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DoWhileStmt(
                        self::fields::DoWhileStmtField::Test,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::DoWhileStmt(
                        self::fields::DoWhileStmtField::Body,
                    ));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                DoWhileStmt { span, test, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for EmptyStmt {
    #[doc = "Calls [FoldAstPath`::fold_empty_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_empty_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            EmptyStmt { span } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::EmptyStmt(self::fields::EmptyStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                EmptyStmt { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportAll {
    #[doc = "Calls [FoldAstPath`::fold_export_all`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_all(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExportAll(self::fields::ExportAllField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let src = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExportAll(self::fields::ExportAllField::Src));
                    <Box<Str> as FoldWithAstPath<V>>::fold_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let with = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExportAll(self::fields::ExportAllField::With));
                    <Option<Box<ObjectLit>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExportAll {
                    span,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDecl {
    #[doc = "Calls [FoldAstPath`::fold_export_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDecl { span, decl } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDecl(
                        self::fields::ExportDeclField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decl = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDecl(
                        self::fields::ExportDeclField::Decl,
                    ));
                    <Decl as FoldWithAstPath<V>>::fold_with_ast_path(
                        decl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExportDecl { span, decl }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDefaultDecl {
    #[doc = "Calls [FoldAstPath`::fold_export_default_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_default_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDefaultDecl { span, decl } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultDecl(
                        self::fields::ExportDefaultDeclField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decl = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultDecl(
                        self::fields::ExportDefaultDeclField::Decl,
                    ));
                    <DefaultDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                        decl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExportDefaultDecl { span, decl }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDefaultExpr {
    #[doc = "Calls [FoldAstPath`::fold_export_default_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_default_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDefaultExpr { span, expr } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultExpr(
                        self::fields::ExportDefaultExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportDefaultExpr(
                        self::fields::ExportDefaultExprField::Expr,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExportDefaultExpr { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDefaultSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_default_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_default_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDefaultSpecifier { exported } => {
                let exported = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportDefaultSpecifier(
                            self::fields::ExportDefaultSpecifierField::Exported,
                        ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        exported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExportDefaultSpecifier { exported }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportNamedSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_named_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_named_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamedSpecifier(
                            self::fields::ExportNamedSpecifierField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let orig = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamedSpecifier(
                            self::fields::ExportNamedSpecifierField::Orig,
                        ));
                    <ModuleExportName as FoldWithAstPath<V>>::fold_with_ast_path(
                        orig,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let exported = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamedSpecifier(
                            self::fields::ExportNamedSpecifierField::Exported,
                        ));
                    <Option<ModuleExportName> as FoldWithAstPath<V>>::fold_with_ast_path(
                        exported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExportNamedSpecifier {
                    span,
                    orig,
                    exported,
                    is_type_only,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_namespace_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_namespace_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamespaceSpecifier(
                            self::fields::ExportNamespaceSpecifierField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ExportNamespaceSpecifier(
                            self::fields::ExportNamespaceSpecifierField::Name,
                        ));
                    <ModuleExportName as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExportNamespaceSpecifier { span, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportSpecifier(
                    self::fields::ExportSpecifierField::Namespace,
                ));
                let _field_0 = <ExportNamespaceSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ExportSpecifier::Namespace { 0: _field_0 }
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportSpecifier(
                    self::fields::ExportSpecifierField::Default,
                ));
                let _field_0 = <ExportDefaultSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ExportSpecifier::Default { 0: _field_0 }
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ExportSpecifier(
                    self::fields::ExportSpecifierField::Named,
                ));
                let _field_0 = <ExportNamedSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ExportSpecifier::Named { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Expr {
    #[doc = "Calls [FoldAstPath`::fold_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Expr::This { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::This));
                let _field_0 = <ThisExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::This { 0: _field_0 }
            }
            Expr::Array { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Array));
                let _field_0 = <ArrayLit as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Array { 0: _field_0 }
            }
            Expr::Object { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Object));
                let _field_0 = <ObjectLit as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Object { 0: _field_0 }
            }
            Expr::Fn { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Fn));
                let _field_0 = <FnExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Fn { 0: _field_0 }
            }
            Expr::Unary { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Unary));
                let _field_0 = <UnaryExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Unary { 0: _field_0 }
            }
            Expr::Update { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Update));
                let _field_0 = <UpdateExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Update { 0: _field_0 }
            }
            Expr::Bin { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Bin));
                let _field_0 = <BinExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Bin { 0: _field_0 }
            }
            Expr::Assign { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Assign));
                let _field_0 = <AssignExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Assign { 0: _field_0 }
            }
            Expr::Member { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Member));
                let _field_0 = <MemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Member { 0: _field_0 }
            }
            Expr::SuperProp { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::SuperProp));
                let _field_0 = <SuperPropExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::SuperProp { 0: _field_0 }
            }
            Expr::Cond { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Cond));
                let _field_0 = <CondExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Cond { 0: _field_0 }
            }
            Expr::Call { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Call));
                let _field_0 = <CallExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Call { 0: _field_0 }
            }
            Expr::New { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::New));
                let _field_0 = <NewExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::New { 0: _field_0 }
            }
            Expr::Seq { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Seq));
                let _field_0 = <SeqExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Seq { 0: _field_0 }
            }
            Expr::Ident { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Ident));
                let _field_0 = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Ident { 0: _field_0 }
            }
            Expr::Lit { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Lit));
                let _field_0 = <Lit as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Lit { 0: _field_0 }
            }
            Expr::Tpl { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Tpl));
                let _field_0 = <Tpl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Tpl { 0: _field_0 }
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::TaggedTpl));
                let _field_0 = <TaggedTpl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::TaggedTpl { 0: _field_0 }
            }
            Expr::Arrow { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Arrow));
                let _field_0 = <ArrowExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Arrow { 0: _field_0 }
            }
            Expr::Class { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Class));
                let _field_0 = <ClassExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Class { 0: _field_0 }
            }
            Expr::Yield { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Yield));
                let _field_0 = <YieldExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Yield { 0: _field_0 }
            }
            Expr::MetaProp { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::MetaProp));
                let _field_0 = <MetaPropExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::MetaProp { 0: _field_0 }
            }
            Expr::Await { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Await));
                let _field_0 = <AwaitExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Await { 0: _field_0 }
            }
            Expr::Paren { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Paren));
                let _field_0 = <ParenExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Paren { 0: _field_0 }
            }
            Expr::JSXMember { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxmember));
                let _field_0 = <JSXMemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::JSXMember { 0: _field_0 }
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::JsxnamespacedName,
                ));
                let _field_0 = <JSXNamespacedName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::JSXNamespacedName { 0: _field_0 }
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxempty));
                let _field_0 = <JSXEmptyExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::JSXEmpty { 0: _field_0 }
            }
            Expr::JSXElement { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxelement));
                let _field_0 = <Box<JSXElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::JSXElement { 0: _field_0 }
            }
            Expr::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Expr(self::fields::ExprField::Jsxfragment));
                let _field_0 = <JSXFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::JSXFragment { 0: _field_0 }
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::TsTypeAssertion,
                ));
                let _field_0 = <TsTypeAssertion as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::TsTypeAssertion { 0: _field_0 }
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::TsConstAssertion,
                ));
                let _field_0 = <TsConstAssertion as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::TsConstAssertion { 0: _field_0 }
            }
            Expr::TsNonNull { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::TsNonNull));
                let _field_0 = <TsNonNullExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::TsNonNull { 0: _field_0 }
            }
            Expr::TsAs { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::TsAs));
                let _field_0 = <TsAsExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::TsAs { 0: _field_0 }
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Expr(
                    self::fields::ExprField::TsInstantiation,
                ));
                let _field_0 = <TsInstantiation as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::TsInstantiation { 0: _field_0 }
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Expr(self::fields::ExprField::TsSatisfies));
                let _field_0 = <TsSatisfiesExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::TsSatisfies { 0: _field_0 }
            }
            Expr::PrivateName { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Expr(self::fields::ExprField::PrivateName));
                let _field_0 = <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::PrivateName { 0: _field_0 }
            }
            Expr::OptChain { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::OptChain));
                let _field_0 = <OptChainExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::OptChain { 0: _field_0 }
            }
            Expr::Invalid { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Expr(self::fields::ExprField::Invalid));
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Expr::Invalid { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExprOrSpread {
    #[doc = "Calls [FoldAstPath`::fold_expr_or_spread`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr_or_spread(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExprOrSpread { spread, expr } => {
                let spread = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExprOrSpread(
                        self::fields::ExprOrSpreadField::Spread,
                    ));
                    <Option<swc_common::Span> as FoldWithAstPath<V>>::fold_with_ast_path(
                        spread,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ExprOrSpread(
                        self::fields::ExprOrSpreadField::Expr,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExprOrSpread { spread, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExprStmt {
    #[doc = "Calls [FoldAstPath`::fold_expr_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ExprStmt { span, expr } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExprStmt(self::fields::ExprStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ExprStmt(self::fields::ExprStmtField::Expr));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ExprStmt { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for FnDecl {
    #[doc = "Calls [FoldAstPath`::fold_fn_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_fn_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                let ident = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnDecl(self::fields::FnDeclField::Ident));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let function = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnDecl(self::fields::FnDeclField::Function));
                    <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                FnDecl {
                    ident,
                    declare,
                    function,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for FnExpr {
    #[doc = "Calls [FoldAstPath`::fold_fn_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_fn_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            FnExpr { ident, function } => {
                let ident = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnExpr(self::fields::FnExprField::Ident));
                    <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                        ident,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let function = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::FnExpr(self::fields::FnExprField::Function));
                    <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                FnExpr { ident, function }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForHead {
    #[doc = "Calls [FoldAstPath`::fold_for_head`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_head(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::ForHead(self::fields::ForHeadField::VarDecl));
                let _field_0 = <Box<VarDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ForHead::VarDecl { 0: _field_0 }
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ForHead(
                    self::fields::ForHeadField::UsingDecl,
                ));
                let _field_0 = <Box<UsingDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ForHead::UsingDecl { 0: _field_0 }
            }
            ForHead::Pat { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::ForHead(self::fields::ForHeadField::Pat));
                let _field_0 = <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ForHead::Pat { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForInStmt {
    #[doc = "Calls [FoldAstPath`::fold_for_in_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_in_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForInStmt(self::fields::ForInStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let left = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForInStmt(self::fields::ForInStmtField::Left));
                    <ForHead as FoldWithAstPath<V>>::fold_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let right = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ForInStmt(
                        self::fields::ForInStmtField::Right,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForInStmt(self::fields::ForInStmtField::Body));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ForInStmt {
                    span,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForOfStmt {
    #[doc = "Calls [FoldAstPath`::fold_for_of_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_of_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForOfStmt(self::fields::ForOfStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let left = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForOfStmt(self::fields::ForOfStmtField::Left));
                    <ForHead as FoldWithAstPath<V>>::fold_with_ast_path(
                        left,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let right = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ForOfStmt(
                        self::fields::ForOfStmtField::Right,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        right,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForOfStmt(self::fields::ForOfStmtField::Body));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ForOfStmt {
                    span,
                    is_await,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForStmt {
    #[doc = "Calls [FoldAstPath`::fold_for_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let init = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Init));
                    <Option<VarDeclOrExpr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        init,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let test = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Test));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let update = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Update));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        update,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ForStmt(self::fields::ForStmtField::Body));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ForStmt {
                    span,
                    init,
                    test,
                    update,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Function {
    #[doc = "Calls [FoldAstPath`::fold_function`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_function(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                let params = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::Params(usize::MAX),
                    ));
                    <Vec<Param> as FoldWithAstPath<V>>::fold_with_ast_path(
                        params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decorators = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Function(self::fields::FunctionField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Function(self::fields::FunctionField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Function(self::fields::FunctionField::Body));
                    <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_params = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::TypeParams,
                    ));
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let return_type = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Function(
                        self::fields::FunctionField::ReturnType,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        return_type,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Function {
                    params,
                    decorators,
                    span,
                    ctxt,
                    body,
                    is_generator,
                    is_async,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for GetterProp {
    #[doc = "Calls [FoldAstPath`::fold_getter_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_getter_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::Key,
                    ));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_ann = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::GetterProp(
                        self::fields::GetterPropField::Body,
                    ));
                    <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                GetterProp {
                    span,
                    key,
                    type_ann,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Ident {
    #[doc = "Calls [FoldAstPath`::fold_ident`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ident(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Ident(self::fields::IdentField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Ident(self::fields::IdentField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let sym = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Ident(self::fields::IdentField::Sym));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        sym,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Ident {
                    span,
                    ctxt,
                    sym,
                    optional,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for IdentName {
    #[doc = "Calls [FoldAstPath`::fold_ident_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ident_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            IdentName { span, sym } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IdentName(self::fields::IdentNameField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let sym = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IdentName(self::fields::IdentNameField::Sym));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        sym,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                IdentName { span, sym }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for IfStmt {
    #[doc = "Calls [FoldAstPath`::fold_if_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_if_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let test = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Test));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let cons = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Cons));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let alt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::IfStmt(self::fields::IfStmtField::Alt));
                    <Option<Box<Stmt>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        alt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                IfStmt {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Import {
    #[doc = "Calls [FoldAstPath`::fold_import`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Import { span, phase } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Import(self::fields::ImportField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let phase = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Import(self::fields::ImportField::Phase));
                    <ImportPhase as FoldWithAstPath<V>>::fold_with_ast_path(
                        phase,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Import { span, phase }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportDecl {
    #[doc = "Calls [FoldAstPath`::fold_import_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let specifiers = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Specifiers(usize::MAX),
                    ));
                    <Vec<ImportSpecifier> as FoldWithAstPath<V>>::fold_with_ast_path(
                        specifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let src = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Src,
                    ));
                    <Box<Str> as FoldWithAstPath<V>>::fold_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let with = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::With,
                    ));
                    <Option<Box<ObjectLit>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let phase = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportDecl(
                        self::fields::ImportDeclField::Phase,
                    ));
                    <ImportPhase as FoldWithAstPath<V>>::fold_with_ast_path(
                        phase,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ImportDecl {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                    phase,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportDefaultSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_default_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_default_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportDefaultSpecifier { span, local } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportDefaultSpecifier(
                            self::fields::ImportDefaultSpecifierField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let local = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportDefaultSpecifier(
                            self::fields::ImportDefaultSpecifierField::Local,
                        ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ImportDefaultSpecifier { span, local }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportNamedSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_named_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_named_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportNamedSpecifier(
                            self::fields::ImportNamedSpecifierField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let local = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportNamedSpecifier(
                            self::fields::ImportNamedSpecifierField::Local,
                        ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let imported = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportNamedSpecifier(
                            self::fields::ImportNamedSpecifierField::Imported,
                        ));
                    <Option<ModuleExportName> as FoldWithAstPath<V>>::fold_with_ast_path(
                        imported,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ImportNamedSpecifier {
                    span,
                    local,
                    imported,
                    is_type_only,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportPhase {
    #[doc = "Calls [FoldAstPath`::fold_import_phase`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_phase(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportPhase::Evaluation => ImportPhase::Evaluation,
            ImportPhase::Source => ImportPhase::Source,
            ImportPhase::Defer => ImportPhase::Defer,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportSpecifier(
                    self::fields::ImportSpecifierField::Named,
                ));
                let _field_0 = <ImportNamedSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ImportSpecifier::Named { 0: _field_0 }
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportSpecifier(
                    self::fields::ImportSpecifierField::Default,
                ));
                let _field_0 = <ImportDefaultSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ImportSpecifier::Default { 0: _field_0 }
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportSpecifier(
                    self::fields::ImportSpecifierField::Namespace,
                ));
                let _field_0 = <ImportStarAsSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ImportSpecifier::Namespace { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportStarAsSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_star_as_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_star_as_specifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportStarAsSpecifier { span, local } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportStarAsSpecifier(
                            self::fields::ImportStarAsSpecifierField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let local = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ImportStarAsSpecifier(
                            self::fields::ImportStarAsSpecifierField::Local,
                        ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        local,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ImportStarAsSpecifier { span, local }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportWith {
    #[doc = "Calls [FoldAstPath`::fold_import_with`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_with(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportWith { span, values } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWith(
                        self::fields::ImportWithField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let values = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWith(
                        self::fields::ImportWithField::Values(usize::MAX),
                    ));
                    <Vec<ImportWithItem> as FoldWithAstPath<V>>::fold_with_ast_path(
                        values,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ImportWith { span, values }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportWithItem {
    #[doc = "Calls [FoldAstPath`::fold_import_with_item`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_with_item(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportWithItem { key, value } => {
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWithItem(
                        self::fields::ImportWithItemField::Key,
                    ));
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ImportWithItem(
                        self::fields::ImportWithItemField::Value,
                    ));
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ImportWithItem { key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Invalid {
    #[doc = "Calls [FoldAstPath`::fold_invalid`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_invalid(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Invalid { span } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Invalid(self::fields::InvalidField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Invalid { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttr { span, name, value } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXAttr(self::fields::JSXAttrField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXAttr(self::fields::JSXAttrField::Name));
                    <JSXAttrName as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXAttr(self::fields::JSXAttrField::Value));
                    <Option<JSXAttrValue> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXAttr { span, name, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttrName {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrName(
                    self::fields::JSXAttrNameField::Ident,
                ));
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrName::Ident { 0: _field_0 }
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrName(
                    self::fields::JSXAttrNameField::JsxnamespacedName,
                ));
                let _field_0 = <JSXNamespacedName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttrOrSpread {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_or_spread`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_or_spread(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrOrSpread(
                    self::fields::JSXAttrOrSpreadField::Jsxattr,
                ));
                let _field_0 = <JSXAttr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrOrSpread::JSXAttr { 0: _field_0 }
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrOrSpread(
                    self::fields::JSXAttrOrSpreadField::SpreadElement,
                ));
                let _field_0 = <SpreadElement as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrOrSpread::SpreadElement { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttrValue {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_value`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_value(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::Lit,
                ));
                let _field_0 = <Lit as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrValue::Lit { 0: _field_0 }
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::JsxexprContainer,
                ));
                let _field_0 = <JSXExprContainer as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrValue::JSXExprContainer { 0: _field_0 }
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::Jsxelement,
                ));
                let _field_0 = <Box<JSXElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrValue::JSXElement { 0: _field_0 }
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXAttrValue(
                    self::fields::JSXAttrValueField::Jsxfragment,
                ));
                let _field_0 = <JSXFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXAttrValue::JSXFragment { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXClosingElement {
    #[doc = "Calls [FoldAstPath`::fold_jsx_closing_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_closing_element(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXClosingElement { span, name } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXClosingElement(
                        self::fields::JSXClosingElementField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXClosingElement(
                        self::fields::JSXClosingElementField::Name,
                    ));
                    <JSXElementName as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXClosingElement { span, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXClosingFragment {
    #[doc = "Calls [FoldAstPath`::fold_jsx_closing_fragment`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_closing_fragment(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXClosingFragment { span } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXClosingFragment(
                        self::fields::JSXClosingFragmentField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXClosingFragment { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXElement {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let opening = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Opening,
                    ));
                    <JSXOpeningElement as FoldWithAstPath<V>>::fold_with_ast_path(
                        opening,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let children = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Children(usize::MAX),
                    ));
                    <Vec<JSXElementChild> as FoldWithAstPath<V>>::fold_with_ast_path(
                        children,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let closing = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElement(
                        self::fields::JSXElementField::Closing,
                    ));
                    <Option<JSXClosingElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                        closing,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXElement {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXElementChild {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element_child`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element_child(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::Jsxtext,
                ));
                let _field_0 = <JSXText as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementChild::JSXText { 0: _field_0 }
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::JsxexprContainer,
                ));
                let _field_0 = <JSXExprContainer as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementChild::JSXExprContainer { 0: _field_0 }
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::JsxspreadChild,
                ));
                let _field_0 = <JSXSpreadChild as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementChild::JSXSpreadChild { 0: _field_0 }
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::Jsxelement,
                ));
                let _field_0 = <Box<JSXElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementChild::JSXElement { 0: _field_0 }
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementChild(
                    self::fields::JSXElementChildField::Jsxfragment,
                ));
                let _field_0 = <JSXFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementChild::JSXFragment { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXElementName {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementName(
                    self::fields::JSXElementNameField::Ident,
                ));
                let _field_0 = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementName::Ident { 0: _field_0 }
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementName(
                    self::fields::JSXElementNameField::JsxmemberExpr,
                ));
                let _field_0 = <JSXMemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementName::JSXMemberExpr { 0: _field_0 }
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXElementName(
                    self::fields::JSXElementNameField::JsxnamespacedName,
                ));
                let _field_0 = <JSXNamespacedName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXElementName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXEmptyExpr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_empty_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_empty_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXEmptyExpr { span } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXEmptyExpr(
                        self::fields::JSXEmptyExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXEmptyExpr { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXExpr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXExpr(
                    self::fields::JSXExprField::JsxemptyExpr,
                ));
                let _field_0 = <JSXEmptyExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXExpr::JSXEmptyExpr { 0: _field_0 }
            }
            JSXExpr::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::JSXExpr(self::fields::JSXExprField::Expr));
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXExpr::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXExprContainer {
    #[doc = "Calls [FoldAstPath`::fold_jsx_expr_container`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_expr_container(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXExprContainer { span, expr } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXExprContainer(
                        self::fields::JSXExprContainerField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXExprContainer(
                        self::fields::JSXExprContainerField::Expr,
                    ));
                    <JSXExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXExprContainer { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXFragment {
    #[doc = "Calls [FoldAstPath`::fold_jsx_fragment`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_fragment(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let opening = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Opening,
                    ));
                    <JSXOpeningFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                        opening,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let children = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Children(usize::MAX),
                    ));
                    <Vec<JSXElementChild> as FoldWithAstPath<V>>::fold_with_ast_path(
                        children,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let closing = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXFragment(
                        self::fields::JSXFragmentField::Closing,
                    ));
                    <JSXClosingFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                        closing,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXFragment {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXMemberExpr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_member_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_member_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXMemberExpr(
                        self::fields::JSXMemberExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let obj = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXMemberExpr(
                        self::fields::JSXMemberExprField::Obj,
                    ));
                    <JSXObject as FoldWithAstPath<V>>::fold_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let prop = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXMemberExpr(
                        self::fields::JSXMemberExprField::Prop,
                    ));
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXMemberExpr { span, obj, prop }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXNamespacedName {
    #[doc = "Calls [FoldAstPath`::fold_jsx_namespaced_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_namespaced_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXNamespacedName { span, ns, name } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXNamespacedName(
                        self::fields::JSXNamespacedNameField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ns = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXNamespacedName(
                        self::fields::JSXNamespacedNameField::Ns,
                    ));
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                        ns,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXNamespacedName(
                        self::fields::JSXNamespacedNameField::Name,
                    ));
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXNamespacedName { span, ns, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXObject {
    #[doc = "Calls [FoldAstPath`::fold_jsx_object`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_object(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXObject(
                    self::fields::JSXObjectField::JsxmemberExpr,
                ));
                let _field_0 = <Box<JSXMemberExpr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXObject::JSXMemberExpr { 0: _field_0 }
            }
            JSXObject::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXObject(
                    self::fields::JSXObjectField::Ident,
                ));
                let _field_0 = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                JSXObject::Ident { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXOpeningElement {
    #[doc = "Calls [FoldAstPath`::fold_jsx_opening_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_opening_element(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                let name = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::Name,
                    ));
                    <JSXElementName as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let attrs = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::Attrs(usize::MAX),
                    ));
                    <Vec<JSXAttrOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                        attrs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_args = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningElement(
                        self::fields::JSXOpeningElementField::TypeArgs,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
                JSXOpeningElement {
                    name,
                    span,
                    attrs,
                    self_closing,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXOpeningFragment {
    #[doc = "Calls [FoldAstPath`::fold_jsx_opening_fragment`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_opening_fragment(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXOpeningFragment { span } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXOpeningFragment(
                        self::fields::JSXOpeningFragmentField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXOpeningFragment { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXSpreadChild {
    #[doc = "Calls [FoldAstPath`::fold_jsx_spread_child`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_spread_child(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXSpreadChild { span, expr } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXSpreadChild(
                        self::fields::JSXSpreadChildField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::JSXSpreadChild(
                        self::fields::JSXSpreadChildField::Expr,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXSpreadChild { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXText {
    #[doc = "Calls [FoldAstPath`::fold_jsx_text`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_text(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXText { span, value, raw } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXText(self::fields::JSXTextField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXText(self::fields::JSXTextField::Value));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let raw = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::JSXText(self::fields::JSXTextField::Raw));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                JSXText { span, value, raw }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Key {
    #[doc = "Calls [FoldAstPath`::fold_key`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_key(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Key::Private { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Key(self::fields::KeyField::Private));
                let _field_0 = <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Key::Private { 0: _field_0 }
            }
            Key::Public { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Key(self::fields::KeyField::Public));
                let _field_0 = <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Key::Public { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for KeyValuePatProp {
    #[doc = "Calls [FoldAstPath`::fold_key_value_pat_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_key_value_pat_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            KeyValuePatProp { key, value } => {
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValuePatProp(
                        self::fields::KeyValuePatPropField::Key,
                    ));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValuePatProp(
                        self::fields::KeyValuePatPropField::Value,
                    ));
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                KeyValuePatProp { key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for KeyValueProp {
    #[doc = "Calls [FoldAstPath`::fold_key_value_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_key_value_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            KeyValueProp { key, value } => {
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValueProp(
                        self::fields::KeyValuePropField::Key,
                    ));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::KeyValueProp(
                        self::fields::KeyValuePropField::Value,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                KeyValueProp { key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for LabeledStmt {
    #[doc = "Calls [FoldAstPath`::fold_labeled_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_labeled_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            LabeledStmt { span, label, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LabeledStmt(
                        self::fields::LabeledStmtField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let label = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LabeledStmt(
                        self::fields::LabeledStmtField::Label,
                    ));
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                        label,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LabeledStmt(
                        self::fields::LabeledStmtField::Body,
                    ));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                LabeledStmt { span, label, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Lit {
    #[doc = "Calls [FoldAstPath`::fold_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_lit(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Lit::Str { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Str));
                let _field_0 = <Str as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Lit::Str { 0: _field_0 }
            }
            Lit::Bool { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Bool));
                let _field_0 = <Bool as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Lit::Bool { 0: _field_0 }
            }
            Lit::Null { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Null));
                let _field_0 = <Null as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Lit::Null { 0: _field_0 }
            }
            Lit::Num { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Num));
                let _field_0 = <Number as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Lit::Num { 0: _field_0 }
            }
            Lit::BigInt { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::BigInt));
                let _field_0 = <BigInt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Lit::BigInt { 0: _field_0 }
            }
            Lit::Regex { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Regex));
                let _field_0 = <Regex as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Lit::Regex { 0: _field_0 }
            }
            Lit::JSXText { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Lit(self::fields::LitField::Jsxtext));
                let _field_0 = <JSXText as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Lit::JSXText { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MemberExpr {
    #[doc = "Calls [FoldAstPath`::fold_member_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_member_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            MemberExpr { span, obj, prop } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberExpr(
                        self::fields::MemberExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let obj = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberExpr(
                        self::fields::MemberExprField::Obj,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let prop = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberExpr(
                        self::fields::MemberExprField::Prop,
                    ));
                    <MemberProp as FoldWithAstPath<V>>::fold_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                MemberExpr { span, obj, prop }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MemberProp {
    #[doc = "Calls [FoldAstPath`::fold_member_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_member_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberProp(
                    self::fields::MemberPropField::Ident,
                ));
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                MemberProp::Ident { 0: _field_0 }
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberProp(
                    self::fields::MemberPropField::PrivateName,
                ));
                let _field_0 = <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                MemberProp::PrivateName { 0: _field_0 }
            }
            MemberProp::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::MemberProp(
                    self::fields::MemberPropField::Computed,
                ));
                let _field_0 = <ComputedPropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                MemberProp::Computed { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MetaPropExpr {
    #[doc = "Calls [FoldAstPath`::fold_meta_prop_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_meta_prop_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            MetaPropExpr { span, kind } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MetaPropExpr(
                        self::fields::MetaPropExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MetaPropExpr(
                        self::fields::MetaPropExprField::Kind,
                    ));
                    <MetaPropKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                MetaPropExpr { span, kind }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MetaPropKind {
    #[doc = "Calls [FoldAstPath`::fold_meta_prop_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_meta_prop_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            MetaPropKind::NewTarget => MetaPropKind::NewTarget,
            MetaPropKind::ImportMeta => MetaPropKind::ImportMeta,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MethodKind {
    #[doc = "Calls [FoldAstPath`::fold_method_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_method_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            MethodKind::Method => MethodKind::Method,
            MethodKind::Getter => MethodKind::Getter,
            MethodKind::Setter => MethodKind::Setter,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MethodProp {
    #[doc = "Calls [FoldAstPath`::fold_method_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_method_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            MethodProp { key, function } => {
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MethodProp(
                        self::fields::MethodPropField::Key,
                    ));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let function = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::MethodProp(
                        self::fields::MethodPropField::Function,
                    ));
                    <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                MethodProp { key, function }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Module {
    #[doc = "Calls [FoldAstPath`::fold_module`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Module(self::fields::ModuleField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Module(
                        self::fields::ModuleField::Body(usize::MAX),
                    ));
                    <Vec<ModuleItem> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let shebang = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Module(self::fields::ModuleField::Shebang));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        shebang,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Module {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ModuleDecl {
    #[doc = "Calls [FoldAstPath`::fold_module_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::Import,
                ));
                let _field_0 = <ImportDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::Import { 0: _field_0 }
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportDecl,
                ));
                let _field_0 = <ExportDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::ExportDecl { 0: _field_0 }
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportNamed,
                ));
                let _field_0 = <NamedExport as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::ExportNamed { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportDefaultDecl,
                ));
                let _field_0 = <ExportDefaultDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::ExportDefaultDecl { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportDefaultExpr,
                ));
                let _field_0 = <ExportDefaultExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::ExportDefaultExpr { 0: _field_0 }
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::ExportAll,
                ));
                let _field_0 = <ExportAll as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::ExportAll { 0: _field_0 }
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::TsImportEquals,
                ));
                let _field_0 = <Box<TsImportEqualsDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::TsImportEquals { 0: _field_0 }
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::TsExportAssignment,
                ));
                let _field_0 = <TsExportAssignment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::TsExportAssignment { 0: _field_0 }
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleDecl(
                    self::fields::ModuleDeclField::TsNamespaceExport,
                ));
                let _field_0 = <TsNamespaceExportDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleDecl::TsNamespaceExport { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ModuleExportName {
    #[doc = "Calls [FoldAstPath`::fold_module_export_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_export_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleExportName(
                    self::fields::ModuleExportNameField::Ident,
                ));
                let _field_0 = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleExportName::Ident { 0: _field_0 }
            }
            ModuleExportName::Str { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleExportName(
                    self::fields::ModuleExportNameField::Str,
                ));
                let _field_0 = <Str as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleExportName::Str { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ModuleItem {
    #[doc = "Calls [FoldAstPath`::fold_module_item`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_item(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleItem(
                    self::fields::ModuleItemField::ModuleDecl,
                ));
                let _field_0 = <ModuleDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleItem::ModuleDecl { 0: _field_0 }
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ModuleItem(
                    self::fields::ModuleItemField::Stmt,
                ));
                let _field_0 = <Stmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ModuleItem::Stmt { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for NamedExport {
    #[doc = "Calls [FoldAstPath`::fold_named_export`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_named_export(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let specifiers = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::Specifiers(usize::MAX),
                    ));
                    <Vec<ExportSpecifier> as FoldWithAstPath<V>>::fold_with_ast_path(
                        specifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let src = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::Src,
                    ));
                    <Option<Box<Str>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        src,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let with = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedExport(
                        self::fields::NamedExportField::With,
                    ));
                    <Option<Box<ObjectLit>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        with,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                NamedExport {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for NewExpr {
    #[doc = "Calls [FoldAstPath`::fold_new_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_new_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let callee = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::Callee));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let args = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NewExpr(
                        self::fields::NewExprField::Args(usize::MAX),
                    ));
                    <Option<Vec<ExprOrSpread>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_args = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::NewExpr(self::fields::NewExprField::TypeArgs));
                    < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
                NewExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Null {
    #[doc = "Calls [FoldAstPath`::fold_null`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_null(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Null { span } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Null(self::fields::NullField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Null { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Number {
    #[doc = "Calls [FoldAstPath`::fold_number`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_number(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Number { span, value, raw } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Number(self::fields::NumberField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let raw = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Number(self::fields::NumberField::Raw));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Number { span, value, raw }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ObjectLit {
    #[doc = "Calls [FoldAstPath`::fold_object_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_lit(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ObjectLit { span, props } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ObjectLit(self::fields::ObjectLitField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let props = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectLit(
                        self::fields::ObjectLitField::Props(usize::MAX),
                    ));
                    <Vec<PropOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                        props,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ObjectLit { span, props }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ObjectPat {
    #[doc = "Calls [FoldAstPath`::fold_object_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_pat(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ObjectPat(self::fields::ObjectPatField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let props = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPat(
                        self::fields::ObjectPatField::Props(usize::MAX),
                    ));
                    <Vec<ObjectPatProp> as FoldWithAstPath<V>>::fold_with_ast_path(
                        props,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_ann = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPat(
                        self::fields::ObjectPatField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ObjectPat {
                    span,
                    props,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ObjectPatProp {
    #[doc = "Calls [FoldAstPath`::fold_object_pat_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_pat_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPatProp(
                    self::fields::ObjectPatPropField::KeyValue,
                ));
                let _field_0 = <KeyValuePatProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ObjectPatProp::KeyValue { 0: _field_0 }
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPatProp(
                    self::fields::ObjectPatPropField::Assign,
                ));
                let _field_0 = <AssignPatProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ObjectPatProp::Assign { 0: _field_0 }
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ObjectPatProp(
                    self::fields::ObjectPatPropField::Rest,
                ));
                let _field_0 = <RestPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ObjectPatProp::Rest { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for OptCall {
    #[doc = "Calls [FoldAstPath`::fold_opt_call`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_call(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let callee = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::Callee));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        callee,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let args = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::OptCall(
                        self::fields::OptCallField::Args(usize::MAX),
                    ));
                    <Vec<ExprOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                        args,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_args = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::OptCall(self::fields::OptCallField::TypeArgs));
                    < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , & mut * __ast_path)
                };
                OptCall {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for OptChainBase {
    #[doc = "Calls [FoldAstPath`::fold_opt_chain_base`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_chain_base(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainBase(
                    self::fields::OptChainBaseField::Member,
                ));
                let _field_0 = <MemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                OptChainBase::Member { 0: _field_0 }
            }
            OptChainBase::Call { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainBase(
                    self::fields::OptChainBaseField::Call,
                ));
                let _field_0 = <OptCall as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                OptChainBase::Call { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for OptChainExpr {
    #[doc = "Calls [FoldAstPath`::fold_opt_chain_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_chain_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainExpr(
                        self::fields::OptChainExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let base = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::OptChainExpr(
                        self::fields::OptChainExprField::Base,
                    ));
                    <Box<OptChainBase> as FoldWithAstPath<V>>::fold_with_ast_path(
                        base,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                OptChainExpr {
                    span,
                    optional,
                    base,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Param {
    #[doc = "Calls [FoldAstPath`::fold_param`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_param(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Param(self::fields::ParamField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decorators = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Param(
                        self::fields::ParamField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let pat = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Param(self::fields::ParamField::Pat));
                    <Pat as FoldWithAstPath<V>>::fold_with_ast_path(pat, visitor, &mut *__ast_path)
                };
                Param {
                    span,
                    decorators,
                    pat,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ParamOrTsParamProp {
    #[doc = "Calls [FoldAstPath`::fold_param_or_ts_param_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_param_or_ts_param_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ParamOrTsParamProp(
                    self::fields::ParamOrTsParamPropField::TsParamProp,
                ));
                let _field_0 = <TsParamProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ParamOrTsParamProp::TsParamProp { 0: _field_0 }
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::ParamOrTsParamProp(
                    self::fields::ParamOrTsParamPropField::Param,
                ));
                let _field_0 = <Param as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                ParamOrTsParamProp::Param { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ParenExpr {
    #[doc = "Calls [FoldAstPath`::fold_paren_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_paren_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ParenExpr { span, expr } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ParenExpr(self::fields::ParenExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ParenExpr(self::fields::ParenExprField::Expr));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ParenExpr { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Pat {
    #[doc = "Calls [FoldAstPath`::fold_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_pat(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Pat::Ident { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Ident));
                let _field_0 = <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Pat::Ident { 0: _field_0 }
            }
            Pat::Array { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Array));
                let _field_0 = <ArrayPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Pat::Array { 0: _field_0 }
            }
            Pat::Rest { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Rest));
                let _field_0 = <RestPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Pat::Rest { 0: _field_0 }
            }
            Pat::Object { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Object));
                let _field_0 = <ObjectPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Pat::Object { 0: _field_0 }
            }
            Pat::Assign { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Assign));
                let _field_0 = <AssignPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Pat::Assign { 0: _field_0 }
            }
            Pat::Invalid { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Invalid));
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Pat::Invalid { 0: _field_0 }
            }
            Pat::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Pat(self::fields::PatField::Expr));
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Pat::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PrivateMethod {
    #[doc = "Calls [FoldAstPath`::fold_private_method`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_private_method(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Key,
                    ));
                    <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let function = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Function,
                    ));
                    <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                        function,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Kind,
                    ));
                    <MethodKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let accessibility = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateMethod(
                        self::fields::PrivateMethodField::Accessibility,
                    ));
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                PrivateMethod {
                    span,
                    key,
                    function,
                    kind,
                    is_static,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PrivateName {
    #[doc = "Calls [FoldAstPath`::fold_private_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_private_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            PrivateName { span, name } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateName(
                        self::fields::PrivateNameField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateName(
                        self::fields::PrivateNameField::Name,
                    ));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                PrivateName { span, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PrivateProp {
    #[doc = "Calls [FoldAstPath`::fold_private_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_private_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Ctxt,
                    ));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Key,
                    ));
                    <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Value,
                    ));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_ann = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::TypeAnn,
                    ));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decorators = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Decorators(usize::MAX),
                    ));
                    <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decorators,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let accessibility = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::PrivateProp(
                        self::fields::PrivatePropField::Accessibility,
                    ));
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                PrivateProp {
                    span,
                    ctxt,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_optional,
                    is_override,
                    readonly,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Program {
    #[doc = "Calls [FoldAstPath`::fold_program`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_program(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Program::Module { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Program(self::fields::ProgramField::Module));
                let _field_0 = <Module as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Program::Module { 0: _field_0 }
            }
            Program::Script { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Program(self::fields::ProgramField::Script));
                let _field_0 = <Script as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Program::Script { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Prop {
    #[doc = "Calls [FoldAstPath`::fold_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Shorthand));
                let _field_0 = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Prop::Shorthand { 0: _field_0 }
            }
            Prop::KeyValue { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::KeyValue));
                let _field_0 = <KeyValueProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Prop::KeyValue { 0: _field_0 }
            }
            Prop::Assign { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Assign));
                let _field_0 = <AssignProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Prop::Assign { 0: _field_0 }
            }
            Prop::Getter { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Getter));
                let _field_0 = <GetterProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Prop::Getter { 0: _field_0 }
            }
            Prop::Setter { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Setter));
                let _field_0 = <SetterProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Prop::Setter { 0: _field_0 }
            }
            Prop::Method { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Prop(self::fields::PropField::Method));
                let _field_0 = <MethodProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Prop::Method { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PropName {
    #[doc = "Calls [FoldAstPath`::fold_prop_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop_name(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            PropName::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::Ident));
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                PropName::Ident { 0: _field_0 }
            }
            PropName::Str { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::Str));
                let _field_0 = <Str as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                PropName::Str { 0: _field_0 }
            }
            PropName::Num { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::Num));
                let _field_0 = <Number as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                PropName::Num { 0: _field_0 }
            }
            PropName::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::PropName(
                    self::fields::PropNameField::Computed,
                ));
                let _field_0 = <ComputedPropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                PropName::Computed { 0: _field_0 }
            }
            PropName::BigInt { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::PropName(self::fields::PropNameField::BigInt));
                let _field_0 = <BigInt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                PropName::BigInt { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PropOrSpread {
    #[doc = "Calls [FoldAstPath`::fold_prop_or_spread`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop_or_spread(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::PropOrSpread(
                    self::fields::PropOrSpreadField::Spread,
                ));
                let _field_0 = <SpreadElement as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                PropOrSpread::Spread { 0: _field_0 }
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::PropOrSpread(
                    self::fields::PropOrSpreadField::Prop,
                ));
                let _field_0 = <Box<Prop> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                PropOrSpread::Prop { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Regex {
    #[doc = "Calls [FoldAstPath`::fold_regex`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_regex(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Regex { span, exp, flags } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Regex(self::fields::RegexField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let exp = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Regex(self::fields::RegexField::Exp));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        exp,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let flags = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Regex(self::fields::RegexField::Flags));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        flags,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Regex { span, exp, flags }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for RestPat {
    #[doc = "Calls [FoldAstPath`::fold_rest_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_rest_pat(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::RestPat(self::fields::RestPatField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let dot3_token = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::RestPat(
                        self::fields::RestPatField::Dot3Token,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        dot3_token,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let arg = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::RestPat(self::fields::RestPatField::Arg));
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_ann = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::RestPat(self::fields::RestPatField::TypeAnn));
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_ann,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                RestPat {
                    span,
                    dot3_token,
                    arg,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ReturnStmt {
    #[doc = "Calls [FoldAstPath`::fold_return_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_return_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ReturnStmt { span, arg } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ReturnStmt(
                        self::fields::ReturnStmtField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let arg = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ReturnStmt(
                        self::fields::ReturnStmtField::Arg,
                    ));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ReturnStmt { span, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Script {
    #[doc = "Calls [FoldAstPath`::fold_script`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_script(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Script(self::fields::ScriptField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Script(
                        self::fields::ScriptField::Body(usize::MAX),
                    ));
                    <Vec<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let shebang = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Script(self::fields::ScriptField::Shebang));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        shebang,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Script {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SeqExpr {
    #[doc = "Calls [FoldAstPath`::fold_seq_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_seq_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SeqExpr { span, exprs } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::SeqExpr(self::fields::SeqExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let exprs = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SeqExpr(
                        self::fields::SeqExprField::Exprs(usize::MAX),
                    ));
                    <Vec<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        exprs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                SeqExpr { span, exprs }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SetterProp {
    #[doc = "Calls [FoldAstPath`::fold_setter_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_setter_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let key = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Key,
                    ));
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                        key,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let this_param = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::ThisParam,
                    ));
                    <Option<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                        this_param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let param = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Param,
                    ));
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                        param,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SetterProp(
                        self::fields::SetterPropField::Body,
                    ));
                    <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                SetterProp {
                    span,
                    key,
                    this_param,
                    param,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SimpleAssignTarget {
    #[doc = "Calls [FoldAstPath`::fold_simple_assign_target`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_simple_assign_target(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Ident,
                ));
                let _field_0 = <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::Ident { 0: _field_0 }
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Member,
                ));
                let _field_0 = <MemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::Member { 0: _field_0 }
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::SuperProp,
                ));
                let _field_0 = <SuperPropExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::SuperProp { 0: _field_0 }
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Paren,
                ));
                let _field_0 = <ParenExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::Paren { 0: _field_0 }
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::OptChain,
                ));
                let _field_0 = <OptChainExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::OptChain { 0: _field_0 }
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsAs,
                ));
                let _field_0 = <TsAsExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::TsAs { 0: _field_0 }
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsSatisfies,
                ));
                let _field_0 = <TsSatisfiesExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::TsSatisfies { 0: _field_0 }
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsNonNull,
                ));
                let _field_0 = <TsNonNullExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::TsNonNull { 0: _field_0 }
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsTypeAssertion,
                ));
                let _field_0 = <TsTypeAssertion as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::TsTypeAssertion { 0: _field_0 }
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::TsInstantiation,
                ));
                let _field_0 = <TsInstantiation as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::TsInstantiation { 0: _field_0 }
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SimpleAssignTarget(
                    self::fields::SimpleAssignTargetField::Invalid,
                ));
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SimpleAssignTarget::Invalid { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SpreadElement {
    #[doc = "Calls [FoldAstPath`::fold_spread_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_spread_element(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SpreadElement { dot3_token, expr } => {
                let dot3_token = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SpreadElement(
                        self::fields::SpreadElementField::Dot3Token,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        dot3_token,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let expr = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SpreadElement(
                        self::fields::SpreadElementField::Expr,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        expr,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                SpreadElement { dot3_token, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for StaticBlock {
    #[doc = "Calls [FoldAstPath`::fold_static_block`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_static_block(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            StaticBlock { span, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::StaticBlock(
                        self::fields::StaticBlockField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::StaticBlock(
                        self::fields::StaticBlockField::Body,
                    ));
                    <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                StaticBlock { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Stmt {
    #[doc = "Calls [FoldAstPath`::fold_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Stmt::Block { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Block));
                let _field_0 = <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Block { 0: _field_0 }
            }
            Stmt::Empty { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Empty));
                let _field_0 = <EmptyStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Empty { 0: _field_0 }
            }
            Stmt::Debugger { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Debugger));
                let _field_0 = <DebuggerStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Debugger { 0: _field_0 }
            }
            Stmt::With { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::With));
                let _field_0 = <WithStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::With { 0: _field_0 }
            }
            Stmt::Return { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Return));
                let _field_0 = <ReturnStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Return { 0: _field_0 }
            }
            Stmt::Labeled { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Labeled));
                let _field_0 = <LabeledStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Labeled { 0: _field_0 }
            }
            Stmt::Break { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Break));
                let _field_0 = <BreakStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Break { 0: _field_0 }
            }
            Stmt::Continue { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Continue));
                let _field_0 = <ContinueStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Continue { 0: _field_0 }
            }
            Stmt::If { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::If));
                let _field_0 = <IfStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::If { 0: _field_0 }
            }
            Stmt::Switch { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Switch));
                let _field_0 = <SwitchStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Switch { 0: _field_0 }
            }
            Stmt::Throw { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Throw));
                let _field_0 = <ThrowStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Throw { 0: _field_0 }
            }
            Stmt::Try { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Try));
                let _field_0 = <Box<TryStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Try { 0: _field_0 }
            }
            Stmt::While { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::While));
                let _field_0 = <WhileStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::While { 0: _field_0 }
            }
            Stmt::DoWhile { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::DoWhile));
                let _field_0 = <DoWhileStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::DoWhile { 0: _field_0 }
            }
            Stmt::For { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::For));
                let _field_0 = <ForStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::For { 0: _field_0 }
            }
            Stmt::ForIn { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::ForIn));
                let _field_0 = <ForInStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::ForIn { 0: _field_0 }
            }
            Stmt::ForOf { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::ForOf));
                let _field_0 = <ForOfStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::ForOf { 0: _field_0 }
            }
            Stmt::Decl { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Decl));
                let _field_0 = <Decl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Decl { 0: _field_0 }
            }
            Stmt::Expr { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Stmt(self::fields::StmtField::Expr));
                let _field_0 = <ExprStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Stmt::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Str {
    #[doc = "Calls [FoldAstPath`::fold_str`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_str(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Str { span, value, raw } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Str(self::fields::StrField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Str(self::fields::StrField::Value));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let raw = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Str(self::fields::StrField::Raw));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Str { span, value, raw }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Super {
    #[doc = "Calls [FoldAstPath`::fold_super`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_super(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Super { span } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Super(self::fields::SuperField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Super { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SuperProp {
    #[doc = "Calls [FoldAstPath`::fold_super_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_super_prop(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperProp(
                    self::fields::SuperPropField::Ident,
                ));
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SuperProp::Ident { 0: _field_0 }
            }
            SuperProp::Computed { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperProp(
                    self::fields::SuperPropField::Computed,
                ));
                let _field_0 = <ComputedPropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                SuperProp::Computed { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SuperPropExpr {
    #[doc = "Calls [FoldAstPath`::fold_super_prop_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_super_prop_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SuperPropExpr { span, obj, prop } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperPropExpr(
                        self::fields::SuperPropExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let obj = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperPropExpr(
                        self::fields::SuperPropExprField::Obj,
                    ));
                    <Super as FoldWithAstPath<V>>::fold_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let prop = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SuperPropExpr(
                        self::fields::SuperPropExprField::Prop,
                    ));
                    <SuperProp as FoldWithAstPath<V>>::fold_with_ast_path(
                        prop,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                SuperPropExpr { span, obj, prop }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SwitchCase {
    #[doc = "Calls [FoldAstPath`::fold_switch_case`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_switch_case(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SwitchCase { span, test, cons } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchCase(
                        self::fields::SwitchCaseField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let test = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchCase(
                        self::fields::SwitchCaseField::Test,
                    ));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let cons = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchCase(
                        self::fields::SwitchCaseField::Cons(usize::MAX),
                    ));
                    <Vec<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        cons,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                SwitchCase { span, test, cons }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SwitchStmt {
    #[doc = "Calls [FoldAstPath`::fold_switch_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_switch_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchStmt(
                        self::fields::SwitchStmtField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let discriminant = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchStmt(
                        self::fields::SwitchStmtField::Discriminant,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        discriminant,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let cases = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::SwitchStmt(
                        self::fields::SwitchStmtField::Cases(usize::MAX),
                    ));
                    <Vec<SwitchCase> as FoldWithAstPath<V>>::fold_with_ast_path(
                        cases,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                SwitchStmt {
                    span,
                    discriminant,
                    cases,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TaggedTpl {
    #[doc = "Calls [FoldAstPath`::fold_tagged_tpl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tagged_tpl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let tag = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Tag));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        tag,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let type_params = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TaggedTpl(
                        self::fields::TaggedTplField::TypeParams,
                    ));
                    < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_params , visitor , & mut * __ast_path)
                };
                let tpl = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TaggedTpl(self::fields::TaggedTplField::Tpl));
                    <Box<Tpl> as FoldWithAstPath<V>>::fold_with_ast_path(
                        tpl,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                TaggedTpl {
                    span,
                    ctxt,
                    tag,
                    type_params,
                    tpl,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ThisExpr {
    #[doc = "Calls [FoldAstPath`::fold_this_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_this_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ThisExpr { span } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ThisExpr(self::fields::ThisExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ThisExpr { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ThrowStmt {
    #[doc = "Calls [FoldAstPath`::fold_throw_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_throw_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ThrowStmt { span, arg } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ThrowStmt(self::fields::ThrowStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let arg = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::ThrowStmt(self::fields::ThrowStmtField::Arg));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ThrowStmt { span, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Tpl {
    #[doc = "Calls [FoldAstPath`::fold_tpl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tpl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Tpl(self::fields::TplField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let exprs = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Tpl(
                        self::fields::TplField::Exprs(usize::MAX),
                    ));
                    <Vec<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        exprs,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let quasis = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Tpl(
                        self::fields::TplField::Quasis(usize::MAX),
                    ));
                    <Vec<TplElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                        quasis,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Tpl {
                    span,
                    exprs,
                    quasis,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TplElement {
    #[doc = "Calls [FoldAstPath`::fold_tpl_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tpl_element(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TplElement(
                        self::fields::TplElementField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let cooked = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TplElement(
                        self::fields::TplElementField::Cooked,
                    ));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        cooked,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let raw = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TplElement(
                        self::fields::TplElementField::Raw,
                    ));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        raw,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                TplElement {
                    span,
                    tail,
                    cooked,
                    raw,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TruePlusMinus {
    #[doc = "Calls [FoldAstPath`::fold_true_plus_minus`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_true_plus_minus(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            TruePlusMinus::True => TruePlusMinus::True,
            TruePlusMinus::Plus => TruePlusMinus::Plus,
            TruePlusMinus::Minus => TruePlusMinus::Minus,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TryStmt {
    #[doc = "Calls [FoldAstPath`::fold_try_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_try_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TryStmt(self::fields::TryStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let block = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TryStmt(self::fields::TryStmtField::Block));
                    <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                        block,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let handler = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::TryStmt(self::fields::TryStmtField::Handler));
                    <Option<CatchClause> as FoldWithAstPath<V>>::fold_with_ast_path(
                        handler,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let finalizer = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::TryStmt(
                        self::fields::TryStmtField::Finalizer,
                    ));
                    <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        finalizer,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                TryStmt {
                    span,
                    block,
                    handler,
                    finalizer,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UnaryExpr {
    #[doc = "Calls [FoldAstPath`::fold_unary_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_unary_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            UnaryExpr { span, op, arg } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UnaryExpr(self::fields::UnaryExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let op = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UnaryExpr(self::fields::UnaryExprField::Op));
                    <UnaryOp as FoldWithAstPath<V>>::fold_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let arg = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UnaryExpr(self::fields::UnaryExprField::Arg));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                UnaryExpr { span, op, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UnaryOp {
    #[doc = "Calls [FoldAstPath`::fold_unary_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_unary_op(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            UnaryOp::Minus => UnaryOp::Minus,
            UnaryOp::Plus => UnaryOp::Plus,
            UnaryOp::Bang => UnaryOp::Bang,
            UnaryOp::Tilde => UnaryOp::Tilde,
            UnaryOp::TypeOf => UnaryOp::TypeOf,
            UnaryOp::Void => UnaryOp::Void,
            UnaryOp::Delete => UnaryOp::Delete,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UpdateExpr {
    #[doc = "Calls [FoldAstPath`::fold_update_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_update_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::UpdateExpr(
                        self::fields::UpdateExprField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let op = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UpdateExpr(self::fields::UpdateExprField::Op));
                    <UpdateOp as FoldWithAstPath<V>>::fold_with_ast_path(
                        op,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let arg = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::UpdateExpr(
                        self::fields::UpdateExprField::Arg,
                    ));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                UpdateExpr {
                    span,
                    op,
                    prefix,
                    arg,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UpdateOp {
    #[doc = "Calls [FoldAstPath`::fold_update_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_update_op(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            UpdateOp::PlusPlus => UpdateOp::PlusPlus,
            UpdateOp::MinusMinus => UpdateOp::MinusMinus,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UsingDecl {
    #[doc = "Calls [FoldAstPath`::fold_using_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_using_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::UsingDecl(self::fields::UsingDeclField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decls = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::UsingDecl(
                        self::fields::UsingDeclField::Decls(usize::MAX),
                    ));
                    <Vec<VarDeclarator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decls,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                UsingDecl {
                    span,
                    is_await,
                    decls,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDecl {
    #[doc = "Calls [FoldAstPath`::fold_var_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_decl(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::VarDecl(self::fields::VarDeclField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let ctxt = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::VarDecl(self::fields::VarDeclField::Ctxt));
                    <swc_common::SyntaxContext as FoldWithAstPath<V>>::fold_with_ast_path(
                        ctxt,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::VarDecl(self::fields::VarDeclField::Kind));
                    <VarDeclKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let decls = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDecl(
                        self::fields::VarDeclField::Decls(usize::MAX),
                    ));
                    <Vec<VarDeclarator> as FoldWithAstPath<V>>::fold_with_ast_path(
                        decls,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                VarDecl {
                    span,
                    ctxt,
                    kind,
                    declare,
                    decls,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDeclKind {
    #[doc = "Calls [FoldAstPath`::fold_var_decl_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_decl_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDeclKind::Var => VarDeclKind::Var,
            VarDeclKind::Let => VarDeclKind::Let,
            VarDeclKind::Const => VarDeclKind::Const,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDeclOrExpr {
    #[doc = "Calls [FoldAstPath`::fold_var_decl_or_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_decl_or_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclOrExpr(
                    self::fields::VarDeclOrExprField::VarDecl,
                ));
                let _field_0 = <Box<VarDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                VarDeclOrExpr::VarDecl { 0: _field_0 }
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclOrExpr(
                    self::fields::VarDeclOrExprField::Expr,
                ));
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                VarDeclOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDeclarator {
    #[doc = "Calls [FoldAstPath`::fold_var_declarator`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_declarator(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclarator(
                        self::fields::VarDeclaratorField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclarator(
                        self::fields::VarDeclaratorField::Name,
                    ));
                    <Pat as FoldWithAstPath<V>>::fold_with_ast_path(name, visitor, &mut *__ast_path)
                };
                let init = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::VarDeclarator(
                        self::fields::VarDeclaratorField::Init,
                    ));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        init,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                VarDeclarator {
                    span,
                    name,
                    init,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for WhileStmt {
    #[doc = "Calls [FoldAstPath`::fold_while_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_while_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            WhileStmt { span, test, body } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WhileStmt(self::fields::WhileStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let test = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WhileStmt(self::fields::WhileStmtField::Test));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        test,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WhileStmt(self::fields::WhileStmtField::Body));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                WhileStmt { span, test, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for WithStmt {
    #[doc = "Calls [FoldAstPath`::fold_with_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_with_stmt(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            WithStmt { span, obj, body } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WithStmt(self::fields::WithStmtField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let obj = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WithStmt(self::fields::WithStmtField::Obj));
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                        obj,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::WithStmt(self::fields::WithStmtField::Body));
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                WithStmt { span, obj, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for YieldExpr {
    #[doc = "Calls [FoldAstPath`::fold_yield_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_yield_expr(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::YieldExpr(self::fields::YieldExprField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let arg = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::YieldExpr(self::fields::YieldExprField::Arg));
                    <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        arg,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                YieldExpr {
                    span,
                    arg,
                    delegate,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [FoldAstPath`::fold_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BigIntValue {
    #[doc = "Calls [FoldAstPath`::fold_big_int_value`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_big_int_value(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ClassMember> {
    #[doc = "Calls [FoldAstPath`::fold_class_members`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_members(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ClassMember as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Decorator> {
    #[doc = "Calls [FoldAstPath`::fold_decorators`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_decorators(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Decorator as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [FoldAstPath`::fold_export_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_specifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ExportSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ExprOrSpread as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Box<Expr>> {
    #[doc = "Calls [FoldAstPath`::fold_exprs`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_exprs(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [FoldAstPath`::fold_import_specifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_specifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ImportSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ImportWithItem> {
    #[doc = "Calls [FoldAstPath`::fold_import_with_items`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_with_items(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ImportWithItem as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <JSXAttrOrSpread as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<JSXElementChild> {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element_childs`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element_childs(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <JSXElementChild as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ModuleItem> {
    #[doc = "Calls [FoldAstPath`::fold_module_items`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_items(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ModuleItem as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [FoldAstPath`::fold_object_pat_props`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_pat_props(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ObjectPatProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [FoldAstPath`::fold_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<BlockStmt> {
    #[doc = "Calls [FoldAstPath`::fold_opt_block_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_block_stmt(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<CatchClause> {
    #[doc = "Calls [FoldAstPath`::fold_opt_catch_clause`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_catch_clause(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <CatchClause as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<Expr>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_expr(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<ExprOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_opt_expr_or_spread`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_expr_or_spread(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <ExprOrSpread as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Vec<ExprOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                inner, visitor, __ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Ident> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ident`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ident(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Ident as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<JSXAttrValue> {
    #[doc = "Calls [FoldAstPath`::fold_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_jsx_attr_value(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <JSXAttrValue as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<JSXClosingElement> {
    #[doc = "Calls [FoldAstPath`::fold_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_jsx_closing_element(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <JSXClosingElement as FoldWithAstPath<V>>::fold_with_ast_path(
                inner, visitor, __ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<ModuleExportName> {
    #[doc = "Calls [FoldAstPath`::fold_opt_module_export_name`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_module_export_name(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <ModuleExportName as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_object_lit`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_object_lit(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<ObjectLit> as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Pat> {
    #[doc = "Calls [FoldAstPath`::fold_opt_pat`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_pat(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Pat as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<swc_common::Span> {
    #[doc = "Calls [FoldAstPath`::fold_opt_span`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_span(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<Stmt>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_stmt`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_stmt(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<Str>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_str`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_str(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<Str> as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [FoldAstPath`::fold_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_var_decl_or_expr(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <VarDeclOrExpr as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_vec_expr_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Option<ExprOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Option<Pat>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_vec_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_vec_pats(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Option<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [FoldAstPath`::fold_param_or_ts_param_props`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_param_or_ts_param_props(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ParamOrTsParamProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Param> {
    #[doc = "Calls [FoldAstPath`::fold_params`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_params(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Param as FoldWithAstPath<V>>::fold_with_ast_path(item, visitor, &mut *__ast_path)
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Pat> {
    #[doc = "Calls [FoldAstPath`::fold_pats`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_pats(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Pat as FoldWithAstPath<V>>::fold_with_ast_path(item, visitor, &mut *__ast_path)
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<PropOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_prop_or_spreads`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop_or_spreads(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <PropOrSpread as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [FoldAstPath`::fold_span`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_span(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Stmt> {
    #[doc = "Calls [FoldAstPath`::fold_stmts`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_stmts(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Stmt as FoldWithAstPath<V>>::fold_with_ast_path(item, visitor, &mut *__ast_path)
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<SwitchCase> {
    #[doc = "Calls [FoldAstPath`::fold_switch_cases`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_switch_cases(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <SwitchCase as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_common::SyntaxContext {
    #[doc = "Calls [FoldAstPath`::fold_syntax_context`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_syntax_context(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TplElement> {
    #[doc = "Calls [FoldAstPath`::fold_tpl_elements`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tpl_elements(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <TplElement as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<VarDeclarator> {
    #[doc = "Calls [FoldAstPath`::fold_var_declarators`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_declarators(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <VarDeclarator as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> FoldWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + FoldAstPath,
    T: FoldWithAstPath<V>,
{
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        swc_visit::util::map::Map::map(self, |inner| {
            <T as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        swc_visit::util::map::Map::map(self, |inner| {
            <T as FoldWithAstPath<V>>::fold_children_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
pub type AstKindPath = swc_visit::AstKindPath<AstParentKind>;
#[cfg(any(docsrs, feature = "path"))]
pub type AstNodePath<'ast> = swc_visit::AstNodePath<AstParentNodeRef<'ast>>;
#[cfg(any(docsrs, feature = "path"))]
pub mod fields {
    use swc_ecma_ast::*;
    #[inline(always)]
    fn assert_initial_index(idx: usize, index: usize) {
        #[cfg(debug_assertions)]
        if !(idx == usize::MAX || index == usize::MAX) {
            {
                panic!("Should be usize::MAX");
            }
        }
    }
    impl ArrayLitField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Elems(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ArrayLitField {
        #[doc = "Represents [`ArrayLit::span`]"]
        Span,
        #[doc = "Represents [`ArrayLit::elems`]"]
        Elems(usize),
    }
    impl ArrayPatField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Elems(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ArrayPatField {
        #[doc = "Represents [`ArrayPat::span`]"]
        Span,
        #[doc = "Represents [`ArrayPat::elems`]"]
        Elems(usize),
        #[doc = "Represents [`ArrayPat::optional`]"]
        Optional,
        #[doc = "Represents [`ArrayPat::type_ann`]"]
        TypeAnn,
    }
    impl ArrowExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Params(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ArrowExprField {
        #[doc = "Represents [`ArrowExpr::span`]"]
        Span,
        #[doc = "Represents [`ArrowExpr::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`ArrowExpr::params`]"]
        Params(usize),
        #[doc = "Represents [`ArrowExpr::body`]"]
        Body,
        #[doc = "Represents [`ArrowExpr::is_async`]"]
        IsAsync,
        #[doc = "Represents [`ArrowExpr::is_generator`]"]
        IsGenerator,
        #[doc = "Represents [`ArrowExpr::type_params`]"]
        TypeParams,
        #[doc = "Represents [`ArrowExpr::return_type`]"]
        ReturnType,
    }
    impl AssignExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AssignExprField {
        #[doc = "Represents [`AssignExpr::span`]"]
        Span,
        #[doc = "Represents [`AssignExpr::op`]"]
        Op,
        #[doc = "Represents [`AssignExpr::left`]"]
        Left,
        #[doc = "Represents [`AssignExpr::right`]"]
        Right,
    }
    impl AssignOpField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AssignOpField {
        #[doc = "Represents [`AssignOp::Assign`]"]
        Assign,
        #[doc = "Represents [`AssignOp::AddAssign`]"]
        AddAssign,
        #[doc = "Represents [`AssignOp::SubAssign`]"]
        SubAssign,
        #[doc = "Represents [`AssignOp::MulAssign`]"]
        MulAssign,
        #[doc = "Represents [`AssignOp::DivAssign`]"]
        DivAssign,
        #[doc = "Represents [`AssignOp::ModAssign`]"]
        ModAssign,
        #[doc = "Represents [`AssignOp::LShiftAssign`]"]
        LshiftAssign,
        #[doc = "Represents [`AssignOp::RShiftAssign`]"]
        RshiftAssign,
        #[doc = "Represents [`AssignOp::ZeroFillRShiftAssign`]"]
        ZeroFillRShiftAssign,
        #[doc = "Represents [`AssignOp::BitOrAssign`]"]
        BitOrAssign,
        #[doc = "Represents [`AssignOp::BitXorAssign`]"]
        BitXorAssign,
        #[doc = "Represents [`AssignOp::BitAndAssign`]"]
        BitAndAssign,
        #[doc = "Represents [`AssignOp::ExpAssign`]"]
        ExpAssign,
        #[doc = "Represents [`AssignOp::AndAssign`]"]
        AndAssign,
        #[doc = "Represents [`AssignOp::OrAssign`]"]
        OrAssign,
        #[doc = "Represents [`AssignOp::NullishAssign`]"]
        NullishAssign,
    }
    impl AssignPatField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AssignPatField {
        #[doc = "Represents [`AssignPat::span`]"]
        Span,
        #[doc = "Represents [`AssignPat::left`]"]
        Left,
        #[doc = "Represents [`AssignPat::right`]"]
        Right,
    }
    impl AssignPatPropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AssignPatPropField {
        #[doc = "Represents [`AssignPatProp::span`]"]
        Span,
        #[doc = "Represents [`AssignPatProp::key`]"]
        Key,
        #[doc = "Represents [`AssignPatProp::value`]"]
        Value,
    }
    impl AssignPropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AssignPropField {
        #[doc = "Represents [`AssignProp::span`]"]
        Span,
        #[doc = "Represents [`AssignProp::key`]"]
        Key,
        #[doc = "Represents [`AssignProp::value`]"]
        Value,
    }
    impl AssignTargetField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AssignTargetField {
        #[doc = "Represents [`AssignTarget::Simple`]"]
        Simple,
        #[doc = "Represents [`AssignTarget::Pat`]"]
        Pat,
    }
    impl AssignTargetPatField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AssignTargetPatField {
        #[doc = "Represents [`AssignTargetPat::Array`]"]
        Array,
        #[doc = "Represents [`AssignTargetPat::Object`]"]
        Object,
        #[doc = "Represents [`AssignTargetPat::Invalid`]"]
        Invalid,
    }
    impl AutoAccessorField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Decorators(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AutoAccessorField {
        #[doc = "Represents [`AutoAccessor::span`]"]
        Span,
        #[doc = "Represents [`AutoAccessor::key`]"]
        Key,
        #[doc = "Represents [`AutoAccessor::value`]"]
        Value,
        #[doc = "Represents [`AutoAccessor::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`AutoAccessor::is_static`]"]
        IsStatic,
        #[doc = "Represents [`AutoAccessor::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`AutoAccessor::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`AutoAccessor::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`AutoAccessor::is_override`]"]
        IsOverride,
        #[doc = "Represents [`AutoAccessor::definite`]"]
        Definite,
    }
    impl AwaitExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AwaitExprField {
        #[doc = "Represents [`AwaitExpr::span`]"]
        Span,
        #[doc = "Represents [`AwaitExpr::arg`]"]
        Arg,
    }
    impl BigIntField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BigIntField {
        #[doc = "Represents [`BigInt::span`]"]
        Span,
        #[doc = "Represents [`BigInt::value`]"]
        Value,
        #[doc = "Represents [`BigInt::raw`]"]
        Raw,
    }
    impl BinExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BinExprField {
        #[doc = "Represents [`BinExpr::span`]"]
        Span,
        #[doc = "Represents [`BinExpr::op`]"]
        Op,
        #[doc = "Represents [`BinExpr::left`]"]
        Left,
        #[doc = "Represents [`BinExpr::right`]"]
        Right,
    }
    impl BinaryOpField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BinaryOpField {
        #[doc = "Represents [`BinaryOp::EqEq`]"]
        EqEq,
        #[doc = "Represents [`BinaryOp::NotEq`]"]
        NotEq,
        #[doc = "Represents [`BinaryOp::EqEqEq`]"]
        EqEqEq,
        #[doc = "Represents [`BinaryOp::NotEqEq`]"]
        NotEqEq,
        #[doc = "Represents [`BinaryOp::Lt`]"]
        Lt,
        #[doc = "Represents [`BinaryOp::LtEq`]"]
        LtEq,
        #[doc = "Represents [`BinaryOp::Gt`]"]
        Gt,
        #[doc = "Represents [`BinaryOp::GtEq`]"]
        GtEq,
        #[doc = "Represents [`BinaryOp::LShift`]"]
        Lshift,
        #[doc = "Represents [`BinaryOp::RShift`]"]
        Rshift,
        #[doc = "Represents [`BinaryOp::ZeroFillRShift`]"]
        ZeroFillRShift,
        #[doc = "Represents [`BinaryOp::Add`]"]
        Add,
        #[doc = "Represents [`BinaryOp::Sub`]"]
        Sub,
        #[doc = "Represents [`BinaryOp::Mul`]"]
        Mul,
        #[doc = "Represents [`BinaryOp::Div`]"]
        Div,
        #[doc = "Represents [`BinaryOp::Mod`]"]
        Mod,
        #[doc = "Represents [`BinaryOp::BitOr`]"]
        BitOr,
        #[doc = "Represents [`BinaryOp::BitXor`]"]
        BitXor,
        #[doc = "Represents [`BinaryOp::BitAnd`]"]
        BitAnd,
        #[doc = "Represents [`BinaryOp::LogicalOr`]"]
        LogicalOr,
        #[doc = "Represents [`BinaryOp::LogicalAnd`]"]
        LogicalAnd,
        #[doc = "Represents [`BinaryOp::In`]"]
        In,
        #[doc = "Represents [`BinaryOp::InstanceOf`]"]
        InstanceOf,
        #[doc = "Represents [`BinaryOp::Exp`]"]
        Exp,
        #[doc = "Represents [`BinaryOp::NullishCoalescing`]"]
        NullishCoalescing,
    }
    impl BindingIdentField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BindingIdentField {
        #[doc = "Represents [`BindingIdent::id`]"]
        Id,
        #[doc = "Represents [`BindingIdent::type_ann`]"]
        TypeAnn,
    }
    impl BlockStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Stmts(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BlockStmtField {
        #[doc = "Represents [`BlockStmt::span`]"]
        Span,
        #[doc = "Represents [`BlockStmt::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`BlockStmt::stmts`]"]
        Stmts(usize),
    }
    impl BlockStmtOrExprField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BlockStmtOrExprField {
        #[doc = "Represents [`BlockStmtOrExpr::BlockStmt`]"]
        BlockStmt,
        #[doc = "Represents [`BlockStmtOrExpr::Expr`]"]
        Expr,
    }
    impl BoolField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BoolField {
        #[doc = "Represents [`Bool::span`]"]
        Span,
        #[doc = "Represents [`Bool::value`]"]
        Value,
    }
    impl BreakStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BreakStmtField {
        #[doc = "Represents [`BreakStmt::span`]"]
        Span,
        #[doc = "Represents [`BreakStmt::label`]"]
        Label,
    }
    impl CallExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Args(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CallExprField {
        #[doc = "Represents [`CallExpr::span`]"]
        Span,
        #[doc = "Represents [`CallExpr::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`CallExpr::callee`]"]
        Callee,
        #[doc = "Represents [`CallExpr::args`]"]
        Args(usize),
        #[doc = "Represents [`CallExpr::type_args`]"]
        TypeArgs,
    }
    impl CalleeField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CalleeField {
        #[doc = "Represents [`Callee::Super`]"]
        Super,
        #[doc = "Represents [`Callee::Import`]"]
        Import,
        #[doc = "Represents [`Callee::Expr`]"]
        Expr,
    }
    impl CatchClauseField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CatchClauseField {
        #[doc = "Represents [`CatchClause::span`]"]
        Span,
        #[doc = "Represents [`CatchClause::param`]"]
        Param,
        #[doc = "Represents [`CatchClause::body`]"]
        Body,
    }
    impl ClassField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Decorators(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                Self::Implements(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassField {
        #[doc = "Represents [`Class::span`]"]
        Span,
        #[doc = "Represents [`Class::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Class::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`Class::body`]"]
        Body(usize),
        #[doc = "Represents [`Class::super_class`]"]
        SuperClass,
        #[doc = "Represents [`Class::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`Class::type_params`]"]
        TypeParams,
        #[doc = "Represents [`Class::super_type_params`]"]
        SuperTypeParams,
        #[doc = "Represents [`Class::implements`]"]
        Implements(usize),
    }
    impl ClassDeclField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassDeclField {
        #[doc = "Represents [`ClassDecl::ident`]"]
        Ident,
        #[doc = "Represents [`ClassDecl::declare`]"]
        Declare,
        #[doc = "Represents [`ClassDecl::class`]"]
        Class,
    }
    impl ClassExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassExprField {
        #[doc = "Represents [`ClassExpr::ident`]"]
        Ident,
        #[doc = "Represents [`ClassExpr::class`]"]
        Class,
    }
    impl ClassMemberField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassMemberField {
        #[doc = "Represents [`ClassMember::Constructor`]"]
        Constructor,
        #[doc = "Represents [`ClassMember::Method`]"]
        Method,
        #[doc = "Represents [`ClassMember::PrivateMethod`]"]
        PrivateMethod,
        #[doc = "Represents [`ClassMember::ClassProp`]"]
        ClassProp,
        #[doc = "Represents [`ClassMember::PrivateProp`]"]
        PrivateProp,
        #[doc = "Represents [`ClassMember::TsIndexSignature`]"]
        TsIndexSignature,
        #[doc = "Represents [`ClassMember::Empty`]"]
        Empty,
        #[doc = "Represents [`ClassMember::StaticBlock`]"]
        StaticBlock,
        #[doc = "Represents [`ClassMember::AutoAccessor`]"]
        AutoAccessor,
    }
    impl ClassMethodField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassMethodField {
        #[doc = "Represents [`ClassMethod::span`]"]
        Span,
        #[doc = "Represents [`ClassMethod::key`]"]
        Key,
        #[doc = "Represents [`ClassMethod::function`]"]
        Function,
        #[doc = "Represents [`ClassMethod::kind`]"]
        Kind,
        #[doc = "Represents [`ClassMethod::is_static`]"]
        IsStatic,
        #[doc = "Represents [`ClassMethod::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`ClassMethod::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`ClassMethod::is_optional`]"]
        IsOptional,
        #[doc = "Represents [`ClassMethod::is_override`]"]
        IsOverride,
    }
    impl ClassPropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Decorators(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassPropField {
        #[doc = "Represents [`ClassProp::span`]"]
        Span,
        #[doc = "Represents [`ClassProp::key`]"]
        Key,
        #[doc = "Represents [`ClassProp::value`]"]
        Value,
        #[doc = "Represents [`ClassProp::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`ClassProp::is_static`]"]
        IsStatic,
        #[doc = "Represents [`ClassProp::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`ClassProp::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`ClassProp::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`ClassProp::is_optional`]"]
        IsOptional,
        #[doc = "Represents [`ClassProp::is_override`]"]
        IsOverride,
        #[doc = "Represents [`ClassProp::readonly`]"]
        Readonly,
        #[doc = "Represents [`ClassProp::declare`]"]
        Declare,
        #[doc = "Represents [`ClassProp::definite`]"]
        Definite,
    }
    impl ComputedPropNameField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ComputedPropNameField {
        #[doc = "Represents [`ComputedPropName::span`]"]
        Span,
        #[doc = "Represents [`ComputedPropName::expr`]"]
        Expr,
    }
    impl CondExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CondExprField {
        #[doc = "Represents [`CondExpr::span`]"]
        Span,
        #[doc = "Represents [`CondExpr::test`]"]
        Test,
        #[doc = "Represents [`CondExpr::cons`]"]
        Cons,
        #[doc = "Represents [`CondExpr::alt`]"]
        Alt,
    }
    impl ConstructorField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Params(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ConstructorField {
        #[doc = "Represents [`Constructor::span`]"]
        Span,
        #[doc = "Represents [`Constructor::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Constructor::key`]"]
        Key,
        #[doc = "Represents [`Constructor::params`]"]
        Params(usize),
        #[doc = "Represents [`Constructor::body`]"]
        Body,
        #[doc = "Represents [`Constructor::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`Constructor::is_optional`]"]
        IsOptional,
    }
    impl ContinueStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ContinueStmtField {
        #[doc = "Represents [`ContinueStmt::span`]"]
        Span,
        #[doc = "Represents [`ContinueStmt::label`]"]
        Label,
    }
    impl DebuggerStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum DebuggerStmtField {
        #[doc = "Represents [`DebuggerStmt::span`]"]
        Span,
    }
    impl DeclField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum DeclField {
        #[doc = "Represents [`Decl::Class`]"]
        Class,
        #[doc = "Represents [`Decl::Fn`]"]
        Fn,
        #[doc = "Represents [`Decl::Var`]"]
        Var,
        #[doc = "Represents [`Decl::Using`]"]
        Using,
        #[doc = "Represents [`Decl::TsInterface`]"]
        TsInterface,
        #[doc = "Represents [`Decl::TsTypeAlias`]"]
        TsTypeAlias,
        #[doc = "Represents [`Decl::TsEnum`]"]
        TsEnum,
        #[doc = "Represents [`Decl::TsModule`]"]
        TsModule,
    }
    impl DecoratorField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum DecoratorField {
        #[doc = "Represents [`Decorator::span`]"]
        Span,
        #[doc = "Represents [`Decorator::expr`]"]
        Expr,
    }
    impl DefaultDeclField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum DefaultDeclField {
        #[doc = "Represents [`DefaultDecl::Class`]"]
        Class,
        #[doc = "Represents [`DefaultDecl::Fn`]"]
        Fn,
        #[doc = "Represents [`DefaultDecl::TsInterfaceDecl`]"]
        TsInterfaceDecl,
    }
    impl DoWhileStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum DoWhileStmtField {
        #[doc = "Represents [`DoWhileStmt::span`]"]
        Span,
        #[doc = "Represents [`DoWhileStmt::test`]"]
        Test,
        #[doc = "Represents [`DoWhileStmt::body`]"]
        Body,
    }
    impl EmptyStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum EmptyStmtField {
        #[doc = "Represents [`EmptyStmt::span`]"]
        Span,
    }
    impl ExportAllField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportAllField {
        #[doc = "Represents [`ExportAll::span`]"]
        Span,
        #[doc = "Represents [`ExportAll::src`]"]
        Src,
        #[doc = "Represents [`ExportAll::type_only`]"]
        TypeOnly,
        #[doc = "Represents [`ExportAll::with`]"]
        With,
    }
    impl ExportDeclField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportDeclField {
        #[doc = "Represents [`ExportDecl::span`]"]
        Span,
        #[doc = "Represents [`ExportDecl::decl`]"]
        Decl,
    }
    impl ExportDefaultDeclField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportDefaultDeclField {
        #[doc = "Represents [`ExportDefaultDecl::span`]"]
        Span,
        #[doc = "Represents [`ExportDefaultDecl::decl`]"]
        Decl,
    }
    impl ExportDefaultExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportDefaultExprField {
        #[doc = "Represents [`ExportDefaultExpr::span`]"]
        Span,
        #[doc = "Represents [`ExportDefaultExpr::expr`]"]
        Expr,
    }
    impl ExportDefaultSpecifierField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportDefaultSpecifierField {
        #[doc = "Represents [`ExportDefaultSpecifier::exported`]"]
        Exported,
    }
    impl ExportNamedSpecifierField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportNamedSpecifierField {
        #[doc = "Represents [`ExportNamedSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ExportNamedSpecifier::orig`]"]
        Orig,
        #[doc = "Represents [`ExportNamedSpecifier::exported`]"]
        Exported,
        #[doc = "Represents [`ExportNamedSpecifier::is_type_only`]"]
        IsTypeOnly,
    }
    impl ExportNamespaceSpecifierField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportNamespaceSpecifierField {
        #[doc = "Represents [`ExportNamespaceSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ExportNamespaceSpecifier::name`]"]
        Name,
    }
    impl ExportSpecifierField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExportSpecifierField {
        #[doc = "Represents [`ExportSpecifier::Namespace`]"]
        Namespace,
        #[doc = "Represents [`ExportSpecifier::Default`]"]
        Default,
        #[doc = "Represents [`ExportSpecifier::Named`]"]
        Named,
    }
    impl ExprField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExprField {
        #[doc = "Represents [`Expr::This`]"]
        This,
        #[doc = "Represents [`Expr::Array`]"]
        Array,
        #[doc = "Represents [`Expr::Object`]"]
        Object,
        #[doc = "Represents [`Expr::Fn`]"]
        Fn,
        #[doc = "Represents [`Expr::Unary`]"]
        Unary,
        #[doc = "Represents [`Expr::Update`]"]
        Update,
        #[doc = "Represents [`Expr::Bin`]"]
        Bin,
        #[doc = "Represents [`Expr::Assign`]"]
        Assign,
        #[doc = "Represents [`Expr::Member`]"]
        Member,
        #[doc = "Represents [`Expr::SuperProp`]"]
        SuperProp,
        #[doc = "Represents [`Expr::Cond`]"]
        Cond,
        #[doc = "Represents [`Expr::Call`]"]
        Call,
        #[doc = "Represents [`Expr::New`]"]
        New,
        #[doc = "Represents [`Expr::Seq`]"]
        Seq,
        #[doc = "Represents [`Expr::Ident`]"]
        Ident,
        #[doc = "Represents [`Expr::Lit`]"]
        Lit,
        #[doc = "Represents [`Expr::Tpl`]"]
        Tpl,
        #[doc = "Represents [`Expr::TaggedTpl`]"]
        TaggedTpl,
        #[doc = "Represents [`Expr::Arrow`]"]
        Arrow,
        #[doc = "Represents [`Expr::Class`]"]
        Class,
        #[doc = "Represents [`Expr::Yield`]"]
        Yield,
        #[doc = "Represents [`Expr::MetaProp`]"]
        MetaProp,
        #[doc = "Represents [`Expr::Await`]"]
        Await,
        #[doc = "Represents [`Expr::Paren`]"]
        Paren,
        #[doc = "Represents [`Expr::JSXMember`]"]
        Jsxmember,
        #[doc = "Represents [`Expr::JSXNamespacedName`]"]
        JsxnamespacedName,
        #[doc = "Represents [`Expr::JSXEmpty`]"]
        Jsxempty,
        #[doc = "Represents [`Expr::JSXElement`]"]
        Jsxelement,
        #[doc = "Represents [`Expr::JSXFragment`]"]
        Jsxfragment,
        #[doc = "Represents [`Expr::TsTypeAssertion`]"]
        TsTypeAssertion,
        #[doc = "Represents [`Expr::TsConstAssertion`]"]
        TsConstAssertion,
        #[doc = "Represents [`Expr::TsNonNull`]"]
        TsNonNull,
        #[doc = "Represents [`Expr::TsAs`]"]
        TsAs,
        #[doc = "Represents [`Expr::TsInstantiation`]"]
        TsInstantiation,
        #[doc = "Represents [`Expr::TsSatisfies`]"]
        TsSatisfies,
        #[doc = "Represents [`Expr::PrivateName`]"]
        PrivateName,
        #[doc = "Represents [`Expr::OptChain`]"]
        OptChain,
        #[doc = "Represents [`Expr::Invalid`]"]
        Invalid,
    }
    impl ExprOrSpreadField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExprOrSpreadField {
        #[doc = "Represents [`ExprOrSpread::spread`]"]
        Spread,
        #[doc = "Represents [`ExprOrSpread::expr`]"]
        Expr,
    }
    impl ExprStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ExprStmtField {
        #[doc = "Represents [`ExprStmt::span`]"]
        Span,
        #[doc = "Represents [`ExprStmt::expr`]"]
        Expr,
    }
    impl FnDeclField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum FnDeclField {
        #[doc = "Represents [`FnDecl::ident`]"]
        Ident,
        #[doc = "Represents [`FnDecl::declare`]"]
        Declare,
        #[doc = "Represents [`FnDecl::function`]"]
        Function,
    }
    impl FnExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum FnExprField {
        #[doc = "Represents [`FnExpr::ident`]"]
        Ident,
        #[doc = "Represents [`FnExpr::function`]"]
        Function,
    }
    impl ForHeadField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ForHeadField {
        #[doc = "Represents [`ForHead::VarDecl`]"]
        VarDecl,
        #[doc = "Represents [`ForHead::UsingDecl`]"]
        UsingDecl,
        #[doc = "Represents [`ForHead::Pat`]"]
        Pat,
    }
    impl ForInStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ForInStmtField {
        #[doc = "Represents [`ForInStmt::span`]"]
        Span,
        #[doc = "Represents [`ForInStmt::left`]"]
        Left,
        #[doc = "Represents [`ForInStmt::right`]"]
        Right,
        #[doc = "Represents [`ForInStmt::body`]"]
        Body,
    }
    impl ForOfStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ForOfStmtField {
        #[doc = "Represents [`ForOfStmt::span`]"]
        Span,
        #[doc = "Represents [`ForOfStmt::is_await`]"]
        IsAwait,
        #[doc = "Represents [`ForOfStmt::left`]"]
        Left,
        #[doc = "Represents [`ForOfStmt::right`]"]
        Right,
        #[doc = "Represents [`ForOfStmt::body`]"]
        Body,
    }
    impl ForStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ForStmtField {
        #[doc = "Represents [`ForStmt::span`]"]
        Span,
        #[doc = "Represents [`ForStmt::init`]"]
        Init,
        #[doc = "Represents [`ForStmt::test`]"]
        Test,
        #[doc = "Represents [`ForStmt::update`]"]
        Update,
        #[doc = "Represents [`ForStmt::body`]"]
        Body,
    }
    impl FunctionField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Params(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                Self::Decorators(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum FunctionField {
        #[doc = "Represents [`Function::params`]"]
        Params(usize),
        #[doc = "Represents [`Function::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`Function::span`]"]
        Span,
        #[doc = "Represents [`Function::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Function::body`]"]
        Body,
        #[doc = "Represents [`Function::is_generator`]"]
        IsGenerator,
        #[doc = "Represents [`Function::is_async`]"]
        IsAsync,
        #[doc = "Represents [`Function::type_params`]"]
        TypeParams,
        #[doc = "Represents [`Function::return_type`]"]
        ReturnType,
    }
    impl GetterPropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum GetterPropField {
        #[doc = "Represents [`GetterProp::span`]"]
        Span,
        #[doc = "Represents [`GetterProp::key`]"]
        Key,
        #[doc = "Represents [`GetterProp::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`GetterProp::body`]"]
        Body,
    }
    impl IdentField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum IdentField {
        #[doc = "Represents [`Ident::span`]"]
        Span,
        #[doc = "Represents [`Ident::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Ident::sym`]"]
        Sym,
        #[doc = "Represents [`Ident::optional`]"]
        Optional,
    }
    impl IdentNameField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum IdentNameField {
        #[doc = "Represents [`IdentName::span`]"]
        Span,
        #[doc = "Represents [`IdentName::sym`]"]
        Sym,
    }
    impl IfStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum IfStmtField {
        #[doc = "Represents [`IfStmt::span`]"]
        Span,
        #[doc = "Represents [`IfStmt::test`]"]
        Test,
        #[doc = "Represents [`IfStmt::cons`]"]
        Cons,
        #[doc = "Represents [`IfStmt::alt`]"]
        Alt,
    }
    impl ImportField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportField {
        #[doc = "Represents [`Import::span`]"]
        Span,
        #[doc = "Represents [`Import::phase`]"]
        Phase,
    }
    impl ImportDeclField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Specifiers(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportDeclField {
        #[doc = "Represents [`ImportDecl::span`]"]
        Span,
        #[doc = "Represents [`ImportDecl::specifiers`]"]
        Specifiers(usize),
        #[doc = "Represents [`ImportDecl::src`]"]
        Src,
        #[doc = "Represents [`ImportDecl::type_only`]"]
        TypeOnly,
        #[doc = "Represents [`ImportDecl::with`]"]
        With,
        #[doc = "Represents [`ImportDecl::phase`]"]
        Phase,
    }
    impl ImportDefaultSpecifierField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportDefaultSpecifierField {
        #[doc = "Represents [`ImportDefaultSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ImportDefaultSpecifier::local`]"]
        Local,
    }
    impl ImportNamedSpecifierField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportNamedSpecifierField {
        #[doc = "Represents [`ImportNamedSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ImportNamedSpecifier::local`]"]
        Local,
        #[doc = "Represents [`ImportNamedSpecifier::imported`]"]
        Imported,
        #[doc = "Represents [`ImportNamedSpecifier::is_type_only`]"]
        IsTypeOnly,
    }
    impl ImportPhaseField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportPhaseField {
        #[doc = "Represents [`ImportPhase::Evaluation`]"]
        Evaluation,
        #[doc = "Represents [`ImportPhase::Source`]"]
        Source,
        #[doc = "Represents [`ImportPhase::Defer`]"]
        Defer,
    }
    impl ImportSpecifierField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportSpecifierField {
        #[doc = "Represents [`ImportSpecifier::Named`]"]
        Named,
        #[doc = "Represents [`ImportSpecifier::Default`]"]
        Default,
        #[doc = "Represents [`ImportSpecifier::Namespace`]"]
        Namespace,
    }
    impl ImportStarAsSpecifierField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportStarAsSpecifierField {
        #[doc = "Represents [`ImportStarAsSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ImportStarAsSpecifier::local`]"]
        Local,
    }
    impl ImportWithField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Values(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportWithField {
        #[doc = "Represents [`ImportWith::span`]"]
        Span,
        #[doc = "Represents [`ImportWith::values`]"]
        Values(usize),
    }
    impl ImportWithItemField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ImportWithItemField {
        #[doc = "Represents [`ImportWithItem::key`]"]
        Key,
        #[doc = "Represents [`ImportWithItem::value`]"]
        Value,
    }
    impl InvalidField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum InvalidField {
        #[doc = "Represents [`Invalid::span`]"]
        Span,
    }
    impl JSXAttrField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXAttrField {
        #[doc = "Represents [`JSXAttr::span`]"]
        Span,
        #[doc = "Represents [`JSXAttr::name`]"]
        Name,
        #[doc = "Represents [`JSXAttr::value`]"]
        Value,
    }
    impl JSXAttrNameField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXAttrNameField {
        #[doc = "Represents [`JSXAttrName::Ident`]"]
        Ident,
        #[doc = "Represents [`JSXAttrName::JSXNamespacedName`]"]
        JsxnamespacedName,
    }
    impl JSXAttrOrSpreadField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXAttrOrSpreadField {
        #[doc = "Represents [`JSXAttrOrSpread::JSXAttr`]"]
        Jsxattr,
        #[doc = "Represents [`JSXAttrOrSpread::SpreadElement`]"]
        SpreadElement,
    }
    impl JSXAttrValueField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXAttrValueField {
        #[doc = "Represents [`JSXAttrValue::Lit`]"]
        Lit,
        #[doc = "Represents [`JSXAttrValue::JSXExprContainer`]"]
        JsxexprContainer,
        #[doc = "Represents [`JSXAttrValue::JSXElement`]"]
        Jsxelement,
        #[doc = "Represents [`JSXAttrValue::JSXFragment`]"]
        Jsxfragment,
    }
    impl JSXClosingElementField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXClosingElementField {
        #[doc = "Represents [`JSXClosingElement::span`]"]
        Span,
        #[doc = "Represents [`JSXClosingElement::name`]"]
        Name,
    }
    impl JSXClosingFragmentField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXClosingFragmentField {
        #[doc = "Represents [`JSXClosingFragment::span`]"]
        Span,
    }
    impl JSXElementField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Children(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXElementField {
        #[doc = "Represents [`JSXElement::span`]"]
        Span,
        #[doc = "Represents [`JSXElement::opening`]"]
        Opening,
        #[doc = "Represents [`JSXElement::children`]"]
        Children(usize),
        #[doc = "Represents [`JSXElement::closing`]"]
        Closing,
    }
    impl JSXElementChildField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXElementChildField {
        #[doc = "Represents [`JSXElementChild::JSXText`]"]
        Jsxtext,
        #[doc = "Represents [`JSXElementChild::JSXExprContainer`]"]
        JsxexprContainer,
        #[doc = "Represents [`JSXElementChild::JSXSpreadChild`]"]
        JsxspreadChild,
        #[doc = "Represents [`JSXElementChild::JSXElement`]"]
        Jsxelement,
        #[doc = "Represents [`JSXElementChild::JSXFragment`]"]
        Jsxfragment,
    }
    impl JSXElementNameField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXElementNameField {
        #[doc = "Represents [`JSXElementName::Ident`]"]
        Ident,
        #[doc = "Represents [`JSXElementName::JSXMemberExpr`]"]
        JsxmemberExpr,
        #[doc = "Represents [`JSXElementName::JSXNamespacedName`]"]
        JsxnamespacedName,
    }
    impl JSXEmptyExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXEmptyExprField {
        #[doc = "Represents [`JSXEmptyExpr::span`]"]
        Span,
    }
    impl JSXExprField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXExprField {
        #[doc = "Represents [`JSXExpr::JSXEmptyExpr`]"]
        JsxemptyExpr,
        #[doc = "Represents [`JSXExpr::Expr`]"]
        Expr,
    }
    impl JSXExprContainerField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXExprContainerField {
        #[doc = "Represents [`JSXExprContainer::span`]"]
        Span,
        #[doc = "Represents [`JSXExprContainer::expr`]"]
        Expr,
    }
    impl JSXFragmentField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Children(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXFragmentField {
        #[doc = "Represents [`JSXFragment::span`]"]
        Span,
        #[doc = "Represents [`JSXFragment::opening`]"]
        Opening,
        #[doc = "Represents [`JSXFragment::children`]"]
        Children(usize),
        #[doc = "Represents [`JSXFragment::closing`]"]
        Closing,
    }
    impl JSXMemberExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXMemberExprField {
        #[doc = "Represents [`JSXMemberExpr::span`]"]
        Span,
        #[doc = "Represents [`JSXMemberExpr::obj`]"]
        Obj,
        #[doc = "Represents [`JSXMemberExpr::prop`]"]
        Prop,
    }
    impl JSXNamespacedNameField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXNamespacedNameField {
        #[doc = "Represents [`JSXNamespacedName::span`]"]
        Span,
        #[doc = "Represents [`JSXNamespacedName::ns`]"]
        Ns,
        #[doc = "Represents [`JSXNamespacedName::name`]"]
        Name,
    }
    impl JSXObjectField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXObjectField {
        #[doc = "Represents [`JSXObject::JSXMemberExpr`]"]
        JsxmemberExpr,
        #[doc = "Represents [`JSXObject::Ident`]"]
        Ident,
    }
    impl JSXOpeningElementField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Attrs(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXOpeningElementField {
        #[doc = "Represents [`JSXOpeningElement::name`]"]
        Name,
        #[doc = "Represents [`JSXOpeningElement::span`]"]
        Span,
        #[doc = "Represents [`JSXOpeningElement::attrs`]"]
        Attrs(usize),
        #[doc = "Represents [`JSXOpeningElement::self_closing`]"]
        SelfClosing,
        #[doc = "Represents [`JSXOpeningElement::type_args`]"]
        TypeArgs,
    }
    impl JSXOpeningFragmentField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXOpeningFragmentField {
        #[doc = "Represents [`JSXOpeningFragment::span`]"]
        Span,
    }
    impl JSXSpreadChildField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXSpreadChildField {
        #[doc = "Represents [`JSXSpreadChild::span`]"]
        Span,
        #[doc = "Represents [`JSXSpreadChild::expr`]"]
        Expr,
    }
    impl JSXTextField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum JSXTextField {
        #[doc = "Represents [`JSXText::span`]"]
        Span,
        #[doc = "Represents [`JSXText::value`]"]
        Value,
        #[doc = "Represents [`JSXText::raw`]"]
        Raw,
    }
    impl KeyField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum KeyField {
        #[doc = "Represents [`Key::Private`]"]
        Private,
        #[doc = "Represents [`Key::Public`]"]
        Public,
    }
    impl KeyValuePatPropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum KeyValuePatPropField {
        #[doc = "Represents [`KeyValuePatProp::key`]"]
        Key,
        #[doc = "Represents [`KeyValuePatProp::value`]"]
        Value,
    }
    impl KeyValuePropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum KeyValuePropField {
        #[doc = "Represents [`KeyValueProp::key`]"]
        Key,
        #[doc = "Represents [`KeyValueProp::value`]"]
        Value,
    }
    impl LabeledStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum LabeledStmtField {
        #[doc = "Represents [`LabeledStmt::span`]"]
        Span,
        #[doc = "Represents [`LabeledStmt::label`]"]
        Label,
        #[doc = "Represents [`LabeledStmt::body`]"]
        Body,
    }
    impl LitField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum LitField {
        #[doc = "Represents [`Lit::Str`]"]
        Str,
        #[doc = "Represents [`Lit::Bool`]"]
        Bool,
        #[doc = "Represents [`Lit::Null`]"]
        Null,
        #[doc = "Represents [`Lit::Num`]"]
        Num,
        #[doc = "Represents [`Lit::BigInt`]"]
        BigInt,
        #[doc = "Represents [`Lit::Regex`]"]
        Regex,
        #[doc = "Represents [`Lit::JSXText`]"]
        Jsxtext,
    }
    impl MemberExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum MemberExprField {
        #[doc = "Represents [`MemberExpr::span`]"]
        Span,
        #[doc = "Represents [`MemberExpr::obj`]"]
        Obj,
        #[doc = "Represents [`MemberExpr::prop`]"]
        Prop,
    }
    impl MemberPropField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum MemberPropField {
        #[doc = "Represents [`MemberProp::Ident`]"]
        Ident,
        #[doc = "Represents [`MemberProp::PrivateName`]"]
        PrivateName,
        #[doc = "Represents [`MemberProp::Computed`]"]
        Computed,
    }
    impl MetaPropExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum MetaPropExprField {
        #[doc = "Represents [`MetaPropExpr::span`]"]
        Span,
        #[doc = "Represents [`MetaPropExpr::kind`]"]
        Kind,
    }
    impl MetaPropKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum MetaPropKindField {
        #[doc = "Represents [`MetaPropKind::NewTarget`]"]
        NewTarget,
        #[doc = "Represents [`MetaPropKind::ImportMeta`]"]
        ImportMeta,
    }
    impl MethodKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum MethodKindField {
        #[doc = "Represents [`MethodKind::Method`]"]
        Method,
        #[doc = "Represents [`MethodKind::Getter`]"]
        Getter,
        #[doc = "Represents [`MethodKind::Setter`]"]
        Setter,
    }
    impl MethodPropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum MethodPropField {
        #[doc = "Represents [`MethodProp::key`]"]
        Key,
        #[doc = "Represents [`MethodProp::function`]"]
        Function,
    }
    impl ModuleField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ModuleField {
        #[doc = "Represents [`Module::span`]"]
        Span,
        #[doc = "Represents [`Module::body`]"]
        Body(usize),
        #[doc = "Represents [`Module::shebang`]"]
        Shebang,
    }
    impl ModuleDeclField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ModuleDeclField {
        #[doc = "Represents [`ModuleDecl::Import`]"]
        Import,
        #[doc = "Represents [`ModuleDecl::ExportDecl`]"]
        ExportDecl,
        #[doc = "Represents [`ModuleDecl::ExportNamed`]"]
        ExportNamed,
        #[doc = "Represents [`ModuleDecl::ExportDefaultDecl`]"]
        ExportDefaultDecl,
        #[doc = "Represents [`ModuleDecl::ExportDefaultExpr`]"]
        ExportDefaultExpr,
        #[doc = "Represents [`ModuleDecl::ExportAll`]"]
        ExportAll,
        #[doc = "Represents [`ModuleDecl::TsImportEquals`]"]
        TsImportEquals,
        #[doc = "Represents [`ModuleDecl::TsExportAssignment`]"]
        TsExportAssignment,
        #[doc = "Represents [`ModuleDecl::TsNamespaceExport`]"]
        TsNamespaceExport,
    }
    impl ModuleExportNameField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ModuleExportNameField {
        #[doc = "Represents [`ModuleExportName::Ident`]"]
        Ident,
        #[doc = "Represents [`ModuleExportName::Str`]"]
        Str,
    }
    impl ModuleItemField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ModuleItemField {
        #[doc = "Represents [`ModuleItem::ModuleDecl`]"]
        ModuleDecl,
        #[doc = "Represents [`ModuleItem::Stmt`]"]
        Stmt,
    }
    impl NamedExportField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Specifiers(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum NamedExportField {
        #[doc = "Represents [`NamedExport::span`]"]
        Span,
        #[doc = "Represents [`NamedExport::specifiers`]"]
        Specifiers(usize),
        #[doc = "Represents [`NamedExport::src`]"]
        Src,
        #[doc = "Represents [`NamedExport::type_only`]"]
        TypeOnly,
        #[doc = "Represents [`NamedExport::with`]"]
        With,
    }
    impl NewExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Args(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum NewExprField {
        #[doc = "Represents [`NewExpr::span`]"]
        Span,
        #[doc = "Represents [`NewExpr::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`NewExpr::callee`]"]
        Callee,
        #[doc = "Represents [`NewExpr::args`]"]
        Args(usize),
        #[doc = "Represents [`NewExpr::type_args`]"]
        TypeArgs,
    }
    impl NullField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum NullField {
        #[doc = "Represents [`Null::span`]"]
        Span,
    }
    impl NumberField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum NumberField {
        #[doc = "Represents [`Number::span`]"]
        Span,
        #[doc = "Represents [`Number::value`]"]
        Value,
        #[doc = "Represents [`Number::raw`]"]
        Raw,
    }
    impl ObjectLitField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Props(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ObjectLitField {
        #[doc = "Represents [`ObjectLit::span`]"]
        Span,
        #[doc = "Represents [`ObjectLit::props`]"]
        Props(usize),
    }
    impl ObjectPatField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Props(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ObjectPatField {
        #[doc = "Represents [`ObjectPat::span`]"]
        Span,
        #[doc = "Represents [`ObjectPat::props`]"]
        Props(usize),
        #[doc = "Represents [`ObjectPat::optional`]"]
        Optional,
        #[doc = "Represents [`ObjectPat::type_ann`]"]
        TypeAnn,
    }
    impl ObjectPatPropField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ObjectPatPropField {
        #[doc = "Represents [`ObjectPatProp::KeyValue`]"]
        KeyValue,
        #[doc = "Represents [`ObjectPatProp::Assign`]"]
        Assign,
        #[doc = "Represents [`ObjectPatProp::Rest`]"]
        Rest,
    }
    impl OptCallField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Args(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum OptCallField {
        #[doc = "Represents [`OptCall::span`]"]
        Span,
        #[doc = "Represents [`OptCall::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`OptCall::callee`]"]
        Callee,
        #[doc = "Represents [`OptCall::args`]"]
        Args(usize),
        #[doc = "Represents [`OptCall::type_args`]"]
        TypeArgs,
    }
    impl OptChainBaseField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum OptChainBaseField {
        #[doc = "Represents [`OptChainBase::Member`]"]
        Member,
        #[doc = "Represents [`OptChainBase::Call`]"]
        Call,
    }
    impl OptChainExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum OptChainExprField {
        #[doc = "Represents [`OptChainExpr::span`]"]
        Span,
        #[doc = "Represents [`OptChainExpr::optional`]"]
        Optional,
        #[doc = "Represents [`OptChainExpr::base`]"]
        Base,
    }
    impl ParamField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Decorators(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ParamField {
        #[doc = "Represents [`Param::span`]"]
        Span,
        #[doc = "Represents [`Param::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`Param::pat`]"]
        Pat,
    }
    impl ParamOrTsParamPropField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ParamOrTsParamPropField {
        #[doc = "Represents [`ParamOrTsParamProp::TsParamProp`]"]
        TsParamProp,
        #[doc = "Represents [`ParamOrTsParamProp::Param`]"]
        Param,
    }
    impl ParenExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ParenExprField {
        #[doc = "Represents [`ParenExpr::span`]"]
        Span,
        #[doc = "Represents [`ParenExpr::expr`]"]
        Expr,
    }
    impl PatField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PatField {
        #[doc = "Represents [`Pat::Ident`]"]
        Ident,
        #[doc = "Represents [`Pat::Array`]"]
        Array,
        #[doc = "Represents [`Pat::Rest`]"]
        Rest,
        #[doc = "Represents [`Pat::Object`]"]
        Object,
        #[doc = "Represents [`Pat::Assign`]"]
        Assign,
        #[doc = "Represents [`Pat::Invalid`]"]
        Invalid,
        #[doc = "Represents [`Pat::Expr`]"]
        Expr,
    }
    impl PrivateMethodField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PrivateMethodField {
        #[doc = "Represents [`PrivateMethod::span`]"]
        Span,
        #[doc = "Represents [`PrivateMethod::key`]"]
        Key,
        #[doc = "Represents [`PrivateMethod::function`]"]
        Function,
        #[doc = "Represents [`PrivateMethod::kind`]"]
        Kind,
        #[doc = "Represents [`PrivateMethod::is_static`]"]
        IsStatic,
        #[doc = "Represents [`PrivateMethod::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`PrivateMethod::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`PrivateMethod::is_optional`]"]
        IsOptional,
        #[doc = "Represents [`PrivateMethod::is_override`]"]
        IsOverride,
    }
    impl PrivateNameField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PrivateNameField {
        #[doc = "Represents [`PrivateName::span`]"]
        Span,
        #[doc = "Represents [`PrivateName::name`]"]
        Name,
    }
    impl PrivatePropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Decorators(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PrivatePropField {
        #[doc = "Represents [`PrivateProp::span`]"]
        Span,
        #[doc = "Represents [`PrivateProp::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`PrivateProp::key`]"]
        Key,
        #[doc = "Represents [`PrivateProp::value`]"]
        Value,
        #[doc = "Represents [`PrivateProp::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`PrivateProp::is_static`]"]
        IsStatic,
        #[doc = "Represents [`PrivateProp::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`PrivateProp::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`PrivateProp::is_optional`]"]
        IsOptional,
        #[doc = "Represents [`PrivateProp::is_override`]"]
        IsOverride,
        #[doc = "Represents [`PrivateProp::readonly`]"]
        Readonly,
        #[doc = "Represents [`PrivateProp::definite`]"]
        Definite,
    }
    impl ProgramField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ProgramField {
        #[doc = "Represents [`Program::Module`]"]
        Module,
        #[doc = "Represents [`Program::Script`]"]
        Script,
    }
    impl PropField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PropField {
        #[doc = "Represents [`Prop::Shorthand`]"]
        Shorthand,
        #[doc = "Represents [`Prop::KeyValue`]"]
        KeyValue,
        #[doc = "Represents [`Prop::Assign`]"]
        Assign,
        #[doc = "Represents [`Prop::Getter`]"]
        Getter,
        #[doc = "Represents [`Prop::Setter`]"]
        Setter,
        #[doc = "Represents [`Prop::Method`]"]
        Method,
    }
    impl PropNameField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PropNameField {
        #[doc = "Represents [`PropName::Ident`]"]
        Ident,
        #[doc = "Represents [`PropName::Str`]"]
        Str,
        #[doc = "Represents [`PropName::Num`]"]
        Num,
        #[doc = "Represents [`PropName::Computed`]"]
        Computed,
        #[doc = "Represents [`PropName::BigInt`]"]
        BigInt,
    }
    impl PropOrSpreadField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PropOrSpreadField {
        #[doc = "Represents [`PropOrSpread::Spread`]"]
        Spread,
        #[doc = "Represents [`PropOrSpread::Prop`]"]
        Prop,
    }
    impl RegexField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum RegexField {
        #[doc = "Represents [`Regex::span`]"]
        Span,
        #[doc = "Represents [`Regex::exp`]"]
        Exp,
        #[doc = "Represents [`Regex::flags`]"]
        Flags,
    }
    impl RestPatField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum RestPatField {
        #[doc = "Represents [`RestPat::span`]"]
        Span,
        #[doc = "Represents [`RestPat::dot3_token`]"]
        Dot3Token,
        #[doc = "Represents [`RestPat::arg`]"]
        Arg,
        #[doc = "Represents [`RestPat::type_ann`]"]
        TypeAnn,
    }
    impl ReturnStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ReturnStmtField {
        #[doc = "Represents [`ReturnStmt::span`]"]
        Span,
        #[doc = "Represents [`ReturnStmt::arg`]"]
        Arg,
    }
    impl ScriptField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ScriptField {
        #[doc = "Represents [`Script::span`]"]
        Span,
        #[doc = "Represents [`Script::body`]"]
        Body(usize),
        #[doc = "Represents [`Script::shebang`]"]
        Shebang,
    }
    impl SeqExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Exprs(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SeqExprField {
        #[doc = "Represents [`SeqExpr::span`]"]
        Span,
        #[doc = "Represents [`SeqExpr::exprs`]"]
        Exprs(usize),
    }
    impl SetterPropField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SetterPropField {
        #[doc = "Represents [`SetterProp::span`]"]
        Span,
        #[doc = "Represents [`SetterProp::key`]"]
        Key,
        #[doc = "Represents [`SetterProp::this_param`]"]
        ThisParam,
        #[doc = "Represents [`SetterProp::param`]"]
        Param,
        #[doc = "Represents [`SetterProp::body`]"]
        Body,
    }
    impl SimpleAssignTargetField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SimpleAssignTargetField {
        #[doc = "Represents [`SimpleAssignTarget::Ident`]"]
        Ident,
        #[doc = "Represents [`SimpleAssignTarget::Member`]"]
        Member,
        #[doc = "Represents [`SimpleAssignTarget::SuperProp`]"]
        SuperProp,
        #[doc = "Represents [`SimpleAssignTarget::Paren`]"]
        Paren,
        #[doc = "Represents [`SimpleAssignTarget::OptChain`]"]
        OptChain,
        #[doc = "Represents [`SimpleAssignTarget::TsAs`]"]
        TsAs,
        #[doc = "Represents [`SimpleAssignTarget::TsSatisfies`]"]
        TsSatisfies,
        #[doc = "Represents [`SimpleAssignTarget::TsNonNull`]"]
        TsNonNull,
        #[doc = "Represents [`SimpleAssignTarget::TsTypeAssertion`]"]
        TsTypeAssertion,
        #[doc = "Represents [`SimpleAssignTarget::TsInstantiation`]"]
        TsInstantiation,
        #[doc = "Represents [`SimpleAssignTarget::Invalid`]"]
        Invalid,
    }
    impl SpreadElementField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SpreadElementField {
        #[doc = "Represents [`SpreadElement::dot3_token`]"]
        Dot3Token,
        #[doc = "Represents [`SpreadElement::expr`]"]
        Expr,
    }
    impl StaticBlockField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum StaticBlockField {
        #[doc = "Represents [`StaticBlock::span`]"]
        Span,
        #[doc = "Represents [`StaticBlock::body`]"]
        Body,
    }
    impl StmtField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum StmtField {
        #[doc = "Represents [`Stmt::Block`]"]
        Block,
        #[doc = "Represents [`Stmt::Empty`]"]
        Empty,
        #[doc = "Represents [`Stmt::Debugger`]"]
        Debugger,
        #[doc = "Represents [`Stmt::With`]"]
        With,
        #[doc = "Represents [`Stmt::Return`]"]
        Return,
        #[doc = "Represents [`Stmt::Labeled`]"]
        Labeled,
        #[doc = "Represents [`Stmt::Break`]"]
        Break,
        #[doc = "Represents [`Stmt::Continue`]"]
        Continue,
        #[doc = "Represents [`Stmt::If`]"]
        If,
        #[doc = "Represents [`Stmt::Switch`]"]
        Switch,
        #[doc = "Represents [`Stmt::Throw`]"]
        Throw,
        #[doc = "Represents [`Stmt::Try`]"]
        Try,
        #[doc = "Represents [`Stmt::While`]"]
        While,
        #[doc = "Represents [`Stmt::DoWhile`]"]
        DoWhile,
        #[doc = "Represents [`Stmt::For`]"]
        For,
        #[doc = "Represents [`Stmt::ForIn`]"]
        ForIn,
        #[doc = "Represents [`Stmt::ForOf`]"]
        ForOf,
        #[doc = "Represents [`Stmt::Decl`]"]
        Decl,
        #[doc = "Represents [`Stmt::Expr`]"]
        Expr,
    }
    impl StrField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum StrField {
        #[doc = "Represents [`Str::span`]"]
        Span,
        #[doc = "Represents [`Str::value`]"]
        Value,
        #[doc = "Represents [`Str::raw`]"]
        Raw,
    }
    impl SuperField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SuperField {
        #[doc = "Represents [`Super::span`]"]
        Span,
    }
    impl SuperPropField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SuperPropField {
        #[doc = "Represents [`SuperProp::Ident`]"]
        Ident,
        #[doc = "Represents [`SuperProp::Computed`]"]
        Computed,
    }
    impl SuperPropExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SuperPropExprField {
        #[doc = "Represents [`SuperPropExpr::span`]"]
        Span,
        #[doc = "Represents [`SuperPropExpr::obj`]"]
        Obj,
        #[doc = "Represents [`SuperPropExpr::prop`]"]
        Prop,
    }
    impl SwitchCaseField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Cons(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SwitchCaseField {
        #[doc = "Represents [`SwitchCase::span`]"]
        Span,
        #[doc = "Represents [`SwitchCase::test`]"]
        Test,
        #[doc = "Represents [`SwitchCase::cons`]"]
        Cons(usize),
    }
    impl SwitchStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Cases(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum SwitchStmtField {
        #[doc = "Represents [`SwitchStmt::span`]"]
        Span,
        #[doc = "Represents [`SwitchStmt::discriminant`]"]
        Discriminant,
        #[doc = "Represents [`SwitchStmt::cases`]"]
        Cases(usize),
    }
    impl TaggedTplField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum TaggedTplField {
        #[doc = "Represents [`TaggedTpl::span`]"]
        Span,
        #[doc = "Represents [`TaggedTpl::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`TaggedTpl::tag`]"]
        Tag,
        #[doc = "Represents [`TaggedTpl::type_params`]"]
        TypeParams,
        #[doc = "Represents [`TaggedTpl::tpl`]"]
        Tpl,
    }
    impl ThisExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ThisExprField {
        #[doc = "Represents [`ThisExpr::span`]"]
        Span,
    }
    impl ThrowStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ThrowStmtField {
        #[doc = "Represents [`ThrowStmt::span`]"]
        Span,
        #[doc = "Represents [`ThrowStmt::arg`]"]
        Arg,
    }
    impl TplField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Exprs(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                Self::Quasis(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum TplField {
        #[doc = "Represents [`Tpl::span`]"]
        Span,
        #[doc = "Represents [`Tpl::exprs`]"]
        Exprs(usize),
        #[doc = "Represents [`Tpl::quasis`]"]
        Quasis(usize),
    }
    impl TplElementField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum TplElementField {
        #[doc = "Represents [`TplElement::span`]"]
        Span,
        #[doc = "Represents [`TplElement::tail`]"]
        Tail,
        #[doc = "Represents [`TplElement::cooked`]"]
        Cooked,
        #[doc = "Represents [`TplElement::raw`]"]
        Raw,
    }
    impl TruePlusMinusField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum TruePlusMinusField {
        #[doc = "Represents [`TruePlusMinus::True`]"]
        True,
        #[doc = "Represents [`TruePlusMinus::Plus`]"]
        Plus,
        #[doc = "Represents [`TruePlusMinus::Minus`]"]
        Minus,
    }
    impl TryStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum TryStmtField {
        #[doc = "Represents [`TryStmt::span`]"]
        Span,
        #[doc = "Represents [`TryStmt::block`]"]
        Block,
        #[doc = "Represents [`TryStmt::handler`]"]
        Handler,
        #[doc = "Represents [`TryStmt::finalizer`]"]
        Finalizer,
    }
    impl UnaryExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum UnaryExprField {
        #[doc = "Represents [`UnaryExpr::span`]"]
        Span,
        #[doc = "Represents [`UnaryExpr::op`]"]
        Op,
        #[doc = "Represents [`UnaryExpr::arg`]"]
        Arg,
    }
    impl UnaryOpField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum UnaryOpField {
        #[doc = "Represents [`UnaryOp::Minus`]"]
        Minus,
        #[doc = "Represents [`UnaryOp::Plus`]"]
        Plus,
        #[doc = "Represents [`UnaryOp::Bang`]"]
        Bang,
        #[doc = "Represents [`UnaryOp::Tilde`]"]
        Tilde,
        #[doc = "Represents [`UnaryOp::TypeOf`]"]
        TypeOf,
        #[doc = "Represents [`UnaryOp::Void`]"]
        Void,
        #[doc = "Represents [`UnaryOp::Delete`]"]
        Delete,
    }
    impl UpdateExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum UpdateExprField {
        #[doc = "Represents [`UpdateExpr::span`]"]
        Span,
        #[doc = "Represents [`UpdateExpr::op`]"]
        Op,
        #[doc = "Represents [`UpdateExpr::prefix`]"]
        Prefix,
        #[doc = "Represents [`UpdateExpr::arg`]"]
        Arg,
    }
    impl UpdateOpField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum UpdateOpField {
        #[doc = "Represents [`UpdateOp::PlusPlus`]"]
        PlusPlus,
        #[doc = "Represents [`UpdateOp::MinusMinus`]"]
        MinusMinus,
    }
    impl UsingDeclField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Decls(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum UsingDeclField {
        #[doc = "Represents [`UsingDecl::span`]"]
        Span,
        #[doc = "Represents [`UsingDecl::is_await`]"]
        IsAwait,
        #[doc = "Represents [`UsingDecl::decls`]"]
        Decls(usize),
    }
    impl VarDeclField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Decls(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum VarDeclField {
        #[doc = "Represents [`VarDecl::span`]"]
        Span,
        #[doc = "Represents [`VarDecl::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`VarDecl::kind`]"]
        Kind,
        #[doc = "Represents [`VarDecl::declare`]"]
        Declare,
        #[doc = "Represents [`VarDecl::decls`]"]
        Decls(usize),
    }
    impl VarDeclKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum VarDeclKindField {
        #[doc = "Represents [`VarDeclKind::Var`]"]
        Var,
        #[doc = "Represents [`VarDeclKind::Let`]"]
        Let,
        #[doc = "Represents [`VarDeclKind::Const`]"]
        Const,
    }
    impl VarDeclOrExprField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum VarDeclOrExprField {
        #[doc = "Represents [`VarDeclOrExpr::VarDecl`]"]
        VarDecl,
        #[doc = "Represents [`VarDeclOrExpr::Expr`]"]
        Expr,
    }
    impl VarDeclaratorField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum VarDeclaratorField {
        #[doc = "Represents [`VarDeclarator::span`]"]
        Span,
        #[doc = "Represents [`VarDeclarator::name`]"]
        Name,
        #[doc = "Represents [`VarDeclarator::init`]"]
        Init,
        #[doc = "Represents [`VarDeclarator::definite`]"]
        Definite,
    }
    impl WhileStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum WhileStmtField {
        #[doc = "Represents [`WhileStmt::span`]"]
        Span,
        #[doc = "Represents [`WhileStmt::test`]"]
        Test,
        #[doc = "Represents [`WhileStmt::body`]"]
        Body,
    }
    impl WithStmtField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum WithStmtField {
        #[doc = "Represents [`WithStmt::span`]"]
        Span,
        #[doc = "Represents [`WithStmt::obj`]"]
        Obj,
        #[doc = "Represents [`WithStmt::body`]"]
        Body,
    }
    impl YieldExprField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum YieldExprField {
        #[doc = "Represents [`YieldExpr::span`]"]
        Span,
        #[doc = "Represents [`YieldExpr::arg`]"]
        Arg,
        #[doc = "Represents [`YieldExpr::delegate`]"]
        Delegate,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AstParentKind {
        ArrayLit(ArrayLitField),
        ArrayPat(ArrayPatField),
        ArrowExpr(ArrowExprField),
        AssignExpr(AssignExprField),
        AssignOp(AssignOpField),
        AssignPat(AssignPatField),
        AssignPatProp(AssignPatPropField),
        AssignProp(AssignPropField),
        AssignTarget(AssignTargetField),
        AssignTargetPat(AssignTargetPatField),
        AutoAccessor(AutoAccessorField),
        AwaitExpr(AwaitExprField),
        BigInt(BigIntField),
        BinExpr(BinExprField),
        BinaryOp(BinaryOpField),
        BindingIdent(BindingIdentField),
        BlockStmt(BlockStmtField),
        BlockStmtOrExpr(BlockStmtOrExprField),
        Bool(BoolField),
        BreakStmt(BreakStmtField),
        CallExpr(CallExprField),
        Callee(CalleeField),
        CatchClause(CatchClauseField),
        Class(ClassField),
        ClassDecl(ClassDeclField),
        ClassExpr(ClassExprField),
        ClassMember(ClassMemberField),
        ClassMethod(ClassMethodField),
        ClassProp(ClassPropField),
        ComputedPropName(ComputedPropNameField),
        CondExpr(CondExprField),
        Constructor(ConstructorField),
        ContinueStmt(ContinueStmtField),
        DebuggerStmt(DebuggerStmtField),
        Decl(DeclField),
        Decorator(DecoratorField),
        DefaultDecl(DefaultDeclField),
        DoWhileStmt(DoWhileStmtField),
        EmptyStmt(EmptyStmtField),
        ExportAll(ExportAllField),
        ExportDecl(ExportDeclField),
        ExportDefaultDecl(ExportDefaultDeclField),
        ExportDefaultExpr(ExportDefaultExprField),
        ExportDefaultSpecifier(ExportDefaultSpecifierField),
        ExportNamedSpecifier(ExportNamedSpecifierField),
        ExportNamespaceSpecifier(ExportNamespaceSpecifierField),
        ExportSpecifier(ExportSpecifierField),
        Expr(ExprField),
        ExprOrSpread(ExprOrSpreadField),
        ExprStmt(ExprStmtField),
        FnDecl(FnDeclField),
        FnExpr(FnExprField),
        ForHead(ForHeadField),
        ForInStmt(ForInStmtField),
        ForOfStmt(ForOfStmtField),
        ForStmt(ForStmtField),
        Function(FunctionField),
        GetterProp(GetterPropField),
        Ident(IdentField),
        IdentName(IdentNameField),
        IfStmt(IfStmtField),
        Import(ImportField),
        ImportDecl(ImportDeclField),
        ImportDefaultSpecifier(ImportDefaultSpecifierField),
        ImportNamedSpecifier(ImportNamedSpecifierField),
        ImportPhase(ImportPhaseField),
        ImportSpecifier(ImportSpecifierField),
        ImportStarAsSpecifier(ImportStarAsSpecifierField),
        ImportWith(ImportWithField),
        ImportWithItem(ImportWithItemField),
        Invalid(InvalidField),
        JSXAttr(JSXAttrField),
        JSXAttrName(JSXAttrNameField),
        JSXAttrOrSpread(JSXAttrOrSpreadField),
        JSXAttrValue(JSXAttrValueField),
        JSXClosingElement(JSXClosingElementField),
        JSXClosingFragment(JSXClosingFragmentField),
        JSXElement(JSXElementField),
        JSXElementChild(JSXElementChildField),
        JSXElementName(JSXElementNameField),
        JSXEmptyExpr(JSXEmptyExprField),
        JSXExpr(JSXExprField),
        JSXExprContainer(JSXExprContainerField),
        JSXFragment(JSXFragmentField),
        JSXMemberExpr(JSXMemberExprField),
        JSXNamespacedName(JSXNamespacedNameField),
        JSXObject(JSXObjectField),
        JSXOpeningElement(JSXOpeningElementField),
        JSXOpeningFragment(JSXOpeningFragmentField),
        JSXSpreadChild(JSXSpreadChildField),
        JSXText(JSXTextField),
        Key(KeyField),
        KeyValuePatProp(KeyValuePatPropField),
        KeyValueProp(KeyValuePropField),
        LabeledStmt(LabeledStmtField),
        Lit(LitField),
        MemberExpr(MemberExprField),
        MemberProp(MemberPropField),
        MetaPropExpr(MetaPropExprField),
        MetaPropKind(MetaPropKindField),
        MethodKind(MethodKindField),
        MethodProp(MethodPropField),
        Module(ModuleField),
        ModuleDecl(ModuleDeclField),
        ModuleExportName(ModuleExportNameField),
        ModuleItem(ModuleItemField),
        NamedExport(NamedExportField),
        NewExpr(NewExprField),
        Null(NullField),
        Number(NumberField),
        ObjectLit(ObjectLitField),
        ObjectPat(ObjectPatField),
        ObjectPatProp(ObjectPatPropField),
        OptCall(OptCallField),
        OptChainBase(OptChainBaseField),
        OptChainExpr(OptChainExprField),
        Param(ParamField),
        ParamOrTsParamProp(ParamOrTsParamPropField),
        ParenExpr(ParenExprField),
        Pat(PatField),
        PrivateMethod(PrivateMethodField),
        PrivateName(PrivateNameField),
        PrivateProp(PrivatePropField),
        Program(ProgramField),
        Prop(PropField),
        PropName(PropNameField),
        PropOrSpread(PropOrSpreadField),
        Regex(RegexField),
        RestPat(RestPatField),
        ReturnStmt(ReturnStmtField),
        Script(ScriptField),
        SeqExpr(SeqExprField),
        SetterProp(SetterPropField),
        SimpleAssignTarget(SimpleAssignTargetField),
        SpreadElement(SpreadElementField),
        StaticBlock(StaticBlockField),
        Stmt(StmtField),
        Str(StrField),
        Super(SuperField),
        SuperProp(SuperPropField),
        SuperPropExpr(SuperPropExprField),
        SwitchCase(SwitchCaseField),
        SwitchStmt(SwitchStmtField),
        TaggedTpl(TaggedTplField),
        ThisExpr(ThisExprField),
        ThrowStmt(ThrowStmtField),
        Tpl(TplField),
        TplElement(TplElementField),
        TruePlusMinus(TruePlusMinusField),
        TryStmt(TryStmtField),
        UnaryExpr(UnaryExprField),
        UnaryOp(UnaryOpField),
        UpdateExpr(UpdateExprField),
        UpdateOp(UpdateOpField),
        UsingDecl(UsingDeclField),
        VarDecl(VarDeclField),
        VarDeclKind(VarDeclKindField),
        VarDeclOrExpr(VarDeclOrExprField),
        VarDeclarator(VarDeclaratorField),
        WhileStmt(WhileStmtField),
        WithStmt(WithStmtField),
        YieldExpr(YieldExprField),
    }
    impl ::swc_visit::ParentKind for AstParentKind {
        #[inline]
        fn set_index(&mut self, index: usize) {
            match self {
                Self::ArrayLit(v) => v.set_index(index),
                Self::ArrayPat(v) => v.set_index(index),
                Self::ArrowExpr(v) => v.set_index(index),
                Self::AssignExpr(v) => v.set_index(index),
                Self::AssignOp(v) => v.set_index(index),
                Self::AssignPat(v) => v.set_index(index),
                Self::AssignPatProp(v) => v.set_index(index),
                Self::AssignProp(v) => v.set_index(index),
                Self::AssignTarget(v) => v.set_index(index),
                Self::AssignTargetPat(v) => v.set_index(index),
                Self::AutoAccessor(v) => v.set_index(index),
                Self::AwaitExpr(v) => v.set_index(index),
                Self::BigInt(v) => v.set_index(index),
                Self::BinExpr(v) => v.set_index(index),
                Self::BinaryOp(v) => v.set_index(index),
                Self::BindingIdent(v) => v.set_index(index),
                Self::BlockStmt(v) => v.set_index(index),
                Self::BlockStmtOrExpr(v) => v.set_index(index),
                Self::Bool(v) => v.set_index(index),
                Self::BreakStmt(v) => v.set_index(index),
                Self::CallExpr(v) => v.set_index(index),
                Self::Callee(v) => v.set_index(index),
                Self::CatchClause(v) => v.set_index(index),
                Self::Class(v) => v.set_index(index),
                Self::ClassDecl(v) => v.set_index(index),
                Self::ClassExpr(v) => v.set_index(index),
                Self::ClassMember(v) => v.set_index(index),
                Self::ClassMethod(v) => v.set_index(index),
                Self::ClassProp(v) => v.set_index(index),
                Self::ComputedPropName(v) => v.set_index(index),
                Self::CondExpr(v) => v.set_index(index),
                Self::Constructor(v) => v.set_index(index),
                Self::ContinueStmt(v) => v.set_index(index),
                Self::DebuggerStmt(v) => v.set_index(index),
                Self::Decl(v) => v.set_index(index),
                Self::Decorator(v) => v.set_index(index),
                Self::DefaultDecl(v) => v.set_index(index),
                Self::DoWhileStmt(v) => v.set_index(index),
                Self::EmptyStmt(v) => v.set_index(index),
                Self::ExportAll(v) => v.set_index(index),
                Self::ExportDecl(v) => v.set_index(index),
                Self::ExportDefaultDecl(v) => v.set_index(index),
                Self::ExportDefaultExpr(v) => v.set_index(index),
                Self::ExportDefaultSpecifier(v) => v.set_index(index),
                Self::ExportNamedSpecifier(v) => v.set_index(index),
                Self::ExportNamespaceSpecifier(v) => v.set_index(index),
                Self::ExportSpecifier(v) => v.set_index(index),
                Self::Expr(v) => v.set_index(index),
                Self::ExprOrSpread(v) => v.set_index(index),
                Self::ExprStmt(v) => v.set_index(index),
                Self::FnDecl(v) => v.set_index(index),
                Self::FnExpr(v) => v.set_index(index),
                Self::ForHead(v) => v.set_index(index),
                Self::ForInStmt(v) => v.set_index(index),
                Self::ForOfStmt(v) => v.set_index(index),
                Self::ForStmt(v) => v.set_index(index),
                Self::Function(v) => v.set_index(index),
                Self::GetterProp(v) => v.set_index(index),
                Self::Ident(v) => v.set_index(index),
                Self::IdentName(v) => v.set_index(index),
                Self::IfStmt(v) => v.set_index(index),
                Self::Import(v) => v.set_index(index),
                Self::ImportDecl(v) => v.set_index(index),
                Self::ImportDefaultSpecifier(v) => v.set_index(index),
                Self::ImportNamedSpecifier(v) => v.set_index(index),
                Self::ImportPhase(v) => v.set_index(index),
                Self::ImportSpecifier(v) => v.set_index(index),
                Self::ImportStarAsSpecifier(v) => v.set_index(index),
                Self::ImportWith(v) => v.set_index(index),
                Self::ImportWithItem(v) => v.set_index(index),
                Self::Invalid(v) => v.set_index(index),
                Self::JSXAttr(v) => v.set_index(index),
                Self::JSXAttrName(v) => v.set_index(index),
                Self::JSXAttrOrSpread(v) => v.set_index(index),
                Self::JSXAttrValue(v) => v.set_index(index),
                Self::JSXClosingElement(v) => v.set_index(index),
                Self::JSXClosingFragment(v) => v.set_index(index),
                Self::JSXElement(v) => v.set_index(index),
                Self::JSXElementChild(v) => v.set_index(index),
                Self::JSXElementName(v) => v.set_index(index),
                Self::JSXEmptyExpr(v) => v.set_index(index),
                Self::JSXExpr(v) => v.set_index(index),
                Self::JSXExprContainer(v) => v.set_index(index),
                Self::JSXFragment(v) => v.set_index(index),
                Self::JSXMemberExpr(v) => v.set_index(index),
                Self::JSXNamespacedName(v) => v.set_index(index),
                Self::JSXObject(v) => v.set_index(index),
                Self::JSXOpeningElement(v) => v.set_index(index),
                Self::JSXOpeningFragment(v) => v.set_index(index),
                Self::JSXSpreadChild(v) => v.set_index(index),
                Self::JSXText(v) => v.set_index(index),
                Self::Key(v) => v.set_index(index),
                Self::KeyValuePatProp(v) => v.set_index(index),
                Self::KeyValueProp(v) => v.set_index(index),
                Self::LabeledStmt(v) => v.set_index(index),
                Self::Lit(v) => v.set_index(index),
                Self::MemberExpr(v) => v.set_index(index),
                Self::MemberProp(v) => v.set_index(index),
                Self::MetaPropExpr(v) => v.set_index(index),
                Self::MetaPropKind(v) => v.set_index(index),
                Self::MethodKind(v) => v.set_index(index),
                Self::MethodProp(v) => v.set_index(index),
                Self::Module(v) => v.set_index(index),
                Self::ModuleDecl(v) => v.set_index(index),
                Self::ModuleExportName(v) => v.set_index(index),
                Self::ModuleItem(v) => v.set_index(index),
                Self::NamedExport(v) => v.set_index(index),
                Self::NewExpr(v) => v.set_index(index),
                Self::Null(v) => v.set_index(index),
                Self::Number(v) => v.set_index(index),
                Self::ObjectLit(v) => v.set_index(index),
                Self::ObjectPat(v) => v.set_index(index),
                Self::ObjectPatProp(v) => v.set_index(index),
                Self::OptCall(v) => v.set_index(index),
                Self::OptChainBase(v) => v.set_index(index),
                Self::OptChainExpr(v) => v.set_index(index),
                Self::Param(v) => v.set_index(index),
                Self::ParamOrTsParamProp(v) => v.set_index(index),
                Self::ParenExpr(v) => v.set_index(index),
                Self::Pat(v) => v.set_index(index),
                Self::PrivateMethod(v) => v.set_index(index),
                Self::PrivateName(v) => v.set_index(index),
                Self::PrivateProp(v) => v.set_index(index),
                Self::Program(v) => v.set_index(index),
                Self::Prop(v) => v.set_index(index),
                Self::PropName(v) => v.set_index(index),
                Self::PropOrSpread(v) => v.set_index(index),
                Self::Regex(v) => v.set_index(index),
                Self::RestPat(v) => v.set_index(index),
                Self::ReturnStmt(v) => v.set_index(index),
                Self::Script(v) => v.set_index(index),
                Self::SeqExpr(v) => v.set_index(index),
                Self::SetterProp(v) => v.set_index(index),
                Self::SimpleAssignTarget(v) => v.set_index(index),
                Self::SpreadElement(v) => v.set_index(index),
                Self::StaticBlock(v) => v.set_index(index),
                Self::Stmt(v) => v.set_index(index),
                Self::Str(v) => v.set_index(index),
                Self::Super(v) => v.set_index(index),
                Self::SuperProp(v) => v.set_index(index),
                Self::SuperPropExpr(v) => v.set_index(index),
                Self::SwitchCase(v) => v.set_index(index),
                Self::SwitchStmt(v) => v.set_index(index),
                Self::TaggedTpl(v) => v.set_index(index),
                Self::ThisExpr(v) => v.set_index(index),
                Self::ThrowStmt(v) => v.set_index(index),
                Self::Tpl(v) => v.set_index(index),
                Self::TplElement(v) => v.set_index(index),
                Self::TruePlusMinus(v) => v.set_index(index),
                Self::TryStmt(v) => v.set_index(index),
                Self::UnaryExpr(v) => v.set_index(index),
                Self::UnaryOp(v) => v.set_index(index),
                Self::UpdateExpr(v) => v.set_index(index),
                Self::UpdateOp(v) => v.set_index(index),
                Self::UsingDecl(v) => v.set_index(index),
                Self::VarDecl(v) => v.set_index(index),
                Self::VarDeclKind(v) => v.set_index(index),
                Self::VarDeclOrExpr(v) => v.set_index(index),
                Self::VarDeclarator(v) => v.set_index(index),
                Self::WhileStmt(v) => v.set_index(index),
                Self::WithStmt(v) => v.set_index(index),
                Self::YieldExpr(v) => v.set_index(index),
            }
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub enum AstParentNodeRef<'ast> {
        ArrayLit(&'ast ArrayLit, ArrayLitField),
        ArrayPat(&'ast ArrayPat, ArrayPatField),
        ArrowExpr(&'ast ArrowExpr, ArrowExprField),
        AssignExpr(&'ast AssignExpr, AssignExprField),
        AssignOp(&'ast AssignOp, AssignOpField),
        AssignPat(&'ast AssignPat, AssignPatField),
        AssignPatProp(&'ast AssignPatProp, AssignPatPropField),
        AssignProp(&'ast AssignProp, AssignPropField),
        AssignTarget(&'ast AssignTarget, AssignTargetField),
        AssignTargetPat(&'ast AssignTargetPat, AssignTargetPatField),
        AutoAccessor(&'ast AutoAccessor, AutoAccessorField),
        AwaitExpr(&'ast AwaitExpr, AwaitExprField),
        BigInt(&'ast BigInt, BigIntField),
        BinExpr(&'ast BinExpr, BinExprField),
        BinaryOp(&'ast BinaryOp, BinaryOpField),
        BindingIdent(&'ast BindingIdent, BindingIdentField),
        BlockStmt(&'ast BlockStmt, BlockStmtField),
        BlockStmtOrExpr(&'ast BlockStmtOrExpr, BlockStmtOrExprField),
        Bool(&'ast Bool, BoolField),
        BreakStmt(&'ast BreakStmt, BreakStmtField),
        CallExpr(&'ast CallExpr, CallExprField),
        Callee(&'ast Callee, CalleeField),
        CatchClause(&'ast CatchClause, CatchClauseField),
        Class(&'ast Class, ClassField),
        ClassDecl(&'ast ClassDecl, ClassDeclField),
        ClassExpr(&'ast ClassExpr, ClassExprField),
        ClassMember(&'ast ClassMember, ClassMemberField),
        ClassMethod(&'ast ClassMethod, ClassMethodField),
        ClassProp(&'ast ClassProp, ClassPropField),
        ComputedPropName(&'ast ComputedPropName, ComputedPropNameField),
        CondExpr(&'ast CondExpr, CondExprField),
        Constructor(&'ast Constructor, ConstructorField),
        ContinueStmt(&'ast ContinueStmt, ContinueStmtField),
        DebuggerStmt(&'ast DebuggerStmt, DebuggerStmtField),
        Decl(&'ast Decl, DeclField),
        Decorator(&'ast Decorator, DecoratorField),
        DefaultDecl(&'ast DefaultDecl, DefaultDeclField),
        DoWhileStmt(&'ast DoWhileStmt, DoWhileStmtField),
        EmptyStmt(&'ast EmptyStmt, EmptyStmtField),
        ExportAll(&'ast ExportAll, ExportAllField),
        ExportDecl(&'ast ExportDecl, ExportDeclField),
        ExportDefaultDecl(&'ast ExportDefaultDecl, ExportDefaultDeclField),
        ExportDefaultExpr(&'ast ExportDefaultExpr, ExportDefaultExprField),
        ExportDefaultSpecifier(&'ast ExportDefaultSpecifier, ExportDefaultSpecifierField),
        ExportNamedSpecifier(&'ast ExportNamedSpecifier, ExportNamedSpecifierField),
        ExportNamespaceSpecifier(
            &'ast ExportNamespaceSpecifier,
            ExportNamespaceSpecifierField,
        ),
        ExportSpecifier(&'ast ExportSpecifier, ExportSpecifierField),
        Expr(&'ast Expr, ExprField),
        ExprOrSpread(&'ast ExprOrSpread, ExprOrSpreadField),
        ExprStmt(&'ast ExprStmt, ExprStmtField),
        FnDecl(&'ast FnDecl, FnDeclField),
        FnExpr(&'ast FnExpr, FnExprField),
        ForHead(&'ast ForHead, ForHeadField),
        ForInStmt(&'ast ForInStmt, ForInStmtField),
        ForOfStmt(&'ast ForOfStmt, ForOfStmtField),
        ForStmt(&'ast ForStmt, ForStmtField),
        Function(&'ast Function, FunctionField),
        GetterProp(&'ast GetterProp, GetterPropField),
        Ident(&'ast Ident, IdentField),
        IdentName(&'ast IdentName, IdentNameField),
        IfStmt(&'ast IfStmt, IfStmtField),
        Import(&'ast Import, ImportField),
        ImportDecl(&'ast ImportDecl, ImportDeclField),
        ImportDefaultSpecifier(&'ast ImportDefaultSpecifier, ImportDefaultSpecifierField),
        ImportNamedSpecifier(&'ast ImportNamedSpecifier, ImportNamedSpecifierField),
        ImportPhase(&'ast ImportPhase, ImportPhaseField),
        ImportSpecifier(&'ast ImportSpecifier, ImportSpecifierField),
        ImportStarAsSpecifier(&'ast ImportStarAsSpecifier, ImportStarAsSpecifierField),
        ImportWith(&'ast ImportWith, ImportWithField),
        ImportWithItem(&'ast ImportWithItem, ImportWithItemField),
        Invalid(&'ast Invalid, InvalidField),
        JSXAttr(&'ast JSXAttr, JSXAttrField),
        JSXAttrName(&'ast JSXAttrName, JSXAttrNameField),
        JSXAttrOrSpread(&'ast JSXAttrOrSpread, JSXAttrOrSpreadField),
        JSXAttrValue(&'ast JSXAttrValue, JSXAttrValueField),
        JSXClosingElement(&'ast JSXClosingElement, JSXClosingElementField),
        JSXClosingFragment(&'ast JSXClosingFragment, JSXClosingFragmentField),
        JSXElement(&'ast JSXElement, JSXElementField),
        JSXElementChild(&'ast JSXElementChild, JSXElementChildField),
        JSXElementName(&'ast JSXElementName, JSXElementNameField),
        JSXEmptyExpr(&'ast JSXEmptyExpr, JSXEmptyExprField),
        JSXExpr(&'ast JSXExpr, JSXExprField),
        JSXExprContainer(&'ast JSXExprContainer, JSXExprContainerField),
        JSXFragment(&'ast JSXFragment, JSXFragmentField),
        JSXMemberExpr(&'ast JSXMemberExpr, JSXMemberExprField),
        JSXNamespacedName(&'ast JSXNamespacedName, JSXNamespacedNameField),
        JSXObject(&'ast JSXObject, JSXObjectField),
        JSXOpeningElement(&'ast JSXOpeningElement, JSXOpeningElementField),
        JSXOpeningFragment(&'ast JSXOpeningFragment, JSXOpeningFragmentField),
        JSXSpreadChild(&'ast JSXSpreadChild, JSXSpreadChildField),
        JSXText(&'ast JSXText, JSXTextField),
        Key(&'ast Key, KeyField),
        KeyValuePatProp(&'ast KeyValuePatProp, KeyValuePatPropField),
        KeyValueProp(&'ast KeyValueProp, KeyValuePropField),
        LabeledStmt(&'ast LabeledStmt, LabeledStmtField),
        Lit(&'ast Lit, LitField),
        MemberExpr(&'ast MemberExpr, MemberExprField),
        MemberProp(&'ast MemberProp, MemberPropField),
        MetaPropExpr(&'ast MetaPropExpr, MetaPropExprField),
        MetaPropKind(&'ast MetaPropKind, MetaPropKindField),
        MethodKind(&'ast MethodKind, MethodKindField),
        MethodProp(&'ast MethodProp, MethodPropField),
        Module(&'ast Module, ModuleField),
        ModuleDecl(&'ast ModuleDecl, ModuleDeclField),
        ModuleExportName(&'ast ModuleExportName, ModuleExportNameField),
        ModuleItem(&'ast ModuleItem, ModuleItemField),
        NamedExport(&'ast NamedExport, NamedExportField),
        NewExpr(&'ast NewExpr, NewExprField),
        Null(&'ast Null, NullField),
        Number(&'ast Number, NumberField),
        ObjectLit(&'ast ObjectLit, ObjectLitField),
        ObjectPat(&'ast ObjectPat, ObjectPatField),
        ObjectPatProp(&'ast ObjectPatProp, ObjectPatPropField),
        OptCall(&'ast OptCall, OptCallField),
        OptChainBase(&'ast OptChainBase, OptChainBaseField),
        OptChainExpr(&'ast OptChainExpr, OptChainExprField),
        Param(&'ast Param, ParamField),
        ParamOrTsParamProp(&'ast ParamOrTsParamProp, ParamOrTsParamPropField),
        ParenExpr(&'ast ParenExpr, ParenExprField),
        Pat(&'ast Pat, PatField),
        PrivateMethod(&'ast PrivateMethod, PrivateMethodField),
        PrivateName(&'ast PrivateName, PrivateNameField),
        PrivateProp(&'ast PrivateProp, PrivatePropField),
        Program(&'ast Program, ProgramField),
        Prop(&'ast Prop, PropField),
        PropName(&'ast PropName, PropNameField),
        PropOrSpread(&'ast PropOrSpread, PropOrSpreadField),
        Regex(&'ast Regex, RegexField),
        RestPat(&'ast RestPat, RestPatField),
        ReturnStmt(&'ast ReturnStmt, ReturnStmtField),
        Script(&'ast Script, ScriptField),
        SeqExpr(&'ast SeqExpr, SeqExprField),
        SetterProp(&'ast SetterProp, SetterPropField),
        SimpleAssignTarget(&'ast SimpleAssignTarget, SimpleAssignTargetField),
        SpreadElement(&'ast SpreadElement, SpreadElementField),
        StaticBlock(&'ast StaticBlock, StaticBlockField),
        Stmt(&'ast Stmt, StmtField),
        Str(&'ast Str, StrField),
        Super(&'ast Super, SuperField),
        SuperProp(&'ast SuperProp, SuperPropField),
        SuperPropExpr(&'ast SuperPropExpr, SuperPropExprField),
        SwitchCase(&'ast SwitchCase, SwitchCaseField),
        SwitchStmt(&'ast SwitchStmt, SwitchStmtField),
        TaggedTpl(&'ast TaggedTpl, TaggedTplField),
        ThisExpr(&'ast ThisExpr, ThisExprField),
        ThrowStmt(&'ast ThrowStmt, ThrowStmtField),
        Tpl(&'ast Tpl, TplField),
        TplElement(&'ast TplElement, TplElementField),
        TruePlusMinus(&'ast TruePlusMinus, TruePlusMinusField),
        TryStmt(&'ast TryStmt, TryStmtField),
        UnaryExpr(&'ast UnaryExpr, UnaryExprField),
        UnaryOp(&'ast UnaryOp, UnaryOpField),
        UpdateExpr(&'ast UpdateExpr, UpdateExprField),
        UpdateOp(&'ast UpdateOp, UpdateOpField),
        UsingDecl(&'ast UsingDecl, UsingDeclField),
        VarDecl(&'ast VarDecl, VarDeclField),
        VarDeclKind(&'ast VarDeclKind, VarDeclKindField),
        VarDeclOrExpr(&'ast VarDeclOrExpr, VarDeclOrExprField),
        VarDeclarator(&'ast VarDeclarator, VarDeclaratorField),
        WhileStmt(&'ast WhileStmt, WhileStmtField),
        WithStmt(&'ast WithStmt, WithStmtField),
        YieldExpr(&'ast YieldExpr, YieldExprField),
    }
    impl<'ast> ::swc_visit::NodeRef for AstParentNodeRef<'ast> {
        type ParentKind = AstParentKind;

        #[inline(always)]
        fn kind(&self) -> AstParentKind {
            self.kind()
        }

        fn set_index(&mut self, index: usize) {
            match self {
                Self::ArrayLit(_, __field_kind) => __field_kind.set_index(index),
                Self::ArrayPat(_, __field_kind) => __field_kind.set_index(index),
                Self::ArrowExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::AssignExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::AssignOp(_, __field_kind) => __field_kind.set_index(index),
                Self::AssignPat(_, __field_kind) => __field_kind.set_index(index),
                Self::AssignPatProp(_, __field_kind) => __field_kind.set_index(index),
                Self::AssignProp(_, __field_kind) => __field_kind.set_index(index),
                Self::AssignTarget(_, __field_kind) => __field_kind.set_index(index),
                Self::AssignTargetPat(_, __field_kind) => __field_kind.set_index(index),
                Self::AutoAccessor(_, __field_kind) => __field_kind.set_index(index),
                Self::AwaitExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::BigInt(_, __field_kind) => __field_kind.set_index(index),
                Self::BinExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::BinaryOp(_, __field_kind) => __field_kind.set_index(index),
                Self::BindingIdent(_, __field_kind) => __field_kind.set_index(index),
                Self::BlockStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::BlockStmtOrExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::Bool(_, __field_kind) => __field_kind.set_index(index),
                Self::BreakStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::CallExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::Callee(_, __field_kind) => __field_kind.set_index(index),
                Self::CatchClause(_, __field_kind) => __field_kind.set_index(index),
                Self::Class(_, __field_kind) => __field_kind.set_index(index),
                Self::ClassDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::ClassExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::ClassMember(_, __field_kind) => __field_kind.set_index(index),
                Self::ClassMethod(_, __field_kind) => __field_kind.set_index(index),
                Self::ClassProp(_, __field_kind) => __field_kind.set_index(index),
                Self::ComputedPropName(_, __field_kind) => __field_kind.set_index(index),
                Self::CondExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::Constructor(_, __field_kind) => __field_kind.set_index(index),
                Self::ContinueStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::DebuggerStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::Decl(_, __field_kind) => __field_kind.set_index(index),
                Self::Decorator(_, __field_kind) => __field_kind.set_index(index),
                Self::DefaultDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::DoWhileStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::EmptyStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportAll(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportDefaultDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportDefaultExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportDefaultSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportNamedSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportNamespaceSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::ExportSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::Expr(_, __field_kind) => __field_kind.set_index(index),
                Self::ExprOrSpread(_, __field_kind) => __field_kind.set_index(index),
                Self::ExprStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::FnDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::FnExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::ForHead(_, __field_kind) => __field_kind.set_index(index),
                Self::ForInStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::ForOfStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::ForStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::Function(_, __field_kind) => __field_kind.set_index(index),
                Self::GetterProp(_, __field_kind) => __field_kind.set_index(index),
                Self::Ident(_, __field_kind) => __field_kind.set_index(index),
                Self::IdentName(_, __field_kind) => __field_kind.set_index(index),
                Self::IfStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::Import(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportDefaultSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportNamedSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportPhase(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportStarAsSpecifier(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportWith(_, __field_kind) => __field_kind.set_index(index),
                Self::ImportWithItem(_, __field_kind) => __field_kind.set_index(index),
                Self::Invalid(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXAttr(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXAttrName(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXAttrOrSpread(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXAttrValue(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXClosingElement(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXClosingFragment(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXElement(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXElementChild(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXElementName(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXEmptyExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXExprContainer(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXFragment(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXMemberExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXNamespacedName(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXObject(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXOpeningElement(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXOpeningFragment(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXSpreadChild(_, __field_kind) => __field_kind.set_index(index),
                Self::JSXText(_, __field_kind) => __field_kind.set_index(index),
                Self::Key(_, __field_kind) => __field_kind.set_index(index),
                Self::KeyValuePatProp(_, __field_kind) => __field_kind.set_index(index),
                Self::KeyValueProp(_, __field_kind) => __field_kind.set_index(index),
                Self::LabeledStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::Lit(_, __field_kind) => __field_kind.set_index(index),
                Self::MemberExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::MemberProp(_, __field_kind) => __field_kind.set_index(index),
                Self::MetaPropExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::MetaPropKind(_, __field_kind) => __field_kind.set_index(index),
                Self::MethodKind(_, __field_kind) => __field_kind.set_index(index),
                Self::MethodProp(_, __field_kind) => __field_kind.set_index(index),
                Self::Module(_, __field_kind) => __field_kind.set_index(index),
                Self::ModuleDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::ModuleExportName(_, __field_kind) => __field_kind.set_index(index),
                Self::ModuleItem(_, __field_kind) => __field_kind.set_index(index),
                Self::NamedExport(_, __field_kind) => __field_kind.set_index(index),
                Self::NewExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::Null(_, __field_kind) => __field_kind.set_index(index),
                Self::Number(_, __field_kind) => __field_kind.set_index(index),
                Self::ObjectLit(_, __field_kind) => __field_kind.set_index(index),
                Self::ObjectPat(_, __field_kind) => __field_kind.set_index(index),
                Self::ObjectPatProp(_, __field_kind) => __field_kind.set_index(index),
                Self::OptCall(_, __field_kind) => __field_kind.set_index(index),
                Self::OptChainBase(_, __field_kind) => __field_kind.set_index(index),
                Self::OptChainExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::Param(_, __field_kind) => __field_kind.set_index(index),
                Self::ParamOrTsParamProp(_, __field_kind) => __field_kind.set_index(index),
                Self::ParenExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::Pat(_, __field_kind) => __field_kind.set_index(index),
                Self::PrivateMethod(_, __field_kind) => __field_kind.set_index(index),
                Self::PrivateName(_, __field_kind) => __field_kind.set_index(index),
                Self::PrivateProp(_, __field_kind) => __field_kind.set_index(index),
                Self::Program(_, __field_kind) => __field_kind.set_index(index),
                Self::Prop(_, __field_kind) => __field_kind.set_index(index),
                Self::PropName(_, __field_kind) => __field_kind.set_index(index),
                Self::PropOrSpread(_, __field_kind) => __field_kind.set_index(index),
                Self::Regex(_, __field_kind) => __field_kind.set_index(index),
                Self::RestPat(_, __field_kind) => __field_kind.set_index(index),
                Self::ReturnStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::Script(_, __field_kind) => __field_kind.set_index(index),
                Self::SeqExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::SetterProp(_, __field_kind) => __field_kind.set_index(index),
                Self::SimpleAssignTarget(_, __field_kind) => __field_kind.set_index(index),
                Self::SpreadElement(_, __field_kind) => __field_kind.set_index(index),
                Self::StaticBlock(_, __field_kind) => __field_kind.set_index(index),
                Self::Stmt(_, __field_kind) => __field_kind.set_index(index),
                Self::Str(_, __field_kind) => __field_kind.set_index(index),
                Self::Super(_, __field_kind) => __field_kind.set_index(index),
                Self::SuperProp(_, __field_kind) => __field_kind.set_index(index),
                Self::SuperPropExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::SwitchCase(_, __field_kind) => __field_kind.set_index(index),
                Self::SwitchStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::TaggedTpl(_, __field_kind) => __field_kind.set_index(index),
                Self::ThisExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::ThrowStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::Tpl(_, __field_kind) => __field_kind.set_index(index),
                Self::TplElement(_, __field_kind) => __field_kind.set_index(index),
                Self::TruePlusMinus(_, __field_kind) => __field_kind.set_index(index),
                Self::TryStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::UnaryExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::UnaryOp(_, __field_kind) => __field_kind.set_index(index),
                Self::UpdateExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::UpdateOp(_, __field_kind) => __field_kind.set_index(index),
                Self::UsingDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::VarDecl(_, __field_kind) => __field_kind.set_index(index),
                Self::VarDeclKind(_, __field_kind) => __field_kind.set_index(index),
                Self::VarDeclOrExpr(_, __field_kind) => __field_kind.set_index(index),
                Self::VarDeclarator(_, __field_kind) => __field_kind.set_index(index),
                Self::WhileStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::WithStmt(_, __field_kind) => __field_kind.set_index(index),
                Self::YieldExpr(_, __field_kind) => __field_kind.set_index(index),
            }
        }
    }
    #[cfg(any(docsrs, feature = "path"))]
    impl<'ast> AstParentNodeRef<'ast> {
        #[inline]
        pub fn kind(&self) -> AstParentKind {
            match self {
                Self::ArrayLit(_, __field_kind) => AstParentKind::ArrayLit(*__field_kind),
                Self::ArrayPat(_, __field_kind) => AstParentKind::ArrayPat(*__field_kind),
                Self::ArrowExpr(_, __field_kind) => AstParentKind::ArrowExpr(*__field_kind),
                Self::AssignExpr(_, __field_kind) => AstParentKind::AssignExpr(*__field_kind),
                Self::AssignOp(_, __field_kind) => AstParentKind::AssignOp(*__field_kind),
                Self::AssignPat(_, __field_kind) => AstParentKind::AssignPat(*__field_kind),
                Self::AssignPatProp(_, __field_kind) => AstParentKind::AssignPatProp(*__field_kind),
                Self::AssignProp(_, __field_kind) => AstParentKind::AssignProp(*__field_kind),
                Self::AssignTarget(_, __field_kind) => AstParentKind::AssignTarget(*__field_kind),
                Self::AssignTargetPat(_, __field_kind) => {
                    AstParentKind::AssignTargetPat(*__field_kind)
                }
                Self::AutoAccessor(_, __field_kind) => AstParentKind::AutoAccessor(*__field_kind),
                Self::AwaitExpr(_, __field_kind) => AstParentKind::AwaitExpr(*__field_kind),
                Self::BigInt(_, __field_kind) => AstParentKind::BigInt(*__field_kind),
                Self::BinExpr(_, __field_kind) => AstParentKind::BinExpr(*__field_kind),
                Self::BinaryOp(_, __field_kind) => AstParentKind::BinaryOp(*__field_kind),
                Self::BindingIdent(_, __field_kind) => AstParentKind::BindingIdent(*__field_kind),
                Self::BlockStmt(_, __field_kind) => AstParentKind::BlockStmt(*__field_kind),
                Self::BlockStmtOrExpr(_, __field_kind) => {
                    AstParentKind::BlockStmtOrExpr(*__field_kind)
                }
                Self::Bool(_, __field_kind) => AstParentKind::Bool(*__field_kind),
                Self::BreakStmt(_, __field_kind) => AstParentKind::BreakStmt(*__field_kind),
                Self::CallExpr(_, __field_kind) => AstParentKind::CallExpr(*__field_kind),
                Self::Callee(_, __field_kind) => AstParentKind::Callee(*__field_kind),
                Self::CatchClause(_, __field_kind) => AstParentKind::CatchClause(*__field_kind),
                Self::Class(_, __field_kind) => AstParentKind::Class(*__field_kind),
                Self::ClassDecl(_, __field_kind) => AstParentKind::ClassDecl(*__field_kind),
                Self::ClassExpr(_, __field_kind) => AstParentKind::ClassExpr(*__field_kind),
                Self::ClassMember(_, __field_kind) => AstParentKind::ClassMember(*__field_kind),
                Self::ClassMethod(_, __field_kind) => AstParentKind::ClassMethod(*__field_kind),
                Self::ClassProp(_, __field_kind) => AstParentKind::ClassProp(*__field_kind),
                Self::ComputedPropName(_, __field_kind) => {
                    AstParentKind::ComputedPropName(*__field_kind)
                }
                Self::CondExpr(_, __field_kind) => AstParentKind::CondExpr(*__field_kind),
                Self::Constructor(_, __field_kind) => AstParentKind::Constructor(*__field_kind),
                Self::ContinueStmt(_, __field_kind) => AstParentKind::ContinueStmt(*__field_kind),
                Self::DebuggerStmt(_, __field_kind) => AstParentKind::DebuggerStmt(*__field_kind),
                Self::Decl(_, __field_kind) => AstParentKind::Decl(*__field_kind),
                Self::Decorator(_, __field_kind) => AstParentKind::Decorator(*__field_kind),
                Self::DefaultDecl(_, __field_kind) => AstParentKind::DefaultDecl(*__field_kind),
                Self::DoWhileStmt(_, __field_kind) => AstParentKind::DoWhileStmt(*__field_kind),
                Self::EmptyStmt(_, __field_kind) => AstParentKind::EmptyStmt(*__field_kind),
                Self::ExportAll(_, __field_kind) => AstParentKind::ExportAll(*__field_kind),
                Self::ExportDecl(_, __field_kind) => AstParentKind::ExportDecl(*__field_kind),
                Self::ExportDefaultDecl(_, __field_kind) => {
                    AstParentKind::ExportDefaultDecl(*__field_kind)
                }
                Self::ExportDefaultExpr(_, __field_kind) => {
                    AstParentKind::ExportDefaultExpr(*__field_kind)
                }
                Self::ExportDefaultSpecifier(_, __field_kind) => {
                    AstParentKind::ExportDefaultSpecifier(*__field_kind)
                }
                Self::ExportNamedSpecifier(_, __field_kind) => {
                    AstParentKind::ExportNamedSpecifier(*__field_kind)
                }
                Self::ExportNamespaceSpecifier(_, __field_kind) => {
                    AstParentKind::ExportNamespaceSpecifier(*__field_kind)
                }
                Self::ExportSpecifier(_, __field_kind) => {
                    AstParentKind::ExportSpecifier(*__field_kind)
                }
                Self::Expr(_, __field_kind) => AstParentKind::Expr(*__field_kind),
                Self::ExprOrSpread(_, __field_kind) => AstParentKind::ExprOrSpread(*__field_kind),
                Self::ExprStmt(_, __field_kind) => AstParentKind::ExprStmt(*__field_kind),
                Self::FnDecl(_, __field_kind) => AstParentKind::FnDecl(*__field_kind),
                Self::FnExpr(_, __field_kind) => AstParentKind::FnExpr(*__field_kind),
                Self::ForHead(_, __field_kind) => AstParentKind::ForHead(*__field_kind),
                Self::ForInStmt(_, __field_kind) => AstParentKind::ForInStmt(*__field_kind),
                Self::ForOfStmt(_, __field_kind) => AstParentKind::ForOfStmt(*__field_kind),
                Self::ForStmt(_, __field_kind) => AstParentKind::ForStmt(*__field_kind),
                Self::Function(_, __field_kind) => AstParentKind::Function(*__field_kind),
                Self::GetterProp(_, __field_kind) => AstParentKind::GetterProp(*__field_kind),
                Self::Ident(_, __field_kind) => AstParentKind::Ident(*__field_kind),
                Self::IdentName(_, __field_kind) => AstParentKind::IdentName(*__field_kind),
                Self::IfStmt(_, __field_kind) => AstParentKind::IfStmt(*__field_kind),
                Self::Import(_, __field_kind) => AstParentKind::Import(*__field_kind),
                Self::ImportDecl(_, __field_kind) => AstParentKind::ImportDecl(*__field_kind),
                Self::ImportDefaultSpecifier(_, __field_kind) => {
                    AstParentKind::ImportDefaultSpecifier(*__field_kind)
                }
                Self::ImportNamedSpecifier(_, __field_kind) => {
                    AstParentKind::ImportNamedSpecifier(*__field_kind)
                }
                Self::ImportPhase(_, __field_kind) => AstParentKind::ImportPhase(*__field_kind),
                Self::ImportSpecifier(_, __field_kind) => {
                    AstParentKind::ImportSpecifier(*__field_kind)
                }
                Self::ImportStarAsSpecifier(_, __field_kind) => {
                    AstParentKind::ImportStarAsSpecifier(*__field_kind)
                }
                Self::ImportWith(_, __field_kind) => AstParentKind::ImportWith(*__field_kind),
                Self::ImportWithItem(_, __field_kind) => {
                    AstParentKind::ImportWithItem(*__field_kind)
                }
                Self::Invalid(_, __field_kind) => AstParentKind::Invalid(*__field_kind),
                Self::JSXAttr(_, __field_kind) => AstParentKind::JSXAttr(*__field_kind),
                Self::JSXAttrName(_, __field_kind) => AstParentKind::JSXAttrName(*__field_kind),
                Self::JSXAttrOrSpread(_, __field_kind) => {
                    AstParentKind::JSXAttrOrSpread(*__field_kind)
                }
                Self::JSXAttrValue(_, __field_kind) => AstParentKind::JSXAttrValue(*__field_kind),
                Self::JSXClosingElement(_, __field_kind) => {
                    AstParentKind::JSXClosingElement(*__field_kind)
                }
                Self::JSXClosingFragment(_, __field_kind) => {
                    AstParentKind::JSXClosingFragment(*__field_kind)
                }
                Self::JSXElement(_, __field_kind) => AstParentKind::JSXElement(*__field_kind),
                Self::JSXElementChild(_, __field_kind) => {
                    AstParentKind::JSXElementChild(*__field_kind)
                }
                Self::JSXElementName(_, __field_kind) => {
                    AstParentKind::JSXElementName(*__field_kind)
                }
                Self::JSXEmptyExpr(_, __field_kind) => AstParentKind::JSXEmptyExpr(*__field_kind),
                Self::JSXExpr(_, __field_kind) => AstParentKind::JSXExpr(*__field_kind),
                Self::JSXExprContainer(_, __field_kind) => {
                    AstParentKind::JSXExprContainer(*__field_kind)
                }
                Self::JSXFragment(_, __field_kind) => AstParentKind::JSXFragment(*__field_kind),
                Self::JSXMemberExpr(_, __field_kind) => AstParentKind::JSXMemberExpr(*__field_kind),
                Self::JSXNamespacedName(_, __field_kind) => {
                    AstParentKind::JSXNamespacedName(*__field_kind)
                }
                Self::JSXObject(_, __field_kind) => AstParentKind::JSXObject(*__field_kind),
                Self::JSXOpeningElement(_, __field_kind) => {
                    AstParentKind::JSXOpeningElement(*__field_kind)
                }
                Self::JSXOpeningFragment(_, __field_kind) => {
                    AstParentKind::JSXOpeningFragment(*__field_kind)
                }
                Self::JSXSpreadChild(_, __field_kind) => {
                    AstParentKind::JSXSpreadChild(*__field_kind)
                }
                Self::JSXText(_, __field_kind) => AstParentKind::JSXText(*__field_kind),
                Self::Key(_, __field_kind) => AstParentKind::Key(*__field_kind),
                Self::KeyValuePatProp(_, __field_kind) => {
                    AstParentKind::KeyValuePatProp(*__field_kind)
                }
                Self::KeyValueProp(_, __field_kind) => AstParentKind::KeyValueProp(*__field_kind),
                Self::LabeledStmt(_, __field_kind) => AstParentKind::LabeledStmt(*__field_kind),
                Self::Lit(_, __field_kind) => AstParentKind::Lit(*__field_kind),
                Self::MemberExpr(_, __field_kind) => AstParentKind::MemberExpr(*__field_kind),
                Self::MemberProp(_, __field_kind) => AstParentKind::MemberProp(*__field_kind),
                Self::MetaPropExpr(_, __field_kind) => AstParentKind::MetaPropExpr(*__field_kind),
                Self::MetaPropKind(_, __field_kind) => AstParentKind::MetaPropKind(*__field_kind),
                Self::MethodKind(_, __field_kind) => AstParentKind::MethodKind(*__field_kind),
                Self::MethodProp(_, __field_kind) => AstParentKind::MethodProp(*__field_kind),
                Self::Module(_, __field_kind) => AstParentKind::Module(*__field_kind),
                Self::ModuleDecl(_, __field_kind) => AstParentKind::ModuleDecl(*__field_kind),
                Self::ModuleExportName(_, __field_kind) => {
                    AstParentKind::ModuleExportName(*__field_kind)
                }
                Self::ModuleItem(_, __field_kind) => AstParentKind::ModuleItem(*__field_kind),
                Self::NamedExport(_, __field_kind) => AstParentKind::NamedExport(*__field_kind),
                Self::NewExpr(_, __field_kind) => AstParentKind::NewExpr(*__field_kind),
                Self::Null(_, __field_kind) => AstParentKind::Null(*__field_kind),
                Self::Number(_, __field_kind) => AstParentKind::Number(*__field_kind),
                Self::ObjectLit(_, __field_kind) => AstParentKind::ObjectLit(*__field_kind),
                Self::ObjectPat(_, __field_kind) => AstParentKind::ObjectPat(*__field_kind),
                Self::ObjectPatProp(_, __field_kind) => AstParentKind::ObjectPatProp(*__field_kind),
                Self::OptCall(_, __field_kind) => AstParentKind::OptCall(*__field_kind),
                Self::OptChainBase(_, __field_kind) => AstParentKind::OptChainBase(*__field_kind),
                Self::OptChainExpr(_, __field_kind) => AstParentKind::OptChainExpr(*__field_kind),
                Self::Param(_, __field_kind) => AstParentKind::Param(*__field_kind),
                Self::ParamOrTsParamProp(_, __field_kind) => {
                    AstParentKind::ParamOrTsParamProp(*__field_kind)
                }
                Self::ParenExpr(_, __field_kind) => AstParentKind::ParenExpr(*__field_kind),
                Self::Pat(_, __field_kind) => AstParentKind::Pat(*__field_kind),
                Self::PrivateMethod(_, __field_kind) => AstParentKind::PrivateMethod(*__field_kind),
                Self::PrivateName(_, __field_kind) => AstParentKind::PrivateName(*__field_kind),
                Self::PrivateProp(_, __field_kind) => AstParentKind::PrivateProp(*__field_kind),
                Self::Program(_, __field_kind) => AstParentKind::Program(*__field_kind),
                Self::Prop(_, __field_kind) => AstParentKind::Prop(*__field_kind),
                Self::PropName(_, __field_kind) => AstParentKind::PropName(*__field_kind),
                Self::PropOrSpread(_, __field_kind) => AstParentKind::PropOrSpread(*__field_kind),
                Self::Regex(_, __field_kind) => AstParentKind::Regex(*__field_kind),
                Self::RestPat(_, __field_kind) => AstParentKind::RestPat(*__field_kind),
                Self::ReturnStmt(_, __field_kind) => AstParentKind::ReturnStmt(*__field_kind),
                Self::Script(_, __field_kind) => AstParentKind::Script(*__field_kind),
                Self::SeqExpr(_, __field_kind) => AstParentKind::SeqExpr(*__field_kind),
                Self::SetterProp(_, __field_kind) => AstParentKind::SetterProp(*__field_kind),
                Self::SimpleAssignTarget(_, __field_kind) => {
                    AstParentKind::SimpleAssignTarget(*__field_kind)
                }
                Self::SpreadElement(_, __field_kind) => AstParentKind::SpreadElement(*__field_kind),
                Self::StaticBlock(_, __field_kind) => AstParentKind::StaticBlock(*__field_kind),
                Self::Stmt(_, __field_kind) => AstParentKind::Stmt(*__field_kind),
                Self::Str(_, __field_kind) => AstParentKind::Str(*__field_kind),
                Self::Super(_, __field_kind) => AstParentKind::Super(*__field_kind),
                Self::SuperProp(_, __field_kind) => AstParentKind::SuperProp(*__field_kind),
                Self::SuperPropExpr(_, __field_kind) => AstParentKind::SuperPropExpr(*__field_kind),
                Self::SwitchCase(_, __field_kind) => AstParentKind::SwitchCase(*__field_kind),
                Self::SwitchStmt(_, __field_kind) => AstParentKind::SwitchStmt(*__field_kind),
                Self::TaggedTpl(_, __field_kind) => AstParentKind::TaggedTpl(*__field_kind),
                Self::ThisExpr(_, __field_kind) => AstParentKind::ThisExpr(*__field_kind),
                Self::ThrowStmt(_, __field_kind) => AstParentKind::ThrowStmt(*__field_kind),
                Self::Tpl(_, __field_kind) => AstParentKind::Tpl(*__field_kind),
                Self::TplElement(_, __field_kind) => AstParentKind::TplElement(*__field_kind),
                Self::TruePlusMinus(_, __field_kind) => AstParentKind::TruePlusMinus(*__field_kind),
                Self::TryStmt(_, __field_kind) => AstParentKind::TryStmt(*__field_kind),
                Self::UnaryExpr(_, __field_kind) => AstParentKind::UnaryExpr(*__field_kind),
                Self::UnaryOp(_, __field_kind) => AstParentKind::UnaryOp(*__field_kind),
                Self::UpdateExpr(_, __field_kind) => AstParentKind::UpdateExpr(*__field_kind),
                Self::UpdateOp(_, __field_kind) => AstParentKind::UpdateOp(*__field_kind),
                Self::UsingDecl(_, __field_kind) => AstParentKind::UsingDecl(*__field_kind),
                Self::VarDecl(_, __field_kind) => AstParentKind::VarDecl(*__field_kind),
                Self::VarDeclKind(_, __field_kind) => AstParentKind::VarDeclKind(*__field_kind),
                Self::VarDeclOrExpr(_, __field_kind) => AstParentKind::VarDeclOrExpr(*__field_kind),
                Self::VarDeclarator(_, __field_kind) => AstParentKind::VarDeclarator(*__field_kind),
                Self::WhileStmt(_, __field_kind) => AstParentKind::WhileStmt(*__field_kind),
                Self::WithStmt(_, __field_kind) => AstParentKind::WithStmt(*__field_kind),
                Self::YieldExpr(_, __field_kind) => AstParentKind::YieldExpr(*__field_kind),
            }
        }
    }
}
impl<'ast> From<&'ast ArrayLit> for NodeRef<'ast> {
    fn from(node: &'ast ArrayLit) -> Self {
        NodeRef::ArrayLit(node)
    }
}
impl<'ast> From<&'ast ArrayPat> for NodeRef<'ast> {
    fn from(node: &'ast ArrayPat) -> Self {
        NodeRef::ArrayPat(node)
    }
}
impl<'ast> From<&'ast ArrowExpr> for NodeRef<'ast> {
    fn from(node: &'ast ArrowExpr) -> Self {
        NodeRef::ArrowExpr(node)
    }
}
impl<'ast> From<&'ast AssignExpr> for NodeRef<'ast> {
    fn from(node: &'ast AssignExpr) -> Self {
        NodeRef::AssignExpr(node)
    }
}
impl<'ast> From<&'ast AssignOp> for NodeRef<'ast> {
    fn from(node: &'ast AssignOp) -> Self {
        NodeRef::AssignOp(node)
    }
}
impl<'ast> From<&'ast AssignPat> for NodeRef<'ast> {
    fn from(node: &'ast AssignPat) -> Self {
        NodeRef::AssignPat(node)
    }
}
impl<'ast> From<&'ast AssignPatProp> for NodeRef<'ast> {
    fn from(node: &'ast AssignPatProp) -> Self {
        NodeRef::AssignPatProp(node)
    }
}
impl<'ast> From<&'ast AssignProp> for NodeRef<'ast> {
    fn from(node: &'ast AssignProp) -> Self {
        NodeRef::AssignProp(node)
    }
}
impl<'ast> From<&'ast AssignTarget> for NodeRef<'ast> {
    fn from(node: &'ast AssignTarget) -> Self {
        NodeRef::AssignTarget(node)
    }
}
impl<'ast> From<&'ast AssignTargetPat> for NodeRef<'ast> {
    fn from(node: &'ast AssignTargetPat) -> Self {
        NodeRef::AssignTargetPat(node)
    }
}
impl<'ast> From<&'ast AutoAccessor> for NodeRef<'ast> {
    fn from(node: &'ast AutoAccessor) -> Self {
        NodeRef::AutoAccessor(node)
    }
}
impl<'ast> From<&'ast AwaitExpr> for NodeRef<'ast> {
    fn from(node: &'ast AwaitExpr) -> Self {
        NodeRef::AwaitExpr(node)
    }
}
impl<'ast> From<&'ast BigInt> for NodeRef<'ast> {
    fn from(node: &'ast BigInt) -> Self {
        NodeRef::BigInt(node)
    }
}
impl<'ast> From<&'ast BinExpr> for NodeRef<'ast> {
    fn from(node: &'ast BinExpr) -> Self {
        NodeRef::BinExpr(node)
    }
}
impl<'ast> From<&'ast BinaryOp> for NodeRef<'ast> {
    fn from(node: &'ast BinaryOp) -> Self {
        NodeRef::BinaryOp(node)
    }
}
impl<'ast> From<&'ast BindingIdent> for NodeRef<'ast> {
    fn from(node: &'ast BindingIdent) -> Self {
        NodeRef::BindingIdent(node)
    }
}
impl<'ast> From<&'ast BlockStmt> for NodeRef<'ast> {
    fn from(node: &'ast BlockStmt) -> Self {
        NodeRef::BlockStmt(node)
    }
}
impl<'ast> From<&'ast BlockStmtOrExpr> for NodeRef<'ast> {
    fn from(node: &'ast BlockStmtOrExpr) -> Self {
        NodeRef::BlockStmtOrExpr(node)
    }
}
impl<'ast> From<&'ast Bool> for NodeRef<'ast> {
    fn from(node: &'ast Bool) -> Self {
        NodeRef::Bool(node)
    }
}
impl<'ast> From<&'ast BreakStmt> for NodeRef<'ast> {
    fn from(node: &'ast BreakStmt) -> Self {
        NodeRef::BreakStmt(node)
    }
}
impl<'ast> From<&'ast CallExpr> for NodeRef<'ast> {
    fn from(node: &'ast CallExpr) -> Self {
        NodeRef::CallExpr(node)
    }
}
impl<'ast> From<&'ast Callee> for NodeRef<'ast> {
    fn from(node: &'ast Callee) -> Self {
        NodeRef::Callee(node)
    }
}
impl<'ast> From<&'ast CatchClause> for NodeRef<'ast> {
    fn from(node: &'ast CatchClause) -> Self {
        NodeRef::CatchClause(node)
    }
}
impl<'ast> From<&'ast Class> for NodeRef<'ast> {
    fn from(node: &'ast Class) -> Self {
        NodeRef::Class(node)
    }
}
impl<'ast> From<&'ast ClassDecl> for NodeRef<'ast> {
    fn from(node: &'ast ClassDecl) -> Self {
        NodeRef::ClassDecl(node)
    }
}
impl<'ast> From<&'ast ClassExpr> for NodeRef<'ast> {
    fn from(node: &'ast ClassExpr) -> Self {
        NodeRef::ClassExpr(node)
    }
}
impl<'ast> From<&'ast ClassMember> for NodeRef<'ast> {
    fn from(node: &'ast ClassMember) -> Self {
        NodeRef::ClassMember(node)
    }
}
impl<'ast> From<&'ast ClassMethod> for NodeRef<'ast> {
    fn from(node: &'ast ClassMethod) -> Self {
        NodeRef::ClassMethod(node)
    }
}
impl<'ast> From<&'ast ClassProp> for NodeRef<'ast> {
    fn from(node: &'ast ClassProp) -> Self {
        NodeRef::ClassProp(node)
    }
}
impl<'ast> From<&'ast ComputedPropName> for NodeRef<'ast> {
    fn from(node: &'ast ComputedPropName) -> Self {
        NodeRef::ComputedPropName(node)
    }
}
impl<'ast> From<&'ast CondExpr> for NodeRef<'ast> {
    fn from(node: &'ast CondExpr) -> Self {
        NodeRef::CondExpr(node)
    }
}
impl<'ast> From<&'ast Constructor> for NodeRef<'ast> {
    fn from(node: &'ast Constructor) -> Self {
        NodeRef::Constructor(node)
    }
}
impl<'ast> From<&'ast ContinueStmt> for NodeRef<'ast> {
    fn from(node: &'ast ContinueStmt) -> Self {
        NodeRef::ContinueStmt(node)
    }
}
impl<'ast> From<&'ast DebuggerStmt> for NodeRef<'ast> {
    fn from(node: &'ast DebuggerStmt) -> Self {
        NodeRef::DebuggerStmt(node)
    }
}
impl<'ast> From<&'ast Decl> for NodeRef<'ast> {
    fn from(node: &'ast Decl) -> Self {
        NodeRef::Decl(node)
    }
}
impl<'ast> From<&'ast Decorator> for NodeRef<'ast> {
    fn from(node: &'ast Decorator) -> Self {
        NodeRef::Decorator(node)
    }
}
impl<'ast> From<&'ast DefaultDecl> for NodeRef<'ast> {
    fn from(node: &'ast DefaultDecl) -> Self {
        NodeRef::DefaultDecl(node)
    }
}
impl<'ast> From<&'ast DoWhileStmt> for NodeRef<'ast> {
    fn from(node: &'ast DoWhileStmt) -> Self {
        NodeRef::DoWhileStmt(node)
    }
}
impl<'ast> From<&'ast EmptyStmt> for NodeRef<'ast> {
    fn from(node: &'ast EmptyStmt) -> Self {
        NodeRef::EmptyStmt(node)
    }
}
impl<'ast> From<&'ast ExportAll> for NodeRef<'ast> {
    fn from(node: &'ast ExportAll) -> Self {
        NodeRef::ExportAll(node)
    }
}
impl<'ast> From<&'ast ExportDecl> for NodeRef<'ast> {
    fn from(node: &'ast ExportDecl) -> Self {
        NodeRef::ExportDecl(node)
    }
}
impl<'ast> From<&'ast ExportDefaultDecl> for NodeRef<'ast> {
    fn from(node: &'ast ExportDefaultDecl) -> Self {
        NodeRef::ExportDefaultDecl(node)
    }
}
impl<'ast> From<&'ast ExportDefaultExpr> for NodeRef<'ast> {
    fn from(node: &'ast ExportDefaultExpr) -> Self {
        NodeRef::ExportDefaultExpr(node)
    }
}
impl<'ast> From<&'ast ExportDefaultSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ExportDefaultSpecifier) -> Self {
        NodeRef::ExportDefaultSpecifier(node)
    }
}
impl<'ast> From<&'ast ExportNamedSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ExportNamedSpecifier) -> Self {
        NodeRef::ExportNamedSpecifier(node)
    }
}
impl<'ast> From<&'ast ExportNamespaceSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ExportNamespaceSpecifier) -> Self {
        NodeRef::ExportNamespaceSpecifier(node)
    }
}
impl<'ast> From<&'ast ExportSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ExportSpecifier) -> Self {
        NodeRef::ExportSpecifier(node)
    }
}
impl<'ast> From<&'ast Expr> for NodeRef<'ast> {
    fn from(node: &'ast Expr) -> Self {
        NodeRef::Expr(node)
    }
}
impl<'ast> From<&'ast ExprOrSpread> for NodeRef<'ast> {
    fn from(node: &'ast ExprOrSpread) -> Self {
        NodeRef::ExprOrSpread(node)
    }
}
impl<'ast> From<&'ast ExprStmt> for NodeRef<'ast> {
    fn from(node: &'ast ExprStmt) -> Self {
        NodeRef::ExprStmt(node)
    }
}
impl<'ast> From<&'ast FnDecl> for NodeRef<'ast> {
    fn from(node: &'ast FnDecl) -> Self {
        NodeRef::FnDecl(node)
    }
}
impl<'ast> From<&'ast FnExpr> for NodeRef<'ast> {
    fn from(node: &'ast FnExpr) -> Self {
        NodeRef::FnExpr(node)
    }
}
impl<'ast> From<&'ast ForHead> for NodeRef<'ast> {
    fn from(node: &'ast ForHead) -> Self {
        NodeRef::ForHead(node)
    }
}
impl<'ast> From<&'ast ForInStmt> for NodeRef<'ast> {
    fn from(node: &'ast ForInStmt) -> Self {
        NodeRef::ForInStmt(node)
    }
}
impl<'ast> From<&'ast ForOfStmt> for NodeRef<'ast> {
    fn from(node: &'ast ForOfStmt) -> Self {
        NodeRef::ForOfStmt(node)
    }
}
impl<'ast> From<&'ast ForStmt> for NodeRef<'ast> {
    fn from(node: &'ast ForStmt) -> Self {
        NodeRef::ForStmt(node)
    }
}
impl<'ast> From<&'ast Function> for NodeRef<'ast> {
    fn from(node: &'ast Function) -> Self {
        NodeRef::Function(node)
    }
}
impl<'ast> From<&'ast GetterProp> for NodeRef<'ast> {
    fn from(node: &'ast GetterProp) -> Self {
        NodeRef::GetterProp(node)
    }
}
impl<'ast> From<&'ast Ident> for NodeRef<'ast> {
    fn from(node: &'ast Ident) -> Self {
        NodeRef::Ident(node)
    }
}
impl<'ast> From<&'ast IdentName> for NodeRef<'ast> {
    fn from(node: &'ast IdentName) -> Self {
        NodeRef::IdentName(node)
    }
}
impl<'ast> From<&'ast IfStmt> for NodeRef<'ast> {
    fn from(node: &'ast IfStmt) -> Self {
        NodeRef::IfStmt(node)
    }
}
impl<'ast> From<&'ast Import> for NodeRef<'ast> {
    fn from(node: &'ast Import) -> Self {
        NodeRef::Import(node)
    }
}
impl<'ast> From<&'ast ImportDecl> for NodeRef<'ast> {
    fn from(node: &'ast ImportDecl) -> Self {
        NodeRef::ImportDecl(node)
    }
}
impl<'ast> From<&'ast ImportDefaultSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ImportDefaultSpecifier) -> Self {
        NodeRef::ImportDefaultSpecifier(node)
    }
}
impl<'ast> From<&'ast ImportNamedSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ImportNamedSpecifier) -> Self {
        NodeRef::ImportNamedSpecifier(node)
    }
}
impl<'ast> From<&'ast ImportPhase> for NodeRef<'ast> {
    fn from(node: &'ast ImportPhase) -> Self {
        NodeRef::ImportPhase(node)
    }
}
impl<'ast> From<&'ast ImportSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ImportSpecifier) -> Self {
        NodeRef::ImportSpecifier(node)
    }
}
impl<'ast> From<&'ast ImportStarAsSpecifier> for NodeRef<'ast> {
    fn from(node: &'ast ImportStarAsSpecifier) -> Self {
        NodeRef::ImportStarAsSpecifier(node)
    }
}
impl<'ast> From<&'ast ImportWith> for NodeRef<'ast> {
    fn from(node: &'ast ImportWith) -> Self {
        NodeRef::ImportWith(node)
    }
}
impl<'ast> From<&'ast ImportWithItem> for NodeRef<'ast> {
    fn from(node: &'ast ImportWithItem) -> Self {
        NodeRef::ImportWithItem(node)
    }
}
impl<'ast> From<&'ast Invalid> for NodeRef<'ast> {
    fn from(node: &'ast Invalid) -> Self {
        NodeRef::Invalid(node)
    }
}
impl<'ast> From<&'ast JSXAttr> for NodeRef<'ast> {
    fn from(node: &'ast JSXAttr) -> Self {
        NodeRef::JSXAttr(node)
    }
}
impl<'ast> From<&'ast JSXAttrName> for NodeRef<'ast> {
    fn from(node: &'ast JSXAttrName) -> Self {
        NodeRef::JSXAttrName(node)
    }
}
impl<'ast> From<&'ast JSXAttrOrSpread> for NodeRef<'ast> {
    fn from(node: &'ast JSXAttrOrSpread) -> Self {
        NodeRef::JSXAttrOrSpread(node)
    }
}
impl<'ast> From<&'ast JSXAttrValue> for NodeRef<'ast> {
    fn from(node: &'ast JSXAttrValue) -> Self {
        NodeRef::JSXAttrValue(node)
    }
}
impl<'ast> From<&'ast JSXClosingElement> for NodeRef<'ast> {
    fn from(node: &'ast JSXClosingElement) -> Self {
        NodeRef::JSXClosingElement(node)
    }
}
impl<'ast> From<&'ast JSXClosingFragment> for NodeRef<'ast> {
    fn from(node: &'ast JSXClosingFragment) -> Self {
        NodeRef::JSXClosingFragment(node)
    }
}
impl<'ast> From<&'ast JSXElement> for NodeRef<'ast> {
    fn from(node: &'ast JSXElement) -> Self {
        NodeRef::JSXElement(node)
    }
}
impl<'ast> From<&'ast JSXElementChild> for NodeRef<'ast> {
    fn from(node: &'ast JSXElementChild) -> Self {
        NodeRef::JSXElementChild(node)
    }
}
impl<'ast> From<&'ast JSXElementName> for NodeRef<'ast> {
    fn from(node: &'ast JSXElementName) -> Self {
        NodeRef::JSXElementName(node)
    }
}
impl<'ast> From<&'ast JSXEmptyExpr> for NodeRef<'ast> {
    fn from(node: &'ast JSXEmptyExpr) -> Self {
        NodeRef::JSXEmptyExpr(node)
    }
}
impl<'ast> From<&'ast JSXExpr> for NodeRef<'ast> {
    fn from(node: &'ast JSXExpr) -> Self {
        NodeRef::JSXExpr(node)
    }
}
impl<'ast> From<&'ast JSXExprContainer> for NodeRef<'ast> {
    fn from(node: &'ast JSXExprContainer) -> Self {
        NodeRef::JSXExprContainer(node)
    }
}
impl<'ast> From<&'ast JSXFragment> for NodeRef<'ast> {
    fn from(node: &'ast JSXFragment) -> Self {
        NodeRef::JSXFragment(node)
    }
}
impl<'ast> From<&'ast JSXMemberExpr> for NodeRef<'ast> {
    fn from(node: &'ast JSXMemberExpr) -> Self {
        NodeRef::JSXMemberExpr(node)
    }
}
impl<'ast> From<&'ast JSXNamespacedName> for NodeRef<'ast> {
    fn from(node: &'ast JSXNamespacedName) -> Self {
        NodeRef::JSXNamespacedName(node)
    }
}
impl<'ast> From<&'ast JSXObject> for NodeRef<'ast> {
    fn from(node: &'ast JSXObject) -> Self {
        NodeRef::JSXObject(node)
    }
}
impl<'ast> From<&'ast JSXOpeningElement> for NodeRef<'ast> {
    fn from(node: &'ast JSXOpeningElement) -> Self {
        NodeRef::JSXOpeningElement(node)
    }
}
impl<'ast> From<&'ast JSXOpeningFragment> for NodeRef<'ast> {
    fn from(node: &'ast JSXOpeningFragment) -> Self {
        NodeRef::JSXOpeningFragment(node)
    }
}
impl<'ast> From<&'ast JSXSpreadChild> for NodeRef<'ast> {
    fn from(node: &'ast JSXSpreadChild) -> Self {
        NodeRef::JSXSpreadChild(node)
    }
}
impl<'ast> From<&'ast JSXText> for NodeRef<'ast> {
    fn from(node: &'ast JSXText) -> Self {
        NodeRef::JSXText(node)
    }
}
impl<'ast> From<&'ast Key> for NodeRef<'ast> {
    fn from(node: &'ast Key) -> Self {
        NodeRef::Key(node)
    }
}
impl<'ast> From<&'ast KeyValuePatProp> for NodeRef<'ast> {
    fn from(node: &'ast KeyValuePatProp) -> Self {
        NodeRef::KeyValuePatProp(node)
    }
}
impl<'ast> From<&'ast KeyValueProp> for NodeRef<'ast> {
    fn from(node: &'ast KeyValueProp) -> Self {
        NodeRef::KeyValueProp(node)
    }
}
impl<'ast> From<&'ast LabeledStmt> for NodeRef<'ast> {
    fn from(node: &'ast LabeledStmt) -> Self {
        NodeRef::LabeledStmt(node)
    }
}
impl<'ast> From<&'ast Lit> for NodeRef<'ast> {
    fn from(node: &'ast Lit) -> Self {
        NodeRef::Lit(node)
    }
}
impl<'ast> From<&'ast MemberExpr> for NodeRef<'ast> {
    fn from(node: &'ast MemberExpr) -> Self {
        NodeRef::MemberExpr(node)
    }
}
impl<'ast> From<&'ast MemberProp> for NodeRef<'ast> {
    fn from(node: &'ast MemberProp) -> Self {
        NodeRef::MemberProp(node)
    }
}
impl<'ast> From<&'ast MetaPropExpr> for NodeRef<'ast> {
    fn from(node: &'ast MetaPropExpr) -> Self {
        NodeRef::MetaPropExpr(node)
    }
}
impl<'ast> From<&'ast MetaPropKind> for NodeRef<'ast> {
    fn from(node: &'ast MetaPropKind) -> Self {
        NodeRef::MetaPropKind(node)
    }
}
impl<'ast> From<&'ast MethodKind> for NodeRef<'ast> {
    fn from(node: &'ast MethodKind) -> Self {
        NodeRef::MethodKind(node)
    }
}
impl<'ast> From<&'ast MethodProp> for NodeRef<'ast> {
    fn from(node: &'ast MethodProp) -> Self {
        NodeRef::MethodProp(node)
    }
}
impl<'ast> From<&'ast Module> for NodeRef<'ast> {
    fn from(node: &'ast Module) -> Self {
        NodeRef::Module(node)
    }
}
impl<'ast> From<&'ast ModuleDecl> for NodeRef<'ast> {
    fn from(node: &'ast ModuleDecl) -> Self {
        NodeRef::ModuleDecl(node)
    }
}
impl<'ast> From<&'ast ModuleExportName> for NodeRef<'ast> {
    fn from(node: &'ast ModuleExportName) -> Self {
        NodeRef::ModuleExportName(node)
    }
}
impl<'ast> From<&'ast ModuleItem> for NodeRef<'ast> {
    fn from(node: &'ast ModuleItem) -> Self {
        NodeRef::ModuleItem(node)
    }
}
impl<'ast> From<&'ast NamedExport> for NodeRef<'ast> {
    fn from(node: &'ast NamedExport) -> Self {
        NodeRef::NamedExport(node)
    }
}
impl<'ast> From<&'ast NewExpr> for NodeRef<'ast> {
    fn from(node: &'ast NewExpr) -> Self {
        NodeRef::NewExpr(node)
    }
}
impl<'ast> From<&'ast Null> for NodeRef<'ast> {
    fn from(node: &'ast Null) -> Self {
        NodeRef::Null(node)
    }
}
impl<'ast> From<&'ast Number> for NodeRef<'ast> {
    fn from(node: &'ast Number) -> Self {
        NodeRef::Number(node)
    }
}
impl<'ast> From<&'ast ObjectLit> for NodeRef<'ast> {
    fn from(node: &'ast ObjectLit) -> Self {
        NodeRef::ObjectLit(node)
    }
}
impl<'ast> From<&'ast ObjectPat> for NodeRef<'ast> {
    fn from(node: &'ast ObjectPat) -> Self {
        NodeRef::ObjectPat(node)
    }
}
impl<'ast> From<&'ast ObjectPatProp> for NodeRef<'ast> {
    fn from(node: &'ast ObjectPatProp) -> Self {
        NodeRef::ObjectPatProp(node)
    }
}
impl<'ast> From<&'ast OptCall> for NodeRef<'ast> {
    fn from(node: &'ast OptCall) -> Self {
        NodeRef::OptCall(node)
    }
}
impl<'ast> From<&'ast OptChainBase> for NodeRef<'ast> {
    fn from(node: &'ast OptChainBase) -> Self {
        NodeRef::OptChainBase(node)
    }
}
impl<'ast> From<&'ast OptChainExpr> for NodeRef<'ast> {
    fn from(node: &'ast OptChainExpr) -> Self {
        NodeRef::OptChainExpr(node)
    }
}
impl<'ast> From<&'ast Param> for NodeRef<'ast> {
    fn from(node: &'ast Param) -> Self {
        NodeRef::Param(node)
    }
}
impl<'ast> From<&'ast ParamOrTsParamProp> for NodeRef<'ast> {
    fn from(node: &'ast ParamOrTsParamProp) -> Self {
        NodeRef::ParamOrTsParamProp(node)
    }
}
impl<'ast> From<&'ast ParenExpr> for NodeRef<'ast> {
    fn from(node: &'ast ParenExpr) -> Self {
        NodeRef::ParenExpr(node)
    }
}
impl<'ast> From<&'ast Pat> for NodeRef<'ast> {
    fn from(node: &'ast Pat) -> Self {
        NodeRef::Pat(node)
    }
}
impl<'ast> From<&'ast PrivateMethod> for NodeRef<'ast> {
    fn from(node: &'ast PrivateMethod) -> Self {
        NodeRef::PrivateMethod(node)
    }
}
impl<'ast> From<&'ast PrivateName> for NodeRef<'ast> {
    fn from(node: &'ast PrivateName) -> Self {
        NodeRef::PrivateName(node)
    }
}
impl<'ast> From<&'ast PrivateProp> for NodeRef<'ast> {
    fn from(node: &'ast PrivateProp) -> Self {
        NodeRef::PrivateProp(node)
    }
}
impl<'ast> From<&'ast Program> for NodeRef<'ast> {
    fn from(node: &'ast Program) -> Self {
        NodeRef::Program(node)
    }
}
impl<'ast> From<&'ast Prop> for NodeRef<'ast> {
    fn from(node: &'ast Prop) -> Self {
        NodeRef::Prop(node)
    }
}
impl<'ast> From<&'ast PropName> for NodeRef<'ast> {
    fn from(node: &'ast PropName) -> Self {
        NodeRef::PropName(node)
    }
}
impl<'ast> From<&'ast PropOrSpread> for NodeRef<'ast> {
    fn from(node: &'ast PropOrSpread) -> Self {
        NodeRef::PropOrSpread(node)
    }
}
impl<'ast> From<&'ast Regex> for NodeRef<'ast> {
    fn from(node: &'ast Regex) -> Self {
        NodeRef::Regex(node)
    }
}
impl<'ast> From<&'ast RestPat> for NodeRef<'ast> {
    fn from(node: &'ast RestPat) -> Self {
        NodeRef::RestPat(node)
    }
}
impl<'ast> From<&'ast ReturnStmt> for NodeRef<'ast> {
    fn from(node: &'ast ReturnStmt) -> Self {
        NodeRef::ReturnStmt(node)
    }
}
impl<'ast> From<&'ast Script> for NodeRef<'ast> {
    fn from(node: &'ast Script) -> Self {
        NodeRef::Script(node)
    }
}
impl<'ast> From<&'ast SeqExpr> for NodeRef<'ast> {
    fn from(node: &'ast SeqExpr) -> Self {
        NodeRef::SeqExpr(node)
    }
}
impl<'ast> From<&'ast SetterProp> for NodeRef<'ast> {
    fn from(node: &'ast SetterProp) -> Self {
        NodeRef::SetterProp(node)
    }
}
impl<'ast> From<&'ast SimpleAssignTarget> for NodeRef<'ast> {
    fn from(node: &'ast SimpleAssignTarget) -> Self {
        NodeRef::SimpleAssignTarget(node)
    }
}
impl<'ast> From<&'ast SpreadElement> for NodeRef<'ast> {
    fn from(node: &'ast SpreadElement) -> Self {
        NodeRef::SpreadElement(node)
    }
}
impl<'ast> From<&'ast StaticBlock> for NodeRef<'ast> {
    fn from(node: &'ast StaticBlock) -> Self {
        NodeRef::StaticBlock(node)
    }
}
impl<'ast> From<&'ast Stmt> for NodeRef<'ast> {
    fn from(node: &'ast Stmt) -> Self {
        NodeRef::Stmt(node)
    }
}
impl<'ast> From<&'ast Str> for NodeRef<'ast> {
    fn from(node: &'ast Str) -> Self {
        NodeRef::Str(node)
    }
}
impl<'ast> From<&'ast Super> for NodeRef<'ast> {
    fn from(node: &'ast Super) -> Self {
        NodeRef::Super(node)
    }
}
impl<'ast> From<&'ast SuperProp> for NodeRef<'ast> {
    fn from(node: &'ast SuperProp) -> Self {
        NodeRef::SuperProp(node)
    }
}
impl<'ast> From<&'ast SuperPropExpr> for NodeRef<'ast> {
    fn from(node: &'ast SuperPropExpr) -> Self {
        NodeRef::SuperPropExpr(node)
    }
}
impl<'ast> From<&'ast SwitchCase> for NodeRef<'ast> {
    fn from(node: &'ast SwitchCase) -> Self {
        NodeRef::SwitchCase(node)
    }
}
impl<'ast> From<&'ast SwitchStmt> for NodeRef<'ast> {
    fn from(node: &'ast SwitchStmt) -> Self {
        NodeRef::SwitchStmt(node)
    }
}
impl<'ast> From<&'ast TaggedTpl> for NodeRef<'ast> {
    fn from(node: &'ast TaggedTpl) -> Self {
        NodeRef::TaggedTpl(node)
    }
}
impl<'ast> From<&'ast ThisExpr> for NodeRef<'ast> {
    fn from(node: &'ast ThisExpr) -> Self {
        NodeRef::ThisExpr(node)
    }
}
impl<'ast> From<&'ast ThrowStmt> for NodeRef<'ast> {
    fn from(node: &'ast ThrowStmt) -> Self {
        NodeRef::ThrowStmt(node)
    }
}
impl<'ast> From<&'ast Tpl> for NodeRef<'ast> {
    fn from(node: &'ast Tpl) -> Self {
        NodeRef::Tpl(node)
    }
}
impl<'ast> From<&'ast TplElement> for NodeRef<'ast> {
    fn from(node: &'ast TplElement) -> Self {
        NodeRef::TplElement(node)
    }
}
impl<'ast> From<&'ast TruePlusMinus> for NodeRef<'ast> {
    fn from(node: &'ast TruePlusMinus) -> Self {
        NodeRef::TruePlusMinus(node)
    }
}
impl<'ast> From<&'ast TryStmt> for NodeRef<'ast> {
    fn from(node: &'ast TryStmt) -> Self {
        NodeRef::TryStmt(node)
    }
}
impl<'ast> From<&'ast UnaryExpr> for NodeRef<'ast> {
    fn from(node: &'ast UnaryExpr) -> Self {
        NodeRef::UnaryExpr(node)
    }
}
impl<'ast> From<&'ast UnaryOp> for NodeRef<'ast> {
    fn from(node: &'ast UnaryOp) -> Self {
        NodeRef::UnaryOp(node)
    }
}
impl<'ast> From<&'ast UpdateExpr> for NodeRef<'ast> {
    fn from(node: &'ast UpdateExpr) -> Self {
        NodeRef::UpdateExpr(node)
    }
}
impl<'ast> From<&'ast UpdateOp> for NodeRef<'ast> {
    fn from(node: &'ast UpdateOp) -> Self {
        NodeRef::UpdateOp(node)
    }
}
impl<'ast> From<&'ast UsingDecl> for NodeRef<'ast> {
    fn from(node: &'ast UsingDecl) -> Self {
        NodeRef::UsingDecl(node)
    }
}
impl<'ast> From<&'ast VarDecl> for NodeRef<'ast> {
    fn from(node: &'ast VarDecl) -> Self {
        NodeRef::VarDecl(node)
    }
}
impl<'ast> From<&'ast VarDeclKind> for NodeRef<'ast> {
    fn from(node: &'ast VarDeclKind) -> Self {
        NodeRef::VarDeclKind(node)
    }
}
impl<'ast> From<&'ast VarDeclOrExpr> for NodeRef<'ast> {
    fn from(node: &'ast VarDeclOrExpr) -> Self {
        NodeRef::VarDeclOrExpr(node)
    }
}
impl<'ast> From<&'ast VarDeclarator> for NodeRef<'ast> {
    fn from(node: &'ast VarDeclarator) -> Self {
        NodeRef::VarDeclarator(node)
    }
}
impl<'ast> From<&'ast WhileStmt> for NodeRef<'ast> {
    fn from(node: &'ast WhileStmt) -> Self {
        NodeRef::WhileStmt(node)
    }
}
impl<'ast> From<&'ast WithStmt> for NodeRef<'ast> {
    fn from(node: &'ast WithStmt) -> Self {
        NodeRef::WithStmt(node)
    }
}
impl<'ast> From<&'ast YieldExpr> for NodeRef<'ast> {
    fn from(node: &'ast YieldExpr) -> Self {
        NodeRef::YieldExpr(node)
    }
}
#[derive(Debug, Clone, Copy)]
pub enum NodeRef<'ast> {
    ArrayLit(&'ast ArrayLit),
    ArrayPat(&'ast ArrayPat),
    ArrowExpr(&'ast ArrowExpr),
    AssignExpr(&'ast AssignExpr),
    AssignOp(&'ast AssignOp),
    AssignPat(&'ast AssignPat),
    AssignPatProp(&'ast AssignPatProp),
    AssignProp(&'ast AssignProp),
    AssignTarget(&'ast AssignTarget),
    AssignTargetPat(&'ast AssignTargetPat),
    AutoAccessor(&'ast AutoAccessor),
    AwaitExpr(&'ast AwaitExpr),
    BigInt(&'ast BigInt),
    BinExpr(&'ast BinExpr),
    BinaryOp(&'ast BinaryOp),
    BindingIdent(&'ast BindingIdent),
    BlockStmt(&'ast BlockStmt),
    BlockStmtOrExpr(&'ast BlockStmtOrExpr),
    Bool(&'ast Bool),
    BreakStmt(&'ast BreakStmt),
    CallExpr(&'ast CallExpr),
    Callee(&'ast Callee),
    CatchClause(&'ast CatchClause),
    Class(&'ast Class),
    ClassDecl(&'ast ClassDecl),
    ClassExpr(&'ast ClassExpr),
    ClassMember(&'ast ClassMember),
    ClassMethod(&'ast ClassMethod),
    ClassProp(&'ast ClassProp),
    ComputedPropName(&'ast ComputedPropName),
    CondExpr(&'ast CondExpr),
    Constructor(&'ast Constructor),
    ContinueStmt(&'ast ContinueStmt),
    DebuggerStmt(&'ast DebuggerStmt),
    Decl(&'ast Decl),
    Decorator(&'ast Decorator),
    DefaultDecl(&'ast DefaultDecl),
    DoWhileStmt(&'ast DoWhileStmt),
    EmptyStmt(&'ast EmptyStmt),
    ExportAll(&'ast ExportAll),
    ExportDecl(&'ast ExportDecl),
    ExportDefaultDecl(&'ast ExportDefaultDecl),
    ExportDefaultExpr(&'ast ExportDefaultExpr),
    ExportDefaultSpecifier(&'ast ExportDefaultSpecifier),
    ExportNamedSpecifier(&'ast ExportNamedSpecifier),
    ExportNamespaceSpecifier(&'ast ExportNamespaceSpecifier),
    ExportSpecifier(&'ast ExportSpecifier),
    Expr(&'ast Expr),
    ExprOrSpread(&'ast ExprOrSpread),
    ExprStmt(&'ast ExprStmt),
    FnDecl(&'ast FnDecl),
    FnExpr(&'ast FnExpr),
    ForHead(&'ast ForHead),
    ForInStmt(&'ast ForInStmt),
    ForOfStmt(&'ast ForOfStmt),
    ForStmt(&'ast ForStmt),
    Function(&'ast Function),
    GetterProp(&'ast GetterProp),
    Ident(&'ast Ident),
    IdentName(&'ast IdentName),
    IfStmt(&'ast IfStmt),
    Import(&'ast Import),
    ImportDecl(&'ast ImportDecl),
    ImportDefaultSpecifier(&'ast ImportDefaultSpecifier),
    ImportNamedSpecifier(&'ast ImportNamedSpecifier),
    ImportPhase(&'ast ImportPhase),
    ImportSpecifier(&'ast ImportSpecifier),
    ImportStarAsSpecifier(&'ast ImportStarAsSpecifier),
    ImportWith(&'ast ImportWith),
    ImportWithItem(&'ast ImportWithItem),
    Invalid(&'ast Invalid),
    JSXAttr(&'ast JSXAttr),
    JSXAttrName(&'ast JSXAttrName),
    JSXAttrOrSpread(&'ast JSXAttrOrSpread),
    JSXAttrValue(&'ast JSXAttrValue),
    JSXClosingElement(&'ast JSXClosingElement),
    JSXClosingFragment(&'ast JSXClosingFragment),
    JSXElement(&'ast JSXElement),
    JSXElementChild(&'ast JSXElementChild),
    JSXElementName(&'ast JSXElementName),
    JSXEmptyExpr(&'ast JSXEmptyExpr),
    JSXExpr(&'ast JSXExpr),
    JSXExprContainer(&'ast JSXExprContainer),
    JSXFragment(&'ast JSXFragment),
    JSXMemberExpr(&'ast JSXMemberExpr),
    JSXNamespacedName(&'ast JSXNamespacedName),
    JSXObject(&'ast JSXObject),
    JSXOpeningElement(&'ast JSXOpeningElement),
    JSXOpeningFragment(&'ast JSXOpeningFragment),
    JSXSpreadChild(&'ast JSXSpreadChild),
    JSXText(&'ast JSXText),
    Key(&'ast Key),
    KeyValuePatProp(&'ast KeyValuePatProp),
    KeyValueProp(&'ast KeyValueProp),
    LabeledStmt(&'ast LabeledStmt),
    Lit(&'ast Lit),
    MemberExpr(&'ast MemberExpr),
    MemberProp(&'ast MemberProp),
    MetaPropExpr(&'ast MetaPropExpr),
    MetaPropKind(&'ast MetaPropKind),
    MethodKind(&'ast MethodKind),
    MethodProp(&'ast MethodProp),
    Module(&'ast Module),
    ModuleDecl(&'ast ModuleDecl),
    ModuleExportName(&'ast ModuleExportName),
    ModuleItem(&'ast ModuleItem),
    NamedExport(&'ast NamedExport),
    NewExpr(&'ast NewExpr),
    Null(&'ast Null),
    Number(&'ast Number),
    ObjectLit(&'ast ObjectLit),
    ObjectPat(&'ast ObjectPat),
    ObjectPatProp(&'ast ObjectPatProp),
    OptCall(&'ast OptCall),
    OptChainBase(&'ast OptChainBase),
    OptChainExpr(&'ast OptChainExpr),
    Param(&'ast Param),
    ParamOrTsParamProp(&'ast ParamOrTsParamProp),
    ParenExpr(&'ast ParenExpr),
    Pat(&'ast Pat),
    PrivateMethod(&'ast PrivateMethod),
    PrivateName(&'ast PrivateName),
    PrivateProp(&'ast PrivateProp),
    Program(&'ast Program),
    Prop(&'ast Prop),
    PropName(&'ast PropName),
    PropOrSpread(&'ast PropOrSpread),
    Regex(&'ast Regex),
    RestPat(&'ast RestPat),
    ReturnStmt(&'ast ReturnStmt),
    Script(&'ast Script),
    SeqExpr(&'ast SeqExpr),
    SetterProp(&'ast SetterProp),
    SimpleAssignTarget(&'ast SimpleAssignTarget),
    SpreadElement(&'ast SpreadElement),
    StaticBlock(&'ast StaticBlock),
    Stmt(&'ast Stmt),
    Str(&'ast Str),
    Super(&'ast Super),
    SuperProp(&'ast SuperProp),
    SuperPropExpr(&'ast SuperPropExpr),
    SwitchCase(&'ast SwitchCase),
    SwitchStmt(&'ast SwitchStmt),
    TaggedTpl(&'ast TaggedTpl),
    ThisExpr(&'ast ThisExpr),
    ThrowStmt(&'ast ThrowStmt),
    Tpl(&'ast Tpl),
    TplElement(&'ast TplElement),
    TruePlusMinus(&'ast TruePlusMinus),
    TryStmt(&'ast TryStmt),
    UnaryExpr(&'ast UnaryExpr),
    UnaryOp(&'ast UnaryOp),
    UpdateExpr(&'ast UpdateExpr),
    UpdateOp(&'ast UpdateOp),
    UsingDecl(&'ast UsingDecl),
    VarDecl(&'ast VarDecl),
    VarDeclKind(&'ast VarDeclKind),
    VarDeclOrExpr(&'ast VarDeclOrExpr),
    VarDeclarator(&'ast VarDeclarator),
    WhileStmt(&'ast WhileStmt),
    WithStmt(&'ast WithStmt),
    YieldExpr(&'ast YieldExpr),
}
impl<'ast> NodeRef<'ast> {
    #[doc = r" This is not a part of semver-stable API. It is experimental and subject to change."]
    #[allow(unreachable_patterns)]
    pub fn experimental_raw_children<'a>(&'a self) -> Box<dyn 'a + Iterator<Item = NodeRef<'ast>>> {
        match self {
            NodeRef::ArrayLit(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.elems.iter().flat_map(|item| {
                        item.iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ExprOrSpread(&item)))
                    }),
                );
                Box::new(iterator)
            }
            NodeRef::ArrayPat(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.elems.iter().flat_map(|item| {
                        item.iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Pat(&item)))
                    }),
                );
                Box::new(iterator)
            }
            NodeRef::ArrowExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.params
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Pat(&item))),
                    )
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::BlockStmtOrExpr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::AssignExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::AssignOp(&node.op)))
                    .chain(::std::iter::once(NodeRef::AssignTarget(&node.left)))
                    .chain({
                        let item = &*node.right;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::AssignOp(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::AssignPat(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.left;
                        ::std::iter::once(NodeRef::Pat(&item))
                    })
                    .chain({
                        let item = &*node.right;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::AssignPatProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::BindingIdent(&node.key)))
                    .chain(node.value.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::AssignProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.key)))
                    .chain({
                        let item = &*node.value;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::AssignTarget(node) => match node {
                AssignTarget::Simple(v0) => {
                    Box::new(::std::iter::once(NodeRef::SimpleAssignTarget(v0)))
                }
                AssignTarget::Pat(v0) => Box::new(::std::iter::once(NodeRef::AssignTargetPat(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::AssignTargetPat(node) => match node {
                AssignTargetPat::Array(v0) => Box::new(::std::iter::once(NodeRef::ArrayPat(v0))),
                AssignTargetPat::Object(v0) => Box::new(::std::iter::once(NodeRef::ObjectPat(v0))),
                AssignTargetPat::Invalid(v0) => Box::new(::std::iter::once(NodeRef::Invalid(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::AutoAccessor(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Key(&node.key)))
                    .chain(node.value.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }))
                    .chain(
                        node.decorators
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Decorator(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::AwaitExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.arg;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::BigInt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::BinExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::BinaryOp(&node.op)))
                    .chain({
                        let item = &*node.left;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.right;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::BinaryOp(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::BindingIdent(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.id)));
                Box::new(iterator)
            }
            NodeRef::BlockStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.stmts
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::Stmt(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::BlockStmtOrExpr(node) => match node {
                BlockStmtOrExpr::BlockStmt(v0) => {
                    Box::new(::std::iter::once(NodeRef::BlockStmt(v0)))
                }
                BlockStmtOrExpr::Expr(v0) => Box::new(::std::iter::once(NodeRef::Expr(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::Bool(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::BreakStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.label
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::Ident(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::CallExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Callee(&node.callee)))
                    .chain(
                        node.args
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ExprOrSpread(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::Callee(node) => match node {
                Callee::Super(v0) => Box::new(::std::iter::once(NodeRef::Super(v0))),
                Callee::Import(v0) => Box::new(::std::iter::once(NodeRef::Import(v0))),
                Callee::Expr(v0) => Box::new(::std::iter::once(NodeRef::Expr(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::CatchClause(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.param
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Pat(&item))),
                    )
                    .chain(::std::iter::once(NodeRef::BlockStmt(&node.body)));
                Box::new(iterator)
            }
            NodeRef::Class(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.decorators
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Decorator(&item))),
                    )
                    .chain(
                        node.body
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ClassMember(&item))),
                    )
                    .chain(node.super_class.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::ClassDecl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.ident)))
                    .chain({
                        let item = &*node.class;
                        ::std::iter::once(NodeRef::Class(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::ClassExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.ident
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Ident(&item))),
                    )
                    .chain({
                        let item = &*node.class;
                        ::std::iter::once(NodeRef::Class(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::ClassMember(node) => match node {
                ClassMember::Constructor(v0) => {
                    Box::new(::std::iter::once(NodeRef::Constructor(v0)))
                }
                ClassMember::Method(v0) => Box::new(::std::iter::once(NodeRef::ClassMethod(v0))),
                ClassMember::PrivateMethod(v0) => {
                    Box::new(::std::iter::once(NodeRef::PrivateMethod(v0)))
                }
                ClassMember::ClassProp(v0) => Box::new(::std::iter::once(NodeRef::ClassProp(v0))),
                ClassMember::PrivateProp(v0) => {
                    Box::new(::std::iter::once(NodeRef::PrivateProp(v0)))
                }
                ClassMember::Empty(v0) => Box::new(::std::iter::once(NodeRef::EmptyStmt(v0))),
                ClassMember::StaticBlock(v0) => {
                    Box::new(::std::iter::once(NodeRef::StaticBlock(v0)))
                }
                ClassMember::AutoAccessor(v0) => {
                    Box::new(::std::iter::once(NodeRef::AutoAccessor(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ClassMethod(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain({
                        let item = &*node.function;
                        ::std::iter::once(NodeRef::Function(&item))
                    })
                    .chain(::std::iter::once(NodeRef::MethodKind(&node.kind)));
                Box::new(iterator)
            }
            NodeRef::ClassProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain(node.value.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }))
                    .chain(
                        node.decorators
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Decorator(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::ComputedPropName(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::CondExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.test;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.cons;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.alt;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::Constructor(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain(
                        node.params
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ParamOrTsParamProp(&item))),
                    )
                    .chain(
                        node.body
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::BlockStmt(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::ContinueStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.label
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::Ident(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::DebuggerStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::Decl(node) => match node {
                Decl::Class(v0) => Box::new(::std::iter::once(NodeRef::ClassDecl(v0))),
                Decl::Fn(v0) => Box::new(::std::iter::once(NodeRef::FnDecl(v0))),
                Decl::Var(v0) => Box::new(::std::iter::once(NodeRef::VarDecl(v0))),
                Decl::Using(v0) => Box::new(::std::iter::once(NodeRef::UsingDecl(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::Decorator(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::DefaultDecl(node) => match node {
                DefaultDecl::Class(v0) => Box::new(::std::iter::once(NodeRef::ClassExpr(v0))),
                DefaultDecl::Fn(v0) => Box::new(::std::iter::once(NodeRef::FnExpr(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::DoWhileStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.test;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::EmptyStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::ExportAll(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.src;
                        ::std::iter::once(NodeRef::Str(&item))
                    })
                    .chain(node.with.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::ObjectLit(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::ExportDecl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Decl(&node.decl)));
                Box::new(iterator)
            }
            NodeRef::ExportDefaultDecl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::DefaultDecl(&node.decl)));
                Box::new(iterator)
            }
            NodeRef::ExportDefaultExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::ExportDefaultSpecifier(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.exported)));
                Box::new(iterator)
            }
            NodeRef::ExportNamedSpecifier(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::ModuleExportName(&node.orig)))
                    .chain(
                        node.exported
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ModuleExportName(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::ExportNamespaceSpecifier(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::ModuleExportName(&node.name)));
                Box::new(iterator)
            }
            NodeRef::ExportSpecifier(node) => match node {
                ExportSpecifier::Namespace(v0) => {
                    Box::new(::std::iter::once(NodeRef::ExportNamespaceSpecifier(v0)))
                }
                ExportSpecifier::Default(v0) => {
                    Box::new(::std::iter::once(NodeRef::ExportDefaultSpecifier(v0)))
                }
                ExportSpecifier::Named(v0) => {
                    Box::new(::std::iter::once(NodeRef::ExportNamedSpecifier(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::Expr(node) => match node {
                Expr::This(v0) => Box::new(::std::iter::once(NodeRef::ThisExpr(v0))),
                Expr::Array(v0) => Box::new(::std::iter::once(NodeRef::ArrayLit(v0))),
                Expr::Object(v0) => Box::new(::std::iter::once(NodeRef::ObjectLit(v0))),
                Expr::Fn(v0) => Box::new(::std::iter::once(NodeRef::FnExpr(v0))),
                Expr::Unary(v0) => Box::new(::std::iter::once(NodeRef::UnaryExpr(v0))),
                Expr::Update(v0) => Box::new(::std::iter::once(NodeRef::UpdateExpr(v0))),
                Expr::Bin(v0) => Box::new(::std::iter::once(NodeRef::BinExpr(v0))),
                Expr::Assign(v0) => Box::new(::std::iter::once(NodeRef::AssignExpr(v0))),
                Expr::Member(v0) => Box::new(::std::iter::once(NodeRef::MemberExpr(v0))),
                Expr::SuperProp(v0) => Box::new(::std::iter::once(NodeRef::SuperPropExpr(v0))),
                Expr::Cond(v0) => Box::new(::std::iter::once(NodeRef::CondExpr(v0))),
                Expr::Call(v0) => Box::new(::std::iter::once(NodeRef::CallExpr(v0))),
                Expr::New(v0) => Box::new(::std::iter::once(NodeRef::NewExpr(v0))),
                Expr::Seq(v0) => Box::new(::std::iter::once(NodeRef::SeqExpr(v0))),
                Expr::Ident(v0) => Box::new(::std::iter::once(NodeRef::Ident(v0))),
                Expr::Lit(v0) => Box::new(::std::iter::once(NodeRef::Lit(v0))),
                Expr::Tpl(v0) => Box::new(::std::iter::once(NodeRef::Tpl(v0))),
                Expr::TaggedTpl(v0) => Box::new(::std::iter::once(NodeRef::TaggedTpl(v0))),
                Expr::Arrow(v0) => Box::new(::std::iter::once(NodeRef::ArrowExpr(v0))),
                Expr::Class(v0) => Box::new(::std::iter::once(NodeRef::ClassExpr(v0))),
                Expr::Yield(v0) => Box::new(::std::iter::once(NodeRef::YieldExpr(v0))),
                Expr::MetaProp(v0) => Box::new(::std::iter::once(NodeRef::MetaPropExpr(v0))),
                Expr::Await(v0) => Box::new(::std::iter::once(NodeRef::AwaitExpr(v0))),
                Expr::Paren(v0) => Box::new(::std::iter::once(NodeRef::ParenExpr(v0))),
                Expr::JSXMember(v0) => Box::new(::std::iter::once(NodeRef::JSXMemberExpr(v0))),
                Expr::JSXNamespacedName(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXNamespacedName(v0)))
                }
                Expr::JSXEmpty(v0) => Box::new(::std::iter::once(NodeRef::JSXEmptyExpr(v0))),
                Expr::JSXElement(v0) => Box::new(::std::iter::once(NodeRef::JSXElement(v0))),
                Expr::JSXFragment(v0) => Box::new(::std::iter::once(NodeRef::JSXFragment(v0))),
                Expr::PrivateName(v0) => Box::new(::std::iter::once(NodeRef::PrivateName(v0))),
                Expr::OptChain(v0) => Box::new(::std::iter::once(NodeRef::OptChainExpr(v0))),
                Expr::Invalid(v0) => Box::new(::std::iter::once(NodeRef::Invalid(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ExprOrSpread(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::ExprStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::FnDecl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.ident)))
                    .chain({
                        let item = &*node.function;
                        ::std::iter::once(NodeRef::Function(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::FnExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.ident
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Ident(&item))),
                    )
                    .chain({
                        let item = &*node.function;
                        ::std::iter::once(NodeRef::Function(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::ForHead(node) => match node {
                ForHead::VarDecl(v0) => Box::new(::std::iter::once(NodeRef::VarDecl(v0))),
                ForHead::UsingDecl(v0) => Box::new(::std::iter::once(NodeRef::UsingDecl(v0))),
                ForHead::Pat(v0) => Box::new(::std::iter::once(NodeRef::Pat(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ForInStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::ForHead(&node.left)))
                    .chain({
                        let item = &*node.right;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::ForOfStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::ForHead(&node.left)))
                    .chain({
                        let item = &*node.right;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::ForStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.init
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::VarDeclOrExpr(&item))),
                    )
                    .chain(node.test.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }))
                    .chain(node.update.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }))
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::Function(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.params
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Param(&item))),
                    )
                    .chain(
                        node.decorators
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Decorator(&item))),
                    )
                    .chain(
                        node.body
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::BlockStmt(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::GetterProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain(
                        node.body
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::BlockStmt(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::Ident(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::IdentName(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::IfStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.test;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.cons;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    })
                    .chain(node.alt.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::Import(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::ImportPhase(&node.phase)));
                Box::new(iterator)
            }
            NodeRef::ImportDecl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.specifiers
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ImportSpecifier(&item))),
                    )
                    .chain({
                        let item = &*node.src;
                        ::std::iter::once(NodeRef::Str(&item))
                    })
                    .chain(node.with.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::ObjectLit(&item))
                    }))
                    .chain(::std::iter::once(NodeRef::ImportPhase(&node.phase)));
                Box::new(iterator)
            }
            NodeRef::ImportDefaultSpecifier(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.local)));
                Box::new(iterator)
            }
            NodeRef::ImportNamedSpecifier(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.local)))
                    .chain(
                        node.imported
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ModuleExportName(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::ImportPhase(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ImportSpecifier(node) => match node {
                ImportSpecifier::Named(v0) => {
                    Box::new(::std::iter::once(NodeRef::ImportNamedSpecifier(v0)))
                }
                ImportSpecifier::Default(v0) => {
                    Box::new(::std::iter::once(NodeRef::ImportDefaultSpecifier(v0)))
                }
                ImportSpecifier::Namespace(v0) => {
                    Box::new(::std::iter::once(NodeRef::ImportStarAsSpecifier(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ImportStarAsSpecifier(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.local)));
                Box::new(iterator)
            }
            NodeRef::ImportWith(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.values
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::ImportWithItem(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::ImportWithItem(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::IdentName(&node.key)))
                    .chain(::std::iter::once(NodeRef::Str(&node.value)));
                Box::new(iterator)
            }
            NodeRef::Invalid(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::JSXAttr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::JSXAttrName(&node.name)))
                    .chain(
                        node.value
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::JSXAttrValue(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::JSXAttrName(node) => match node {
                JSXAttrName::Ident(v0) => Box::new(::std::iter::once(NodeRef::IdentName(v0))),
                JSXAttrName::JSXNamespacedName(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXNamespacedName(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::JSXAttrOrSpread(node) => match node {
                JSXAttrOrSpread::JSXAttr(v0) => Box::new(::std::iter::once(NodeRef::JSXAttr(v0))),
                JSXAttrOrSpread::SpreadElement(v0) => {
                    Box::new(::std::iter::once(NodeRef::SpreadElement(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::JSXAttrValue(node) => match node {
                JSXAttrValue::Lit(v0) => Box::new(::std::iter::once(NodeRef::Lit(v0))),
                JSXAttrValue::JSXExprContainer(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXExprContainer(v0)))
                }
                JSXAttrValue::JSXElement(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXElement(v0)))
                }
                JSXAttrValue::JSXFragment(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXFragment(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::JSXClosingElement(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::JSXElementName(&node.name)));
                Box::new(iterator)
            }
            NodeRef::JSXClosingFragment(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::JSXElement(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::JSXOpeningElement(&node.opening)))
                    .chain(
                        node.children
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::JSXElementChild(&item))),
                    )
                    .chain(
                        node.closing
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::JSXClosingElement(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::JSXElementChild(node) => match node {
                JSXElementChild::JSXText(v0) => Box::new(::std::iter::once(NodeRef::JSXText(v0))),
                JSXElementChild::JSXExprContainer(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXExprContainer(v0)))
                }
                JSXElementChild::JSXSpreadChild(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXSpreadChild(v0)))
                }
                JSXElementChild::JSXElement(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXElement(v0)))
                }
                JSXElementChild::JSXFragment(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXFragment(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::JSXElementName(node) => match node {
                JSXElementName::Ident(v0) => Box::new(::std::iter::once(NodeRef::Ident(v0))),
                JSXElementName::JSXMemberExpr(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXMemberExpr(v0)))
                }
                JSXElementName::JSXNamespacedName(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXNamespacedName(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::JSXEmptyExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::JSXExpr(node) => match node {
                JSXExpr::JSXEmptyExpr(v0) => Box::new(::std::iter::once(NodeRef::JSXEmptyExpr(v0))),
                JSXExpr::Expr(v0) => Box::new(::std::iter::once(NodeRef::Expr(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::JSXExprContainer(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::JSXExpr(&node.expr)));
                Box::new(iterator)
            }
            NodeRef::JSXFragment(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::JSXOpeningFragment(
                        &node.opening,
                    )))
                    .chain(
                        node.children
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::JSXElementChild(&item))),
                    )
                    .chain(::std::iter::once(NodeRef::JSXClosingFragment(
                        &node.closing,
                    )));
                Box::new(iterator)
            }
            NodeRef::JSXMemberExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::JSXObject(&node.obj)))
                    .chain(::std::iter::once(NodeRef::IdentName(&node.prop)));
                Box::new(iterator)
            }
            NodeRef::JSXNamespacedName(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::IdentName(&node.ns)))
                    .chain(::std::iter::once(NodeRef::IdentName(&node.name)));
                Box::new(iterator)
            }
            NodeRef::JSXObject(node) => match node {
                JSXObject::JSXMemberExpr(v0) => {
                    Box::new(::std::iter::once(NodeRef::JSXMemberExpr(v0)))
                }
                JSXObject::Ident(v0) => Box::new(::std::iter::once(NodeRef::Ident(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::JSXOpeningElement(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::JSXElementName(&node.name)))
                    .chain(
                        node.attrs
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::JSXAttrOrSpread(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::JSXOpeningFragment(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::JSXSpreadChild(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::JSXText(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::Key(node) => match node {
                Key::Private(v0) => Box::new(::std::iter::once(NodeRef::PrivateName(v0))),
                Key::Public(v0) => Box::new(::std::iter::once(NodeRef::PropName(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::KeyValuePatProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain({
                        let item = &*node.value;
                        ::std::iter::once(NodeRef::Pat(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::KeyValueProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain({
                        let item = &*node.value;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::LabeledStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Ident(&node.label)))
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::Lit(node) => match node {
                Lit::Str(v0) => Box::new(::std::iter::once(NodeRef::Str(v0))),
                Lit::Bool(v0) => Box::new(::std::iter::once(NodeRef::Bool(v0))),
                Lit::Null(v0) => Box::new(::std::iter::once(NodeRef::Null(v0))),
                Lit::Num(v0) => Box::new(::std::iter::once(NodeRef::Number(v0))),
                Lit::BigInt(v0) => Box::new(::std::iter::once(NodeRef::BigInt(v0))),
                Lit::Regex(v0) => Box::new(::std::iter::once(NodeRef::Regex(v0))),
                Lit::JSXText(v0) => Box::new(::std::iter::once(NodeRef::JSXText(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::MemberExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.obj;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain(::std::iter::once(NodeRef::MemberProp(&node.prop)));
                Box::new(iterator)
            }
            NodeRef::MemberProp(node) => match node {
                MemberProp::Ident(v0) => Box::new(::std::iter::once(NodeRef::IdentName(v0))),
                MemberProp::PrivateName(v0) => {
                    Box::new(::std::iter::once(NodeRef::PrivateName(v0)))
                }
                MemberProp::Computed(v0) => {
                    Box::new(::std::iter::once(NodeRef::ComputedPropName(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::MetaPropExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::MetaPropKind(&node.kind)));
                Box::new(iterator)
            }
            NodeRef::MetaPropKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::MethodKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::MethodProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain({
                        let item = &*node.function;
                        ::std::iter::once(NodeRef::Function(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::Module(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.body
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::ModuleItem(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::ModuleDecl(node) => match node {
                ModuleDecl::Import(v0) => Box::new(::std::iter::once(NodeRef::ImportDecl(v0))),
                ModuleDecl::ExportDecl(v0) => Box::new(::std::iter::once(NodeRef::ExportDecl(v0))),
                ModuleDecl::ExportNamed(v0) => {
                    Box::new(::std::iter::once(NodeRef::NamedExport(v0)))
                }
                ModuleDecl::ExportDefaultDecl(v0) => {
                    Box::new(::std::iter::once(NodeRef::ExportDefaultDecl(v0)))
                }
                ModuleDecl::ExportDefaultExpr(v0) => {
                    Box::new(::std::iter::once(NodeRef::ExportDefaultExpr(v0)))
                }
                ModuleDecl::ExportAll(v0) => Box::new(::std::iter::once(NodeRef::ExportAll(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ModuleExportName(node) => match node {
                ModuleExportName::Ident(v0) => Box::new(::std::iter::once(NodeRef::Ident(v0))),
                ModuleExportName::Str(v0) => Box::new(::std::iter::once(NodeRef::Str(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ModuleItem(node) => match node {
                ModuleItem::ModuleDecl(v0) => Box::new(::std::iter::once(NodeRef::ModuleDecl(v0))),
                ModuleItem::Stmt(v0) => Box::new(::std::iter::once(NodeRef::Stmt(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::NamedExport(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.specifiers
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ExportSpecifier(&item))),
                    )
                    .chain(node.src.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Str(&item))
                    }))
                    .chain(node.with.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::ObjectLit(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::NewExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.callee;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain(node.args.iter().flat_map(|item| {
                        item.iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ExprOrSpread(&item)))
                    }));
                Box::new(iterator)
            }
            NodeRef::Null(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::Number(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::ObjectLit(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.props
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::PropOrSpread(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::ObjectPat(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.props
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::ObjectPatProp(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::ObjectPatProp(node) => match node {
                ObjectPatProp::KeyValue(v0) => {
                    Box::new(::std::iter::once(NodeRef::KeyValuePatProp(v0)))
                }
                ObjectPatProp::Assign(v0) => {
                    Box::new(::std::iter::once(NodeRef::AssignPatProp(v0)))
                }
                ObjectPatProp::Rest(v0) => Box::new(::std::iter::once(NodeRef::RestPat(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::OptCall(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.callee;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain(
                        node.args
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::ExprOrSpread(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::OptChainBase(node) => match node {
                OptChainBase::Member(v0) => Box::new(::std::iter::once(NodeRef::MemberExpr(v0))),
                OptChainBase::Call(v0) => Box::new(::std::iter::once(NodeRef::OptCall(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::OptChainExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.base;
                    ::std::iter::once(NodeRef::OptChainBase(&item))
                });
                Box::new(iterator)
            }
            NodeRef::Param(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.decorators
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Decorator(&item))),
                    )
                    .chain(::std::iter::once(NodeRef::Pat(&node.pat)));
                Box::new(iterator)
            }
            NodeRef::ParamOrTsParamProp(node) => match node {
                ParamOrTsParamProp::Param(v0) => Box::new(::std::iter::once(NodeRef::Param(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ParenExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::Pat(node) => match node {
                Pat::Ident(v0) => Box::new(::std::iter::once(NodeRef::BindingIdent(v0))),
                Pat::Array(v0) => Box::new(::std::iter::once(NodeRef::ArrayPat(v0))),
                Pat::Rest(v0) => Box::new(::std::iter::once(NodeRef::RestPat(v0))),
                Pat::Object(v0) => Box::new(::std::iter::once(NodeRef::ObjectPat(v0))),
                Pat::Assign(v0) => Box::new(::std::iter::once(NodeRef::AssignPat(v0))),
                Pat::Invalid(v0) => Box::new(::std::iter::once(NodeRef::Invalid(v0))),
                Pat::Expr(v0) => Box::new(::std::iter::once(NodeRef::Expr(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::PrivateMethod(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PrivateName(&node.key)))
                    .chain({
                        let item = &*node.function;
                        ::std::iter::once(NodeRef::Function(&item))
                    })
                    .chain(::std::iter::once(NodeRef::MethodKind(&node.kind)));
                Box::new(iterator)
            }
            NodeRef::PrivateName(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::PrivateProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PrivateName(&node.key)))
                    .chain(node.value.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }))
                    .chain(
                        node.decorators
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Decorator(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::Program(node) => match node {
                Program::Module(v0) => Box::new(::std::iter::once(NodeRef::Module(v0))),
                Program::Script(v0) => Box::new(::std::iter::once(NodeRef::Script(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::Prop(node) => match node {
                Prop::Shorthand(v0) => Box::new(::std::iter::once(NodeRef::Ident(v0))),
                Prop::KeyValue(v0) => Box::new(::std::iter::once(NodeRef::KeyValueProp(v0))),
                Prop::Assign(v0) => Box::new(::std::iter::once(NodeRef::AssignProp(v0))),
                Prop::Getter(v0) => Box::new(::std::iter::once(NodeRef::GetterProp(v0))),
                Prop::Setter(v0) => Box::new(::std::iter::once(NodeRef::SetterProp(v0))),
                Prop::Method(v0) => Box::new(::std::iter::once(NodeRef::MethodProp(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::PropName(node) => match node {
                PropName::Ident(v0) => Box::new(::std::iter::once(NodeRef::IdentName(v0))),
                PropName::Str(v0) => Box::new(::std::iter::once(NodeRef::Str(v0))),
                PropName::Num(v0) => Box::new(::std::iter::once(NodeRef::Number(v0))),
                PropName::Computed(v0) => {
                    Box::new(::std::iter::once(NodeRef::ComputedPropName(v0)))
                }
                PropName::BigInt(v0) => Box::new(::std::iter::once(NodeRef::BigInt(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::PropOrSpread(node) => match node {
                PropOrSpread::Spread(v0) => Box::new(::std::iter::once(NodeRef::SpreadElement(v0))),
                PropOrSpread::Prop(v0) => Box::new(::std::iter::once(NodeRef::Prop(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::Regex(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::RestPat(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.arg;
                    ::std::iter::once(NodeRef::Pat(&item))
                });
                Box::new(iterator)
            }
            NodeRef::ReturnStmt(node) => {
                let iterator =
                    ::std::iter::empty::<NodeRef<'ast>>().chain(node.arg.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::Script(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.body
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::Stmt(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::SeqExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.exprs.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }),
                );
                Box::new(iterator)
            }
            NodeRef::SetterProp(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::PropName(&node.key)))
                    .chain(
                        node.this_param
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Pat(&item))),
                    )
                    .chain({
                        let item = &*node.param;
                        ::std::iter::once(NodeRef::Pat(&item))
                    })
                    .chain(
                        node.body
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::BlockStmt(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::SimpleAssignTarget(node) => match node {
                SimpleAssignTarget::Ident(v0) => {
                    Box::new(::std::iter::once(NodeRef::BindingIdent(v0)))
                }
                SimpleAssignTarget::Member(v0) => {
                    Box::new(::std::iter::once(NodeRef::MemberExpr(v0)))
                }
                SimpleAssignTarget::SuperProp(v0) => {
                    Box::new(::std::iter::once(NodeRef::SuperPropExpr(v0)))
                }
                SimpleAssignTarget::Paren(v0) => {
                    Box::new(::std::iter::once(NodeRef::ParenExpr(v0)))
                }
                SimpleAssignTarget::OptChain(v0) => {
                    Box::new(::std::iter::once(NodeRef::OptChainExpr(v0)))
                }
                SimpleAssignTarget::Invalid(v0) => {
                    Box::new(::std::iter::once(NodeRef::Invalid(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::SpreadElement(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.expr;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::StaticBlock(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::BlockStmt(&node.body)));
                Box::new(iterator)
            }
            NodeRef::Stmt(node) => match node {
                Stmt::Block(v0) => Box::new(::std::iter::once(NodeRef::BlockStmt(v0))),
                Stmt::Empty(v0) => Box::new(::std::iter::once(NodeRef::EmptyStmt(v0))),
                Stmt::Debugger(v0) => Box::new(::std::iter::once(NodeRef::DebuggerStmt(v0))),
                Stmt::With(v0) => Box::new(::std::iter::once(NodeRef::WithStmt(v0))),
                Stmt::Return(v0) => Box::new(::std::iter::once(NodeRef::ReturnStmt(v0))),
                Stmt::Labeled(v0) => Box::new(::std::iter::once(NodeRef::LabeledStmt(v0))),
                Stmt::Break(v0) => Box::new(::std::iter::once(NodeRef::BreakStmt(v0))),
                Stmt::Continue(v0) => Box::new(::std::iter::once(NodeRef::ContinueStmt(v0))),
                Stmt::If(v0) => Box::new(::std::iter::once(NodeRef::IfStmt(v0))),
                Stmt::Switch(v0) => Box::new(::std::iter::once(NodeRef::SwitchStmt(v0))),
                Stmt::Throw(v0) => Box::new(::std::iter::once(NodeRef::ThrowStmt(v0))),
                Stmt::Try(v0) => Box::new(::std::iter::once(NodeRef::TryStmt(v0))),
                Stmt::While(v0) => Box::new(::std::iter::once(NodeRef::WhileStmt(v0))),
                Stmt::DoWhile(v0) => Box::new(::std::iter::once(NodeRef::DoWhileStmt(v0))),
                Stmt::For(v0) => Box::new(::std::iter::once(NodeRef::ForStmt(v0))),
                Stmt::ForIn(v0) => Box::new(::std::iter::once(NodeRef::ForInStmt(v0))),
                Stmt::ForOf(v0) => Box::new(::std::iter::once(NodeRef::ForOfStmt(v0))),
                Stmt::Decl(v0) => Box::new(::std::iter::once(NodeRef::Decl(v0))),
                Stmt::Expr(v0) => Box::new(::std::iter::once(NodeRef::ExprStmt(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::Str(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::Super(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::SuperProp(node) => match node {
                SuperProp::Ident(v0) => Box::new(::std::iter::once(NodeRef::IdentName(v0))),
                SuperProp::Computed(v0) => {
                    Box::new(::std::iter::once(NodeRef::ComputedPropName(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::SuperPropExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Super(&node.obj)))
                    .chain(::std::iter::once(NodeRef::SuperProp(&node.prop)));
                Box::new(iterator)
            }
            NodeRef::SwitchCase(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(node.test.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }))
                    .chain(
                        node.cons
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Stmt(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::SwitchStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.discriminant;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain(
                        node.cases
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::SwitchCase(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::TaggedTpl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.tag;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.tpl;
                        ::std::iter::once(NodeRef::Tpl(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::ThisExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::ThrowStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain({
                    let item = &*node.arg;
                    ::std::iter::once(NodeRef::Expr(&item))
                });
                Box::new(iterator)
            }
            NodeRef::Tpl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(node.exprs.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }))
                    .chain(
                        node.quasis
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::TplElement(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::TplElement(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::TruePlusMinus(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::TryStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::BlockStmt(&node.block)))
                    .chain(
                        node.handler
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::CatchClause(&item))),
                    )
                    .chain(
                        node.finalizer
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::BlockStmt(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::UnaryExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::UnaryOp(&node.op)))
                    .chain({
                        let item = &*node.arg;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::UnaryOp(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::UpdateExpr(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::UpdateOp(&node.op)))
                    .chain({
                        let item = &*node.arg;
                        ::std::iter::once(NodeRef::Expr(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::UpdateOp(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::UsingDecl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.decls
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::VarDeclarator(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::VarDecl(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::VarDeclKind(&node.kind)))
                    .chain(
                        node.decls
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::VarDeclarator(&item))),
                    );
                Box::new(iterator)
            }
            NodeRef::VarDeclKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::VarDeclOrExpr(node) => match node {
                VarDeclOrExpr::VarDecl(v0) => Box::new(::std::iter::once(NodeRef::VarDecl(v0))),
                VarDeclOrExpr::Expr(v0) => Box::new(::std::iter::once(NodeRef::Expr(v0))),
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::VarDeclarator(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Pat(&node.name)))
                    .chain(node.init.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::WhileStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.test;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::WithStmt(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain({
                        let item = &*node.obj;
                        ::std::iter::once(NodeRef::Expr(&item))
                    })
                    .chain({
                        let item = &*node.body;
                        ::std::iter::once(NodeRef::Stmt(&item))
                    });
                Box::new(iterator)
            }
            NodeRef::YieldExpr(node) => {
                let iterator =
                    ::std::iter::empty::<NodeRef<'ast>>().chain(node.arg.iter().flat_map(|item| {
                        let item = &*item;
                        ::std::iter::once(NodeRef::Expr(&item))
                    }));
                Box::new(iterator)
            }
        }
    }
}
impl<'ast> NodeRef<'ast> {
    #[doc = r" Visit all nodes in self in preorder."]
    #[doc = r""]
    #[doc = r" This is not a part of semver-stable API. It is"]
    #[doc = r" experimental and subject to change."]
    pub fn experimental_traverse(&'ast self) -> Box<dyn 'ast + Iterator<Item = NodeRef<'ast>>> {
        let mut queue = std::collections::VecDeque::<NodeRef<'ast>>::new();
        queue.push_back(*self);
        Box::new(std::iter::from_fn(move || {
            let node: NodeRef<'ast> = queue.pop_front()?;
            {
                let children = node.experimental_raw_children();
                queue.extend(children);
            }
            Some(node)
        }))
    }
}
#[cfg(any(docsrs, feature = "path"))]
pub use self::fields::{AstParentKind, AstParentNodeRef};
