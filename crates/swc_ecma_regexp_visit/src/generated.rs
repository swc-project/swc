#![doc = r" This file is generated by `tools/generate-code`. DO NOT MODIFY."]
#![allow(unused_variables)]
#![allow(clippy::all)]
pub use ::swc_visit::All;
use swc_ecma_regexp_ast::*;
#[doc = r" A visitor trait for traversing the AST."]
pub trait Visit {
    #[doc = "Visit a node of type `Alternative`.\n\nBy default, this method calls \
             [`Alternative::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_alternative(&mut self, node: &Alternative) {
        <Alternative as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Alternative >`.\n\nBy default, this method calls [`Vec < \
             Alternative >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_alternatives(&mut self, node: &[Alternative]) {
        <[Alternative] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        <swc_atoms::Atom as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BoundaryAssertion`.\n\nBy default, this method calls \
             [`BoundaryAssertion::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_boundary_assertion(&mut self, node: &BoundaryAssertion) {
        <BoundaryAssertion as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BoundaryAssertionKind`.\n\nBy default, this method calls \
             [`BoundaryAssertionKind::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_boundary_assertion_kind(&mut self, node: &BoundaryAssertionKind) {
        <BoundaryAssertionKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CapturingGroup`.\n\nBy default, this method calls \
             [`CapturingGroup::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_capturing_group(&mut self, node: &CapturingGroup) {
        <CapturingGroup as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Character`.\n\nBy default, this method calls \
             [`Character::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_character(&mut self, node: &Character) {
        <Character as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClass`.\n\nBy default, this method calls \
             [`CharacterClass::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_character_class(&mut self, node: &CharacterClass) {
        <CharacterClass as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassContents`.\n\nBy default, this method calls \
             [`CharacterClassContents::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_character_class_contents(&mut self, node: &CharacterClassContents) {
        <CharacterClassContents as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassContentsKind`.\n\nBy default, this method calls \
             [`CharacterClassContentsKind::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_character_class_contents_kind(&mut self, node: &CharacterClassContentsKind) {
        <CharacterClassContentsKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < CharacterClassContents >`.\n\nBy default, this method \
             calls [`Vec < CharacterClassContents >::visit_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_character_class_contentss(&mut self, node: &[CharacterClassContents]) {
        <[CharacterClassContents] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassEscape`.\n\nBy default, this method calls \
             [`CharacterClassEscape::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_character_class_escape(&mut self, node: &CharacterClassEscape) {
        <CharacterClassEscape as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassEscapeKind`.\n\nBy default, this method calls \
             [`CharacterClassEscapeKind::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_character_class_escape_kind(&mut self, node: &CharacterClassEscapeKind) {
        <CharacterClassEscapeKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassRange`.\n\nBy default, this method calls \
             [`CharacterClassRange::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_character_class_range(&mut self, node: &CharacterClassRange) {
        <CharacterClassRange as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterKind`.\n\nBy default, this method calls \
             [`CharacterKind::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_character_kind(&mut self, node: &CharacterKind) {
        <CharacterKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Character >`.\n\nBy default, this method calls [`Vec < \
             Character >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_characters(&mut self, node: &[Character]) {
        <[Character] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassString`.\n\nBy default, this method calls \
             [`ClassString::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_string(&mut self, node: &ClassString) {
        <ClassString as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassStringDisjunction`.\n\nBy default, this method calls \
             [`ClassStringDisjunction::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_class_string_disjunction(&mut self, node: &ClassStringDisjunction) {
        <ClassStringDisjunction as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassString >`.\n\nBy default, this method calls [`Vec < \
             ClassString >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_class_strings(&mut self, node: &[ClassString]) {
        <[ClassString] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Disjunction`.\n\nBy default, this method calls \
             [`Disjunction::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_disjunction(&mut self, node: &Disjunction) {
        <Disjunction as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Dot`.\n\nBy default, this method calls \
             [`Dot::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_dot(&mut self, node: &Dot) {
        <Dot as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `IgnoreGroup`.\n\nBy default, this method calls \
             [`IgnoreGroup::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_ignore_group(&mut self, node: &IgnoreGroup) {
        <IgnoreGroup as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `IndexedReference`.\n\nBy default, this method calls \
             [`IndexedReference::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_indexed_reference(&mut self, node: &IndexedReference) {
        <IndexedReference as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `LookAroundAssertion`.\n\nBy default, this method calls \
             [`LookAroundAssertion::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_look_around_assertion(&mut self, node: &LookAroundAssertion) {
        <LookAroundAssertion as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `LookAroundAssertionKind`.\n\nBy default, this method calls \
             [`LookAroundAssertionKind::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_look_around_assertion_kind(&mut self, node: &LookAroundAssertionKind) {
        <LookAroundAssertionKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Modifier`.\n\nBy default, this method calls \
             [`Modifier::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_modifier(&mut self, node: &Modifier) {
        <Modifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Modifiers`.\n\nBy default, this method calls \
             [`Modifiers::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_modifiers(&mut self, node: &Modifiers) {
        <Modifiers as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedReference`.\n\nBy default, this method calls \
             [`NamedReference::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_named_reference(&mut self, node: &NamedReference) {
        <NamedReference as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        <Option<swc_atoms::Atom> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Modifiers >`.\n\nBy default, this method calls \
             [`Option < Modifiers >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_opt_modifiers(&mut self, node: &Option<Modifiers>) {
        <Option<Modifiers> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pattern`.\n\nBy default, this method calls \
             [`Pattern::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_pattern(&mut self, node: &Pattern) {
        <Pattern as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Quantifier`.\n\nBy default, this method calls \
             [`Quantifier::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_quantifier(&mut self, node: &Quantifier) {
        <Quantifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        <swc_common::Span as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Term`.\n\nBy default, this method calls \
             [`Term::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_term(&mut self, node: &Term) {
        <Term as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Term >`.\n\nBy default, this method calls [`Vec < Term \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_terms(&mut self, node: &[Term]) {
        <[Term] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnicodePropertyEscape`.\n\nBy default, this method calls \
             [`UnicodePropertyEscape::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_unicode_property_escape(&mut self, node: &UnicodePropertyEscape) {
        <UnicodePropertyEscape as VisitWith<Self>>::visit_children_with(node, self)
    }
}
impl<V> Visit for &mut V
where
    V: ?Sized + Visit,
{
    #[inline]
    fn visit_alternative(&mut self, node: &Alternative) {
        <V as Visit>::visit_alternative(&mut **self, node)
    }

    #[inline]
    fn visit_alternatives(&mut self, node: &[Alternative]) {
        <V as Visit>::visit_alternatives(&mut **self, node)
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        <V as Visit>::visit_atom(&mut **self, node)
    }

    #[inline]
    fn visit_boundary_assertion(&mut self, node: &BoundaryAssertion) {
        <V as Visit>::visit_boundary_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_boundary_assertion_kind(&mut self, node: &BoundaryAssertionKind) {
        <V as Visit>::visit_boundary_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_capturing_group(&mut self, node: &CapturingGroup) {
        <V as Visit>::visit_capturing_group(&mut **self, node)
    }

    #[inline]
    fn visit_character(&mut self, node: &Character) {
        <V as Visit>::visit_character(&mut **self, node)
    }

    #[inline]
    fn visit_character_class(&mut self, node: &CharacterClass) {
        <V as Visit>::visit_character_class(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_contents(&mut self, node: &CharacterClassContents) {
        <V as Visit>::visit_character_class_contents(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_contents_kind(&mut self, node: &CharacterClassContentsKind) {
        <V as Visit>::visit_character_class_contents_kind(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_contentss(&mut self, node: &[CharacterClassContents]) {
        <V as Visit>::visit_character_class_contentss(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_escape(&mut self, node: &CharacterClassEscape) {
        <V as Visit>::visit_character_class_escape(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_escape_kind(&mut self, node: &CharacterClassEscapeKind) {
        <V as Visit>::visit_character_class_escape_kind(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_range(&mut self, node: &CharacterClassRange) {
        <V as Visit>::visit_character_class_range(&mut **self, node)
    }

    #[inline]
    fn visit_character_kind(&mut self, node: &CharacterKind) {
        <V as Visit>::visit_character_kind(&mut **self, node)
    }

    #[inline]
    fn visit_characters(&mut self, node: &[Character]) {
        <V as Visit>::visit_characters(&mut **self, node)
    }

    #[inline]
    fn visit_class_string(&mut self, node: &ClassString) {
        <V as Visit>::visit_class_string(&mut **self, node)
    }

    #[inline]
    fn visit_class_string_disjunction(&mut self, node: &ClassStringDisjunction) {
        <V as Visit>::visit_class_string_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_class_strings(&mut self, node: &[ClassString]) {
        <V as Visit>::visit_class_strings(&mut **self, node)
    }

    #[inline]
    fn visit_disjunction(&mut self, node: &Disjunction) {
        <V as Visit>::visit_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_dot(&mut self, node: &Dot) {
        <V as Visit>::visit_dot(&mut **self, node)
    }

    #[inline]
    fn visit_ignore_group(&mut self, node: &IgnoreGroup) {
        <V as Visit>::visit_ignore_group(&mut **self, node)
    }

    #[inline]
    fn visit_indexed_reference(&mut self, node: &IndexedReference) {
        <V as Visit>::visit_indexed_reference(&mut **self, node)
    }

    #[inline]
    fn visit_look_around_assertion(&mut self, node: &LookAroundAssertion) {
        <V as Visit>::visit_look_around_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_look_around_assertion_kind(&mut self, node: &LookAroundAssertionKind) {
        <V as Visit>::visit_look_around_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_modifier(&mut self, node: &Modifier) {
        <V as Visit>::visit_modifier(&mut **self, node)
    }

    #[inline]
    fn visit_modifiers(&mut self, node: &Modifiers) {
        <V as Visit>::visit_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_named_reference(&mut self, node: &NamedReference) {
        <V as Visit>::visit_named_reference(&mut **self, node)
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        <V as Visit>::visit_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_opt_modifiers(&mut self, node: &Option<Modifiers>) {
        <V as Visit>::visit_opt_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_pattern(&mut self, node: &Pattern) {
        <V as Visit>::visit_pattern(&mut **self, node)
    }

    #[inline]
    fn visit_quantifier(&mut self, node: &Quantifier) {
        <V as Visit>::visit_quantifier(&mut **self, node)
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        <V as Visit>::visit_span(&mut **self, node)
    }

    #[inline]
    fn visit_term(&mut self, node: &Term) {
        <V as Visit>::visit_term(&mut **self, node)
    }

    #[inline]
    fn visit_terms(&mut self, node: &[Term]) {
        <V as Visit>::visit_terms(&mut **self, node)
    }

    #[inline]
    fn visit_unicode_property_escape(&mut self, node: &UnicodePropertyEscape) {
        <V as Visit>::visit_unicode_property_escape(&mut **self, node)
    }
}
impl<V> Visit for Box<V>
where
    V: ?Sized + Visit,
{
    #[inline]
    fn visit_alternative(&mut self, node: &Alternative) {
        <V as Visit>::visit_alternative(&mut **self, node)
    }

    #[inline]
    fn visit_alternatives(&mut self, node: &[Alternative]) {
        <V as Visit>::visit_alternatives(&mut **self, node)
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        <V as Visit>::visit_atom(&mut **self, node)
    }

    #[inline]
    fn visit_boundary_assertion(&mut self, node: &BoundaryAssertion) {
        <V as Visit>::visit_boundary_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_boundary_assertion_kind(&mut self, node: &BoundaryAssertionKind) {
        <V as Visit>::visit_boundary_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_capturing_group(&mut self, node: &CapturingGroup) {
        <V as Visit>::visit_capturing_group(&mut **self, node)
    }

    #[inline]
    fn visit_character(&mut self, node: &Character) {
        <V as Visit>::visit_character(&mut **self, node)
    }

    #[inline]
    fn visit_character_class(&mut self, node: &CharacterClass) {
        <V as Visit>::visit_character_class(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_contents(&mut self, node: &CharacterClassContents) {
        <V as Visit>::visit_character_class_contents(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_contents_kind(&mut self, node: &CharacterClassContentsKind) {
        <V as Visit>::visit_character_class_contents_kind(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_contentss(&mut self, node: &[CharacterClassContents]) {
        <V as Visit>::visit_character_class_contentss(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_escape(&mut self, node: &CharacterClassEscape) {
        <V as Visit>::visit_character_class_escape(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_escape_kind(&mut self, node: &CharacterClassEscapeKind) {
        <V as Visit>::visit_character_class_escape_kind(&mut **self, node)
    }

    #[inline]
    fn visit_character_class_range(&mut self, node: &CharacterClassRange) {
        <V as Visit>::visit_character_class_range(&mut **self, node)
    }

    #[inline]
    fn visit_character_kind(&mut self, node: &CharacterKind) {
        <V as Visit>::visit_character_kind(&mut **self, node)
    }

    #[inline]
    fn visit_characters(&mut self, node: &[Character]) {
        <V as Visit>::visit_characters(&mut **self, node)
    }

    #[inline]
    fn visit_class_string(&mut self, node: &ClassString) {
        <V as Visit>::visit_class_string(&mut **self, node)
    }

    #[inline]
    fn visit_class_string_disjunction(&mut self, node: &ClassStringDisjunction) {
        <V as Visit>::visit_class_string_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_class_strings(&mut self, node: &[ClassString]) {
        <V as Visit>::visit_class_strings(&mut **self, node)
    }

    #[inline]
    fn visit_disjunction(&mut self, node: &Disjunction) {
        <V as Visit>::visit_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_dot(&mut self, node: &Dot) {
        <V as Visit>::visit_dot(&mut **self, node)
    }

    #[inline]
    fn visit_ignore_group(&mut self, node: &IgnoreGroup) {
        <V as Visit>::visit_ignore_group(&mut **self, node)
    }

    #[inline]
    fn visit_indexed_reference(&mut self, node: &IndexedReference) {
        <V as Visit>::visit_indexed_reference(&mut **self, node)
    }

    #[inline]
    fn visit_look_around_assertion(&mut self, node: &LookAroundAssertion) {
        <V as Visit>::visit_look_around_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_look_around_assertion_kind(&mut self, node: &LookAroundAssertionKind) {
        <V as Visit>::visit_look_around_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_modifier(&mut self, node: &Modifier) {
        <V as Visit>::visit_modifier(&mut **self, node)
    }

    #[inline]
    fn visit_modifiers(&mut self, node: &Modifiers) {
        <V as Visit>::visit_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_named_reference(&mut self, node: &NamedReference) {
        <V as Visit>::visit_named_reference(&mut **self, node)
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        <V as Visit>::visit_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_opt_modifiers(&mut self, node: &Option<Modifiers>) {
        <V as Visit>::visit_opt_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_pattern(&mut self, node: &Pattern) {
        <V as Visit>::visit_pattern(&mut **self, node)
    }

    #[inline]
    fn visit_quantifier(&mut self, node: &Quantifier) {
        <V as Visit>::visit_quantifier(&mut **self, node)
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        <V as Visit>::visit_span(&mut **self, node)
    }

    #[inline]
    fn visit_term(&mut self, node: &Term) {
        <V as Visit>::visit_term(&mut **self, node)
    }

    #[inline]
    fn visit_terms(&mut self, node: &[Term]) {
        <V as Visit>::visit_terms(&mut **self, node)
    }

    #[inline]
    fn visit_unicode_property_escape(&mut self, node: &UnicodePropertyEscape) {
        <V as Visit>::visit_unicode_property_escape(&mut **self, node)
    }
}
impl<A, B> Visit for ::swc_visit::Either<A, B>
where
    A: Visit,
    B: Visit,
{
    #[inline]
    fn visit_alternative(&mut self, node: &Alternative) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_alternative(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_alternative(visitor, node),
        }
    }

    #[inline]
    fn visit_alternatives(&mut self, node: &[Alternative]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_alternatives(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_alternatives(visitor, node),
        }
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_boundary_assertion(&mut self, node: &BoundaryAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_boundary_assertion(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_boundary_assertion(visitor, node),
        }
    }

    #[inline]
    fn visit_boundary_assertion_kind(&mut self, node: &BoundaryAssertionKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_boundary_assertion_kind(visitor, node),
            swc_visit::Either::Right(visitor) => {
                Visit::visit_boundary_assertion_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_capturing_group(&mut self, node: &CapturingGroup) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_capturing_group(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_capturing_group(visitor, node),
        }
    }

    #[inline]
    fn visit_character(&mut self, node: &Character) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_character(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_character(visitor, node),
        }
    }

    #[inline]
    fn visit_character_class(&mut self, node: &CharacterClass) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_character_class(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_character_class(visitor, node),
        }
    }

    #[inline]
    fn visit_character_class_contents(&mut self, node: &CharacterClassContents) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_character_class_contents(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_character_class_contents(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_character_class_contents_kind(&mut self, node: &CharacterClassContentsKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_character_class_contents_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_character_class_contents_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_character_class_contentss(&mut self, node: &[CharacterClassContents]) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_character_class_contentss(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_character_class_contentss(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_character_class_escape(&mut self, node: &CharacterClassEscape) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_character_class_escape(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_character_class_escape(visitor, node),
        }
    }

    #[inline]
    fn visit_character_class_escape_kind(&mut self, node: &CharacterClassEscapeKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_character_class_escape_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_character_class_escape_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_character_class_range(&mut self, node: &CharacterClassRange) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_character_class_range(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_character_class_range(visitor, node),
        }
    }

    #[inline]
    fn visit_character_kind(&mut self, node: &CharacterKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_character_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_character_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_characters(&mut self, node: &[Character]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_characters(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_characters(visitor, node),
        }
    }

    #[inline]
    fn visit_class_string(&mut self, node: &ClassString) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_string(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_string(visitor, node),
        }
    }

    #[inline]
    fn visit_class_string_disjunction(&mut self, node: &ClassStringDisjunction) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_class_string_disjunction(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_class_string_disjunction(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_class_strings(&mut self, node: &[ClassString]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_strings(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_strings(visitor, node),
        }
    }

    #[inline]
    fn visit_disjunction(&mut self, node: &Disjunction) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_disjunction(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_disjunction(visitor, node),
        }
    }

    #[inline]
    fn visit_dot(&mut self, node: &Dot) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_dot(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_dot(visitor, node),
        }
    }

    #[inline]
    fn visit_ignore_group(&mut self, node: &IgnoreGroup) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ignore_group(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ignore_group(visitor, node),
        }
    }

    #[inline]
    fn visit_indexed_reference(&mut self, node: &IndexedReference) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_indexed_reference(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_indexed_reference(visitor, node),
        }
    }

    #[inline]
    fn visit_look_around_assertion(&mut self, node: &LookAroundAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_look_around_assertion(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_look_around_assertion(visitor, node),
        }
    }

    #[inline]
    fn visit_look_around_assertion_kind(&mut self, node: &LookAroundAssertionKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_look_around_assertion_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_look_around_assertion_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_modifier(&mut self, node: &Modifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_modifier(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_modifier(visitor, node),
        }
    }

    #[inline]
    fn visit_modifiers(&mut self, node: &Modifiers) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_modifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_modifiers(visitor, node),
        }
    }

    #[inline]
    fn visit_named_reference(&mut self, node: &NamedReference) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_named_reference(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_named_reference(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_opt_modifiers(&mut self, node: &Option<Modifiers>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_modifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_modifiers(visitor, node),
        }
    }

    #[inline]
    fn visit_pattern(&mut self, node: &Pattern) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_pattern(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_pattern(visitor, node),
        }
    }

    #[inline]
    fn visit_quantifier(&mut self, node: &Quantifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_quantifier(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_quantifier(visitor, node),
        }
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_span(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_span(visitor, node),
        }
    }

    #[inline]
    fn visit_term(&mut self, node: &Term) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_term(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_term(visitor, node),
        }
    }

    #[inline]
    fn visit_terms(&mut self, node: &[Term]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_terms(visitor, node),
            swc_visit::Either::Right(visitor) => Visit::visit_terms(visitor, node),
        }
    }

    #[inline]
    fn visit_unicode_property_escape(&mut self, node: &UnicodePropertyEscape) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_unicode_property_escape(visitor, node),
            swc_visit::Either::Right(visitor) => {
                Visit::visit_unicode_property_escape(visitor, node)
            }
        }
    }
}
impl<V> Visit for ::swc_visit::Optional<V>
where
    V: Visit,
{
    #[inline]
    fn visit_alternative(&mut self, node: &Alternative) {
        if self.enabled {
            <V as Visit>::visit_alternative(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_alternatives(&mut self, node: &[Alternative]) {
        if self.enabled {
            <V as Visit>::visit_alternatives(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        if self.enabled {
            <V as Visit>::visit_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_boundary_assertion(&mut self, node: &BoundaryAssertion) {
        if self.enabled {
            <V as Visit>::visit_boundary_assertion(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_boundary_assertion_kind(&mut self, node: &BoundaryAssertionKind) {
        if self.enabled {
            <V as Visit>::visit_boundary_assertion_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_capturing_group(&mut self, node: &CapturingGroup) {
        if self.enabled {
            <V as Visit>::visit_capturing_group(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character(&mut self, node: &Character) {
        if self.enabled {
            <V as Visit>::visit_character(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_class(&mut self, node: &CharacterClass) {
        if self.enabled {
            <V as Visit>::visit_character_class(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_contents(&mut self, node: &CharacterClassContents) {
        if self.enabled {
            <V as Visit>::visit_character_class_contents(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_contents_kind(&mut self, node: &CharacterClassContentsKind) {
        if self.enabled {
            <V as Visit>::visit_character_class_contents_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_contentss(&mut self, node: &[CharacterClassContents]) {
        if self.enabled {
            <V as Visit>::visit_character_class_contentss(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_escape(&mut self, node: &CharacterClassEscape) {
        if self.enabled {
            <V as Visit>::visit_character_class_escape(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_escape_kind(&mut self, node: &CharacterClassEscapeKind) {
        if self.enabled {
            <V as Visit>::visit_character_class_escape_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_range(&mut self, node: &CharacterClassRange) {
        if self.enabled {
            <V as Visit>::visit_character_class_range(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_character_kind(&mut self, node: &CharacterKind) {
        if self.enabled {
            <V as Visit>::visit_character_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_characters(&mut self, node: &[Character]) {
        if self.enabled {
            <V as Visit>::visit_characters(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_string(&mut self, node: &ClassString) {
        if self.enabled {
            <V as Visit>::visit_class_string(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_string_disjunction(&mut self, node: &ClassStringDisjunction) {
        if self.enabled {
            <V as Visit>::visit_class_string_disjunction(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_class_strings(&mut self, node: &[ClassString]) {
        if self.enabled {
            <V as Visit>::visit_class_strings(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_disjunction(&mut self, node: &Disjunction) {
        if self.enabled {
            <V as Visit>::visit_disjunction(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_dot(&mut self, node: &Dot) {
        if self.enabled {
            <V as Visit>::visit_dot(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_ignore_group(&mut self, node: &IgnoreGroup) {
        if self.enabled {
            <V as Visit>::visit_ignore_group(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_indexed_reference(&mut self, node: &IndexedReference) {
        if self.enabled {
            <V as Visit>::visit_indexed_reference(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_look_around_assertion(&mut self, node: &LookAroundAssertion) {
        if self.enabled {
            <V as Visit>::visit_look_around_assertion(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_look_around_assertion_kind(&mut self, node: &LookAroundAssertionKind) {
        if self.enabled {
            <V as Visit>::visit_look_around_assertion_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_modifier(&mut self, node: &Modifier) {
        if self.enabled {
            <V as Visit>::visit_modifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_modifiers(&mut self, node: &Modifiers) {
        if self.enabled {
            <V as Visit>::visit_modifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_named_reference(&mut self, node: &NamedReference) {
        if self.enabled {
            <V as Visit>::visit_named_reference(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        if self.enabled {
            <V as Visit>::visit_opt_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_opt_modifiers(&mut self, node: &Option<Modifiers>) {
        if self.enabled {
            <V as Visit>::visit_opt_modifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_pattern(&mut self, node: &Pattern) {
        if self.enabled {
            <V as Visit>::visit_pattern(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_quantifier(&mut self, node: &Quantifier) {
        if self.enabled {
            <V as Visit>::visit_quantifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_span(&mut self, node: &swc_common::Span) {
        if self.enabled {
            <V as Visit>::visit_span(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_term(&mut self, node: &Term) {
        if self.enabled {
            <V as Visit>::visit_term(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_terms(&mut self, node: &[Term]) {
        if self.enabled {
            <V as Visit>::visit_terms(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_unicode_property_escape(&mut self, node: &UnicodePropertyEscape) {
        if self.enabled {
            <V as Visit>::visit_unicode_property_escape(&mut self.visitor, node)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait VisitWith<V: ?Sized + Visit> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_with(&self, visitor: &mut V);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_children_with(&self, visitor: &mut V);
}
impl<V: ?Sized + Visit> VisitWith<V> for Alternative {
    #[doc = "Calls [Visit`::visit_alternative`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_alternative(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Alternative { span, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Term> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BoundaryAssertion {
    #[doc = "Calls [Visit`::visit_boundary_assertion`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_boundary_assertion(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BoundaryAssertion { span, kind } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <BoundaryAssertionKind as VisitWith<V>>::visit_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BoundaryAssertionKind {
    #[doc = "Calls [Visit`::visit_boundary_assertion_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_boundary_assertion_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BoundaryAssertionKind::Start => {}
            BoundaryAssertionKind::End => {}
            BoundaryAssertionKind::Boundary => {}
            BoundaryAssertionKind::NegativeBoundary => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CapturingGroup {
    #[doc = "Calls [Visit`::visit_capturing_group`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_capturing_group(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CapturingGroup { span, name, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(name, visitor)
                };
                {
                    <Disjunction as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Character {
    #[doc = "Calls [Visit`::visit_character`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Character { span, kind, value } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <CharacterKind as VisitWith<V>>::visit_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CharacterClass {
    #[doc = "Calls [Visit`::visit_character_class`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_class(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CharacterClass {
                span,
                negative,
                strings,
                kind,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <CharacterClassContentsKind as VisitWith<V>>::visit_with(kind, visitor)
                };
                {
                    <Vec<CharacterClassContents> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CharacterClassContents {
    #[doc = "Calls [Visit`::visit_character_class_contents`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_class_contents(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CharacterClassContents::CharacterClassRange { 0: _field_0 } => {
                <Box<CharacterClassRange> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            CharacterClassContents::CharacterClassEscape { 0: _field_0 } => {
                <Box<CharacterClassEscape> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            CharacterClassContents::UnicodePropertyEscape { 0: _field_0 } => {
                <Box<UnicodePropertyEscape> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            CharacterClassContents::Character { 0: _field_0 } => {
                <Box<Character> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            CharacterClassContents::NestedCharacterClass { 0: _field_0 } => {
                <Box<CharacterClass> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            CharacterClassContents::ClassStringDisjunction { 0: _field_0 } => {
                <Box<ClassStringDisjunction> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CharacterClassContentsKind {
    #[doc = "Calls [Visit`::visit_character_class_contents_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_class_contents_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CharacterClassContentsKind::Union => {}
            CharacterClassContentsKind::Intersection => {}
            CharacterClassContentsKind::Subtraction => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CharacterClassEscape {
    #[doc = "Calls [Visit`::visit_character_class_escape`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_class_escape(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CharacterClassEscape { span, kind } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <CharacterClassEscapeKind as VisitWith<V>>::visit_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CharacterClassEscapeKind {
    #[doc = "Calls [Visit`::visit_character_class_escape_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_class_escape_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CharacterClassEscapeKind::D => {}
            CharacterClassEscapeKind::NegativeD => {}
            CharacterClassEscapeKind::S => {}
            CharacterClassEscapeKind::NegativeS => {}
            CharacterClassEscapeKind::W => {}
            CharacterClassEscapeKind::NegativeW => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CharacterClassRange {
    #[doc = "Calls [Visit`::visit_character_class_range`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_class_range(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CharacterClassRange { span, min, max } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Character as VisitWith<V>>::visit_with(min, visitor)
                };
                {
                    <Character as VisitWith<V>>::visit_with(max, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CharacterKind {
    #[doc = "Calls [Visit`::visit_character_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CharacterKind::ControlLetter => {}
            CharacterKind::HexadecimalEscape => {}
            CharacterKind::Identifier => {}
            CharacterKind::Null => {}
            CharacterKind::Octal1 => {}
            CharacterKind::Octal2 => {}
            CharacterKind::Octal3 => {}
            CharacterKind::SingleEscape => {}
            CharacterKind::Symbol => {}
            CharacterKind::UnicodeEscape => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassString {
    #[doc = "Calls [Visit`::visit_class_string`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_string(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassString {
                span,
                strings,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Character> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassStringDisjunction {
    #[doc = "Calls [Visit`::visit_class_string_disjunction`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_string_disjunction(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassStringDisjunction {
                span,
                strings,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<ClassString> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Disjunction {
    #[doc = "Calls [Visit`::visit_disjunction`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_disjunction(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Disjunction { span, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Vec<Alternative> as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Dot {
    #[doc = "Calls [Visit`::visit_dot`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_dot(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Dot { span } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for IgnoreGroup {
    #[doc = "Calls [Visit`::visit_ignore_group`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ignore_group(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            IgnoreGroup {
                span,
                modifiers,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Option<Modifiers> as VisitWith<V>>::visit_with(modifiers, visitor)
                };
                {
                    <Disjunction as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for IndexedReference {
    #[doc = "Calls [Visit`::visit_indexed_reference`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_indexed_reference(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            IndexedReference { span, index } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for LookAroundAssertion {
    #[doc = "Calls [Visit`::visit_look_around_assertion`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_look_around_assertion(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            LookAroundAssertion { span, kind, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <LookAroundAssertionKind as VisitWith<V>>::visit_with(kind, visitor)
                };
                {
                    <Disjunction as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for LookAroundAssertionKind {
    #[doc = "Calls [Visit`::visit_look_around_assertion_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_look_around_assertion_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            LookAroundAssertionKind::Lookahead => {}
            LookAroundAssertionKind::NegativeLookahead => {}
            LookAroundAssertionKind::Lookbehind => {}
            LookAroundAssertionKind::NegativeLookbehind => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Modifiers {
    #[doc = "Calls [Visit`::visit_modifiers`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_modifiers(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Modifiers {
                span,
                enabling,
                disabling,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Modifier as VisitWith<V>>::visit_with(enabling, visitor)
                };
                {
                    <Modifier as VisitWith<V>>::visit_with(disabling, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for NamedReference {
    #[doc = "Calls [Visit`::visit_named_reference`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_named_reference(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            NamedReference { span, name } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Pattern {
    #[doc = "Calls [Visit`::visit_pattern`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_pattern(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Pattern { span, body } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Disjunction as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Quantifier {
    #[doc = "Calls [Visit`::visit_quantifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_quantifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Quantifier {
                span,
                min,
                max,
                greedy,
                body,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <Term as VisitWith<V>>::visit_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Term {
    #[doc = "Calls [Visit`::visit_term`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_term(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Term::BoundaryAssertion { 0: _field_0 } => {
                <Box<BoundaryAssertion> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::LookAroundAssertion { 0: _field_0 } => {
                <Box<LookAroundAssertion> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::Quantifier { 0: _field_0 } => {
                <Box<Quantifier> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::Character { 0: _field_0 } => {
                <Box<Character> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::Dot { 0: _field_0 } => {
                <Dot as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::CharacterClassEscape { 0: _field_0 } => {
                <Box<CharacterClassEscape> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::UnicodePropertyEscape { 0: _field_0 } => {
                <Box<UnicodePropertyEscape> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::CharacterClass { 0: _field_0 } => {
                <Box<CharacterClass> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::CapturingGroup { 0: _field_0 } => {
                <Box<CapturingGroup> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::IgnoreGroup { 0: _field_0 } => {
                <Box<IgnoreGroup> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::IndexedReference { 0: _field_0 } => {
                <Box<IndexedReference> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Term::NamedReference { 0: _field_0 } => {
                <Box<NamedReference> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UnicodePropertyEscape {
    #[doc = "Calls [Visit`::visit_unicode_property_escape`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_unicode_property_escape(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UnicodePropertyEscape {
                span,
                negative,
                strings,
                name,
                value,
            } => {
                {
                    <swc_common::Span as VisitWith<V>>::visit_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitWith<V>>::visit_with(name, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitWith<V>>::visit_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Alternative] {
    #[doc = "Calls [Visit`::visit_alternatives`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_alternatives(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Alternative as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_atoms::Atom {
    #[doc = "Calls [Visit`::visit_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_atom(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [CharacterClassContents] {
    #[doc = "Calls [Visit`::visit_character_class_contentss`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_character_class_contentss(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <CharacterClassContents as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Character] {
    #[doc = "Calls [Visit`::visit_characters`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_characters(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Character as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ClassString] {
    #[doc = "Calls [Visit`::visit_class_strings`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_strings(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ClassString as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Modifier {
    #[doc = "Calls [Visit`::visit_modifier`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_modifier(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [Visit`::visit_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_atom(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Modifiers> {
    #[doc = "Calls [Visit`::visit_opt_modifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_modifiers(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Modifiers as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_common::Span {
    #[doc = "Calls [Visit`::visit_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_span(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Term] {
    #[doc = "Calls [Visit`::visit_terms`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_terms(visitor, self)
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Term as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V, T> VisitWith<V> for std::boxed::Box<T>
where
    V: ?Sized + Visit,
    T: VisitWith<V>,
{
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        let v = <T as VisitWith<V>>::visit_with(&**self, visitor);
        v
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        let v = <T as VisitWith<V>>::visit_children_with(&**self, visitor);
        v
    }
}
impl<V, T> VisitWith<V> for std::vec::Vec<T>
where
    V: ?Sized + Visit,
    [T]: VisitWith<V>,
{
    #[inline]
    fn visit_with(&self, visitor: &mut V) {
        let v = <[T] as VisitWith<V>>::visit_with(self, visitor);
        v
    }

    #[inline]
    fn visit_children_with(&self, visitor: &mut V) {
        let v = <[T] as VisitWith<V>>::visit_children_with(self, visitor);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitAstPath {
    #[doc = "Visit a node of type `Alternative`.\n\nBy default, this method calls \
             [`Alternative::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_alternative<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Alternative,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Alternative as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Alternative >`.\n\nBy default, this method calls [`Vec < \
             Alternative >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_alternatives<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Alternative],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[Alternative] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_atoms::Atom as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BoundaryAssertion`.\n\nBy default, this method calls \
             [`BoundaryAssertion::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_boundary_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BoundaryAssertion as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BoundaryAssertionKind`.\n\nBy default, this method calls \
             [`BoundaryAssertionKind::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_boundary_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <BoundaryAssertionKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CapturingGroup`.\n\nBy default, this method calls \
             [`CapturingGroup::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_capturing_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CapturingGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CapturingGroup as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Character`.\n\nBy default, this method calls \
             [`Character::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_character<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Character,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Character as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `CharacterClass`.\n\nBy default, this method calls \
             [`CharacterClass::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_character_class<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClass,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CharacterClass as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassContents`.\n\nBy default, this method calls \
             [`CharacterClassContents::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_character_class_contents<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContents,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CharacterClassContents as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassContentsKind`.\n\nBy default, this method calls \
             [`CharacterClassContentsKind::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_character_class_contents_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContentsKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CharacterClassContentsKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < CharacterClassContents >`.\n\nBy default, this method \
             calls [`Vec < CharacterClassContents >::visit_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    #[inline]
    fn visit_character_class_contentss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [CharacterClassContents],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[CharacterClassContents] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassEscape`.\n\nBy default, this method calls \
             [`CharacterClassEscape::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_character_class_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CharacterClassEscape as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassEscapeKind`.\n\nBy default, this method calls \
             [`CharacterClassEscapeKind::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_character_class_escape_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscapeKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CharacterClassEscapeKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassRange`.\n\nBy default, this method calls \
             [`CharacterClassRange::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_character_class_range<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassRange,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CharacterClassRange as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterKind`.\n\nBy default, this method calls \
             [`CharacterKind::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_character_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <CharacterKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Character >`.\n\nBy default, this method calls [`Vec < \
             Character >::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_characters<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Character],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[Character] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassString`.\n\nBy default, this method calls \
             [`ClassString::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_class_string<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassString,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassString as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassStringDisjunction`.\n\nBy default, this method calls \
             [`ClassStringDisjunction::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_class_string_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassStringDisjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassStringDisjunction as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ClassString >`.\n\nBy default, this method calls [`Vec < \
             ClassString >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_class_strings<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassString],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <[ClassString] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Disjunction`.\n\nBy default, this method calls \
             [`Disjunction::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Disjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Disjunction as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Dot`.\n\nBy default, this method calls \
             [`Dot::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_dot<'ast: 'r, 'r>(&mut self, node: &'ast Dot, __ast_path: &mut AstNodePath<'r>) {
        <Dot as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IgnoreGroup`.\n\nBy default, this method calls \
             [`IgnoreGroup::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_ignore_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IgnoreGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <IgnoreGroup as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `IndexedReference`.\n\nBy default, this method calls \
             [`IndexedReference::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_indexed_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IndexedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <IndexedReference as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LookAroundAssertion`.\n\nBy default, this method calls \
             [`LookAroundAssertion::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_look_around_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <LookAroundAssertion as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LookAroundAssertionKind`.\n\nBy default, this method calls \
             [`LookAroundAssertionKind::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_look_around_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <LookAroundAssertionKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Modifier`.\n\nBy default, this method calls \
             [`Modifier::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_modifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Modifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Modifiers`.\n\nBy default, this method calls \
             [`Modifiers::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifiers,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Modifiers as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `NamedReference`.\n\nBy default, this method calls \
             [`NamedReference::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_named_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <NamedReference as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<swc_atoms::Atom> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Modifiers >`.\n\nBy default, this method calls \
             [`Option < Modifiers >::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_opt_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Modifiers>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Modifiers> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Pattern`.\n\nBy default, this method calls \
             [`Pattern::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_pattern<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Pattern,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Pattern as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Quantifier`.\n\nBy default, this method calls \
             [`Quantifier::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_quantifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Quantifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <Quantifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_common::Span as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Term`.\n\nBy default, this method calls \
             [`Term::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_term<'ast: 'r, 'r>(&mut self, node: &'ast Term, __ast_path: &mut AstNodePath<'r>) {
        <Term as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Term >`.\n\nBy default, this method calls [`Vec < Term \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_terms<'ast: 'r, 'r>(&mut self, node: &'ast [Term], __ast_path: &mut AstNodePath<'r>) {
        <[Term] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UnicodePropertyEscape`.\n\nBy default, this method calls \
             [`UnicodePropertyEscape::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_unicode_property_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnicodePropertyEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <UnicodePropertyEscape as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, __ast_path,
        )
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for &mut V
where
    V: ?Sized + VisitAstPath,
{
    #[inline]
    fn visit_alternative<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Alternative,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_alternative(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_alternatives<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Alternative],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_alternatives(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_boundary_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_boundary_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_boundary_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_boundary_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_capturing_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CapturingGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_capturing_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Character,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClass,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_contents<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContents,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contents(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_contents_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContentsKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contents_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_contentss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [CharacterClassContents],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contentss(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_escape(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_escape_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscapeKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_escape_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_range<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassRange,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_range(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_characters<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Character],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_characters(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_string<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassString,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_string(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_string_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassStringDisjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_string_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_strings<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassString],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_strings(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Disjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_dot<'ast: 'r, 'r>(&mut self, node: &'ast Dot, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_dot(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_ignore_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IgnoreGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ignore_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_indexed_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IndexedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_indexed_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_look_around_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_look_around_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_look_around_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_look_around_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_modifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_modifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifiers,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_named_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_named_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Modifiers>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_pattern<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Pattern,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_pattern(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_quantifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Quantifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_quantifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_term<'ast: 'r, 'r>(&mut self, node: &'ast Term, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_term(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_terms<'ast: 'r, 'r>(&mut self, node: &'ast [Term], __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_terms(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_unicode_property_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnicodePropertyEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unicode_property_escape(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for Box<V>
where
    V: ?Sized + VisitAstPath,
{
    #[inline]
    fn visit_alternative<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Alternative,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_alternative(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_alternatives<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Alternative],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_alternatives(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_boundary_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_boundary_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_boundary_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_boundary_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_capturing_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CapturingGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_capturing_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Character,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClass,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_contents<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContents,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contents(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_contents_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContentsKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contents_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_contentss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [CharacterClassContents],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contentss(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_escape(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_escape_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscapeKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_escape_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_class_range<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassRange,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_range(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_character_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_characters<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Character],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_characters(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_string<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassString,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_string(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_string_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassStringDisjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_string_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_class_strings<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassString],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_strings(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Disjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_dot<'ast: 'r, 'r>(&mut self, node: &'ast Dot, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_dot(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_ignore_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IgnoreGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ignore_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_indexed_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IndexedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_indexed_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_look_around_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_look_around_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_look_around_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_look_around_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_modifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_modifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifiers,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_named_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_named_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_opt_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Modifiers>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_pattern<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Pattern,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_pattern(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_quantifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Quantifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_quantifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_term<'ast: 'r, 'r>(&mut self, node: &'ast Term, __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_term(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_terms<'ast: 'r, 'r>(&mut self, node: &'ast [Term], __ast_path: &mut AstNodePath<'r>) {
        <V as VisitAstPath>::visit_terms(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_unicode_property_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnicodePropertyEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unicode_property_escape(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> VisitAstPath for ::swc_visit::Either<A, B>
where
    A: VisitAstPath,
    B: VisitAstPath,
{
    #[inline]
    fn visit_alternative<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Alternative,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_alternative(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_alternative(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_alternatives<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Alternative],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_alternatives(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_alternatives(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_atom(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_boundary_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_boundary_assertion(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_boundary_assertion(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_boundary_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_boundary_assertion_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_boundary_assertion_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_capturing_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CapturingGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_capturing_group(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_capturing_group(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Character,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_class<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClass,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_class(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_class(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_class_contents<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContents,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_class_contents(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_class_contents(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_class_contents_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContentsKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_class_contents_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_class_contents_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_class_contentss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [CharacterClassContents],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_class_contentss(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_class_contentss(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_class_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_class_escape(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_class_escape(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_class_escape_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscapeKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_class_escape_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_class_escape_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_class_range<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassRange,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_class_range(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_class_range(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_character_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_character_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_character_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_characters<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Character],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_characters(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_characters(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_string<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassString,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_string(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_string(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_string_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassStringDisjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_string_disjunction(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_string_disjunction(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_class_strings<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassString],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_strings(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_strings(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Disjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_disjunction(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_disjunction(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_dot<'ast: 'r, 'r>(&mut self, node: &'ast Dot, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_dot(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_dot(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn visit_ignore_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IgnoreGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ignore_group(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ignore_group(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_indexed_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IndexedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_indexed_reference(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_indexed_reference(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_look_around_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_look_around_assertion(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_look_around_assertion(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_look_around_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_look_around_assertion_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_look_around_assertion_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_modifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_modifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_modifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifiers,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_modifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_modifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_named_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_named_reference(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_named_reference(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_opt_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Modifiers>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_modifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_modifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_pattern<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Pattern,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_pattern(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_pattern(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_quantifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Quantifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_quantifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_quantifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_span(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_span(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_term<'ast: 'r, 'r>(&mut self, node: &'ast Term, __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_term(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_term(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_terms<'ast: 'r, 'r>(&mut self, node: &'ast [Term], __ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_terms(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_terms(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_unicode_property_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnicodePropertyEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_unicode_property_escape(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_unicode_property_escape(visitor, node, __ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for ::swc_visit::Optional<V>
where
    V: VisitAstPath,
{
    #[inline]
    fn visit_alternative<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Alternative,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_alternative(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_alternatives<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Alternative],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_alternatives(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_boundary_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_boundary_assertion(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_boundary_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BoundaryAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_boundary_assertion_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_capturing_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CapturingGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_capturing_group(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_character<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Character,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_character_class<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClass,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_class(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_contents<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContents,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_class_contents(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_contents_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassContentsKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_class_contents_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_character_class_contentss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [CharacterClassContents],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_class_contentss(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_character_class_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_class_escape(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_character_class_escape_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassEscapeKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_class_escape_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_character_class_range<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterClassRange,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_class_range(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_character_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CharacterKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_character_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_characters<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Character],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_characters(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_string<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassString,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_string(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_string_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassStringDisjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_string_disjunction(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_class_strings<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassString],
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_class_strings(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_disjunction<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Disjunction,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_disjunction(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_dot<'ast: 'r, 'r>(&mut self, node: &'ast Dot, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_dot(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_ignore_group<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IgnoreGroup,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_ignore_group(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_indexed_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IndexedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_indexed_reference(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_look_around_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertion,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_look_around_assertion(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_look_around_assertion_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LookAroundAssertionKind,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_look_around_assertion_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_modifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_modifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Modifiers,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_modifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_named_reference<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedReference,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_named_reference(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_opt_modifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Modifiers>,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_opt_modifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_pattern<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Pattern,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_pattern(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_quantifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Quantifier,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_quantifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_span(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_term<'ast: 'r, 'r>(&mut self, node: &'ast Term, __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_term(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_terms<'ast: 'r, 'r>(&mut self, node: &'ast [Term], __ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            <V as VisitAstPath>::visit_terms(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_unicode_property_escape<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnicodePropertyEscape,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            <V as VisitAstPath>::visit_unicode_property_escape(&mut self.visitor, node, __ast_path)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitWithAstPath<V: ?Sized + VisitAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    );
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    );
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Alternative {
    #[doc = "Calls [VisitAstPath`::visit_alternative`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_alternative(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Alternative { span, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Alternative(
                        self,
                        self::fields::AlternativeField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Alternative(
                        self,
                        self::fields::AlternativeField::Body(usize::MAX),
                    ));
                    <Vec<Term> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BoundaryAssertion {
    #[doc = "Calls [VisitAstPath`::visit_boundary_assertion`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_boundary_assertion(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BoundaryAssertion { span, kind } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::BoundaryAssertion(
                            self,
                            self::fields::BoundaryAssertionField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::BoundaryAssertion(
                            self,
                            self::fields::BoundaryAssertionField::Kind,
                        ));
                    <BoundaryAssertionKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BoundaryAssertionKind {
    #[doc = "Calls [VisitAstPath`::visit_boundary_assertion_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_boundary_assertion_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BoundaryAssertionKind::Start => {}
            BoundaryAssertionKind::End => {}
            BoundaryAssertionKind::Boundary => {}
            BoundaryAssertionKind::NegativeBoundary => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CapturingGroup {
    #[doc = "Calls [VisitAstPath`::visit_capturing_group`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_capturing_group(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CapturingGroup { span, name, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CapturingGroup(
                        self,
                        self::fields::CapturingGroupField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CapturingGroup(
                        self,
                        self::fields::CapturingGroupField::Name,
                    ));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CapturingGroup(
                        self,
                        self::fields::CapturingGroupField::Body,
                    ));
                    <Disjunction as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Character {
    #[doc = "Calls [VisitAstPath`::visit_character`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Character { span, kind, value } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Character(
                        self,
                        self::fields::CharacterField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Character(
                        self,
                        self::fields::CharacterField::Kind,
                    ));
                    <CharacterKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CharacterClass {
    #[doc = "Calls [VisitAstPath`::visit_character_class`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CharacterClass {
                span,
                negative,
                strings,
                kind,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CharacterClass(
                        self,
                        self::fields::CharacterClassField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CharacterClass(
                        self,
                        self::fields::CharacterClassField::Kind,
                    ));
                    <CharacterClassContentsKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::CharacterClass(
                        self,
                        self::fields::CharacterClassField::Body(usize::MAX),
                    ));
                    <Vec<CharacterClassContents> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CharacterClassContents {
    #[doc = "Calls [VisitAstPath`::visit_character_class_contents`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contents(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CharacterClassContents::CharacterClassRange { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::CharacterClassContents(
                        self,
                        self::fields::CharacterClassContentsField::CharacterClassRange,
                    ));
                <Box<CharacterClassRange> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::CharacterClassEscape { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::CharacterClassContents(
                        self,
                        self::fields::CharacterClassContentsField::CharacterClassEscape,
                    ));
                <Box<CharacterClassEscape> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::UnicodePropertyEscape { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::CharacterClassContents(
                        self,
                        self::fields::CharacterClassContentsField::UnicodePropertyEscape,
                    ));
                <Box<UnicodePropertyEscape> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::Character { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::CharacterClassContents(
                        self,
                        self::fields::CharacterClassContentsField::Character,
                    ));
                <Box<Character> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::NestedCharacterClass { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::CharacterClassContents(
                        self,
                        self::fields::CharacterClassContentsField::NestedCharacterClass,
                    ));
                <Box<CharacterClass> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::ClassStringDisjunction { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentNodeRef::CharacterClassContents(
                        self,
                        self::fields::CharacterClassContentsField::ClassStringDisjunction,
                    ));
                <Box<ClassStringDisjunction> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CharacterClassContentsKind {
    #[doc = "Calls [VisitAstPath`::visit_character_class_contents_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contents_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CharacterClassContentsKind::Union => {}
            CharacterClassContentsKind::Intersection => {}
            CharacterClassContentsKind::Subtraction => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CharacterClassEscape {
    #[doc = "Calls [VisitAstPath`::visit_character_class_escape`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_escape(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CharacterClassEscape { span, kind } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::CharacterClassEscape(
                            self,
                            self::fields::CharacterClassEscapeField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::CharacterClassEscape(
                            self,
                            self::fields::CharacterClassEscapeField::Kind,
                        ));
                    <CharacterClassEscapeKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CharacterClassEscapeKind {
    #[doc = "Calls [VisitAstPath`::visit_character_class_escape_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_escape_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CharacterClassEscapeKind::D => {}
            CharacterClassEscapeKind::NegativeD => {}
            CharacterClassEscapeKind::S => {}
            CharacterClassEscapeKind::NegativeS => {}
            CharacterClassEscapeKind::W => {}
            CharacterClassEscapeKind::NegativeW => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CharacterClassRange {
    #[doc = "Calls [VisitAstPath`::visit_character_class_range`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_range(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CharacterClassRange { span, min, max } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::CharacterClassRange(
                            self,
                            self::fields::CharacterClassRangeField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::CharacterClassRange(
                            self,
                            self::fields::CharacterClassRangeField::Min,
                        ));
                    <Character as VisitWithAstPath<V>>::visit_with_ast_path(
                        min,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::CharacterClassRange(
                            self,
                            self::fields::CharacterClassRangeField::Max,
                        ));
                    <Character as VisitWithAstPath<V>>::visit_with_ast_path(
                        max,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CharacterKind {
    #[doc = "Calls [VisitAstPath`::visit_character_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CharacterKind::ControlLetter => {}
            CharacterKind::HexadecimalEscape => {}
            CharacterKind::Identifier => {}
            CharacterKind::Null => {}
            CharacterKind::Octal1 => {}
            CharacterKind::Octal2 => {}
            CharacterKind::Octal3 => {}
            CharacterKind::SingleEscape => {}
            CharacterKind::Symbol => {}
            CharacterKind::UnicodeEscape => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassString {
    #[doc = "Calls [VisitAstPath`::visit_class_string`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_string(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassString {
                span,
                strings,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassString(
                        self,
                        self::fields::ClassStringField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::ClassString(
                        self,
                        self::fields::ClassStringField::Body(usize::MAX),
                    ));
                    <Vec<Character> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassStringDisjunction {
    #[doc = "Calls [VisitAstPath`::visit_class_string_disjunction`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_string_disjunction(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassStringDisjunction {
                span,
                strings,
                body,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ClassStringDisjunction(
                            self,
                            self::fields::ClassStringDisjunctionField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::ClassStringDisjunction(
                            self,
                            self::fields::ClassStringDisjunctionField::Body(usize::MAX),
                        ));
                    <Vec<ClassString> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Disjunction {
    #[doc = "Calls [VisitAstPath`::visit_disjunction`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_disjunction(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Disjunction { span, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Disjunction(
                        self,
                        self::fields::DisjunctionField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Disjunction(
                        self,
                        self::fields::DisjunctionField::Body(usize::MAX),
                    ));
                    <Vec<Alternative> as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Dot {
    #[doc = "Calls [VisitAstPath`::visit_dot`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_dot(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Dot { span } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentNodeRef::Dot(self, self::fields::DotField::Span));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for IgnoreGroup {
    #[doc = "Calls [VisitAstPath`::visit_ignore_group`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ignore_group(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            IgnoreGroup {
                span,
                modifiers,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IgnoreGroup(
                        self,
                        self::fields::IgnoreGroupField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IgnoreGroup(
                        self,
                        self::fields::IgnoreGroupField::Modifiers,
                    ));
                    <Option<Modifiers> as VisitWithAstPath<V>>::visit_with_ast_path(
                        modifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IgnoreGroup(
                        self,
                        self::fields::IgnoreGroupField::Body,
                    ));
                    <Disjunction as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for IndexedReference {
    #[doc = "Calls [VisitAstPath`::visit_indexed_reference`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_indexed_reference(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            IndexedReference { span, index } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::IndexedReference(
                        self,
                        self::fields::IndexedReferenceField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for LookAroundAssertion {
    #[doc = "Calls [VisitAstPath`::visit_look_around_assertion`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_look_around_assertion(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            LookAroundAssertion { span, kind, body } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::LookAroundAssertion(
                            self,
                            self::fields::LookAroundAssertionField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::LookAroundAssertion(
                            self,
                            self::fields::LookAroundAssertionField::Kind,
                        ));
                    <LookAroundAssertionKind as VisitWithAstPath<V>>::visit_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::LookAroundAssertion(
                            self,
                            self::fields::LookAroundAssertionField::Body,
                        ));
                    <Disjunction as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for LookAroundAssertionKind {
    #[doc = "Calls [VisitAstPath`::visit_look_around_assertion_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_look_around_assertion_kind(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            LookAroundAssertionKind::Lookahead => {}
            LookAroundAssertionKind::NegativeLookahead => {}
            LookAroundAssertionKind::Lookbehind => {}
            LookAroundAssertionKind::NegativeLookbehind => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Modifiers {
    #[doc = "Calls [VisitAstPath`::visit_modifiers`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_modifiers(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Modifiers {
                span,
                enabling,
                disabling,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Modifiers(
                        self,
                        self::fields::ModifiersField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Modifiers(
                        self,
                        self::fields::ModifiersField::Enabling,
                    ));
                    <Modifier as VisitWithAstPath<V>>::visit_with_ast_path(
                        enabling,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Modifiers(
                        self,
                        self::fields::ModifiersField::Disabling,
                    ));
                    <Modifier as VisitWithAstPath<V>>::visit_with_ast_path(
                        disabling,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for NamedReference {
    #[doc = "Calls [VisitAstPath`::visit_named_reference`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_named_reference(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            NamedReference { span, name } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NamedReference(
                        self,
                        self::fields::NamedReferenceField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::NamedReference(
                        self,
                        self::fields::NamedReferenceField::Name,
                    ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Pattern {
    #[doc = "Calls [VisitAstPath`::visit_pattern`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_pattern(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Pattern { span, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Pattern(
                        self,
                        self::fields::PatternField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Pattern(
                        self,
                        self::fields::PatternField::Body,
                    ));
                    <Disjunction as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Quantifier {
    #[doc = "Calls [VisitAstPath`::visit_quantifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_quantifier(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Quantifier {
                span,
                min,
                max,
                greedy,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Quantifier(
                        self,
                        self::fields::QuantifierField::Span,
                    ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Quantifier(
                        self,
                        self::fields::QuantifierField::Body,
                    ));
                    <Term as VisitWithAstPath<V>>::visit_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Term {
    #[doc = "Calls [VisitAstPath`::visit_term`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_term(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Term::BoundaryAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::BoundaryAssertion,
                ));
                <Box<BoundaryAssertion> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::LookAroundAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::LookAroundAssertion,
                ));
                <Box<LookAroundAssertion> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::Quantifier { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::Quantifier,
                ));
                <Box<Quantifier> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::Character { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::Character,
                ));
                <Box<Character> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::Dot { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentNodeRef::Term(self, self::fields::TermField::Dot));
                <Dot as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::CharacterClassEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::CharacterClassEscape,
                ));
                <Box<CharacterClassEscape> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::UnicodePropertyEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::UnicodePropertyEscape,
                ));
                <Box<UnicodePropertyEscape> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::CharacterClass { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::CharacterClass,
                ));
                <Box<CharacterClass> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::CapturingGroup { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::CapturingGroup,
                ));
                <Box<CapturingGroup> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::IgnoreGroup { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::IgnoreGroup,
                ));
                <Box<IgnoreGroup> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::IndexedReference { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::IndexedReference,
                ));
                <Box<IndexedReference> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::NamedReference { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentNodeRef::Term(
                    self,
                    self::fields::TermField::NamedReference,
                ));
                <Box<NamedReference> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UnicodePropertyEscape {
    #[doc = "Calls [VisitAstPath`::visit_unicode_property_escape`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unicode_property_escape(visitor, self, __ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UnicodePropertyEscape {
                span,
                negative,
                strings,
                name,
                value,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::UnicodePropertyEscape(
                            self,
                            self::fields::UnicodePropertyEscapeField::Span,
                        ));
                    <swc_common::Span as VisitWithAstPath<V>>::visit_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::UnicodePropertyEscape(
                            self,
                            self::fields::UnicodePropertyEscapeField::Name,
                        ));
                    <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentNodeRef::UnicodePropertyEscape(
                            self,
                            self::fields::UnicodePropertyEscapeField::Value,
                        ));
                    <Option<swc_atoms::Atom> as VisitWithAstPath<V>>::visit_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Alternative] {
    #[doc = "Calls [VisitAstPath`::visit_alternatives`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_alternatives(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Alternative as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitAstPath`::visit_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [CharacterClassContents] {
    #[doc = "Calls [VisitAstPath`::visit_character_class_contentss`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_character_class_contentss(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <CharacterClassContents as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Character] {
    #[doc = "Calls [VisitAstPath`::visit_characters`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_characters(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Character as VisitWithAstPath<V>>::visit_with_ast_path(item, visitor, &mut *__ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ClassString] {
    #[doc = "Calls [VisitAstPath`::visit_class_strings`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_strings(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ClassString as VisitWithAstPath<V>>::visit_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Modifier {
    #[doc = "Calls [VisitAstPath`::visit_modifier`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_modifier(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitAstPath`::visit_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Modifiers> {
    #[doc = "Calls [VisitAstPath`::visit_opt_modifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_modifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Modifiers as VisitWithAstPath<V>>::visit_with_ast_path(inner, visitor, __ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [VisitAstPath`::visit_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_span(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Term] {
    #[doc = "Calls [VisitAstPath`::visit_terms`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_terms(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Term as VisitWithAstPath<V>>::visit_with_ast_path(item, visitor, &mut *__ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitAstPath,
    T: VisitWithAstPath<V>,
{
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v = <T as VisitWithAstPath<V>>::visit_with_ast_path(&**self, visitor, __ast_path);
        v
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v =
            <T as VisitWithAstPath<V>>::visit_children_with_ast_path(&**self, visitor, __ast_path);
        v
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitWithAstPath<V> for std::vec::Vec<T>
where
    V: ?Sized + VisitAstPath,
    [T]: VisitWithAstPath<V>,
{
    #[inline]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v = <[T] as VisitWithAstPath<V>>::visit_with_ast_path(self, visitor, __ast_path);
        v
    }

    #[inline]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        __ast_path: &mut AstNodePath<'r>,
    ) {
        let v =
            <[T] as VisitWithAstPath<V>>::visit_children_with_ast_path(self, visitor, __ast_path);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
pub trait VisitMut {
    #[doc = "Visit a node of type `Alternative`.\n\nBy default, this method calls \
             [`Alternative::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative) {
        <Alternative as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Alternative >`.\n\nBy default, this method calls [`Vec < \
             Alternative >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_alternatives(&mut self, node: &mut Vec<Alternative>) {
        <Vec<Alternative> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        <swc_atoms::Atom as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BoundaryAssertion`.\n\nBy default, this method calls \
             [`BoundaryAssertion::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        <BoundaryAssertion as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BoundaryAssertionKind`.\n\nBy default, this method calls \
             [`BoundaryAssertionKind::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        <BoundaryAssertionKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CapturingGroup`.\n\nBy default, this method calls \
             [`CapturingGroup::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_capturing_group(&mut self, node: &mut CapturingGroup) {
        <CapturingGroup as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Character`.\n\nBy default, this method calls \
             [`Character::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character) {
        <Character as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClass`.\n\nBy default, this method calls \
             [`CharacterClass::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_character_class(&mut self, node: &mut CharacterClass) {
        <CharacterClass as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassContents`.\n\nBy default, this method calls \
             [`CharacterClassContents::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        <CharacterClassContents as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassContentsKind`.\n\nBy default, this method calls \
             [`CharacterClassContentsKind::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        <CharacterClassContentsKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < CharacterClassContents >`.\n\nBy default, this method \
             calls [`Vec < CharacterClassContents >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        <Vec<CharacterClassContents> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassEscape`.\n\nBy default, this method calls \
             [`CharacterClassEscape::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        <CharacterClassEscape as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassEscapeKind`.\n\nBy default, this method calls \
             [`CharacterClassEscapeKind::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        <CharacterClassEscapeKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassRange`.\n\nBy default, this method calls \
             [`CharacterClassRange::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_character_class_range(&mut self, node: &mut CharacterClassRange) {
        <CharacterClassRange as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterKind`.\n\nBy default, this method calls \
             [`CharacterKind::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind) {
        <CharacterKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Character >`.\n\nBy default, this method calls [`Vec < \
             Character >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>) {
        <Vec<Character> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassString`.\n\nBy default, this method calls \
             [`ClassString::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString) {
        <ClassString as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassStringDisjunction`.\n\nBy default, this method calls \
             [`ClassStringDisjunction::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        <ClassStringDisjunction as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassString >`.\n\nBy default, this method calls [`Vec < \
             ClassString >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_class_strings(&mut self, node: &mut Vec<ClassString>) {
        <Vec<ClassString> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Disjunction`.\n\nBy default, this method calls \
             [`Disjunction::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction) {
        <Disjunction as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Dot`.\n\nBy default, this method calls \
             [`Dot::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot) {
        <Dot as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `IgnoreGroup`.\n\nBy default, this method calls \
             [`IgnoreGroup::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup) {
        <IgnoreGroup as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `IndexedReference`.\n\nBy default, this method calls \
             [`IndexedReference::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_indexed_reference(&mut self, node: &mut IndexedReference) {
        <IndexedReference as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `LookAroundAssertion`.\n\nBy default, this method calls \
             [`LookAroundAssertion::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        <LookAroundAssertion as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `LookAroundAssertionKind`.\n\nBy default, this method calls \
             [`LookAroundAssertionKind::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        <LookAroundAssertionKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Modifier`.\n\nBy default, this method calls \
             [`Modifier::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier) {
        <Modifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Modifiers`.\n\nBy default, this method calls \
             [`Modifiers::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers) {
        <Modifiers as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedReference`.\n\nBy default, this method calls \
             [`NamedReference::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_named_reference(&mut self, node: &mut NamedReference) {
        <NamedReference as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        <Option<swc_atoms::Atom> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Modifiers >`.\n\nBy default, this method calls \
             [`Option < Modifiers >::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        <Option<Modifiers> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pattern`.\n\nBy default, this method calls \
             [`Pattern::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern) {
        <Pattern as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Quantifier`.\n\nBy default, this method calls \
             [`Quantifier::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier) {
        <Quantifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        <swc_common::Span as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Term`.\n\nBy default, this method calls \
             [`Term::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term) {
        <Term as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Term >`.\n\nBy default, this method calls [`Vec < Term \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>) {
        <Vec<Term> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnicodePropertyEscape`.\n\nBy default, this method calls \
             [`UnicodePropertyEscape::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        <UnicodePropertyEscape as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
}
impl<V> VisitMut for &mut V
where
    V: ?Sized + VisitMut,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative) {
        <V as VisitMut>::visit_mut_alternative(&mut **self, node)
    }

    #[inline]
    fn visit_mut_alternatives(&mut self, node: &mut Vec<Alternative>) {
        <V as VisitMut>::visit_mut_alternatives(&mut **self, node)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        <V as VisitMut>::visit_mut_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        <V as VisitMut>::visit_mut_boundary_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        <V as VisitMut>::visit_mut_boundary_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_capturing_group(&mut self, node: &mut CapturingGroup) {
        <V as VisitMut>::visit_mut_capturing_group(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character) {
        <V as VisitMut>::visit_mut_character(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class(&mut self, node: &mut CharacterClass) {
        <V as VisitMut>::visit_mut_character_class(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        <V as VisitMut>::visit_mut_character_class_contents(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        <V as VisitMut>::visit_mut_character_class_contents_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        <V as VisitMut>::visit_mut_character_class_contentss(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        <V as VisitMut>::visit_mut_character_class_escape(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        <V as VisitMut>::visit_mut_character_class_escape_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_range(&mut self, node: &mut CharacterClassRange) {
        <V as VisitMut>::visit_mut_character_class_range(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind) {
        <V as VisitMut>::visit_mut_character_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>) {
        <V as VisitMut>::visit_mut_characters(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString) {
        <V as VisitMut>::visit_mut_class_string(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        <V as VisitMut>::visit_mut_class_string_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_strings(&mut self, node: &mut Vec<ClassString>) {
        <V as VisitMut>::visit_mut_class_strings(&mut **self, node)
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction) {
        <V as VisitMut>::visit_mut_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot) {
        <V as VisitMut>::visit_mut_dot(&mut **self, node)
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup) {
        <V as VisitMut>::visit_mut_ignore_group(&mut **self, node)
    }

    #[inline]
    fn visit_mut_indexed_reference(&mut self, node: &mut IndexedReference) {
        <V as VisitMut>::visit_mut_indexed_reference(&mut **self, node)
    }

    #[inline]
    fn visit_mut_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        <V as VisitMut>::visit_mut_look_around_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        <V as VisitMut>::visit_mut_look_around_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier) {
        <V as VisitMut>::visit_mut_modifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers) {
        <V as VisitMut>::visit_mut_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_named_reference(&mut self, node: &mut NamedReference) {
        <V as VisitMut>::visit_mut_named_reference(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        <V as VisitMut>::visit_mut_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        <V as VisitMut>::visit_mut_opt_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern) {
        <V as VisitMut>::visit_mut_pattern(&mut **self, node)
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier) {
        <V as VisitMut>::visit_mut_quantifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        <V as VisitMut>::visit_mut_span(&mut **self, node)
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term) {
        <V as VisitMut>::visit_mut_term(&mut **self, node)
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>) {
        <V as VisitMut>::visit_mut_terms(&mut **self, node)
    }

    #[inline]
    fn visit_mut_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        <V as VisitMut>::visit_mut_unicode_property_escape(&mut **self, node)
    }
}
impl<V> VisitMut for Box<V>
where
    V: ?Sized + VisitMut,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative) {
        <V as VisitMut>::visit_mut_alternative(&mut **self, node)
    }

    #[inline]
    fn visit_mut_alternatives(&mut self, node: &mut Vec<Alternative>) {
        <V as VisitMut>::visit_mut_alternatives(&mut **self, node)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        <V as VisitMut>::visit_mut_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        <V as VisitMut>::visit_mut_boundary_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        <V as VisitMut>::visit_mut_boundary_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_capturing_group(&mut self, node: &mut CapturingGroup) {
        <V as VisitMut>::visit_mut_capturing_group(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character) {
        <V as VisitMut>::visit_mut_character(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class(&mut self, node: &mut CharacterClass) {
        <V as VisitMut>::visit_mut_character_class(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        <V as VisitMut>::visit_mut_character_class_contents(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        <V as VisitMut>::visit_mut_character_class_contents_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        <V as VisitMut>::visit_mut_character_class_contentss(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        <V as VisitMut>::visit_mut_character_class_escape(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        <V as VisitMut>::visit_mut_character_class_escape_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_class_range(&mut self, node: &mut CharacterClassRange) {
        <V as VisitMut>::visit_mut_character_class_range(&mut **self, node)
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind) {
        <V as VisitMut>::visit_mut_character_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>) {
        <V as VisitMut>::visit_mut_characters(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString) {
        <V as VisitMut>::visit_mut_class_string(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        <V as VisitMut>::visit_mut_class_string_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_mut_class_strings(&mut self, node: &mut Vec<ClassString>) {
        <V as VisitMut>::visit_mut_class_strings(&mut **self, node)
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction) {
        <V as VisitMut>::visit_mut_disjunction(&mut **self, node)
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot) {
        <V as VisitMut>::visit_mut_dot(&mut **self, node)
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup) {
        <V as VisitMut>::visit_mut_ignore_group(&mut **self, node)
    }

    #[inline]
    fn visit_mut_indexed_reference(&mut self, node: &mut IndexedReference) {
        <V as VisitMut>::visit_mut_indexed_reference(&mut **self, node)
    }

    #[inline]
    fn visit_mut_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        <V as VisitMut>::visit_mut_look_around_assertion(&mut **self, node)
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        <V as VisitMut>::visit_mut_look_around_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier) {
        <V as VisitMut>::visit_mut_modifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers) {
        <V as VisitMut>::visit_mut_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_named_reference(&mut self, node: &mut NamedReference) {
        <V as VisitMut>::visit_mut_named_reference(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        <V as VisitMut>::visit_mut_opt_atom(&mut **self, node)
    }

    #[inline]
    fn visit_mut_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        <V as VisitMut>::visit_mut_opt_modifiers(&mut **self, node)
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern) {
        <V as VisitMut>::visit_mut_pattern(&mut **self, node)
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier) {
        <V as VisitMut>::visit_mut_quantifier(&mut **self, node)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        <V as VisitMut>::visit_mut_span(&mut **self, node)
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term) {
        <V as VisitMut>::visit_mut_term(&mut **self, node)
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>) {
        <V as VisitMut>::visit_mut_terms(&mut **self, node)
    }

    #[inline]
    fn visit_mut_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        <V as VisitMut>::visit_mut_unicode_property_escape(&mut **self, node)
    }
}
impl<A, B> VisitMut for ::swc_visit::Either<A, B>
where
    A: VisitMut,
    B: VisitMut,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_alternative(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_alternative(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_alternatives(&mut self, node: &mut Vec<Alternative>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_alternatives(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_alternatives(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_atom(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_boundary_assertion(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_boundary_assertion(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_boundary_assertion_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_boundary_assertion_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_capturing_group(&mut self, node: &mut CapturingGroup) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_capturing_group(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_capturing_group(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_character(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_character(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_character_class(&mut self, node: &mut CharacterClass) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_character_class(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_character_class(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_character_class_contents(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_character_class_contents(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_character_class_contents_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_character_class_contents_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_character_class_contentss(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_character_class_contentss(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_character_class_escape(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_character_class_escape(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_character_class_escape_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_character_class_escape_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_range(&mut self, node: &mut CharacterClassRange) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_character_class_range(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_character_class_range(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_character_kind(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_character_kind(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_characters(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_characters(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_string(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_string(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_class_string_disjunction(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_class_string_disjunction(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_class_strings(&mut self, node: &mut Vec<ClassString>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_strings(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_strings(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_disjunction(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_disjunction(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_dot(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_dot(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ignore_group(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ignore_group(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_indexed_reference(&mut self, node: &mut IndexedReference) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_indexed_reference(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_indexed_reference(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_look_around_assertion(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_look_around_assertion(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_look_around_assertion_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_look_around_assertion_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_modifier(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_modifier(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_modifiers(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_modifiers(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_named_reference(&mut self, node: &mut NamedReference) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_named_reference(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_named_reference(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_atom(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_atom(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_modifiers(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_modifiers(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_pattern(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_pattern(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_quantifier(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_quantifier(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_span(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_span(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_term(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_term(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_terms(visitor, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_terms(visitor, node),
        }
    }

    #[inline]
    fn visit_mut_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_unicode_property_escape(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_unicode_property_escape(visitor, node)
            }
        }
    }
}
impl<V> VisitMut for ::swc_visit::Optional<V>
where
    V: VisitMut,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative) {
        if self.enabled {
            <V as VisitMut>::visit_mut_alternative(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_alternatives(&mut self, node: &mut Vec<Alternative>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_alternatives(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        if self.enabled {
            <V as VisitMut>::visit_mut_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        if self.enabled {
            <V as VisitMut>::visit_mut_boundary_assertion(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_boundary_assertion_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_capturing_group(&mut self, node: &mut CapturingGroup) {
        if self.enabled {
            <V as VisitMut>::visit_mut_capturing_group(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class(&mut self, node: &mut CharacterClass) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_class(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_class_contents(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_class_contents_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_class_contentss(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_class_escape(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_class_escape_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_range(&mut self, node: &mut CharacterClassRange) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_class_range(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_character_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_characters(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_string(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_string_disjunction(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_strings(&mut self, node: &mut Vec<ClassString>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_class_strings(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction) {
        if self.enabled {
            <V as VisitMut>::visit_mut_disjunction(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot) {
        if self.enabled {
            <V as VisitMut>::visit_mut_dot(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup) {
        if self.enabled {
            <V as VisitMut>::visit_mut_ignore_group(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_indexed_reference(&mut self, node: &mut IndexedReference) {
        if self.enabled {
            <V as VisitMut>::visit_mut_indexed_reference(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        if self.enabled {
            <V as VisitMut>::visit_mut_look_around_assertion(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        if self.enabled {
            <V as VisitMut>::visit_mut_look_around_assertion_kind(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_modifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers) {
        if self.enabled {
            <V as VisitMut>::visit_mut_modifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_named_reference(&mut self, node: &mut NamedReference) {
        if self.enabled {
            <V as VisitMut>::visit_mut_named_reference(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_atom(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_opt_modifiers(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern) {
        if self.enabled {
            <V as VisitMut>::visit_mut_pattern(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier) {
        if self.enabled {
            <V as VisitMut>::visit_mut_quantifier(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        if self.enabled {
            <V as VisitMut>::visit_mut_span(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term) {
        if self.enabled {
            <V as VisitMut>::visit_mut_term(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>) {
        if self.enabled {
            <V as VisitMut>::visit_mut_terms(&mut self.visitor, node)
        } else {
        }
    }

    #[inline]
    fn visit_mut_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        if self.enabled {
            <V as VisitMut>::visit_mut_unicode_property_escape(&mut self.visitor, node)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait VisitMutWith<V: ?Sized + VisitMut> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_mut_with(&mut self, visitor: &mut V);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_mut_children_with(&mut self, visitor: &mut V);
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Alternative {
    #[doc = "Calls [VisitMut`::visit_mut_alternative`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_alternative(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Alternative { span, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Term> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BoundaryAssertion {
    #[doc = "Calls [VisitMut`::visit_mut_boundary_assertion`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_boundary_assertion(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BoundaryAssertion { span, kind } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <BoundaryAssertionKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BoundaryAssertionKind {
    #[doc = "Calls [VisitMut`::visit_mut_boundary_assertion_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_boundary_assertion_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BoundaryAssertionKind::Start => {}
            BoundaryAssertionKind::End => {}
            BoundaryAssertionKind::Boundary => {}
            BoundaryAssertionKind::NegativeBoundary => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CapturingGroup {
    #[doc = "Calls [VisitMut`::visit_mut_capturing_group`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_capturing_group(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CapturingGroup { span, name, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
                {
                    <Disjunction as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Character {
    #[doc = "Calls [VisitMut`::visit_mut_character`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Character { span, kind, value } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <CharacterKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CharacterClass {
    #[doc = "Calls [VisitMut`::visit_mut_character_class`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_class(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CharacterClass {
                span,
                negative,
                strings,
                kind,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <CharacterClassContentsKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
                {
                    <Vec<CharacterClassContents> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CharacterClassContents {
    #[doc = "Calls [VisitMut`::visit_mut_character_class_contents`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_class_contents(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CharacterClassContents::CharacterClassRange { 0: _field_0 } => {
                <Box<CharacterClassRange> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            CharacterClassContents::CharacterClassEscape { 0: _field_0 } => {
                <Box<CharacterClassEscape> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            CharacterClassContents::UnicodePropertyEscape { 0: _field_0 } => {
                <Box<UnicodePropertyEscape> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            CharacterClassContents::Character { 0: _field_0 } => {
                <Box<Character> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            CharacterClassContents::NestedCharacterClass { 0: _field_0 } => {
                <Box<CharacterClass> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            CharacterClassContents::ClassStringDisjunction { 0: _field_0 } => {
                <Box<ClassStringDisjunction> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CharacterClassContentsKind {
    #[doc = "Calls [VisitMut`::visit_mut_character_class_contents_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_class_contents_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CharacterClassContentsKind::Union => {}
            CharacterClassContentsKind::Intersection => {}
            CharacterClassContentsKind::Subtraction => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CharacterClassEscape {
    #[doc = "Calls [VisitMut`::visit_mut_character_class_escape`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_class_escape(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CharacterClassEscape { span, kind } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <CharacterClassEscapeKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CharacterClassEscapeKind {
    #[doc = "Calls [VisitMut`::visit_mut_character_class_escape_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_class_escape_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CharacterClassEscapeKind::D => {}
            CharacterClassEscapeKind::NegativeD => {}
            CharacterClassEscapeKind::S => {}
            CharacterClassEscapeKind::NegativeS => {}
            CharacterClassEscapeKind::W => {}
            CharacterClassEscapeKind::NegativeW => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CharacterClassRange {
    #[doc = "Calls [VisitMut`::visit_mut_character_class_range`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_class_range(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CharacterClassRange { span, min, max } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Character as VisitMutWith<V>>::visit_mut_with(min, visitor)
                };
                {
                    <Character as VisitMutWith<V>>::visit_mut_with(max, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CharacterKind {
    #[doc = "Calls [VisitMut`::visit_mut_character_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CharacterKind::ControlLetter => {}
            CharacterKind::HexadecimalEscape => {}
            CharacterKind::Identifier => {}
            CharacterKind::Null => {}
            CharacterKind::Octal1 => {}
            CharacterKind::Octal2 => {}
            CharacterKind::Octal3 => {}
            CharacterKind::SingleEscape => {}
            CharacterKind::Symbol => {}
            CharacterKind::UnicodeEscape => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassString {
    #[doc = "Calls [VisitMut`::visit_mut_class_string`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_string(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassString {
                span,
                strings,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Character> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassStringDisjunction {
    #[doc = "Calls [VisitMut`::visit_mut_class_string_disjunction`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_string_disjunction(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassStringDisjunction {
                span,
                strings,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<ClassString> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Disjunction {
    #[doc = "Calls [VisitMut`::visit_mut_disjunction`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_disjunction(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Disjunction { span, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Vec<Alternative> as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Dot {
    #[doc = "Calls [VisitMut`::visit_mut_dot`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_dot(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Dot { span } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for IgnoreGroup {
    #[doc = "Calls [VisitMut`::visit_mut_ignore_group`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ignore_group(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            IgnoreGroup {
                span,
                modifiers,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Option<Modifiers> as VisitMutWith<V>>::visit_mut_with(modifiers, visitor)
                };
                {
                    <Disjunction as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for IndexedReference {
    #[doc = "Calls [VisitMut`::visit_mut_indexed_reference`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_indexed_reference(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            IndexedReference { span, index } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for LookAroundAssertion {
    #[doc = "Calls [VisitMut`::visit_mut_look_around_assertion`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_look_around_assertion(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            LookAroundAssertion { span, kind, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <LookAroundAssertionKind as VisitMutWith<V>>::visit_mut_with(kind, visitor)
                };
                {
                    <Disjunction as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for LookAroundAssertionKind {
    #[doc = "Calls [VisitMut`::visit_mut_look_around_assertion_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_look_around_assertion_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            LookAroundAssertionKind::Lookahead => {}
            LookAroundAssertionKind::NegativeLookahead => {}
            LookAroundAssertionKind::Lookbehind => {}
            LookAroundAssertionKind::NegativeLookbehind => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Modifiers {
    #[doc = "Calls [VisitMut`::visit_mut_modifiers`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_modifiers(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Modifiers {
                span,
                enabling,
                disabling,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Modifier as VisitMutWith<V>>::visit_mut_with(enabling, visitor)
                };
                {
                    <Modifier as VisitMutWith<V>>::visit_mut_with(disabling, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for NamedReference {
    #[doc = "Calls [VisitMut`::visit_mut_named_reference`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_named_reference(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            NamedReference { span, name } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Pattern {
    #[doc = "Calls [VisitMut`::visit_mut_pattern`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_pattern(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Pattern { span, body } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Disjunction as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Quantifier {
    #[doc = "Calls [VisitMut`::visit_mut_quantifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_quantifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Quantifier {
                span,
                min,
                max,
                greedy,
                body,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <Term as VisitMutWith<V>>::visit_mut_with(body, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Term {
    #[doc = "Calls [VisitMut`::visit_mut_term`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_term(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Term::BoundaryAssertion { 0: _field_0 } => {
                <Box<BoundaryAssertion> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::LookAroundAssertion { 0: _field_0 } => {
                <Box<LookAroundAssertion> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::Quantifier { 0: _field_0 } => {
                <Box<Quantifier> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::Character { 0: _field_0 } => {
                <Box<Character> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::Dot { 0: _field_0 } => {
                <Dot as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::CharacterClassEscape { 0: _field_0 } => {
                <Box<CharacterClassEscape> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::UnicodePropertyEscape { 0: _field_0 } => {
                <Box<UnicodePropertyEscape> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::CharacterClass { 0: _field_0 } => {
                <Box<CharacterClass> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::CapturingGroup { 0: _field_0 } => {
                <Box<CapturingGroup> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::IgnoreGroup { 0: _field_0 } => {
                <Box<IgnoreGroup> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::IndexedReference { 0: _field_0 } => {
                <Box<IndexedReference> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Term::NamedReference { 0: _field_0 } => {
                <Box<NamedReference> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UnicodePropertyEscape {
    #[doc = "Calls [VisitMut`::visit_mut_unicode_property_escape`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_unicode_property_escape(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UnicodePropertyEscape {
                span,
                negative,
                strings,
                name,
                value,
            } => {
                {
                    <swc_common::Span as VisitMutWith<V>>::visit_mut_with(span, visitor)
                };
                {
                    <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(name, visitor)
                };
                {
                    <Option<swc_atoms::Atom> as VisitMutWith<V>>::visit_mut_with(value, visitor)
                };
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Alternative> {
    #[doc = "Calls [VisitMut`::visit_mut_alternatives`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_alternatives(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Alternative as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitMut`::visit_mut_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_atom(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<CharacterClassContents> {
    #[doc = "Calls [VisitMut`::visit_mut_character_class_contentss`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_character_class_contentss(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut().for_each(|item| {
            <CharacterClassContents as VisitMutWith<V>>::visit_mut_with(item, visitor)
        })
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Character> {
    #[doc = "Calls [VisitMut`::visit_mut_characters`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_characters(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Character as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ClassString> {
    #[doc = "Calls [VisitMut`::visit_mut_class_strings`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_strings(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ClassString as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Modifier {
    #[doc = "Calls [VisitMut`::visit_mut_modifier`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_modifier(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_atom(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Modifiers> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_modifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_modifiers(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Modifiers as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_common::Span {
    #[doc = "Calls [VisitMut`::visit_mut_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_span(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Term> {
    #[doc = "Calls [VisitMut`::visit_mut_terms`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_terms(visitor, self)
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Term as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V, T> VisitMutWith<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitMut,
    T: VisitMutWith<V>,
{
    #[inline]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        let v = <T as VisitMutWith<V>>::visit_mut_with(&mut **self, visitor);
        v
    }

    #[inline]
    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        let v = <T as VisitMutWith<V>>::visit_mut_children_with(&mut **self, visitor);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitMutAstPath {
    #[doc = "Visit a node of type `Alternative`.\n\nBy default, this method calls \
             [`Alternative::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative, __ast_path: &mut AstKindPath) {
        <Alternative as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Alternative >`.\n\nBy default, this method calls [`Vec < \
             Alternative >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_alternatives(
        &mut self,
        node: &mut Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<Alternative> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        <swc_atoms::Atom as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BoundaryAssertion`.\n\nBy default, this method calls \
             [`BoundaryAssertion::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_boundary_assertion(
        &mut self,
        node: &mut BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        <BoundaryAssertion as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BoundaryAssertionKind`.\n\nBy default, this method calls \
             [`BoundaryAssertionKind::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_boundary_assertion_kind(
        &mut self,
        node: &mut BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        <BoundaryAssertionKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CapturingGroup`.\n\nBy default, this method calls \
             [`CapturingGroup::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_capturing_group(
        &mut self,
        node: &mut CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) {
        <CapturingGroup as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Character`.\n\nBy default, this method calls \
             [`Character::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character, __ast_path: &mut AstKindPath) {
        <Character as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClass`.\n\nBy default, this method calls \
             [`CharacterClass::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_character_class(
        &mut self,
        node: &mut CharacterClass,
        __ast_path: &mut AstKindPath,
    ) {
        <CharacterClass as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassContents`.\n\nBy default, this method calls \
             [`CharacterClassContents::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_character_class_contents(
        &mut self,
        node: &mut CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) {
        <CharacterClassContents as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassContentsKind`.\n\nBy default, this method calls \
             [`CharacterClassContentsKind::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_character_class_contents_kind(
        &mut self,
        node: &mut CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) {
        <CharacterClassContentsKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < CharacterClassContents >`.\n\nBy default, this method \
             calls [`Vec < CharacterClassContents >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_character_class_contentss(
        &mut self,
        node: &mut Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<CharacterClassContents> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassEscape`.\n\nBy default, this method calls \
             [`CharacterClassEscape::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_character_class_escape(
        &mut self,
        node: &mut CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) {
        <CharacterClassEscape as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassEscapeKind`.\n\nBy default, this method calls \
             [`CharacterClassEscapeKind::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_character_class_escape_kind(
        &mut self,
        node: &mut CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) {
        <CharacterClassEscapeKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassRange`.\n\nBy default, this method calls \
             [`CharacterClassRange::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_character_class_range(
        &mut self,
        node: &mut CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) {
        <CharacterClassRange as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterKind`.\n\nBy default, this method calls \
             [`CharacterKind::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind, __ast_path: &mut AstKindPath) {
        <CharacterKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Character >`.\n\nBy default, this method calls [`Vec < \
             Character >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>, __ast_path: &mut AstKindPath) {
        <Vec<Character> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassString`.\n\nBy default, this method calls \
             [`ClassString::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString, __ast_path: &mut AstKindPath) {
        <ClassString as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassStringDisjunction`.\n\nBy default, this method calls \
             [`ClassStringDisjunction::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_class_string_disjunction(
        &mut self,
        node: &mut ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) {
        <ClassStringDisjunction as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ClassString >`.\n\nBy default, this method calls [`Vec < \
             ClassString >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_class_strings(
        &mut self,
        node: &mut Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) {
        <Vec<ClassString> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Disjunction`.\n\nBy default, this method calls \
             [`Disjunction::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction, __ast_path: &mut AstKindPath) {
        <Disjunction as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Dot`.\n\nBy default, this method calls \
             [`Dot::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot, __ast_path: &mut AstKindPath) {
        <Dot as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IgnoreGroup`.\n\nBy default, this method calls \
             [`IgnoreGroup::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup, __ast_path: &mut AstKindPath) {
        <IgnoreGroup as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `IndexedReference`.\n\nBy default, this method calls \
             [`IndexedReference::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_indexed_reference(
        &mut self,
        node: &mut IndexedReference,
        __ast_path: &mut AstKindPath,
    ) {
        <IndexedReference as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LookAroundAssertion`.\n\nBy default, this method calls \
             [`LookAroundAssertion::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_look_around_assertion(
        &mut self,
        node: &mut LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        <LookAroundAssertion as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LookAroundAssertionKind`.\n\nBy default, this method calls \
             [`LookAroundAssertionKind::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_look_around_assertion_kind(
        &mut self,
        node: &mut LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        <LookAroundAssertionKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Modifier`.\n\nBy default, this method calls \
             [`Modifier::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier, __ast_path: &mut AstKindPath) {
        <Modifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Modifiers`.\n\nBy default, this method calls \
             [`Modifiers::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers, __ast_path: &mut AstKindPath) {
        <Modifiers as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `NamedReference`.\n\nBy default, this method calls \
             [`NamedReference::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_named_reference(
        &mut self,
        node: &mut NamedReference,
        __ast_path: &mut AstKindPath,
    ) {
        <NamedReference as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<swc_atoms::Atom> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Modifiers >`.\n\nBy default, this method calls \
             [`Option < Modifiers >::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_opt_modifiers(
        &mut self,
        node: &mut Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) {
        <Option<Modifiers> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Pattern`.\n\nBy default, this method calls \
             [`Pattern::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern, __ast_path: &mut AstKindPath) {
        <Pattern as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Quantifier`.\n\nBy default, this method calls \
             [`Quantifier::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier, __ast_path: &mut AstKindPath) {
        <Quantifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        <swc_common::Span as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Term`.\n\nBy default, this method calls \
             [`Term::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term, __ast_path: &mut AstKindPath) {
        <Term as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Term >`.\n\nBy default, this method calls [`Vec < Term \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>, __ast_path: &mut AstKindPath) {
        <Vec<Term> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `UnicodePropertyEscape`.\n\nBy default, this method calls \
             [`UnicodePropertyEscape::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn visit_mut_unicode_property_escape(
        &mut self,
        node: &mut UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) {
        <UnicodePropertyEscape as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, __ast_path,
        )
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for &mut V
where
    V: ?Sized + VisitMutAstPath,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_alternative(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_alternatives(
        &mut self,
        node: &mut Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_alternatives(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_boundary_assertion(
        &mut self,
        node: &mut BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_boundary_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(
        &mut self,
        node: &mut BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_boundary_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_capturing_group(
        &mut self,
        node: &mut CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_capturing_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class(
        &mut self,
        node: &mut CharacterClass,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_contents(
        &mut self,
        node: &mut CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_contents(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(
        &mut self,
        node: &mut CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_contents_kind(
            &mut **self,
            node,
            __ast_path,
        )
    }

    #[inline]
    fn visit_mut_character_class_contentss(
        &mut self,
        node: &mut Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_contentss(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_escape(
        &mut self,
        node: &mut CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_escape(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(
        &mut self,
        node: &mut CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_escape_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_range(
        &mut self,
        node: &mut CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_range(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_characters(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_string(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_string_disjunction(
        &mut self,
        node: &mut ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_class_string_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_strings(
        &mut self,
        node: &mut Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_class_strings(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_dot(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ignore_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_indexed_reference(
        &mut self,
        node: &mut IndexedReference,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_indexed_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_look_around_assertion(
        &mut self,
        node: &mut LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_look_around_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(
        &mut self,
        node: &mut LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_look_around_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_modifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_named_reference(
        &mut self,
        node: &mut NamedReference,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_named_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_modifiers(
        &mut self,
        node: &mut Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pattern(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_quantifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_term(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_terms(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_unicode_property_escape(
        &mut self,
        node: &mut UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_unicode_property_escape(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for Box<V>
where
    V: ?Sized + VisitMutAstPath,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_alternative(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_alternatives(
        &mut self,
        node: &mut Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_alternatives(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_boundary_assertion(
        &mut self,
        node: &mut BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_boundary_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(
        &mut self,
        node: &mut BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_boundary_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_capturing_group(
        &mut self,
        node: &mut CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_capturing_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class(
        &mut self,
        node: &mut CharacterClass,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_contents(
        &mut self,
        node: &mut CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_contents(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(
        &mut self,
        node: &mut CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_contents_kind(
            &mut **self,
            node,
            __ast_path,
        )
    }

    #[inline]
    fn visit_mut_character_class_contentss(
        &mut self,
        node: &mut Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_contentss(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_escape(
        &mut self,
        node: &mut CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_escape(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(
        &mut self,
        node: &mut CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_escape_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_class_range(
        &mut self,
        node: &mut CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_character_class_range(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_characters(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_string(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_string_disjunction(
        &mut self,
        node: &mut ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_class_string_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_class_strings(
        &mut self,
        node: &mut Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_class_strings(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_dot(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ignore_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_indexed_reference(
        &mut self,
        node: &mut IndexedReference,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_indexed_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_look_around_assertion(
        &mut self,
        node: &mut LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_look_around_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(
        &mut self,
        node: &mut LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_look_around_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_modifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_named_reference(
        &mut self,
        node: &mut NamedReference,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_named_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_opt_modifiers(
        &mut self,
        node: &mut Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_opt_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pattern(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_quantifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_term(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_terms(&mut **self, node, __ast_path)
    }

    #[inline]
    fn visit_mut_unicode_property_escape(
        &mut self,
        node: &mut UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) {
        <V as VisitMutAstPath>::visit_mut_unicode_property_escape(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> VisitMutAstPath for ::swc_visit::Either<A, B>
where
    A: VisitMutAstPath,
    B: VisitMutAstPath,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_alternative(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_alternative(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_alternatives(
        &mut self,
        node: &mut Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_alternatives(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_alternatives(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion(
        &mut self,
        node: &mut BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_boundary_assertion(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_boundary_assertion(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(
        &mut self,
        node: &mut BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_boundary_assertion_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_boundary_assertion_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_capturing_group(
        &mut self,
        node: &mut CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_capturing_group(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_capturing_group(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class(
        &mut self,
        node: &mut CharacterClass,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_class(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_class(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_contents(
        &mut self,
        node: &mut CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_class_contents(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_class_contents(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(
        &mut self,
        node: &mut CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_class_contents_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_class_contents_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_contentss(
        &mut self,
        node: &mut Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_class_contentss(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_class_contentss(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_escape(
        &mut self,
        node: &mut CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_class_escape(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_class_escape(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(
        &mut self,
        node: &mut CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_class_escape_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_class_escape_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_class_range(
        &mut self,
        node: &mut CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_class_range(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_class_range(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_character_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_character_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_characters(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_characters(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_string(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_string(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_string_disjunction(
        &mut self,
        node: &mut ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_string_disjunction(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_string_disjunction(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_class_strings(
        &mut self,
        node: &mut Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_strings(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_strings(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_disjunction(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_disjunction(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_dot(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_dot(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ignore_group(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ignore_group(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_indexed_reference(
        &mut self,
        node: &mut IndexedReference,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_indexed_reference(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_indexed_reference(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion(
        &mut self,
        node: &mut LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_look_around_assertion(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_look_around_assertion(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(
        &mut self,
        node: &mut LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_look_around_assertion_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_look_around_assertion_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_modifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_modifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_modifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_modifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_named_reference(
        &mut self,
        node: &mut NamedReference,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_named_reference(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_named_reference(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_opt_modifiers(
        &mut self,
        node: &mut Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_modifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_modifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_pattern(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_pattern(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_quantifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_quantifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_span(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_span(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_term(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_term(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>, __ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_terms(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_terms(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn visit_mut_unicode_property_escape(
        &mut self,
        node: &mut UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_unicode_property_escape(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_unicode_property_escape(visitor, node, __ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for ::swc_visit::Optional<V>
where
    V: VisitMutAstPath,
{
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_alternative(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_alternatives(
        &mut self,
        node: &mut Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_alternatives(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion(
        &mut self,
        node: &mut BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_boundary_assertion(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_boundary_assertion_kind(
        &mut self,
        node: &mut BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_boundary_assertion_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_capturing_group(
        &mut self,
        node: &mut CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_capturing_group(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class(
        &mut self,
        node: &mut CharacterClass,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_class(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_contents(
        &mut self,
        node: &mut CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_class_contents(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_contents_kind(
        &mut self,
        node: &mut CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_class_contents_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_contentss(
        &mut self,
        node: &mut Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_class_contentss(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_escape(
        &mut self,
        node: &mut CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_class_escape(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_escape_kind(
        &mut self,
        node: &mut CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_class_escape_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_class_range(
        &mut self,
        node: &mut CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_class_range(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_character_kind(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_characters(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_string(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_string_disjunction(
        &mut self,
        node: &mut ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_string_disjunction(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_class_strings(
        &mut self,
        node: &mut Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_class_strings(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_disjunction(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_dot(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_ignore_group(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_indexed_reference(
        &mut self,
        node: &mut IndexedReference,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_indexed_reference(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion(
        &mut self,
        node: &mut LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_look_around_assertion(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_look_around_assertion_kind(
        &mut self,
        node: &mut LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_look_around_assertion_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }

    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_modifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_modifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_named_reference(
        &mut self,
        node: &mut NamedReference,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_named_reference(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_atom(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_opt_modifiers(
        &mut self,
        node: &mut Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_opt_modifiers(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_pattern(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_quantifier(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_span(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_term(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>, __ast_path: &mut AstKindPath) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_terms(&mut self.visitor, node, __ast_path)
        } else {
        }
    }

    #[inline]
    fn visit_mut_unicode_property_escape(
        &mut self,
        node: &mut UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            <V as VisitMutAstPath>::visit_mut_unicode_property_escape(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitMutWithAstPath<V: ?Sized + VisitMutAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath);
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Alternative {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_alternative`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_alternative(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Alternative { span, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Alternative(
                        self::fields::AlternativeField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Alternative(
                        self::fields::AlternativeField::Body(usize::MAX),
                    ));
                    <Vec<Term> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BoundaryAssertion {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_boundary_assertion`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_boundary_assertion(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BoundaryAssertion { span, kind } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BoundaryAssertion(
                        self::fields::BoundaryAssertionField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BoundaryAssertion(
                        self::fields::BoundaryAssertionField::Kind,
                    ));
                    <BoundaryAssertionKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BoundaryAssertionKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_boundary_assertion_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_boundary_assertion_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            BoundaryAssertionKind::Start => {}
            BoundaryAssertionKind::End => {}
            BoundaryAssertionKind::Boundary => {}
            BoundaryAssertionKind::NegativeBoundary => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CapturingGroup {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_capturing_group`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_capturing_group(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CapturingGroup { span, name, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CapturingGroup(
                        self::fields::CapturingGroupField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CapturingGroup(
                        self::fields::CapturingGroupField::Name,
                    ));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CapturingGroup(
                        self::fields::CapturingGroupField::Body,
                    ));
                    <Disjunction as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Character {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Character { span, kind, value } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Character(self::fields::CharacterField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Character(self::fields::CharacterField::Kind));
                    <CharacterKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CharacterClass {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_class`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_class(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CharacterClass {
                span,
                negative,
                strings,
                kind,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClass(
                        self::fields::CharacterClassField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClass(
                        self::fields::CharacterClassField::Kind,
                    ));
                    <CharacterClassContentsKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClass(
                        self::fields::CharacterClassField::Body(usize::MAX),
                    ));
                    <Vec<CharacterClassContents> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CharacterClassContents {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_class_contents`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_class_contents(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CharacterClassContents::CharacterClassRange { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::CharacterClassRange,
                ));
                <Box<CharacterClassRange> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::CharacterClassEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::CharacterClassEscape,
                ));
                <Box<CharacterClassEscape> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::UnicodePropertyEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::UnicodePropertyEscape,
                ));
                <Box<UnicodePropertyEscape> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::Character { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::Character,
                ));
                <Box<Character> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::NestedCharacterClass { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::NestedCharacterClass,
                ));
                <Box<CharacterClass> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            CharacterClassContents::ClassStringDisjunction { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::ClassStringDisjunction,
                ));
                <Box<ClassStringDisjunction> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CharacterClassContentsKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_class_contents_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_class_contents_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CharacterClassContentsKind::Union => {}
            CharacterClassContentsKind::Intersection => {}
            CharacterClassContentsKind::Subtraction => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CharacterClassEscape {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_class_escape`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_class_escape(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CharacterClassEscape { span, kind } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::CharacterClassEscape(
                            self::fields::CharacterClassEscapeField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::CharacterClassEscape(
                            self::fields::CharacterClassEscapeField::Kind,
                        ));
                    <CharacterClassEscapeKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CharacterClassEscapeKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_class_escape_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_class_escape_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CharacterClassEscapeKind::D => {}
            CharacterClassEscapeKind::NegativeD => {}
            CharacterClassEscapeKind::S => {}
            CharacterClassEscapeKind::NegativeS => {}
            CharacterClassEscapeKind::W => {}
            CharacterClassEscapeKind::NegativeW => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CharacterClassRange {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_class_range`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_class_range(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CharacterClassRange { span, min, max } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassRange(
                        self::fields::CharacterClassRangeField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassRange(
                        self::fields::CharacterClassRangeField::Min,
                    ));
                    <Character as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        min,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassRange(
                        self::fields::CharacterClassRangeField::Max,
                    ));
                    <Character as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        max,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CharacterKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            CharacterKind::ControlLetter => {}
            CharacterKind::HexadecimalEscape => {}
            CharacterKind::Identifier => {}
            CharacterKind::Null => {}
            CharacterKind::Octal1 => {}
            CharacterKind::Octal2 => {}
            CharacterKind::Octal3 => {}
            CharacterKind::SingleEscape => {}
            CharacterKind::Symbol => {}
            CharacterKind::UnicodeEscape => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassString {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_string`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_string(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ClassString {
                span,
                strings,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassString(
                        self::fields::ClassStringField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassString(
                        self::fields::ClassStringField::Body(usize::MAX),
                    ));
                    <Vec<Character> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassStringDisjunction {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_string_disjunction`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_string_disjunction(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            ClassStringDisjunction {
                span,
                strings,
                body,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ClassStringDisjunction(
                            self::fields::ClassStringDisjunctionField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ClassStringDisjunction(
                            self::fields::ClassStringDisjunctionField::Body(usize::MAX),
                        ));
                    <Vec<ClassString> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Disjunction {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_disjunction`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_disjunction(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Disjunction { span, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Disjunction(
                        self::fields::DisjunctionField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Disjunction(
                        self::fields::DisjunctionField::Body(usize::MAX),
                    ));
                    <Vec<Alternative> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Dot {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_dot`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_dot(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Dot { span } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Dot(self::fields::DotField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for IgnoreGroup {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ignore_group`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ignore_group(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            IgnoreGroup {
                span,
                modifiers,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IgnoreGroup(
                        self::fields::IgnoreGroupField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IgnoreGroup(
                        self::fields::IgnoreGroupField::Modifiers,
                    ));
                    <Option<Modifiers> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        modifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IgnoreGroup(
                        self::fields::IgnoreGroupField::Body,
                    ));
                    <Disjunction as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for IndexedReference {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_indexed_reference`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_indexed_reference(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            IndexedReference { span, index } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IndexedReference(
                        self::fields::IndexedReferenceField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for LookAroundAssertion {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_look_around_assertion`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_look_around_assertion(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            LookAroundAssertion { span, kind, body } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LookAroundAssertion(
                        self::fields::LookAroundAssertionField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LookAroundAssertion(
                        self::fields::LookAroundAssertionField::Kind,
                    ));
                    <LookAroundAssertionKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LookAroundAssertion(
                        self::fields::LookAroundAssertionField::Body,
                    ));
                    <Disjunction as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for LookAroundAssertionKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_look_around_assertion_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_look_around_assertion_kind(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            LookAroundAssertionKind::Lookahead => {}
            LookAroundAssertionKind::NegativeLookahead => {}
            LookAroundAssertionKind::Lookbehind => {}
            LookAroundAssertionKind::NegativeLookbehind => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Modifiers {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_modifiers`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_modifiers(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Modifiers {
                span,
                enabling,
                disabling,
            } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Modifiers(self::fields::ModifiersField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Modifiers(
                        self::fields::ModifiersField::Enabling,
                    ));
                    <Modifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        enabling,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Modifiers(
                        self::fields::ModifiersField::Disabling,
                    ));
                    <Modifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        disabling,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for NamedReference {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_named_reference`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_named_reference(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            NamedReference { span, name } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedReference(
                        self::fields::NamedReferenceField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedReference(
                        self::fields::NamedReferenceField::Name,
                    ));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Pattern {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_pattern`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pattern(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Pattern { span, body } => {
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Pattern(self::fields::PatternField::Span));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Pattern(self::fields::PatternField::Body));
                    <Disjunction as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Quantifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_quantifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_quantifier(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Quantifier {
                span,
                min,
                max,
                greedy,
                body,
            } => {
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Quantifier(
                        self::fields::QuantifierField::Span,
                    ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Quantifier(
                        self::fields::QuantifierField::Body,
                    ));
                    <Term as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Term {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_term`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_term(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Term::BoundaryAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::BoundaryAssertion,
                ));
                <Box<BoundaryAssertion> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::LookAroundAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::LookAroundAssertion,
                ));
                <Box<LookAroundAssertion> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::Quantifier { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Term(self::fields::TermField::Quantifier));
                <Box<Quantifier> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::Character { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Term(self::fields::TermField::Character));
                <Box<Character> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::Dot { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Term(self::fields::TermField::Dot));
                <Dot as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::CharacterClassEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::CharacterClassEscape,
                ));
                <Box<CharacterClassEscape> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::UnicodePropertyEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::UnicodePropertyEscape,
                ));
                <Box<UnicodePropertyEscape> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::CharacterClass { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::CharacterClass));
                <Box<CharacterClass> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::CapturingGroup { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::CapturingGroup));
                <Box<CapturingGroup> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::IgnoreGroup { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::IgnoreGroup));
                <Box<IgnoreGroup> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::IndexedReference { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::IndexedReference,
                ));
                <Box<IndexedReference> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
            Term::NamedReference { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::NamedReference));
                <Box<NamedReference> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UnicodePropertyEscape {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_unicode_property_escape`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unicode_property_escape(visitor, self, __ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            UnicodePropertyEscape {
                span,
                negative,
                strings,
                name,
                value,
            } => {
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::UnicodePropertyEscape(
                            self::fields::UnicodePropertyEscapeField::Span,
                        ));
                    <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::UnicodePropertyEscape(
                            self::fields::UnicodePropertyEscapeField::Name,
                        ));
                    <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::UnicodePropertyEscape(
                            self::fields::UnicodePropertyEscapeField::Value,
                        ));
                    <Option<swc_atoms::Atom> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Alternative> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_alternatives`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_alternatives(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Alternative as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<CharacterClassContents> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_character_class_contentss`] with `self`. (Extra \
             impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_character_class_contentss(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <CharacterClassContents as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Character> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_characters`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_characters(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Character as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ClassString> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_strings`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_strings(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <ClassString as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Modifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_modifier`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_modifier(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Modifiers> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_modifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_modifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Modifiers as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                inner, visitor, __ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_span`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_span(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Term> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_terms`] with `self`. (Extra impl)"]
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_terms(visitor, self, __ast_path)
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        self.iter_mut().enumerate().for_each(|(__idx, item)| {
            let mut __ast_path = __ast_path.with_index_guard(__idx);
            <Term as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                item,
                visitor,
                &mut *__ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitMutWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitMutAstPath,
    T: VisitMutWithAstPath<V>,
{
    #[inline]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        let v = <T as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
            &mut **self,
            visitor,
            __ast_path,
        );
        v
    }

    #[inline]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, __ast_path: &mut AstKindPath) {
        let v = <T as VisitMutWithAstPath<V>>::visit_mut_children_with_ast_path(
            &mut **self,
            visitor,
            __ast_path,
        );
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
pub trait Fold {
    #[doc = "Visit a node of type `Alternative`.\n\nBy default, this method calls \
             [`Alternative::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_alternative(&mut self, node: Alternative) -> Alternative {
        <Alternative as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Alternative >`.\n\nBy default, this method calls [`Vec < \
             Alternative >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_alternatives(&mut self, node: Vec<Alternative>) -> Vec<Alternative> {
        <Vec<Alternative> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        <swc_atoms::Atom as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BoundaryAssertion`.\n\nBy default, this method calls \
             [`BoundaryAssertion::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_boundary_assertion(&mut self, node: BoundaryAssertion) -> BoundaryAssertion {
        <BoundaryAssertion as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BoundaryAssertionKind`.\n\nBy default, this method calls \
             [`BoundaryAssertionKind::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
    ) -> BoundaryAssertionKind {
        <BoundaryAssertionKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CapturingGroup`.\n\nBy default, this method calls \
             [`CapturingGroup::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_capturing_group(&mut self, node: CapturingGroup) -> CapturingGroup {
        <CapturingGroup as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Character`.\n\nBy default, this method calls \
             [`Character::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_character(&mut self, node: Character) -> Character {
        <Character as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClass`.\n\nBy default, this method calls \
             [`CharacterClass::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_character_class(&mut self, node: CharacterClass) -> CharacterClass {
        <CharacterClass as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassContents`.\n\nBy default, this method calls \
             [`CharacterClassContents::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
    ) -> CharacterClassContents {
        <CharacterClassContents as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassContentsKind`.\n\nBy default, this method calls \
             [`CharacterClassContentsKind::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
    ) -> CharacterClassContentsKind {
        <CharacterClassContentsKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < CharacterClassContents >`.\n\nBy default, this method \
             calls [`Vec < CharacterClassContents >::fold_children_with`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
    ) -> Vec<CharacterClassContents> {
        <Vec<CharacterClassContents> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassEscape`.\n\nBy default, this method calls \
             [`CharacterClassEscape::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_character_class_escape(&mut self, node: CharacterClassEscape) -> CharacterClassEscape {
        <CharacterClassEscape as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassEscapeKind`.\n\nBy default, this method calls \
             [`CharacterClassEscapeKind::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
    ) -> CharacterClassEscapeKind {
        <CharacterClassEscapeKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterClassRange`.\n\nBy default, this method calls \
             [`CharacterClassRange::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_character_class_range(&mut self, node: CharacterClassRange) -> CharacterClassRange {
        <CharacterClassRange as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CharacterKind`.\n\nBy default, this method calls \
             [`CharacterKind::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_character_kind(&mut self, node: CharacterKind) -> CharacterKind {
        <CharacterKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Character >`.\n\nBy default, this method calls [`Vec < \
             Character >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_characters(&mut self, node: Vec<Character>) -> Vec<Character> {
        <Vec<Character> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassString`.\n\nBy default, this method calls \
             [`ClassString::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_string(&mut self, node: ClassString) -> ClassString {
        <ClassString as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassStringDisjunction`.\n\nBy default, this method calls \
             [`ClassStringDisjunction::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
    ) -> ClassStringDisjunction {
        <ClassStringDisjunction as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassString >`.\n\nBy default, this method calls [`Vec < \
             ClassString >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_class_strings(&mut self, node: Vec<ClassString>) -> Vec<ClassString> {
        <Vec<ClassString> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Disjunction`.\n\nBy default, this method calls \
             [`Disjunction::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction) -> Disjunction {
        <Disjunction as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Dot`.\n\nBy default, this method calls \
             [`Dot::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_dot(&mut self, node: Dot) -> Dot {
        <Dot as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `IgnoreGroup`.\n\nBy default, this method calls \
             [`IgnoreGroup::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_ignore_group(&mut self, node: IgnoreGroup) -> IgnoreGroup {
        <IgnoreGroup as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `IndexedReference`.\n\nBy default, this method calls \
             [`IndexedReference::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_indexed_reference(&mut self, node: IndexedReference) -> IndexedReference {
        <IndexedReference as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `LookAroundAssertion`.\n\nBy default, this method calls \
             [`LookAroundAssertion::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_look_around_assertion(&mut self, node: LookAroundAssertion) -> LookAroundAssertion {
        <LookAroundAssertion as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `LookAroundAssertionKind`.\n\nBy default, this method calls \
             [`LookAroundAssertionKind::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
    ) -> LookAroundAssertionKind {
        <LookAroundAssertionKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Modifier`.\n\nBy default, this method calls \
             [`Modifier::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_modifier(&mut self, node: Modifier) -> Modifier {
        <Modifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Modifiers`.\n\nBy default, this method calls \
             [`Modifiers::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers) -> Modifiers {
        <Modifiers as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedReference`.\n\nBy default, this method calls \
             [`NamedReference::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_named_reference(&mut self, node: NamedReference) -> NamedReference {
        <NamedReference as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        <Option<swc_atoms::Atom> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Modifiers >`.\n\nBy default, this method calls \
             [`Option < Modifiers >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_opt_modifiers(&mut self, node: Option<Modifiers>) -> Option<Modifiers> {
        <Option<Modifiers> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pattern`.\n\nBy default, this method calls \
             [`Pattern::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_pattern(&mut self, node: Pattern) -> Pattern {
        <Pattern as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Quantifier`.\n\nBy default, this method calls \
             [`Quantifier::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier) -> Quantifier {
        <Quantifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        <swc_common::Span as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Term`.\n\nBy default, this method calls \
             [`Term::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_term(&mut self, node: Term) -> Term {
        <Term as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Term >`.\n\nBy default, this method calls [`Vec < Term \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>) -> Vec<Term> {
        <Vec<Term> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnicodePropertyEscape`.\n\nBy default, this method calls \
             [`UnicodePropertyEscape::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
    ) -> UnicodePropertyEscape {
        <UnicodePropertyEscape as FoldWith<Self>>::fold_children_with(node, self)
    }
}
impl<V> Fold for &mut V
where
    V: ?Sized + Fold,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative) -> Alternative {
        <V as Fold>::fold_alternative(&mut **self, node)
    }

    #[inline]
    fn fold_alternatives(&mut self, node: Vec<Alternative>) -> Vec<Alternative> {
        <V as Fold>::fold_alternatives(&mut **self, node)
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        <V as Fold>::fold_atom(&mut **self, node)
    }

    #[inline]
    fn fold_boundary_assertion(&mut self, node: BoundaryAssertion) -> BoundaryAssertion {
        <V as Fold>::fold_boundary_assertion(&mut **self, node)
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
    ) -> BoundaryAssertionKind {
        <V as Fold>::fold_boundary_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn fold_capturing_group(&mut self, node: CapturingGroup) -> CapturingGroup {
        <V as Fold>::fold_capturing_group(&mut **self, node)
    }

    #[inline]
    fn fold_character(&mut self, node: Character) -> Character {
        <V as Fold>::fold_character(&mut **self, node)
    }

    #[inline]
    fn fold_character_class(&mut self, node: CharacterClass) -> CharacterClass {
        <V as Fold>::fold_character_class(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
    ) -> CharacterClassContents {
        <V as Fold>::fold_character_class_contents(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
    ) -> CharacterClassContentsKind {
        <V as Fold>::fold_character_class_contents_kind(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
    ) -> Vec<CharacterClassContents> {
        <V as Fold>::fold_character_class_contentss(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_escape(&mut self, node: CharacterClassEscape) -> CharacterClassEscape {
        <V as Fold>::fold_character_class_escape(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
    ) -> CharacterClassEscapeKind {
        <V as Fold>::fold_character_class_escape_kind(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_range(&mut self, node: CharacterClassRange) -> CharacterClassRange {
        <V as Fold>::fold_character_class_range(&mut **self, node)
    }

    #[inline]
    fn fold_character_kind(&mut self, node: CharacterKind) -> CharacterKind {
        <V as Fold>::fold_character_kind(&mut **self, node)
    }

    #[inline]
    fn fold_characters(&mut self, node: Vec<Character>) -> Vec<Character> {
        <V as Fold>::fold_characters(&mut **self, node)
    }

    #[inline]
    fn fold_class_string(&mut self, node: ClassString) -> ClassString {
        <V as Fold>::fold_class_string(&mut **self, node)
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
    ) -> ClassStringDisjunction {
        <V as Fold>::fold_class_string_disjunction(&mut **self, node)
    }

    #[inline]
    fn fold_class_strings(&mut self, node: Vec<ClassString>) -> Vec<ClassString> {
        <V as Fold>::fold_class_strings(&mut **self, node)
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction) -> Disjunction {
        <V as Fold>::fold_disjunction(&mut **self, node)
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot) -> Dot {
        <V as Fold>::fold_dot(&mut **self, node)
    }

    #[inline]
    fn fold_ignore_group(&mut self, node: IgnoreGroup) -> IgnoreGroup {
        <V as Fold>::fold_ignore_group(&mut **self, node)
    }

    #[inline]
    fn fold_indexed_reference(&mut self, node: IndexedReference) -> IndexedReference {
        <V as Fold>::fold_indexed_reference(&mut **self, node)
    }

    #[inline]
    fn fold_look_around_assertion(&mut self, node: LookAroundAssertion) -> LookAroundAssertion {
        <V as Fold>::fold_look_around_assertion(&mut **self, node)
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
    ) -> LookAroundAssertionKind {
        <V as Fold>::fold_look_around_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier) -> Modifier {
        <V as Fold>::fold_modifier(&mut **self, node)
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers) -> Modifiers {
        <V as Fold>::fold_modifiers(&mut **self, node)
    }

    #[inline]
    fn fold_named_reference(&mut self, node: NamedReference) -> NamedReference {
        <V as Fold>::fold_named_reference(&mut **self, node)
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        <V as Fold>::fold_opt_atom(&mut **self, node)
    }

    #[inline]
    fn fold_opt_modifiers(&mut self, node: Option<Modifiers>) -> Option<Modifiers> {
        <V as Fold>::fold_opt_modifiers(&mut **self, node)
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern) -> Pattern {
        <V as Fold>::fold_pattern(&mut **self, node)
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier) -> Quantifier {
        <V as Fold>::fold_quantifier(&mut **self, node)
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        <V as Fold>::fold_span(&mut **self, node)
    }

    #[inline]
    fn fold_term(&mut self, node: Term) -> Term {
        <V as Fold>::fold_term(&mut **self, node)
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>) -> Vec<Term> {
        <V as Fold>::fold_terms(&mut **self, node)
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
    ) -> UnicodePropertyEscape {
        <V as Fold>::fold_unicode_property_escape(&mut **self, node)
    }
}
impl<V> Fold for Box<V>
where
    V: ?Sized + Fold,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative) -> Alternative {
        <V as Fold>::fold_alternative(&mut **self, node)
    }

    #[inline]
    fn fold_alternatives(&mut self, node: Vec<Alternative>) -> Vec<Alternative> {
        <V as Fold>::fold_alternatives(&mut **self, node)
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        <V as Fold>::fold_atom(&mut **self, node)
    }

    #[inline]
    fn fold_boundary_assertion(&mut self, node: BoundaryAssertion) -> BoundaryAssertion {
        <V as Fold>::fold_boundary_assertion(&mut **self, node)
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
    ) -> BoundaryAssertionKind {
        <V as Fold>::fold_boundary_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn fold_capturing_group(&mut self, node: CapturingGroup) -> CapturingGroup {
        <V as Fold>::fold_capturing_group(&mut **self, node)
    }

    #[inline]
    fn fold_character(&mut self, node: Character) -> Character {
        <V as Fold>::fold_character(&mut **self, node)
    }

    #[inline]
    fn fold_character_class(&mut self, node: CharacterClass) -> CharacterClass {
        <V as Fold>::fold_character_class(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
    ) -> CharacterClassContents {
        <V as Fold>::fold_character_class_contents(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
    ) -> CharacterClassContentsKind {
        <V as Fold>::fold_character_class_contents_kind(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
    ) -> Vec<CharacterClassContents> {
        <V as Fold>::fold_character_class_contentss(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_escape(&mut self, node: CharacterClassEscape) -> CharacterClassEscape {
        <V as Fold>::fold_character_class_escape(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
    ) -> CharacterClassEscapeKind {
        <V as Fold>::fold_character_class_escape_kind(&mut **self, node)
    }

    #[inline]
    fn fold_character_class_range(&mut self, node: CharacterClassRange) -> CharacterClassRange {
        <V as Fold>::fold_character_class_range(&mut **self, node)
    }

    #[inline]
    fn fold_character_kind(&mut self, node: CharacterKind) -> CharacterKind {
        <V as Fold>::fold_character_kind(&mut **self, node)
    }

    #[inline]
    fn fold_characters(&mut self, node: Vec<Character>) -> Vec<Character> {
        <V as Fold>::fold_characters(&mut **self, node)
    }

    #[inline]
    fn fold_class_string(&mut self, node: ClassString) -> ClassString {
        <V as Fold>::fold_class_string(&mut **self, node)
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
    ) -> ClassStringDisjunction {
        <V as Fold>::fold_class_string_disjunction(&mut **self, node)
    }

    #[inline]
    fn fold_class_strings(&mut self, node: Vec<ClassString>) -> Vec<ClassString> {
        <V as Fold>::fold_class_strings(&mut **self, node)
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction) -> Disjunction {
        <V as Fold>::fold_disjunction(&mut **self, node)
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot) -> Dot {
        <V as Fold>::fold_dot(&mut **self, node)
    }

    #[inline]
    fn fold_ignore_group(&mut self, node: IgnoreGroup) -> IgnoreGroup {
        <V as Fold>::fold_ignore_group(&mut **self, node)
    }

    #[inline]
    fn fold_indexed_reference(&mut self, node: IndexedReference) -> IndexedReference {
        <V as Fold>::fold_indexed_reference(&mut **self, node)
    }

    #[inline]
    fn fold_look_around_assertion(&mut self, node: LookAroundAssertion) -> LookAroundAssertion {
        <V as Fold>::fold_look_around_assertion(&mut **self, node)
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
    ) -> LookAroundAssertionKind {
        <V as Fold>::fold_look_around_assertion_kind(&mut **self, node)
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier) -> Modifier {
        <V as Fold>::fold_modifier(&mut **self, node)
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers) -> Modifiers {
        <V as Fold>::fold_modifiers(&mut **self, node)
    }

    #[inline]
    fn fold_named_reference(&mut self, node: NamedReference) -> NamedReference {
        <V as Fold>::fold_named_reference(&mut **self, node)
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        <V as Fold>::fold_opt_atom(&mut **self, node)
    }

    #[inline]
    fn fold_opt_modifiers(&mut self, node: Option<Modifiers>) -> Option<Modifiers> {
        <V as Fold>::fold_opt_modifiers(&mut **self, node)
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern) -> Pattern {
        <V as Fold>::fold_pattern(&mut **self, node)
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier) -> Quantifier {
        <V as Fold>::fold_quantifier(&mut **self, node)
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        <V as Fold>::fold_span(&mut **self, node)
    }

    #[inline]
    fn fold_term(&mut self, node: Term) -> Term {
        <V as Fold>::fold_term(&mut **self, node)
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>) -> Vec<Term> {
        <V as Fold>::fold_terms(&mut **self, node)
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
    ) -> UnicodePropertyEscape {
        <V as Fold>::fold_unicode_property_escape(&mut **self, node)
    }
}
impl<A, B> Fold for ::swc_visit::Either<A, B>
where
    A: Fold,
    B: Fold,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative) -> Alternative {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_alternative(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_alternative(visitor, node),
        }
    }

    #[inline]
    fn fold_alternatives(&mut self, node: Vec<Alternative>) -> Vec<Alternative> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_alternatives(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_alternatives(visitor, node),
        }
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_atom(visitor, node),
        }
    }

    #[inline]
    fn fold_boundary_assertion(&mut self, node: BoundaryAssertion) -> BoundaryAssertion {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_boundary_assertion(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_boundary_assertion(visitor, node),
        }
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
    ) -> BoundaryAssertionKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_boundary_assertion_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_boundary_assertion_kind(visitor, node),
        }
    }

    #[inline]
    fn fold_capturing_group(&mut self, node: CapturingGroup) -> CapturingGroup {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_capturing_group(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_capturing_group(visitor, node),
        }
    }

    #[inline]
    fn fold_character(&mut self, node: Character) -> Character {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_character(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_character(visitor, node),
        }
    }

    #[inline]
    fn fold_character_class(&mut self, node: CharacterClass) -> CharacterClass {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_character_class(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_character_class(visitor, node),
        }
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
    ) -> CharacterClassContents {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_character_class_contents(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_character_class_contents(visitor, node),
        }
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
    ) -> CharacterClassContentsKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                Fold::fold_character_class_contents_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Fold::fold_character_class_contents_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
    ) -> Vec<CharacterClassContents> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_character_class_contentss(visitor, node),
            swc_visit::Either::Right(visitor) => {
                Fold::fold_character_class_contentss(visitor, node)
            }
        }
    }

    #[inline]
    fn fold_character_class_escape(&mut self, node: CharacterClassEscape) -> CharacterClassEscape {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_character_class_escape(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_character_class_escape(visitor, node),
        }
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
    ) -> CharacterClassEscapeKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                Fold::fold_character_class_escape_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Fold::fold_character_class_escape_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn fold_character_class_range(&mut self, node: CharacterClassRange) -> CharacterClassRange {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_character_class_range(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_character_class_range(visitor, node),
        }
    }

    #[inline]
    fn fold_character_kind(&mut self, node: CharacterKind) -> CharacterKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_character_kind(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_character_kind(visitor, node),
        }
    }

    #[inline]
    fn fold_characters(&mut self, node: Vec<Character>) -> Vec<Character> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_characters(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_characters(visitor, node),
        }
    }

    #[inline]
    fn fold_class_string(&mut self, node: ClassString) -> ClassString {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_string(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_string(visitor, node),
        }
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
    ) -> ClassStringDisjunction {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_string_disjunction(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_string_disjunction(visitor, node),
        }
    }

    #[inline]
    fn fold_class_strings(&mut self, node: Vec<ClassString>) -> Vec<ClassString> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_strings(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_strings(visitor, node),
        }
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction) -> Disjunction {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_disjunction(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_disjunction(visitor, node),
        }
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot) -> Dot {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_dot(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_dot(visitor, node),
        }
    }

    #[inline]
    fn fold_ignore_group(&mut self, node: IgnoreGroup) -> IgnoreGroup {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ignore_group(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ignore_group(visitor, node),
        }
    }

    #[inline]
    fn fold_indexed_reference(&mut self, node: IndexedReference) -> IndexedReference {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_indexed_reference(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_indexed_reference(visitor, node),
        }
    }

    #[inline]
    fn fold_look_around_assertion(&mut self, node: LookAroundAssertion) -> LookAroundAssertion {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_look_around_assertion(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_look_around_assertion(visitor, node),
        }
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
    ) -> LookAroundAssertionKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                Fold::fold_look_around_assertion_kind(visitor, node)
            }
            swc_visit::Either::Right(visitor) => {
                Fold::fold_look_around_assertion_kind(visitor, node)
            }
        }
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier) -> Modifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_modifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_modifier(visitor, node),
        }
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers) -> Modifiers {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_modifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_modifiers(visitor, node),
        }
    }

    #[inline]
    fn fold_named_reference(&mut self, node: NamedReference) -> NamedReference {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_named_reference(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_named_reference(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_atom(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_atom(visitor, node),
        }
    }

    #[inline]
    fn fold_opt_modifiers(&mut self, node: Option<Modifiers>) -> Option<Modifiers> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_modifiers(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_modifiers(visitor, node),
        }
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern) -> Pattern {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_pattern(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_pattern(visitor, node),
        }
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier) -> Quantifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_quantifier(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_quantifier(visitor, node),
        }
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_span(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_span(visitor, node),
        }
    }

    #[inline]
    fn fold_term(&mut self, node: Term) -> Term {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_term(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_term(visitor, node),
        }
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>) -> Vec<Term> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_terms(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_terms(visitor, node),
        }
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
    ) -> UnicodePropertyEscape {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_unicode_property_escape(visitor, node),
            swc_visit::Either::Right(visitor) => Fold::fold_unicode_property_escape(visitor, node),
        }
    }
}
impl<V> Fold for ::swc_visit::Optional<V>
where
    V: Fold,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative) -> Alternative {
        if self.enabled {
            <V as Fold>::fold_alternative(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_alternatives(&mut self, node: Vec<Alternative>) -> Vec<Alternative> {
        if self.enabled {
            <V as Fold>::fold_alternatives(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        if self.enabled {
            <V as Fold>::fold_atom(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_boundary_assertion(&mut self, node: BoundaryAssertion) -> BoundaryAssertion {
        if self.enabled {
            <V as Fold>::fold_boundary_assertion(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
    ) -> BoundaryAssertionKind {
        if self.enabled {
            <V as Fold>::fold_boundary_assertion_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_capturing_group(&mut self, node: CapturingGroup) -> CapturingGroup {
        if self.enabled {
            <V as Fold>::fold_capturing_group(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character(&mut self, node: Character) -> Character {
        if self.enabled {
            <V as Fold>::fold_character(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class(&mut self, node: CharacterClass) -> CharacterClass {
        if self.enabled {
            <V as Fold>::fold_character_class(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
    ) -> CharacterClassContents {
        if self.enabled {
            <V as Fold>::fold_character_class_contents(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
    ) -> CharacterClassContentsKind {
        if self.enabled {
            <V as Fold>::fold_character_class_contents_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
    ) -> Vec<CharacterClassContents> {
        if self.enabled {
            <V as Fold>::fold_character_class_contentss(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_escape(&mut self, node: CharacterClassEscape) -> CharacterClassEscape {
        if self.enabled {
            <V as Fold>::fold_character_class_escape(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
    ) -> CharacterClassEscapeKind {
        if self.enabled {
            <V as Fold>::fold_character_class_escape_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_range(&mut self, node: CharacterClassRange) -> CharacterClassRange {
        if self.enabled {
            <V as Fold>::fold_character_class_range(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_kind(&mut self, node: CharacterKind) -> CharacterKind {
        if self.enabled {
            <V as Fold>::fold_character_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_characters(&mut self, node: Vec<Character>) -> Vec<Character> {
        if self.enabled {
            <V as Fold>::fold_characters(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_string(&mut self, node: ClassString) -> ClassString {
        if self.enabled {
            <V as Fold>::fold_class_string(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
    ) -> ClassStringDisjunction {
        if self.enabled {
            <V as Fold>::fold_class_string_disjunction(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_strings(&mut self, node: Vec<ClassString>) -> Vec<ClassString> {
        if self.enabled {
            <V as Fold>::fold_class_strings(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction) -> Disjunction {
        if self.enabled {
            <V as Fold>::fold_disjunction(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot) -> Dot {
        if self.enabled {
            <V as Fold>::fold_dot(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_ignore_group(&mut self, node: IgnoreGroup) -> IgnoreGroup {
        if self.enabled {
            <V as Fold>::fold_ignore_group(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_indexed_reference(&mut self, node: IndexedReference) -> IndexedReference {
        if self.enabled {
            <V as Fold>::fold_indexed_reference(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_look_around_assertion(&mut self, node: LookAroundAssertion) -> LookAroundAssertion {
        if self.enabled {
            <V as Fold>::fold_look_around_assertion(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
    ) -> LookAroundAssertionKind {
        if self.enabled {
            <V as Fold>::fold_look_around_assertion_kind(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier) -> Modifier {
        if self.enabled {
            <V as Fold>::fold_modifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers) -> Modifiers {
        if self.enabled {
            <V as Fold>::fold_modifiers(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_named_reference(&mut self, node: NamedReference) -> NamedReference {
        if self.enabled {
            <V as Fold>::fold_named_reference(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        if self.enabled {
            <V as Fold>::fold_opt_atom(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_modifiers(&mut self, node: Option<Modifiers>) -> Option<Modifiers> {
        if self.enabled {
            <V as Fold>::fold_opt_modifiers(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern) -> Pattern {
        if self.enabled {
            <V as Fold>::fold_pattern(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier) -> Quantifier {
        if self.enabled {
            <V as Fold>::fold_quantifier(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        if self.enabled {
            <V as Fold>::fold_span(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_term(&mut self, node: Term) -> Term {
        if self.enabled {
            <V as Fold>::fold_term(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>) -> Vec<Term> {
        if self.enabled {
            <V as Fold>::fold_terms(&mut self.visitor, node)
        } else {
            node
        }
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
    ) -> UnicodePropertyEscape {
        if self.enabled {
            <V as Fold>::fold_unicode_property_escape(&mut self.visitor, node)
        } else {
            node
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait FoldWith<V: ?Sized + Fold> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn fold_with(self, visitor: &mut V) -> Self;
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn fold_children_with(self, visitor: &mut V) -> Self;
}
impl<V: ?Sized + Fold> FoldWith<V> for Alternative {
    #[doc = "Calls [Fold`::fold_alternative`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_alternative(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Alternative { span, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Vec<Term> as FoldWith<V>>::fold_with(body, visitor) };
                Alternative { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BoundaryAssertion {
    #[doc = "Calls [Fold`::fold_boundary_assertion`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_boundary_assertion(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BoundaryAssertion { span, kind } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let kind = { <BoundaryAssertionKind as FoldWith<V>>::fold_with(kind, visitor) };
                BoundaryAssertion { span, kind }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BoundaryAssertionKind {
    #[doc = "Calls [Fold`::fold_boundary_assertion_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_boundary_assertion_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BoundaryAssertionKind::Start => BoundaryAssertionKind::Start,
            BoundaryAssertionKind::End => BoundaryAssertionKind::End,
            BoundaryAssertionKind::Boundary => BoundaryAssertionKind::Boundary,
            BoundaryAssertionKind::NegativeBoundary => BoundaryAssertionKind::NegativeBoundary,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CapturingGroup {
    #[doc = "Calls [Fold`::fold_capturing_group`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_capturing_group(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CapturingGroup { span, name, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(name, visitor) };
                let body = { <Disjunction as FoldWith<V>>::fold_with(body, visitor) };
                CapturingGroup { span, name, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Character {
    #[doc = "Calls [Fold`::fold_character`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Character { span, kind, value } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let kind = { <CharacterKind as FoldWith<V>>::fold_with(kind, visitor) };
                Character { span, kind, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CharacterClass {
    #[doc = "Calls [Fold`::fold_character_class`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_class(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CharacterClass {
                span,
                negative,
                strings,
                kind,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let kind =
                    { <CharacterClassContentsKind as FoldWith<V>>::fold_with(kind, visitor) };
                let body =
                    { <Vec<CharacterClassContents> as FoldWith<V>>::fold_with(body, visitor) };
                CharacterClass {
                    span,
                    negative,
                    strings,
                    kind,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CharacterClassContents {
    #[doc = "Calls [Fold`::fold_character_class_contents`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_class_contents(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CharacterClassContents::CharacterClassRange { 0: _field_0 } => {
                let _field_0 =
                    <Box<CharacterClassRange> as FoldWith<V>>::fold_with(_field_0, visitor);
                CharacterClassContents::CharacterClassRange { 0: _field_0 }
            }
            CharacterClassContents::CharacterClassEscape { 0: _field_0 } => {
                let _field_0 =
                    <Box<CharacterClassEscape> as FoldWith<V>>::fold_with(_field_0, visitor);
                CharacterClassContents::CharacterClassEscape { 0: _field_0 }
            }
            CharacterClassContents::UnicodePropertyEscape { 0: _field_0 } => {
                let _field_0 =
                    <Box<UnicodePropertyEscape> as FoldWith<V>>::fold_with(_field_0, visitor);
                CharacterClassContents::UnicodePropertyEscape { 0: _field_0 }
            }
            CharacterClassContents::Character { 0: _field_0 } => {
                let _field_0 = <Box<Character> as FoldWith<V>>::fold_with(_field_0, visitor);
                CharacterClassContents::Character { 0: _field_0 }
            }
            CharacterClassContents::NestedCharacterClass { 0: _field_0 } => {
                let _field_0 = <Box<CharacterClass> as FoldWith<V>>::fold_with(_field_0, visitor);
                CharacterClassContents::NestedCharacterClass { 0: _field_0 }
            }
            CharacterClassContents::ClassStringDisjunction { 0: _field_0 } => {
                let _field_0 =
                    <Box<ClassStringDisjunction> as FoldWith<V>>::fold_with(_field_0, visitor);
                CharacterClassContents::ClassStringDisjunction { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CharacterClassContentsKind {
    #[doc = "Calls [Fold`::fold_character_class_contents_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_class_contents_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CharacterClassContentsKind::Union => CharacterClassContentsKind::Union,
            CharacterClassContentsKind::Intersection => CharacterClassContentsKind::Intersection,
            CharacterClassContentsKind::Subtraction => CharacterClassContentsKind::Subtraction,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CharacterClassEscape {
    #[doc = "Calls [Fold`::fold_character_class_escape`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_class_escape(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CharacterClassEscape { span, kind } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let kind = { <CharacterClassEscapeKind as FoldWith<V>>::fold_with(kind, visitor) };
                CharacterClassEscape { span, kind }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CharacterClassEscapeKind {
    #[doc = "Calls [Fold`::fold_character_class_escape_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_class_escape_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CharacterClassEscapeKind::D => CharacterClassEscapeKind::D,
            CharacterClassEscapeKind::NegativeD => CharacterClassEscapeKind::NegativeD,
            CharacterClassEscapeKind::S => CharacterClassEscapeKind::S,
            CharacterClassEscapeKind::NegativeS => CharacterClassEscapeKind::NegativeS,
            CharacterClassEscapeKind::W => CharacterClassEscapeKind::W,
            CharacterClassEscapeKind::NegativeW => CharacterClassEscapeKind::NegativeW,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CharacterClassRange {
    #[doc = "Calls [Fold`::fold_character_class_range`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_class_range(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CharacterClassRange { span, min, max } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let min = { <Character as FoldWith<V>>::fold_with(min, visitor) };
                let max = { <Character as FoldWith<V>>::fold_with(max, visitor) };
                CharacterClassRange { span, min, max }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CharacterKind {
    #[doc = "Calls [Fold`::fold_character_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CharacterKind::ControlLetter => CharacterKind::ControlLetter,
            CharacterKind::HexadecimalEscape => CharacterKind::HexadecimalEscape,
            CharacterKind::Identifier => CharacterKind::Identifier,
            CharacterKind::Null => CharacterKind::Null,
            CharacterKind::Octal1 => CharacterKind::Octal1,
            CharacterKind::Octal2 => CharacterKind::Octal2,
            CharacterKind::Octal3 => CharacterKind::Octal3,
            CharacterKind::SingleEscape => CharacterKind::SingleEscape,
            CharacterKind::Symbol => CharacterKind::Symbol,
            CharacterKind::UnicodeEscape => CharacterKind::UnicodeEscape,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassString {
    #[doc = "Calls [Fold`::fold_class_string`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_string(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassString {
                span,
                strings,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Vec<Character> as FoldWith<V>>::fold_with(body, visitor) };
                ClassString {
                    span,
                    strings,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassStringDisjunction {
    #[doc = "Calls [Fold`::fold_class_string_disjunction`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_string_disjunction(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassStringDisjunction {
                span,
                strings,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Vec<ClassString> as FoldWith<V>>::fold_with(body, visitor) };
                ClassStringDisjunction {
                    span,
                    strings,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Disjunction {
    #[doc = "Calls [Fold`::fold_disjunction`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_disjunction(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Disjunction { span, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Vec<Alternative> as FoldWith<V>>::fold_with(body, visitor) };
                Disjunction { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Dot {
    #[doc = "Calls [Fold`::fold_dot`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_dot(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Dot { span } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                Dot { span }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for IgnoreGroup {
    #[doc = "Calls [Fold`::fold_ignore_group`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ignore_group(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            IgnoreGroup {
                span,
                modifiers,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let modifiers =
                    { <Option<Modifiers> as FoldWith<V>>::fold_with(modifiers, visitor) };
                let body = { <Disjunction as FoldWith<V>>::fold_with(body, visitor) };
                IgnoreGroup {
                    span,
                    modifiers,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for IndexedReference {
    #[doc = "Calls [Fold`::fold_indexed_reference`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_indexed_reference(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            IndexedReference { span, index } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                IndexedReference { span, index }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for LookAroundAssertion {
    #[doc = "Calls [Fold`::fold_look_around_assertion`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_look_around_assertion(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            LookAroundAssertion { span, kind, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let kind = { <LookAroundAssertionKind as FoldWith<V>>::fold_with(kind, visitor) };
                let body = { <Disjunction as FoldWith<V>>::fold_with(body, visitor) };
                LookAroundAssertion { span, kind, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for LookAroundAssertionKind {
    #[doc = "Calls [Fold`::fold_look_around_assertion_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_look_around_assertion_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            LookAroundAssertionKind::Lookahead => LookAroundAssertionKind::Lookahead,
            LookAroundAssertionKind::NegativeLookahead => {
                LookAroundAssertionKind::NegativeLookahead
            }
            LookAroundAssertionKind::Lookbehind => LookAroundAssertionKind::Lookbehind,
            LookAroundAssertionKind::NegativeLookbehind => {
                LookAroundAssertionKind::NegativeLookbehind
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Modifiers {
    #[doc = "Calls [Fold`::fold_modifiers`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_modifiers(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Modifiers {
                span,
                enabling,
                disabling,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let enabling = { <Modifier as FoldWith<V>>::fold_with(enabling, visitor) };
                let disabling = { <Modifier as FoldWith<V>>::fold_with(disabling, visitor) };
                Modifiers {
                    span,
                    enabling,
                    disabling,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for NamedReference {
    #[doc = "Calls [Fold`::fold_named_reference`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_named_reference(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            NamedReference { span, name } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <swc_atoms::Atom as FoldWith<V>>::fold_with(name, visitor) };
                NamedReference { span, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Pattern {
    #[doc = "Calls [Fold`::fold_pattern`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_pattern(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Pattern { span, body } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Disjunction as FoldWith<V>>::fold_with(body, visitor) };
                Pattern { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Quantifier {
    #[doc = "Calls [Fold`::fold_quantifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_quantifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Quantifier {
                span,
                min,
                max,
                greedy,
                body,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let body = { <Term as FoldWith<V>>::fold_with(body, visitor) };
                Quantifier {
                    span,
                    min,
                    max,
                    greedy,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Term {
    #[doc = "Calls [Fold`::fold_term`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_term(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Term::BoundaryAssertion { 0: _field_0 } => {
                let _field_0 =
                    <Box<BoundaryAssertion> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::BoundaryAssertion { 0: _field_0 }
            }
            Term::LookAroundAssertion { 0: _field_0 } => {
                let _field_0 =
                    <Box<LookAroundAssertion> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::LookAroundAssertion { 0: _field_0 }
            }
            Term::Quantifier { 0: _field_0 } => {
                let _field_0 = <Box<Quantifier> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::Quantifier { 0: _field_0 }
            }
            Term::Character { 0: _field_0 } => {
                let _field_0 = <Box<Character> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::Character { 0: _field_0 }
            }
            Term::Dot { 0: _field_0 } => {
                let _field_0 = <Dot as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::Dot { 0: _field_0 }
            }
            Term::CharacterClassEscape { 0: _field_0 } => {
                let _field_0 =
                    <Box<CharacterClassEscape> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::CharacterClassEscape { 0: _field_0 }
            }
            Term::UnicodePropertyEscape { 0: _field_0 } => {
                let _field_0 =
                    <Box<UnicodePropertyEscape> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::UnicodePropertyEscape { 0: _field_0 }
            }
            Term::CharacterClass { 0: _field_0 } => {
                let _field_0 = <Box<CharacterClass> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::CharacterClass { 0: _field_0 }
            }
            Term::CapturingGroup { 0: _field_0 } => {
                let _field_0 = <Box<CapturingGroup> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::CapturingGroup { 0: _field_0 }
            }
            Term::IgnoreGroup { 0: _field_0 } => {
                let _field_0 = <Box<IgnoreGroup> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::IgnoreGroup { 0: _field_0 }
            }
            Term::IndexedReference { 0: _field_0 } => {
                let _field_0 = <Box<IndexedReference> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::IndexedReference { 0: _field_0 }
            }
            Term::NamedReference { 0: _field_0 } => {
                let _field_0 = <Box<NamedReference> as FoldWith<V>>::fold_with(_field_0, visitor);
                Term::NamedReference { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UnicodePropertyEscape {
    #[doc = "Calls [Fold`::fold_unicode_property_escape`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_unicode_property_escape(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UnicodePropertyEscape {
                span,
                negative,
                strings,
                name,
                value,
            } => {
                let span = { <swc_common::Span as FoldWith<V>>::fold_with(span, visitor) };
                let name = { <swc_atoms::Atom as FoldWith<V>>::fold_with(name, visitor) };
                let value = { <Option<swc_atoms::Atom> as FoldWith<V>>::fold_with(value, visitor) };
                UnicodePropertyEscape {
                    span,
                    negative,
                    strings,
                    name,
                    value,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Alternative> {
    #[doc = "Calls [Fold`::fold_alternatives`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_alternatives(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Alternative as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_atoms::Atom {
    #[doc = "Calls [Fold`::fold_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_atom(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<CharacterClassContents> {
    #[doc = "Calls [Fold`::fold_character_class_contentss`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_character_class_contentss(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <CharacterClassContents as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Character> {
    #[doc = "Calls [Fold`::fold_characters`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_characters(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Character as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ClassString> {
    #[doc = "Calls [Fold`::fold_class_strings`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_strings(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <ClassString as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Modifier {
    #[doc = "Calls [Fold`::fold_modifier`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_modifier(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [Fold`::fold_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_atom(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <swc_atoms::Atom as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Modifiers> {
    #[doc = "Calls [Fold`::fold_opt_modifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_modifiers(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Modifiers as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_common::Span {
    #[doc = "Calls [Fold`::fold_span`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_span(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Term> {
    #[doc = "Calls [Fold`::fold_terms`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_terms(visitor, self)
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::move_map::MoveMap::move_map(self, |item| {
            <Term as FoldWith<V>>::fold_with(item, visitor)
        })
    }
}
impl<V, T> FoldWith<V> for std::boxed::Box<T>
where
    V: ?Sized + Fold,
    T: FoldWith<V>,
{
    #[inline]
    fn fold_with(self, visitor: &mut V) -> Self {
        swc_visit::util::map::Map::map(self, |inner| <T as FoldWith<V>>::fold_with(inner, visitor))
    }

    #[inline]
    fn fold_children_with(self, visitor: &mut V) -> Self {
        swc_visit::util::map::Map::map(self, |inner| {
            <T as FoldWith<V>>::fold_children_with(inner, visitor)
        })
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait FoldAstPath {
    #[doc = "Visit a node of type `Alternative`.\n\nBy default, this method calls \
             [`Alternative::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_alternative(&mut self, node: Alternative, __ast_path: &mut AstKindPath) -> Alternative {
        <Alternative as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Alternative >`.\n\nBy default, this method calls [`Vec < \
             Alternative >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_alternatives(
        &mut self,
        node: Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Alternative> {
        <Vec<Alternative> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        <swc_atoms::Atom as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BoundaryAssertion`.\n\nBy default, this method calls \
             [`BoundaryAssertion::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_boundary_assertion(
        &mut self,
        node: BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertion {
        <BoundaryAssertion as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `BoundaryAssertionKind`.\n\nBy default, this method calls \
             [`BoundaryAssertionKind::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertionKind {
        <BoundaryAssertionKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CapturingGroup`.\n\nBy default, this method calls \
             [`CapturingGroup::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_capturing_group(
        &mut self,
        node: CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) -> CapturingGroup {
        <CapturingGroup as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Character`.\n\nBy default, this method calls \
             [`Character::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_character(&mut self, node: Character, __ast_path: &mut AstKindPath) -> Character {
        <Character as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `CharacterClass`.\n\nBy default, this method calls \
             [`CharacterClass::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_character_class(
        &mut self,
        node: CharacterClass,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClass {
        <CharacterClass as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassContents`.\n\nBy default, this method calls \
             [`CharacterClassContents::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContents {
        <CharacterClassContents as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassContentsKind`.\n\nBy default, this method calls \
             [`CharacterClassContentsKind::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContentsKind {
        <CharacterClassContentsKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < CharacterClassContents >`.\n\nBy default, this method \
             calls [`Vec < CharacterClassContents >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<CharacterClassContents> {
        <Vec<CharacterClassContents> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassEscape`.\n\nBy default, this method calls \
             [`CharacterClassEscape::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_character_class_escape(
        &mut self,
        node: CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscape {
        <CharacterClassEscape as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassEscapeKind`.\n\nBy default, this method calls \
             [`CharacterClassEscapeKind::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscapeKind {
        <CharacterClassEscapeKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterClassRange`.\n\nBy default, this method calls \
             [`CharacterClassRange::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_character_class_range(
        &mut self,
        node: CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassRange {
        <CharacterClassRange as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `CharacterKind`.\n\nBy default, this method calls \
             [`CharacterKind::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_character_kind(
        &mut self,
        node: CharacterKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterKind {
        <CharacterKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Character >`.\n\nBy default, this method calls [`Vec < \
             Character >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_characters(
        &mut self,
        node: Vec<Character>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Character> {
        <Vec<Character> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassString`.\n\nBy default, this method calls \
             [`ClassString::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_class_string(
        &mut self,
        node: ClassString,
        __ast_path: &mut AstKindPath,
    ) -> ClassString {
        <ClassString as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `ClassStringDisjunction`.\n\nBy default, this method calls \
             [`ClassStringDisjunction::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) -> ClassStringDisjunction {
        <ClassStringDisjunction as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ClassString >`.\n\nBy default, this method calls [`Vec < \
             ClassString >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_class_strings(
        &mut self,
        node: Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassString> {
        <Vec<ClassString> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Disjunction`.\n\nBy default, this method calls \
             [`Disjunction::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction, __ast_path: &mut AstKindPath) -> Disjunction {
        <Disjunction as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Dot`.\n\nBy default, this method calls \
             [`Dot::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_dot(&mut self, node: Dot, __ast_path: &mut AstKindPath) -> Dot {
        <Dot as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IgnoreGroup`.\n\nBy default, this method calls \
             [`IgnoreGroup::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_ignore_group(
        &mut self,
        node: IgnoreGroup,
        __ast_path: &mut AstKindPath,
    ) -> IgnoreGroup {
        <IgnoreGroup as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `IndexedReference`.\n\nBy default, this method calls \
             [`IndexedReference::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_indexed_reference(
        &mut self,
        node: IndexedReference,
        __ast_path: &mut AstKindPath,
    ) -> IndexedReference {
        <IndexedReference as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LookAroundAssertion`.\n\nBy default, this method calls \
             [`LookAroundAssertion::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_look_around_assertion(
        &mut self,
        node: LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertion {
        <LookAroundAssertion as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `LookAroundAssertionKind`.\n\nBy default, this method calls \
             [`LookAroundAssertionKind::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertionKind {
        <LookAroundAssertionKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Modifier`.\n\nBy default, this method calls \
             [`Modifier::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_modifier(&mut self, node: Modifier, __ast_path: &mut AstKindPath) -> Modifier {
        <Modifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Modifiers`.\n\nBy default, this method calls \
             [`Modifiers::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers, __ast_path: &mut AstKindPath) -> Modifiers {
        <Modifiers as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `NamedReference`.\n\nBy default, this method calls \
             [`NamedReference::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    #[inline]
    fn fold_named_reference(
        &mut self,
        node: NamedReference,
        __ast_path: &mut AstKindPath,
    ) -> NamedReference {
        <NamedReference as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        <Option<swc_atoms::Atom> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Modifiers >`.\n\nBy default, this method calls \
             [`Option < Modifiers >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_opt_modifiers(
        &mut self,
        node: Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Modifiers> {
        <Option<Modifiers> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Pattern`.\n\nBy default, this method calls \
             [`Pattern::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_pattern(&mut self, node: Pattern, __ast_path: &mut AstKindPath) -> Pattern {
        <Pattern as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Quantifier`.\n\nBy default, this method calls \
             [`Quantifier::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier, __ast_path: &mut AstKindPath) -> Quantifier {
        <Quantifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        <swc_common::Span as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
    #[doc = "Visit a node of type `Term`.\n\nBy default, this method calls \
             [`Term::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_term(&mut self, node: Term, __ast_path: &mut AstKindPath) -> Term {
        <Term as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `Vec < Term >`.\n\nBy default, this method calls [`Vec < Term \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>, __ast_path: &mut AstKindPath) -> Vec<Term> {
        <Vec<Term> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, __ast_path)
    }
    #[doc = "Visit a node of type `UnicodePropertyEscape`.\n\nBy default, this method calls \
             [`UnicodePropertyEscape::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) -> UnicodePropertyEscape {
        <UnicodePropertyEscape as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, __ast_path,
        )
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for &mut V
where
    V: ?Sized + FoldAstPath,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative, __ast_path: &mut AstKindPath) -> Alternative {
        <V as FoldAstPath>::fold_alternative(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_alternatives(
        &mut self,
        node: Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Alternative> {
        <V as FoldAstPath>::fold_alternatives(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        <V as FoldAstPath>::fold_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_boundary_assertion(
        &mut self,
        node: BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertion {
        <V as FoldAstPath>::fold_boundary_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertionKind {
        <V as FoldAstPath>::fold_boundary_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_capturing_group(
        &mut self,
        node: CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) -> CapturingGroup {
        <V as FoldAstPath>::fold_capturing_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character(&mut self, node: Character, __ast_path: &mut AstKindPath) -> Character {
        <V as FoldAstPath>::fold_character(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class(
        &mut self,
        node: CharacterClass,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClass {
        <V as FoldAstPath>::fold_character_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContents {
        <V as FoldAstPath>::fold_character_class_contents(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContentsKind {
        <V as FoldAstPath>::fold_character_class_contents_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<CharacterClassContents> {
        <V as FoldAstPath>::fold_character_class_contentss(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_escape(
        &mut self,
        node: CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscape {
        <V as FoldAstPath>::fold_character_class_escape(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscapeKind {
        <V as FoldAstPath>::fold_character_class_escape_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_range(
        &mut self,
        node: CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassRange {
        <V as FoldAstPath>::fold_character_class_range(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_kind(
        &mut self,
        node: CharacterKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterKind {
        <V as FoldAstPath>::fold_character_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_characters(
        &mut self,
        node: Vec<Character>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Character> {
        <V as FoldAstPath>::fold_characters(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_string(
        &mut self,
        node: ClassString,
        __ast_path: &mut AstKindPath,
    ) -> ClassString {
        <V as FoldAstPath>::fold_class_string(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) -> ClassStringDisjunction {
        <V as FoldAstPath>::fold_class_string_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_strings(
        &mut self,
        node: Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassString> {
        <V as FoldAstPath>::fold_class_strings(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction, __ast_path: &mut AstKindPath) -> Disjunction {
        <V as FoldAstPath>::fold_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot, __ast_path: &mut AstKindPath) -> Dot {
        <V as FoldAstPath>::fold_dot(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_ignore_group(
        &mut self,
        node: IgnoreGroup,
        __ast_path: &mut AstKindPath,
    ) -> IgnoreGroup {
        <V as FoldAstPath>::fold_ignore_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_indexed_reference(
        &mut self,
        node: IndexedReference,
        __ast_path: &mut AstKindPath,
    ) -> IndexedReference {
        <V as FoldAstPath>::fold_indexed_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_look_around_assertion(
        &mut self,
        node: LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertion {
        <V as FoldAstPath>::fold_look_around_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertionKind {
        <V as FoldAstPath>::fold_look_around_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier, __ast_path: &mut AstKindPath) -> Modifier {
        <V as FoldAstPath>::fold_modifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers, __ast_path: &mut AstKindPath) -> Modifiers {
        <V as FoldAstPath>::fold_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_named_reference(
        &mut self,
        node: NamedReference,
        __ast_path: &mut AstKindPath,
    ) -> NamedReference {
        <V as FoldAstPath>::fold_named_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        <V as FoldAstPath>::fold_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_modifiers(
        &mut self,
        node: Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Modifiers> {
        <V as FoldAstPath>::fold_opt_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern, __ast_path: &mut AstKindPath) -> Pattern {
        <V as FoldAstPath>::fold_pattern(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier, __ast_path: &mut AstKindPath) -> Quantifier {
        <V as FoldAstPath>::fold_quantifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        <V as FoldAstPath>::fold_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_term(&mut self, node: Term, __ast_path: &mut AstKindPath) -> Term {
        <V as FoldAstPath>::fold_term(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>, __ast_path: &mut AstKindPath) -> Vec<Term> {
        <V as FoldAstPath>::fold_terms(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) -> UnicodePropertyEscape {
        <V as FoldAstPath>::fold_unicode_property_escape(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for Box<V>
where
    V: ?Sized + FoldAstPath,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative, __ast_path: &mut AstKindPath) -> Alternative {
        <V as FoldAstPath>::fold_alternative(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_alternatives(
        &mut self,
        node: Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Alternative> {
        <V as FoldAstPath>::fold_alternatives(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        <V as FoldAstPath>::fold_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_boundary_assertion(
        &mut self,
        node: BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertion {
        <V as FoldAstPath>::fold_boundary_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertionKind {
        <V as FoldAstPath>::fold_boundary_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_capturing_group(
        &mut self,
        node: CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) -> CapturingGroup {
        <V as FoldAstPath>::fold_capturing_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character(&mut self, node: Character, __ast_path: &mut AstKindPath) -> Character {
        <V as FoldAstPath>::fold_character(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class(
        &mut self,
        node: CharacterClass,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClass {
        <V as FoldAstPath>::fold_character_class(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContents {
        <V as FoldAstPath>::fold_character_class_contents(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContentsKind {
        <V as FoldAstPath>::fold_character_class_contents_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<CharacterClassContents> {
        <V as FoldAstPath>::fold_character_class_contentss(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_escape(
        &mut self,
        node: CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscape {
        <V as FoldAstPath>::fold_character_class_escape(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscapeKind {
        <V as FoldAstPath>::fold_character_class_escape_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_class_range(
        &mut self,
        node: CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassRange {
        <V as FoldAstPath>::fold_character_class_range(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_character_kind(
        &mut self,
        node: CharacterKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterKind {
        <V as FoldAstPath>::fold_character_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_characters(
        &mut self,
        node: Vec<Character>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Character> {
        <V as FoldAstPath>::fold_characters(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_string(
        &mut self,
        node: ClassString,
        __ast_path: &mut AstKindPath,
    ) -> ClassString {
        <V as FoldAstPath>::fold_class_string(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) -> ClassStringDisjunction {
        <V as FoldAstPath>::fold_class_string_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_class_strings(
        &mut self,
        node: Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassString> {
        <V as FoldAstPath>::fold_class_strings(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction, __ast_path: &mut AstKindPath) -> Disjunction {
        <V as FoldAstPath>::fold_disjunction(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot, __ast_path: &mut AstKindPath) -> Dot {
        <V as FoldAstPath>::fold_dot(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_ignore_group(
        &mut self,
        node: IgnoreGroup,
        __ast_path: &mut AstKindPath,
    ) -> IgnoreGroup {
        <V as FoldAstPath>::fold_ignore_group(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_indexed_reference(
        &mut self,
        node: IndexedReference,
        __ast_path: &mut AstKindPath,
    ) -> IndexedReference {
        <V as FoldAstPath>::fold_indexed_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_look_around_assertion(
        &mut self,
        node: LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertion {
        <V as FoldAstPath>::fold_look_around_assertion(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertionKind {
        <V as FoldAstPath>::fold_look_around_assertion_kind(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier, __ast_path: &mut AstKindPath) -> Modifier {
        <V as FoldAstPath>::fold_modifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers, __ast_path: &mut AstKindPath) -> Modifiers {
        <V as FoldAstPath>::fold_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_named_reference(
        &mut self,
        node: NamedReference,
        __ast_path: &mut AstKindPath,
    ) -> NamedReference {
        <V as FoldAstPath>::fold_named_reference(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        <V as FoldAstPath>::fold_opt_atom(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_opt_modifiers(
        &mut self,
        node: Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Modifiers> {
        <V as FoldAstPath>::fold_opt_modifiers(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern, __ast_path: &mut AstKindPath) -> Pattern {
        <V as FoldAstPath>::fold_pattern(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier, __ast_path: &mut AstKindPath) -> Quantifier {
        <V as FoldAstPath>::fold_quantifier(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        <V as FoldAstPath>::fold_span(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_term(&mut self, node: Term, __ast_path: &mut AstKindPath) -> Term {
        <V as FoldAstPath>::fold_term(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>, __ast_path: &mut AstKindPath) -> Vec<Term> {
        <V as FoldAstPath>::fold_terms(&mut **self, node, __ast_path)
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) -> UnicodePropertyEscape {
        <V as FoldAstPath>::fold_unicode_property_escape(&mut **self, node, __ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> FoldAstPath for ::swc_visit::Either<A, B>
where
    A: FoldAstPath,
    B: FoldAstPath,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative, __ast_path: &mut AstKindPath) -> Alternative {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_alternative(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_alternative(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_alternatives(
        &mut self,
        node: Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Alternative> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_alternatives(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_alternatives(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_atom(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_atom(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_boundary_assertion(
        &mut self,
        node: BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertion {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_boundary_assertion(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_boundary_assertion(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertionKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_boundary_assertion_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_boundary_assertion_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_capturing_group(
        &mut self,
        node: CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) -> CapturingGroup {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_capturing_group(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_capturing_group(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character(&mut self, node: Character, __ast_path: &mut AstKindPath) -> Character {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_class(
        &mut self,
        node: CharacterClass,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClass {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_class(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_class(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContents {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_class_contents(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_class_contents(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContentsKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_class_contents_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_class_contents_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<CharacterClassContents> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_class_contentss(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_class_contentss(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_class_escape(
        &mut self,
        node: CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscape {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_class_escape(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_class_escape(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscapeKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_class_escape_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_class_escape_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_class_range(
        &mut self,
        node: CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassRange {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_class_range(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_class_range(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_character_kind(
        &mut self,
        node: CharacterKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_character_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_character_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_characters(
        &mut self,
        node: Vec<Character>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Character> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_characters(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_characters(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_string(
        &mut self,
        node: ClassString,
        __ast_path: &mut AstKindPath,
    ) -> ClassString {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_string(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_string(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) -> ClassStringDisjunction {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_string_disjunction(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_string_disjunction(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_class_strings(
        &mut self,
        node: Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassString> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_strings(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_strings(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction, __ast_path: &mut AstKindPath) -> Disjunction {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_disjunction(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_disjunction(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot, __ast_path: &mut AstKindPath) -> Dot {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_dot(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_dot(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_ignore_group(
        &mut self,
        node: IgnoreGroup,
        __ast_path: &mut AstKindPath,
    ) -> IgnoreGroup {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ignore_group(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ignore_group(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_indexed_reference(
        &mut self,
        node: IndexedReference,
        __ast_path: &mut AstKindPath,
    ) -> IndexedReference {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_indexed_reference(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_indexed_reference(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_look_around_assertion(
        &mut self,
        node: LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertion {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_look_around_assertion(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_look_around_assertion(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertionKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_look_around_assertion_kind(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_look_around_assertion_kind(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier, __ast_path: &mut AstKindPath) -> Modifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_modifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_modifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers, __ast_path: &mut AstKindPath) -> Modifiers {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_modifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_modifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_named_reference(
        &mut self,
        node: NamedReference,
        __ast_path: &mut AstKindPath,
    ) -> NamedReference {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_named_reference(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_named_reference(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_atom(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_atom(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_opt_modifiers(
        &mut self,
        node: Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Modifiers> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_modifiers(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_modifiers(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern, __ast_path: &mut AstKindPath) -> Pattern {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_pattern(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_pattern(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier, __ast_path: &mut AstKindPath) -> Quantifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_quantifier(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_quantifier(visitor, node, __ast_path)
            }
        }
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_span(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_span(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_term(&mut self, node: Term, __ast_path: &mut AstKindPath) -> Term {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_term(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_term(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>, __ast_path: &mut AstKindPath) -> Vec<Term> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_terms(visitor, node, __ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_terms(visitor, node, __ast_path),
        }
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) -> UnicodePropertyEscape {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_unicode_property_escape(visitor, node, __ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_unicode_property_escape(visitor, node, __ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for ::swc_visit::Optional<V>
where
    V: FoldAstPath,
{
    #[inline]
    fn fold_alternative(&mut self, node: Alternative, __ast_path: &mut AstKindPath) -> Alternative {
        if self.enabled {
            <V as FoldAstPath>::fold_alternative(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_alternatives(
        &mut self,
        node: Vec<Alternative>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Alternative> {
        if self.enabled {
            <V as FoldAstPath>::fold_alternatives(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_atom(
        &mut self,
        node: swc_atoms::Atom,
        __ast_path: &mut AstKindPath,
    ) -> swc_atoms::Atom {
        if self.enabled {
            <V as FoldAstPath>::fold_atom(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_boundary_assertion(
        &mut self,
        node: BoundaryAssertion,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertion {
        if self.enabled {
            <V as FoldAstPath>::fold_boundary_assertion(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_boundary_assertion_kind(
        &mut self,
        node: BoundaryAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> BoundaryAssertionKind {
        if self.enabled {
            <V as FoldAstPath>::fold_boundary_assertion_kind(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_capturing_group(
        &mut self,
        node: CapturingGroup,
        __ast_path: &mut AstKindPath,
    ) -> CapturingGroup {
        if self.enabled {
            <V as FoldAstPath>::fold_capturing_group(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character(&mut self, node: Character, __ast_path: &mut AstKindPath) -> Character {
        if self.enabled {
            <V as FoldAstPath>::fold_character(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class(
        &mut self,
        node: CharacterClass,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClass {
        if self.enabled {
            <V as FoldAstPath>::fold_character_class(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_contents(
        &mut self,
        node: CharacterClassContents,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContents {
        if self.enabled {
            <V as FoldAstPath>::fold_character_class_contents(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_contents_kind(
        &mut self,
        node: CharacterClassContentsKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassContentsKind {
        if self.enabled {
            <V as FoldAstPath>::fold_character_class_contents_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_contentss(
        &mut self,
        node: Vec<CharacterClassContents>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<CharacterClassContents> {
        if self.enabled {
            <V as FoldAstPath>::fold_character_class_contentss(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_escape(
        &mut self,
        node: CharacterClassEscape,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscape {
        if self.enabled {
            <V as FoldAstPath>::fold_character_class_escape(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_escape_kind(
        &mut self,
        node: CharacterClassEscapeKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassEscapeKind {
        if self.enabled {
            <V as FoldAstPath>::fold_character_class_escape_kind(
                &mut self.visitor,
                node,
                __ast_path,
            )
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_class_range(
        &mut self,
        node: CharacterClassRange,
        __ast_path: &mut AstKindPath,
    ) -> CharacterClassRange {
        if self.enabled {
            <V as FoldAstPath>::fold_character_class_range(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_character_kind(
        &mut self,
        node: CharacterKind,
        __ast_path: &mut AstKindPath,
    ) -> CharacterKind {
        if self.enabled {
            <V as FoldAstPath>::fold_character_kind(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_characters(
        &mut self,
        node: Vec<Character>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<Character> {
        if self.enabled {
            <V as FoldAstPath>::fold_characters(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_string(
        &mut self,
        node: ClassString,
        __ast_path: &mut AstKindPath,
    ) -> ClassString {
        if self.enabled {
            <V as FoldAstPath>::fold_class_string(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_string_disjunction(
        &mut self,
        node: ClassStringDisjunction,
        __ast_path: &mut AstKindPath,
    ) -> ClassStringDisjunction {
        if self.enabled {
            <V as FoldAstPath>::fold_class_string_disjunction(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_class_strings(
        &mut self,
        node: Vec<ClassString>,
        __ast_path: &mut AstKindPath,
    ) -> Vec<ClassString> {
        if self.enabled {
            <V as FoldAstPath>::fold_class_strings(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_disjunction(&mut self, node: Disjunction, __ast_path: &mut AstKindPath) -> Disjunction {
        if self.enabled {
            <V as FoldAstPath>::fold_disjunction(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_dot(&mut self, node: Dot, __ast_path: &mut AstKindPath) -> Dot {
        if self.enabled {
            <V as FoldAstPath>::fold_dot(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_ignore_group(
        &mut self,
        node: IgnoreGroup,
        __ast_path: &mut AstKindPath,
    ) -> IgnoreGroup {
        if self.enabled {
            <V as FoldAstPath>::fold_ignore_group(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_indexed_reference(
        &mut self,
        node: IndexedReference,
        __ast_path: &mut AstKindPath,
    ) -> IndexedReference {
        if self.enabled {
            <V as FoldAstPath>::fold_indexed_reference(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_look_around_assertion(
        &mut self,
        node: LookAroundAssertion,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertion {
        if self.enabled {
            <V as FoldAstPath>::fold_look_around_assertion(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_look_around_assertion_kind(
        &mut self,
        node: LookAroundAssertionKind,
        __ast_path: &mut AstKindPath,
    ) -> LookAroundAssertionKind {
        if self.enabled {
            <V as FoldAstPath>::fold_look_around_assertion_kind(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_modifier(&mut self, node: Modifier, __ast_path: &mut AstKindPath) -> Modifier {
        if self.enabled {
            <V as FoldAstPath>::fold_modifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_modifiers(&mut self, node: Modifiers, __ast_path: &mut AstKindPath) -> Modifiers {
        if self.enabled {
            <V as FoldAstPath>::fold_modifiers(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_named_reference(
        &mut self,
        node: NamedReference,
        __ast_path: &mut AstKindPath,
    ) -> NamedReference {
        if self.enabled {
            <V as FoldAstPath>::fold_named_reference(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        __ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_atom(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_opt_modifiers(
        &mut self,
        node: Option<Modifiers>,
        __ast_path: &mut AstKindPath,
    ) -> Option<Modifiers> {
        if self.enabled {
            <V as FoldAstPath>::fold_opt_modifiers(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_pattern(&mut self, node: Pattern, __ast_path: &mut AstKindPath) -> Pattern {
        if self.enabled {
            <V as FoldAstPath>::fold_pattern(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_quantifier(&mut self, node: Quantifier, __ast_path: &mut AstKindPath) -> Quantifier {
        if self.enabled {
            <V as FoldAstPath>::fold_quantifier(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        __ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        if self.enabled {
            <V as FoldAstPath>::fold_span(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_term(&mut self, node: Term, __ast_path: &mut AstKindPath) -> Term {
        if self.enabled {
            <V as FoldAstPath>::fold_term(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_terms(&mut self, node: Vec<Term>, __ast_path: &mut AstKindPath) -> Vec<Term> {
        if self.enabled {
            <V as FoldAstPath>::fold_terms(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }

    #[inline]
    fn fold_unicode_property_escape(
        &mut self,
        node: UnicodePropertyEscape,
        __ast_path: &mut AstKindPath,
    ) -> UnicodePropertyEscape {
        if self.enabled {
            <V as FoldAstPath>::fold_unicode_property_escape(&mut self.visitor, node, __ast_path)
        } else {
            node
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait FoldWithAstPath<V: ?Sized + FoldAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self;
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self;
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Alternative {
    #[doc = "Calls [FoldAstPath`::fold_alternative`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_alternative(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Alternative { span, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Alternative(
                        self::fields::AlternativeField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Alternative(
                        self::fields::AlternativeField::Body(usize::MAX),
                    ));
                    <Vec<Term> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Alternative { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BoundaryAssertion {
    #[doc = "Calls [FoldAstPath`::fold_boundary_assertion`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_boundary_assertion(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BoundaryAssertion { span, kind } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BoundaryAssertion(
                        self::fields::BoundaryAssertionField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::BoundaryAssertion(
                        self::fields::BoundaryAssertionField::Kind,
                    ));
                    <BoundaryAssertionKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                BoundaryAssertion { span, kind }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BoundaryAssertionKind {
    #[doc = "Calls [FoldAstPath`::fold_boundary_assertion_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_boundary_assertion_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            BoundaryAssertionKind::Start => BoundaryAssertionKind::Start,
            BoundaryAssertionKind::End => BoundaryAssertionKind::End,
            BoundaryAssertionKind::Boundary => BoundaryAssertionKind::Boundary,
            BoundaryAssertionKind::NegativeBoundary => BoundaryAssertionKind::NegativeBoundary,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CapturingGroup {
    #[doc = "Calls [FoldAstPath`::fold_capturing_group`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_capturing_group(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CapturingGroup { span, name, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CapturingGroup(
                        self::fields::CapturingGroupField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CapturingGroup(
                        self::fields::CapturingGroupField::Name,
                    ));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CapturingGroup(
                        self::fields::CapturingGroupField::Body,
                    ));
                    <Disjunction as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                CapturingGroup { span, name, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Character {
    #[doc = "Calls [FoldAstPath`::fold_character`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Character { span, kind, value } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Character(self::fields::CharacterField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Character(self::fields::CharacterField::Kind));
                    <CharacterKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Character { span, kind, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CharacterClass {
    #[doc = "Calls [FoldAstPath`::fold_character_class`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_class(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CharacterClass {
                span,
                negative,
                strings,
                kind,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClass(
                        self::fields::CharacterClassField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClass(
                        self::fields::CharacterClassField::Kind,
                    ));
                    <CharacterClassContentsKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClass(
                        self::fields::CharacterClassField::Body(usize::MAX),
                    ));
                    <Vec<CharacterClassContents> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                CharacterClass {
                    span,
                    negative,
                    strings,
                    kind,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CharacterClassContents {
    #[doc = "Calls [FoldAstPath`::fold_character_class_contents`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_class_contents(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CharacterClassContents::CharacterClassRange { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::CharacterClassRange,
                ));
                let _field_0 = <Box<CharacterClassRange> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                CharacterClassContents::CharacterClassRange { 0: _field_0 }
            }
            CharacterClassContents::CharacterClassEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::CharacterClassEscape,
                ));
                let _field_0 =
                    <Box<CharacterClassEscape> as FoldWithAstPath<V>>::fold_with_ast_path(
                        _field_0,
                        visitor,
                        &mut *__ast_path,
                    );
                CharacterClassContents::CharacterClassEscape { 0: _field_0 }
            }
            CharacterClassContents::UnicodePropertyEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::UnicodePropertyEscape,
                ));
                let _field_0 =
                    <Box<UnicodePropertyEscape> as FoldWithAstPath<V>>::fold_with_ast_path(
                        _field_0,
                        visitor,
                        &mut *__ast_path,
                    );
                CharacterClassContents::UnicodePropertyEscape { 0: _field_0 }
            }
            CharacterClassContents::Character { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::Character,
                ));
                let _field_0 = <Box<Character> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                CharacterClassContents::Character { 0: _field_0 }
            }
            CharacterClassContents::NestedCharacterClass { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::NestedCharacterClass,
                ));
                let _field_0 = <Box<CharacterClass> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                CharacterClassContents::NestedCharacterClass { 0: _field_0 }
            }
            CharacterClassContents::ClassStringDisjunction { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassContents(
                    self::fields::CharacterClassContentsField::ClassStringDisjunction,
                ));
                let _field_0 =
                    <Box<ClassStringDisjunction> as FoldWithAstPath<V>>::fold_with_ast_path(
                        _field_0,
                        visitor,
                        &mut *__ast_path,
                    );
                CharacterClassContents::ClassStringDisjunction { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CharacterClassContentsKind {
    #[doc = "Calls [FoldAstPath`::fold_character_class_contents_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_class_contents_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CharacterClassContentsKind::Union => CharacterClassContentsKind::Union,
            CharacterClassContentsKind::Intersection => CharacterClassContentsKind::Intersection,
            CharacterClassContentsKind::Subtraction => CharacterClassContentsKind::Subtraction,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CharacterClassEscape {
    #[doc = "Calls [FoldAstPath`::fold_character_class_escape`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_class_escape(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CharacterClassEscape { span, kind } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::CharacterClassEscape(
                            self::fields::CharacterClassEscapeField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::CharacterClassEscape(
                            self::fields::CharacterClassEscapeField::Kind,
                        ));
                    <CharacterClassEscapeKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                CharacterClassEscape { span, kind }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CharacterClassEscapeKind {
    #[doc = "Calls [FoldAstPath`::fold_character_class_escape_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_class_escape_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CharacterClassEscapeKind::D => CharacterClassEscapeKind::D,
            CharacterClassEscapeKind::NegativeD => CharacterClassEscapeKind::NegativeD,
            CharacterClassEscapeKind::S => CharacterClassEscapeKind::S,
            CharacterClassEscapeKind::NegativeS => CharacterClassEscapeKind::NegativeS,
            CharacterClassEscapeKind::W => CharacterClassEscapeKind::W,
            CharacterClassEscapeKind::NegativeW => CharacterClassEscapeKind::NegativeW,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CharacterClassRange {
    #[doc = "Calls [FoldAstPath`::fold_character_class_range`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_class_range(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CharacterClassRange { span, min, max } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassRange(
                        self::fields::CharacterClassRangeField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let min = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassRange(
                        self::fields::CharacterClassRangeField::Min,
                    ));
                    <Character as FoldWithAstPath<V>>::fold_with_ast_path(
                        min,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let max = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::CharacterClassRange(
                        self::fields::CharacterClassRangeField::Max,
                    ));
                    <Character as FoldWithAstPath<V>>::fold_with_ast_path(
                        max,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                CharacterClassRange { span, min, max }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CharacterKind {
    #[doc = "Calls [FoldAstPath`::fold_character_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            CharacterKind::ControlLetter => CharacterKind::ControlLetter,
            CharacterKind::HexadecimalEscape => CharacterKind::HexadecimalEscape,
            CharacterKind::Identifier => CharacterKind::Identifier,
            CharacterKind::Null => CharacterKind::Null,
            CharacterKind::Octal1 => CharacterKind::Octal1,
            CharacterKind::Octal2 => CharacterKind::Octal2,
            CharacterKind::Octal3 => CharacterKind::Octal3,
            CharacterKind::SingleEscape => CharacterKind::SingleEscape,
            CharacterKind::Symbol => CharacterKind::Symbol,
            CharacterKind::UnicodeEscape => CharacterKind::UnicodeEscape,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassString {
    #[doc = "Calls [FoldAstPath`::fold_class_string`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_string(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassString {
                span,
                strings,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassString(
                        self::fields::ClassStringField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::ClassString(
                        self::fields::ClassStringField::Body(usize::MAX),
                    ));
                    <Vec<Character> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ClassString {
                    span,
                    strings,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassStringDisjunction {
    #[doc = "Calls [FoldAstPath`::fold_class_string_disjunction`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_string_disjunction(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassStringDisjunction {
                span,
                strings,
                body,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ClassStringDisjunction(
                            self::fields::ClassStringDisjunctionField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::ClassStringDisjunction(
                            self::fields::ClassStringDisjunctionField::Body(usize::MAX),
                        ));
                    <Vec<ClassString> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                ClassStringDisjunction {
                    span,
                    strings,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Disjunction {
    #[doc = "Calls [FoldAstPath`::fold_disjunction`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_disjunction(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Disjunction { span, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Disjunction(
                        self::fields::DisjunctionField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Disjunction(
                        self::fields::DisjunctionField::Body(usize::MAX),
                    ));
                    <Vec<Alternative> as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Disjunction { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Dot {
    #[doc = "Calls [FoldAstPath`::fold_dot`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_dot(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Dot { span } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::Dot(self::fields::DotField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Dot { span }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for IgnoreGroup {
    #[doc = "Calls [FoldAstPath`::fold_ignore_group`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ignore_group(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            IgnoreGroup {
                span,
                modifiers,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IgnoreGroup(
                        self::fields::IgnoreGroupField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let modifiers = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IgnoreGroup(
                        self::fields::IgnoreGroupField::Modifiers,
                    ));
                    <Option<Modifiers> as FoldWithAstPath<V>>::fold_with_ast_path(
                        modifiers,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IgnoreGroup(
                        self::fields::IgnoreGroupField::Body,
                    ));
                    <Disjunction as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                IgnoreGroup {
                    span,
                    modifiers,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for IndexedReference {
    #[doc = "Calls [FoldAstPath`::fold_indexed_reference`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_indexed_reference(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            IndexedReference { span, index } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::IndexedReference(
                        self::fields::IndexedReferenceField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                IndexedReference { span, index }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for LookAroundAssertion {
    #[doc = "Calls [FoldAstPath`::fold_look_around_assertion`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_look_around_assertion(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            LookAroundAssertion { span, kind, body } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LookAroundAssertion(
                        self::fields::LookAroundAssertionField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let kind = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LookAroundAssertion(
                        self::fields::LookAroundAssertionField::Kind,
                    ));
                    <LookAroundAssertionKind as FoldWithAstPath<V>>::fold_with_ast_path(
                        kind,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::LookAroundAssertion(
                        self::fields::LookAroundAssertionField::Body,
                    ));
                    <Disjunction as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                LookAroundAssertion { span, kind, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for LookAroundAssertionKind {
    #[doc = "Calls [FoldAstPath`::fold_look_around_assertion_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_look_around_assertion_kind(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            LookAroundAssertionKind::Lookahead => LookAroundAssertionKind::Lookahead,
            LookAroundAssertionKind::NegativeLookahead => {
                LookAroundAssertionKind::NegativeLookahead
            }
            LookAroundAssertionKind::Lookbehind => LookAroundAssertionKind::Lookbehind,
            LookAroundAssertionKind::NegativeLookbehind => {
                LookAroundAssertionKind::NegativeLookbehind
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Modifiers {
    #[doc = "Calls [FoldAstPath`::fold_modifiers`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_modifiers(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Modifiers {
                span,
                enabling,
                disabling,
            } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Modifiers(self::fields::ModifiersField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let enabling = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Modifiers(
                        self::fields::ModifiersField::Enabling,
                    ));
                    <Modifier as FoldWithAstPath<V>>::fold_with_ast_path(
                        enabling,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let disabling = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Modifiers(
                        self::fields::ModifiersField::Disabling,
                    ));
                    <Modifier as FoldWithAstPath<V>>::fold_with_ast_path(
                        disabling,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Modifiers {
                    span,
                    enabling,
                    disabling,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for NamedReference {
    #[doc = "Calls [FoldAstPath`::fold_named_reference`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_named_reference(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            NamedReference { span, name } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedReference(
                        self::fields::NamedReferenceField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::NamedReference(
                        self::fields::NamedReferenceField::Name,
                    ));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                NamedReference { span, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Pattern {
    #[doc = "Calls [FoldAstPath`::fold_pattern`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_pattern(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Pattern { span, body } => {
                let span = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Pattern(self::fields::PatternField::Span));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path
                        .with_guard(AstParentKind::Pattern(self::fields::PatternField::Body));
                    <Disjunction as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Pattern { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Quantifier {
    #[doc = "Calls [FoldAstPath`::fold_quantifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_quantifier(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Quantifier {
                span,
                min,
                max,
                greedy,
                body,
            } => {
                let span = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Quantifier(
                        self::fields::QuantifierField::Span,
                    ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let body = {
                    let mut __ast_path = __ast_path.with_guard(AstParentKind::Quantifier(
                        self::fields::QuantifierField::Body,
                    ));
                    <Term as FoldWithAstPath<V>>::fold_with_ast_path(
                        body,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                Quantifier {
                    span,
                    min,
                    max,
                    greedy,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Term {
    #[doc = "Calls [FoldAstPath`::fold_term`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_term(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            Term::BoundaryAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::BoundaryAssertion,
                ));
                let _field_0 = <Box<BoundaryAssertion> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::BoundaryAssertion { 0: _field_0 }
            }
            Term::LookAroundAssertion { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::LookAroundAssertion,
                ));
                let _field_0 = <Box<LookAroundAssertion> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::LookAroundAssertion { 0: _field_0 }
            }
            Term::Quantifier { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Term(self::fields::TermField::Quantifier));
                let _field_0 = <Box<Quantifier> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::Quantifier { 0: _field_0 }
            }
            Term::Character { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Term(self::fields::TermField::Character));
                let _field_0 = <Box<Character> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::Character { 0: _field_0 }
            }
            Term::Dot { 0: _field_0 } => {
                let mut __ast_path =
                    __ast_path.with_guard(AstParentKind::Term(self::fields::TermField::Dot));
                let _field_0 = <Dot as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::Dot { 0: _field_0 }
            }
            Term::CharacterClassEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::CharacterClassEscape,
                ));
                let _field_0 =
                    <Box<CharacterClassEscape> as FoldWithAstPath<V>>::fold_with_ast_path(
                        _field_0,
                        visitor,
                        &mut *__ast_path,
                    );
                Term::CharacterClassEscape { 0: _field_0 }
            }
            Term::UnicodePropertyEscape { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::UnicodePropertyEscape,
                ));
                let _field_0 =
                    <Box<UnicodePropertyEscape> as FoldWithAstPath<V>>::fold_with_ast_path(
                        _field_0,
                        visitor,
                        &mut *__ast_path,
                    );
                Term::UnicodePropertyEscape { 0: _field_0 }
            }
            Term::CharacterClass { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::CharacterClass));
                let _field_0 = <Box<CharacterClass> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::CharacterClass { 0: _field_0 }
            }
            Term::CapturingGroup { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::CapturingGroup));
                let _field_0 = <Box<CapturingGroup> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::CapturingGroup { 0: _field_0 }
            }
            Term::IgnoreGroup { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::IgnoreGroup));
                let _field_0 = <Box<IgnoreGroup> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::IgnoreGroup { 0: _field_0 }
            }
            Term::IndexedReference { 0: _field_0 } => {
                let mut __ast_path = __ast_path.with_guard(AstParentKind::Term(
                    self::fields::TermField::IndexedReference,
                ));
                let _field_0 = <Box<IndexedReference> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::IndexedReference { 0: _field_0 }
            }
            Term::NamedReference { 0: _field_0 } => {
                let mut __ast_path = __ast_path
                    .with_guard(AstParentKind::Term(self::fields::TermField::NamedReference));
                let _field_0 = <Box<NamedReference> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0,
                    visitor,
                    &mut *__ast_path,
                );
                Term::NamedReference { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UnicodePropertyEscape {
    #[doc = "Calls [FoldAstPath`::fold_unicode_property_escape`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_unicode_property_escape(visitor, self, __ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        match self {
            UnicodePropertyEscape {
                span,
                negative,
                strings,
                name,
                value,
            } => {
                let span = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::UnicodePropertyEscape(
                            self::fields::UnicodePropertyEscapeField::Span,
                        ));
                    <swc_common::Span as FoldWithAstPath<V>>::fold_with_ast_path(
                        span,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let name = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::UnicodePropertyEscape(
                            self::fields::UnicodePropertyEscapeField::Name,
                        ));
                    <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(
                        name,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                let value = {
                    let mut __ast_path =
                        __ast_path.with_guard(AstParentKind::UnicodePropertyEscape(
                            self::fields::UnicodePropertyEscapeField::Value,
                        ));
                    <Option<swc_atoms::Atom> as FoldWithAstPath<V>>::fold_with_ast_path(
                        value,
                        visitor,
                        &mut *__ast_path,
                    )
                };
                UnicodePropertyEscape {
                    span,
                    negative,
                    strings,
                    name,
                    value,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Alternative> {
    #[doc = "Calls [FoldAstPath`::fold_alternatives`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_alternatives(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Alternative as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [FoldAstPath`::fold_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<CharacterClassContents> {
    #[doc = "Calls [FoldAstPath`::fold_character_class_contentss`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_character_class_contentss(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <CharacterClassContents as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Character> {
    #[doc = "Calls [FoldAstPath`::fold_characters`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_characters(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Character as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ClassString> {
    #[doc = "Calls [FoldAstPath`::fold_class_strings`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_strings(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <ClassString as FoldWithAstPath<V>>::fold_with_ast_path(
                    item,
                    visitor,
                    &mut *__ast_path,
                )
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Modifier {
    #[doc = "Calls [FoldAstPath`::fold_modifier`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_modifier(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [FoldAstPath`::fold_opt_atom`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_atom(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Modifiers> {
    #[doc = "Calls [FoldAstPath`::fold_opt_modifiers`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_modifiers(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Modifiers as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [FoldAstPath`::fold_span`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_span(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Term> {
    #[doc = "Calls [FoldAstPath`::fold_terms`] with `self`. (Extra impl)"]
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_terms(visitor, self, __ast_path)
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .enumerate()
            .map(|(__idx, item)| {
                let mut __ast_path = __ast_path.with_index_guard(__idx);
                <Term as FoldWithAstPath<V>>::fold_with_ast_path(item, visitor, &mut *__ast_path)
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> FoldWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + FoldAstPath,
    T: FoldWithAstPath<V>,
{
    #[inline]
    fn fold_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        swc_visit::util::map::Map::map(self, |inner| {
            <T as FoldWithAstPath<V>>::fold_with_ast_path(inner, visitor, __ast_path)
        })
    }

    #[inline]
    fn fold_children_with_ast_path(self, visitor: &mut V, __ast_path: &mut AstKindPath) -> Self {
        swc_visit::util::map::Map::map(self, |inner| {
            <T as FoldWithAstPath<V>>::fold_children_with_ast_path(inner, visitor, __ast_path)
        })
    }
}
#[doc = r" A hook trait for composable AST visitors."]
#[doc = r""]
#[doc = r" This trait provides `enter_xxx` and `exit_xxx` methods for each AST node type."]
#[doc = r" The enter method is called before visiting children, and the exit method is called after."]
pub trait VisitMutHook {
    #[doc = "Called when entering a node of type `Alternative` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_alternative(&mut self, node: &mut Alternative) {}
    #[doc = "Called when exiting a node of type `Alternative` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_alternative(&mut self, node: &mut Alternative) {}
    #[doc = "Called when entering a node of type `Vec < Alternative >` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_alternatives(&mut self, node: &mut Vec<Alternative>) {}
    #[doc = "Called when exiting a node of type `Vec < Alternative >` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_alternatives(&mut self, node: &mut Vec<Alternative>) {}
    #[doc = "Called when entering a node of type `swc_atoms :: Atom` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_atom(&mut self, node: &mut swc_atoms::Atom) {}
    #[doc = "Called when exiting a node of type `swc_atoms :: Atom` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_atom(&mut self, node: &mut swc_atoms::Atom) {}
    #[doc = "Called when entering a node of type `BoundaryAssertion` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {}
    #[doc = "Called when exiting a node of type `BoundaryAssertion` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {}
    #[doc = "Called when entering a node of type `BoundaryAssertionKind` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {}
    #[doc = "Called when exiting a node of type `BoundaryAssertionKind` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {}
    #[doc = "Called when entering a node of type `CapturingGroup` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_capturing_group(&mut self, node: &mut CapturingGroup) {}
    #[doc = "Called when exiting a node of type `CapturingGroup` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_capturing_group(&mut self, node: &mut CapturingGroup) {}
    #[doc = "Called when entering a node of type `Character` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character(&mut self, node: &mut Character) {}
    #[doc = "Called when exiting a node of type `Character` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character(&mut self, node: &mut Character) {}
    #[doc = "Called when entering a node of type `CharacterClass` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_class(&mut self, node: &mut CharacterClass) {}
    #[doc = "Called when exiting a node of type `CharacterClass` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_class(&mut self, node: &mut CharacterClass) {}
    #[doc = "Called when entering a node of type `CharacterClassContents` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_class_contents(&mut self, node: &mut CharacterClassContents) {}
    #[doc = "Called when exiting a node of type `CharacterClassContents` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_class_contents(&mut self, node: &mut CharacterClassContents) {}
    #[doc = "Called when entering a node of type `CharacterClassContentsKind` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {}
    #[doc = "Called when exiting a node of type `CharacterClassContentsKind` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {}
    #[doc = "Called when entering a node of type `Vec < CharacterClassContents >` before visiting \
             its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {}
    #[doc = "Called when exiting a node of type `Vec < CharacterClassContents >` after visiting \
             its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {}
    #[doc = "Called when entering a node of type `CharacterClassEscape` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_class_escape(&mut self, node: &mut CharacterClassEscape) {}
    #[doc = "Called when exiting a node of type `CharacterClassEscape` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_class_escape(&mut self, node: &mut CharacterClassEscape) {}
    #[doc = "Called when entering a node of type `CharacterClassEscapeKind` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {}
    #[doc = "Called when exiting a node of type `CharacterClassEscapeKind` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {}
    #[doc = "Called when entering a node of type `CharacterClassRange` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_class_range(&mut self, node: &mut CharacterClassRange) {}
    #[doc = "Called when exiting a node of type `CharacterClassRange` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_class_range(&mut self, node: &mut CharacterClassRange) {}
    #[doc = "Called when entering a node of type `CharacterKind` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_character_kind(&mut self, node: &mut CharacterKind) {}
    #[doc = "Called when exiting a node of type `CharacterKind` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_character_kind(&mut self, node: &mut CharacterKind) {}
    #[doc = "Called when entering a node of type `Vec < Character >` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_characters(&mut self, node: &mut Vec<Character>) {}
    #[doc = "Called when exiting a node of type `Vec < Character >` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_characters(&mut self, node: &mut Vec<Character>) {}
    #[doc = "Called when entering a node of type `ClassString` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_class_string(&mut self, node: &mut ClassString) {}
    #[doc = "Called when exiting a node of type `ClassString` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_class_string(&mut self, node: &mut ClassString) {}
    #[doc = "Called when entering a node of type `ClassStringDisjunction` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {}
    #[doc = "Called when exiting a node of type `ClassStringDisjunction` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {}
    #[doc = "Called when entering a node of type `Vec < ClassString >` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_class_strings(&mut self, node: &mut Vec<ClassString>) {}
    #[doc = "Called when exiting a node of type `Vec < ClassString >` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_class_strings(&mut self, node: &mut Vec<ClassString>) {}
    #[doc = "Called when entering a node of type `Disjunction` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_disjunction(&mut self, node: &mut Disjunction) {}
    #[doc = "Called when exiting a node of type `Disjunction` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_disjunction(&mut self, node: &mut Disjunction) {}
    #[doc = "Called when entering a node of type `Dot` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_dot(&mut self, node: &mut Dot) {}
    #[doc = "Called when exiting a node of type `Dot` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_dot(&mut self, node: &mut Dot) {}
    #[doc = "Called when entering a node of type `IgnoreGroup` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_ignore_group(&mut self, node: &mut IgnoreGroup) {}
    #[doc = "Called when exiting a node of type `IgnoreGroup` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_ignore_group(&mut self, node: &mut IgnoreGroup) {}
    #[doc = "Called when entering a node of type `IndexedReference` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_indexed_reference(&mut self, node: &mut IndexedReference) {}
    #[doc = "Called when exiting a node of type `IndexedReference` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_indexed_reference(&mut self, node: &mut IndexedReference) {}
    #[doc = "Called when entering a node of type `LookAroundAssertion` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {}
    #[doc = "Called when exiting a node of type `LookAroundAssertion` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {}
    #[doc = "Called when entering a node of type `LookAroundAssertionKind` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {}
    #[doc = "Called when exiting a node of type `LookAroundAssertionKind` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {}
    #[doc = "Called when entering a node of type `Modifier` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_modifier(&mut self, node: &mut Modifier) {}
    #[doc = "Called when exiting a node of type `Modifier` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_modifier(&mut self, node: &mut Modifier) {}
    #[doc = "Called when entering a node of type `Modifiers` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_modifiers(&mut self, node: &mut Modifiers) {}
    #[doc = "Called when exiting a node of type `Modifiers` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_modifiers(&mut self, node: &mut Modifiers) {}
    #[doc = "Called when entering a node of type `NamedReference` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_named_reference(&mut self, node: &mut NamedReference) {}
    #[doc = "Called when exiting a node of type `NamedReference` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_named_reference(&mut self, node: &mut NamedReference) {}
    #[doc = "Called when entering a node of type `Option < swc_atoms :: Atom >` before visiting \
             its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {}
    #[doc = "Called when exiting a node of type `Option < swc_atoms :: Atom >` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {}
    #[doc = "Called when entering a node of type `Option < Modifiers >` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {}
    #[doc = "Called when exiting a node of type `Option < Modifiers >` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {}
    #[doc = "Called when entering a node of type `Pattern` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_pattern(&mut self, node: &mut Pattern) {}
    #[doc = "Called when exiting a node of type `Pattern` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_pattern(&mut self, node: &mut Pattern) {}
    #[doc = "Called when entering a node of type `Quantifier` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_quantifier(&mut self, node: &mut Quantifier) {}
    #[doc = "Called when exiting a node of type `Quantifier` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_quantifier(&mut self, node: &mut Quantifier) {}
    #[doc = "Called when entering a node of type `swc_common :: Span` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_span(&mut self, node: &mut swc_common::Span) {}
    #[doc = "Called when exiting a node of type `swc_common :: Span` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_span(&mut self, node: &mut swc_common::Span) {}
    #[doc = "Called when entering a node of type `Term` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_term(&mut self, node: &mut Term) {}
    #[doc = "Called when exiting a node of type `Term` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_term(&mut self, node: &mut Term) {}
    #[doc = "Called when entering a node of type `Vec < Term >` before visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_terms(&mut self, node: &mut Vec<Term>) {}
    #[doc = "Called when exiting a node of type `Vec < Term >` after visiting its children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_terms(&mut self, node: &mut Vec<Term>) {}
    #[doc = "Called when entering a node of type `UnicodePropertyEscape` before visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn enter_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {}
    #[doc = "Called when exiting a node of type `UnicodePropertyEscape` after visiting its \
             children."]
    #[inline]
    #[allow(unused_variables)]
    fn exit_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {}
}
#[doc = r" A composable hook that combines two hooks."]
#[doc = r""]
#[doc = r" Executes hooks in nested order:"]
#[doc = r" - Enter: first.enter -> second.enter"]
#[doc = r" - Exit: second.exit -> first.exit"]
pub struct CompositeHook<A, B> {
    pub first: A,
    pub second: B,
}
impl<A, B> VisitMutHook for CompositeHook<A, B>
where
    A: VisitMutHook,
    B: VisitMutHook,
{
    #[inline]
    fn enter_alternative(&mut self, node: &mut Alternative) {
        self.first.enter_alternative(node);
        self.second.enter_alternative(node);
    }

    #[inline]
    fn exit_alternative(&mut self, node: &mut Alternative) {
        self.second.exit_alternative(node);
        self.first.exit_alternative(node);
    }

    #[inline]
    fn enter_alternatives(&mut self, node: &mut Vec<Alternative>) {
        self.first.enter_alternatives(node);
        self.second.enter_alternatives(node);
    }

    #[inline]
    fn exit_alternatives(&mut self, node: &mut Vec<Alternative>) {
        self.second.exit_alternatives(node);
        self.first.exit_alternatives(node);
    }

    #[inline]
    fn enter_atom(&mut self, node: &mut swc_atoms::Atom) {
        self.first.enter_atom(node);
        self.second.enter_atom(node);
    }

    #[inline]
    fn exit_atom(&mut self, node: &mut swc_atoms::Atom) {
        self.second.exit_atom(node);
        self.first.exit_atom(node);
    }

    #[inline]
    fn enter_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        self.first.enter_boundary_assertion(node);
        self.second.enter_boundary_assertion(node);
    }

    #[inline]
    fn exit_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        self.second.exit_boundary_assertion(node);
        self.first.exit_boundary_assertion(node);
    }

    #[inline]
    fn enter_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        self.first.enter_boundary_assertion_kind(node);
        self.second.enter_boundary_assertion_kind(node);
    }

    #[inline]
    fn exit_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        self.second.exit_boundary_assertion_kind(node);
        self.first.exit_boundary_assertion_kind(node);
    }

    #[inline]
    fn enter_capturing_group(&mut self, node: &mut CapturingGroup) {
        self.first.enter_capturing_group(node);
        self.second.enter_capturing_group(node);
    }

    #[inline]
    fn exit_capturing_group(&mut self, node: &mut CapturingGroup) {
        self.second.exit_capturing_group(node);
        self.first.exit_capturing_group(node);
    }

    #[inline]
    fn enter_character(&mut self, node: &mut Character) {
        self.first.enter_character(node);
        self.second.enter_character(node);
    }

    #[inline]
    fn exit_character(&mut self, node: &mut Character) {
        self.second.exit_character(node);
        self.first.exit_character(node);
    }

    #[inline]
    fn enter_character_class(&mut self, node: &mut CharacterClass) {
        self.first.enter_character_class(node);
        self.second.enter_character_class(node);
    }

    #[inline]
    fn exit_character_class(&mut self, node: &mut CharacterClass) {
        self.second.exit_character_class(node);
        self.first.exit_character_class(node);
    }

    #[inline]
    fn enter_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        self.first.enter_character_class_contents(node);
        self.second.enter_character_class_contents(node);
    }

    #[inline]
    fn exit_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        self.second.exit_character_class_contents(node);
        self.first.exit_character_class_contents(node);
    }

    #[inline]
    fn enter_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        self.first.enter_character_class_contents_kind(node);
        self.second.enter_character_class_contents_kind(node);
    }

    #[inline]
    fn exit_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        self.second.exit_character_class_contents_kind(node);
        self.first.exit_character_class_contents_kind(node);
    }

    #[inline]
    fn enter_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        self.first.enter_character_class_contentss(node);
        self.second.enter_character_class_contentss(node);
    }

    #[inline]
    fn exit_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        self.second.exit_character_class_contentss(node);
        self.first.exit_character_class_contentss(node);
    }

    #[inline]
    fn enter_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        self.first.enter_character_class_escape(node);
        self.second.enter_character_class_escape(node);
    }

    #[inline]
    fn exit_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        self.second.exit_character_class_escape(node);
        self.first.exit_character_class_escape(node);
    }

    #[inline]
    fn enter_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        self.first.enter_character_class_escape_kind(node);
        self.second.enter_character_class_escape_kind(node);
    }

    #[inline]
    fn exit_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        self.second.exit_character_class_escape_kind(node);
        self.first.exit_character_class_escape_kind(node);
    }

    #[inline]
    fn enter_character_class_range(&mut self, node: &mut CharacterClassRange) {
        self.first.enter_character_class_range(node);
        self.second.enter_character_class_range(node);
    }

    #[inline]
    fn exit_character_class_range(&mut self, node: &mut CharacterClassRange) {
        self.second.exit_character_class_range(node);
        self.first.exit_character_class_range(node);
    }

    #[inline]
    fn enter_character_kind(&mut self, node: &mut CharacterKind) {
        self.first.enter_character_kind(node);
        self.second.enter_character_kind(node);
    }

    #[inline]
    fn exit_character_kind(&mut self, node: &mut CharacterKind) {
        self.second.exit_character_kind(node);
        self.first.exit_character_kind(node);
    }

    #[inline]
    fn enter_characters(&mut self, node: &mut Vec<Character>) {
        self.first.enter_characters(node);
        self.second.enter_characters(node);
    }

    #[inline]
    fn exit_characters(&mut self, node: &mut Vec<Character>) {
        self.second.exit_characters(node);
        self.first.exit_characters(node);
    }

    #[inline]
    fn enter_class_string(&mut self, node: &mut ClassString) {
        self.first.enter_class_string(node);
        self.second.enter_class_string(node);
    }

    #[inline]
    fn exit_class_string(&mut self, node: &mut ClassString) {
        self.second.exit_class_string(node);
        self.first.exit_class_string(node);
    }

    #[inline]
    fn enter_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        self.first.enter_class_string_disjunction(node);
        self.second.enter_class_string_disjunction(node);
    }

    #[inline]
    fn exit_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        self.second.exit_class_string_disjunction(node);
        self.first.exit_class_string_disjunction(node);
    }

    #[inline]
    fn enter_class_strings(&mut self, node: &mut Vec<ClassString>) {
        self.first.enter_class_strings(node);
        self.second.enter_class_strings(node);
    }

    #[inline]
    fn exit_class_strings(&mut self, node: &mut Vec<ClassString>) {
        self.second.exit_class_strings(node);
        self.first.exit_class_strings(node);
    }

    #[inline]
    fn enter_disjunction(&mut self, node: &mut Disjunction) {
        self.first.enter_disjunction(node);
        self.second.enter_disjunction(node);
    }

    #[inline]
    fn exit_disjunction(&mut self, node: &mut Disjunction) {
        self.second.exit_disjunction(node);
        self.first.exit_disjunction(node);
    }

    #[inline]
    fn enter_dot(&mut self, node: &mut Dot) {
        self.first.enter_dot(node);
        self.second.enter_dot(node);
    }

    #[inline]
    fn exit_dot(&mut self, node: &mut Dot) {
        self.second.exit_dot(node);
        self.first.exit_dot(node);
    }

    #[inline]
    fn enter_ignore_group(&mut self, node: &mut IgnoreGroup) {
        self.first.enter_ignore_group(node);
        self.second.enter_ignore_group(node);
    }

    #[inline]
    fn exit_ignore_group(&mut self, node: &mut IgnoreGroup) {
        self.second.exit_ignore_group(node);
        self.first.exit_ignore_group(node);
    }

    #[inline]
    fn enter_indexed_reference(&mut self, node: &mut IndexedReference) {
        self.first.enter_indexed_reference(node);
        self.second.enter_indexed_reference(node);
    }

    #[inline]
    fn exit_indexed_reference(&mut self, node: &mut IndexedReference) {
        self.second.exit_indexed_reference(node);
        self.first.exit_indexed_reference(node);
    }

    #[inline]
    fn enter_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        self.first.enter_look_around_assertion(node);
        self.second.enter_look_around_assertion(node);
    }

    #[inline]
    fn exit_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        self.second.exit_look_around_assertion(node);
        self.first.exit_look_around_assertion(node);
    }

    #[inline]
    fn enter_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        self.first.enter_look_around_assertion_kind(node);
        self.second.enter_look_around_assertion_kind(node);
    }

    #[inline]
    fn exit_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        self.second.exit_look_around_assertion_kind(node);
        self.first.exit_look_around_assertion_kind(node);
    }

    #[inline]
    fn enter_modifier(&mut self, node: &mut Modifier) {
        self.first.enter_modifier(node);
        self.second.enter_modifier(node);
    }

    #[inline]
    fn exit_modifier(&mut self, node: &mut Modifier) {
        self.second.exit_modifier(node);
        self.first.exit_modifier(node);
    }

    #[inline]
    fn enter_modifiers(&mut self, node: &mut Modifiers) {
        self.first.enter_modifiers(node);
        self.second.enter_modifiers(node);
    }

    #[inline]
    fn exit_modifiers(&mut self, node: &mut Modifiers) {
        self.second.exit_modifiers(node);
        self.first.exit_modifiers(node);
    }

    #[inline]
    fn enter_named_reference(&mut self, node: &mut NamedReference) {
        self.first.enter_named_reference(node);
        self.second.enter_named_reference(node);
    }

    #[inline]
    fn exit_named_reference(&mut self, node: &mut NamedReference) {
        self.second.exit_named_reference(node);
        self.first.exit_named_reference(node);
    }

    #[inline]
    fn enter_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        self.first.enter_opt_atom(node);
        self.second.enter_opt_atom(node);
    }

    #[inline]
    fn exit_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        self.second.exit_opt_atom(node);
        self.first.exit_opt_atom(node);
    }

    #[inline]
    fn enter_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        self.first.enter_opt_modifiers(node);
        self.second.enter_opt_modifiers(node);
    }

    #[inline]
    fn exit_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        self.second.exit_opt_modifiers(node);
        self.first.exit_opt_modifiers(node);
    }

    #[inline]
    fn enter_pattern(&mut self, node: &mut Pattern) {
        self.first.enter_pattern(node);
        self.second.enter_pattern(node);
    }

    #[inline]
    fn exit_pattern(&mut self, node: &mut Pattern) {
        self.second.exit_pattern(node);
        self.first.exit_pattern(node);
    }

    #[inline]
    fn enter_quantifier(&mut self, node: &mut Quantifier) {
        self.first.enter_quantifier(node);
        self.second.enter_quantifier(node);
    }

    #[inline]
    fn exit_quantifier(&mut self, node: &mut Quantifier) {
        self.second.exit_quantifier(node);
        self.first.exit_quantifier(node);
    }

    #[inline]
    fn enter_span(&mut self, node: &mut swc_common::Span) {
        self.first.enter_span(node);
        self.second.enter_span(node);
    }

    #[inline]
    fn exit_span(&mut self, node: &mut swc_common::Span) {
        self.second.exit_span(node);
        self.first.exit_span(node);
    }

    #[inline]
    fn enter_term(&mut self, node: &mut Term) {
        self.first.enter_term(node);
        self.second.enter_term(node);
    }

    #[inline]
    fn exit_term(&mut self, node: &mut Term) {
        self.second.exit_term(node);
        self.first.exit_term(node);
    }

    #[inline]
    fn enter_terms(&mut self, node: &mut Vec<Term>) {
        self.first.enter_terms(node);
        self.second.enter_terms(node);
    }

    #[inline]
    fn exit_terms(&mut self, node: &mut Vec<Term>) {
        self.second.exit_terms(node);
        self.first.exit_terms(node);
    }

    #[inline]
    fn enter_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        self.first.enter_unicode_property_escape(node);
        self.second.enter_unicode_property_escape(node);
    }

    #[inline]
    fn exit_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        self.second.exit_unicode_property_escape(node);
        self.first.exit_unicode_property_escape(node);
    }
}
#[doc = r" An adapter that implements VisitMut using a VisitMutHook."]
#[doc = r""]
#[doc = r" This allows any hook to be used as a visitor by calling:"]
#[doc = r" - hook.enter_xxx before visiting children"]
#[doc = r" - hook.exit_xxx after visiting children"]
pub struct VisitMutWithHook<H> {
    pub hook: H,
}
impl<H: VisitMutHook> VisitMut for VisitMutWithHook<H> {
    #[doc = "Visits a node of type `Alternative` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_alternative(&mut self, node: &mut Alternative) {
        self.hook.enter_alternative(node);
        node.visit_mut_children_with(self);
        self.hook.exit_alternative(node);
    }

    #[doc = "Visits a node of type `Vec < Alternative >` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_alternatives(&mut self, node: &mut Vec<Alternative>) {
        self.hook.enter_alternatives(node);
        node.visit_mut_children_with(self);
        self.hook.exit_alternatives(node);
    }

    #[doc = "Visits a node of type `swc_atoms :: Atom` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        self.hook.enter_atom(node);
        node.visit_mut_children_with(self);
        self.hook.exit_atom(node);
    }

    #[doc = "Visits a node of type `BoundaryAssertion` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_boundary_assertion(&mut self, node: &mut BoundaryAssertion) {
        self.hook.enter_boundary_assertion(node);
        node.visit_mut_children_with(self);
        self.hook.exit_boundary_assertion(node);
    }

    #[doc = "Visits a node of type `BoundaryAssertionKind` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_boundary_assertion_kind(&mut self, node: &mut BoundaryAssertionKind) {
        self.hook.enter_boundary_assertion_kind(node);
        node.visit_mut_children_with(self);
        self.hook.exit_boundary_assertion_kind(node);
    }

    #[doc = "Visits a node of type `CapturingGroup` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_capturing_group(&mut self, node: &mut CapturingGroup) {
        self.hook.enter_capturing_group(node);
        node.visit_mut_children_with(self);
        self.hook.exit_capturing_group(node);
    }

    #[doc = "Visits a node of type `Character` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_character(&mut self, node: &mut Character) {
        self.hook.enter_character(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character(node);
    }

    #[doc = "Visits a node of type `CharacterClass` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_character_class(&mut self, node: &mut CharacterClass) {
        self.hook.enter_character_class(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_class(node);
    }

    #[doc = "Visits a node of type `CharacterClassContents` using the hook's enter and exit \
             methods."]
    #[inline]
    fn visit_mut_character_class_contents(&mut self, node: &mut CharacterClassContents) {
        self.hook.enter_character_class_contents(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_class_contents(node);
    }

    #[doc = "Visits a node of type `CharacterClassContentsKind` using the hook's enter and exit \
             methods."]
    #[inline]
    fn visit_mut_character_class_contents_kind(&mut self, node: &mut CharacterClassContentsKind) {
        self.hook.enter_character_class_contents_kind(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_class_contents_kind(node);
    }

    #[doc = "Visits a node of type `Vec < CharacterClassContents >` using the hook's enter and \
             exit methods."]
    #[inline]
    fn visit_mut_character_class_contentss(&mut self, node: &mut Vec<CharacterClassContents>) {
        self.hook.enter_character_class_contentss(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_class_contentss(node);
    }

    #[doc = "Visits a node of type `CharacterClassEscape` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_character_class_escape(&mut self, node: &mut CharacterClassEscape) {
        self.hook.enter_character_class_escape(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_class_escape(node);
    }

    #[doc = "Visits a node of type `CharacterClassEscapeKind` using the hook's enter and exit \
             methods."]
    #[inline]
    fn visit_mut_character_class_escape_kind(&mut self, node: &mut CharacterClassEscapeKind) {
        self.hook.enter_character_class_escape_kind(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_class_escape_kind(node);
    }

    #[doc = "Visits a node of type `CharacterClassRange` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_character_class_range(&mut self, node: &mut CharacterClassRange) {
        self.hook.enter_character_class_range(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_class_range(node);
    }

    #[doc = "Visits a node of type `CharacterKind` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_character_kind(&mut self, node: &mut CharacterKind) {
        self.hook.enter_character_kind(node);
        node.visit_mut_children_with(self);
        self.hook.exit_character_kind(node);
    }

    #[doc = "Visits a node of type `Vec < Character >` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_characters(&mut self, node: &mut Vec<Character>) {
        self.hook.enter_characters(node);
        node.visit_mut_children_with(self);
        self.hook.exit_characters(node);
    }

    #[doc = "Visits a node of type `ClassString` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_class_string(&mut self, node: &mut ClassString) {
        self.hook.enter_class_string(node);
        node.visit_mut_children_with(self);
        self.hook.exit_class_string(node);
    }

    #[doc = "Visits a node of type `ClassStringDisjunction` using the hook's enter and exit \
             methods."]
    #[inline]
    fn visit_mut_class_string_disjunction(&mut self, node: &mut ClassStringDisjunction) {
        self.hook.enter_class_string_disjunction(node);
        node.visit_mut_children_with(self);
        self.hook.exit_class_string_disjunction(node);
    }

    #[doc = "Visits a node of type `Vec < ClassString >` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_class_strings(&mut self, node: &mut Vec<ClassString>) {
        self.hook.enter_class_strings(node);
        node.visit_mut_children_with(self);
        self.hook.exit_class_strings(node);
    }

    #[doc = "Visits a node of type `Disjunction` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_disjunction(&mut self, node: &mut Disjunction) {
        self.hook.enter_disjunction(node);
        node.visit_mut_children_with(self);
        self.hook.exit_disjunction(node);
    }

    #[doc = "Visits a node of type `Dot` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_dot(&mut self, node: &mut Dot) {
        self.hook.enter_dot(node);
        node.visit_mut_children_with(self);
        self.hook.exit_dot(node);
    }

    #[doc = "Visits a node of type `IgnoreGroup` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_ignore_group(&mut self, node: &mut IgnoreGroup) {
        self.hook.enter_ignore_group(node);
        node.visit_mut_children_with(self);
        self.hook.exit_ignore_group(node);
    }

    #[doc = "Visits a node of type `IndexedReference` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_indexed_reference(&mut self, node: &mut IndexedReference) {
        self.hook.enter_indexed_reference(node);
        node.visit_mut_children_with(self);
        self.hook.exit_indexed_reference(node);
    }

    #[doc = "Visits a node of type `LookAroundAssertion` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_look_around_assertion(&mut self, node: &mut LookAroundAssertion) {
        self.hook.enter_look_around_assertion(node);
        node.visit_mut_children_with(self);
        self.hook.exit_look_around_assertion(node);
    }

    #[doc = "Visits a node of type `LookAroundAssertionKind` using the hook's enter and exit \
             methods."]
    #[inline]
    fn visit_mut_look_around_assertion_kind(&mut self, node: &mut LookAroundAssertionKind) {
        self.hook.enter_look_around_assertion_kind(node);
        node.visit_mut_children_with(self);
        self.hook.exit_look_around_assertion_kind(node);
    }

    #[doc = "Visits a node of type `Modifier` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_modifier(&mut self, node: &mut Modifier) {
        self.hook.enter_modifier(node);
        node.visit_mut_children_with(self);
        self.hook.exit_modifier(node);
    }

    #[doc = "Visits a node of type `Modifiers` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_modifiers(&mut self, node: &mut Modifiers) {
        self.hook.enter_modifiers(node);
        node.visit_mut_children_with(self);
        self.hook.exit_modifiers(node);
    }

    #[doc = "Visits a node of type `NamedReference` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_named_reference(&mut self, node: &mut NamedReference) {
        self.hook.enter_named_reference(node);
        node.visit_mut_children_with(self);
        self.hook.exit_named_reference(node);
    }

    #[doc = "Visits a node of type `Option < swc_atoms :: Atom >` using the hook's enter and exit \
             methods."]
    #[inline]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        self.hook.enter_opt_atom(node);
        node.visit_mut_children_with(self);
        self.hook.exit_opt_atom(node);
    }

    #[doc = "Visits a node of type `Option < Modifiers >` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_opt_modifiers(&mut self, node: &mut Option<Modifiers>) {
        self.hook.enter_opt_modifiers(node);
        node.visit_mut_children_with(self);
        self.hook.exit_opt_modifiers(node);
    }

    #[doc = "Visits a node of type `Pattern` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_pattern(&mut self, node: &mut Pattern) {
        self.hook.enter_pattern(node);
        node.visit_mut_children_with(self);
        self.hook.exit_pattern(node);
    }

    #[doc = "Visits a node of type `Quantifier` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_quantifier(&mut self, node: &mut Quantifier) {
        self.hook.enter_quantifier(node);
        node.visit_mut_children_with(self);
        self.hook.exit_quantifier(node);
    }

    #[doc = "Visits a node of type `swc_common :: Span` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        self.hook.enter_span(node);
        node.visit_mut_children_with(self);
        self.hook.exit_span(node);
    }

    #[doc = "Visits a node of type `Term` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_term(&mut self, node: &mut Term) {
        self.hook.enter_term(node);
        node.visit_mut_children_with(self);
        self.hook.exit_term(node);
    }

    #[doc = "Visits a node of type `Vec < Term >` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_terms(&mut self, node: &mut Vec<Term>) {
        self.hook.enter_terms(node);
        node.visit_mut_children_with(self);
        self.hook.exit_terms(node);
    }

    #[doc = "Visits a node of type `UnicodePropertyEscape` using the hook's enter and exit methods."]
    #[inline]
    fn visit_mut_unicode_property_escape(&mut self, node: &mut UnicodePropertyEscape) {
        self.hook.enter_unicode_property_escape(node);
        node.visit_mut_children_with(self);
        self.hook.exit_unicode_property_escape(node);
    }
}
#[cfg(any(docsrs, feature = "path"))]
pub type AstKindPath = swc_visit::AstKindPath<AstParentKind>;
#[cfg(any(docsrs, feature = "path"))]
pub type AstNodePath<'ast> = swc_visit::AstNodePath<AstParentNodeRef<'ast>>;
#[cfg(any(docsrs, feature = "path"))]
pub mod fields {
    use swc_ecma_regexp_ast::*;
    #[inline(always)]
    fn assert_initial_index(idx: usize, index: usize) {
        #[cfg(debug_assertions)]
        if !(idx == usize::MAX || index == usize::MAX) {
            {
                panic!("Should be usize::MAX");
            }
        }
    }
    impl AlternativeField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AlternativeField {
        #[doc = "Represents [`Alternative::span`]"]
        Span,
        #[doc = "Represents [`Alternative::body`]"]
        Body(usize),
    }
    impl BoundaryAssertionField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BoundaryAssertionField {
        #[doc = "Represents [`BoundaryAssertion::span`]"]
        Span,
        #[doc = "Represents [`BoundaryAssertion::kind`]"]
        Kind,
    }
    impl BoundaryAssertionKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum BoundaryAssertionKindField {
        #[doc = "Represents [`BoundaryAssertionKind::Start`]"]
        Start,
        #[doc = "Represents [`BoundaryAssertionKind::End`]"]
        End,
        #[doc = "Represents [`BoundaryAssertionKind::Boundary`]"]
        Boundary,
        #[doc = "Represents [`BoundaryAssertionKind::NegativeBoundary`]"]
        NegativeBoundary,
    }
    impl CapturingGroupField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CapturingGroupField {
        #[doc = "Represents [`CapturingGroup::span`]"]
        Span,
        #[doc = "Represents [`CapturingGroup::name`]"]
        Name,
        #[doc = "Represents [`CapturingGroup::body`]"]
        Body,
    }
    impl CharacterField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterField {
        #[doc = "Represents [`Character::span`]"]
        Span,
        #[doc = "Represents [`Character::kind`]"]
        Kind,
        #[doc = "Represents [`Character::value`]"]
        Value,
    }
    impl CharacterClassField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterClassField {
        #[doc = "Represents [`CharacterClass::span`]"]
        Span,
        #[doc = "Represents [`CharacterClass::negative`]"]
        Negative,
        #[doc = "Represents [`CharacterClass::strings`]"]
        Strings,
        #[doc = "Represents [`CharacterClass::kind`]"]
        Kind,
        #[doc = "Represents [`CharacterClass::body`]"]
        Body(usize),
    }
    impl CharacterClassContentsField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterClassContentsField {
        #[doc = "Represents [`CharacterClassContents::CharacterClassRange`]"]
        CharacterClassRange,
        #[doc = "Represents [`CharacterClassContents::CharacterClassEscape`]"]
        CharacterClassEscape,
        #[doc = "Represents [`CharacterClassContents::UnicodePropertyEscape`]"]
        UnicodePropertyEscape,
        #[doc = "Represents [`CharacterClassContents::Character`]"]
        Character,
        #[doc = "Represents [`CharacterClassContents::NestedCharacterClass`]"]
        NestedCharacterClass,
        #[doc = "Represents [`CharacterClassContents::ClassStringDisjunction`]"]
        ClassStringDisjunction,
    }
    impl CharacterClassContentsKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterClassContentsKindField {
        #[doc = "Represents [`CharacterClassContentsKind::Union`]"]
        Union,
        #[doc = "Represents [`CharacterClassContentsKind::Intersection`]"]
        Intersection,
        #[doc = "Represents [`CharacterClassContentsKind::Subtraction`]"]
        Subtraction,
    }
    impl CharacterClassEscapeField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterClassEscapeField {
        #[doc = "Represents [`CharacterClassEscape::span`]"]
        Span,
        #[doc = "Represents [`CharacterClassEscape::kind`]"]
        Kind,
    }
    impl CharacterClassEscapeKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterClassEscapeKindField {
        #[doc = "Represents [`CharacterClassEscapeKind::D`]"]
        D,
        #[doc = "Represents [`CharacterClassEscapeKind::NegativeD`]"]
        NegativeD,
        #[doc = "Represents [`CharacterClassEscapeKind::S`]"]
        S,
        #[doc = "Represents [`CharacterClassEscapeKind::NegativeS`]"]
        NegativeS,
        #[doc = "Represents [`CharacterClassEscapeKind::W`]"]
        W,
        #[doc = "Represents [`CharacterClassEscapeKind::NegativeW`]"]
        NegativeW,
    }
    impl CharacterClassRangeField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterClassRangeField {
        #[doc = "Represents [`CharacterClassRange::span`]"]
        Span,
        #[doc = "Represents [`CharacterClassRange::min`]"]
        Min,
        #[doc = "Represents [`CharacterClassRange::max`]"]
        Max,
    }
    impl CharacterKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum CharacterKindField {
        #[doc = "Represents [`CharacterKind::ControlLetter`]"]
        ControlLetter,
        #[doc = "Represents [`CharacterKind::HexadecimalEscape`]"]
        HexadecimalEscape,
        #[doc = "Represents [`CharacterKind::Identifier`]"]
        Identifier,
        #[doc = "Represents [`CharacterKind::Null`]"]
        Null,
        #[doc = "Represents [`CharacterKind::Octal1`]"]
        Octal1,
        #[doc = "Represents [`CharacterKind::Octal2`]"]
        Octal2,
        #[doc = "Represents [`CharacterKind::Octal3`]"]
        Octal3,
        #[doc = "Represents [`CharacterKind::SingleEscape`]"]
        SingleEscape,
        #[doc = "Represents [`CharacterKind::Symbol`]"]
        Symbol,
        #[doc = "Represents [`CharacterKind::UnicodeEscape`]"]
        UnicodeEscape,
    }
    impl ClassStringField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassStringField {
        #[doc = "Represents [`ClassString::span`]"]
        Span,
        #[doc = "Represents [`ClassString::strings`]"]
        Strings,
        #[doc = "Represents [`ClassString::body`]"]
        Body(usize),
    }
    impl ClassStringDisjunctionField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ClassStringDisjunctionField {
        #[doc = "Represents [`ClassStringDisjunction::span`]"]
        Span,
        #[doc = "Represents [`ClassStringDisjunction::strings`]"]
        Strings,
        #[doc = "Represents [`ClassStringDisjunction::body`]"]
        Body(usize),
    }
    impl DisjunctionField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                Self::Body(idx) => {
                    assert_initial_index(*idx, index);
                    *idx = index;
                }
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum DisjunctionField {
        #[doc = "Represents [`Disjunction::span`]"]
        Span,
        #[doc = "Represents [`Disjunction::body`]"]
        Body(usize),
    }
    impl DotField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum DotField {
        #[doc = "Represents [`Dot::span`]"]
        Span,
    }
    impl IgnoreGroupField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum IgnoreGroupField {
        #[doc = "Represents [`IgnoreGroup::span`]"]
        Span,
        #[doc = "Represents [`IgnoreGroup::modifiers`]"]
        Modifiers,
        #[doc = "Represents [`IgnoreGroup::body`]"]
        Body,
    }
    impl IndexedReferenceField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum IndexedReferenceField {
        #[doc = "Represents [`IndexedReference::span`]"]
        Span,
        #[doc = "Represents [`IndexedReference::index`]"]
        Index,
    }
    impl LookAroundAssertionField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum LookAroundAssertionField {
        #[doc = "Represents [`LookAroundAssertion::span`]"]
        Span,
        #[doc = "Represents [`LookAroundAssertion::kind`]"]
        Kind,
        #[doc = "Represents [`LookAroundAssertion::body`]"]
        Body,
    }
    impl LookAroundAssertionKindField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum LookAroundAssertionKindField {
        #[doc = "Represents [`LookAroundAssertionKind::Lookahead`]"]
        Lookahead,
        #[doc = "Represents [`LookAroundAssertionKind::NegativeLookahead`]"]
        NegativeLookahead,
        #[doc = "Represents [`LookAroundAssertionKind::Lookbehind`]"]
        Lookbehind,
        #[doc = "Represents [`LookAroundAssertionKind::NegativeLookbehind`]"]
        NegativeLookbehind,
    }
    impl ModifiersField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum ModifiersField {
        #[doc = "Represents [`Modifiers::span`]"]
        Span,
        #[doc = "Represents [`Modifiers::enabling`]"]
        Enabling,
        #[doc = "Represents [`Modifiers::disabling`]"]
        Disabling,
    }
    impl NamedReferenceField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum NamedReferenceField {
        #[doc = "Represents [`NamedReference::span`]"]
        Span,
        #[doc = "Represents [`NamedReference::name`]"]
        Name,
    }
    impl PatternField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum PatternField {
        #[doc = "Represents [`Pattern::span`]"]
        Span,
        #[doc = "Represents [`Pattern::body`]"]
        Body,
    }
    impl QuantifierField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum QuantifierField {
        #[doc = "Represents [`Quantifier::span`]"]
        Span,
        #[doc = "Represents [`Quantifier::min`]"]
        Min,
        #[doc = "Represents [`Quantifier::max`]"]
        Max,
        #[doc = "Represents [`Quantifier::greedy`]"]
        Greedy,
        #[doc = "Represents [`Quantifier::body`]"]
        Body,
    }
    impl TermField {
        #[inline(always)]
        pub(crate) fn set_index(&mut self, _: usize) {
            swc_visit::wrong_ast_path();
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum TermField {
        #[doc = "Represents [`Term::BoundaryAssertion`]"]
        BoundaryAssertion,
        #[doc = "Represents [`Term::LookAroundAssertion`]"]
        LookAroundAssertion,
        #[doc = "Represents [`Term::Quantifier`]"]
        Quantifier,
        #[doc = "Represents [`Term::Character`]"]
        Character,
        #[doc = "Represents [`Term::Dot`]"]
        Dot,
        #[doc = "Represents [`Term::CharacterClassEscape`]"]
        CharacterClassEscape,
        #[doc = "Represents [`Term::UnicodePropertyEscape`]"]
        UnicodePropertyEscape,
        #[doc = "Represents [`Term::CharacterClass`]"]
        CharacterClass,
        #[doc = "Represents [`Term::CapturingGroup`]"]
        CapturingGroup,
        #[doc = "Represents [`Term::IgnoreGroup`]"]
        IgnoreGroup,
        #[doc = "Represents [`Term::IndexedReference`]"]
        IndexedReference,
        #[doc = "Represents [`Term::NamedReference`]"]
        NamedReference,
    }
    impl UnicodePropertyEscapeField {
        pub(crate) fn set_index(&mut self, index: usize) {
            match self {
                _ => swc_visit::wrong_ast_path(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum UnicodePropertyEscapeField {
        #[doc = "Represents [`UnicodePropertyEscape::span`]"]
        Span,
        #[doc = "Represents [`UnicodePropertyEscape::negative`]"]
        Negative,
        #[doc = "Represents [`UnicodePropertyEscape::strings`]"]
        Strings,
        #[doc = "Represents [`UnicodePropertyEscape::name`]"]
        Name,
        #[doc = "Represents [`UnicodePropertyEscape::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[cfg_attr(feature = "serde-impl", derive(serde::Serialize, serde::Deserialize))]
    pub enum AstParentKind {
        Alternative(AlternativeField),
        BoundaryAssertion(BoundaryAssertionField),
        BoundaryAssertionKind(BoundaryAssertionKindField),
        CapturingGroup(CapturingGroupField),
        Character(CharacterField),
        CharacterClass(CharacterClassField),
        CharacterClassContents(CharacterClassContentsField),
        CharacterClassContentsKind(CharacterClassContentsKindField),
        CharacterClassEscape(CharacterClassEscapeField),
        CharacterClassEscapeKind(CharacterClassEscapeKindField),
        CharacterClassRange(CharacterClassRangeField),
        CharacterKind(CharacterKindField),
        ClassString(ClassStringField),
        ClassStringDisjunction(ClassStringDisjunctionField),
        Disjunction(DisjunctionField),
        Dot(DotField),
        IgnoreGroup(IgnoreGroupField),
        IndexedReference(IndexedReferenceField),
        LookAroundAssertion(LookAroundAssertionField),
        LookAroundAssertionKind(LookAroundAssertionKindField),
        Modifiers(ModifiersField),
        NamedReference(NamedReferenceField),
        Pattern(PatternField),
        Quantifier(QuantifierField),
        Term(TermField),
        UnicodePropertyEscape(UnicodePropertyEscapeField),
    }
    impl ::swc_visit::ParentKind for AstParentKind {
        #[inline]
        fn set_index(&mut self, index: usize) {
            match self {
                Self::Alternative(v) => v.set_index(index),
                Self::BoundaryAssertion(v) => v.set_index(index),
                Self::BoundaryAssertionKind(v) => v.set_index(index),
                Self::CapturingGroup(v) => v.set_index(index),
                Self::Character(v) => v.set_index(index),
                Self::CharacterClass(v) => v.set_index(index),
                Self::CharacterClassContents(v) => v.set_index(index),
                Self::CharacterClassContentsKind(v) => v.set_index(index),
                Self::CharacterClassEscape(v) => v.set_index(index),
                Self::CharacterClassEscapeKind(v) => v.set_index(index),
                Self::CharacterClassRange(v) => v.set_index(index),
                Self::CharacterKind(v) => v.set_index(index),
                Self::ClassString(v) => v.set_index(index),
                Self::ClassStringDisjunction(v) => v.set_index(index),
                Self::Disjunction(v) => v.set_index(index),
                Self::Dot(v) => v.set_index(index),
                Self::IgnoreGroup(v) => v.set_index(index),
                Self::IndexedReference(v) => v.set_index(index),
                Self::LookAroundAssertion(v) => v.set_index(index),
                Self::LookAroundAssertionKind(v) => v.set_index(index),
                Self::Modifiers(v) => v.set_index(index),
                Self::NamedReference(v) => v.set_index(index),
                Self::Pattern(v) => v.set_index(index),
                Self::Quantifier(v) => v.set_index(index),
                Self::Term(v) => v.set_index(index),
                Self::UnicodePropertyEscape(v) => v.set_index(index),
            }
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub enum AstParentNodeRef<'ast> {
        Alternative(&'ast Alternative, AlternativeField),
        BoundaryAssertion(&'ast BoundaryAssertion, BoundaryAssertionField),
        BoundaryAssertionKind(&'ast BoundaryAssertionKind, BoundaryAssertionKindField),
        CapturingGroup(&'ast CapturingGroup, CapturingGroupField),
        Character(&'ast Character, CharacterField),
        CharacterClass(&'ast CharacterClass, CharacterClassField),
        CharacterClassContents(&'ast CharacterClassContents, CharacterClassContentsField),
        CharacterClassContentsKind(
            &'ast CharacterClassContentsKind,
            CharacterClassContentsKindField,
        ),
        CharacterClassEscape(&'ast CharacterClassEscape, CharacterClassEscapeField),
        CharacterClassEscapeKind(
            &'ast CharacterClassEscapeKind,
            CharacterClassEscapeKindField,
        ),
        CharacterClassRange(&'ast CharacterClassRange, CharacterClassRangeField),
        CharacterKind(&'ast CharacterKind, CharacterKindField),
        ClassString(&'ast ClassString, ClassStringField),
        ClassStringDisjunction(&'ast ClassStringDisjunction, ClassStringDisjunctionField),
        Disjunction(&'ast Disjunction, DisjunctionField),
        Dot(&'ast Dot, DotField),
        IgnoreGroup(&'ast IgnoreGroup, IgnoreGroupField),
        IndexedReference(&'ast IndexedReference, IndexedReferenceField),
        LookAroundAssertion(&'ast LookAroundAssertion, LookAroundAssertionField),
        LookAroundAssertionKind(&'ast LookAroundAssertionKind, LookAroundAssertionKindField),
        Modifiers(&'ast Modifiers, ModifiersField),
        NamedReference(&'ast NamedReference, NamedReferenceField),
        Pattern(&'ast Pattern, PatternField),
        Quantifier(&'ast Quantifier, QuantifierField),
        Term(&'ast Term, TermField),
        UnicodePropertyEscape(&'ast UnicodePropertyEscape, UnicodePropertyEscapeField),
    }
    impl<'ast> ::swc_visit::NodeRef for AstParentNodeRef<'ast> {
        type ParentKind = AstParentKind;

        #[inline(always)]
        fn kind(&self) -> AstParentKind {
            self.kind()
        }

        fn set_index(&mut self, index: usize) {
            match self {
                Self::Alternative(_, __field_kind) => __field_kind.set_index(index),
                Self::BoundaryAssertion(_, __field_kind) => __field_kind.set_index(index),
                Self::BoundaryAssertionKind(_, __field_kind) => __field_kind.set_index(index),
                Self::CapturingGroup(_, __field_kind) => __field_kind.set_index(index),
                Self::Character(_, __field_kind) => __field_kind.set_index(index),
                Self::CharacterClass(_, __field_kind) => __field_kind.set_index(index),
                Self::CharacterClassContents(_, __field_kind) => __field_kind.set_index(index),
                Self::CharacterClassContentsKind(_, __field_kind) => __field_kind.set_index(index),
                Self::CharacterClassEscape(_, __field_kind) => __field_kind.set_index(index),
                Self::CharacterClassEscapeKind(_, __field_kind) => __field_kind.set_index(index),
                Self::CharacterClassRange(_, __field_kind) => __field_kind.set_index(index),
                Self::CharacterKind(_, __field_kind) => __field_kind.set_index(index),
                Self::ClassString(_, __field_kind) => __field_kind.set_index(index),
                Self::ClassStringDisjunction(_, __field_kind) => __field_kind.set_index(index),
                Self::Disjunction(_, __field_kind) => __field_kind.set_index(index),
                Self::Dot(_, __field_kind) => __field_kind.set_index(index),
                Self::IgnoreGroup(_, __field_kind) => __field_kind.set_index(index),
                Self::IndexedReference(_, __field_kind) => __field_kind.set_index(index),
                Self::LookAroundAssertion(_, __field_kind) => __field_kind.set_index(index),
                Self::LookAroundAssertionKind(_, __field_kind) => __field_kind.set_index(index),
                Self::Modifiers(_, __field_kind) => __field_kind.set_index(index),
                Self::NamedReference(_, __field_kind) => __field_kind.set_index(index),
                Self::Pattern(_, __field_kind) => __field_kind.set_index(index),
                Self::Quantifier(_, __field_kind) => __field_kind.set_index(index),
                Self::Term(_, __field_kind) => __field_kind.set_index(index),
                Self::UnicodePropertyEscape(_, __field_kind) => __field_kind.set_index(index),
            }
        }
    }
    #[cfg(any(docsrs, feature = "path"))]
    impl<'ast> AstParentNodeRef<'ast> {
        #[inline]
        pub fn kind(&self) -> AstParentKind {
            match self {
                Self::Alternative(_, __field_kind) => AstParentKind::Alternative(*__field_kind),
                Self::BoundaryAssertion(_, __field_kind) => {
                    AstParentKind::BoundaryAssertion(*__field_kind)
                }
                Self::BoundaryAssertionKind(_, __field_kind) => {
                    AstParentKind::BoundaryAssertionKind(*__field_kind)
                }
                Self::CapturingGroup(_, __field_kind) => {
                    AstParentKind::CapturingGroup(*__field_kind)
                }
                Self::Character(_, __field_kind) => AstParentKind::Character(*__field_kind),
                Self::CharacterClass(_, __field_kind) => {
                    AstParentKind::CharacterClass(*__field_kind)
                }
                Self::CharacterClassContents(_, __field_kind) => {
                    AstParentKind::CharacterClassContents(*__field_kind)
                }
                Self::CharacterClassContentsKind(_, __field_kind) => {
                    AstParentKind::CharacterClassContentsKind(*__field_kind)
                }
                Self::CharacterClassEscape(_, __field_kind) => {
                    AstParentKind::CharacterClassEscape(*__field_kind)
                }
                Self::CharacterClassEscapeKind(_, __field_kind) => {
                    AstParentKind::CharacterClassEscapeKind(*__field_kind)
                }
                Self::CharacterClassRange(_, __field_kind) => {
                    AstParentKind::CharacterClassRange(*__field_kind)
                }
                Self::CharacterKind(_, __field_kind) => AstParentKind::CharacterKind(*__field_kind),
                Self::ClassString(_, __field_kind) => AstParentKind::ClassString(*__field_kind),
                Self::ClassStringDisjunction(_, __field_kind) => {
                    AstParentKind::ClassStringDisjunction(*__field_kind)
                }
                Self::Disjunction(_, __field_kind) => AstParentKind::Disjunction(*__field_kind),
                Self::Dot(_, __field_kind) => AstParentKind::Dot(*__field_kind),
                Self::IgnoreGroup(_, __field_kind) => AstParentKind::IgnoreGroup(*__field_kind),
                Self::IndexedReference(_, __field_kind) => {
                    AstParentKind::IndexedReference(*__field_kind)
                }
                Self::LookAroundAssertion(_, __field_kind) => {
                    AstParentKind::LookAroundAssertion(*__field_kind)
                }
                Self::LookAroundAssertionKind(_, __field_kind) => {
                    AstParentKind::LookAroundAssertionKind(*__field_kind)
                }
                Self::Modifiers(_, __field_kind) => AstParentKind::Modifiers(*__field_kind),
                Self::NamedReference(_, __field_kind) => {
                    AstParentKind::NamedReference(*__field_kind)
                }
                Self::Pattern(_, __field_kind) => AstParentKind::Pattern(*__field_kind),
                Self::Quantifier(_, __field_kind) => AstParentKind::Quantifier(*__field_kind),
                Self::Term(_, __field_kind) => AstParentKind::Term(*__field_kind),
                Self::UnicodePropertyEscape(_, __field_kind) => {
                    AstParentKind::UnicodePropertyEscape(*__field_kind)
                }
            }
        }
    }
}
impl<'ast> From<&'ast Alternative> for NodeRef<'ast> {
    fn from(node: &'ast Alternative) -> Self {
        NodeRef::Alternative(node)
    }
}
impl<'ast> From<&'ast BoundaryAssertion> for NodeRef<'ast> {
    fn from(node: &'ast BoundaryAssertion) -> Self {
        NodeRef::BoundaryAssertion(node)
    }
}
impl<'ast> From<&'ast BoundaryAssertionKind> for NodeRef<'ast> {
    fn from(node: &'ast BoundaryAssertionKind) -> Self {
        NodeRef::BoundaryAssertionKind(node)
    }
}
impl<'ast> From<&'ast CapturingGroup> for NodeRef<'ast> {
    fn from(node: &'ast CapturingGroup) -> Self {
        NodeRef::CapturingGroup(node)
    }
}
impl<'ast> From<&'ast Character> for NodeRef<'ast> {
    fn from(node: &'ast Character) -> Self {
        NodeRef::Character(node)
    }
}
impl<'ast> From<&'ast CharacterClass> for NodeRef<'ast> {
    fn from(node: &'ast CharacterClass) -> Self {
        NodeRef::CharacterClass(node)
    }
}
impl<'ast> From<&'ast CharacterClassContents> for NodeRef<'ast> {
    fn from(node: &'ast CharacterClassContents) -> Self {
        NodeRef::CharacterClassContents(node)
    }
}
impl<'ast> From<&'ast CharacterClassContentsKind> for NodeRef<'ast> {
    fn from(node: &'ast CharacterClassContentsKind) -> Self {
        NodeRef::CharacterClassContentsKind(node)
    }
}
impl<'ast> From<&'ast CharacterClassEscape> for NodeRef<'ast> {
    fn from(node: &'ast CharacterClassEscape) -> Self {
        NodeRef::CharacterClassEscape(node)
    }
}
impl<'ast> From<&'ast CharacterClassEscapeKind> for NodeRef<'ast> {
    fn from(node: &'ast CharacterClassEscapeKind) -> Self {
        NodeRef::CharacterClassEscapeKind(node)
    }
}
impl<'ast> From<&'ast CharacterClassRange> for NodeRef<'ast> {
    fn from(node: &'ast CharacterClassRange) -> Self {
        NodeRef::CharacterClassRange(node)
    }
}
impl<'ast> From<&'ast CharacterKind> for NodeRef<'ast> {
    fn from(node: &'ast CharacterKind) -> Self {
        NodeRef::CharacterKind(node)
    }
}
impl<'ast> From<&'ast ClassString> for NodeRef<'ast> {
    fn from(node: &'ast ClassString) -> Self {
        NodeRef::ClassString(node)
    }
}
impl<'ast> From<&'ast ClassStringDisjunction> for NodeRef<'ast> {
    fn from(node: &'ast ClassStringDisjunction) -> Self {
        NodeRef::ClassStringDisjunction(node)
    }
}
impl<'ast> From<&'ast Disjunction> for NodeRef<'ast> {
    fn from(node: &'ast Disjunction) -> Self {
        NodeRef::Disjunction(node)
    }
}
impl<'ast> From<&'ast Dot> for NodeRef<'ast> {
    fn from(node: &'ast Dot) -> Self {
        NodeRef::Dot(node)
    }
}
impl<'ast> From<&'ast IgnoreGroup> for NodeRef<'ast> {
    fn from(node: &'ast IgnoreGroup) -> Self {
        NodeRef::IgnoreGroup(node)
    }
}
impl<'ast> From<&'ast IndexedReference> for NodeRef<'ast> {
    fn from(node: &'ast IndexedReference) -> Self {
        NodeRef::IndexedReference(node)
    }
}
impl<'ast> From<&'ast LookAroundAssertion> for NodeRef<'ast> {
    fn from(node: &'ast LookAroundAssertion) -> Self {
        NodeRef::LookAroundAssertion(node)
    }
}
impl<'ast> From<&'ast LookAroundAssertionKind> for NodeRef<'ast> {
    fn from(node: &'ast LookAroundAssertionKind) -> Self {
        NodeRef::LookAroundAssertionKind(node)
    }
}
impl<'ast> From<&'ast Modifiers> for NodeRef<'ast> {
    fn from(node: &'ast Modifiers) -> Self {
        NodeRef::Modifiers(node)
    }
}
impl<'ast> From<&'ast NamedReference> for NodeRef<'ast> {
    fn from(node: &'ast NamedReference) -> Self {
        NodeRef::NamedReference(node)
    }
}
impl<'ast> From<&'ast Pattern> for NodeRef<'ast> {
    fn from(node: &'ast Pattern) -> Self {
        NodeRef::Pattern(node)
    }
}
impl<'ast> From<&'ast Quantifier> for NodeRef<'ast> {
    fn from(node: &'ast Quantifier) -> Self {
        NodeRef::Quantifier(node)
    }
}
impl<'ast> From<&'ast Term> for NodeRef<'ast> {
    fn from(node: &'ast Term) -> Self {
        NodeRef::Term(node)
    }
}
impl<'ast> From<&'ast UnicodePropertyEscape> for NodeRef<'ast> {
    fn from(node: &'ast UnicodePropertyEscape) -> Self {
        NodeRef::UnicodePropertyEscape(node)
    }
}
#[derive(Debug, Clone, Copy)]
pub enum NodeRef<'ast> {
    Alternative(&'ast Alternative),
    BoundaryAssertion(&'ast BoundaryAssertion),
    BoundaryAssertionKind(&'ast BoundaryAssertionKind),
    CapturingGroup(&'ast CapturingGroup),
    Character(&'ast Character),
    CharacterClass(&'ast CharacterClass),
    CharacterClassContents(&'ast CharacterClassContents),
    CharacterClassContentsKind(&'ast CharacterClassContentsKind),
    CharacterClassEscape(&'ast CharacterClassEscape),
    CharacterClassEscapeKind(&'ast CharacterClassEscapeKind),
    CharacterClassRange(&'ast CharacterClassRange),
    CharacterKind(&'ast CharacterKind),
    ClassString(&'ast ClassString),
    ClassStringDisjunction(&'ast ClassStringDisjunction),
    Disjunction(&'ast Disjunction),
    Dot(&'ast Dot),
    IgnoreGroup(&'ast IgnoreGroup),
    IndexedReference(&'ast IndexedReference),
    LookAroundAssertion(&'ast LookAroundAssertion),
    LookAroundAssertionKind(&'ast LookAroundAssertionKind),
    Modifiers(&'ast Modifiers),
    NamedReference(&'ast NamedReference),
    Pattern(&'ast Pattern),
    Quantifier(&'ast Quantifier),
    Term(&'ast Term),
    UnicodePropertyEscape(&'ast UnicodePropertyEscape),
}
impl<'ast> NodeRef<'ast> {
    #[doc = r" This is not a part of semver-stable API. It is experimental and subject to change."]
    #[allow(unreachable_patterns)]
    pub fn experimental_raw_children<'a>(&'a self) -> Box<dyn 'a + Iterator<Item = NodeRef<'ast>>> {
        match self {
            NodeRef::Alternative(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.body
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::Term(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::BoundaryAssertion(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(::std::iter::once(
                    NodeRef::BoundaryAssertionKind(&node.kind),
                ));
                Box::new(iterator)
            }
            NodeRef::BoundaryAssertionKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::CapturingGroup(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Disjunction(&node.body)));
                Box::new(iterator)
            }
            NodeRef::Character(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::CharacterKind(&node.kind)));
                Box::new(iterator)
            }
            NodeRef::CharacterClass(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::CharacterClassContentsKind(
                        &node.kind,
                    )))
                    .chain(node.body.iter().flat_map(|item| {
                        ::std::iter::once(NodeRef::CharacterClassContents(&item))
                    }));
                Box::new(iterator)
            }
            NodeRef::CharacterClassContents(node) => match node {
                CharacterClassContents::CharacterClassRange(v0) => {
                    Box::new(::std::iter::once(NodeRef::CharacterClassRange(v0)))
                }
                CharacterClassContents::CharacterClassEscape(v0) => {
                    Box::new(::std::iter::once(NodeRef::CharacterClassEscape(v0)))
                }
                CharacterClassContents::UnicodePropertyEscape(v0) => {
                    Box::new(::std::iter::once(NodeRef::UnicodePropertyEscape(v0)))
                }
                CharacterClassContents::Character(v0) => {
                    Box::new(::std::iter::once(NodeRef::Character(v0)))
                }
                CharacterClassContents::NestedCharacterClass(v0) => {
                    Box::new(::std::iter::once(NodeRef::CharacterClass(v0)))
                }
                CharacterClassContents::ClassStringDisjunction(v0) => {
                    Box::new(::std::iter::once(NodeRef::ClassStringDisjunction(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::CharacterClassContentsKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::CharacterClassEscape(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(::std::iter::once(
                    NodeRef::CharacterClassEscapeKind(&node.kind),
                ));
                Box::new(iterator)
            }
            NodeRef::CharacterClassEscapeKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::CharacterClassRange(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Character(&node.min)))
                    .chain(::std::iter::once(NodeRef::Character(&node.max)));
                Box::new(iterator)
            }
            NodeRef::CharacterKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::ClassString(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.body
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::Character(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::ClassStringDisjunction(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.body
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::ClassString(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::Disjunction(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>().chain(
                    node.body
                        .iter()
                        .flat_map(|item| ::std::iter::once(NodeRef::Alternative(&item))),
                );
                Box::new(iterator)
            }
            NodeRef::Dot(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::IgnoreGroup(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(
                        node.modifiers
                            .iter()
                            .flat_map(|item| ::std::iter::once(NodeRef::Modifiers(&item))),
                    )
                    .chain(::std::iter::once(NodeRef::Disjunction(&node.body)));
                Box::new(iterator)
            }
            NodeRef::IndexedReference(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::LookAroundAssertion(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::LookAroundAssertionKind(
                        &node.kind,
                    )))
                    .chain(::std::iter::once(NodeRef::Disjunction(&node.body)));
                Box::new(iterator)
            }
            NodeRef::LookAroundAssertionKind(node) => match node {
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::Modifiers(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::NamedReference(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
            NodeRef::Pattern(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Disjunction(&node.body)));
                Box::new(iterator)
            }
            NodeRef::Quantifier(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>()
                    .chain(::std::iter::once(NodeRef::Term(&node.body)));
                Box::new(iterator)
            }
            NodeRef::Term(node) => match node {
                Term::BoundaryAssertion(v0) => {
                    Box::new(::std::iter::once(NodeRef::BoundaryAssertion(v0)))
                }
                Term::LookAroundAssertion(v0) => {
                    Box::new(::std::iter::once(NodeRef::LookAroundAssertion(v0)))
                }
                Term::Quantifier(v0) => Box::new(::std::iter::once(NodeRef::Quantifier(v0))),
                Term::Character(v0) => Box::new(::std::iter::once(NodeRef::Character(v0))),
                Term::Dot(v0) => Box::new(::std::iter::once(NodeRef::Dot(v0))),
                Term::CharacterClassEscape(v0) => {
                    Box::new(::std::iter::once(NodeRef::CharacterClassEscape(v0)))
                }
                Term::UnicodePropertyEscape(v0) => {
                    Box::new(::std::iter::once(NodeRef::UnicodePropertyEscape(v0)))
                }
                Term::CharacterClass(v0) => {
                    Box::new(::std::iter::once(NodeRef::CharacterClass(v0)))
                }
                Term::CapturingGroup(v0) => {
                    Box::new(::std::iter::once(NodeRef::CapturingGroup(v0)))
                }
                Term::IgnoreGroup(v0) => Box::new(::std::iter::once(NodeRef::IgnoreGroup(v0))),
                Term::IndexedReference(v0) => {
                    Box::new(::std::iter::once(NodeRef::IndexedReference(v0)))
                }
                Term::NamedReference(v0) => {
                    Box::new(::std::iter::once(NodeRef::NamedReference(v0)))
                }
                _ => Box::new(::std::iter::empty::<NodeRef<'ast>>()),
            },
            NodeRef::UnicodePropertyEscape(node) => {
                let iterator = ::std::iter::empty::<NodeRef<'ast>>();
                Box::new(iterator)
            }
        }
    }
}
impl<'ast> NodeRef<'ast> {
    #[doc = r" Visit all nodes in self in preorder."]
    #[doc = r""]
    #[doc = r" This is not a part of semver-stable API. It is"]
    #[doc = r" experimental and subject to change."]
    pub fn experimental_traverse(&'ast self) -> Box<dyn 'ast + Iterator<Item = NodeRef<'ast>>> {
        let mut queue = std::collections::VecDeque::<NodeRef<'ast>>::new();
        queue.push_back(*self);
        Box::new(std::iter::from_fn(move || {
            let node: NodeRef<'ast> = queue.pop_front()?;
            {
                let children = node.experimental_raw_children();
                queue.extend(children);
            }
            Some(node)
        }))
    }
}
#[cfg(any(docsrs, feature = "path"))]
pub use self::fields::{AstParentKind, AstParentNodeRef};
