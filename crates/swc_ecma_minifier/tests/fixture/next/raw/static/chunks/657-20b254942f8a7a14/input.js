(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([
    [657],
    {
        /***/ 4816: /***/ function (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
        ) {
            "use strict";

            // EXPORTS
            __webpack_require__.d(__webpack_exports__, {
                _: function () {
                    return /* binding */ DataGrid;
                },
            });

            // EXTERNAL MODULE: ./node_modules/react/index.js
            var react = __webpack_require__(7294);
            // EXTERNAL MODULE: ./node_modules/prop-types/index.js
            var prop_types = __webpack_require__(5697);
            var prop_types_default =
                /*#__PURE__*/ __webpack_require__.n(prop_types); // CONCATENATED MODULE: ./node_modules/@mui/utils/esm/chainPropTypes.js
            function chainPropTypes(propType1, propType2) {
                if (true) {
                    return () => null;
                }

                return function validate(...args) {
                    return propType1(...args) || propType2(...args);
                };
            }
            // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
            var esm_extends = __webpack_require__(7462);
            // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
            var objectWithoutPropertiesLoose = __webpack_require__(3366);
            // EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.m.js
            var clsx_m = __webpack_require__(6010);
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/useForkRef.js
            var useForkRef = __webpack_require__(1705);
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/useEnhancedEffect.js
            var useEnhancedEffect = __webpack_require__(8974);
            // EXTERNAL MODULE: ./node_modules/@mui/material/styles/styled.js + 2 modules
            var styled = __webpack_require__(1496);
            // EXTERNAL MODULE: ./node_modules/@mui/system/esm/colorManipulator.js
            var colorManipulator = __webpack_require__(1796);
            // EXTERNAL MODULE: ./node_modules/@mui/base/generateUtilityClass/generateUtilityClass.js
            var generateUtilityClass = __webpack_require__(8979);
            // EXTERNAL MODULE: ./node_modules/@mui/base/generateUtilityClasses/generateUtilityClasses.js
            var generateUtilityClasses = __webpack_require__(6087); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/constants/gridClasses.js
            function getDataGridUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiDataGrid",
                    slot
                );
            }
            const gridClasses_gridClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiDataGrid", [
                "actionsCell",
                "autoHeight",
                "booleanCell",
                "cell--editable",
                "cell--editing",
                "cell--textCenter",
                "cell--textLeft",
                "cell--textRight",
                "cell--withRenderer",
                "cell",
                "cellContent",
                "cellCheckbox",
                "checkboxInput",
                "columnHeader--alignCenter",
                "columnHeader--alignLeft",
                "columnHeader--alignRight",
                "columnHeader--dragging",
                "columnHeader--moving",
                "columnHeader--numeric",
                "columnHeader--sortable",
                "columnHeader--sorted",
                "columnHeader--filtered",
                "columnHeader",
                "columnHeaderCheckbox",
                "columnHeaderDraggableContainer",
                "columnHeaderDropZone",
                "columnHeaderTitle",
                "columnHeaderTitleContainer",
                "columnHeaderTitleContainerContent",
                "columnHeaders",
                "columnHeadersInner",
                "columnHeadersInner--scrollable",
                "columnSeparator--resizable",
                "columnSeparator--resizing",
                "columnSeparator--sideLeft",
                "columnSeparator--sideRight",
                "columnSeparator",
                "columnsPanel",
                "columnsPanelRow",
                "detailPanel",
                "detailPanels",
                "detailPanelToggleCell",
                "detailPanelToggleCell--expanded",
                "panel",
                "panelHeader",
                "panelWrapper",
                "panelContent",
                "panelFooter",
                "paper",
                "editBooleanCell",
                "editInputCell",
                "filterForm",
                "filterFormDeleteIcon",
                "filterFormLinkOperatorInput",
                "filterFormColumnInput",
                "filterFormOperatorInput",
                "filterFormValueInput",
                "filterIcon",
                "footerContainer",
                "iconButtonContainer",
                "iconSeparator",
                "main",
                "menu",
                "menuIcon",
                "menuIconButton",
                "menuOpen",
                "menuList",
                "overlay",
                "root",
                "row",
                "row--editable",
                "row--editing",
                "row--lastVisible",
                "row--dragging",
                "rowReorderCellPlaceholder",
                "rowCount",
                "rowReorderCellContainer",
                "rowReorderCell",
                "rowReorderCell--draggable",
                "scrollArea--left",
                "scrollArea--right",
                "scrollArea",
                "selectedRowCount",
                "sortIcon",
                "toolbarContainer",
                "toolbarFilterList",
                "virtualScroller",
                "virtualScrollerContent",
                "virtualScrollerContent--overflowed",
                "virtualScrollerRenderZone",
                "pinnedColumns",
                "pinnedColumns--left",
                "pinnedColumns--right",
                "pinnedColumnHeaders",
                "pinnedColumnHeaders--left",
                "pinnedColumnHeaders--right",
                "withBorder",
                "treeDataGroupingCell",
                "treeDataGroupingCellToggle",
                "groupingCriteriaCell",
                "groupingCriteriaCellToggle",
            ]); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/containers/GridRootStyles.js
            const GridRootStyles = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "Root",
                overridesResolver: (props, styles) => [
                    {
                        [`&.${gridClasses_gridClasses.autoHeight}`]:
                            styles.autoHeight,
                    },
                    {
                        [`& .${gridClasses_gridClasses.editBooleanCell}`]:
                            styles.editBooleanCell,
                    },
                    {
                        [`& .${gridClasses_gridClasses["cell--editing"]}`]:
                            styles["cell--editing"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["cell--textCenter"]}`]:
                            styles["cell--textCenter"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["cell--textLeft"]}`]:
                            styles["cell--textLeft"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["cell--textRight"]}`]:
                            styles["cell--textRight"],
                    }, // TODO v6: Remove
                    {
                        [`& .${gridClasses_gridClasses["cell--withRenderer"]}`]:
                            styles["cell--withRenderer"],
                    },
                    {
                        [`& .${gridClasses_gridClasses.cell}`]: styles.cell,
                    },
                    {
                        [`& .${gridClasses_gridClasses.cellContent}`]:
                            styles.cellContent,
                    },
                    {
                        [`& .${gridClasses_gridClasses.cellCheckbox}`]:
                            styles.cellCheckbox,
                    },
                    {
                        [`& .${gridClasses_gridClasses.checkboxInput}`]:
                            styles.checkboxInput,
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--alignCenter"]}`]:
                            styles["columnHeader--alignCenter"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--alignLeft"]}`]:
                            styles["columnHeader--alignLeft"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--alignRight"]}`]:
                            styles["columnHeader--alignRight"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--dragging"]}`]:
                            styles["columnHeader--dragging"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--moving"]}`]:
                            styles["columnHeader--moving"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--numeric"]}`]:
                            styles["columnHeader--numeric"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--sortable"]}`]:
                            styles["columnHeader--sortable"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnHeader--sorted"]}`]:
                            styles["columnHeader--sorted"],
                    },
                    {
                        [`& .${gridClasses_gridClasses.columnHeader}`]:
                            styles.columnHeader,
                    },
                    {
                        [`& .${gridClasses_gridClasses.columnHeaderCheckbox}`]:
                            styles.columnHeaderCheckbox,
                    },
                    {
                        [`& .${gridClasses_gridClasses.columnHeaderDraggableContainer}`]:
                            styles.columnHeaderDraggableContainer,
                    },
                    {
                        [`& .${gridClasses_gridClasses.columnHeaderTitleContainer}`]:
                            styles.columnHeaderTitleContainer,
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnSeparator--resizable"]}`]:
                            styles["columnSeparator--resizable"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["columnSeparator--resizing"]}`]:
                            styles["columnSeparator--resizing"],
                    },
                    {
                        [`& .${gridClasses_gridClasses.columnSeparator}`]:
                            styles.columnSeparator,
                    },
                    {
                        [`& .${gridClasses_gridClasses.filterIcon}`]:
                            styles.filterIcon,
                    },
                    {
                        [`& .${gridClasses_gridClasses.iconSeparator}`]:
                            styles.iconSeparator,
                    },
                    {
                        [`& .${gridClasses_gridClasses.menuIcon}`]:
                            styles.menuIcon,
                    },
                    {
                        [`& .${gridClasses_gridClasses.menuIconButton}`]:
                            styles.menuIconButton,
                    },
                    {
                        [`& .${gridClasses_gridClasses.menuOpen}`]:
                            styles.menuOpen,
                    },
                    {
                        [`& .${gridClasses_gridClasses.menuList}`]:
                            styles.menuList,
                    },
                    {
                        [`& .${gridClasses_gridClasses["row--editable"]}`]:
                            styles["row--editable"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["row--editing"]}`]:
                            styles["row--editing"],
                    },
                    {
                        [`& .${gridClasses_gridClasses["row--dragging"]}`]:
                            styles["row--dragging"],
                    },
                    {
                        [`& .${gridClasses_gridClasses.row}`]: styles.row,
                    },
                    {
                        [`& .${gridClasses_gridClasses.rowReorderCellPlaceholder}`]:
                            styles.rowReorderCellPlaceholder,
                    },
                    {
                        [`& .${gridClasses_gridClasses.rowReorderCell}`]:
                            styles.rowReorderCell,
                    },
                    {
                        [`& .${gridClasses_gridClasses["rowReorderCell--draggable"]}`]:
                            styles["rowReorderCell--draggable"],
                    },
                    {
                        [`& .${gridClasses_gridClasses.sortIcon}`]:
                            styles.sortIcon,
                    },
                    {
                        [`& .${gridClasses_gridClasses.withBorder}`]:
                            styles.withBorder,
                    },
                    {
                        [`& .${gridClasses_gridClasses.treeDataGroupingCell}`]:
                            styles.treeDataGroupingCell,
                    },
                    {
                        [`& .${gridClasses_gridClasses.treeDataGroupingCellToggle}`]:
                            styles.treeDataGroupingCellToggle,
                    },
                    {
                        [`& .${gridClasses_gridClasses.detailPanelToggleCell}`]:
                            styles.detailPanelToggleCell,
                    },
                    {
                        [`& .${gridClasses_gridClasses["detailPanelToggleCell--expanded"]}`]:
                            styles["detailPanelToggleCell--expanded"],
                    },
                    styles.root,
                ],
            })(({ theme }) => {
                const borderColor =
                    theme.palette.mode === "light"
                        ? (0, colorManipulator /* lighten */.$n)(
                              (0, colorManipulator /* alpha */.Fq)(
                                  theme.palette.divider,
                                  1
                              ),
                              0.88
                          )
                        : (0, colorManipulator /* darken */._j)(
                              (0, colorManipulator /* alpha */.Fq)(
                                  theme.palette.divider,
                                  1
                              ),
                              0.68
                          );

                const gridStyle = (0, esm_extends /* default */.Z)(
                    {
                        flex: 1,
                        boxSizing: "border-box",
                        position: "relative",
                        border: `1px solid ${borderColor}`,
                        borderRadius: theme.shape.borderRadius,
                        color: theme.palette.text.primary,
                    },
                    theme.typography.body2,
                    {
                        outline: "none",
                        height: "100%",
                        display: "flex",
                        flexDirection: "column",
                        [`&.${gridClasses_gridClasses.autoHeight}`]: {
                            height: "auto",
                            [`& .${gridClasses_gridClasses["row--lastVisible"]} .${gridClasses_gridClasses.cell}`]:
                                {
                                    borderBottomColor: "transparent",
                                },
                        },
                        [`& .${gridClasses_gridClasses["virtualScrollerContent--overflowed"]} .${gridClasses_gridClasses["row--lastVisible"]} .${gridClasses_gridClasses.cell}`]:
                            {
                                borderBottomColor: "transparent",
                            },
                        [`& .${gridClasses_gridClasses.columnHeader}, & .${gridClasses_gridClasses.cell}`]:
                            {
                                WebkitTapHighlightColor: "transparent",
                                lineHeight: null,
                                padding: "0 10px",
                                boxSizing: "border-box",
                            },
                        [`& .${gridClasses_gridClasses.columnHeader}:focus-within, & .${gridClasses_gridClasses.cell}:focus-within`]:
                            {
                                outline: `solid ${(0,
                                colorManipulator /* alpha */.Fq)(
                                    theme.palette.primary.main,
                                    0.5
                                )} 1px`,
                                outlineWidth: 1,
                                outlineOffset: -1,
                            },
                        [`& .${gridClasses_gridClasses.columnHeader}:focus, & .${gridClasses_gridClasses.cell}:focus`]:
                            {
                                outline: `solid ${theme.palette.primary.main} 1px`,
                            },
                        [`& .${gridClasses_gridClasses.columnHeaderCheckbox}, & .${gridClasses_gridClasses.cellCheckbox}`]:
                            {
                                padding: 0,
                                justifyContent: "center",
                                alignItems: "center",
                            },
                        [`& .${gridClasses_gridClasses.columnHeader}`]: {
                            position: "relative",
                            display: "flex",
                            alignItems: "center",
                        },
                        [`& .${gridClasses_gridClasses["columnHeader--sorted"]} .${gridClasses_gridClasses.iconButtonContainer}, & .${gridClasses_gridClasses["columnHeader--filtered"]} .${gridClasses_gridClasses.iconButtonContainer}`]:
                            {
                                visibility: "visible",
                                width: "auto",
                            },
                        [`& .${gridClasses_gridClasses.columnHeader}:not(.${gridClasses_gridClasses["columnHeader--sorted"]}) .${gridClasses_gridClasses.sortIcon}`]:
                            {
                                opacity: 0,
                                transition: theme.transitions.create(
                                    ["opacity"],
                                    {
                                        duration:
                                            theme.transitions.duration.shorter,
                                    }
                                ),
                            },
                        [`& .${gridClasses_gridClasses.columnHeader}:not(.${gridClasses_gridClasses["columnHeader--sorted"]}):hover .${gridClasses_gridClasses.sortIcon}`]:
                            {
                                opacity: 0.5,
                            },
                        [`& .${gridClasses_gridClasses.columnHeaderTitleContainer}`]:
                            {
                                display: "flex",
                                alignItems: "center",
                                minWidth: 0,
                                flex: 1,
                                whiteSpace: "nowrap",
                                overflow: "hidden",
                            },
                        [`& .${gridClasses_gridClasses.columnHeaderTitleContainerContent}`]:
                            {
                                overflow: "hidden",
                                display: "flex",
                                alignItems: "center",
                            },
                        [`& .${gridClasses_gridClasses.sortIcon}, & .${gridClasses_gridClasses.filterIcon}`]:
                            {
                                fontSize: "inherit",
                            },
                        [`& .${gridClasses_gridClasses["columnHeader--sortable"]}`]:
                            {
                                cursor: "pointer",
                            },
                        [`& .${gridClasses_gridClasses["columnHeader--alignCenter"]} .${gridClasses_gridClasses.columnHeaderTitleContainer}`]:
                            {
                                justifyContent: "center",
                            },
                        [`& .${gridClasses_gridClasses["columnHeader--alignRight"]} .${gridClasses_gridClasses.columnHeaderDraggableContainer}, & .${gridClasses_gridClasses["columnHeader--alignRight"]} .${gridClasses_gridClasses.columnHeaderTitleContainer}`]:
                            {
                                flexDirection: "row-reverse",
                            },
                        [`& .${gridClasses_gridClasses["columnHeader--alignCenter"]} .${gridClasses_gridClasses.menuIcon}, & .${gridClasses_gridClasses["columnHeader--alignRight"]} .${gridClasses_gridClasses.menuIcon}`]:
                            {
                                marginRight: "auto",
                                marginLeft: -6,
                            },
                        [`& .${gridClasses_gridClasses["columnHeader--alignRight"]} .${gridClasses_gridClasses.menuIcon}, & .${gridClasses_gridClasses["columnHeader--alignRight"]} .${gridClasses_gridClasses.menuIcon}`]:
                            {
                                marginRight: "auto",
                                marginLeft: -10,
                            },
                        [`& .${gridClasses_gridClasses["columnHeader--moving"]}`]:
                            {
                                backgroundColor: theme.palette.action.hover,
                            },
                        [`& .${gridClasses_gridClasses.columnSeparator}`]: {
                            position: "absolute",
                            zIndex: 100,
                            display: "flex",
                            flexDirection: "column",
                            justifyContent: "center",
                            color: borderColor,
                        },
                        [`& .${gridClasses_gridClasses["columnSeparator--sideLeft"]}`]:
                            {
                                left: -12,
                            },
                        [`& .${gridClasses_gridClasses["columnSeparator--sideRight"]}`]:
                            {
                                right: -12,
                            },
                        [`& .${gridClasses_gridClasses["columnSeparator--resizable"]}`]:
                            {
                                cursor: "col-resize",
                                touchAction: "none",
                                "&:hover": {
                                    color: theme.palette.text.primary,
                                    // Reset on touch devices, it doesn't add specificity
                                    "@media (hover: none)": {
                                        color: borderColor,
                                    },
                                },
                                [`&.${gridClasses_gridClasses["columnSeparator--resizing"]}`]:
                                    {
                                        color: theme.palette.text.primary,
                                    },
                            },
                        [`& .${gridClasses_gridClasses.iconSeparator}`]: {
                            color: "inherit",
                        },
                        [`& .${gridClasses_gridClasses.menuIcon}`]: {
                            width: 0,
                            visibility: "hidden",
                            fontSize: 20,
                            marginRight: -10,
                            display: "flex",
                            alignItems: "center",
                        },
                        [`& .${gridClasses_gridClasses.columnHeader}:hover`]: {
                            [`& .${gridClasses_gridClasses.iconButtonContainer}`]:
                                {
                                    visibility: "visible",
                                    width: "auto",
                                },
                            [`& .${gridClasses_gridClasses.menuIcon}`]: {
                                width: "auto",
                                visibility: "visible",
                            },
                        },
                        [`.${gridClasses_gridClasses.menuOpen}`]: {
                            visibility: "visible",
                            width: "auto",
                        },
                        [`& .${gridClasses_gridClasses.row}`]: {
                            display: "flex",
                            width: "fit-content",
                            breakInside: "avoid",
                            // Avoid the row to be broken in two different print pages.
                            "&:hover, &.Mui-hovered": {
                                backgroundColor: theme.palette.action.hover,
                                // Reset on touch devices, it doesn't add specificity
                                "@media (hover: none)": {
                                    backgroundColor: "transparent",
                                },
                            },
                            "&.Mui-selected": {
                                backgroundColor: (0,
                                colorManipulator /* alpha */.Fq)(
                                    theme.palette.primary.main,
                                    theme.palette.action.selectedOpacity
                                ),
                                "&:hover, &.Mui-hovered": {
                                    backgroundColor: (0,
                                    colorManipulator /* alpha */.Fq)(
                                        theme.palette.primary.main,
                                        theme.palette.action.selectedOpacity +
                                            theme.palette.action.hoverOpacity
                                    ),
                                    // Reset on touch devices, it doesn't add specificity
                                    "@media (hover: none)": {
                                        backgroundColor: (0,
                                        colorManipulator /* alpha */.Fq)(
                                            theme.palette.primary.main,
                                            theme.palette.action.selectedOpacity
                                        ),
                                    },
                                },
                            },
                        },
                        [`& .${gridClasses_gridClasses.cell}`]: {
                            display: "flex",
                            alignItems: "center",
                            overflow: "hidden",
                            whiteSpace: "nowrap",
                            borderBottom: `1px solid ${borderColor}`,
                        },
                        [`& .${gridClasses_gridClasses.cellContent}`]: {
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                        },
                        [`& .${gridClasses_gridClasses.cell}.${gridClasses_gridClasses["cell--editing"]}`]:
                            {
                                padding: 1,
                                display: "flex",
                                boxShadow: theme.shadows[2],
                                backgroundColor: theme.palette.background.paper,
                                "&:focus-within": {
                                    outline: `solid ${theme.palette.primary.main} 1px`,
                                    outlineOffset: "-1px",
                                },
                            },
                        [`& .${gridClasses_gridClasses["row--editing"]}`]: {
                            boxShadow: theme.shadows[2],
                        },
                        [`& .${gridClasses_gridClasses["row--editing"]} .${gridClasses_gridClasses.cell}`]:
                            {
                                boxShadow: theme.shadows[0],
                                backgroundColor: theme.palette.background.paper,
                            },
                        [`& .${gridClasses_gridClasses.editBooleanCell}`]: {
                            display: "flex",
                            height: "100%",
                            width: "100%",
                            alignItems: "center",
                            justifyContent: "center",
                        },
                        [`& .${gridClasses_gridClasses.booleanCell}[data-value="true"]`]:
                            {
                                color: theme.palette.text.secondary,
                            },
                        [`& .${gridClasses_gridClasses.booleanCell}[data-value="false"]`]:
                            {
                                color: theme.palette.text.disabled,
                            },
                        [`& .${gridClasses_gridClasses.actionsCell}`]: {
                            display: "inline-flex",
                            alignItems: "center",
                            gridGap: theme.spacing(1),
                        },
                        [`& .${gridClasses_gridClasses.rowReorderCell}`]: {
                            display: "inline-flex",
                            flex: 1,
                            alignItems: "center",
                            justifyContent: "center",
                            opacity: theme.palette.action.disabledOpacity,
                        },
                        [`& .${gridClasses_gridClasses["rowReorderCell--draggable"]}`]:
                            {
                                cursor: "move",
                                opacity: 1,
                            },
                        [`& .${gridClasses_gridClasses.rowReorderCellContainer}`]:
                            {
                                padding: 0,
                                alignItems: "stretch",
                            },
                        [`& .${gridClasses_gridClasses.withBorder}`]: {
                            borderRight: `1px solid ${borderColor}`,
                        },
                        [`& .${gridClasses_gridClasses["cell--textLeft"]}`]: {
                            justifyContent: "flex-start",
                        },
                        [`& .${gridClasses_gridClasses["cell--textRight"]}`]: {
                            justifyContent: "flex-end",
                        },
                        [`& .${gridClasses_gridClasses["cell--textCenter"]}`]: {
                            justifyContent: "center",
                        },
                        [`& .${gridClasses_gridClasses.columnHeaderDraggableContainer}`]:
                            {
                                display: "flex",
                                width: "100%",
                            },
                        [`& .${gridClasses_gridClasses.rowReorderCellPlaceholder}`]:
                            {
                                display: "none",
                            },
                        [`& .${gridClasses_gridClasses["columnHeader--dragging"]}, & .${gridClasses_gridClasses["row--dragging"]}`]:
                            {
                                background: theme.palette.background.paper,
                                padding: "0 12px",
                                borderRadius: theme.shape.borderRadius,
                                opacity: theme.palette.action.disabledOpacity,
                            },
                        [`& .${gridClasses_gridClasses["row--dragging"]}`]: {
                            background: theme.palette.background.paper,
                            padding: "0 12px",
                            borderRadius: theme.shape.borderRadius,
                            opacity: theme.palette.action.disabledOpacity,
                            [`& .${gridClasses_gridClasses.rowReorderCellPlaceholder}`]:
                                {
                                    display: "flex",
                                },
                        },
                        [`& .${gridClasses_gridClasses.treeDataGroupingCell}`]:
                            {
                                display: "flex",
                                alignItems: "center",
                                width: "100%",
                            },
                        [`& .${gridClasses_gridClasses.treeDataGroupingCellToggle}`]:
                            {
                                flex: "0 0 28px",
                                alignSelf: "stretch",
                                marginRight: theme.spacing(2),
                            },
                        [`& .${gridClasses_gridClasses.groupingCriteriaCell}`]:
                            {
                                display: "flex",
                                alignItems: "center",
                                width: "100%",
                            },
                        [`& .${gridClasses_gridClasses.groupingCriteriaCellToggle}`]:
                            {
                                flex: "0 0 28px",
                                alignSelf: "stretch",
                                marginRight: theme.spacing(2),
                            },
                    }
                );

                return gridStyle;
            }); // CONCATENATED MODULE: ./node_modules/reselect/es/defaultMemoize.js
            // Cache implementation based on Erik Rasmussen's `lru-memoize`:
            // https://github.com/erikras/lru-memoize
            var NOT_FOUND = "NOT_FOUND";

            function createSingletonCache(equals) {
                var entry;
                return {
                    get: function get(key) {
                        if (entry && equals(entry.key, key)) {
                            return entry.value;
                        }

                        return NOT_FOUND;
                    },
                    put: function put(key, value) {
                        entry = {
                            key: key,
                            value: value,
                        };
                    },
                    getEntries: function getEntries() {
                        return entry ? [entry] : [];
                    },
                    clear: function clear() {
                        entry = undefined;
                    },
                };
            }

            function createLruCache(maxSize, equals) {
                var entries = [];

                function get(key) {
                    var cacheIndex = entries.findIndex(function (entry) {
                        return equals(key, entry.key);
                    }); // We found a cached entry

                    if (cacheIndex > -1) {
                        var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top

                        if (cacheIndex > 0) {
                            entries.splice(cacheIndex, 1);
                            entries.unshift(entry);
                        }

                        return entry.value;
                    } // No entry found in cache, return sentinel

                    return NOT_FOUND;
                }

                function put(key, value) {
                    if (get(key) === NOT_FOUND) {
                        // TODO Is unshift slow?
                        entries.unshift({
                            key: key,
                            value: value,
                        });

                        if (entries.length > maxSize) {
                            entries.pop();
                        }
                    }
                }

                function getEntries() {
                    return entries;
                }

                function clear() {
                    entries = [];
                }

                return {
                    get: get,
                    put: put,
                    getEntries: getEntries,
                    clear: clear,
                };
            }

            var defaultEqualityCheck = function defaultEqualityCheck(a, b) {
                return a === b;
            };
            function createCacheKeyComparator(equalityCheck) {
                return function areArgumentsShallowlyEqual(prev, next) {
                    if (
                        prev === null ||
                        next === null ||
                        prev.length !== next.length
                    ) {
                        return false;
                    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.

                    var length = prev.length;

                    for (var i = 0; i < length; i++) {
                        if (!equalityCheck(prev[i], next[i])) {
                            return false;
                        }
                    }

                    return true;
                };
            }
            // defaultMemoize now supports a configurable cache size with LRU behavior,
            // and optional comparison of the result value with existing values
            function defaultMemoize(func, equalityCheckOrOptions) {
                var providedOptions =
                    typeof equalityCheckOrOptions === "object"
                        ? equalityCheckOrOptions
                        : {
                              equalityCheck: equalityCheckOrOptions,
                          };
                var _providedOptions$equa = providedOptions.equalityCheck,
                    equalityCheck =
                        _providedOptions$equa === void 0
                            ? defaultEqualityCheck
                            : _providedOptions$equa,
                    _providedOptions$maxS = providedOptions.maxSize,
                    maxSize =
                        _providedOptions$maxS === void 0
                            ? 1
                            : _providedOptions$maxS,
                    resultEqualityCheck = providedOptions.resultEqualityCheck;
                var comparator = createCacheKeyComparator(equalityCheck);
                var cache =
                    maxSize === 1
                        ? createSingletonCache(comparator)
                        : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons

                function memoized() {
                    var value = cache.get(arguments);

                    if (value === NOT_FOUND) {
                        // @ts-ignore
                        value = func.apply(null, arguments);

                        if (resultEqualityCheck) {
                            var entries = cache.getEntries();
                            var matchingEntry = entries.find(function (entry) {
                                return resultEqualityCheck(entry.value, value);
                            });

                            if (matchingEntry) {
                                value = matchingEntry.value;
                            }
                        }

                        cache.put(arguments, value);
                    }

                    return value;
                }

                memoized.clearCache = function () {
                    return cache.clear();
                };

                return memoized;
            } // CONCATENATED MODULE: ./node_modules/reselect/es/index.js
            function getDependencies(funcs) {
                var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

                if (
                    !dependencies.every(function (dep) {
                        return typeof dep === "function";
                    })
                ) {
                    var dependencyTypes = dependencies
                        .map(function (dep) {
                            return typeof dep === "function"
                                ? "function " + (dep.name || "unnamed") + "()"
                                : typeof dep;
                        })
                        .join(", ");
                    throw new Error(
                        "createSelector expects all input-selectors to be functions, but received the following types: [" +
                            dependencyTypes +
                            "]"
                    );
                }

                return dependencies;
            }

            function createSelectorCreator(memoize) {
                for (
                    var _len = arguments.length,
                        memoizeOptionsFromArgs = new Array(
                            _len > 1 ? _len - 1 : 0
                        ),
                        _key = 1;
                    _key < _len;
                    _key++
                ) {
                    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
                }

                var createSelector = function createSelector() {
                    for (
                        var _len2 = arguments.length,
                            funcs = new Array(_len2),
                            _key2 = 0;
                        _key2 < _len2;
                        _key2++
                    ) {
                        funcs[_key2] = arguments[_key2];
                    }

                    var _recomputations = 0;

                    var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.
                    // So, start by declaring the default value here.
                    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)

                    var directlyPassedOptions = {
                        memoizeOptions: undefined,
                    }; // Normally, the result func or "output selector" is the last arg

                    var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object

                    if (typeof resultFunc === "object") {
                        directlyPassedOptions = resultFunc; // and pop the real result func off

                        resultFunc = funcs.pop();
                    }

                    if (typeof resultFunc !== "function") {
                        throw new Error(
                            "createSelector expects an output function after the inputs, but received: [" +
                                typeof resultFunc +
                                "]"
                        );
                    } // Determine which set of options we're using. Prefer options passed directly,
                    // but fall back to options given to createSelectorCreator.

                    var _directlyPassedOption = directlyPassedOptions,
                        _directlyPassedOption2 =
                            _directlyPassedOption.memoizeOptions,
                        memoizeOptions =
                            _directlyPassedOption2 === void 0
                                ? memoizeOptionsFromArgs
                                : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer
                    // is an array. In most libs I've looked at, it's an equality function or options object.
                    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full
                    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so
                    // we wrap it in an array so we can apply it.

                    var finalMemoizeOptions = Array.isArray(memoizeOptions)
                        ? memoizeOptions
                        : [memoizeOptions];
                    var dependencies = getDependencies(funcs);
                    var memoizedResultFunc = memoize.apply(
                        void 0,
                        [
                            function () {
                                _recomputations++; // apply arguments instead of spreading for performance.

                                return resultFunc.apply(null, arguments);
                            },
                        ].concat(finalMemoizeOptions)
                    ); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.

                    var selector = memoize(function () {
                        var params = [];
                        var length = dependencies.length;

                        for (var i = 0; i < length; i++) {
                            // apply arguments instead of spreading and mutate a local list of params for performance.
                            // @ts-ignore
                            params.push(dependencies[i].apply(null, arguments));
                        } // apply arguments instead of spreading for performance.

                        _lastResult = memoizedResultFunc.apply(null, params);
                        return _lastResult;
                    });
                    Object.assign(selector, {
                        resultFunc: resultFunc,
                        memoizedResultFunc: memoizedResultFunc,
                        dependencies: dependencies,
                        lastResult: function lastResult() {
                            return _lastResult;
                        },
                        recomputations: function recomputations() {
                            return _recomputations;
                        },
                        resetRecomputations: function resetRecomputations() {
                            return (_recomputations = 0);
                        },
                    });
                    return selector;
                }; // @ts-ignore

                return createSelector;
            }
            var createSelector =
                /* #__PURE__ */ createSelectorCreator(defaultMemoize);
            // Manual definition of state and output arguments
            var createStructuredSelector = function createStructuredSelector(
                selectors,
                selectorCreator
            ) {
                if (selectorCreator === void 0) {
                    selectorCreator = createSelector;
                }

                if (typeof selectors !== "object") {
                    throw new Error(
                        "createStructuredSelector expects first argument to be an object " +
                            ("where each property is a selector, instead received a " +
                                typeof selectors)
                    );
                }

                var objectKeys = Object.keys(selectors);
                var resultSelector = selectorCreator(
                    // @ts-ignore
                    objectKeys.map(function (key) {
                        return selectors[key];
                    }),
                    function () {
                        for (
                            var _len3 = arguments.length,
                                values = new Array(_len3),
                                _key3 = 0;
                            _key3 < _len3;
                            _key3++
                        ) {
                            values[_key3] = arguments[_key3];
                        }

                        return values.reduce(function (
                            composition,
                            value,
                            index
                        ) {
                            composition[objectKeys[index]] = value;
                            return composition;
                        },
                        {});
                    }
                );
                return resultSelector;
            };
            // EXTERNAL MODULE: ./node_modules/@mui/x-data-grid/utils/warning.js
            var warning = __webpack_require__(2339); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/createSelector.js
            const cache = {};
            const missingInstanceIdWarning = (0, warning /* buildWarning */.b)([
                "MUI: A selector was called without passing the instance ID, which may impact the performance of the grid.",
                "To fix, call it with `apiRef`, e.g. `mySelector(apiRef)`, or pass the instance ID explicitly, e.g `mySelector(state, apiRef.current.instanceId)`.",
            ]);
            const createSelector_createSelector = (...args) => {
                const selector = (...selectorArgs) => {
                    const [stateOrApiRef, instanceId] = selectorArgs;
                    const isApiRef = !!stateOrApiRef.current;
                    const cacheKey = isApiRef
                        ? stateOrApiRef.current.instanceId
                        : instanceId != null
                        ? instanceId
                        : "default";
                    const state = isApiRef
                        ? stateOrApiRef.current.state
                        : stateOrApiRef;

                    if (false) {
                    }

                    if (cache[cacheKey] && cache[cacheKey].get(args)) {
                        // We pass the cache key because the called selector might have as
                        // dependency another selector created with this `createSelector`.
                        return cache[cacheKey].get(args)(state, cacheKey);
                    }

                    const newSelector = createSelector(...args);

                    if (!cache[cacheKey]) {
                        cache[cacheKey] = new Map();
                    }

                    cache[cacheKey].set(args, newSelector);
                    return newSelector(state, cacheKey);
                }; // We use this property to detect if the selector was created with createSelector
                // or it's only a simple function the receives the state and returns part of it.

                selector.cache = cache;
                return selector;
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsSelector.js
            /**
             * @category Columns
             * @deprecated Use the selector returning exactly the value you are looking for.
             * @ignore - do not document.
             * TODO v6: Rename `gridColumnsStateSelector`
             */

            const gridColumnsSelector = (state) => state.columns;
            /**
             * Get the field of each column.
             * @category Columns
             */

            const gridColumnFieldsSelector = createSelector_createSelector(
                gridColumnsSelector,
                (columnsState) => columnsState.all
            );
            /**
             * Get the columns as a lookup (an object containing the field for keys and the definition for values).
             * @category Columns
             */

            const gridColumnLookupSelector = createSelector_createSelector(
                gridColumnsSelector,
                (columnsState) => columnsState.lookup
            );
            /**
             * Get the columns as an array.
             * @category Columns
             */

            const gridColumnDefinitionsSelector = createSelector_createSelector(
                gridColumnFieldsSelector,
                gridColumnLookupSelector,
                (allFields, lookup) => allFields.map((field) => lookup[field])
            );
            /**
             * Get the column visibility model, containing the visibility status of each column.
             * If a column is not registered in the model, it is visible.
             * @category Visible Columns
             */

            const gridColumnVisibilityModelSelector =
                createSelector_createSelector(
                    gridColumnsSelector,
                    (columnsState) => columnsState.columnVisibilityModel
                );
            /**
             * Get the visible columns as a lookup (an object containing the field for keys and the definition for values).
             * @category Visible Columns
             */

            const gridVisibleColumnDefinitionsSelector =
                createSelector_createSelector(
                    gridColumnDefinitionsSelector,
                    gridColumnVisibilityModelSelector,
                    (columns, columnVisibilityModel) =>
                        columns.filter(
                            (column) =>
                                columnVisibilityModel[column.field] !== false
                        )
                );
            /**
             * Get the field of each visible column.
             * @category Visible Columns
             */

            const gridVisibleColumnFieldsSelector =
                createSelector_createSelector(
                    gridVisibleColumnDefinitionsSelector,
                    (visibleColumns) =>
                        visibleColumns.map((column) => column.field)
                );
            /**
             * Get the left position in pixel of each visible columns relative to the left of the first column.
             * @category Visible Columns
             */

            const gridColumnPositionsSelector = createSelector_createSelector(
                gridVisibleColumnDefinitionsSelector,
                (visibleColumns) => {
                    const positions = [];
                    let currentPosition = 0;

                    for (let i = 0; i < visibleColumns.length; i += 1) {
                        positions.push(currentPosition);
                        currentPosition += visibleColumns[i].computedWidth;
                    }

                    return positions;
                }
            );
            /**
             * Get the summed width of all the visible columns.
             * @category Visible Columns
             */

            const gridColumnsTotalWidthSelector = createSelector_createSelector(
                gridVisibleColumnDefinitionsSelector,
                gridColumnPositionsSelector,
                (visibleColumns, positions) => {
                    const colCount = visibleColumns.length;

                    if (colCount === 0) {
                        return 0;
                    }

                    return (
                        positions[colCount - 1] +
                        visibleColumns[colCount - 1].computedWidth
                    );
                }
            );
            /**
             * Get the filterable columns as an array.
             * @category Columns
             */

            const gridFilterableColumnDefinitionsSelector =
                createSelector_createSelector(
                    gridColumnDefinitionsSelector,
                    (columns) => columns.filter((col) => col.filterable)
                );
            /**
             * Get the filterable columns as a lookup (an object containing the field for keys and the definition for values).
             * @category Columns
             */

            const gridFilterableColumnLookupSelector =
                createSelector_createSelector(
                    gridColumnDefinitionsSelector,
                    (columns) =>
                        columns.reduce((acc, col) => {
                            if (col.filterable) {
                                acc[col.field] = col;
                            }

                            return acc;
                        }, {})
                );
            /**
             * @category Columns
             * @deprecated Use `gridColumnFieldsSelector` instead.
             * @ignore - do not document.
             */

            const allGridColumnsFieldsSelector = (0,
            warning /* wrapWithWarningOnCall */.M)(gridColumnFieldsSelector, [
                "MUI: The method allGridColumnsFieldsSelector is deprecated and will be removed in the next major version.",
                "Use gridColumnFieldsSelector instead",
            ]);
            /**
             * @category Columns
             * @deprecated Use `gridColumnDefinitionsSelector` instead.
             * @ignore - do not document.
             */

            const allGridColumnsSelector = (0,
            warning /* wrapWithWarningOnCall */.M)(
                gridColumnDefinitionsSelector,
                [
                    "MUI: The method allGridColumnsSelector is deprecated and will be removed in the next major version.",
                    "Use gridColumnDefinitionsSelector instead",
                ]
            );
            /**
             * @category Visible Columns
             * @deprecated Use `gridVisibleColumnDefinitionsSelector` instead.
             * @ignore - do not document.
             */

            const visibleGridColumnsSelector = (0,
            warning /* wrapWithWarningOnCall */.M)(
                gridVisibleColumnDefinitionsSelector,
                [
                    "MUI: The method visibleGridColumnsSelector is deprecated and will be removed in the next major version.",
                    "Use gridVisibleColumnDefinitionsSelector instead",
                ]
            );
            /**
             * @category Columns
             * @deprecated Use `gridFilterableColumnDefinitionsSelector` instead.
             * @ignore - do not document.
             */

            const filterableGridColumnsSelector = (0,
            warning /* wrapWithWarningOnCall */.M)(
                gridFilterableColumnDefinitionsSelector,
                [
                    "MUI: The method filterableGridColumnsSelector is deprecated and will be removed in the next major version.",
                    "Use gridFilterableColumnDefinitionsSelector instead",
                ]
            );
            /**
             * @category Columns
             * @deprecated Use `gridFilterableColumnLookupSelector` instead (not the same return format).
             * @ignore - do not document.
             */

            const filterableGridColumnsIdsSelector = (0,
            warning /* wrapWithWarningOnCall */.M)(
                createSelector_createSelector(
                    gridFilterableColumnDefinitionsSelector,
                    (columns) => columns.map((col) => col.field)
                ),
                [
                    "MUI: The method filterableGridColumnsIdsSelector is deprecated and will be removed in the next major version.",
                    "Use gridFilterableColumnDefinitionsSelector instead.",
                    "The return format is now a lookup, if you want to get the same output as before, use the following code:",
                    "",
                    "const lookup = gridFilterableColumnLookupSelector(apiRef);",
                    "const fields = gridColumnFieldsSelector(apiRef).filter(field => lookup[field]);",
                ]
            );
            /**
             * Get the amount of visible columns.
             * @category Visible Columns
             * @deprecated Use the length of the array returned by `gridVisibleColumnDefinitionsSelector` instead.
             * @ignore - do not document.
             */

            const visibleGridColumnsLengthSelector = (0,
            warning /* wrapWithWarningOnCall */.M)(
                createSelector_createSelector(
                    gridVisibleColumnDefinitionsSelector,
                    (visibleColumns) => visibleColumns.length
                ),
                [
                    "MUI: The method visibleGridColumnsLengthSelector is deprecated and will be removed in the next major version.",
                    "Use the length of the array returned by gridVisibleColumnDefinitionsSelector instead.",
                ]
            );
            /**
             * @category Visible Columns
             * @deprecated Use `gridColumnsTotalWidthSelector` or `gridColumnPositionsSelector` instead.
             * @ignore - do not document.
             */

            const gridColumnsMetaSelector = (0,
            warning /* wrapWithWarningOnCall */.M)(
                createSelector_createSelector(
                    gridColumnPositionsSelector,
                    gridColumnsTotalWidthSelector,
                    (positions, totalWidth) => ({
                        totalWidth,
                        positions,
                    })
                ),
                [
                    "MUI: The method gridColumnsMetaSelector is deprecated and will be removed in the next major version.",
                    "Use gridColumnsTotalWidthSelector or gridColumnPositionsSelector instead",
                ]
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridSelector.js
            function isOutputSelector(selector) {
                return selector.cache;
            }

            const stateNotInitializedWarning = (0,
            warning /* buildWarning */.b)([
                "MUI: `useGridSelector` has been called before the initialization of the state.",
                "This hook can only be used inside the context of the grid.",
            ]);
            const useGridSelector = (apiRef, selector) => {
                if (false) {
                }

                if (isOutputSelector(selector)) {
                    return selector(apiRef);
                }

                return selector(apiRef.current.state);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridApiContext.js
            const GridApiContext = /*#__PURE__*/ react.createContext(undefined);

            if (false) {
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridApiContext.js
            function useGridApiContext() {
                const apiRef = react.useContext(GridApiContext);

                if (apiRef === undefined) {
                    throw new Error(
                        [
                            "MUI: Could not find the data grid context.",
                            "It looks like you rendered your component outside of a DataGrid or DataGridPro parent component.",
                            "This can also happen if you are bundling multiple versions of the data grid.",
                        ].join("\n")
                    );
                }

                return apiRef;
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/context/GridRootPropsContext.js
            const GridRootPropsContext =
                /*#__PURE__*/ react.createContext(undefined);

            if (false) {
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridRootProps.js

            const useGridRootProps = () => {
                const contextValue = react.useContext(GridRootPropsContext);

                if (!contextValue) {
                    throw new Error(
                        "MUI: useGridRootProps should only be used inside the DataGrid/DataGridPro component."
                    );
                }

                return contextValue;
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/rows/gridRowsSelector.js
            const gridRowsStateSelector = (state) => state.rows;
            const gridRowCountSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.totalRowCount
            );
            const gridRowsLoadingSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.loading
            );
            const gridTopLevelRowCountSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.totalTopLevelRowCount
            );
            const gridRowsLookupSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.idRowsLookup
            );
            const gridRowTreeSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.tree
            );
            const gridRowGroupingNameSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.groupingName
            );
            const gridRowTreeDepthSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.treeDepth
            );
            const gridRowIdsSelector = createSelector_createSelector(
                gridRowsStateSelector,
                (rows) => rows.ids
            );
            // EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
            var jsx_runtime = __webpack_require__(5893); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/containers/GridRoot.js
            const _excluded = ["children", "className"];

            const GridRoot = /*#__PURE__*/ react.forwardRef(function GridRoot(
                props,
                ref
            ) {
                var _rootProps$classes;

                const rootProps = useGridRootProps();

                const { children, className } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        _excluded
                    );

                const apiRef = useGridApiContext();
                const visibleColumns = useGridSelector(
                    apiRef,
                    gridVisibleColumnDefinitionsSelector
                );
                const totalRowCount = useGridSelector(
                    apiRef,
                    gridRowCountSelector
                );
                const rootContainerRef = react.useRef(null);
                const handleRef = (0, useForkRef /* default */.Z)(
                    rootContainerRef,
                    ref
                );
                apiRef.current.rootElementRef = rootContainerRef; // Our implementation of <NoSsr />

                const [mountedState, setMountedState] = react.useState(false);
                (0, useEnhancedEffect /* default */.Z)(() => {
                    setMountedState(true);
                }, []);
                (0, useEnhancedEffect /* default */.Z)(() => {
                    if (mountedState) {
                        apiRef.current.unstable_updateGridDimensionsRef();
                    }
                }, [apiRef, mountedState]);

                if (!mountedState) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridRootStyles,
                    (0, esm_extends /* default */.Z)(
                        {
                            ref: handleRef,
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                (_rootProps$classes = rootProps.classes) == null
                                    ? void 0
                                    : _rootProps$classes.root,
                                gridClasses_gridClasses.root,
                                rootProps.autoHeight &&
                                    gridClasses_gridClasses.autoHeight
                            ),
                            role: "grid",
                            "aria-colcount": visibleColumns.length,
                            "aria-rowcount": totalRowCount,
                            "aria-multiselectable":
                                !rootProps.disableMultipleSelection,
                            "aria-label": rootProps["aria-label"],
                            "aria-labelledby": rootProps["aria-labelledby"],
                        },
                        other,
                        {
                            children: children,
                        }
                    )
                );
            });
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridLogger.js

            function useGridLogger(apiRef, name) {
                const logger = react.useRef(null);

                if (logger.current) {
                    return logger.current;
                }

                const newLogger = apiRef.current.getLogger(name);
                logger.current = newLogger;
                return newLogger;
            }
            // EXTERNAL MODULE: ./node_modules/@mui/base/composeClasses/composeClasses.js
            var composeClasses = __webpack_require__(7192); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/containers/GridMainContainer.js
            const useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["main"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridMainContainerRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "Main",
                overridesResolver: (props, styles) => styles.main,
            })(() => ({
                position: "relative",
                flexGrow: 1,
                display: "flex",
                flexDirection: "column",
                overflow: "hidden",
            }));
            function GridMainContainer(props) {
                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridMainContainerRoot,
                    {
                        className: classes.root,
                        children: props.children,
                    }
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/ErrorBoundary.js
            class ErrorBoundary extends react.Component {
                static getDerivedStateFromError(error) {
                    // Update state so the next render will show the fallback UI.
                    return {
                        hasError: true,
                        error,
                    };
                }

                componentDidCatch(error, errorInfo) {
                    if (this.props.api.current) {
                        this.logError(error); // Allows to trigger the Error event and all listener can run on Error

                        this.props.api.current.showError({
                            error,
                            errorInfo,
                        });
                    }
                }

                logError(error, errorInfo) {
                    this.props.logger.error(
                        `An unexpected error occurred. Error: ${
                            error && error.message
                        }. `,
                        error,
                        errorInfo
                    );
                }

                render() {
                    var _this$state;

                    if (
                        this.props.hasError ||
                        ((_this$state = this.state) != null &&
                            _this$state.hasError)
                    ) {
                        // You can render any custom fallback UI
                        return this.props.render(
                            this.props.componentProps || this.state
                        );
                    }

                    return this.props.children;
                }
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/base/GridErrorHandler.js
            function GridErrorHandler(props) {
                const { children } = props;
                const apiRef = useGridApiContext();
                const logger = useGridLogger(apiRef, "GridErrorHandler");
                const rootProps = useGridRootProps();
                const error = apiRef.current.state.error;
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(ErrorBoundary, {
                    hasError: error != null,
                    componentProps: error,
                    api: apiRef,
                    logger: logger,
                    render: (errorProps) => {
                        var _rootProps$components;

                        return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            GridMainContainer,
                            {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    rootProps.components.ErrorOverlay,
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        errorProps,
                                        (_rootProps$components =
                                            rootProps.componentsProps) == null
                                            ? void 0
                                            : _rootProps$components.errorOverlay
                                    )
                                ),
                            }
                        );
                    },
                    children: children,
                });
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/base/GridHeaderPlaceholder.js

            function GridHeaderPlaceholder() {
                var _rootProps$components;

                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const headerRef = react.useRef(null);
                apiRef.current.headerRef = headerRef;
                return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                    ref: headerRef,
                    children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.Header,
                        (0, esm_extends /* default */.Z)(
                            {},
                            (_rootProps$components =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components.header
                        )
                    ),
                });
            }
            // EXTERNAL MODULE: ./node_modules/@mui/x-data-grid/models/events/gridEvents.js
            var gridEvents = __webpack_require__(8701);
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/useEventCallback.js
            var useEventCallback = __webpack_require__(2068);
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/ownerWindow.js
            var ownerWindow = __webpack_require__(5340); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/lib/createDetectElementResize/index.js
            /**
             * Detect Element Resize.
             * https://github.com/sdecima/javascript-detect-element-resize
             * Sebastian Decima
             *
             * Forked from version 0.5.3; includes the following modifications:
             * 1)Guard against unsafe 'window' and 'document' references (to support SSR).
             * 2)Defer initialization code via a top-level function wrapper (to support SSR).
             * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
             * 4) Add nonce for style element.
             *
             * TODO replace with https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
             * once browser support allows it.
             **/
            function createDetectElementResize(nonce, hostWindow) {
                var resetTriggers = function resetTriggers(element) {
                    var triggers = element.__resizeTriggers__,
                        expand = triggers.firstElementChild,
                        contract = triggers.lastElementChild,
                        expandChild = expand.firstElementChild;
                    contract.scrollLeft = contract.scrollWidth;
                    contract.scrollTop = contract.scrollHeight;
                    expandChild.style.width = expand.offsetWidth + 1 + "px";
                    expandChild.style.height = expand.offsetHeight + 1 + "px";
                    expand.scrollLeft = expand.scrollWidth;
                    expand.scrollTop = expand.scrollHeight;
                };

                var checkTriggers = function checkTriggers(element) {
                    return (
                        element.offsetWidth != element.__resizeLast__.width ||
                        element.offsetHeight != element.__resizeLast__.height
                    );
                };

                var scrollListener = function scrollListener(e) {
                    // Don't measure (which forces) reflow for scrolls that happen inside of children!
                    if (
                        e.target.className.indexOf("contract-trigger") < 0 &&
                        e.target.className.indexOf("expand-trigger") < 0
                    ) {
                        return;
                    }

                    var element = this;
                    resetTriggers(this);

                    if (this.__resizeRAF__) {
                        hostWindow.cancelAnimationFrame(this.__resizeRAF__);
                    }

                    this.__resizeRAF__ = hostWindow.requestAnimationFrame(
                        function () {
                            if (checkTriggers(element)) {
                                element.__resizeLast__.width =
                                    element.offsetWidth;
                                element.__resizeLast__.height =
                                    element.offsetHeight;

                                element.__resizeListeners__.forEach(function (
                                    fn
                                ) {
                                    fn.call(element, e);
                                });
                            }
                        }
                    );
                };
                /* Detect CSS Animations support to detect element display/re-attach */

                var animation = false,
                    keyframeprefix = "",
                    animationstartevent = "animationstart",
                    domPrefixes = "Webkit Moz O ms".split(" "),
                    startEvents =
                        "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(
                            " "
                        ),
                    pfx = "";
                {
                    var elm = document.createElement("fakeelement");

                    if (elm.style.animationName !== undefined) {
                        animation = true;
                    }

                    if (animation === false) {
                        for (var i = 0; i < domPrefixes.length; i++) {
                            if (
                                elm.style[domPrefixes[i] + "AnimationName"] !==
                                undefined
                            ) {
                                pfx = domPrefixes[i];
                                keyframeprefix = "-" + pfx.toLowerCase() + "-";
                                animationstartevent = startEvents[i];
                                animation = true;
                                break;
                            }
                        }
                    }
                }
                var animationName = "resizeanim";
                var animationKeyframes =
                    "@" +
                    keyframeprefix +
                    "keyframes " +
                    animationName +
                    " { from { opacity: 0; } to { opacity: 0; } } ";
                var animationStyle =
                    keyframeprefix + "animation: 1ms " + animationName + "; ";

                var createStyles = function createStyles(doc) {
                    if (!doc.getElementById("muiDetectElementResize")) {
                        //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
                        var css =
                                (animationKeyframes ? animationKeyframes : "") +
                                ".Mui-resizeTriggers { " +
                                (animationStyle ? animationStyle : "") +
                                "visibility: hidden; opacity: 0; } " +
                                '.Mui-resizeTriggers, .Mui-resizeTriggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .Mui-resizeTriggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
                            head =
                                doc.head || doc.getElementsByTagName("head")[0],
                            style = doc.createElement("style");
                        style.id = "muiDetectElementResize";
                        style.type = "text/css";

                        if (nonce != null) {
                            style.setAttribute("nonce", nonce);
                        }

                        if (style.styleSheet) {
                            style.styleSheet.cssText = css;
                        } else {
                            style.appendChild(doc.createTextNode(css));
                        }

                        head.appendChild(style);
                    }
                };

                var addResizeListener = function addResizeListener(
                    element,
                    fn
                ) {
                    if (!element.__resizeTriggers__) {
                        var doc = element.ownerDocument;
                        var elementStyle = hostWindow.getComputedStyle(element);

                        if (elementStyle && elementStyle.position == "static") {
                            element.style.position = "relative";
                        }

                        createStyles(doc);
                        element.__resizeLast__ = {};
                        element.__resizeListeners__ = [];
                        (element.__resizeTriggers__ =
                            doc.createElement("div")).className =
                            "Mui-resizeTriggers";
                        element.__resizeTriggers__.innerHTML =
                            '<div class="expand-trigger"><div></div></div>' +
                            '<div class="contract-trigger"></div>';
                        element.appendChild(element.__resizeTriggers__);
                        resetTriggers(element);
                        element.addEventListener(
                            "scroll",
                            scrollListener,
                            true
                        );
                        /* Listen for a css animation to detect element display/re-attach */

                        if (animationstartevent) {
                            element.__resizeTriggers__.__animationListener__ =
                                function animationListener(e) {
                                    if (e.animationName == animationName) {
                                        resetTriggers(element);
                                    }
                                };

                            element.__resizeTriggers__.addEventListener(
                                animationstartevent,
                                element.__resizeTriggers__.__animationListener__
                            );
                        }
                    }

                    element.__resizeListeners__.push(fn);
                };

                var removeResizeListener = function removeResizeListener(
                    element,
                    fn
                ) {
                    element.__resizeListeners__.splice(
                        element.__resizeListeners__.indexOf(fn),
                        1
                    );

                    if (!element.__resizeListeners__.length) {
                        element.removeEventListener(
                            "scroll",
                            scrollListener,
                            true
                        );

                        if (element.__resizeTriggers__.__animationListener__) {
                            element.__resizeTriggers__.removeEventListener(
                                animationstartevent,
                                element.__resizeTriggers__.__animationListener__
                            );

                            element.__resizeTriggers__.__animationListener__ =
                                null;
                        }

                        try {
                            element.__resizeTriggers__ = !element.removeChild(
                                element.__resizeTriggers__
                            );
                        } catch (e) {
                            // Preact compat; see developit/preact-compat/issues/228
                        }
                    }
                };

                return {
                    addResizeListener,
                    removeResizeListener,
                };
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridAutoSizer.js
            const GridAutoSizer_excluded = [
                "children",
                "defaultHeight",
                "defaultWidth",
                "disableHeight",
                "disableWidth",
                "nonce",
                "onResize",
                "style",
            ];

            // TODO replace with https://caniuse.com/resizeobserver.

            const GridAutoSizer = /*#__PURE__*/ react.forwardRef(
                function AutoSizer(props, ref) {
                    const {
                            children,
                            defaultHeight = null,
                            defaultWidth = null,
                            disableHeight = false,
                            disableWidth = false,
                            nonce,
                            onResize,
                            style,
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridAutoSizer_excluded
                        );

                    const [state, setState] = react.useState({
                        height: defaultHeight,
                        width: defaultWidth,
                    });
                    const rootRef = react.useRef(null);
                    const parentElement = react.useRef(null);
                    const handleResize = (0, useEventCallback /* default */.Z)(
                        () => {
                            // Guard against AutoSizer component being removed from the DOM immediately after being added.
                            // This can result in invalid style values which can result in NaN values if we don't handle them.
                            // See issue #150 for more context.
                            if (parentElement.current) {
                                const height =
                                    parentElement.current.offsetHeight || 0;
                                const width =
                                    parentElement.current.offsetWidth || 0;
                                const win = (0, ownerWindow /* default */.Z)(
                                    parentElement.current
                                );
                                const computedStyle = win.getComputedStyle(
                                    parentElement.current
                                );
                                const paddingLeft =
                                    parseInt(computedStyle.paddingLeft, 10) ||
                                    0;
                                const paddingRight =
                                    parseInt(computedStyle.paddingRight, 10) ||
                                    0;
                                const paddingTop =
                                    parseInt(computedStyle.paddingTop, 10) || 0;
                                const paddingBottom =
                                    parseInt(computedStyle.paddingBottom, 10) ||
                                    0;
                                const newHeight =
                                    height - paddingTop - paddingBottom;
                                const newWidth =
                                    width - paddingLeft - paddingRight;

                                if (
                                    (!disableHeight &&
                                        state.height !== newHeight) ||
                                    (!disableWidth && state.width !== newWidth)
                                ) {
                                    setState({
                                        height: newHeight,
                                        width: newWidth,
                                    });

                                    if (onResize) {
                                        onResize({
                                            height: newHeight,
                                            width: newWidth,
                                        });
                                    }
                                }
                            }
                        }
                    );
                    (0, useEnhancedEffect /* default */.Z)(() => {
                        var _parentElement$curren;

                        parentElement.current = rootRef.current.parentElement;

                        if (!parentElement) {
                            return undefined;
                        }

                        const win = (0, ownerWindow /* default */.Z)(
                            (_parentElement$curren = parentElement.current) !=
                                null
                                ? _parentElement$curren
                                : undefined
                        );
                        const detectElementResize = createDetectElementResize(
                            nonce,
                            win
                        );
                        detectElementResize.addResizeListener(
                            parentElement.current,
                            handleResize
                        );
                        handleResize();
                        return () => {
                            detectElementResize.removeResizeListener(
                                parentElement.current,
                                handleResize
                            );
                        };
                    }, [nonce, handleResize]); // Outer div should not force width/height since that may prevent containers from shrinking.
                    // Inner component should overflow and use calculated width/height.
                    // See issue #68 for more information.

                    const outerStyle = {
                        overflow: "visible",
                    };
                    const childParams = {};

                    if (!disableHeight) {
                        outerStyle.height = 0;
                        childParams.height = state.height;
                    }

                    if (!disableWidth) {
                        outerStyle.width = 0;
                        childParams.width = state.width;
                    }

                    const handleRef = (0, useForkRef /* default */.Z)(
                        rootRef,
                        ref
                    );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        "div",
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: handleRef,
                                style: (0, esm_extends /* default */.Z)(
                                    {},
                                    outerStyle,
                                    style
                                ),
                            },
                            other,
                            {
                                children:
                                    state.height === null &&
                                    state.width === null
                                        ? null
                                        : children(childParams),
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/sorting/gridSortingSelector.js

            /**
             * @category Sorting
             * @ignore - do not document.
             */

            const gridSortingStateSelector = (state) => state.sorting;
            /**
             * Get the id of the rows after the sorting process.
             * @category Sorting
             */

            const gridSortedRowIdsSelector = createSelector_createSelector(
                gridSortingStateSelector,
                (sortingState) => sortingState.sortedRows
            );
            /**
             * Get the id and the model of the rows after the sorting process.
             * @category Sorting
             */

            const gridSortedRowEntriesSelector = createSelector_createSelector(
                gridSortedRowIdsSelector,
                gridRowsLookupSelector,
                (sortedIds, idRowsLookup) =>
                    sortedIds.map((id) => ({
                        id,
                        model: idRowsLookup[id],
                    }))
            );
            /**
             * Get the current sorting model.
             * @category Sorting
             */

            const gridSortModelSelector = createSelector_createSelector(
                gridSortingStateSelector,
                (sorting) => sorting.sortModel
            );

            /**
             * @category Sorting
             * @ignore - do not document.
             */
            const gridSortColumnLookupSelector = createSelector_createSelector(
                gridSortModelSelector,
                (sortModel) => {
                    const result = sortModel.reduce((res, sortItem, index) => {
                        res[sortItem.field] = {
                            sortDirection: sortItem.sort,
                            sortIndex:
                                sortModel.length > 1 ? index + 1 : undefined,
                        };
                        return res;
                    }, {});
                    return result;
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterSelector.js
            /**
             * @category Filtering
             */

            const gridFilterStateSelector = (state) => state.filter;
            /**
             * Get the current filter model.
             * @category Filtering
             */

            const gridFilterModelSelector = createSelector_createSelector(
                gridFilterStateSelector,
                (filterState) => filterState.filterModel
            );
            /**
             * @category Filtering
             * @ignore - do not document.
             */

            const gridVisibleRowsLookupSelector = createSelector_createSelector(
                gridFilterStateSelector,
                (filterState) => filterState.visibleRowsLookup
            );
            /**
             * @category Filtering
             * @ignore - do not document.
             */

            const gridFilteredRowsLookupSelector =
                createSelector_createSelector(
                    gridFilterStateSelector,
                    (filterState) => filterState.filteredRowsLookup
                );
            /**
             * @category Filtering
             * @ignore - do not document.
             */

            const gridFilteredDescendantCountLookupSelector =
                createSelector_createSelector(
                    gridFilterStateSelector,
                    (filterState) => filterState.filteredDescendantCountLookup
                );
            /**
             * Get the id and the model of the rows accessible after the filtering process.
             * Does not contain the collapsed children.
             * @category Filtering
             */

            const gridVisibleSortedRowEntriesSelector =
                createSelector_createSelector(
                    gridVisibleRowsLookupSelector,
                    gridSortedRowEntriesSelector,
                    (visibleRowsLookup, sortedRows) =>
                        sortedRows.filter(
                            (row) => visibleRowsLookup[row.id] !== false
                        )
                );
            /**
             * Get the id of the rows accessible after the filtering process.
             * Does not contain the collapsed children.
             * @category Filtering
             */

            const gridVisibleSortedRowIdsSelector =
                createSelector_createSelector(
                    gridVisibleSortedRowEntriesSelector,
                    (visibleSortedRowEntries) =>
                        visibleSortedRowEntries.map((row) => row.id)
                );
            /**
             * Get the id and the model of the rows accessible after the filtering process.
             * Contains the collapsed children.
             * @category Filtering
             */

            const gridFilteredSortedRowEntriesSelector =
                createSelector_createSelector(
                    gridFilteredRowsLookupSelector,
                    gridSortedRowEntriesSelector,
                    (filteredRowsLookup, sortedRows) =>
                        sortedRows.filter(
                            (row) => filteredRowsLookup[row.id] !== false
                        )
                );
            /**
             * Get the id of the rows accessible after the filtering process.
             * Contains the collapsed children.
             * @category Filtering
             */

            const gridFilteredSortedRowIdsSelector =
                createSelector_createSelector(
                    gridFilteredSortedRowEntriesSelector,
                    (filteredSortedRowEntries) =>
                        filteredSortedRowEntries.map((row) => row.id)
                );
            /**
             * @category Filtering
             * @deprecated Use `gridVisibleSortedRowIdsSelector` instead
             * @ignore - do not document.
             * TODO: Add deprecation warning once we have the new selectors without the "visible" keyword.
             */

            const gridVisibleRowsSelector =
                /* unused pure expression or super */ null &&
                gridVisibleSortedRowIdsSelector;
            /**
             * Get the id and the model of the top level rows accessible after the filtering process.
             * @category Filtering
             */

            const gridVisibleSortedTopLevelRowEntriesSelector =
                createSelector_createSelector(
                    gridVisibleSortedRowEntriesSelector,
                    gridRowTreeSelector,
                    gridRowTreeDepthSelector,
                    (visibleSortedRows, rowTree, rowTreeDepth) => {
                        if (rowTreeDepth < 2) {
                            return visibleSortedRows;
                        }

                        return visibleSortedRows.filter((row) => {
                            var _rowTree$row$id;

                            return (
                                ((_rowTree$row$id = rowTree[row.id]) == null
                                    ? void 0
                                    : _rowTree$row$id.depth) === 0
                            );
                        });
                    }
                );
            /**
             * Get the amount of rows accessible after the filtering process.
             * @category Filtering
             */

            const gridVisibleRowCountSelector = createSelector_createSelector(
                gridVisibleSortedRowEntriesSelector,
                (visibleSortedRows) => visibleSortedRows.length
            );
            /**
             * Get the amount of top level rows accessible after the filtering process.
             * @category Filtering
             */

            const gridVisibleTopLevelRowCountSelector =
                createSelector_createSelector(
                    gridVisibleSortedTopLevelRowEntriesSelector,
                    (visibleSortedTopLevelRows) =>
                        visibleSortedTopLevelRows.length
                );
            /**
             * @category Filtering
             * @ignore - do not document.
             */

            const gridFilterActiveItemsSelector = createSelector_createSelector(
                gridFilterModelSelector,
                gridColumnLookupSelector,
                (filterModel, columnLookup) => {
                    var _filterModel$items;

                    return (_filterModel$items = filterModel.items) == null
                        ? void 0
                        : _filterModel$items.filter((item) => {
                              var _column$filterOperato, _item$value;

                              if (!item.columnField) {
                                  return false;
                              }

                              const column = columnLookup[item.columnField];

                              if (
                                  !(column != null && column.filterOperators) ||
                                  (column == null
                                      ? void 0
                                      : (_column$filterOperato =
                                            column.filterOperators) == null
                                      ? void 0
                                      : _column$filterOperato.length) === 0
                              ) {
                                  return false;
                              }

                              const filterOperator =
                                  column.filterOperators.find(
                                      (operator) =>
                                          operator.value === item.operatorValue
                                  );

                              if (!filterOperator) {
                                  return false;
                              }

                              return (
                                  !filterOperator.InputComponent ||
                                  (item.value != null &&
                                      ((_item$value = item.value) == null
                                          ? void 0
                                          : _item$value.toString()) !== "")
                              );
                          });
                }
            );

            /**
             * @category Filtering
             * @ignore - do not document.
             */
            const gridFilterActiveItemsLookupSelector =
                createSelector_createSelector(
                    gridFilterActiveItemsSelector,
                    (activeFilters) => {
                        const result = activeFilters.reduce(
                            (res, filterItem) => {
                                if (!res[filterItem.columnField]) {
                                    res[filterItem.columnField] = [filterItem];
                                } else {
                                    res[filterItem.columnField].push(
                                        filterItem
                                    );
                                }

                                return res;
                            },
                            {}
                        );
                        return result;
                    }
                ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/density/densitySelector.js
            const gridDensitySelector = (state) => state.density;
            const gridDensityValueSelector = createSelector_createSelector(
                gridDensitySelector,
                (density) => density.value
            );
            const gridDensityRowHeightSelector = createSelector_createSelector(
                gridDensitySelector,
                (density) => density.rowHeight
            );
            const gridDensityHeaderHeightSelector =
                createSelector_createSelector(
                    gridDensitySelector,
                    (density) => density.headerHeight
                );
            const gridDensityFactorSelector = createSelector_createSelector(
                gridDensitySelector,
                (density) => density.factor
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/base/GridOverlays.js
            function GridOverlayWrapper(props) {
                var _viewportInnerSize$he, _viewportInnerSize$wi;

                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const headerHeight = useGridSelector(
                    apiRef,
                    gridDensityHeaderHeightSelector
                );
                const [viewportInnerSize, setViewportInnerSize] =
                    react.useState(() => {
                        var _apiRef$current$getRo, _apiRef$current$getRo2;

                        return (_apiRef$current$getRo =
                            (_apiRef$current$getRo2 =
                                apiRef.current.getRootDimensions()) == null
                                ? void 0
                                : _apiRef$current$getRo2.viewportInnerSize) !=
                            null
                            ? _apiRef$current$getRo
                            : null;
                    });
                const handleViewportSizeChange = react.useCallback(() => {
                    var _apiRef$current$getRo3, _apiRef$current$getRo4;

                    setViewportInnerSize(
                        (_apiRef$current$getRo3 =
                            (_apiRef$current$getRo4 =
                                apiRef.current.getRootDimensions()) == null
                                ? void 0
                                : _apiRef$current$getRo4.viewportInnerSize) !=
                            null
                            ? _apiRef$current$getRo3
                            : null
                    );
                }, [apiRef]);
                (0, useEnhancedEffect /* default */.Z)(() => {
                    return apiRef.current.subscribeEvent(
                        gridEvents /* GridEvents.viewportInnerSizeChange */.t
                            .viewportInnerSizeChange,
                        handleViewportSizeChange
                    );
                }, [apiRef, handleViewportSizeChange]);
                let height =
                    (_viewportInnerSize$he =
                        viewportInnerSize == null
                            ? void 0
                            : viewportInnerSize.height) != null
                        ? _viewportInnerSize$he
                        : 0;

                if (rootProps.autoHeight && height === 0) {
                    height = "auto";
                }

                if (!viewportInnerSize) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    "div",
                    (0, esm_extends /* default */.Z)(
                        {
                            style: {
                                height,
                                width:
                                    (_viewportInnerSize$wi =
                                        viewportInnerSize == null
                                            ? void 0
                                            : viewportInnerSize.width) != null
                                        ? _viewportInnerSize$wi
                                        : 0,
                                position: "absolute",
                                top: headerHeight,
                                bottom: height === "auto" ? 0 : undefined,
                            },
                        },
                        props
                    )
                );
            }

            function GridOverlays() {
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const totalRowCount = useGridSelector(
                    apiRef,
                    gridRowCountSelector
                );
                const visibleRowCount = useGridSelector(
                    apiRef,
                    gridVisibleRowCountSelector
                );
                const loading = useGridSelector(
                    apiRef,
                    gridRowsLoadingSelector
                );
                const showNoRowsOverlay = !loading && totalRowCount === 0;
                const showNoResultsOverlay =
                    !loading && totalRowCount > 0 && visibleRowCount === 0;
                let overlay = null;

                if (showNoRowsOverlay) {
                    var _rootProps$components;

                    overlay = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.NoRowsOverlay,
                        (0, esm_extends /* default */.Z)(
                            {},
                            (_rootProps$components =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components.noRowsOverlay
                        )
                    );
                }

                if (showNoResultsOverlay) {
                    var _rootProps$components2;

                    overlay = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.NoResultsOverlay,
                        (0, esm_extends /* default */.Z)(
                            {},
                            (_rootProps$components2 =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components2.noResultsOverlay
                        )
                    );
                }

                if (rootProps.loading) {
                    var _rootProps$components3;

                    overlay = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.LoadingOverlay,
                        (0, esm_extends /* default */.Z)(
                            {},
                            (_rootProps$components3 =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components3.loadingOverlay
                        )
                    );
                }

                if (overlay === null) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(GridOverlayWrapper, {
                    children: overlay,
                });
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/base/GridBody.js
            function GridBody(props) {
                const {
                    children,
                    VirtualScrollerComponent,
                    ColumnHeadersComponent,
                } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const headerHeight = useGridSelector(
                    apiRef,
                    gridDensityHeaderHeightSelector
                );
                const [isVirtualizationDisabled, setIsVirtualizationDisabled] =
                    react.useState(rootProps.disableVirtualization);
                const disableVirtualization = react.useCallback(() => {
                    setIsVirtualizationDisabled(true);
                }, []);
                const enableVirtualization = react.useCallback(() => {
                    setIsVirtualizationDisabled(false);
                }, []); // The `useGridApiMethod` hook can't be used here, because it only installs the
                // method if it doesn't exist yet. Once installed, it's never updated again.
                // This break the methods above, since their closure comes from the first time
                // they were installed. Which means that calling `setIsVirtualizationDisabled`
                // will trigger a re-render, but it won't update the state. That can be solved
                // by migrating the virtualization status to the global state.

                apiRef.current.unstable_disableVirtualization =
                    disableVirtualization;
                apiRef.current.unstable_enableVirtualization =
                    enableVirtualization;
                const columnHeadersRef = react.useRef(null);
                const columnsContainerRef = react.useRef(null);
                const windowRef = react.useRef(null);
                const renderingZoneRef = react.useRef(null);
                apiRef.current.columnHeadersContainerElementRef =
                    columnsContainerRef;
                apiRef.current.columnHeadersElementRef = columnHeadersRef;
                apiRef.current.windowRef = windowRef; // TODO rename, it's not attached to the window anymore

                apiRef.current.renderingZoneRef = renderingZoneRef; // TODO remove, nobody should have access to internal parts of the virtualization

                const handleResize = react.useCallback(
                    (size) => {
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.resize */.t.resize,
                            size
                        );
                    },
                    [apiRef]
                );
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(GridMainContainer, {
                    children: [
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(GridOverlays, {}),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            ColumnHeadersComponent,
                            {
                                ref: columnsContainerRef,
                                innerRef: columnHeadersRef,
                            }
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(GridAutoSizer, {
                            nonce: rootProps.nonce,
                            disableHeight: rootProps.autoHeight,
                            onResize: handleResize,
                            children: (size) => {
                                const style = {
                                    width: size.width,
                                    // If `autoHeight` is on, there will be no height value.
                                    // In this case, let the container to grow whatever it needs.
                                    height: size.height
                                        ? size.height - headerHeight
                                        : "auto",
                                    marginTop: headerHeight,
                                };
                                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    VirtualScrollerComponent,
                                    {
                                        ref: windowRef,
                                        style: style,
                                        disableVirtualization:
                                            isVirtualizationDisabled,
                                    }
                                );
                            },
                        }),
                        children,
                    ],
                });
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/base/GridFooterPlaceholder.js

            function GridFooterPlaceholder() {
                var _rootProps$components;

                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const footerRef = react.useRef(null);
                apiRef.current.footerRef = footerRef;

                if (rootProps.hideFooter) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                    ref: footerRef,
                    children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.Footer,
                        (0, esm_extends /* default */.Z)(
                            {},
                            (_rootProps$components =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components.footer
                        )
                    ),
                });
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/context/GridContextProvider.js
            const GridContextProvider = ({ apiRef, props, children }) => {
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridRootPropsContext.Provider,
                    {
                        value: props,
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            GridApiContext.Provider,
                            {
                                value: apiRef,
                                children: children,
                            }
                        ),
                    }
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/utils.js
            function isNumber(value) {
                return typeof value === "number";
            }
            function isFunction(value) {
                return typeof value === "function";
            }
            function isObject(value) {
                return typeof value === "object";
            }
            function localStorageAvailable() {
                try {
                    // Incognito mode might reject access to the localStorage for security reasons.
                    // window isn't defined on Node.js
                    // https://stackoverflow.com/questions/16427636/check-if-localstorage-is-available
                    const key = "__some_random_key_you_are_not_going_to_use__";
                    window.localStorage.setItem(key, key);
                    window.localStorage.removeItem(key);
                    return true;
                } catch (err) {
                    return false;
                }
            }
            function escapeRegExp(value) {
                return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            }
            /**
             * Follows the CSS specification behavior for min and max
             * If min > max, then the min have priority
             */

            const clamp = (value, min, max) =>
                Math.max(min, Math.min(max, value));
            /**
             * Based on `fast-deep-equal`
             *
             *  MIT License
             *
             * Copyright (c) 2017 Evgeny Poberezkin
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in all
             * copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
             * SOFTWARE.
             * We only type the public interface to avoid dozens of `as` in the function.
             */

            function isDeepEqual(a, b) {
                if (a === b) {
                    return true;
                }

                if (a && b && typeof a === "object" && typeof b === "object") {
                    if (a.constructor !== b.constructor) {
                        return false;
                    }

                    if (Array.isArray(a)) {
                        const length = a.length;

                        if (length !== b.length) {
                            return false;
                        }

                        for (let i = 0; i < length; i += 1) {
                            if (!isDeepEqual(a[i], b[i])) {
                                return false;
                            }
                        }

                        return true;
                    }

                    if (a instanceof Map && b instanceof Map) {
                        if (a.size !== b.size) {
                            return false;
                        }

                        const entriesA = Array.from(a.entries());

                        for (let i = 0; i < entriesA.length; i += 1) {
                            if (!b.has(entriesA[i][0])) {
                                return false;
                            }
                        }

                        for (let i = 0; i < entriesA.length; i += 1) {
                            const entryA = entriesA[i];

                            if (!isDeepEqual(entryA[1], b.get(entryA[0]))) {
                                return false;
                            }
                        }

                        return true;
                    }

                    if (a instanceof Set && b instanceof Set) {
                        if (a.size !== b.size) {
                            return false;
                        }

                        const entries = Array.from(a.entries());

                        for (let i = 0; i < entries.length; i += 1) {
                            if (!b.has(entries[i][0])) {
                                return false;
                            }
                        }

                        return true;
                    }

                    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
                        const length = a.length;

                        if (length !== b.length) {
                            return false;
                        }

                        for (let i = 0; i < length; i += 1) {
                            if (a[i] !== b[i]) {
                                return false;
                            }
                        }

                        return true;
                    }

                    if (a.constructor === RegExp) {
                        return a.source === b.source && a.flags === b.flags;
                    }

                    if (a.valueOf !== Object.prototype.valueOf) {
                        return a.valueOf() === b.valueOf();
                    }

                    if (a.toString !== Object.prototype.toString) {
                        return a.toString() === b.toString();
                    }

                    const keys = Object.keys(a);
                    const length = keys.length;

                    if (length !== Object.keys(b).length) {
                        return false;
                    }

                    for (let i = 0; i < length; i += 1) {
                        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
                            return false;
                        }
                    }

                    for (let i = 0; i < length; i += 1) {
                        const key = keys[i];

                        if (!isDeepEqual(a[key], b[key])) {
                            return false;
                        }
                    }

                    return true;
                } // true if both NaN, false otherwise
                // eslint-disable-next-line no-self-compare

                return a !== a && b !== b;
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/useGridLoggerFactory.js
            const forceDebug =
                localStorageAvailable() &&
                window.localStorage.getItem("DEBUG") != null;

            const noop = () => {};

            const noopLogger = {
                debug: noop,
                info: noop,
                warn: noop,
                error: noop,
            };
            const LOG_LEVELS = ["debug", "info", "warn", "error"];

            function getAppender(name, logLevel, appender = console) {
                const minLogLevelIdx = LOG_LEVELS.indexOf(logLevel);

                if (minLogLevelIdx === -1) {
                    throw new Error(
                        `MUI: Log level ${logLevel} not recognized.`
                    );
                }

                const logger = LOG_LEVELS.reduce((loggerObj, method, idx) => {
                    if (idx >= minLogLevelIdx) {
                        loggerObj[method] = (...args) => {
                            const [message, ...other] = args;
                            appender[method](
                                `MUI: ${name} - ${message}`,
                                ...other
                            );
                        };
                    } else {
                        loggerObj[method] = noop;
                    }

                    return loggerObj;
                }, {});
                return logger;
            }

            const useGridLoggerFactory = (apiRef, props) => {
                apiRef.current.getLogger = react.useCallback(
                    (name) => {
                        if (forceDebug) {
                            return getAppender(name, "debug", props.logger);
                        }

                        if (!props.logLevel) {
                            return noopLogger;
                        }

                        return getAppender(
                            name,
                            props.logLevel.toString(),
                            props.logger
                        );
                    },
                    [props.logLevel, props.logger]
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridApiMethod.js
            function useGridApiMethod(
                apiRef,
                apiMethods, // TODO: Remove `apiName
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                apiName
            ) {
                const apiMethodsRef = react.useRef(apiMethods);
                const [apiMethodsNames] = react.useState(
                    Object.keys(apiMethods)
                );
                const installMethods = react.useCallback(() => {
                    if (!apiRef.current) {
                        return;
                    }

                    apiMethodsNames.forEach((methodName) => {
                        if (!apiRef.current.hasOwnProperty(methodName)) {
                            apiRef.current[methodName] = (...args) =>
                                apiMethodsRef.current[methodName](...args);
                        }
                    });
                }, [apiMethodsNames, apiRef]);
                react.useEffect(() => {
                    apiMethodsRef.current = apiMethods;
                }, [apiMethods]);
                react.useEffect(() => {
                    installMethods();
                }, [installMethods]);
                installMethods();
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/cleanupTracking/TimerBasedCleanupTracking.js
            // If no effect ran after this amount of time, we assume that the render was not committed by React
            const CLEANUP_TIMER_LOOP_MILLIS = 1000;
            class TimerBasedCleanupTracking {
                constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
                    this.timeouts = new Map();
                    this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
                    this.cleanupTimeout = timeout;
                }

                register(object, unsubscribe, unregisterToken) {
                    if (!this.timeouts) {
                        this.timeouts = new Map();
                    }

                    const timeout = setTimeout(() => {
                        if (typeof unsubscribe === "function") {
                            unsubscribe();
                        }

                        this.timeouts.delete(unregisterToken.cleanupToken);
                    }, this.cleanupTimeout);
                    this.timeouts.set(unregisterToken.cleanupToken, timeout);
                }

                unregister(unregisterToken) {
                    const timeout = this.timeouts.get(
                        unregisterToken.cleanupToken
                    );

                    if (timeout) {
                        this.timeouts.delete(unregisterToken.cleanupToken);
                        clearTimeout(timeout);
                    }
                }

                reset() {
                    if (this.timeouts) {
                        this.timeouts.forEach((value, key) => {
                            this.unregister({
                                cleanupToken: key,
                            });
                        });
                        this.timeouts = undefined;
                    }
                }
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/cleanupTracking/FinalizationRegistryBasedCleanupTracking.js
            class FinalizationRegistryBasedCleanupTracking {
                constructor() {
                    this.registry = new FinalizationRegistry((unsubscribe) => {
                        if (typeof unsubscribe === "function") {
                            unsubscribe();
                        }
                    });
                }

                register(object, unsubscribe, unregisterToken) {
                    this.registry.register(
                        object,
                        unsubscribe,
                        unregisterToken
                    );
                }

                unregister(unregisterToken) {
                    this.registry.unregister(unregisterToken);
                } // eslint-disable-next-line class-methods-use-this

                reset() {}
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridApiEventHandler.js
            /**
             * Signal to the underlying logic what version of the public component API
             * of the data grid is exposed.
             */
            var GridSignature; // We use class to make it easier to detect in heap snapshots by name

            (function (GridSignature) {
                GridSignature["DataGrid"] = "DataGrid";
                GridSignature["DataGridPro"] = "DataGridPro";
            })(GridSignature || (GridSignature = {}));

            class ObjectToBeRetainedByReact {} // Based on https://github.com/Bnaya/use-dispose-uncommitted/blob/main/src/finalization-registry-based-impl.ts
            // Check https://github.com/facebook/react/issues/15317 to get more information

            function createUseGridApiEventHandler(registry) {
                let cleanupTokensCounter = 0;
                return function useGridApiEventHandler(
                    apiRef,
                    eventName,
                    handler,
                    options
                ) {
                    const [objectRetainedByReact] = react.useState(
                        new ObjectToBeRetainedByReact()
                    );
                    const subscription = react.useRef(null);
                    const handlerRef = react.useRef();
                    handlerRef.current = handler;
                    const cleanupTokenRef = react.useRef(null);

                    if (!subscription.current && handlerRef.current) {
                        const enhancedHandler = (params, event, details) => {
                            if (!event.defaultMuiPrevented) {
                                var _handlerRef$current;

                                (_handlerRef$current = handlerRef.current) ==
                                null
                                    ? void 0
                                    : _handlerRef$current.call(
                                          handlerRef,
                                          params,
                                          event,
                                          details
                                      );
                            }
                        };

                        subscription.current = apiRef.current.subscribeEvent(
                            eventName,
                            enhancedHandler,
                            options
                        );
                        cleanupTokensCounter += 1;
                        cleanupTokenRef.current = {
                            cleanupToken: cleanupTokensCounter,
                        };
                        registry.register(
                            objectRetainedByReact, // The callback below will be called once this reference stops being retained
                            () => {
                                var _subscription$current;

                                (_subscription$current =
                                    subscription.current) == null
                                    ? void 0
                                    : _subscription$current.call(subscription);
                                subscription.current = null;
                                cleanupTokenRef.current = null;
                            },
                            cleanupTokenRef.current
                        );
                    } else if (!handlerRef.current && subscription.current) {
                        subscription.current();
                        subscription.current = null;

                        if (cleanupTokenRef.current) {
                            registry.unregister(cleanupTokenRef.current);
                            cleanupTokenRef.current = null;
                        }
                    }

                    react.useEffect(() => {
                        if (!subscription.current && handlerRef.current) {
                            const enhancedHandler = (
                                params,
                                event,
                                details
                            ) => {
                                if (!event.defaultMuiPrevented) {
                                    var _handlerRef$current2;

                                    (_handlerRef$current2 =
                                        handlerRef.current) == null
                                        ? void 0
                                        : _handlerRef$current2.call(
                                              handlerRef,
                                              params,
                                              event,
                                              details
                                          );
                                }
                            };

                            subscription.current =
                                apiRef.current.subscribeEvent(
                                    eventName,
                                    enhancedHandler,
                                    options
                                );
                        }

                        if (cleanupTokenRef.current && registry) {
                            // If the effect was called, it means that this render was committed
                            // so we can trust the cleanup function to remove the listener.
                            registry.unregister(cleanupTokenRef.current);
                            cleanupTokenRef.current = null;
                        }

                        return () => {
                            var _subscription$current2;

                            (_subscription$current2 = subscription.current) ==
                            null
                                ? void 0
                                : _subscription$current2.call(subscription);
                            subscription.current = null;
                        };
                    }, [apiRef, eventName, options]);
                };
            }
            const registry =
                typeof FinalizationRegistry !== "undefined"
                    ? new FinalizationRegistryBasedCleanupTracking()
                    : new TimerBasedCleanupTracking(); // eslint-disable-next-line @typescript-eslint/naming-convention

            const unstable_resetCleanupTracking = () => registry.reset();
            const useGridApiEventHandler =
                createUseGridApiEventHandler(registry);
            const optionsSubscriberOptions = {
                isFirst: true,
            };
            function useGridApiOptionHandler(apiRef, eventName, handler) {
                // Validate that only one per event name?
                useGridApiEventHandler(
                    apiRef,
                    eventName,
                    handler,
                    optionsSubscriberOptions
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/EventManager.js

            // Used https://gist.github.com/mudge/5830382 as a starting point.
            // See https://github.com/browserify/events/blob/master/events.js for
            // the Node.js (https://nodejs.org/api/events.html) polyfill used by webpack.
            class EventManager {
                constructor() {
                    this.maxListeners = 10;
                    this.warnOnce = false;
                    this.events = {};
                }

                on(eventName, listener, options = {}) {
                    let collection = this.events[eventName];

                    if (!collection) {
                        collection = {
                            highPriority: new Map(),
                            regular: new Map(),
                        };
                        this.events[eventName] = collection;
                    }

                    if (options.isFirst) {
                        collection.highPriority.set(listener, true);
                    } else {
                        collection.regular.set(listener, true);
                    }

                    if (false) {
                    }
                }

                removeListener(eventName, listener) {
                    if (this.events[eventName]) {
                        this.events[eventName].regular.delete(listener);
                        this.events[eventName].highPriority.delete(listener);
                    }
                }

                removeAllListeners() {
                    this.events = {};
                }

                emit(eventName, ...args) {
                    const collection = this.events[eventName];

                    if (!collection) {
                        return;
                    }

                    const highPriorityListeners = Array.from(
                        collection.highPriority.keys()
                    );
                    const regularListeners = Array.from(
                        collection.regular.keys()
                    );

                    for (
                        let i = highPriorityListeners.length - 1;
                        i >= 0;
                        i -= 1
                    ) {
                        const listener = highPriorityListeners[i];

                        if (collection.highPriority.has(listener)) {
                            listener.apply(this, args);
                        }
                    }

                    for (let i = 0; i < regularListeners.length; i += 1) {
                        const listener = regularListeners[i];

                        if (collection.regular.has(listener)) {
                            listener.apply(this, args);
                        }
                    }
                }

                once(eventName, listener) {
                    // eslint-disable-next-line consistent-this
                    const that = this;
                    this.on(eventName, function oneTimeListener(...args) {
                        that.removeListener(eventName, oneTimeListener);
                        listener.apply(that, args);
                    });
                }
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/useGridApiInitialization.js
            const isSyntheticEvent = (event) => {
                return event.isPropagationStopped !== undefined;
            };

            let globalId = 0;
            function useGridApiInitialization(inputApiRef, props) {
                const apiRef = react.useRef();

                if (!apiRef.current) {
                    apiRef.current = {
                        unstable_eventManager: new EventManager(),
                        state: {},
                        instanceId: globalId,
                    };
                    globalId += 1;
                }

                react.useImperativeHandle(inputApiRef, () => apiRef.current, [
                    apiRef,
                ]);
                const publishEvent = react.useCallback(
                    (...args) => {
                        const [name, params, event = {}] = args;
                        event.defaultMuiPrevented = false;

                        if (
                            isSyntheticEvent(event) &&
                            event.isPropagationStopped()
                        ) {
                            return;
                        }

                        const details =
                            props.signature === GridSignature.DataGridPro
                                ? {
                                      api: apiRef.current,
                                  }
                                : {};
                        apiRef.current.unstable_eventManager.emit(
                            name,
                            params,
                            event,
                            details
                        );
                    },
                    [apiRef, props.signature]
                );
                const subscribeEvent = react.useCallback(
                    (event, handler, options) => {
                        apiRef.current.unstable_eventManager.on(
                            event,
                            handler,
                            options
                        );
                        const api = apiRef.current;
                        return () => {
                            api.unstable_eventManager.removeListener(
                                event,
                                handler
                            );
                        };
                    },
                    [apiRef]
                );
                const showError = react.useCallback(
                    (args) => {
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.componentError */.t
                                .componentError,
                            args
                        );
                    },
                    [apiRef]
                );
                useGridApiMethod(
                    apiRef,
                    {
                        subscribeEvent,
                        publishEvent,
                        showError,
                    },
                    "GridCoreApi"
                );
                react.useEffect(() => {
                    const api = apiRef.current;
                    return () => {
                        api.publishEvent(
                            gridEvents /* GridEvents.unmount */.t.unmount
                        );
                    };
                }, [apiRef]);
                return apiRef;
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/useGridErrorHandler.js
            function useGridErrorHandler(apiRef, props) {
                const handleError = react.useCallback(
                    (args) => {
                        // We are handling error here, to set up the handler as early as possible and be able to catch error thrown at init time.
                        apiRef.current.setState((state) =>
                            (0, esm_extends /* default */.Z)({}, state, {
                                error: args,
                            })
                        );
                    },
                    [apiRef]
                );
                react.useEffect(() => {
                    handleError(props.error);
                }, [handleError, props.error]);
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.componentError */.t.componentError,
                    handleError
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/useGridLocaleText.js
            const useGridLocaleText = (apiRef, props) => {
                const getLocaleText = react.useCallback(
                    (key) => {
                        if (props.localeText[key] == null) {
                            throw new Error(
                                `Missing translation for key ${key}.`
                            );
                        }

                        return props.localeText[key];
                    },
                    [props.localeText]
                );
                const localeTextApi = {
                    getLocaleText,
                };
                useGridApiMethod(apiRef, localeTextApi, "LocaleTextApi");
            }; // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
            function _typeof(obj) {
                "@babel/helpers - typeof";

                return (
                    (_typeof =
                        "function" == typeof Symbol &&
                        "symbol" == typeof Symbol.iterator
                            ? function (obj) {
                                  return typeof obj;
                              }
                            : function (obj) {
                                  return obj &&
                                      "function" == typeof Symbol &&
                                      obj.constructor === Symbol &&
                                      obj !== Symbol.prototype
                                      ? "symbol"
                                      : typeof obj;
                              }),
                    _typeof(obj)
                );
            } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js
            function _toPrimitive(input, hint) {
                if (_typeof(input) !== "object" || input === null) return input;
                var prim = input[Symbol.toPrimitive];

                if (prim !== undefined) {
                    var res = prim.call(input, hint || "default");
                    if (_typeof(res) !== "object") return res;
                    throw new TypeError(
                        "@@toPrimitive must return a primitive value."
                    );
                }

                return (hint === "string" ? String : Number)(input);
            } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
            function _toPropertyKey(arg) {
                var key = _toPrimitive(arg, "string");
                return _typeof(key) === "symbol" ? key : String(key);
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/pipeProcessing/useGridPipeProcessing.js
            /**
             * Implement the Pipeline Pattern
             *
             * More information and detailed example in (TODO add link to technical doc when ready)
             *
             * Some plugins contains custom logic to enrich data provided by other plugins or components.
             * For instance, the row grouping plugin needs to add / remove the grouping columns when the grid columns are updated.
             *
             * =====================================================================================================================
             *
             * The plugin containing the custom logic must use:
             *
             * - `useGridRegisterPipeProcessor` to register their processor.
             *
             * - `apiRef.current.unstable_requestPipeProcessorsApplication` to imperatively re-apply a group.
             *   This method should be used in last resort.
             *   Most of the time, the application should be triggered by an update on the deps of the processor.
             *
             * =====================================================================================================================
             *
             * The plugin or component that needs to enrich its data must use:
             *
             * - `apiRef.current.unstable_applyPipeProcessors` to run in chain all the processors of a given group.
             *
             * - `useGridRegisterPipeApplier` to re-apply the whole pipe when requested.
             *   The applier will be called when:
             *   * a processor is registered.
             *   * `apiRef.current.unstable_requestPipeProcessorsApplication` is called for the given group.
             */
            const useGridPipeProcessing = (apiRef) => {
                const processorsCache = react.useRef({});
                const runAppliers = react.useCallback((groupCache) => {
                    if (!groupCache) {
                        return;
                    }

                    Object.values(groupCache.appliers).forEach((callback) => {
                        callback();
                    });
                }, []);
                const registerPipeProcessor = react.useCallback(
                    (group, id, processor) => {
                        if (!processorsCache.current[group]) {
                            processorsCache.current[group] = {
                                processors: {},
                                appliers: {},
                            };
                        }

                        const groupCache = processorsCache.current[group];
                        const oldProcessor = groupCache.processors[id];

                        if (oldProcessor !== processor) {
                            groupCache.processors[id] = processor;
                            runAppliers(groupCache);
                        }

                        return () => {
                            const _processors =
                                    processorsCache.current[group].processors,
                                otherProcessors = (0,
                                objectWithoutPropertiesLoose /* default */.Z)(
                                    _processors,
                                    [id].map(_toPropertyKey)
                                );

                            processorsCache.current[group].processors =
                                otherProcessors;
                        };
                    },
                    [runAppliers]
                );
                const registerPipeApplier = react.useCallback(
                    (group, id, applier) => {
                        if (!processorsCache.current[group]) {
                            processorsCache.current[group] = {
                                processors: {},
                                appliers: {},
                            };
                        }

                        processorsCache.current[group].appliers[id] = applier;
                        return () => {
                            const _appliers =
                                    processorsCache.current[group].appliers,
                                otherAppliers = (0,
                                objectWithoutPropertiesLoose /* default */.Z)(
                                    _appliers,
                                    [id].map(_toPropertyKey)
                                );

                            processorsCache.current[group].appliers =
                                otherAppliers;
                        };
                    },
                    []
                );
                const requestPipeProcessorsApplication = react.useCallback(
                    (group) => {
                        const groupCache = processorsCache.current[group];
                        runAppliers(groupCache);
                    },
                    [runAppliers]
                );
                const applyPipeProcessors = react.useCallback((...args) => {
                    const [group, value, context] = args;

                    if (!processorsCache.current[group]) {
                        return value;
                    }

                    const preProcessors = Object.values(
                        processorsCache.current[group].processors
                    );
                    return preProcessors.reduce((acc, preProcessor) => {
                        return preProcessor(acc, context);
                    }, value);
                }, []);
                const preProcessingApi = {
                    unstable_registerPipeProcessor: registerPipeProcessor,
                    unstable_registerPipeApplier: registerPipeApplier,
                    unstable_requestPipeProcessorsApplication:
                        requestPipeProcessorsApplication,
                    unstable_applyPipeProcessors: applyPipeProcessors,
                };
                useGridApiMethod(
                    apiRef,
                    preProcessingApi,
                    "GridPipeProcessingApi"
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/strategyProcessing/useGridStrategyProcessing.js
            const GRID_DEFAULT_STRATEGY = "none";
            const GRID_STRATEGIES_PROCESSORS = {
                rowTreeCreation: "rowTree",
                filtering: "rowTree",
                sorting: "rowTree",
            };

            /**
             * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)
             *
             * More information and detailed example in (TODO add link to technical doc when ready)
             *
             * Some plugins contains custom logic that must only be applied if the right strategy is active.
             * For instance, the row grouping plugin has a custom filtering algorithm.
             * This algorithm must be applied by the filtering plugin if the row grouping is the current way of grouping rows,
             * but not if the tree data is the current way of grouping rows.
             *
             * =====================================================================================================================
             *
             * The plugin containing the custom logic must use:
             *
             * - `useGridRegisterStrategyProcessor` to register their processor.
             *   When the processor of the active strategy changes, it will fire `GridEvents.activeStrategyProcessorChange` to re-apply the processor.
             *
             * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.
             *
             * =====================================================================================================================
             *
             * The plugin or component that needs to apply the custom logic of the current strategy must use:
             *
             * - `apiRef.current.unstable_applyStrategyProcessor` to run the processor of the active strategy for a given processor name.
             *
             * - `GridEvents.strategyAvailabilityChange` to update something when the active strategy changes.
             *    Warning: Be careful not to apply the processor several times.
             *    For instance `GridEvents.rowsSet` is fired by `useGridRows` whenever the active strategy changes.
             *    So listening to both would most likely run your logic twice.
             *
             * - `GridEvents.activeStrategyProcessorChange` to update something when the processor of the active strategy changes.
             *
             * =====================================================================================================================
             *
             * Each processor name is part of a strategy group which can only have one active strategy at the time.
             * For now, there is only one strategy group named `rowTree` which customize
             * - row tree creation algorithm.
             * - sorting algorithm.
             * - filtering algorithm.
             */
            const useGridStrategyProcessing = (apiRef) => {
                const availableStrategies = react.useRef(new Map());
                const strategiesCache = react.useRef({});
                const registerStrategyProcessor = react.useCallback(
                    (strategyName, processorName, processor) => {
                        const cleanup = () => {
                            const _ref = strategiesCache.current[processorName],
                                otherProcessors = (0,
                                objectWithoutPropertiesLoose /* default */.Z)(
                                    _ref,
                                    [strategyName].map(_toPropertyKey)
                                );

                            strategiesCache.current[processorName] =
                                otherProcessors;
                        };

                        if (!strategiesCache.current[processorName]) {
                            strategiesCache.current[processorName] = {};
                        }

                        const groupPreProcessors =
                            strategiesCache.current[processorName];
                        const previousProcessor =
                            groupPreProcessors[strategyName];
                        groupPreProcessors[strategyName] = processor;

                        if (
                            !previousProcessor ||
                            previousProcessor === processor
                        ) {
                            return cleanup;
                        }

                        if (
                            strategyName ===
                            apiRef.current.unstable_getActiveStrategy(
                                GRID_STRATEGIES_PROCESSORS[processorName]
                            )
                        ) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.activeStrategyProcessorChange */
                                    .t.activeStrategyProcessorChange,
                                processorName
                            );
                        }

                        return cleanup;
                    },
                    [apiRef]
                );
                const applyStrategyProcessor = react.useCallback(
                    (processorName, params) => {
                        const activeStrategy =
                            apiRef.current.unstable_getActiveStrategy(
                                GRID_STRATEGIES_PROCESSORS[processorName]
                            );

                        if (activeStrategy == null) {
                            throw new Error(
                                "Can't apply a strategy processor before defining an active strategy"
                            );
                        }

                        const groupCache =
                            strategiesCache.current[processorName];

                        if (!groupCache || !groupCache[activeStrategy]) {
                            throw new Error(
                                `No processor found for processor "${processorName}" on strategy "${activeStrategy}"`
                            );
                        }

                        const processor = groupCache[activeStrategy];
                        return processor(params);
                    },
                    [apiRef]
                );
                const getActiveStrategy = react.useCallback((strategyGroup) => {
                    var _availableStrategyEnt;

                    const strategyEntries = Array.from(
                        availableStrategies.current.entries()
                    );
                    const availableStrategyEntry = strategyEntries.find(
                        ([, strategy]) => {
                            if (strategy.group !== strategyGroup) {
                                return false;
                            }

                            return strategy.isAvailable();
                        }
                    );
                    return (_availableStrategyEnt =
                        availableStrategyEntry == null
                            ? void 0
                            : availableStrategyEntry[0]) != null
                        ? _availableStrategyEnt
                        : GRID_DEFAULT_STRATEGY;
                }, []);
                const setStrategyAvailability = react.useCallback(
                    (strategyGroup, strategyName, isAvailable) => {
                        availableStrategies.current.set(strategyName, {
                            group: strategyGroup,
                            isAvailable,
                        });
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.strategyAvailabilityChange */
                                .t.strategyAvailabilityChange
                        );
                    },
                    [apiRef]
                );
                const strategyProcessingApi = {
                    unstable_registerStrategyProcessor:
                        registerStrategyProcessor,
                    unstable_applyStrategyProcessor: applyStrategyProcessor,
                    unstable_getActiveStrategy: getActiveStrategy,
                    unstable_setStrategyAvailability: setStrategyAvailability,
                };
                useGridApiMethod(
                    apiRef,
                    strategyProcessingApi,
                    "GridStrategyProcessing"
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/useGridStateInitialization.js
            const useGridStateInitialization_excluded = ["stateId"];

            const useGridStateInitialization = (apiRef, props) => {
                const controlStateMapRef = react.useRef({});
                const [, rawForceUpdate] = react.useState();
                const updateControlState = react.useCallback(
                    (controlStateItem) => {
                        const { stateId } = controlStateItem,
                            others = (0,
                            objectWithoutPropertiesLoose /* default */.Z)(
                                controlStateItem,
                                useGridStateInitialization_excluded
                            );

                        controlStateMapRef.current[stateId] = (0,
                        esm_extends /* default */.Z)({}, others, {
                            stateId,
                        });
                    },
                    []
                );
                const setState = react.useCallback(
                    (state) => {
                        let newState;

                        if (isFunction(state)) {
                            newState = state(apiRef.current.state);
                        } else {
                            newState = state;
                        }

                        if (apiRef.current.state === newState) {
                            return false;
                        }

                        let ignoreSetState = false; // Apply the control state constraints

                        const updatedControlStateIds = [];
                        Object.keys(controlStateMapRef.current).forEach(
                            (stateId) => {
                                const controlState =
                                    controlStateMapRef.current[stateId];
                                const oldSubState = controlState.stateSelector(
                                    apiRef.current.state,
                                    apiRef.current.instanceId
                                );
                                const newSubState = controlState.stateSelector(
                                    newState,
                                    apiRef.current.instanceId
                                );

                                if (newSubState === oldSubState) {
                                    return;
                                }

                                updatedControlStateIds.push({
                                    stateId: controlState.stateId,
                                    hasPropChanged:
                                        newSubState !== controlState.propModel,
                                }); // The state is controlled, the prop should always win

                                if (
                                    controlState.propModel !== undefined &&
                                    newSubState !== controlState.propModel
                                ) {
                                    ignoreSetState = true;
                                }
                            }
                        );

                        if (updatedControlStateIds.length > 1) {
                            // Each hook modify its own state, and it should not leak
                            // Events are here to forward to other hooks and apply changes.
                            // You are trying to update several states in a no isolated way.
                            throw new Error(
                                `You're not allowed to update several sub-state in one transaction. You already updated ${
                                    updatedControlStateIds[0].stateId
                                }, therefore, you're not allowed to update ${updatedControlStateIds
                                    .map((el) => el.stateId)
                                    .join(", ")} in the same transaction.`
                            );
                        }

                        if (!ignoreSetState) {
                            // We always assign it as we mutate rows for perf reason.
                            apiRef.current.state = newState;

                            if (apiRef.current.publishEvent) {
                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.stateChange */.t
                                        .stateChange,
                                    newState
                                );
                            }
                        }

                        if (updatedControlStateIds.length === 1) {
                            const { stateId, hasPropChanged } =
                                updatedControlStateIds[0];
                            const controlState =
                                controlStateMapRef.current[stateId];
                            const model = controlState.stateSelector(
                                newState,
                                apiRef.current.instanceId
                            );

                            if (controlState.propOnChange && hasPropChanged) {
                                const details =
                                    props.signature ===
                                    GridSignature.DataGridPro
                                        ? {
                                              api: apiRef.current,
                                          }
                                        : {};
                                controlState.propOnChange(model, details);
                            }

                            if (!ignoreSetState) {
                                apiRef.current.publishEvent(
                                    controlState.changeEvent,
                                    model
                                );
                            }
                        }

                        return !ignoreSetState;
                    },
                    [apiRef, props.signature]
                );
                const forceUpdate = react.useCallback(
                    () => rawForceUpdate(() => apiRef.current.state),
                    [apiRef]
                );
                const stateApi = {
                    setState,
                    forceUpdate,
                    unstable_updateControlState: updateControlState,
                };
                useGridApiMethod(apiRef, stateApi, "GridStateApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/useGridInitialization.js
            /**
             * Initialize the technical pieces of the DataGrid (logger, state, ...) that any DataGrid implementation needs
             */

            const useGridInitialization = (inputApiRef, props) => {
                const apiRef = useGridApiInitialization(inputApiRef, props);
                useGridLoggerFactory(apiRef, props);
                useGridErrorHandler(apiRef, props);
                useGridStateInitialization(apiRef, props);
                useGridPipeProcessing(apiRef);
                useGridStrategyProcessing(apiRef);
                useGridLocaleText(apiRef, props);
                return apiRef;
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridInitializeState.js
            const useGridInitializeState = (initializer, apiRef, props) => {
                const isInitialized = react.useRef(false);

                if (!isInitialized.current) {
                    apiRef.current.state = initializer(
                        apiRef.current.state,
                        props,
                        apiRef
                    );
                    isInitialized.current = true;
                }
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridNativeEventListener.js
            const useGridNativeEventListener = (
                apiRef,
                ref,
                eventName,
                handler,
                options
            ) => {
                const logger = useGridLogger(apiRef, "useNativeEventListener");
                const [added, setAdded] = react.useState(false);
                const handlerRef = react.useRef(handler);
                const wrapHandler = react.useCallback((args) => {
                    return handlerRef.current && handlerRef.current(args);
                }, []);
                react.useEffect(() => {
                    handlerRef.current = handler;
                }, [handler]);
                react.useEffect(() => {
                    let targetElement;

                    if (isFunction(ref)) {
                        targetElement = ref();
                    } else {
                        targetElement = ref && ref.current ? ref.current : null;
                    }

                    if (targetElement && wrapHandler && eventName && !added) {
                        logger.debug(`Binding native ${eventName} event`);
                        targetElement.addEventListener(
                            eventName,
                            wrapHandler,
                            options
                        );
                        const boundElem = targetElement;
                        setAdded(true);

                        const unsubscribe = () => {
                            logger.debug(`Clearing native ${eventName} event`);
                            boundElem.removeEventListener(
                                eventName,
                                wrapHandler,
                                options
                            );
                        };

                        apiRef.current.subscribeEvent(
                            gridEvents /* GridEvents.unmount */.t.unmount,
                            unsubscribe
                        );
                    }
                }, [
                    ref,
                    wrapHandler,
                    eventName,
                    added,
                    logger,
                    options,
                    apiRef,
                ]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/clipboard/useGridClipboard.js
            function writeToClipboardPolyfill(data) {
                const span = document.createElement("span");
                span.style.whiteSpace = "pre";
                span.style.userSelect = "all";
                span.style.opacity = "0px";
                span.textContent = data;
                document.body.appendChild(span);
                const range = document.createRange();
                range.selectNode(span);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                try {
                    document.execCommand("copy");
                } finally {
                    document.body.removeChild(span);
                }
            }
            /**
             * @requires useGridCsvExport (method)
             * @requires useGridSelection (method)
             */

            const useGridClipboard = (apiRef) => {
                const copySelectedRowsToClipboard = react.useCallback(
                    (includeHeaders = false) => {
                        if (apiRef.current.getSelectedRows().size === 0) {
                            return;
                        }

                        const data = apiRef.current.getDataAsCsv({
                            includeHeaders,
                            delimiter: "\t",
                        });

                        if (navigator.clipboard) {
                            navigator.clipboard.writeText(data).catch(() => {
                                writeToClipboardPolyfill(data);
                            });
                        } else {
                            writeToClipboardPolyfill(data);
                        }
                    },
                    [apiRef]
                );
                const handleKeydown = react.useCallback(
                    (event) => {
                        var _window$getSelection;

                        const isModifierKeyPressed =
                            event.ctrlKey || event.metaKey || event.altKey; // event.key === 'c' is not enough as alt+c can lead to , , or other characters on macOS.
                        // event.code === 'KeyC' is not enough as event.code assume a QWERTY keyboard layout which would
                        // be wrong with a Dvorak keyboard (as if pressing J).

                        if (
                            String.fromCharCode(event.keyCode) !== "C" ||
                            !isModifierKeyPressed
                        ) {
                            return;
                        } // Do nothing if there's a native selection

                        if (
                            ((_window$getSelection = window.getSelection()) ==
                            null
                                ? void 0
                                : _window$getSelection.toString()) !== ""
                        ) {
                            return;
                        }

                        apiRef.current.unstable_copySelectedRowsToClipboard(
                            event.altKey
                        );
                    },
                    [apiRef]
                );
                useGridNativeEventListener(
                    apiRef,
                    apiRef.current.rootElementRef,
                    "keydown",
                    handleKeydown
                );
                const clipboardApi = {
                    unstable_copySelectedRowsToClipboard:
                        copySelectedRowsToClipboard,
                };
                useGridApiMethod(apiRef, clipboardApi, "GridClipboardApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/columnMenu/columnMenuSelector.js
            const gridColumnMenuSelector = (state) => state.columnMenu; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/columnMenu/useGridColumnMenu.js
            const columnMenuStateInitializer = (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    columnMenu: {
                        open: false,
                    },
                });
            /**
             * @requires useGridColumnResize (event)
             * @requires useGridInfiniteLoader (event)
             */

            const useGridColumnMenu = (apiRef) => {
                const logger = useGridLogger(apiRef, "useGridColumnMenu");
                /**
                 * API METHODS
                 */

                const showColumnMenu = react.useCallback(
                    (field) => {
                        const shouldUpdate = apiRef.current.setState(
                            (state) => {
                                if (
                                    state.columnMenu.open &&
                                    state.columnMenu.field === field
                                ) {
                                    return state;
                                }

                                logger.debug("Opening Column Menu");
                                return (0, esm_extends /* default */.Z)(
                                    {},
                                    state,
                                    {
                                        columnMenu: {
                                            open: true,
                                            field,
                                        },
                                    }
                                );
                            }
                        );

                        if (shouldUpdate) {
                            apiRef.current.hidePreferences();
                            apiRef.current.forceUpdate();
                        }
                    },
                    [apiRef, logger]
                );
                const hideColumnMenu = react.useCallback(() => {
                    const shouldUpdate = apiRef.current.setState((state) => {
                        if (
                            !state.columnMenu.open &&
                            state.columnMenu.field === undefined
                        ) {
                            return state;
                        }

                        logger.debug("Hiding Column Menu");
                        return (0, esm_extends /* default */.Z)({}, state, {
                            columnMenu: (0, esm_extends /* default */.Z)(
                                {},
                                state.columnMenu,
                                {
                                    open: false,
                                    field: undefined,
                                }
                            ),
                        });
                    });

                    if (shouldUpdate) {
                        apiRef.current.forceUpdate();
                    }
                }, [apiRef, logger]);
                const toggleColumnMenu = react.useCallback(
                    (field) => {
                        logger.debug("Toggle Column Menu");
                        const columnMenu = gridColumnMenuSelector(
                            apiRef.current.state
                        );

                        if (!columnMenu.open || columnMenu.field !== field) {
                            showColumnMenu(field);
                        } else {
                            hideColumnMenu();
                        }
                    },
                    [apiRef, logger, showColumnMenu, hideColumnMenu]
                );
                const columnMenuApi = {
                    showColumnMenu,
                    hideColumnMenu,
                    toggleColumnMenu,
                };
                useGridApiMethod(apiRef, columnMenuApi, "GridColumnMenuApi");
                /**
                 * EVENTS
                 */

                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnResizeStart */.t
                        .columnResizeStart,
                    hideColumnMenu
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.virtualScrollerWheel */.t
                        .virtualScrollerWheel,
                    apiRef.current.hideColumnMenu
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.virtualScrollerTouchMove */.t
                        .virtualScrollerTouchMove,
                    apiRef.current.hideColumnMenu
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useFirstRender.js
            const useFirstRender = (callback) => {
                const isFirstRender = react.useRef(true);

                if (isFirstRender.current) {
                    isFirstRender.current = false;
                    callback();
                }
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/pipeProcessing/useGridRegisterPipeProcessor.js
            const useGridRegisterPipeProcessor = (apiRef, group, callback) => {
                const cleanup = react.useRef();
                const id = react.useRef(
                    `mui-${Math.round(Math.random() * 1e9)}`
                );
                const registerPreProcessor = react.useCallback(() => {
                    cleanup.current =
                        apiRef.current.unstable_registerPipeProcessor(
                            group,
                            id.current,
                            callback
                        );
                }, [apiRef, callback, group]);
                useFirstRender(() => {
                    registerPreProcessor();
                });
                const isFirstRender = react.useRef(true);
                react.useEffect(() => {
                    if (isFirstRender.current) {
                        isFirstRender.current = false;
                    } else {
                        registerPreProcessor();
                    }

                    return () => {
                        if (cleanup.current) {
                            cleanup.current();
                            cleanup.current = null;
                        }
                    };
                }, [registerPreProcessor]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/pipeProcessing/useGridRegisterPipeApplier.js
            const useGridRegisterPipeApplier = (apiRef, group, callback) => {
                const cleanup = react.useRef();
                const id = react.useRef(
                    `mui-${Math.round(Math.random() * 1e9)}`
                );
                const registerPreProcessor = react.useCallback(() => {
                    cleanup.current =
                        apiRef.current.unstable_registerPipeApplier(
                            group,
                            id.current,
                            callback
                        );
                }, [apiRef, callback, group]);
                useFirstRender(() => {
                    registerPreProcessor();
                });
                const isFirstRender = react.useRef(true);
                react.useEffect(() => {
                    if (isFirstRender.current) {
                        isFirstRender.current = false;
                    } else {
                        registerPreProcessor();
                    }

                    return () => {
                        if (cleanup.current) {
                            cleanup.current();
                            cleanup.current = null;
                        }
                    };
                }, [registerPreProcessor]);
            };
            // EXTERNAL MODULE: ./node_modules/@mui/material/InputBase/InputBase.js + 3 modules
            var InputBase = __webpack_require__(787);
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/createSvgIcon.js + 2 modules
            var createSvgIcon = __webpack_require__(8169); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/icons/index.js
            const GridArrowUpwardIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z",
                }),
                "ArrowUpward"
            );
            const GridArrowDownwardIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z",
                }),
                "ArrowDownward"
            );
            const GridKeyboardArrowRight = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z",
                }),
                "KeyboardArrowRight"
            );
            const GridExpandMoreIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z",
                }),
                "ExpandMore"
            );
            const GridFilterListIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",
                }),
                "FilterList"
            );
            const GridFilterAltIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61z",
                }),
                "FilterAlt"
            );
            const GridSearchIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z",
                }),
                "Search"
            );
            const GridMenuIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z",
                }),
                "Menu"
            );
            const GridCheckCircleIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z",
                }),
                "CheckCircle"
            );
            const GridColumnIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z",
                }),
                "ColumnIcon"
            );
            const GridSeparatorIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M11 19V5h2v14z",
                }),
                "Separator"
            );
            const GridViewHeadlineIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z",
                }),
                "ViewHeadline"
            );
            const GridTableRowsIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M21,8H3V4h18V8z M21,10H3v4h18V10z M21,16H3v4h18V16z",
                }),
                "TableRows"
            );
            const GridViewStreamIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M4 18h17v-6H4v6zM4 5v6h17V5H4z",
                }),
                "ViewStream"
            );
            const GridTripleDotsVerticalIcon = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z",
                }),
                "TripleDotsVertical"
            );
            const GridCloseIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
                }),
                "Close"
            );
            const GridAddIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z",
                }),
                "Add"
            );
            const GridRemoveIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M19 13H5v-2h14v2z",
                }),
                "Remove"
            );
            const GridLoadIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z",
                }),
                "Load"
            );
            const GridDragIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z",
                }),
                "Drag"
            );
            const GridSaveAltIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z",
                }),
                "SaveAlt"
            );
            const GridCheckIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z",
                }),
                "Check"
            );
            const GridMoreVertIcon = (0, createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z",
                }),
                "MoreVert"
            );
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/useId.js
            var useId = __webpack_require__(7909);
            // EXTERNAL MODULE: ./node_modules/@mui/material/MenuItem/MenuItem.js + 2 modules
            var MenuItem = __webpack_require__(4178); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/filterPanelUtils.js
            function getValueFromOption(option) {
                if (typeof option === "object" && option !== null) {
                    return option.value;
                }

                return option;
            }
            function getValueFromValueOptions(value, valueOptions) {
                if (valueOptions === undefined) {
                    return undefined;
                }

                const result = valueOptions.find((option) => {
                    const optionValue = getValueFromOption(option);
                    return String(optionValue) === String(value);
                });
                return getValueFromOption(result);
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterInputValue.js
            const GridFilterInputValue_excluded = [
                "item",
                "applyValue",
                "type",
                "apiRef",
                "focusElementRef",
            ];

            const warnedOnce = {};

            function warnDeprecatedTypeSupport(type) {
                console.warn(
                    [
                        `MUI: Using GridFilterInputValue with a "${type}" column is deprecated.`,
                        "Use GridFilterInputSingleSelect instead.",
                    ].join("\n")
                );
                warnedOnce[type] = true;
            }

            const renderSingleSelectOptions = (
                { valueOptions, valueFormatter, field },
                api,
                OptionComponent
            ) => {
                const iterableColumnValues =
                    typeof valueOptions === "function"
                        ? [
                              "",
                              ...valueOptions({
                                  field,
                              }),
                          ]
                        : ["", ...(valueOptions || [])];
                return iterableColumnValues.map((option) => {
                    const isOptionTypeObject = typeof option === "object";
                    const key = isOptionTypeObject ? option.value : option;
                    const value = isOptionTypeObject ? option.value : option;
                    const formattedValue =
                        valueFormatter && option !== ""
                            ? valueFormatter({
                                  value: option,
                                  field,
                                  api,
                              })
                            : option;
                    const content = isOptionTypeObject
                        ? option.label
                        : formattedValue;
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        OptionComponent,
                        {
                            value: value,
                            children: content,
                        },
                        key
                    );
                });
            };

            const SUBMIT_FILTER_STROKE_TIME = 500;

            function GridFilterInputValue(props) {
                var _item$value,
                    _rootProps$components,
                    _baseSelectProps$nati,
                    _rootProps$components2,
                    _rootProps$components3;

                const { item, applyValue, type, apiRef, focusElementRef } =
                        props,
                    others = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridFilterInputValue_excluded
                    );

                if (false) {
                }

                const filterTimeout = react.useRef();
                const [filterValueState, setFilterValueState] = react.useState(
                    (_item$value = item.value) != null ? _item$value : ""
                );
                const [applying, setIsApplying] = react.useState(false);
                const id = (0, useId /* default */.Z)();
                const rootProps = useGridRootProps();
                const baseSelectProps =
                    ((_rootProps$components = rootProps.componentsProps) == null
                        ? void 0
                        : _rootProps$components.baseSelect) || {};
                const isSelectNative =
                    (_baseSelectProps$nati = baseSelectProps.native) != null
                        ? _baseSelectProps$nati
                        : true;
                const singleSelectProps =
                    type === "singleSelect"
                        ? {
                              select: true,
                              SelectProps: (0, esm_extends /* default */.Z)(
                                  {
                                      native: isSelectNative,
                                  },
                                  (_rootProps$components2 =
                                      rootProps.componentsProps) == null
                                      ? void 0
                                      : _rootProps$components2.baseSelect
                              ),
                              children: renderSingleSelectOptions(
                                  apiRef.current.getColumn(item.columnField),
                                  apiRef.current,
                                  isSelectNative
                                      ? "option"
                                      : MenuItem /* default */.Z
                              ),
                          }
                        : {};
                const onFilterChange = react.useCallback(
                    (event) => {
                        let value = event.target.value; // NativeSelect casts the value to a string.

                        if (type === "singleSelect") {
                            const column = apiRef.current.getColumn(
                                item.columnField
                            );
                            const columnValueOptions =
                                typeof column.valueOptions === "function"
                                    ? column.valueOptions({
                                          field: column.field,
                                      })
                                    : column.valueOptions;
                            value = getValueFromValueOptions(
                                value,
                                columnValueOptions
                            );
                        }

                        clearTimeout(filterTimeout.current);
                        setFilterValueState(String(value));
                        setIsApplying(true); // TODO singleSelect doesn't debounce

                        filterTimeout.current = setTimeout(() => {
                            applyValue(
                                (0, esm_extends /* default */.Z)({}, item, {
                                    value,
                                })
                            );
                            setIsApplying(false);
                        }, SUBMIT_FILTER_STROKE_TIME);
                    },
                    [apiRef, applyValue, item, type]
                );
                react.useEffect(() => {
                    return () => {
                        clearTimeout(filterTimeout.current);
                    };
                }, []);
                react.useEffect(() => {
                    var _item$value2;

                    const itemValue =
                        (_item$value2 = item.value) != null ? _item$value2 : "";
                    setFilterValueState(String(itemValue));
                }, [item.value]);
                const InputProps = applying
                    ? {
                          endAdornment: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                              GridLoadIcon,
                              {}
                          ),
                      }
                    : others.InputProps;
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    rootProps.components.BaseTextField,
                    (0, esm_extends /* default */.Z)(
                        {
                            id: id,
                            label: apiRef.current.getLocaleText(
                                "filterPanelInputLabel"
                            ),
                            placeholder: apiRef.current.getLocaleText(
                                "filterPanelInputPlaceholder"
                            ),
                            value: filterValueState,
                            onChange: onFilterChange,
                            type: type || "text",
                            variant: "standard",
                            InputProps: InputProps,
                            InputLabelProps: {
                                shrink: true,
                            },
                            inputRef: focusElementRef,
                        },
                        singleSelectProps,
                        others,
                        (_rootProps$components3 = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components3.baseTextField
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/cell/GridEditInputCell.js

            const GridEditInputCell_excluded = [
                "id",
                "value",
                "formattedValue",
                "api",
                "field",
                "row",
                "rowNode",
                "colDef",
                "cellMode",
                "isEditable",
                "tabIndex",
                "hasFocus",
                "getValue",
                "isValidating",
                "debounceMs",
                "isProcessingProps",
            ];

            const GridEditInputCell_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["editInputCell"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridEditInputCellRoot = (0, styled /* default */.ZP)(
                InputBase /* default */.ZP,
                {
                    name: "MuiDataGrid",
                    slot: "EditInputCell",
                    overridesResolver: (props, styles) => styles.editInputCell,
                }
            )(({ theme }) =>
                (0, esm_extends /* default */.Z)({}, theme.typography.body2, {
                    padding: "1px 0",
                    "& input": {
                        padding: "0 16px",
                        height: "100%",
                    },
                })
            );

            function GridEditInputCell(props) {
                var _rootProps$experiment;

                const rootProps = useGridRootProps();

                const {
                        id,
                        value,
                        api,
                        field,
                        colDef,
                        hasFocus,
                        debounceMs = (_rootProps$experiment =
                            rootProps.experimentalFeatures) != null &&
                        _rootProps$experiment.newEditingApi
                            ? 200
                            : SUBMIT_FILTER_STROKE_TIME,
                        isProcessingProps,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridEditInputCell_excluded
                    );

                const inputRef = react.useRef();
                const [valueState, setValueState] = react.useState(value);
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridEditInputCell_useUtilityClasses(ownerState);
                const handleChange = react.useCallback(
                    (event) => {
                        const newValue = event.target.value;
                        setValueState(newValue);
                        api.setEditCellValue(
                            {
                                id,
                                field,
                                value: newValue,
                                debounceMs,
                            },
                            event
                        );
                    },
                    [api, debounceMs, field, id]
                );
                react.useEffect(() => {
                    setValueState(value);
                }, [value]);
                (0, useEnhancedEffect /* default */.Z)(() => {
                    if (hasFocus) {
                        inputRef.current.focus();
                    }
                }, [hasFocus]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridEditInputCellRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            inputRef: inputRef,
                            className: classes.root,
                            fullWidth: true,
                            type:
                                colDef.type === "number" ? colDef.type : "text",
                            value: valueState != null ? valueState : "",
                            onChange: handleChange,
                            endAdornment: isProcessingProps
                                ? /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                      GridLoadIcon,
                                      {}
                                  )
                                : undefined,
                        },
                        other
                    )
                );
            }

            false ? 0 : void 0;

            const renderEditInputCell = (params) =>
                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridEditInputCell,
                    (0, esm_extends /* default */.Z)({}, params)
                );
            // EXTERNAL MODULE: ./node_modules/@mui/x-data-grid/hooks/features/sorting/gridSortingUtils.js
            var gridSortingUtils = __webpack_require__(9588);
            // EXTERNAL MODULE: ./node_modules/@mui/material/Autocomplete/Autocomplete.js + 3 modules
            var Autocomplete = __webpack_require__(9890);
            // EXTERNAL MODULE: ./node_modules/@mui/material/Chip/Chip.js + 2 modules
            var Chip = __webpack_require__(7918);
            // EXTERNAL MODULE: ./node_modules/@mui/utils/esm/useId.js
            var esm_useId = __webpack_require__(7579);
            // EXTERNAL MODULE: ./node_modules/@mui/material/styles/useThemeProps.js + 2 modules
            var useThemeProps = __webpack_require__(7623);
            // EXTERNAL MODULE: ./node_modules/@mui/material/Input/Input.js
            var Input = __webpack_require__(9332);
            // EXTERNAL MODULE: ./node_modules/@mui/material/FilledInput/FilledInput.js
            var FilledInput = __webpack_require__(6135);
            // EXTERNAL MODULE: ./node_modules/@mui/material/OutlinedInput/OutlinedInput.js + 1 modules
            var OutlinedInput = __webpack_require__(7709);
            // EXTERNAL MODULE: ./node_modules/@mui/material/FormControl/formControlState.js
            var formControlState = __webpack_require__(5704);
            // EXTERNAL MODULE: ./node_modules/@mui/material/FormControl/useFormControl.js
            var useFormControl = __webpack_require__(4423);
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/capitalize.js
            var capitalize = __webpack_require__(8216); // CONCATENATED MODULE: ./node_modules/@mui/material/FormLabel/formLabelClasses.js
            function getFormLabelUtilityClasses(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiFormLabel",
                    slot
                );
            }
            const formLabelClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiFormLabel", [
                "root",
                "colorSecondary",
                "focused",
                "disabled",
                "error",
                "filled",
                "required",
                "asterisk",
            ]);
            /* harmony default export */ var FormLabel_formLabelClasses =
                formLabelClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/FormLabel/FormLabel.js
            const FormLabel_excluded = [
                "children",
                "className",
                "color",
                "component",
                "disabled",
                "error",
                "filled",
                "focused",
                "required",
            ];

            const FormLabel_useUtilityClasses = (ownerState) => {
                const {
                    classes,
                    color,
                    focused,
                    disabled,
                    error,
                    filled,
                    required,
                } = ownerState;
                const slots = {
                    root: [
                        "root",
                        `color${(0, capitalize /* default */.Z)(color)}`,
                        disabled && "disabled",
                        error && "error",
                        filled && "filled",
                        focused && "focused",
                        required && "required",
                    ],
                    asterisk: ["asterisk", error && "error"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getFormLabelUtilityClasses,
                    classes
                );
            };

            const FormLabelRoot = (0, styled /* default */.ZP)("label", {
                name: "MuiFormLabel",
                slot: "Root",
                overridesResolver: ({ ownerState }, styles) => {
                    return (0, esm_extends /* default */.Z)(
                        {},
                        styles.root,
                        ownerState.color === "secondary" &&
                            styles.colorSecondary,
                        ownerState.filled && styles.filled
                    );
                },
            })(({ theme, ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        color: theme.palette.text.secondary,
                    },
                    theme.typography.body1,
                    {
                        lineHeight: "1.4375em",
                        padding: 0,
                        position: "relative",
                        [`&.${FormLabel_formLabelClasses.focused}`]: {
                            color: theme.palette[ownerState.color].main,
                        },
                        [`&.${FormLabel_formLabelClasses.disabled}`]: {
                            color: theme.palette.text.disabled,
                        },
                        [`&.${FormLabel_formLabelClasses.error}`]: {
                            color: theme.palette.error.main,
                        },
                    }
                )
            );
            const AsteriskComponent = (0, styled /* default */.ZP)("span", {
                name: "MuiFormLabel",
                slot: "Asterisk",
                overridesResolver: (props, styles) => styles.asterisk,
            })(({ theme }) => ({
                [`&.${FormLabel_formLabelClasses.error}`]: {
                    color: theme.palette.error.main,
                },
            }));
            const FormLabel = /*#__PURE__*/ react.forwardRef(function FormLabel(
                inProps,
                ref
            ) {
                const props = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiFormLabel",
                });

                const { children, className, component = "label" } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        FormLabel_excluded
                    );

                const muiFormControl = (0, useFormControl /* default */.Z)();
                const fcs = (0, formControlState /* default */.Z)({
                    props,
                    muiFormControl,
                    states: [
                        "color",
                        "required",
                        "focused",
                        "disabled",
                        "error",
                        "filled",
                    ],
                });

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    color: fcs.color || "primary",
                    component,
                    disabled: fcs.disabled,
                    error: fcs.error,
                    filled: fcs.filled,
                    focused: fcs.focused,
                    required: fcs.required,
                });

                const classes = FormLabel_useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    FormLabelRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            as: component,
                            ownerState: ownerState,
                            className: (0, clsx_m /* default */.Z)(
                                classes.root,
                                className
                            ),
                            ref: ref,
                        },
                        other,
                        {
                            children: [
                                children,
                                fcs.required &&
                                    /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                                        AsteriskComponent,
                                        {
                                            ownerState: ownerState,
                                            "aria-hidden": true,
                                            className: classes.asterisk,
                                            children: ["\u2009", "*"],
                                        }
                                    ),
                            ],
                        }
                    )
                );
            });
            false ? 0 : void 0;
            /* harmony default export */ var FormLabel_FormLabel = FormLabel; // CONCATENATED MODULE: ./node_modules/@mui/material/InputLabel/inputLabelClasses.js
            function getInputLabelUtilityClasses(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiInputLabel",
                    slot
                );
            }
            const inputLabelClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiInputLabel", [
                "root",
                "focused",
                "disabled",
                "error",
                "required",
                "asterisk",
                "formControl",
                "sizeSmall",
                "shrink",
                "animated",
                "standard",
                "filled",
                "outlined",
            ]);
            /* harmony default export */ var InputLabel_inputLabelClasses =
                /* unused pure expression or super */ null && inputLabelClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/InputLabel/InputLabel.js
            const InputLabel_excluded = [
                "disableAnimation",
                "margin",
                "shrink",
                "variant",
            ];

            const InputLabel_useUtilityClasses = (ownerState) => {
                const {
                    classes,
                    formControl,
                    size,
                    shrink,
                    disableAnimation,
                    variant,
                    required,
                } = ownerState;
                const slots = {
                    root: [
                        "root",
                        formControl && "formControl",
                        !disableAnimation && "animated",
                        shrink && "shrink",
                        size === "small" && "sizeSmall",
                        variant,
                    ],
                    asterisk: [required && "asterisk"],
                };
                const composedClasses = (0, composeClasses /* default */.Z)(
                    slots,
                    getInputLabelUtilityClasses,
                    classes
                );
                return (0, esm_extends /* default */.Z)(
                    {},
                    classes,
                    composedClasses
                );
            };

            const InputLabelRoot = (0, styled /* default */.ZP)(
                FormLabel_FormLabel,
                {
                    shouldForwardProp: (prop) =>
                        (0, styled /* rootShouldForwardProp */.FO)(prop) ||
                        prop === "classes",
                    name: "MuiInputLabel",
                    slot: "Root",
                    overridesResolver: (props, styles) => {
                        const { ownerState } = props;
                        return [
                            {
                                [`& .${FormLabel_formLabelClasses.asterisk}`]:
                                    styles.asterisk,
                            },
                            styles.root,
                            ownerState.formControl && styles.formControl,
                            ownerState.size === "small" && styles.sizeSmall,
                            ownerState.shrink && styles.shrink,
                            !ownerState.disableAnimation && styles.animated,
                            styles[ownerState.variant],
                        ];
                    },
                }
            )(({ theme, ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        display: "block",
                        transformOrigin: "top left",
                        whiteSpace: "nowrap",
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        maxWidth: "100%",
                    },
                    ownerState.formControl && {
                        position: "absolute",
                        left: 0,
                        top: 0,
                        // slight alteration to spec spacing to match visual spec result
                        transform: "translate(0, 20px) scale(1)",
                    },
                    ownerState.size === "small" && {
                        // Compensation for the `Input.inputSizeSmall` style.
                        transform: "translate(0, 17px) scale(1)",
                    },
                    ownerState.shrink && {
                        transform: "translate(0, -1.5px) scale(0.75)",
                        transformOrigin: "top left",
                        maxWidth: "133%",
                    },
                    !ownerState.disableAnimation && {
                        transition: theme.transitions.create(
                            ["color", "transform", "max-width"],
                            {
                                duration: theme.transitions.duration.shorter,
                                easing: theme.transitions.easing.easeOut,
                            }
                        ),
                    },
                    ownerState.variant === "filled" &&
                        (0, esm_extends /* default */.Z)(
                            {
                                // Chrome's autofill feature gives the input field a yellow background.
                                // Since the input field is behind the label in the HTML tree,
                                // the input field is drawn last and hides the label with an opaque background color.
                                // zIndex: 1 will raise the label above opaque background-colors of input.
                                zIndex: 1,
                                pointerEvents: "none",
                                transform: "translate(12px, 16px) scale(1)",
                                maxWidth: "calc(100% - 24px)",
                            },
                            ownerState.size === "small" && {
                                transform: "translate(12px, 13px) scale(1)",
                            },
                            ownerState.shrink &&
                                (0, esm_extends /* default */.Z)(
                                    {
                                        userSelect: "none",
                                        pointerEvents: "auto",
                                        transform:
                                            "translate(12px, 7px) scale(0.75)",
                                        maxWidth: "calc(133% - 24px)",
                                    },
                                    ownerState.size === "small" && {
                                        transform:
                                            "translate(12px, 4px) scale(0.75)",
                                    }
                                )
                        ),
                    ownerState.variant === "outlined" &&
                        (0, esm_extends /* default */.Z)(
                            {
                                // see comment above on filled.zIndex
                                zIndex: 1,
                                pointerEvents: "none",
                                transform: "translate(14px, 16px) scale(1)",
                                maxWidth: "calc(100% - 24px)",
                            },
                            ownerState.size === "small" && {
                                transform: "translate(14px, 9px) scale(1)",
                            },
                            ownerState.shrink && {
                                userSelect: "none",
                                pointerEvents: "auto",
                                maxWidth: "calc(133% - 24px)",
                                transform: "translate(14px, -9px) scale(0.75)",
                            }
                        )
                )
            );
            const InputLabel = /*#__PURE__*/ react.forwardRef(
                function InputLabel(inProps, ref) {
                    const props = (0, useThemeProps /* default */.Z)({
                        name: "MuiInputLabel",
                        props: inProps,
                    });

                    const { disableAnimation = false, shrink: shrinkProp } =
                            props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            InputLabel_excluded
                        );

                    const muiFormControl = (0,
                    useFormControl /* default */.Z)();
                    let shrink = shrinkProp;

                    if (typeof shrink === "undefined" && muiFormControl) {
                        shrink =
                            muiFormControl.filled ||
                            muiFormControl.focused ||
                            muiFormControl.adornedStart;
                    }

                    const fcs = (0, formControlState /* default */.Z)({
                        props,
                        muiFormControl,
                        states: ["size", "variant", "required"],
                    });

                    const ownerState = (0, esm_extends /* default */.Z)(
                        {},
                        props,
                        {
                            disableAnimation,
                            formControl: muiFormControl,
                            shrink,
                            size: fcs.size,
                            variant: fcs.variant,
                            required: fcs.required,
                        }
                    );

                    const classes = InputLabel_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        InputLabelRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                "data-shrink": shrink,
                                ownerState: ownerState,
                                ref: ref,
                            },
                            other,
                            {
                                classes: classes,
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var InputLabel_InputLabel = InputLabel;
            // EXTERNAL MODULE: ./node_modules/@mui/material/InputBase/utils.js
            var utils = __webpack_require__(5108);
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/isMuiElement.js + 1 modules
            var isMuiElement = __webpack_require__(1579);
            // EXTERNAL MODULE: ./node_modules/@mui/material/FormControl/FormControlContext.js
            var FormControlContext = __webpack_require__(7167); // CONCATENATED MODULE: ./node_modules/@mui/material/FormControl/formControlClasses.js
            function getFormControlUtilityClasses(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiFormControl",
                    slot
                );
            }
            const formControlClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiFormControl", [
                "root",
                "marginNone",
                "marginNormal",
                "marginDense",
                "fullWidth",
                "disabled",
            ]);
            /* harmony default export */ var FormControl_formControlClasses =
                /* unused pure expression or super */ null &&
                formControlClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/FormControl/FormControl.js
            const FormControl_excluded = [
                "children",
                "className",
                "color",
                "component",
                "disabled",
                "error",
                "focused",
                "fullWidth",
                "hiddenLabel",
                "margin",
                "required",
                "size",
                "variant",
            ];

            const FormControl_useUtilityClasses = (ownerState) => {
                const { classes, margin, fullWidth } = ownerState;
                const slots = {
                    root: [
                        "root",
                        margin !== "none" &&
                            `margin${(0, capitalize /* default */.Z)(margin)}`,
                        fullWidth && "fullWidth",
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getFormControlUtilityClasses,
                    classes
                );
            };

            const FormControlRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiFormControl",
                slot: "Root",
                overridesResolver: ({ ownerState }, styles) => {
                    return (0, esm_extends /* default */.Z)(
                        {},
                        styles.root,
                        styles[
                            `margin${(0, capitalize /* default */.Z)(
                                ownerState.margin
                            )}`
                        ],
                        ownerState.fullWidth && styles.fullWidth
                    );
                },
            })(({ ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        display: "inline-flex",
                        flexDirection: "column",
                        position: "relative",
                        // Reset fieldset default style.
                        minWidth: 0,
                        padding: 0,
                        margin: 0,
                        border: 0,
                        verticalAlign: "top",
                    },
                    ownerState.margin === "normal" && {
                        marginTop: 16,
                        marginBottom: 8,
                    },
                    ownerState.margin === "dense" && {
                        marginTop: 8,
                        marginBottom: 4,
                    },
                    ownerState.fullWidth && {
                        width: "100%",
                    }
                )
            );
            /**
             * Provides context such as filled/focused/error/required for form inputs.
             * Relying on the context provides high flexibility and ensures that the state always stays
             * consistent across the children of the `FormControl`.
             * This context is used by the following components:
             *
             *  - FormLabel
             *  - FormHelperText
             *  - Input
             *  - InputLabel
             *
             * You can find one composition example below and more going to [the demos](/material-ui/react-text-field/#components).
             *
             * ```jsx
             * <FormControl>
             *   <InputLabel htmlFor="my-input">Email address</InputLabel>
             *   <Input id="my-input" aria-describedby="my-helper-text" />
             *   <FormHelperText id="my-helper-text">We'll never share your email.</FormHelperText>
             * </FormControl>
             * ```
             *
             *  Only one `InputBase` can be used within a FormControl because it create visual inconsistencies.
             * For instance, only one input can be focused at the same time, the state shouldn't be shared.
             */

            const FormControl = /*#__PURE__*/ react.forwardRef(
                function FormControl(inProps, ref) {
                    const props = (0, useThemeProps /* default */.Z)({
                        props: inProps,
                        name: "MuiFormControl",
                    });

                    const {
                            children,
                            className,
                            color = "primary",
                            component = "div",
                            disabled = false,
                            error = false,
                            focused: visuallyFocused,
                            fullWidth = false,
                            hiddenLabel = false,
                            margin = "none",
                            required = false,
                            size = "medium",
                            variant = "outlined",
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            FormControl_excluded
                        );

                    const ownerState = (0, esm_extends /* default */.Z)(
                        {},
                        props,
                        {
                            color,
                            component,
                            disabled,
                            error,
                            fullWidth,
                            hiddenLabel,
                            margin,
                            required,
                            size,
                            variant,
                        }
                    );

                    const classes = FormControl_useUtilityClasses(ownerState);
                    const [adornedStart, setAdornedStart] = react.useState(
                        () => {
                            // We need to iterate through the children and find the Input in order
                            // to fully support server-side rendering.
                            let initialAdornedStart = false;

                            if (children) {
                                react.Children.forEach(children, (child) => {
                                    if (
                                        !(0, isMuiElement /* default */.Z)(
                                            child,
                                            ["Input", "Select"]
                                        )
                                    ) {
                                        return;
                                    }

                                    const input = (0,
                                    isMuiElement /* default */.Z)(child, [
                                        "Select",
                                    ])
                                        ? child.props.input
                                        : child;

                                    if (
                                        input &&
                                        (0, utils /* isAdornedStart */.B7)(
                                            input.props
                                        )
                                    ) {
                                        initialAdornedStart = true;
                                    }
                                });
                            }

                            return initialAdornedStart;
                        }
                    );
                    const [filled, setFilled] = react.useState(() => {
                        // We need to iterate through the children and find the Input in order
                        // to fully support server-side rendering.
                        let initialFilled = false;

                        if (children) {
                            react.Children.forEach(children, (child) => {
                                if (
                                    !(0, isMuiElement /* default */.Z)(child, [
                                        "Input",
                                        "Select",
                                    ])
                                ) {
                                    return;
                                }

                                if (
                                    (0, utils /* isFilled */.vd)(
                                        child.props,
                                        true
                                    )
                                ) {
                                    initialFilled = true;
                                }
                            });
                        }

                        return initialFilled;
                    });
                    const [focusedState, setFocused] = react.useState(false);

                    if (disabled && focusedState) {
                        setFocused(false);
                    }

                    const focused =
                        visuallyFocused !== undefined && !disabled
                            ? visuallyFocused
                            : focusedState;
                    let registerEffect;

                    if (false) {
                    }

                    const onFilled = react.useCallback(() => {
                        setFilled(true);
                    }, []);
                    const onEmpty = react.useCallback(() => {
                        setFilled(false);
                    }, []);
                    const childContext = {
                        adornedStart,
                        setAdornedStart,
                        color,
                        disabled,
                        error,
                        filled,
                        focused,
                        fullWidth,
                        hiddenLabel,
                        size,
                        onBlur: () => {
                            setFocused(false);
                        },
                        onEmpty,
                        onFilled,
                        onFocus: () => {
                            setFocused(true);
                        },
                        registerEffect,
                        required,
                        variant,
                    };
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        FormControlContext /* default.Provider */.Z.Provider,
                        {
                            value: childContext,
                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                FormControlRoot,
                                (0, esm_extends /* default */.Z)(
                                    {
                                        as: component,
                                        ownerState: ownerState,
                                        className: (0, clsx_m /* default */.Z)(
                                            classes.root,
                                            className
                                        ),
                                        ref: ref,
                                    },
                                    other,
                                    {
                                        children: children,
                                    }
                                )
                            ),
                        }
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var FormControl_FormControl =
                FormControl; // CONCATENATED MODULE: ./node_modules/@mui/material/FormHelperText/formHelperTextClasses.js
            function getFormHelperTextUtilityClasses(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiFormHelperText",
                    slot
                );
            }
            const formHelperTextClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiFormHelperText", [
                "root",
                "error",
                "disabled",
                "sizeSmall",
                "sizeMedium",
                "contained",
                "focused",
                "filled",
                "required",
            ]);
            /* harmony default export */ var FormHelperText_formHelperTextClasses =
                formHelperTextClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/FormHelperText/FormHelperText.js
            var _span;

            const FormHelperText_excluded = [
                "children",
                "className",
                "component",
                "disabled",
                "error",
                "filled",
                "focused",
                "margin",
                "required",
                "variant",
            ];

            const FormHelperText_useUtilityClasses = (ownerState) => {
                const {
                    classes,
                    contained,
                    size,
                    disabled,
                    error,
                    filled,
                    focused,
                    required,
                } = ownerState;
                const slots = {
                    root: [
                        "root",
                        disabled && "disabled",
                        error && "error",
                        size && `size${(0, capitalize /* default */.Z)(size)}`,
                        contained && "contained",
                        focused && "focused",
                        filled && "filled",
                        required && "required",
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getFormHelperTextUtilityClasses,
                    classes
                );
            };

            const FormHelperTextRoot = (0, styled /* default */.ZP)("p", {
                name: "MuiFormHelperText",
                slot: "Root",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.root,
                        ownerState.size &&
                            styles[
                                `size${(0, capitalize /* default */.Z)(
                                    ownerState.size
                                )}`
                            ],
                        ownerState.contained && styles.contained,
                        ownerState.filled && styles.filled,
                    ];
                },
            })(({ theme, ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        color: theme.palette.text.secondary,
                    },
                    theme.typography.caption,
                    {
                        textAlign: "left",
                        marginTop: 3,
                        marginRight: 0,
                        marginBottom: 0,
                        marginLeft: 0,
                        [`&.${FormHelperText_formHelperTextClasses.disabled}`]:
                            {
                                color: theme.palette.text.disabled,
                            },
                        [`&.${FormHelperText_formHelperTextClasses.error}`]: {
                            color: theme.palette.error.main,
                        },
                    },
                    ownerState.size === "small" && {
                        marginTop: 4,
                    },
                    ownerState.contained && {
                        marginLeft: 14,
                        marginRight: 14,
                    }
                )
            );
            const FormHelperText = /*#__PURE__*/ react.forwardRef(
                function FormHelperText(inProps, ref) {
                    const props = (0, useThemeProps /* default */.Z)({
                        props: inProps,
                        name: "MuiFormHelperText",
                    });

                    const { children, className, component = "p" } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            FormHelperText_excluded
                        );

                    const muiFormControl = (0,
                    useFormControl /* default */.Z)();
                    const fcs = (0, formControlState /* default */.Z)({
                        props,
                        muiFormControl,
                        states: [
                            "variant",
                            "size",
                            "disabled",
                            "error",
                            "filled",
                            "focused",
                            "required",
                        ],
                    });

                    const ownerState = (0, esm_extends /* default */.Z)(
                        {},
                        props,
                        {
                            component,
                            contained:
                                fcs.variant === "filled" ||
                                fcs.variant === "outlined",
                            variant: fcs.variant,
                            size: fcs.size,
                            disabled: fcs.disabled,
                            error: fcs.error,
                            filled: fcs.filled,
                            focused: fcs.focused,
                            required: fcs.required,
                        }
                    );

                    const classes =
                        FormHelperText_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        FormHelperTextRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                as: component,
                                ownerState: ownerState,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                                ref: ref,
                            },
                            other,
                            {
                                children:
                                    children === " " // notranslate needed while Google Translate will not fix zero-width space issue
                                        ? _span ||
                                          (_span = /*#__PURE__*/ (0,
                                          jsx_runtime.jsx)("span", {
                                              className: "notranslate",
                                              children: "\u200B",
                                          }))
                                        : children,
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var FormHelperText_FormHelperText =
                FormHelperText;
            // EXTERNAL MODULE: ./node_modules/@mui/material/Select/Select.js + 15 modules
            var Select = __webpack_require__(6770); // CONCATENATED MODULE: ./node_modules/@mui/material/TextField/textFieldClasses.js
            function getTextFieldUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiTextField",
                    slot
                );
            }
            const textFieldClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiTextField", ["root"]);
            /* harmony default export */ var TextField_textFieldClasses =
                /* unused pure expression or super */ null && textFieldClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/TextField/TextField.js
            const TextField_excluded = [
                "autoComplete",
                "autoFocus",
                "children",
                "className",
                "color",
                "defaultValue",
                "disabled",
                "error",
                "FormHelperTextProps",
                "fullWidth",
                "helperText",
                "id",
                "InputLabelProps",
                "inputProps",
                "InputProps",
                "inputRef",
                "label",
                "maxRows",
                "minRows",
                "multiline",
                "name",
                "onBlur",
                "onChange",
                "onFocus",
                "placeholder",
                "required",
                "rows",
                "select",
                "SelectProps",
                "type",
                "value",
                "variant",
            ];

            const variantComponent = {
                standard: Input /* default */.Z,
                filled: FilledInput /* default */.Z,
                outlined: OutlinedInput /* default */.Z,
            };

            const TextField_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["root"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getTextFieldUtilityClass,
                    classes
                );
            };

            const TextFieldRoot = (0, styled /* default */.ZP)(
                FormControl_FormControl,
                {
                    name: "MuiTextField",
                    slot: "Root",
                    overridesResolver: (props, styles) => styles.root,
                }
            )({});
            /**
             * The `TextField` is a convenience wrapper for the most common cases (80%).
             * It cannot be all things to all people, otherwise the API would grow out of control.
             *
             * ## Advanced Configuration
             *
             * It's important to understand that the text field is a simple abstraction
             * on top of the following components:
             *
             * - [FormControl](/material-ui/api/form-control/)
             * - [InputLabel](/material-ui/api/input-label/)
             * - [FilledInput](/material-ui/api/filled-input/)
             * - [OutlinedInput](/material-ui/api/outlined-input/)
             * - [Input](/material-ui/api/input/)
             * - [FormHelperText](/material-ui/api/form-helper-text/)
             *
             * If you wish to alter the props applied to the `input` element, you can do so as follows:
             *
             * ```jsx
             * const inputProps = {
             *   step: 300,
             * };
             *
             * return <TextField id="time" type="time" inputProps={inputProps} />;
             * ```
             *
             * For advanced cases, please look at the source of TextField by clicking on the
             * "Edit this page" button above. Consider either:
             *
             * - using the upper case props for passing values directly to the components
             * - using the underlying components directly as shown in the demos
             */

            const TextField = /*#__PURE__*/ react.forwardRef(function TextField(
                inProps,
                ref
            ) {
                const props = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiTextField",
                });

                const {
                        autoComplete,
                        autoFocus = false,
                        children,
                        className,
                        color = "primary",
                        defaultValue,
                        disabled = false,
                        error = false,
                        FormHelperTextProps,
                        fullWidth = false,
                        helperText,
                        id: idOverride,
                        InputLabelProps,
                        inputProps,
                        InputProps,
                        inputRef,
                        label,
                        maxRows,
                        minRows,
                        multiline = false,
                        name,
                        onBlur,
                        onChange,
                        onFocus,
                        placeholder,
                        required = false,
                        rows,
                        select = false,
                        SelectProps,
                        type,
                        value,
                        variant = "outlined",
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        TextField_excluded
                    );

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    autoFocus,
                    color,
                    disabled,
                    error,
                    fullWidth,
                    multiline,
                    required,
                    select,
                    variant,
                });

                const classes = TextField_useUtilityClasses(ownerState);

                if (false) {
                }

                const InputMore = {};

                if (variant === "outlined") {
                    if (
                        InputLabelProps &&
                        typeof InputLabelProps.shrink !== "undefined"
                    ) {
                        InputMore.notched = InputLabelProps.shrink;
                    }

                    InputMore.label = label;
                }

                if (select) {
                    // unset defaults from textbox inputs
                    if (!SelectProps || !SelectProps.native) {
                        InputMore.id = undefined;
                    }

                    InputMore["aria-describedby"] = undefined;
                }

                const id = (0, esm_useId /* default */.Z)(idOverride);
                const helperTextId =
                    helperText && id ? `${id}-helper-text` : undefined;
                const inputLabelId = label && id ? `${id}-label` : undefined;
                const InputComponent = variantComponent[variant];

                const InputElement = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    InputComponent,
                    (0, esm_extends /* default */.Z)(
                        {
                            "aria-describedby": helperTextId,
                            autoComplete: autoComplete,
                            autoFocus: autoFocus,
                            defaultValue: defaultValue,
                            fullWidth: fullWidth,
                            multiline: multiline,
                            name: name,
                            rows: rows,
                            maxRows: maxRows,
                            minRows: minRows,
                            type: type,
                            value: value,
                            id: id,
                            inputRef: inputRef,
                            onBlur: onBlur,
                            onChange: onChange,
                            onFocus: onFocus,
                            placeholder: placeholder,
                            inputProps: inputProps,
                        },
                        InputMore,
                        InputProps
                    )
                );

                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    TextFieldRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            className: (0, clsx_m /* default */.Z)(
                                classes.root,
                                className
                            ),
                            disabled: disabled,
                            error: error,
                            fullWidth: fullWidth,
                            ref: ref,
                            required: required,
                            color: color,
                            variant: variant,
                            ownerState: ownerState,
                        },
                        other,
                        {
                            children: [
                                label != null &&
                                    label !== "" &&
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        InputLabel_InputLabel,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                htmlFor: id,
                                                id: inputLabelId,
                                            },
                                            InputLabelProps,
                                            {
                                                children: label,
                                            }
                                        )
                                    ),
                                select
                                    ? /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                          Select /* default */.Z,
                                          (0, esm_extends /* default */.Z)(
                                              {
                                                  "aria-describedby":
                                                      helperTextId,
                                                  id: id,
                                                  labelId: inputLabelId,
                                                  value: value,
                                                  input: InputElement,
                                              },
                                              SelectProps,
                                              {
                                                  children: children,
                                              }
                                          )
                                      )
                                    : InputElement,
                                helperText &&
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        FormHelperText_FormHelperText,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                id: helperTextId,
                                            },
                                            FormHelperTextProps,
                                            {
                                                children: helperText,
                                            }
                                        )
                                    ),
                            ],
                        }
                    )
                );
            });
            false ? 0 : void 0;
            /* harmony default export */ var TextField_TextField = TextField; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterInputMultipleValue.js
            const GridFilterInputMultipleValue_excluded = [
                "item",
                "applyValue",
                "type",
                "apiRef",
                "focusElementRef",
            ];

            function GridFilterInputMultipleValue(props) {
                const { item, applyValue, type, apiRef, focusElementRef } =
                        props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridFilterInputMultipleValue_excluded
                    );

                const [filterValueState, setFilterValueState] = react.useState(
                    item.value || []
                );
                const id = (0, useId /* default */.Z)();
                react.useEffect(() => {
                    var _item$value;

                    const itemValue =
                        (_item$value = item.value) != null ? _item$value : [];
                    setFilterValueState(itemValue.map(String));
                }, [item.value]);
                const handleChange = react.useCallback(
                    (event, value) => {
                        setFilterValueState(value.map(String));
                        applyValue(
                            (0, esm_extends /* default */.Z)({}, item, {
                                value: [...value],
                            })
                        );
                    },
                    [applyValue, item]
                );
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    Autocomplete /* default */.Z,
                    (0, esm_extends /* default */.Z)(
                        {
                            multiple: true,
                            freeSolo: true,
                            limitTags: 1,
                            options: [],
                            filterOptions: (options, params) => {
                                const { inputValue } = params;
                                return inputValue == null || inputValue === ""
                                    ? []
                                    : [inputValue];
                            },
                            id: id,
                            value: filterValueState,
                            onChange: handleChange,
                            renderTags: (value, getTagProps) =>
                                value.map((option, index) =>
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        Chip /* default */.Z,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                variant: "outlined",
                                                size: "small",
                                                label: option,
                                            },
                                            getTagProps({
                                                index,
                                            })
                                        )
                                    )
                                ),
                            renderInput: (params) =>
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    TextField_TextField,
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        params,
                                        {
                                            label: apiRef.current.getLocaleText(
                                                "filterPanelInputLabel"
                                            ),
                                            placeholder:
                                                apiRef.current.getLocaleText(
                                                    "filterPanelInputPlaceholder"
                                                ),
                                            InputLabelProps: (0,
                                            esm_extends /* default */.Z)(
                                                {},
                                                params.InputLabelProps,
                                                {
                                                    shrink: true,
                                                }
                                            ),
                                            inputRef: focusElementRef,
                                            type: type || "text",
                                            variant: "standard",
                                        }
                                    )
                                ),
                        },
                        other
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridStringOperators.js

            const getGridStringOperators = () => [
                {
                    value: "contains",
                    getApplyFilterFn: (filterItem) => {
                        if (!filterItem.value) {
                            return null;
                        }

                        const filterRegex = new RegExp(
                            escapeRegExp(filterItem.value),
                            "i"
                        );
                        return ({ value }) => {
                            return value != null
                                ? filterRegex.test(value.toString())
                                : false;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                },
                {
                    value: "equals",
                    getApplyFilterFn: (filterItem) => {
                        if (!filterItem.value) {
                            return null;
                        }

                        const collator = new Intl.Collator(undefined, {
                            sensitivity: "base",
                            usage: "search",
                        });
                        return ({ value }) => {
                            return value != null
                                ? collator.compare(
                                      filterItem.value,
                                      value.toString()
                                  ) === 0
                                : false;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                },
                {
                    value: "startsWith",
                    getApplyFilterFn: (filterItem) => {
                        if (!filterItem.value) {
                            return null;
                        }

                        const filterRegex = new RegExp(
                            `^${escapeRegExp(filterItem.value)}.*$`,
                            "i"
                        );
                        return ({ value }) => {
                            return value != null
                                ? filterRegex.test(value.toString())
                                : false;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                },
                {
                    value: "endsWith",
                    getApplyFilterFn: (filterItem) => {
                        if (!filterItem.value) {
                            return null;
                        }

                        const filterRegex = new RegExp(
                            `.*${escapeRegExp(filterItem.value)}$`,
                            "i"
                        );
                        return ({ value }) => {
                            return value != null
                                ? filterRegex.test(value.toString())
                                : false;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                },
                {
                    value: "isEmpty",
                    getApplyFilterFn: () => {
                        return ({ value }) => {
                            return value === "" || value == null;
                        };
                    },
                },
                {
                    value: "isNotEmpty",
                    getApplyFilterFn: () => {
                        return ({ value }) => {
                            return value !== "" && value != null;
                        };
                    },
                },
                {
                    value: "isAnyOf",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            !Array.isArray(filterItem.value) ||
                            filterItem.value.length === 0
                        ) {
                            return null;
                        }

                        const collator = new Intl.Collator(undefined, {
                            sensitivity: "base",
                            usage: "search",
                        });
                        return ({ value }) =>
                            value != null
                                ? filterItem.value.some((filterValue) => {
                                      return (
                                          collator.compare(
                                              filterValue,
                                              value.toString() || ""
                                          ) === 0
                                      );
                                  })
                                : false;
                    },
                    InputComponent: GridFilterInputMultipleValue,
                },
            ]; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridStringColDef.js
            const GRID_STRING_COL_DEF = {
                width: 100,
                minWidth: 50,
                maxWidth: Infinity,
                hide: false,
                hideable: true,
                sortable: true,
                resizable: true,
                filterable: true,
                groupable: true,
                pinnable: true,
                editable: false,
                sortComparator:
                    gridSortingUtils /* gridStringOrNumberComparator */.Id,
                type: "string",
                align: "left",
                filterOperators: getGridStringOperators(),
                renderEditCell: renderEditInputCell,
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridNumericOperators.js
            const parseNumericValue = (value) => {
                if (value == null) {
                    return null;
                }

                return Number(value);
            };

            const getGridNumericOperators = () => [
                {
                    label: "=",
                    value: "=",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            Number.isNaN(filterItem.value)
                        ) {
                            return null;
                        }

                        return ({ value }) => {
                            return (
                                parseNumericValue(value) === filterItem.value
                            );
                        };
                    },
                    InputComponent: GridFilterInputValue,
                    InputComponentProps: {
                        type: "number",
                    },
                },
                {
                    label: "!=",
                    value: "!=",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            Number.isNaN(filterItem.value)
                        ) {
                            return null;
                        }

                        return ({ value }) => {
                            return (
                                parseNumericValue(value) !== filterItem.value
                            );
                        };
                    },
                    InputComponent: GridFilterInputValue,
                    InputComponentProps: {
                        type: "number",
                    },
                },
                {
                    label: ">",
                    value: ">",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            Number.isNaN(filterItem.value)
                        ) {
                            return null;
                        }

                        return ({ value }) => {
                            if (value == null) {
                                return false;
                            }

                            return parseNumericValue(value) > filterItem.value;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                    InputComponentProps: {
                        type: "number",
                    },
                },
                {
                    label: ">=",
                    value: ">=",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            Number.isNaN(filterItem.value)
                        ) {
                            return null;
                        }

                        return ({ value }) => {
                            if (value == null) {
                                return false;
                            }

                            return parseNumericValue(value) >= filterItem.value;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                    InputComponentProps: {
                        type: "number",
                    },
                },
                {
                    label: "<",
                    value: "<",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            Number.isNaN(filterItem.value)
                        ) {
                            return null;
                        }

                        return ({ value }) => {
                            if (value == null) {
                                return false;
                            }

                            return parseNumericValue(value) < filterItem.value;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                    InputComponentProps: {
                        type: "number",
                    },
                },
                {
                    label: "<=",
                    value: "<=",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            Number.isNaN(filterItem.value)
                        ) {
                            return null;
                        }

                        return ({ value }) => {
                            if (value == null) {
                                return false;
                            }

                            return parseNumericValue(value) <= filterItem.value;
                        };
                    },
                    InputComponent: GridFilterInputValue,
                    InputComponentProps: {
                        type: "number",
                    },
                },
                {
                    value: "isEmpty",
                    getApplyFilterFn: () => {
                        return ({ value }) => {
                            return value == null;
                        };
                    },
                },
                {
                    value: "isNotEmpty",
                    getApplyFilterFn: () => {
                        return ({ value }) => {
                            return value != null;
                        };
                    },
                },
                {
                    value: "isAnyOf",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            !Array.isArray(filterItem.value) ||
                            filterItem.value.length === 0
                        ) {
                            return null;
                        }

                        return ({ value }) => {
                            return (
                                value != null &&
                                filterItem.value.includes(Number(value))
                            );
                        };
                    },
                    InputComponent: GridFilterInputMultipleValue,
                    InputComponentProps: {
                        type: "number",
                    },
                },
            ];
            /**
             * @deprecated Use `getGridNumericOperators` instead.
             */

            const getGridNumericColumnOperators = (0,
            warning /* wrapWithWarningOnCall */.M)(getGridNumericOperators, [
                "MUI: The method getGridNumericColumnOperators is deprecated and will be removed in the next major version.",
                "Use getGridNumericOperators instead.",
            ]); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridNumericColDef.js
            const GRID_NUMERIC_COL_DEF = (0, esm_extends /* default */.Z)(
                {},
                GRID_STRING_COL_DEF,
                {
                    type: "number",
                    align: "right",
                    headerAlign: "right",
                    sortComparator:
                        gridSortingUtils /* gridNumberComparator */.GH,
                    valueParser: (value) =>
                        value === "" ? null : Number(value),
                    valueFormatter: ({ value }) =>
                        (value && isNumber(value) && value.toLocaleString()) ||
                        value,
                    filterOperators: getGridNumericOperators(),
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterInputDate.js
            const GridFilterInputDate_excluded = [
                "item",
                "applyValue",
                "type",
                "apiRef",
                "focusElementRef",
                "InputProps",
            ];

            const SUBMIT_FILTER_DATE_STROKE_TIME = 500;

            function GridFilterInputDate(props) {
                var _item$value, _rootProps$components;

                const {
                        item,
                        applyValue,
                        type,
                        apiRef,
                        focusElementRef,
                        InputProps,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridFilterInputDate_excluded
                    );

                const filterTimeout = react.useRef();
                const [filterValueState, setFilterValueState] = react.useState(
                    (_item$value = item.value) != null ? _item$value : ""
                );
                const [applying, setIsApplying] = react.useState(false);
                const id = (0, useId /* default */.Z)();
                const rootProps = useGridRootProps();
                const onFilterChange = react.useCallback(
                    (event) => {
                        const value = event.target.value;
                        clearTimeout(filterTimeout.current);
                        setFilterValueState(String(value));
                        setIsApplying(true);
                        filterTimeout.current = setTimeout(() => {
                            applyValue(
                                (0, esm_extends /* default */.Z)({}, item, {
                                    value,
                                })
                            );
                            setIsApplying(false);
                        }, SUBMIT_FILTER_DATE_STROKE_TIME);
                    },
                    [applyValue, item]
                );
                react.useEffect(() => {
                    return () => {
                        clearTimeout(filterTimeout.current);
                    };
                }, []);
                react.useEffect(() => {
                    var _item$value2;

                    const itemValue =
                        (_item$value2 = item.value) != null ? _item$value2 : "";
                    setFilterValueState(String(itemValue));
                }, [item.value]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    rootProps.components.BaseTextField,
                    (0, esm_extends /* default */.Z)(
                        {
                            id: id,
                            label: apiRef.current.getLocaleText(
                                "filterPanelInputLabel"
                            ),
                            placeholder: apiRef.current.getLocaleText(
                                "filterPanelInputPlaceholder"
                            ),
                            value: filterValueState,
                            onChange: onFilterChange,
                            type: type || "text",
                            variant: "standard",
                            InputLabelProps: {
                                shrink: true,
                            },
                            inputRef: focusElementRef,
                            InputProps: (0, esm_extends /* default */.Z)(
                                {},
                                applying
                                    ? {
                                          endAdornment: /*#__PURE__*/ (0,
                                          jsx_runtime.jsx)(GridLoadIcon, {}),
                                      }
                                    : {},
                                InputProps,
                                {
                                    inputProps: (0,
                                    esm_extends /* default */.Z)(
                                        {
                                            max:
                                                type === "datetime-local"
                                                    ? "9999-12-31T23:59"
                                                    : "9999-12-31",
                                        },
                                        InputProps == null
                                            ? void 0
                                            : InputProps.inputProps
                                    ),
                                }
                            ),
                        },
                        other,
                        (_rootProps$components = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components.baseTextField
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridDateOperators.js

            const dateRegex = /(\d+)-(\d+)-(\d+)/;
            const dateTimeRegex = /(\d+)-(\d+)-(\d+)T(\d+):(\d+)/;

            function buildApplyFilterFn(
                filterItem,
                compareFn,
                showTime,
                keepHours
            ) {
                if (!filterItem.value) {
                    return null;
                }

                const [year, month, day, hour, minute] = filterItem.value
                    .match(showTime ? dateTimeRegex : dateRegex)
                    .slice(1)
                    .map(Number);
                const time = new Date(
                    year,
                    month - 1,
                    day,
                    hour || 0,
                    minute || 0
                ).getTime();
                return ({ value }) => {
                    if (!value) {
                        return false;
                    }

                    const valueAsDate =
                        value instanceof Date
                            ? value
                            : new Date(value.toString());

                    if (keepHours) {
                        return compareFn(valueAsDate.getTime(), time);
                    } // Make a copy of the date to not reset the hours in the original object

                    const dateCopy =
                        value instanceof Date
                            ? new Date(valueAsDate)
                            : valueAsDate;
                    const timeToCompare = dateCopy.setHours(
                        showTime ? valueAsDate.getHours() : 0,
                        showTime ? valueAsDate.getMinutes() : 0,
                        0,
                        0
                    );
                    return compareFn(timeToCompare, time);
                };
            }

            const getGridDateOperators = (showTime) => [
                {
                    value: "is",
                    getApplyFilterFn: (filterItem) => {
                        return buildApplyFilterFn(
                            filterItem,
                            (value1, value2) => value1 === value2,
                            showTime
                        );
                    },
                    InputComponent: GridFilterInputDate,
                    InputComponentProps: {
                        type: showTime ? "datetime-local" : "date",
                    },
                },
                {
                    value: "not",
                    getApplyFilterFn: (filterItem) => {
                        return buildApplyFilterFn(
                            filterItem,
                            (value1, value2) => value1 !== value2,
                            showTime
                        );
                    },
                    InputComponent: GridFilterInputDate,
                    InputComponentProps: {
                        type: showTime ? "datetime-local" : "date",
                    },
                },
                {
                    value: "after",
                    getApplyFilterFn: (filterItem) => {
                        return buildApplyFilterFn(
                            filterItem,
                            (value1, value2) => value1 > value2,
                            showTime
                        );
                    },
                    InputComponent: GridFilterInputDate,
                    InputComponentProps: {
                        type: showTime ? "datetime-local" : "date",
                    },
                },
                {
                    value: "onOrAfter",
                    getApplyFilterFn: (filterItem) => {
                        return buildApplyFilterFn(
                            filterItem,
                            (value1, value2) => value1 >= value2,
                            showTime
                        );
                    },
                    InputComponent: GridFilterInputDate,
                    InputComponentProps: {
                        type: showTime ? "datetime-local" : "date",
                    },
                },
                {
                    value: "before",
                    getApplyFilterFn: (filterItem) => {
                        return buildApplyFilterFn(
                            filterItem,
                            (value1, value2) => value1 < value2,
                            showTime,
                            !showTime
                        );
                    },
                    InputComponent: GridFilterInputDate,
                    InputComponentProps: {
                        type: showTime ? "datetime-local" : "date",
                    },
                },
                {
                    value: "onOrBefore",
                    getApplyFilterFn: (filterItem) => {
                        return buildApplyFilterFn(
                            filterItem,
                            (value1, value2) => value1 <= value2,
                            showTime
                        );
                    },
                    InputComponent: GridFilterInputDate,
                    InputComponentProps: {
                        type: showTime ? "datetime-local" : "date",
                    },
                },
                {
                    value: "isEmpty",
                    getApplyFilterFn: () => {
                        return ({ value }) => {
                            return value == null;
                        };
                    },
                },
                {
                    value: "isNotEmpty",
                    getApplyFilterFn: () => {
                        return ({ value }) => {
                            return value != null;
                        };
                    },
                },
            ]; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/cell/GridEditDateCell.js
            const GridEditDateCell_excluded = [
                "id",
                "value",
                "formattedValue",
                "api",
                "field",
                "row",
                "rowNode",
                "colDef",
                "cellMode",
                "isEditable",
                "tabIndex",
                "hasFocus",
                "getValue",
                "inputProps",
                "isValidating",
                "isProcessingProps",
            ];

            const GridEditDateCell_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["editInputCell"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            function GridEditDateCell(props) {
                const {
                        id,
                        value: valueProp,
                        api,
                        field,
                        colDef,
                        hasFocus,
                        inputProps,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridEditDateCell_excluded
                    );

                const isDateTime = colDef.type === "dateTime";
                const inputRef = react.useRef();
                const valueTransformed = react.useMemo(() => {
                    let parsedDate;

                    if (valueProp == null) {
                        parsedDate = null;
                    } else if (valueProp instanceof Date) {
                        parsedDate = valueProp;
                    } else {
                        parsedDate = new Date(
                            (valueProp != null ? valueProp : "").toString()
                        );
                    }

                    let formattedDate;

                    if (
                        parsedDate == null ||
                        Number.isNaN(parsedDate.getTime())
                    ) {
                        formattedDate = "";
                    } else {
                        const localDate = new Date(
                            parsedDate.getTime() -
                                parsedDate.getTimezoneOffset() * 60 * 1000
                        );
                        formattedDate = localDate
                            .toISOString()
                            .substr(0, isDateTime ? 16 : 10);
                    }

                    return {
                        parsed: parsedDate,
                        formatted: formattedDate,
                    };
                }, [valueProp, isDateTime]);
                const [valueState, setValueState] =
                    react.useState(valueTransformed);
                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridEditDateCell_useUtilityClasses(ownerState);
                const handleChange = react.useCallback(
                    (event) => {
                        const newFormattedDate = event.target.value;
                        let newParsedDate;

                        if (newFormattedDate === "") {
                            newParsedDate = null;
                        } else {
                            const [date, time] = newFormattedDate.split("T");
                            const [year, month, day] = date.split("-");
                            newParsedDate = new Date();
                            newParsedDate.setFullYear(
                                year,
                                Number(month) - 1,
                                day
                            );
                            newParsedDate.setHours(0, 0, 0, 0);

                            if (time) {
                                const [hours, minutes] = time.split(":");
                                newParsedDate.setHours(
                                    Number(hours),
                                    Number(minutes),
                                    0,
                                    0
                                );
                            }
                        }

                        setValueState({
                            parsed: newParsedDate,
                            formatted: newFormattedDate,
                        });
                        api.setEditCellValue(
                            {
                                id,
                                field,
                                value: newParsedDate,
                            },
                            event
                        );
                    },
                    [api, field, id]
                );
                react.useEffect(() => {
                    setValueState((state) => {
                        var _valueTransformed$par, _state$parsed;

                        if (
                            valueTransformed.parsed !== state.parsed &&
                            ((_valueTransformed$par =
                                valueTransformed.parsed) == null
                                ? void 0
                                : _valueTransformed$par.getTime()) !==
                                ((_state$parsed = state.parsed) == null
                                    ? void 0
                                    : _state$parsed.getTime())
                        ) {
                            return valueTransformed;
                        }

                        return state;
                    });
                }, [valueTransformed]);
                (0, useEnhancedEffect /* default */.Z)(() => {
                    if (hasFocus) {
                        inputRef.current.focus();
                    }
                }, [hasFocus]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    InputBase /* default */.ZP,
                    (0, esm_extends /* default */.Z)(
                        {
                            inputRef: inputRef,
                            fullWidth: true,
                            className: classes.root,
                            type: isDateTime ? "datetime-local" : "date",
                            inputProps: (0, esm_extends /* default */.Z)(
                                {
                                    max: isDateTime
                                        ? "9999-12-31T23:59"
                                        : "9999-12-31",
                                },
                                inputProps
                            ),
                            value: valueState.formatted,
                            onChange: handleChange,
                        },
                        other
                    )
                );
            }
            const renderEditDateCell = (params) =>
                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridEditDateCell,
                    (0, esm_extends /* default */.Z)({}, params)
                ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridDateColDef.js
            function gridDateFormatter({ value }) {
                if (value instanceof Date) {
                    return value.toLocaleDateString();
                }

                return value != null ? value : "";
            }
            function gridDateTimeFormatter({ value }) {
                if (value instanceof Date) {
                    return value.toLocaleString();
                }

                return value != null ? value : "";
            }
            const GRID_DATE_COL_DEF = (0, esm_extends /* default */.Z)(
                {},
                GRID_STRING_COL_DEF,
                {
                    type: "date",
                    sortComparator:
                        gridSortingUtils /* gridDateComparator */.mA,
                    valueFormatter: gridDateFormatter,
                    filterOperators: getGridDateOperators(),
                    renderEditCell: renderEditDateCell,
                }
            );
            const GRID_DATETIME_COL_DEF = (0, esm_extends /* default */.Z)(
                {},
                GRID_STRING_COL_DEF,
                {
                    type: "dateTime",
                    sortComparator:
                        gridSortingUtils /* gridDateComparator */.mA,
                    valueFormatter: gridDateTimeFormatter,
                    filterOperators: getGridDateOperators(true),
                    renderEditCell: renderEditDateCell,
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/cell/GridBooleanCell.js
            const GridBooleanCell_excluded = [
                "id",
                "value",
                "formattedValue",
                "api",
                "field",
                "row",
                "rowNode",
                "colDef",
                "cellMode",
                "isEditable",
                "hasFocus",
                "tabIndex",
                "getValue",
            ];

            const GridBooleanCell_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["booleanCell"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridBooleanCell = /*#__PURE__*/ react.memo((props) => {
                const { value, api } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridBooleanCell_excluded
                    );

                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridBooleanCell_useUtilityClasses(ownerState);
                const Icon = react.useMemo(
                    () =>
                        value
                            ? rootProps.components.BooleanCellTrueIcon
                            : rootProps.components.BooleanCellFalseIcon,
                    [
                        rootProps.components.BooleanCellFalseIcon,
                        rootProps.components.BooleanCellTrueIcon,
                        value,
                    ]
                );
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    Icon,
                    (0, esm_extends /* default */.Z)(
                        {
                            fontSize: "small",
                            className: classes.root,
                            titleAccess: api.getLocaleText(
                                value
                                    ? "booleanCellTrueLabel"
                                    : "booleanCellFalseLabel"
                            ),
                            "data-value": Boolean(value),
                        },
                        other
                    )
                );
            });
            const renderBooleanCell = (params) => {
                if (params.rowNode.isAutoGenerated) {
                    return "";
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridBooleanCell,
                    (0, esm_extends /* default */.Z)({}, params)
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/cell/GridEditBooleanCell.js
            const GridEditBooleanCell_excluded = [
                "id",
                "value",
                "formattedValue",
                "api",
                "field",
                "row",
                "rowNode",
                "colDef",
                "cellMode",
                "isEditable",
                "tabIndex",
                "className",
                "getValue",
                "hasFocus",
                "isValidating",
                "isProcessingProps",
                "error",
            ];

            const GridEditBooleanCell_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["editBooleanCell"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            function GridEditBooleanCell(props) {
                var _rootProps$components;

                const {
                        id: idProp,
                        value,
                        api,
                        field,
                        className,
                        hasFocus,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridEditBooleanCell_excluded
                    );

                const inputRef = react.useRef(null);
                const id = (0, useId /* default */.Z)();
                const [valueState, setValueState] = react.useState(value);
                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes =
                    GridEditBooleanCell_useUtilityClasses(ownerState);
                const handleChange = react.useCallback(
                    (event) => {
                        const newValue = event.target.checked;
                        setValueState(newValue);
                        api.setEditCellValue(
                            {
                                id: idProp,
                                field,
                                value: newValue,
                            },
                            event
                        );
                    },
                    [api, field, idProp]
                );
                react.useEffect(() => {
                    setValueState(value);
                }, [value]);
                (0, useEnhancedEffect /* default */.Z)(() => {
                    if (hasFocus) {
                        inputRef.current.focus();
                    }
                }, [hasFocus]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    "label",
                    (0, esm_extends /* default */.Z)(
                        {
                            htmlFor: id,
                            className: (0, clsx_m /* default */.Z)(
                                classes.root,
                                className
                            ),
                        },
                        other,
                        {
                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                rootProps.components.BaseCheckbox,
                                (0, esm_extends /* default */.Z)(
                                    {
                                        id: id,
                                        inputRef: inputRef,
                                        checked: Boolean(valueState),
                                        onChange: handleChange,
                                        size: "small",
                                    },
                                    (_rootProps$components =
                                        rootProps.componentsProps) == null
                                        ? void 0
                                        : _rootProps$components.baseCheckbox
                                )
                            ),
                        }
                    )
                );
            }
            const renderEditBooleanCell = (params) =>
                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridEditBooleanCell,
                    (0, esm_extends /* default */.Z)({}, params)
                ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterInputBoolean.js
            const GridFilterInputBoolean_excluded = [
                "item",
                "applyValue",
                "apiRef",
                "focusElementRef",
            ];

            function GridFilterInputBoolean(props) {
                var _rootProps$components,
                    _baseSelectProps$nati,
                    _rootProps$components2,
                    _rootProps$components3;

                const { item, applyValue, apiRef, focusElementRef } = props,
                    others = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridFilterInputBoolean_excluded
                    );

                const [filterValueState, setFilterValueState] = react.useState(
                    item.value || ""
                );
                const rootProps = useGridRootProps();
                const baseSelectProps =
                    ((_rootProps$components = rootProps.componentsProps) == null
                        ? void 0
                        : _rootProps$components.baseSelect) || {};
                const isSelectNative =
                    (_baseSelectProps$nati = baseSelectProps.native) != null
                        ? _baseSelectProps$nati
                        : true;
                const OptionComponent = isSelectNative
                    ? "option"
                    : MenuItem /* default */.Z;
                const onFilterChange = react.useCallback(
                    (event) => {
                        const value = event.target.value;
                        setFilterValueState(value);
                        applyValue(
                            (0, esm_extends /* default */.Z)({}, item, {
                                value,
                            })
                        );
                    },
                    [applyValue, item]
                );
                react.useEffect(() => {
                    setFilterValueState(item.value || "");
                }, [item.value]);
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    rootProps.components.BaseTextField,
                    (0, esm_extends /* default */.Z)(
                        {
                            label: apiRef.current.getLocaleText(
                                "filterPanelInputLabel"
                            ),
                            value: filterValueState,
                            onChange: onFilterChange,
                            variant: "standard",
                            select: true,
                            SelectProps: (0, esm_extends /* default */.Z)(
                                {
                                    native: isSelectNative,
                                    displayEmpty: true,
                                },
                                (_rootProps$components2 =
                                    rootProps.componentsProps) == null
                                    ? void 0
                                    : _rootProps$components2.baseSelect
                            ),
                            InputLabelProps: {
                                shrink: true,
                            },
                            inputRef: focusElementRef,
                        },
                        others,
                        (_rootProps$components3 = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components3.baseTextField,
                        {
                            children: [
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    OptionComponent,
                                    {
                                        value: "",
                                        children:
                                            apiRef.current.getLocaleText(
                                                "filterValueAny"
                                            ),
                                    }
                                ),
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    OptionComponent,
                                    {
                                        value: "true",
                                        children:
                                            apiRef.current.getLocaleText(
                                                "filterValueTrue"
                                            ),
                                    }
                                ),
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    OptionComponent,
                                    {
                                        value: "false",
                                        children:
                                            apiRef.current.getLocaleText(
                                                "filterValueFalse"
                                            ),
                                    }
                                ),
                            ],
                        }
                    )
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridBooleanOperators.js
            const getGridBooleanOperators = () => [
                {
                    value: "is",
                    getApplyFilterFn: (filterItem) => {
                        if (!filterItem.value) {
                            return null;
                        }

                        const valueAsBoolean = filterItem.value === "true";
                        return ({ value }) => {
                            return Boolean(value) === valueAsBoolean;
                        };
                    },
                    InputComponent: GridFilterInputBoolean,
                },
            ]; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridBooleanColDef.js
            function gridBooleanFormatter({ value, api }) {
                return value
                    ? api.getLocaleText("booleanCellTrueLabel")
                    : api.getLocaleText("booleanCellFalseLabel");
            }

            const GRID_BOOLEAN_COL_DEF = (0, esm_extends /* default */.Z)(
                {},
                GRID_STRING_COL_DEF,
                {
                    type: "boolean",
                    align: "center",
                    headerAlign: "center",
                    renderCell: renderBooleanCell,
                    renderEditCell: renderEditBooleanCell,
                    sortComparator:
                        gridSortingUtils /* gridNumberComparator */.GH,
                    valueFormatter: gridBooleanFormatter,
                    filterOperators: getGridBooleanOperators(),
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/keyboardUtils.js
            const isEscapeKey = (key) => key === "Escape"; // TODO remove

            const isEnterKey = (key) => key === "Enter"; // TODO remove

            const isTabKey = (key) => key === "Tab"; // TODO remove

            const isSpaceKey = (key) => key === " ";
            const isArrowKeys = (key) => key.indexOf("Arrow") === 0;
            const isHomeOrEndKeys = (key) => key === "Home" || key === "End";
            const isPageKeys = (key) => key.indexOf("Page") === 0;
            const isDeleteKeys = (key) =>
                key === "Delete" || key === "Backspace";
            const printableCharRegex =
                /^(\p{L}|\p{M}\p{L}|\p{M}|\p{N}|\p{Z}|\p{S}|\p{P})$/iu;
            const isPrintableKey = (key) => printableCharRegex.test(key);
            const GRID_MULTIPLE_SELECTION_KEYS =
                /* unused pure expression or super */ null && [
                    "Meta",
                    "Control",
                    "Shift",
                ];
            const GRID_CELL_EXIT_EDIT_MODE_KEYS = ["Enter", "Escape", "Tab"];
            const GRID_CELL_EDIT_COMMIT_KEYS = ["Enter", "Tab"];
            const isMultipleKey = (key) =>
                GRID_MULTIPLE_SELECTION_KEYS.indexOf(key) > -1;
            const isCellEnterEditModeKeys = (key) =>
                isEnterKey(key) || isDeleteKeys(key) || isPrintableKey(key);
            const isCellExitEditModeKeys = (key) =>
                GRID_CELL_EXIT_EDIT_MODE_KEYS.indexOf(key) > -1;
            const isCellEditCommitKeys = (key) =>
                GRID_CELL_EDIT_COMMIT_KEYS.indexOf(key) > -1;
            const isNavigationKey = (key) =>
                isHomeOrEndKeys(key) ||
                isArrowKeys(key) ||
                isPageKeys(key) ||
                isSpaceKey(key);
            const isKeyboardEvent = (event) => !!event.key;
            const isHideMenuKey = (key) => isTabKey(key) || isEscapeKey(key); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/models/gridEditRowModel.js
            // TODO v6: rename to GridEditingState
            var GridEditModes;

            (function (GridEditModes) {
                GridEditModes["Cell"] = "cell";
                GridEditModes["Row"] = "row";
            })(GridEditModes || (GridEditModes = {}));

            var GridCellModes;

            (function (GridCellModes) {
                GridCellModes["Edit"] = "edit";
                GridCellModes["View"] = "view";
            })(GridCellModes || (GridCellModes = {}));

            var GridRowModes;

            (function (GridRowModes) {
                GridRowModes["Edit"] = "edit";
                GridRowModes["View"] = "view";
            })(GridRowModes || (GridRowModes = {})); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/cell/GridEditSingleSelectCell.js

            const GridEditSingleSelectCell_excluded = [
                "id",
                "value",
                "formattedValue",
                "api",
                "field",
                "row",
                "rowNode",
                "colDef",
                "cellMode",
                "isEditable",
                "tabIndex",
                "className",
                "getValue",
                "hasFocus",
                "isValidating",
                "isProcessingProps",
                "error",
            ];

            const GridEditSingleSelectCell_renderSingleSelectOptions = (
                option,
                OptionComponent
            ) => {
                const isOptionTypeObject = typeof option === "object";
                const key = isOptionTypeObject ? option.value : option;
                const value = isOptionTypeObject ? option.value : option;
                const content = isOptionTypeObject ? option.label : option;
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    OptionComponent,
                    {
                        value: value,
                        children: content,
                    },
                    key
                );
            };

            function GridEditSingleSelectCell(props) {
                var _rootProps$components,
                    _baseSelectProps$nati,
                    _rootProps$components2;

                const { id, value, api, field, row, colDef, hasFocus, error } =
                        props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridEditSingleSelectCell_excluded
                    );

                const ref = react.useRef();
                const inputRef = react.useRef();
                const rootProps = useGridRootProps();
                const [open, setOpen] = react.useState(
                    rootProps.editMode === "cell"
                );
                const baseSelectProps =
                    ((_rootProps$components = rootProps.componentsProps) == null
                        ? void 0
                        : _rootProps$components.baseSelect) || {};
                const isSelectNative =
                    (_baseSelectProps$nati = baseSelectProps.native) != null
                        ? _baseSelectProps$nati
                        : false;
                let valueOptionsFormatted;

                if (typeof colDef.valueOptions === "function") {
                    valueOptionsFormatted = colDef.valueOptions({
                        id,
                        row,
                        field,
                    });
                } else {
                    valueOptionsFormatted = colDef.valueOptions;
                }

                if (colDef.valueFormatter) {
                    valueOptionsFormatted = valueOptionsFormatted.map(
                        (option) => {
                            if (typeof option === "object") {
                                return option;
                            }

                            const params = {
                                field,
                                api,
                                value: option,
                            };
                            return {
                                value: option,
                                label: String(colDef.valueFormatter(params)),
                            };
                        }
                    );
                }

                const handleChange = async (event) => {
                    var _rootProps$experiment;

                    setOpen(false);
                    const target = event.target; // NativeSelect casts the value to a string.

                    const formattedTargetValue = getValueFromValueOptions(
                        target.value,
                        valueOptionsFormatted
                    );
                    const isValid = await api.setEditCellValue(
                        {
                            id,
                            field,
                            value: formattedTargetValue,
                        },
                        event
                    );

                    if (
                        (_rootProps$experiment =
                            rootProps.experimentalFeatures) != null &&
                        _rootProps$experiment.newEditingApi
                    ) {
                        return;
                    } // We use isValid === false because the default return is undefined which evaluates to true with !isValid

                    if (
                        rootProps.editMode === GridEditModes.Row ||
                        isValid === false
                    ) {
                        return;
                    }

                    const canCommit = await Promise.resolve(
                        api.commitCellChange(
                            {
                                id,
                                field,
                            },
                            event
                        )
                    );

                    if (canCommit) {
                        api.setCellMode(id, field, "view");

                        if (event.key) {
                            // TODO v6: remove once we stop ignoring events fired from portals
                            const params = api.getCellParams(id, field);
                            api.publishEvent(
                                gridEvents /* GridEvents.cellNavigationKeyDown */
                                    .t.cellNavigationKeyDown,
                                params,
                                event
                            );
                        }
                    }
                };

                const handleClose = (event, reason) => {
                    if (rootProps.editMode === GridEditModes.Row) {
                        setOpen(false);
                        return;
                    }

                    if (reason === "backdropClick" || isEscapeKey(event.key)) {
                        var _rootProps$experiment2;

                        if (
                            (_rootProps$experiment2 =
                                rootProps.experimentalFeatures) != null &&
                            _rootProps$experiment2.newEditingApi
                        ) {
                            api.stopCellEditMode({
                                id,
                                field,
                                ignoreModifications: true,
                            });
                        } else {
                            api.setCellMode(id, field, "view");
                        }
                    }
                };

                const handleOpen = () => {
                    setOpen(true);
                };

                (0, useEnhancedEffect /* default */.Z)(() => {
                    if (hasFocus) {
                        inputRef.current.focus();
                    }
                }, [hasFocus]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    rootProps.components.BaseSelect,
                    (0, esm_extends /* default */.Z)(
                        {
                            ref: ref,
                            inputRef: inputRef,
                            value: value,
                            onChange: handleChange,
                            open: open,
                            onOpen: handleOpen,
                            MenuProps: {
                                onClose: handleClose,
                            },
                            error: error,
                            native: isSelectNative,
                            fullWidth: true,
                        },
                        other,
                        (_rootProps$components2 = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components2.baseSelect,
                        {
                            children: valueOptionsFormatted.map(
                                (valueOptions) =>
                                    GridEditSingleSelectCell_renderSingleSelectOptions(
                                        valueOptions,
                                        isSelectNative
                                            ? "option"
                                            : MenuItem /* default */.Z
                                    )
                            ),
                        }
                    )
                );
            }

            false ? 0 : void 0;

            const renderEditSingleSelectCell = (params) =>
                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridEditSingleSelectCell,
                    (0, esm_extends /* default */.Z)({}, params)
                ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterInputSingleSelect.js
            const GridFilterInputSingleSelect_excluded = [
                "item",
                "applyValue",
                "type",
                "apiRef",
                "focusElementRef",
            ];

            const GridFilterInputSingleSelect_renderSingleSelectOptions = (
                { valueOptions, valueFormatter, field },
                api,
                OptionComponent
            ) => {
                const iterableColumnValues =
                    typeof valueOptions === "function"
                        ? [
                              "",
                              ...valueOptions({
                                  field,
                              }),
                          ]
                        : ["", ...(valueOptions || [])];
                return iterableColumnValues.map((option) => {
                    const isOptionTypeObject = typeof option === "object";
                    const key = isOptionTypeObject ? option.value : option;
                    const value = isOptionTypeObject ? option.value : option;
                    const formattedValue =
                        valueFormatter && option !== ""
                            ? valueFormatter({
                                  value: option,
                                  field,
                                  api,
                              })
                            : option;
                    const content = isOptionTypeObject
                        ? option.label
                        : formattedValue;
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        OptionComponent,
                        {
                            value: value,
                            children: content,
                        },
                        key
                    );
                });
            };

            function GridFilterInputSingleSelect(props) {
                var _item$value,
                    _rootProps$components,
                    _baseSelectProps$nati,
                    _rootProps$components2,
                    _rootProps$components3;

                const { item, applyValue, type, apiRef, focusElementRef } =
                        props,
                    others = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridFilterInputSingleSelect_excluded
                    );

                const [filterValueState, setFilterValueState] = react.useState(
                    (_item$value = item.value) != null ? _item$value : ""
                );
                const id = (0, useId /* default */.Z)();
                const rootProps = useGridRootProps();
                const baseSelectProps =
                    ((_rootProps$components = rootProps.componentsProps) == null
                        ? void 0
                        : _rootProps$components.baseSelect) || {};
                const isSelectNative =
                    (_baseSelectProps$nati = baseSelectProps.native) != null
                        ? _baseSelectProps$nati
                        : true;
                const currentColumn = item.columnField
                    ? apiRef.current.getColumn(item.columnField)
                    : null;
                const currentValueOptions = react.useMemo(() => {
                    return typeof currentColumn.valueOptions === "function"
                        ? currentColumn.valueOptions({
                              field: currentColumn.field,
                          })
                        : currentColumn.valueOptions;
                }, [currentColumn]);
                const onFilterChange = react.useCallback(
                    (event) => {
                        let value = event.target.value; // NativeSelect casts the value to a string.

                        value = getValueFromValueOptions(
                            value,
                            currentValueOptions
                        );
                        setFilterValueState(String(value));
                        applyValue(
                            (0, esm_extends /* default */.Z)({}, item, {
                                value,
                            })
                        );
                    },
                    [applyValue, item, currentValueOptions]
                );
                react.useEffect(() => {
                    var _itemValue;

                    let itemValue;

                    if (currentValueOptions !== undefined) {
                        // sanitize if valueOptions are provided
                        itemValue = getValueFromValueOptions(
                            item.value,
                            currentValueOptions
                        );

                        if (itemValue !== item.value) {
                            applyValue(
                                (0, esm_extends /* default */.Z)({}, item, {
                                    value: itemValue,
                                })
                            );
                            return;
                        }
                    } else {
                        itemValue = item.value;
                    }

                    itemValue =
                        (_itemValue = itemValue) != null ? _itemValue : "";
                    setFilterValueState(String(itemValue));
                }, [item, currentValueOptions, applyValue]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    rootProps.components.BaseTextField,
                    (0, esm_extends /* default */.Z)(
                        {
                            id: id,
                            label: apiRef.current.getLocaleText(
                                "filterPanelInputLabel"
                            ),
                            placeholder: apiRef.current.getLocaleText(
                                "filterPanelInputPlaceholder"
                            ),
                            value: filterValueState,
                            onChange: onFilterChange,
                            type: type || "text",
                            variant: "standard",
                            InputLabelProps: {
                                shrink: true,
                            },
                            inputRef: focusElementRef,
                            select: true,
                            SelectProps: (0, esm_extends /* default */.Z)(
                                {
                                    native: isSelectNative,
                                },
                                (_rootProps$components2 =
                                    rootProps.componentsProps) == null
                                    ? void 0
                                    : _rootProps$components2.baseSelect
                            ),
                        },
                        others,
                        (_rootProps$components3 = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components3.baseTextField,
                        {
                            children:
                                GridFilterInputSingleSelect_renderSingleSelectOptions(
                                    apiRef.current.getColumn(item.columnField),
                                    apiRef.current,
                                    isSelectNative
                                        ? "option"
                                        : MenuItem /* default */.Z
                                ),
                        }
                    )
                );
            }

            false ? 0 : void 0;

            // EXTERNAL MODULE: ./node_modules/@mui/base/AutocompleteUnstyled/useAutocomplete.js
            var useAutocomplete = __webpack_require__(5949); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterInputMultipleSingleSelect.js
            const GridFilterInputMultipleSingleSelect_excluded = [
                "item",
                "applyValue",
                "type",
                "apiRef",
                "focusElementRef",
            ];

            const isOptionEqualToValue = (option, value) =>
                getValueFromOption(option) === getValueFromOption(value);

            const filter = (0, useAutocomplete /* createFilterOptions */.D)();

            function GridFilterInputMultipleSingleSelect(props) {
                const { item, applyValue, apiRef, focusElementRef } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridFilterInputMultipleSingleSelect_excluded
                    );

                const id = (0, useId /* default */.Z)();
                const resolvedColumn = item.columnField
                    ? apiRef.current.getColumn(item.columnField)
                    : null;
                const resolvedValueOptions = react.useMemo(() => {
                    return typeof (resolvedColumn == null
                        ? void 0
                        : resolvedColumn.valueOptions) === "function"
                        ? resolvedColumn.valueOptions({
                              field: resolvedColumn.field,
                          })
                        : resolvedColumn == null
                        ? void 0
                        : resolvedColumn.valueOptions;
                }, [resolvedColumn]);
                const resolvedFormattedValueOptions = react.useMemo(() => {
                    return resolvedValueOptions == null
                        ? void 0
                        : resolvedValueOptions.map(getValueFromOption);
                }, [resolvedValueOptions]);
                const { valueFormatter, field } = apiRef.current.getColumn(
                    item.columnField
                );

                const filterValueOptionFormatter = (option) => {
                    if (typeof option === "object") {
                        return option.label;
                    }

                    return valueFormatter && option !== ""
                        ? valueFormatter({
                              value: option,
                              field,
                              api: apiRef.current,
                          })
                        : option;
                }; // The value is computed from the item.value and used directly
                // If it was done by a useEffect/useState, the Autocomplete could receive incoherent value and options

                const filterValues = react.useMemo(() => {
                    if (!Array.isArray(item.value)) {
                        return [];
                    }

                    if (resolvedValueOptions !== undefined) {
                        const itemValueIndexes = item.value.map((element) => {
                            // get the index matching between values and valueoptions
                            const formattedElement =
                                getValueFromOption(element);
                            const index =
                                (resolvedFormattedValueOptions == null
                                    ? void 0
                                    : resolvedFormattedValueOptions.findIndex(
                                          (formatedOption) =>
                                              formatedOption ===
                                              formattedElement
                                      )) || 0;
                            return index;
                        });
                        return itemValueIndexes
                            .filter((index) => index >= 0)
                            .map((index) => resolvedValueOptions[index]);
                    }

                    return item.value;
                }, [
                    item.value,
                    resolvedValueOptions,
                    resolvedFormattedValueOptions,
                ]);
                react.useEffect(() => {
                    if (
                        !Array.isArray(item.value) ||
                        filterValues.length !== item.value.length
                    ) {
                        // update the state if the filter value has been cleaned by the component
                        applyValue(
                            (0, esm_extends /* default */.Z)({}, item, {
                                value: filterValues.map(getValueFromOption),
                            })
                        );
                    }
                }, [item, filterValues, applyValue]);
                const handleChange = react.useCallback(
                    (event, value) => {
                        applyValue(
                            (0, esm_extends /* default */.Z)({}, item, {
                                value: [...value.map(getValueFromOption)],
                            })
                        );
                    },
                    [applyValue, item]
                );
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    Autocomplete /* default */.Z,
                    (0, esm_extends /* default */.Z)(
                        {
                            multiple: true,
                            freeSolo: false,
                            limitTags: 1,
                            options: resolvedValueOptions, // TODO: avoid `any`?
                            isOptionEqualToValue: isOptionEqualToValue,
                            filterOptions: filter,
                            id: id,
                            value: filterValues,
                            onChange: handleChange,
                            renderTags: (value, getTagProps) =>
                                value.map((option, index) =>
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        Chip /* default */.Z,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                variant: "outlined",
                                                size: "small",
                                                label: filterValueOptionFormatter(
                                                    option
                                                ),
                                            },
                                            getTagProps({
                                                index,
                                            })
                                        )
                                    )
                                ),
                            renderInput: (params) =>
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    TextField_TextField,
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        params,
                                        {
                                            label: apiRef.current.getLocaleText(
                                                "filterPanelInputLabel"
                                            ),
                                            placeholder:
                                                apiRef.current.getLocaleText(
                                                    "filterPanelInputPlaceholder"
                                                ),
                                            InputLabelProps: (0,
                                            esm_extends /* default */.Z)(
                                                {},
                                                params.InputLabelProps,
                                                {
                                                    shrink: true,
                                                }
                                            ),
                                            inputRef: focusElementRef,
                                            type: "singleSelect",
                                            variant: "standard",
                                        }
                                    )
                                ),
                        },
                        other
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridSingleSelectOperators.js

            const parseObjectValue = (value) => {
                if (value == null || typeof value !== "object") {
                    return value;
                }

                return value.value;
            };

            const getGridSingleSelectOperators = () => [
                {
                    value: "is",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            filterItem.value === ""
                        ) {
                            return null;
                        }

                        return ({ value }) =>
                            parseObjectValue(value) ===
                            parseObjectValue(filterItem.value);
                    },
                    InputComponent: GridFilterInputSingleSelect,
                },
                {
                    value: "not",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            filterItem.value == null ||
                            filterItem.value === ""
                        ) {
                            return null;
                        }

                        return ({ value }) =>
                            parseObjectValue(value) !==
                            parseObjectValue(filterItem.value);
                    },
                    InputComponent: GridFilterInputSingleSelect,
                },
                {
                    value: "isAnyOf",
                    getApplyFilterFn: (filterItem) => {
                        if (
                            !Array.isArray(filterItem.value) ||
                            filterItem.value.length === 0
                        ) {
                            return null;
                        }

                        const filterItemValues =
                            filterItem.value.map(parseObjectValue);
                        return ({ value }) =>
                            filterItemValues.includes(parseObjectValue(value));
                    },
                    InputComponent: GridFilterInputMultipleSingleSelect,
                },
            ]; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridSingleSelectColDef.js
            const GRID_SINGLE_SELECT_COL_DEF = (0, esm_extends /* default */.Z)(
                {},
                GRID_STRING_COL_DEF,
                {
                    type: "singleSelect",
                    renderEditCell: renderEditSingleSelectCell,
                    filterOperators: getGridSingleSelectOperators(),
                }
            );
            // EXTERNAL MODULE: ./node_modules/@mui/material/IconButton/IconButton.js + 1 modules
            var IconButton = __webpack_require__(3946);
            // EXTERNAL MODULE: ./node_modules/@mui/material/MenuList/MenuList.js + 3 modules
            var MenuList = __webpack_require__(2096);
            // EXTERNAL MODULE: ./node_modules/@mui/utils/esm/useForkRef.js
            var esm_useForkRef = __webpack_require__(432);
            // EXTERNAL MODULE: ./node_modules/@mui/utils/esm/useEventCallback.js
            var esm_useEventCallback = __webpack_require__(3633);
            // EXTERNAL MODULE: ./node_modules/@mui/utils/esm/ownerDocument.js
            var ownerDocument = __webpack_require__(7094); // CONCATENATED MODULE: ./node_modules/@mui/base/ClickAwayListener/ClickAwayListener.js
            // TODO: return `EventHandlerName extends `on${infer EventName}` ? Lowercase<EventName> : never` once generatePropTypes runs with TS 4.1

            function mapEventPropToEvent(eventProp) {
                return eventProp.substring(2).toLowerCase();
            }

            function clickedRootScrollbar(event, doc) {
                return (
                    doc.documentElement.clientWidth < event.clientX ||
                    doc.documentElement.clientHeight < event.clientY
                );
            }

            /**
             * Listen for click events that occur somewhere in the document, outside of the element itself.
             * For instance, if you need to hide a menu when people click anywhere else on your page.
             *
             * Demos:
             *
             * - [Click away listener](https://mui.com/base/react-click-away-listener/)
             *
             * API:
             *
             * - [ClickAwayListener API](https://mui.com/base/api/click-away-listener/)
             */
            function ClickAwayListener(props) {
                const {
                    children,
                    disableReactTree = false,
                    mouseEvent = "onClick",
                    onClickAway,
                    touchEvent = "onTouchEnd",
                } = props;
                const movedRef = react.useRef(false);
                const nodeRef = react.useRef(null);
                const activatedRef = react.useRef(false);
                const syntheticEventRef = react.useRef(false);
                react.useEffect(() => {
                    // Ensure that this component is not "activated" synchronously.
                    // https://github.com/facebook/react/issues/20074
                    setTimeout(() => {
                        activatedRef.current = true;
                    }, 0);
                    return () => {
                        activatedRef.current = false;
                    };
                }, []);
                const handleRef = (0, esm_useForkRef /* default */.Z)(
                    // @ts-expect-error TODO upstream fix
                    children.ref,
                    nodeRef
                ); // The handler doesn't take event.defaultPrevented into account:
                //
                // event.preventDefault() is meant to stop default behaviors like
                // clicking a checkbox to check it, hitting a button to submit a form,
                // and hitting left arrow to move the cursor in a text input etc.
                // Only special HTML elements have these default behaviors.

                const handleClickAway = (0,
                esm_useEventCallback /* default */.Z)((event) => {
                    // Given developers can stop the propagation of the synthetic event,
                    // we can only be confident with a positive value.
                    const insideReactTree = syntheticEventRef.current;
                    syntheticEventRef.current = false;
                    const doc = (0, ownerDocument /* default */.Z)(
                        nodeRef.current
                    ); // 1. IE11 support, which trigger the handleClickAway even after the unbind
                    // 2. The child might render null.
                    // 3. Behave like a blur listener.

                    if (
                        !activatedRef.current ||
                        !nodeRef.current ||
                        ("clientX" in event && clickedRootScrollbar(event, doc))
                    ) {
                        return;
                    } // Do not act if user performed touchmove

                    if (movedRef.current) {
                        movedRef.current = false;
                        return;
                    }

                    let insideDOM; // If not enough, can use https://github.com/DieterHolvoet/event-propagation-path/blob/master/propagationPath.js

                    if (event.composedPath) {
                        insideDOM =
                            event.composedPath().indexOf(nodeRef.current) > -1;
                    } else {
                        insideDOM =
                            !doc.documentElement.contains(
                                // @ts-expect-error returns `false` as intended when not dispatched from a Node
                                event.target
                            ) ||
                            nodeRef.current.contains(
                                // @ts-expect-error returns `false` as intended when not dispatched from a Node
                                event.target
                            );
                    }

                    if (!insideDOM && (disableReactTree || !insideReactTree)) {
                        onClickAway(event);
                    }
                }); // Keep track of mouse/touch events that bubbled up through the portal.

                const createHandleSynthetic = (handlerName) => (event) => {
                    syntheticEventRef.current = true;
                    const childrenPropsHandler = children.props[handlerName];

                    if (childrenPropsHandler) {
                        childrenPropsHandler(event);
                    }
                };

                const childrenProps = {
                    ref: handleRef,
                };

                if (touchEvent !== false) {
                    childrenProps[touchEvent] =
                        createHandleSynthetic(touchEvent);
                }

                react.useEffect(() => {
                    if (touchEvent !== false) {
                        const mappedTouchEvent =
                            mapEventPropToEvent(touchEvent);
                        const doc = (0, ownerDocument /* default */.Z)(
                            nodeRef.current
                        );

                        const handleTouchMove = () => {
                            movedRef.current = true;
                        };

                        doc.addEventListener(mappedTouchEvent, handleClickAway);
                        doc.addEventListener("touchmove", handleTouchMove);
                        return () => {
                            doc.removeEventListener(
                                mappedTouchEvent,
                                handleClickAway
                            );
                            doc.removeEventListener(
                                "touchmove",
                                handleTouchMove
                            );
                        };
                    }

                    return undefined;
                }, [handleClickAway, touchEvent]);

                if (mouseEvent !== false) {
                    childrenProps[mouseEvent] =
                        createHandleSynthetic(mouseEvent);
                }

                react.useEffect(() => {
                    if (mouseEvent !== false) {
                        const mappedMouseEvent =
                            mapEventPropToEvent(mouseEvent);
                        const doc = (0, ownerDocument /* default */.Z)(
                            nodeRef.current
                        );
                        doc.addEventListener(mappedMouseEvent, handleClickAway);
                        return () => {
                            doc.removeEventListener(
                                mappedMouseEvent,
                                handleClickAway
                            );
                        };
                    }

                    return undefined;
                }, [handleClickAway, mouseEvent]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(react.Fragment, {
                    children: /*#__PURE__*/ react.cloneElement(
                        children,
                        childrenProps
                    ),
                });
            }

            false ? 0 : void 0;

            if (false) {
            }

            /* harmony default export */ var ClickAwayListener_ClickAwayListener =
                ClickAwayListener;
            // EXTERNAL MODULE: ./node_modules/@mui/material/Grow/Grow.js
            var Grow = __webpack_require__(6514);
            // EXTERNAL MODULE: ./node_modules/@mui/material/Paper/Paper.js + 1 modules
            var Paper = __webpack_require__(5113);
            // EXTERNAL MODULE: ./node_modules/@mui/material/Popper/Popper.js + 53 modules
            var Popper = __webpack_require__(1849); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/GridMenu.js
            const GridMenu_excluded = [
                "open",
                "target",
                "onClickAway",
                "children",
                "position",
                "className",
                "onExited",
            ];

            const GridMenu_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["menu"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridMenuRoot = (0, styled /* default */.ZP)(
                Popper /* default */.Z,
                {
                    name: "MuiDataGrid",
                    slot: "Menu",
                    overridesResolver: (props, styles) => styles.menu,
                }
            )(({ theme }) => ({
                zIndex: theme.zIndex.modal,
                [`& .${gridClasses_gridClasses.menuList}`]: {
                    outline: 0,
                },
            }));
            const transformOrigin = {
                "bottom-start": "top left",
                "bottom-end": "top right",
            };

            const GridMenu = (props) => {
                var _rootProps$components;

                const {
                        open,
                        target,
                        onClickAway,
                        children,
                        position,
                        className,
                        onExited,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridMenu_excluded
                    );

                const prevTarget = react.useRef(target);
                const prevOpen = react.useRef(open);
                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridMenu_useUtilityClasses(ownerState);
                react.useEffect(() => {
                    if (prevOpen.current && prevTarget.current) {
                        prevTarget.current.focus();
                    }

                    prevOpen.current = open;
                    prevTarget.current = target;
                }, [open, target]);

                const handleExited = (popperOnExited) => (node) => {
                    if (popperOnExited) {
                        popperOnExited();
                    }

                    if (onExited) {
                        onExited(node);
                    }
                };

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridMenuRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            as: rootProps.components.BasePopper,
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                classes.root
                            ),
                            open: open,
                            anchorEl: target,
                            transition: true,
                            placement: position,
                        },
                        other,
                        (_rootProps$components = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components.basePopper,
                        {
                            children: ({ TransitionProps, placement }) =>
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    ClickAwayListener_ClickAwayListener,
                                    {
                                        onClickAway: onClickAway,
                                        mouseEvent: "onMouseDown",
                                        children: /*#__PURE__*/ (0,
                                        jsx_runtime.jsx)(
                                            Grow /* default */.Z,
                                            (0, esm_extends /* default */.Z)(
                                                {},
                                                TransitionProps,
                                                {
                                                    style: {
                                                        transformOrigin:
                                                            transformOrigin[
                                                                placement
                                                            ],
                                                    },
                                                    onExited: handleExited(
                                                        TransitionProps == null
                                                            ? void 0
                                                            : TransitionProps.onExited
                                                    ),
                                                    children: /*#__PURE__*/ (0,
                                                    jsx_runtime.jsx)(
                                                        Paper /* default */.Z,
                                                        {
                                                            children: children,
                                                        }
                                                    ),
                                                }
                                            )
                                        ),
                                    }
                                ),
                        }
                    )
                );
            };

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/cell/GridActionsCell.js

            const GridActionsCell_excluded = [
                "colDef",
                "id",
                "api",
                "hasFocus",
                "isEditable",
                "field",
                "value",
                "formattedValue",
                "row",
                "rowNode",
                "cellMode",
                "getValue",
                "tabIndex",
                "position",
                "focusElementRef",
            ];

            const hasActions = (colDef) =>
                typeof colDef.getActions === "function";

            const GridActionsCell = (props) => {
                const {
                        colDef,
                        id,
                        hasFocus,
                        tabIndex,
                        position = "bottom-end",
                        focusElementRef,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridActionsCell_excluded
                    );

                const [focusedButtonIndex, setFocusedButtonIndex] =
                    react.useState(-1);
                const [open, setOpen] = react.useState(false);
                const apiRef = useGridApiContext();
                const rootRef = react.useRef(null);
                const buttonRef = react.useRef(null);
                const ignoreCallToFocus = react.useRef(false);
                const touchRippleRefs = react.useRef({});
                const menuId = (0, useId /* default */.Z)();
                const buttonId = (0, useId /* default */.Z)();
                const rootProps = useGridRootProps();
                react.useLayoutEffect(() => {
                    if (!hasFocus) {
                        Object.entries(touchRippleRefs.current).forEach(
                            ([index, ref]) => {
                                ref == null
                                    ? void 0
                                    : ref.stop({}, () => {
                                          delete touchRippleRefs.current[index];
                                      });
                            }
                        );
                    }
                }, [hasFocus]);
                react.useEffect(() => {
                    if (focusedButtonIndex >= 0) {
                        var _rootRef$current;

                        const child =
                            (_rootRef$current = rootRef.current) == null
                                ? void 0
                                : _rootRef$current.children[focusedButtonIndex];
                        child.focus();
                    }
                }, [focusedButtonIndex]);
                react.useEffect(() => {
                    if (!hasFocus) {
                        setFocusedButtonIndex(-1);
                        ignoreCallToFocus.current = false;
                    }
                }, [hasFocus]);
                react.useImperativeHandle(
                    focusElementRef,
                    () => ({
                        focus() {
                            // If ignoreCallToFocus is true, then one of the buttons was clicked and the focus is already set
                            if (!ignoreCallToFocus.current) {
                                setFocusedButtonIndex(0);
                            }
                        },
                    }),
                    []
                );

                if (!hasActions(colDef)) {
                    throw new Error(
                        "MUI: Missing the `getActions` property in the `GridColDef`."
                    );
                }

                const options = colDef.getActions(
                    apiRef.current.getRowParams(id)
                );
                const iconButtons = options.filter(
                    (option) => !option.props.showInMenu
                );
                const menuButtons = options.filter(
                    (option) => option.props.showInMenu
                );
                const numberOfButtons =
                    iconButtons.length + (menuButtons.length ? 1 : 0);

                const showMenu = () => {
                    setOpen(true);
                    setFocusedButtonIndex(numberOfButtons - 1);
                    ignoreCallToFocus.current = true;
                };

                const hideMenu = () => {
                    setOpen(false);
                };

                const handleTouchRippleRef = (index) => (instance) => {
                    touchRippleRefs.current[index] = instance;
                };

                const handleButtonClick = (index, onClick) => (event) => {
                    setFocusedButtonIndex(index);
                    ignoreCallToFocus.current = true;

                    if (onClick) {
                        onClick(event);
                    }
                };

                const handleRootKeyDown = (event) => {
                    if (numberOfButtons <= 1) {
                        return;
                    }

                    let newIndex = focusedButtonIndex;

                    if (event.key === "ArrowRight") {
                        newIndex += 1;
                    } else if (event.key === "ArrowLeft") {
                        newIndex -= 1;
                    }

                    if (newIndex < 0 || newIndex >= numberOfButtons) {
                        return; // We're already in the first or last item = do nothing and let the grid listen the event
                    }

                    if (newIndex !== focusedButtonIndex) {
                        event.preventDefault(); // Prevent scrolling

                        event.stopPropagation(); // Don't stop propagation for other keys, e.g. ArrowUp

                        setFocusedButtonIndex(newIndex);
                    }
                };

                const handleListKeyDown = (event) => {
                    if (event.key === "Tab") {
                        event.preventDefault();
                    }

                    if (["Tab", "Enter", "Escape"].includes(event.key)) {
                        hideMenu();
                    }
                };

                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    "div",
                    (0, esm_extends /* default */.Z)(
                        {
                            role: "menu",
                            ref: rootRef,
                            tabIndex: -1,
                            className: gridClasses_gridClasses.actionsCell,
                            onKeyDown: handleRootKeyDown,
                        },
                        other,
                        {
                            children: [
                                iconButtons.map((button, index) =>
                                    /*#__PURE__*/ react.cloneElement(button, {
                                        key: index,
                                        touchRippleRef:
                                            handleTouchRippleRef(index),
                                        onClick: handleButtonClick(
                                            index,
                                            button.props.onClick
                                        ),
                                        tabIndex:
                                            focusedButtonIndex === index
                                                ? tabIndex
                                                : -1,
                                    })
                                ),
                                menuButtons.length > 0 &&
                                    buttonId &&
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        IconButton /* default */.Z,
                                        {
                                            ref: buttonRef,
                                            id: buttonId,
                                            "aria-label":
                                                apiRef.current.getLocaleText(
                                                    "actionsCellMore"
                                                ),
                                            "aria-controls": menuId,
                                            "aria-expanded": open
                                                ? "true"
                                                : undefined,
                                            "aria-haspopup": "true",
                                            role: "menuitem",
                                            size: "small",
                                            onClick: showMenu,
                                            touchRippleRef:
                                                handleTouchRippleRef(buttonId),
                                            tabIndex:
                                                focusedButtonIndex ===
                                                iconButtons.length
                                                    ? tabIndex
                                                    : -1,
                                            children: /*#__PURE__*/ (0,
                                            jsx_runtime.jsx)(
                                                rootProps.components
                                                    .MoreActionsIcon,
                                                {
                                                    fontSize: "small",
                                                }
                                            ),
                                        }
                                    ),
                                menuButtons.length > 0 &&
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        GridMenu,
                                        {
                                            onClickAway: hideMenu,
                                            onClick: hideMenu,
                                            open: open,
                                            target: buttonRef.current,
                                            position: position,
                                            children: /*#__PURE__*/ (0,
                                            jsx_runtime.jsx)(
                                                MenuList /* default */.Z,
                                                {
                                                    id: menuId,
                                                    className:
                                                        gridClasses_gridClasses.menuList,
                                                    onKeyDown:
                                                        handleListKeyDown,
                                                    "aria-labelledby": buttonId,
                                                    variant: "menu",
                                                    autoFocusItem: true,
                                                    children: menuButtons.map(
                                                        (button, index) =>
                                                            /*#__PURE__*/ react.cloneElement(
                                                                button,
                                                                {
                                                                    key: index,
                                                                }
                                                            )
                                                    ),
                                                }
                                            ),
                                        }
                                    ),
                            ],
                        }
                    )
                );
            };

            false ? 0 : void 0;

            const renderActionsCell = (params) =>
                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridActionsCell,
                    (0, esm_extends /* default */.Z)({}, params)
                ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridActionsColDef.js
            const GRID_ACTIONS_COLUMN_TYPE = "actions";
            const GRID_ACTIONS_COL_DEF = (0, esm_extends /* default */.Z)(
                {},
                GRID_STRING_COL_DEF,
                {
                    sortable: false,
                    filterable: false,
                    width: 100,
                    align: "center",
                    headerAlign: "center",
                    headerName: "",
                    disableColumnMenu: true,
                    disableExport: true,
                    renderCell: renderActionsCell,
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridDefaultColumnTypes.js
            const DEFAULT_GRID_COL_TYPE_KEY = "__default__";
            const getGridDefaultColumnTypes = () => {
                const nativeColumnTypes = {
                    string: GRID_STRING_COL_DEF,
                    number: GRID_NUMERIC_COL_DEF,
                    date: GRID_DATE_COL_DEF,
                    dateTime: GRID_DATETIME_COL_DEF,
                    boolean: GRID_BOOLEAN_COL_DEF,
                    singleSelect: GRID_SINGLE_SELECT_COL_DEF,
                    [GRID_ACTIONS_COLUMN_TYPE]: GRID_ACTIONS_COL_DEF,
                    [DEFAULT_GRID_COL_TYPE_KEY]: GRID_STRING_COL_DEF,
                };
                return nativeColumnTypes;
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js
            const COLUMNS_DIMENSION_PROPERTIES = [
                "maxWidth",
                "minWidth",
                "width",
                "flex",
            ];
            const computeColumnTypes = (customColumnTypes = {}) => {
                const mergedColumnTypes = (0, esm_extends /* default */.Z)(
                    {},
                    getGridDefaultColumnTypes()
                );

                Object.entries(customColumnTypes).forEach(
                    ([colType, colTypeDef]) => {
                        if (mergedColumnTypes[colType]) {
                            mergedColumnTypes[colType] = (0,
                            esm_extends /* default */.Z)(
                                {},
                                mergedColumnTypes[colType],
                                colTypeDef
                            );
                        } else {
                            mergedColumnTypes[colType] = (0,
                            esm_extends /* default */.Z)(
                                {},
                                mergedColumnTypes[
                                    colTypeDef.extendType ||
                                        DEFAULT_GRID_COL_TYPE_KEY
                                ],
                                colTypeDef
                            );
                        }
                    }
                );
                return mergedColumnTypes;
            };
            /**
             * Computes width for flex columns.
             * Based on CSS Flexbox specification:
             * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths
             */

            function computeFlexColumnsWidth({
                initialFreeSpace,
                totalFlexUnits,
                flexColumns,
            }) {
                const flexColumnsLookup = {
                    all: {},
                    frozenFields: [],
                    freeze: (field) => {
                        const value = flexColumnsLookup.all[field];

                        if (value && value.frozen !== true) {
                            flexColumnsLookup.all[field].frozen = true;
                            flexColumnsLookup.frozenFields.push(field);
                        }
                    },
                }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths

                function loopOverFlexItems() {
                    // 5a: If all the flex items on the line are frozen, free space has been distributed.
                    if (
                        flexColumnsLookup.frozenFields.length ===
                        flexColumns.length
                    ) {
                        return;
                    }

                    const violationsLookup = {
                        min: {},
                        max: {},
                    };
                    let remainingFreeSpace = initialFreeSpace;
                    let flexUnits = totalFlexUnits;
                    let totalViolation = 0; // 5b: Calculate the remaining free space

                    flexColumnsLookup.frozenFields.forEach((field) => {
                        remainingFreeSpace -=
                            flexColumnsLookup.all[field].computedWidth;
                        flexUnits -= flexColumnsLookup.all[field].flex;
                    });

                    for (let i = 0; i < flexColumns.length; i += 1) {
                        const column = flexColumns[i];

                        if (
                            flexColumnsLookup.all[column.field] &&
                            flexColumnsLookup.all[column.field].frozen === true
                        ) {
                            // eslint-disable-next-line no-continue
                            continue;
                        } // 5c: Distribute remaining free space proportional to the flex factors

                        const widthPerFlexUnit = remainingFreeSpace / flexUnits;
                        let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations

                        if (computedWidth < column.minWidth) {
                            totalViolation += column.minWidth - computedWidth;
                            computedWidth = column.minWidth;
                            violationsLookup.min[column.field] = true;
                        } else if (computedWidth > column.maxWidth) {
                            totalViolation += column.maxWidth - computedWidth;
                            computedWidth = column.maxWidth;
                            violationsLookup.max[column.field] = true;
                        }

                        flexColumnsLookup.all[column.field] = {
                            frozen: false,
                            computedWidth,
                            flex: column.flex,
                        };
                    } // 5e: Freeze over-flexed items

                    if (totalViolation < 0) {
                        // Freeze all the items with max violations
                        Object.keys(violationsLookup.max).forEach((field) => {
                            flexColumnsLookup.freeze(field);
                        });
                    } else if (totalViolation > 0) {
                        // Freeze all the items with min violations
                        Object.keys(violationsLookup.min).forEach((field) => {
                            flexColumnsLookup.freeze(field);
                        });
                    } else {
                        // Freeze all items
                        flexColumns.forEach(({ field }) => {
                            flexColumnsLookup.freeze(field);
                        });
                    } // 5f: Return to the start of this loop

                    loopOverFlexItems();
                }

                loopOverFlexItems();
                return flexColumnsLookup.all;
            }
            /**
             * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.
             * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.
             * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.
             * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.
             */

            const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {
                const columnsLookup = {};
                let totalFlexUnits = 0;
                let widthAllocatedBeforeFlex = 0;
                const flexColumns = []; // For the non-flex columns, compute their width
                // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation

                rawState.all.forEach((columnField) => {
                    const newColumn = (0, esm_extends /* default */.Z)(
                        {},
                        rawState.lookup[columnField]
                    );

                    if (rawState.columnVisibilityModel[columnField] === false) {
                        newColumn.computedWidth = 0;
                    } else {
                        let computedWidth;

                        if (newColumn.flex && newColumn.flex > 0) {
                            totalFlexUnits += newColumn.flex;
                            computedWidth = 0;
                            flexColumns.push(newColumn);
                        } else {
                            computedWidth = clamp(
                                newColumn.width,
                                newColumn.minWidth,
                                newColumn.maxWidth
                            );
                        }

                        widthAllocatedBeforeFlex += computedWidth;
                        newColumn.computedWidth = computedWidth;
                    }

                    columnsLookup[columnField] = newColumn;
                });
                const initialFreeSpace = Math.max(
                    viewportInnerWidth - widthAllocatedBeforeFlex,
                    0
                ); // Allocate the remaining space to the flex columns

                if (totalFlexUnits > 0 && viewportInnerWidth > 0) {
                    const computedColumnWidths = computeFlexColumnsWidth({
                        initialFreeSpace,
                        totalFlexUnits,
                        flexColumns,
                    });
                    Object.keys(computedColumnWidths).forEach((field) => {
                        columnsLookup[field].computedWidth =
                            computedColumnWidths[field].computedWidth;
                    });
                }

                return (0, esm_extends /* default */.Z)({}, rawState, {
                    lookup: columnsLookup,
                });
            };
            let columnTypeWarnedOnce = false;
            /**
             * Apply the order and the dimensions of the initial state.
             * The columns not registered in `orderedFields` will be placed after the imported columns.
             */

            const applyInitialState = (columnsState, initialState) => {
                if (!initialState) {
                    return columnsState;
                }

                const { orderedFields = [], dimensions = {} } = initialState;
                const columnsWithUpdatedDimensions = Object.keys(dimensions);

                if (
                    columnsWithUpdatedDimensions.length === 0 &&
                    orderedFields.length === 0
                ) {
                    return columnsState;
                }

                const orderedFieldsLookup = {};
                const cleanOrderedFields = [];

                for (let i = 0; i < orderedFields.length; i += 1) {
                    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state

                    if (columnsState.lookup[field]) {
                        orderedFieldsLookup[field] = true;
                        cleanOrderedFields.push(field);
                    }
                }

                const newOrderedFields =
                    cleanOrderedFields.length === 0
                        ? columnsState.all
                        : [
                              ...cleanOrderedFields,
                              ...columnsState.all.filter(
                                  (field) => !orderedFieldsLookup[field]
                              ),
                          ];

                const newColumnLookup = (0, esm_extends /* default */.Z)(
                    {},
                    columnsState.lookup
                );

                for (
                    let i = 0;
                    i < columnsWithUpdatedDimensions.length;
                    i += 1
                ) {
                    const field = columnsWithUpdatedDimensions[i];

                    const newColDef = (0, esm_extends /* default */.Z)(
                        {},
                        newColumnLookup[field],
                        {
                            hasBeenResized: true,
                        }
                    );

                    Object.entries(dimensions[field]).forEach(
                        ([key, value]) => {
                            newColDef[key] = value === -1 ? Infinity : value;
                        }
                    );
                    newColumnLookup[field] = newColDef;
                }

                const newColumnsState = {
                    all: newOrderedFields,
                    lookup: newColumnLookup,
                };
                return newColumnsState;
            };
            /**
             * @deprecated Should have been internal only, you can inline the logic.
             */

            const getGridColDef = (columnTypes, type) => {
                if (!type) {
                    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
                }

                if (false) {
                }

                if (!columnTypes[type]) {
                    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
                }

                return columnTypes[type];
            };
            const createColumnsState = ({
                apiRef,
                columnsToUpsert,
                initialState,
                columnTypes,
                currentColumnVisibilityModel = gridColumnVisibilityModelSelector(
                    apiRef
                ),
                shouldRegenColumnVisibilityModelFromColumns,
                keepOnlyColumnsToUpsert = false,
            }) => {
                var _apiRef$current$getRo,
                    _apiRef$current$getRo2,
                    _apiRef$current,
                    _apiRef$current$getRo3;

                const isInsideStateInitializer = !apiRef.current.state.columns;
                let columnsStateWithoutColumnVisibilityModel;

                if (isInsideStateInitializer) {
                    columnsStateWithoutColumnVisibilityModel = {
                        all: [],
                        lookup: {},
                    };
                } else {
                    const currentState = gridColumnsSelector(
                        apiRef.current.state
                    );
                    columnsStateWithoutColumnVisibilityModel = {
                        all: keepOnlyColumnsToUpsert
                            ? []
                            : [...currentState.all],
                        lookup: (0, esm_extends /* default */.Z)(
                            {},
                            currentState.lookup
                        ), // Will be cleaned later if keepOnlyColumnsToUpsert=true
                    };
                }

                let columnsToKeep = {};

                if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
                    columnsToKeep = Object.keys(
                        columnsStateWithoutColumnVisibilityModel.lookup
                    ).reduce(
                        (acc, key) =>
                            (0, esm_extends /* default */.Z)({}, acc, {
                                [key]: false,
                            }),
                        {}
                    );
                }

                const columnsToUpsertLookup = {};
                columnsToUpsert.forEach((newColumn) => {
                    const { field } = newColumn;
                    columnsToUpsertLookup[field] = true;
                    columnsToKeep[field] = true;
                    let existingState =
                        columnsStateWithoutColumnVisibilityModel.lookup[field];

                    if (existingState == null) {
                        // New Column
                        existingState = (0, esm_extends /* default */.Z)(
                            {},
                            getGridColDef(columnTypes, newColumn.type),
                            {
                                // TODO v6: Inline `getGridColDef`
                                field,
                                hasBeenResized: false,
                            }
                        );
                        columnsStateWithoutColumnVisibilityModel.all.push(
                            field
                        );
                    } else if (keepOnlyColumnsToUpsert) {
                        columnsStateWithoutColumnVisibilityModel.all.push(
                            field
                        );
                    }

                    let hasBeenResized = existingState.hasBeenResized;
                    COLUMNS_DIMENSION_PROPERTIES.forEach((key) => {
                        if (newColumn[key] !== undefined) {
                            hasBeenResized = true;

                            if (newColumn[key] === -1) {
                                newColumn[key] = Infinity;
                            }
                        }
                    });
                    columnsStateWithoutColumnVisibilityModel.lookup[field] = (0,
                    esm_extends /* default */.Z)(
                        {},
                        existingState,
                        {
                            hide:
                                newColumn.hide == null ? false : newColumn.hide,
                        },
                        newColumn,
                        {
                            hasBeenResized,
                        }
                    );
                });

                if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
                    Object.keys(
                        columnsStateWithoutColumnVisibilityModel.lookup
                    ).forEach((field) => {
                        if (!columnsToKeep[field]) {
                            delete columnsStateWithoutColumnVisibilityModel
                                .lookup[field];
                        }
                    });
                }

                const columnsLookupBeforePreProcessing = (0,
                esm_extends /* default */.Z)(
                    {},
                    columnsStateWithoutColumnVisibilityModel.lookup
                );

                const columnsStateWithPreProcessing =
                    apiRef.current.unstable_applyPipeProcessors(
                        "hydrateColumns",
                        columnsStateWithoutColumnVisibilityModel
                    ); // TODO v6: remove the sync between the columns `hide` option and the model.

                let columnVisibilityModel = {};

                if (shouldRegenColumnVisibilityModelFromColumns) {
                    let hasModelChanged = false;

                    const newColumnVisibilityModel = (0,
                    esm_extends /* default */.Z)(
                        {},
                        currentColumnVisibilityModel
                    );

                    if (isInsideStateInitializer) {
                        columnsStateWithPreProcessing.all.forEach((field) => {
                            newColumnVisibilityModel[field] =
                                !columnsStateWithoutColumnVisibilityModel
                                    .lookup[field].hide;
                        });
                    } else if (keepOnlyColumnsToUpsert) {
                        // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns
                        // passed via `columnToUpsert` + columns added by the pre-processors. We do the following
                        // cleanup because a given column may have been removed from the `columns` prop but it still
                        // exists in the state.
                        Object.keys(newColumnVisibilityModel).forEach(
                            (field) => {
                                if (
                                    !columnsStateWithPreProcessing.lookup[field]
                                ) {
                                    delete newColumnVisibilityModel[field];
                                    hasModelChanged = true;
                                }
                            }
                        );
                    }

                    columnsStateWithPreProcessing.all.forEach((field) => {
                        // If neither the `columnsToUpsert` nor the pre-processors updated the column,
                        // Then we don't want to update the visibility status of the column in the model.
                        if (
                            !columnsToUpsertLookup[field] &&
                            columnsLookupBeforePreProcessing[field] ===
                                columnsStateWithPreProcessing.lookup[field]
                        ) {
                            return;
                        } // We always assume that a column not in the model is visible by default. However, there's an
                        // edge case where the column is not in the model but it also doesn't exist in the `columns`
                        // prop, meaning that the column is being added. In that case, we assume that the column was
                        // not visible before for it be added to the model.

                        let isVisibleBefore =
                            currentColumnVisibilityModel[field];

                        if (isVisibleBefore === undefined) {
                            if (isInsideStateInitializer) {
                                isVisibleBefore = true;
                            } else {
                                const currentState = gridColumnsSelector(
                                    apiRef.current.state
                                );
                                isVisibleBefore = !!currentState.lookup[field];
                            }
                        }

                        const isVisibleAfter =
                            !columnsStateWithPreProcessing.lookup[field].hide;

                        if (isVisibleAfter !== isVisibleBefore) {
                            hasModelChanged = true;
                            newColumnVisibilityModel[field] = isVisibleAfter;
                        }
                    });

                    if (hasModelChanged || isInsideStateInitializer) {
                        columnVisibilityModel = newColumnVisibilityModel;
                    } else {
                        columnVisibilityModel = currentColumnVisibilityModel;
                    }
                } else {
                    columnVisibilityModel = currentColumnVisibilityModel;
                }

                const columnsStateWithPortableColumns = applyInitialState(
                    columnsStateWithPreProcessing,
                    initialState
                );

                const columnsState = (0, esm_extends /* default */.Z)(
                    {},
                    columnsStateWithPortableColumns,
                    {
                        columnVisibilityModel,
                    }
                );

                return hydrateColumnsWidth(
                    columnsState,
                    (_apiRef$current$getRo =
                        (_apiRef$current$getRo2 = (_apiRef$current =
                            apiRef.current).getRootDimensions) == null
                            ? void 0
                            : (_apiRef$current$getRo3 =
                                  _apiRef$current$getRo2.call(
                                      _apiRef$current
                                  )) == null
                            ? void 0
                            : _apiRef$current$getRo3.viewportInnerSize.width) !=
                        null
                        ? _apiRef$current$getRo
                        : 0
                );
            };
            const mergeColumnsState = (columnsState) => (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    columns: columnsState,
                });
            function getFirstNonSpannedColumnToRender({
                firstColumnToRender,
                apiRef,
                firstRowToRender,
                lastRowToRender,
                visibleRows,
            }) {
                let firstNonSpannedColumnToRender = firstColumnToRender;

                for (let i = firstRowToRender; i < lastRowToRender; i += 1) {
                    const row = visibleRows[i];

                    if (row) {
                        const rowId = visibleRows[i].id;
                        const cellColSpanInfo =
                            apiRef.current.unstable_getCellColSpanInfo(
                                rowId,
                                firstColumnToRender
                            );

                        if (
                            cellColSpanInfo &&
                            cellColSpanInfo.spannedByColSpan
                        ) {
                            firstNonSpannedColumnToRender =
                                cellColSpanInfo.leftVisibleCellIndex;
                        }
                    }
                }

                return firstNonSpannedColumnToRender;
            }
            function getFirstColumnIndexToRender({
                firstColumnIndex,
                minColumnIndex,
                columnBuffer,
                firstRowToRender,
                lastRowToRender,
                apiRef,
                visibleRows,
            }) {
                const initialFirstColumnToRender = Math.max(
                    firstColumnIndex - columnBuffer,
                    minColumnIndex
                );
                const firstColumnToRender = getFirstNonSpannedColumnToRender({
                    firstColumnToRender: initialFirstColumnToRender,
                    apiRef,
                    firstRowToRender,
                    lastRowToRender,
                    visibleRows,
                });
                return firstColumnToRender;
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/preferencesPanel/gridPreferencePanelsValue.js
            var GridPreferencePanelsValue;

            (function (GridPreferencePanelsValue) {
                GridPreferencePanelsValue["filters"] = "filters";
                GridPreferencePanelsValue["columns"] = "columns";
            })(GridPreferencePanelsValue || (GridPreferencePanelsValue = {})); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/columns/useGridColumns.js

            const columnsStateInitializer = (state, props, apiRef) => {
                var _props$initialState,
                    _props$initialState$c,
                    _props$initialState2,
                    _ref,
                    _props$columnVisibili,
                    _props$initialState3,
                    _props$initialState3$;

                const isUsingColumnVisibilityModel =
                    !!props.columnVisibilityModel ||
                    !!(
                        (_props$initialState = props.initialState) != null &&
                        (_props$initialState$c = _props$initialState.columns) !=
                            null &&
                        _props$initialState$c.columnVisibilityModel
                    );
                const columnsTypes = computeColumnTypes(props.columnTypes);
                const columnsState = createColumnsState({
                    apiRef,
                    columnTypes: columnsTypes,
                    columnsToUpsert: props.columns,
                    initialState:
                        (_props$initialState2 = props.initialState) == null
                            ? void 0
                            : _props$initialState2.columns,
                    shouldRegenColumnVisibilityModelFromColumns:
                        !isUsingColumnVisibilityModel,
                    currentColumnVisibilityModel:
                        (_ref =
                            (_props$columnVisibili =
                                props.columnVisibilityModel) != null
                                ? _props$columnVisibili
                                : (_props$initialState3 = props.initialState) ==
                                  null
                                ? void 0
                                : (_props$initialState3$ =
                                      _props$initialState3.columns) == null
                                ? void 0
                                : _props$initialState3$.columnVisibilityModel) !=
                        null
                            ? _ref
                            : {},
                    keepOnlyColumnsToUpsert: true,
                });
                return (0, esm_extends /* default */.Z)({}, state, {
                    columns: columnsState,
                });
            };
            /**
             * @requires useGridParamsApi (method)
             * @requires useGridDimensions (method, event) - can be after
             * TODO: Impossible priority - useGridParamsApi also needs to be after useGridColumns
             */

            function useGridColumns(apiRef, props) {
                var _props$initialState4,
                    _props$initialState4$,
                    _props$componentsProp2;

                const logger = useGridLogger(apiRef, "useGridColumns");
                const columnTypes = react.useMemo(
                    () => computeColumnTypes(props.columnTypes),
                    [props.columnTypes]
                );
                const previousColumnsProp = react.useRef(props.columns);
                const previousColumnTypesProp = react.useRef(columnTypes);
                /**
                 * If `initialState.columns.columnVisibilityModel` or `columnVisibilityModel` was defined during the 1st render, we are directly updating the model
                 * If not, we keep the old behavior and update the `GridColDef.hide` option (which will update the state model through the `GridColDef.hide` => `columnVisibilityModel` sync in `createColumnsState`
                 */

                const isUsingColumnVisibilityModel = react.useRef(
                    !!props.columnVisibilityModel ||
                        !!(
                            (_props$initialState4 = props.initialState) !=
                                null &&
                            (_props$initialState4$ =
                                _props$initialState4.columns) != null &&
                            _props$initialState4$.columnVisibilityModel
                        )
                );
                apiRef.current.unstable_updateControlState({
                    stateId: "visibleColumns",
                    propModel: props.columnVisibilityModel,
                    propOnChange: props.onColumnVisibilityModelChange,
                    stateSelector: gridColumnVisibilityModelSelector,
                    changeEvent:
                        gridEvents /* GridEvents.columnVisibilityModelChange */
                            .t.columnVisibilityModelChange,
                });
                const setGridColumnsState = react.useCallback(
                    (columnsState) => {
                        logger.debug("Updating columns state.");
                        apiRef.current.setState(
                            mergeColumnsState(columnsState)
                        );
                        apiRef.current.forceUpdate();
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.columnsChange */.t
                                .columnsChange,
                            columnsState.all
                        );
                    },
                    [logger, apiRef]
                );
                /**
                 * API METHODS
                 */

                const getColumn = react.useCallback(
                    (field) => gridColumnLookupSelector(apiRef)[field],
                    [apiRef]
                );
                const getAllColumns = react.useCallback(
                    () => gridColumnDefinitionsSelector(apiRef),
                    [apiRef]
                );
                const getVisibleColumns = react.useCallback(
                    () => gridVisibleColumnDefinitionsSelector(apiRef),
                    [apiRef]
                );
                const getColumnsMeta = react.useCallback(
                    () => gridColumnsMetaSelector(apiRef),
                    [apiRef]
                );
                const getColumnIndex = react.useCallback(
                    (field, useVisibleColumns = true) => {
                        const columns = useVisibleColumns
                            ? gridVisibleColumnDefinitionsSelector(apiRef)
                            : gridColumnDefinitionsSelector(apiRef);
                        return columns.findIndex((col) => col.field === field);
                    },
                    [apiRef]
                );
                const getColumnPosition = react.useCallback(
                    (field) => {
                        const index = getColumnIndex(field);
                        return gridColumnPositionsSelector(apiRef)[index];
                    },
                    [apiRef, getColumnIndex]
                );
                const setColumnVisibilityModel = react.useCallback(
                    (model) => {
                        const currentModel =
                            gridColumnVisibilityModelSelector(apiRef);

                        if (currentModel !== model) {
                            apiRef.current.setState((state) =>
                                (0, esm_extends /* default */.Z)({}, state, {
                                    columns: createColumnsState({
                                        apiRef,
                                        columnTypes,
                                        columnsToUpsert: [],
                                        initialState: undefined,
                                        shouldRegenColumnVisibilityModelFromColumns: false,
                                        currentColumnVisibilityModel: model,
                                        keepOnlyColumnsToUpsert: false,
                                    }),
                                })
                            );
                            apiRef.current.forceUpdate();
                        }
                    },
                    [apiRef, columnTypes]
                );
                const updateColumns = react.useCallback(
                    (columns) => {
                        const columnsState = createColumnsState({
                            apiRef,
                            columnTypes,
                            columnsToUpsert: columns,
                            initialState: undefined,
                            shouldRegenColumnVisibilityModelFromColumns: true,
                            keepOnlyColumnsToUpsert: false,
                        });
                        setGridColumnsState(columnsState);
                    },
                    [apiRef, setGridColumnsState, columnTypes]
                );
                const updateColumn = react.useCallback(
                    (column) => apiRef.current.updateColumns([column]),
                    [apiRef]
                );
                const setColumnVisibility = react.useCallback(
                    (field, isVisible) => {
                        // We keep updating the `hide` option of `GridColDef` when not controlling the model to avoid any breaking change.
                        // `updateColumns` take care of updating the model itself if needs be.
                        // TODO v6: stop using the `hide` field even when the model is not defined
                        if (isUsingColumnVisibilityModel.current) {
                            var _columnVisibilityMode;

                            const columnVisibilityModel =
                                gridColumnVisibilityModelSelector(apiRef);
                            const isCurrentlyVisible =
                                (_columnVisibilityMode =
                                    columnVisibilityModel[field]) != null
                                    ? _columnVisibilityMode
                                    : true;

                            if (isVisible !== isCurrentlyVisible) {
                                const newModel = (0,
                                esm_extends /* default */.Z)(
                                    {},
                                    columnVisibilityModel,
                                    {
                                        [field]: isVisible,
                                    }
                                );

                                apiRef.current.setColumnVisibilityModel(
                                    newModel
                                );
                            }
                        } else {
                            const column = apiRef.current.getColumn(field);

                            const newColumn = (0, esm_extends /* default */.Z)(
                                {},
                                column,
                                {
                                    hide: !isVisible,
                                }
                            );

                            apiRef.current.updateColumns([newColumn]);
                            const params = {
                                field,
                                colDef: newColumn,
                                isVisible,
                            };
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.columnVisibilityChange */
                                    .t.columnVisibilityChange,
                                params
                            );
                        }
                    },
                    [apiRef]
                );
                const setColumnIndex = react.useCallback(
                    (field, targetIndexPosition) => {
                        const allColumns = gridColumnFieldsSelector(apiRef);
                        const oldIndexPosition = allColumns.findIndex(
                            (col) => col === field
                        );

                        if (oldIndexPosition === targetIndexPosition) {
                            return;
                        }

                        logger.debug(
                            `Moving column ${field} to index ${targetIndexPosition}`
                        );
                        const updatedColumns = [...allColumns];
                        updatedColumns.splice(
                            targetIndexPosition,
                            0,
                            updatedColumns.splice(oldIndexPosition, 1)[0]
                        );
                        setGridColumnsState(
                            (0, esm_extends /* default */.Z)(
                                {},
                                gridColumnsSelector(apiRef.current.state),
                                {
                                    all: updatedColumns,
                                }
                            )
                        );
                        const params = {
                            field,
                            element:
                                apiRef.current.getColumnHeaderElement(field),
                            colDef: apiRef.current.getColumn(field),
                            targetIndex: targetIndexPosition,
                            oldIndex: oldIndexPosition,
                        };
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.columnOrderChange */.t
                                .columnOrderChange,
                            params
                        );
                    },
                    [apiRef, logger, setGridColumnsState]
                );
                const setColumnWidth = react.useCallback(
                    (field, width) => {
                        logger.debug(
                            `Updating column ${field} width to ${width}`
                        );
                        const column = apiRef.current.getColumn(field);

                        const newColumn = (0, esm_extends /* default */.Z)(
                            {},
                            column,
                            {
                                width,
                            }
                        );

                        apiRef.current.updateColumns([newColumn]);
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.columnWidthChange */.t
                                .columnWidthChange,
                            {
                                element:
                                    apiRef.current.getColumnHeaderElement(
                                        field
                                    ),
                                colDef: newColumn,
                                width,
                            }
                        );
                    },
                    [apiRef, logger]
                );
                const columnApi = {
                    getColumn,
                    getAllColumns,
                    getColumnIndex,
                    getColumnPosition,
                    getVisibleColumns,
                    getColumnsMeta,
                    updateColumn,
                    updateColumns,
                    setColumnVisibilityModel,
                    setColumnVisibility,
                    setColumnIndex,
                    setColumnWidth,
                };
                useGridApiMethod(apiRef, columnApi, "GridColumnApi");
                /**
                 * PRE-PROCESSING
                 */

                const stateExportPreProcessing = react.useCallback(
                    (prevState) => {
                        const columnsStateToExport = {};

                        if (isUsingColumnVisibilityModel.current) {
                            const columnVisibilityModelToExport =
                                gridColumnVisibilityModelSelector(apiRef);
                            const hasHiddenColumns = Object.values(
                                columnVisibilityModelToExport
                            ).some((value) => value === false);

                            if (hasHiddenColumns) {
                                columnsStateToExport.columnVisibilityModel =
                                    columnVisibilityModelToExport;
                            }
                        }

                        columnsStateToExport.orderedFields =
                            gridColumnFieldsSelector(apiRef);
                        const columns = gridColumnDefinitionsSelector(apiRef);
                        const dimensions = {};
                        columns.forEach((colDef) => {
                            if (colDef.hasBeenResized) {
                                const colDefDimensions = {};
                                COLUMNS_DIMENSION_PROPERTIES.forEach(
                                    (propertyName) => {
                                        let propertyValue =
                                            colDef[propertyName];

                                        if (propertyValue === Infinity) {
                                            propertyValue = -1;
                                        }

                                        colDefDimensions[propertyName] =
                                            propertyValue;
                                    }
                                );
                                dimensions[colDef.field] = colDefDimensions;
                            }
                        });

                        if (Object.keys(dimensions).length > 0) {
                            columnsStateToExport.dimensions = dimensions;
                        }

                        return (0, esm_extends /* default */.Z)({}, prevState, {
                            columns: columnsStateToExport,
                        });
                    },
                    [apiRef]
                );
                const stateRestorePreProcessing = react.useCallback(
                    (params, context) => {
                        var _context$stateToResto;

                        const columnVisibilityModelToImport =
                            isUsingColumnVisibilityModel.current
                                ? (_context$stateToResto =
                                      context.stateToRestore.columns) == null
                                    ? void 0
                                    : _context$stateToResto.columnVisibilityModel
                                : undefined;
                        const initialState = context.stateToRestore.columns;

                        if (
                            columnVisibilityModelToImport == null &&
                            initialState == null
                        ) {
                            return params;
                        }

                        const columnsState = createColumnsState({
                            apiRef,
                            columnTypes,
                            columnsToUpsert: [],
                            initialState,
                            shouldRegenColumnVisibilityModelFromColumns:
                                !isUsingColumnVisibilityModel.current,
                            currentColumnVisibilityModel:
                                columnVisibilityModelToImport,
                            keepOnlyColumnsToUpsert: false,
                        });
                        apiRef.current.setState(
                            mergeColumnsState(columnsState)
                        );

                        if (initialState != null) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.columnsChange */.t
                                    .columnsChange,
                                columnsState.all
                            );
                        }

                        return params;
                    },
                    [apiRef, columnTypes]
                );
                const preferencePanelPreProcessing = react.useCallback(
                    (initialValue, value) => {
                        if (value === GridPreferencePanelsValue.columns) {
                            var _props$componentsProp;

                            const ColumnsPanel = props.components.ColumnsPanel;
                            return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                ColumnsPanel,
                                (0, esm_extends /* default */.Z)(
                                    {},
                                    (_props$componentsProp =
                                        props.componentsProps) == null
                                        ? void 0
                                        : _props$componentsProp.columnsPanel
                                )
                            );
                        }

                        return initialValue;
                    },
                    [
                        props.components.ColumnsPanel,
                        (_props$componentsProp2 = props.componentsProps) == null
                            ? void 0
                            : _props$componentsProp2.columnsPanel,
                    ]
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "exportState",
                    stateExportPreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "restoreState",
                    stateRestorePreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "preferencePanel",
                    preferencePanelPreProcessing
                );
                /**
                 * EVENTS
                 */

                const prevInnerWidth = react.useRef(null);

                const handleGridSizeChange = (viewportInnerSize) => {
                    if (prevInnerWidth.current !== viewportInnerSize.width) {
                        prevInnerWidth.current = viewportInnerSize.width;
                        setGridColumnsState(
                            hydrateColumnsWidth(
                                gridColumnsSelector(apiRef.current.state),
                                viewportInnerSize.width
                            )
                        );
                    }
                };

                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.viewportInnerSizeChange */.t
                        .viewportInnerSizeChange,
                    handleGridSizeChange
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnVisibilityChange */.t
                        .columnVisibilityChange,
                    props.onColumnVisibilityChange
                );
                /**
                 * APPLIERS
                 */

                const hydrateColumns = react.useCallback(() => {
                    logger.info(
                        `Columns pipe processing have changed, regenerating the columns`
                    );
                    const columnsState = createColumnsState({
                        apiRef,
                        columnTypes,
                        columnsToUpsert: [],
                        initialState: undefined,
                        shouldRegenColumnVisibilityModelFromColumns:
                            !isUsingColumnVisibilityModel.current,
                        keepOnlyColumnsToUpsert: false,
                    });
                    setGridColumnsState(columnsState);
                }, [apiRef, logger, setGridColumnsState, columnTypes]);
                useGridRegisterPipeApplier(
                    apiRef,
                    "hydrateColumns",
                    hydrateColumns
                );
                /**
                 * EFFECTS
                 */
                // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`
                // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one

                const isFirstRender = react.useRef(true);
                react.useEffect(() => {
                    if (isFirstRender.current) {
                        isFirstRender.current = false;
                        return;
                    }

                    logger.info(
                        `GridColumns have changed, new length ${props.columns.length}`
                    );

                    if (
                        previousColumnsProp.current === props.columns &&
                        previousColumnTypesProp.current === columnTypes
                    ) {
                        return;
                    }

                    const columnsState = createColumnsState({
                        apiRef,
                        columnTypes,
                        initialState: undefined,
                        // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`
                        shouldRegenColumnVisibilityModelFromColumns:
                            !isUsingColumnVisibilityModel.current,
                        columnsToUpsert: props.columns,
                        keepOnlyColumnsToUpsert: true,
                    });
                    previousColumnsProp.current = props.columns;
                    previousColumnTypesProp.current = columnTypes;
                    setGridColumnsState(columnsState);
                }, [
                    logger,
                    apiRef,
                    setGridColumnsState,
                    props.columns,
                    columnTypes,
                ]);
                react.useEffect(() => {
                    if (props.columnVisibilityModel !== undefined) {
                        apiRef.current.setColumnVisibilityModel(
                            props.columnVisibilityModel
                        );
                    }
                }, [apiRef, logger, props.columnVisibilityModel]);
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/models/gridDensity.js
            /**
             * Available densities.
             */

            /**
             * Density enum.
             */
            var GridDensityTypes;

            (function (GridDensityTypes) {
                GridDensityTypes["Compact"] = "compact";
                GridDensityTypes["Standard"] = "standard";
                GridDensityTypes["Comfortable"] = "comfortable";
            })(GridDensityTypes || (GridDensityTypes = {})); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/density/useGridDensity.js

            const COMPACT_DENSITY_FACTOR = 0.7;
            const COMFORTABLE_DENSITY_FACTOR = 1.3; // TODO v6: revise keeping headerHeight and rowHeight in state

            const getUpdatedDensityState = (
                newDensity,
                newHeaderHeight,
                newRowHeight
            ) => {
                switch (newDensity) {
                    case GridDensityTypes.Compact:
                        return {
                            value: newDensity,
                            headerHeight: Math.floor(
                                newHeaderHeight * COMPACT_DENSITY_FACTOR
                            ),
                            rowHeight: Math.floor(
                                newRowHeight * COMPACT_DENSITY_FACTOR
                            ),
                            factor: COMPACT_DENSITY_FACTOR,
                        };

                    case GridDensityTypes.Comfortable:
                        return {
                            value: newDensity,
                            headerHeight: Math.floor(
                                newHeaderHeight * COMFORTABLE_DENSITY_FACTOR
                            ),
                            rowHeight: Math.floor(
                                newRowHeight * COMFORTABLE_DENSITY_FACTOR
                            ),
                            factor: COMFORTABLE_DENSITY_FACTOR,
                        };

                    default:
                        return {
                            value: newDensity,
                            headerHeight: newHeaderHeight,
                            rowHeight: newRowHeight,
                            factor: 1,
                        };
                }
            };

            const densityStateInitializer = (state, props) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    density: getUpdatedDensityState(
                        props.density,
                        props.headerHeight,
                        props.rowHeight
                    ),
                });
            const useGridDensity = (apiRef, props) => {
                const logger = useGridLogger(apiRef, "useDensity");
                const setDensity = react.useCallback(
                    (
                        newDensity,
                        newHeaderHeight = props.headerHeight,
                        newRowHeight = props.rowHeight
                    ) => {
                        logger.debug(`Set grid density to ${newDensity}`);
                        apiRef.current.setState((state) => {
                            const currentDensityState =
                                gridDensitySelector(state);
                            const newDensityState = getUpdatedDensityState(
                                newDensity,
                                newHeaderHeight,
                                newRowHeight
                            );

                            if (
                                isDeepEqual(
                                    currentDensityState,
                                    newDensityState
                                )
                            ) {
                                return state;
                            }

                            return (0, esm_extends /* default */.Z)({}, state, {
                                density: newDensityState,
                            });
                        });
                        apiRef.current.forceUpdate();
                    },
                    [logger, apiRef, props.headerHeight, props.rowHeight]
                );
                react.useEffect(() => {
                    apiRef.current.setDensity(
                        props.density,
                        props.headerHeight,
                        props.rowHeight
                    );
                }, [
                    apiRef,
                    props.density,
                    props.rowHeight,
                    props.headerHeight,
                ]);
                const densityApi = {
                    setDensity,
                };
                useGridApiMethod(apiRef, densityApi, "GridDensityApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/exportAs.js
            /**
             * I have hesitated to use https://github.com/eligrey/FileSaver.js.
             * If we get bug reports that this project solves, we should consider using it.
             *
             * Related resources.
             * https://blog.logrocket.com/programmatic-file-downloads-in-the-browser-9a5186298d5c/
             * https://github.com/mbrn/filefy/blob/ec4ed0b7415d93be7158c23029f2ea1fa0b8e2d9/src/core/BaseBuilder.ts
             * https://unpkg.com/browse/@progress/kendo-file-saver@1.0.7/dist/es/save-as.js
             * https://github.com/ag-grid/ag-grid/blob/9565c219b6210aa85fa833c929d0728f9d163a91/community-modules/csv-export/src/csvExport/downloader.ts
             */
            function exportAs(
                blob,
                extension = "csv",
                filename = document.title
            ) {
                const fullName = `${filename}.${extension}`; // Test download attribute first
                // https://github.com/eligrey/FileSaver.js/issues/193

                if ("download" in HTMLAnchorElement.prototype) {
                    // Create an object URL for the blob object
                    const url = URL.createObjectURL(blob); // Create a new anchor element

                    const a = document.createElement("a");
                    a.href = url;
                    a.download = fullName; // Programmatically trigger a click on the anchor element
                    // Useful if you want the download to happen automatically
                    // Without attaching the anchor element to the DOM

                    a.click(); // https://github.com/eligrey/FileSaver.js/issues/205

                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                    });
                    return;
                }

                throw new Error("MUI: exportAs not supported");
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnSelection/GridCellCheckboxRenderer.js
            const GridCellCheckboxRenderer_excluded = [
                "field",
                "id",
                "value",
                "formattedValue",
                "row",
                "rowNode",
                "colDef",
                "isEditable",
                "cellMode",
                "hasFocus",
                "tabIndex",
                "getValue",
                "api",
            ];

            const GridCellCheckboxRenderer_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["checkboxInput"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridCellCheckboxForwardRef = /*#__PURE__*/ react.forwardRef(
                function GridCellCheckboxRenderer(props, ref) {
                    var _rootProps$components;

                    const {
                            field,
                            id,
                            value: isChecked,
                            hasFocus,
                            tabIndex,
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridCellCheckboxRenderer_excluded
                        );

                    const apiRef = useGridApiContext();
                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridCellCheckboxRenderer_useUtilityClasses(ownerState);
                    const checkboxElement = react.useRef(null);
                    const rippleRef = react.useRef();
                    const handleRef = (0, useForkRef /* default */.Z)(
                        checkboxElement,
                        ref
                    );
                    const element = apiRef.current.getCellElement(id, field);

                    const handleChange = (event) => {
                        const params = {
                            value: event.target.checked,
                            id,
                        };
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.rowSelectionCheckboxChange */
                                .t.rowSelectionCheckboxChange,
                            params,
                            event
                        );
                    };

                    react.useLayoutEffect(() => {
                        if (tabIndex === 0 && element) {
                            element.tabIndex = -1;
                        }
                    }, [element, tabIndex]);
                    react.useLayoutEffect(() => {
                        if (hasFocus) {
                            var _checkboxElement$curr;

                            const input =
                                (_checkboxElement$curr =
                                    checkboxElement.current) == null
                                    ? void 0
                                    : _checkboxElement$curr.querySelector(
                                          "input"
                                      );
                            input == null ? void 0 : input.focus();
                        } else if (rippleRef.current) {
                            // Only available in @mui/material v5.4.1 or later
                            rippleRef.current.stop({});
                        }
                    }, [hasFocus]);
                    const handleKeyDown = react.useCallback(
                        (event) => {
                            if (isSpaceKey(event.key)) {
                                event.stopPropagation();
                            }

                            if (isNavigationKey(event.key) && !event.shiftKey) {
                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.cellNavigationKeyDown */
                                        .t.cellNavigationKeyDown,
                                    props,
                                    event
                                );
                            }
                        },
                        [apiRef, props]
                    );
                    const isSelectable =
                        !rootProps.isRowSelectable ||
                        rootProps.isRowSelectable(
                            apiRef.current.getRowParams(id)
                        );
                    const label = apiRef.current.getLocaleText(
                        isChecked
                            ? "checkboxSelectionUnselectRow"
                            : "checkboxSelectionSelectRow"
                    );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.BaseCheckbox,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: handleRef,
                                tabIndex: tabIndex,
                                checked: isChecked,
                                onChange: handleChange,
                                className: classes.root,
                                color: "primary",
                                inputProps: {
                                    "aria-label": label,
                                },
                                onKeyDown: handleKeyDown,
                                disabled: !isSelectable,
                                touchRippleRef: rippleRef,
                            },
                            (_rootProps$components =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components.baseCheckbox,
                            other
                        )
                    );
                }
            );
            false ? 0 : void 0;

            const GridCellCheckboxRenderer = /*#__PURE__*/ react.memo(
                GridCellCheckboxForwardRef
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/focus/gridFocusStateSelector.js
            const gridFocusStateSelector = (state) => state.focus;
            const gridFocusCellSelector = createSelector_createSelector(
                gridFocusStateSelector,
                (focusState) => focusState.cell
            );
            const gridFocusColumnHeaderSelector = createSelector_createSelector(
                gridFocusStateSelector,
                (focusState) => focusState.columnHeader
            );
            const gridTabIndexStateSelector = (state) => state.tabIndex;
            const gridTabIndexCellSelector = createSelector_createSelector(
                gridTabIndexStateSelector,
                (state) => state.cell
            );
            const gridTabIndexColumnHeaderSelector =
                createSelector_createSelector(
                    gridTabIndexStateSelector,
                    (state) => state.columnHeader
                ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/selection/gridSelectionSelector.js
            const gridSelectionStateSelector = (state) => state.selection;
            const selectedGridRowsCountSelector = createSelector_createSelector(
                gridSelectionStateSelector,
                (selection) => selection.length
            );
            const selectedGridRowsSelector = createSelector_createSelector(
                gridSelectionStateSelector,
                gridRowsLookupSelector,
                (selectedRows, rowsLookup) =>
                    new Map(selectedRows.map((id) => [id, rowsLookup[id]]))
            );
            const selectedIdsLookupSelector = createSelector_createSelector(
                gridSelectionStateSelector,
                (selection) =>
                    selection.reduce((lookup, rowId) => {
                        lookup[rowId] = rowId;
                        return lookup;
                    }, {})
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/pagination/gridPaginationSelector.js
            /**
             * @category Pagination
             * @ignore - do not document.
             */

            const gridPaginationSelector = (state) => state.pagination;
            /**
             * Get the index of the page to render if the pagination is enabled
             * @category Pagination
             */

            const gridPageSelector = createSelector_createSelector(
                gridPaginationSelector,
                (pagination) => pagination.page
            );
            /**
             * Get the maximum amount of rows to display on a single page if the pagination is enabled
             * @category Pagination
             */

            const gridPageSizeSelector = createSelector_createSelector(
                gridPaginationSelector,
                (pagination) => pagination.pageSize
            );
            /**
             * Get the amount of pages needed to display all the rows if the pagination is enabled
             * @category Pagination
             */

            const gridPageCountSelector = createSelector_createSelector(
                gridPaginationSelector,
                (pagination) => pagination.pageCount
            );
            /**
             * Get the index of the first and the last row to include in the current page if the pagination is enabled.
             * @category Pagination
             */

            const gridPaginationRowRangeSelector =
                createSelector_createSelector(
                    gridPaginationSelector,
                    gridRowTreeSelector,
                    gridRowTreeDepthSelector,
                    gridVisibleSortedRowEntriesSelector,
                    gridVisibleSortedTopLevelRowEntriesSelector,
                    (
                        pagination,
                        rowTree,
                        rowTreeDepth,
                        visibleSortedRowEntries,
                        visibleSortedTopLevelRowEntries
                    ) => {
                        const visibleTopLevelRowCount =
                            visibleSortedTopLevelRowEntries.length;
                        const topLevelFirstRowIndex = Math.min(
                            pagination.pageSize * pagination.page,
                            visibleTopLevelRowCount - 1
                        );
                        const topLevelLastRowIndex = Math.min(
                            topLevelFirstRowIndex + pagination.pageSize - 1,
                            visibleTopLevelRowCount - 1
                        ); // The range contains no element

                        if (
                            topLevelFirstRowIndex === -1 ||
                            topLevelLastRowIndex === -1
                        ) {
                            return null;
                        } // The tree is flat, there is no need to look for children

                        if (rowTreeDepth < 2) {
                            return {
                                firstRowIndex: topLevelFirstRowIndex,
                                lastRowIndex: topLevelLastRowIndex,
                            };
                        }

                        const topLevelFirstRow =
                            visibleSortedTopLevelRowEntries[
                                topLevelFirstRowIndex
                            ];
                        const topLevelRowsInCurrentPageCount =
                            topLevelLastRowIndex - topLevelFirstRowIndex + 1;
                        const firstRowIndex = visibleSortedRowEntries.findIndex(
                            (row) => row.id === topLevelFirstRow.id
                        );
                        let lastRowIndex = firstRowIndex;
                        let topLevelRowAdded = 0;

                        while (
                            lastRowIndex < visibleSortedRowEntries.length &&
                            topLevelRowAdded <= topLevelRowsInCurrentPageCount
                        ) {
                            const row = visibleSortedRowEntries[lastRowIndex];
                            const depth = rowTree[row.id].depth;

                            if (
                                topLevelRowAdded <
                                    topLevelRowsInCurrentPageCount ||
                                depth > 0
                            ) {
                                lastRowIndex += 1;
                            }

                            if (depth === 0) {
                                topLevelRowAdded += 1;
                            }
                        }

                        return {
                            firstRowIndex,
                            lastRowIndex: lastRowIndex - 1,
                        };
                    }
                );
            /**
             * Get the id and the model of each row to include in the current page if the pagination is enabled.
             * @category Pagination
             */

            const gridPaginatedVisibleSortedGridRowEntriesSelector =
                createSelector_createSelector(
                    gridVisibleSortedRowEntriesSelector,
                    gridPaginationRowRangeSelector,
                    (visibleSortedRowEntries, paginationRange) => {
                        if (!paginationRange) {
                            return [];
                        }

                        return visibleSortedRowEntries.slice(
                            paginationRange.firstRowIndex,
                            paginationRange.lastRowIndex + 1
                        );
                    }
                );
            /**
             * Get the id of each row to include in the current page if the pagination is enabled.
             * @category Pagination
             */

            const gridPaginatedVisibleSortedGridRowIdsSelector =
                createSelector_createSelector(
                    gridVisibleSortedRowIdsSelector,
                    gridPaginationRowRangeSelector,
                    (visibleSortedRowIds, paginationRange) => {
                        if (!paginationRange) {
                            return [];
                        }

                        return visibleSortedRowIds.slice(
                            paginationRange.firstRowIndex,
                            paginationRange.lastRowIndex + 1
                        );
                    }
                ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnSelection/GridHeaderCheckbox.js
            const GridHeaderCheckbox_excluded = ["field", "colDef"];

            const GridHeaderCheckbox_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["checkboxInput"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridHeaderCheckbox = /*#__PURE__*/ react.forwardRef(
                function GridHeaderCheckbox(props, ref) {
                    var _rootProps$components;

                    const other = (0,
                    objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridHeaderCheckbox_excluded
                    );

                    const [, forceUpdate] = react.useState(false);
                    const apiRef = useGridApiContext();
                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridHeaderCheckbox_useUtilityClasses(ownerState);
                    const tabIndexState = useGridSelector(
                        apiRef,
                        gridTabIndexColumnHeaderSelector
                    );
                    const selection = useGridSelector(
                        apiRef,
                        gridSelectionStateSelector
                    );
                    const visibleRowIds = useGridSelector(
                        apiRef,
                        gridVisibleSortedRowIdsSelector
                    );
                    const paginatedVisibleRowIds = useGridSelector(
                        apiRef,
                        gridPaginatedVisibleSortedGridRowIdsSelector
                    );
                    const filteredSelection = react.useMemo(() => {
                        if (typeof rootProps.isRowSelectable !== "function") {
                            return selection;
                        }

                        return selection.filter((id) => {
                            // The row might have been deleted
                            if (!apiRef.current.getRow(id)) {
                                return false;
                            }

                            return rootProps.isRowSelectable(
                                apiRef.current.getRowParams(id)
                            );
                        });
                    }, [apiRef, rootProps.isRowSelectable, selection]); // All the rows that could be selected / unselected by toggling this checkbox

                    const selectionCandidates = react.useMemo(() => {
                        const rowIds =
                            !rootProps.pagination ||
                            !rootProps.checkboxSelectionVisibleOnly
                                ? visibleRowIds
                                : paginatedVisibleRowIds; // Convert to an object to make O(1) checking if a row exists or not
                        // TODO create selector that returns visibleRowIds/paginatedVisibleRowIds as an object

                        return rowIds.reduce((acc, id) => {
                            acc[id] = true;
                            return acc;
                        }, {});
                    }, [
                        rootProps.pagination,
                        rootProps.checkboxSelectionVisibleOnly,
                        paginatedVisibleRowIds,
                        visibleRowIds,
                    ]); // Amount of rows selected and that are visible in the current page

                    const currentSelectionSize = react.useMemo(
                        () =>
                            filteredSelection.filter(
                                (id) => selectionCandidates[id]
                            ).length,
                        [filteredSelection, selectionCandidates]
                    );
                    const isIndeterminate =
                        currentSelectionSize > 0 &&
                        currentSelectionSize <
                            Object.keys(selectionCandidates).length;
                    const isChecked = currentSelectionSize > 0;

                    const handleChange = (event) => {
                        const params = {
                            value: event.target.checked,
                        };
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.headerSelectionCheckboxChange */
                                .t.headerSelectionCheckboxChange,
                            params
                        );
                    };

                    const tabIndex =
                        tabIndexState !== null &&
                        tabIndexState.field === props.field
                            ? 0
                            : -1;
                    react.useLayoutEffect(() => {
                        const element = apiRef.current.getColumnHeaderElement(
                            props.field
                        );

                        if (tabIndex === 0 && element) {
                            element.tabIndex = -1;
                        }
                    }, [tabIndex, apiRef, props.field]);
                    const handleKeyDown = react.useCallback(
                        (event) => {
                            if (event.key === " ") {
                                // imperative toggle the checkbox because Space is disable by some preventDefault
                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.headerSelectionCheckboxChange */
                                        .t.headerSelectionCheckboxChange,
                                    {
                                        value: !isChecked,
                                    }
                                );
                            } // TODO v6 remove columnHeaderNavigationKeyDown events which are not used internally anymore

                            if (isNavigationKey(event.key) && !event.shiftKey) {
                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.columnHeaderNavigationKeyDown */
                                        .t.columnHeaderNavigationKeyDown,
                                    props,
                                    event
                                );
                            }
                        },
                        [apiRef, props, isChecked]
                    );
                    const handleSelectionChange = react.useCallback(() => {
                        forceUpdate((p) => !p);
                    }, []);
                    react.useEffect(() => {
                        return apiRef.current.subscribeEvent(
                            gridEvents /* GridEvents.selectionChange */.t
                                .selectionChange,
                            handleSelectionChange
                        );
                    }, [apiRef, handleSelectionChange]);
                    const label = apiRef.current.getLocaleText(
                        isChecked
                            ? "checkboxSelectionUnselectAllRows"
                            : "checkboxSelectionSelectAllRows"
                    );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.BaseCheckbox,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                indeterminate: isIndeterminate,
                                checked: isChecked,
                                onChange: handleChange,
                                className: classes.root,
                                color: "primary",
                                inputProps: {
                                    "aria-label": label,
                                },
                                tabIndex: tabIndex,
                                onKeyDown: handleKeyDown,
                            },
                            (_rootProps$components =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components.baseCheckbox,
                            other
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/colDef/gridCheckboxSelectionColDef.js

            const GRID_CHECKBOX_SELECTION_COL_DEF = (0,
            esm_extends /* default */.Z)({}, GRID_BOOLEAN_COL_DEF, {
                field: "__check__",
                type: "checkboxSelection",
                width: 50,
                resizable: false,
                sortable: false,
                filterable: false,
                disableColumnMenu: true,
                disableReorder: true,
                disableExport: true,
                valueGetter: (params) => {
                    const selectionLookup = selectedIdsLookupSelector(
                        params.api.state,
                        params.api.instanceId
                    );
                    return selectionLookup[params.id] !== undefined;
                },
                renderHeader: (params) =>
                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridHeaderCheckbox,
                        (0, esm_extends /* default */.Z)({}, params)
                    ),
                renderCell: (params) =>
                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridCellCheckboxRenderer,
                        (0, esm_extends /* default */.Z)({}, params)
                    ),
            }); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/export/serializers/csvSerializer.js
            const serialiseCellValue = (value, delimiterCharacter) => {
                if (typeof value === "string") {
                    const formattedValue = value.replace(/"/g, '""'); // Make sure value containing delimiter or line break won't be split into multiple rows

                    if (
                        [delimiterCharacter, "\n", "\r"].some((delimiter) =>
                            formattedValue.includes(delimiter)
                        )
                    ) {
                        return `"${formattedValue}"`;
                    }

                    return formattedValue;
                }

                return value;
            };

            const objectFormattedValueWarning = (0,
            warning /* buildWarning */.b)([
                "MUI: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.",
                "You can provide a `valueFormatter` with a string representation to be used.",
            ]);

            const serialiseRow = (
                id,
                columns,
                getCellParams,
                delimiterCharacter
            ) =>
                columns.map((column) => {
                    const cellParams = getCellParams(id, column.field);

                    if (false) {
                    }

                    return serialiseCellValue(
                        cellParams.formattedValue,
                        delimiterCharacter
                    );
                });

            function buildCSV(options) {
                const {
                    columns,
                    rowIds,
                    getCellParams,
                    delimiterCharacter,
                    includeHeaders,
                } = options;
                const CSVBody = rowIds
                    .reduce(
                        (acc, id) =>
                            `${acc}${serialiseRow(
                                id,
                                columns,
                                getCellParams,
                                delimiterCharacter
                            ).join(delimiterCharacter)}\r\n`,
                        ""
                    )
                    .trim();

                if (!includeHeaders) {
                    return CSVBody;
                }

                const CSVHead = `${columns
                    .filter(
                        (column) =>
                            column.field !==
                            GRID_CHECKBOX_SELECTION_COL_DEF.field
                    )
                    .map((column) =>
                        serialiseCellValue(
                            column.headerName || column.field,
                            delimiterCharacter
                        )
                    )
                    .join(delimiterCharacter)}\r\n`;
                return `${CSVHead}${CSVBody}`.trim();
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/export/utils.js
            const getColumnsToExport = ({ apiRef, options }) => {
                const columns = gridColumnDefinitionsSelector(apiRef);

                if (options.fields) {
                    return options.fields
                        .map((field) =>
                            columns.find((column) => column.field === field)
                        )
                        .filter((column) => !!column);
                }

                const validColumns = options.allColumns
                    ? columns
                    : gridVisibleColumnDefinitionsSelector(apiRef);
                return validColumns.filter((column) => !column.disableExport);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/export/useGridCsvExport.js
            const defaultGetRowsToExport = ({ apiRef }) => {
                const filteredSortedRowIds =
                    gridFilteredSortedRowIdsSelector(apiRef);
                const selectedRows = apiRef.current.getSelectedRows();

                if (selectedRows.size > 0) {
                    return filteredSortedRowIds.filter((id) =>
                        selectedRows.has(id)
                    );
                }

                return filteredSortedRowIds;
            };
            /**
             * @requires useGridColumns (state)
             * @requires useGridFilter (state)
             * @requires useGridSorting (state)
             * @requires useGridSelection (state)
             * @requires useGridParamsApi (method)
             */

            const useGridCsvExport = (apiRef) => {
                const logger = useGridLogger(apiRef, "useGridCsvExport");
                const getDataAsCsv = react.useCallback(
                    (options = {}) => {
                        var _options$getRowsToExp, _options$includeHeade;

                        logger.debug(`Get data as CSV`);
                        const exportedColumns = getColumnsToExport({
                            apiRef,
                            options,
                        });
                        const getRowsToExport =
                            (_options$getRowsToExp = options.getRowsToExport) !=
                            null
                                ? _options$getRowsToExp
                                : defaultGetRowsToExport;
                        const exportedRowIds = getRowsToExport({
                            apiRef,
                        });
                        return buildCSV({
                            columns: exportedColumns,
                            rowIds: exportedRowIds,
                            getCellParams: apiRef.current.getCellParams,
                            delimiterCharacter: options.delimiter || ",",
                            includeHeaders:
                                (_options$includeHeade =
                                    options.includeHeaders) != null
                                    ? _options$includeHeade
                                    : true,
                        });
                    },
                    [logger, apiRef]
                );
                const exportDataAsCsv = react.useCallback(
                    (options) => {
                        logger.debug(`Export data as CSV`);
                        const csv = getDataAsCsv(options);
                        const blob = new Blob(
                            [
                                options != null && options.utf8WithBom
                                    ? new Uint8Array([0xef, 0xbb, 0xbf])
                                    : "",
                                csv,
                            ],
                            {
                                type: "text/csv",
                            }
                        );
                        exportAs(
                            blob,
                            "csv",
                            options == null ? void 0 : options.fileName
                        );
                    },
                    [logger, getDataAsCsv]
                );
                const csvExportApi = {
                    getDataAsCsv,
                    exportDataAsCsv,
                };
                useGridApiMethod(apiRef, csvExportApi, "GridCsvExportApi");
            };
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/ownerDocument.js
            var utils_ownerDocument = __webpack_require__(8038); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/rows/gridRowsMetaSelector.js
            const gridRowsMetaSelector = (state) => state.rowsMeta; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/export/useGridPrintExport.js
            /**
             * @requires useGridColumns (state)
             * @requires useGridFilter (state)
             * @requires useGridSorting (state)
             * @requires useGridParamsApi (method)
             */
            const useGridPrintExport = (apiRef, props) => {
                const logger = useGridLogger(apiRef, "useGridPrintExport");
                const doc = react.useRef(null);
                const previousGridState = react.useRef(null);
                const previousColumnVisibility = react.useRef({});
                react.useEffect(() => {
                    doc.current = (0, utils_ownerDocument /* default */.Z)(
                        apiRef.current.rootElementRef.current
                    );
                }, [apiRef]); // Returns a promise because updateColumns triggers state update and
                // the new state needs to be in place before the grid can be sized correctly

                const updateGridColumnsForPrint = react.useCallback(
                    (fields, allColumns) =>
                        new Promise((resolve) => {
                            if (!fields && !allColumns) {
                                resolve();
                                return;
                            }

                            const exportedColumnFields = getColumnsToExport({
                                apiRef,
                                options: {
                                    fields,
                                    allColumns,
                                },
                            }).map((column) => column.field);
                            const columns =
                                gridColumnDefinitionsSelector(apiRef);
                            const newColumnVisibilityModel = {};
                            columns.forEach((column) => {
                                newColumnVisibilityModel[column.field] =
                                    exportedColumnFields.includes(column.field);
                            });
                            apiRef.current.setColumnVisibilityModel(
                                newColumnVisibilityModel
                            );
                            resolve();
                        }),
                    [apiRef]
                );
                const buildPrintWindow = react.useCallback((title) => {
                    const iframeEl = document.createElement("iframe");
                    iframeEl.id = "grid-print-window"; // Without this 'onload' event won't fire in some browsers

                    iframeEl.src = window.location.href;
                    iframeEl.style.position = "absolute";
                    iframeEl.style.width = "0px";
                    iframeEl.style.height = "0px";
                    iframeEl.title = title || document.title;
                    return iframeEl;
                }, []);
                const handlePrintWindowLoad = react.useCallback(
                    (printWindow, options) => {
                        var _printWindow$contentW,
                            _querySelector,
                            _querySelector2;

                        const normalizeOptions = (0,
                        esm_extends /* default */.Z)(
                            {
                                copyStyles: true,
                                hideToolbar: false,
                                hideFooter: false,
                            },
                            options
                        ); // Some agents, such as IE11 and Enzyme (as of 2 Jun 2020) continuously call the
                        // `onload` callback. This ensures that it is only called once.

                        printWindow.onload = null;
                        const printDoc =
                            printWindow.contentDocument ||
                            ((_printWindow$contentW =
                                printWindow.contentWindow) == null
                                ? void 0
                                : _printWindow$contentW.document);

                        if (!printDoc) {
                            return;
                        }

                        const headerHeight =
                            gridDensityHeaderHeightSelector(apiRef);
                        const rowsMeta = gridRowsMetaSelector(
                            apiRef.current.state
                        );
                        const gridRootElement =
                            apiRef.current.rootElementRef.current;
                        const gridClone = gridRootElement.cloneNode(true);
                        const gridCloneViewport = gridClone.querySelector(
                            `.${gridClasses_gridClasses.virtualScroller}`
                        ); // Expand the viewport window to prevent clipping

                        gridCloneViewport.style.height = "auto";
                        gridCloneViewport.style.width = "auto";
                        gridCloneViewport.parentElement.style.width = "auto";
                        gridCloneViewport.parentElement.style.height = "auto"; // Allow to overflow to not hide the border of the last row

                        const gridMain = gridClone.querySelector(
                            `.${gridClasses_gridClasses.main}`
                        );
                        gridMain.style.overflow = "visible";
                        const columnHeaders = gridClone.querySelector(
                            `.${gridClasses_gridClasses.columnHeaders}`
                        );
                        const columnHeadersInner = columnHeaders.querySelector(
                            `.${gridClasses_gridClasses.columnHeadersInner}`
                        );
                        columnHeadersInner.style.width = "100%";
                        let gridToolbarElementHeight =
                            ((_querySelector = gridRootElement.querySelector(
                                `.${gridClasses_gridClasses.toolbarContainer}`
                            )) == null
                                ? void 0
                                : _querySelector.clientHeight) || 0;
                        let gridFooterElementHeight =
                            ((_querySelector2 = gridRootElement.querySelector(
                                `.${gridClasses_gridClasses.footerContainer}`
                            )) == null
                                ? void 0
                                : _querySelector2.clientHeight) || 0;

                        if (normalizeOptions.hideToolbar) {
                            var _gridClone$querySelec;

                            (_gridClone$querySelec = gridClone.querySelector(
                                `.${gridClasses_gridClasses.toolbarContainer}`
                            )) == null
                                ? void 0
                                : _gridClone$querySelec.remove();
                            gridToolbarElementHeight = 0;
                        }

                        if (normalizeOptions.hideFooter) {
                            var _gridClone$querySelec2;

                            (_gridClone$querySelec2 = gridClone.querySelector(
                                `.${gridClasses_gridClasses.footerContainer}`
                            )) == null
                                ? void 0
                                : _gridClone$querySelec2.remove();
                            gridFooterElementHeight = 0;
                        } // Expand container height to accommodate all rows

                        gridClone.style.height = `${
                            rowsMeta.currentPageTotalHeight +
                            headerHeight +
                            gridToolbarElementHeight +
                            gridFooterElementHeight
                        }px`; // Remove all loaded elements from the current host

                        printDoc.body.innerHTML = "";
                        printDoc.body.appendChild(gridClone);
                        const defaultPageStyle =
                            typeof normalizeOptions.pageStyle === "function"
                                ? normalizeOptions.pageStyle()
                                : normalizeOptions.pageStyle;

                        if (typeof defaultPageStyle === "string") {
                            // TODO custom styles should always win
                            const styleElement =
                                printDoc.createElement("style");
                            styleElement.appendChild(
                                printDoc.createTextNode(defaultPageStyle)
                            );
                            printDoc.head.appendChild(styleElement);
                        }

                        if (normalizeOptions.bodyClassName) {
                            printDoc.body.classList.add(
                                ...normalizeOptions.bodyClassName.split(" ")
                            );
                        }

                        if (normalizeOptions.copyStyles) {
                            const headStyleElements =
                                doc.current.querySelectorAll(
                                    "style, link[rel='stylesheet']"
                                );

                            for (
                                let i = 0;
                                i < headStyleElements.length;
                                i += 1
                            ) {
                                const node = headStyleElements[i];

                                if (node.tagName === "STYLE") {
                                    const newHeadStyleElements =
                                        printDoc.createElement(node.tagName);
                                    const sheet = node.sheet;

                                    if (sheet) {
                                        let styleCSS = ""; // NOTE: for-of is not supported by IE

                                        for (
                                            let j = 0;
                                            j < sheet.cssRules.length;
                                            j += 1
                                        ) {
                                            if (
                                                typeof sheet.cssRules[j]
                                                    .cssText === "string"
                                            ) {
                                                styleCSS += `${sheet.cssRules[j].cssText}\r\n`;
                                            }
                                        }

                                        newHeadStyleElements.appendChild(
                                            printDoc.createTextNode(styleCSS)
                                        );
                                        printDoc.head.appendChild(
                                            newHeadStyleElements
                                        );
                                    }
                                } else if (node.getAttribute("href")) {
                                    // If `href` tag is empty, avoid loading these links
                                    const newHeadStyleElements =
                                        printDoc.createElement(node.tagName);

                                    for (
                                        let j = 0;
                                        j < node.attributes.length;
                                        j += 1
                                    ) {
                                        const attr = node.attributes[j];

                                        if (attr) {
                                            newHeadStyleElements.setAttribute(
                                                attr.nodeName,
                                                attr.nodeValue || ""
                                            );
                                        }
                                    }

                                    printDoc.head.appendChild(
                                        newHeadStyleElements
                                    );
                                }
                            }
                        } // Trigger print

                        if (true) {
                            printWindow.contentWindow.print();
                        }
                    },
                    [apiRef, doc]
                );
                const handlePrintWindowAfterPrint = react.useCallback(
                    (printWindow) => {
                        var _previousGridState$cu, _previousGridState$cu2;

                        // Remove the print iframe
                        doc.current.body.removeChild(printWindow); // Revert grid to previous state

                        apiRef.current.restoreState(
                            previousGridState.current || {}
                        );

                        if (
                            !(
                                (_previousGridState$cu =
                                    previousGridState.current) != null &&
                                (_previousGridState$cu2 =
                                    _previousGridState$cu.columns) != null &&
                                _previousGridState$cu2.columnVisibilityModel
                            )
                        ) {
                            // if the apiRef.current.exportState(); did not exported the column visibility, we update it
                            apiRef.current.setColumnVisibilityModel(
                                previousColumnVisibility.current
                            );
                        }

                        apiRef.current.unstable_enableVirtualization(); // Clear local state

                        previousGridState.current = null;
                        previousColumnVisibility.current = {};
                    },
                    [apiRef]
                );
                const exportDataAsPrint = react.useCallback(
                    async (options) => {
                        logger.debug(`Export data as Print`);

                        if (!apiRef.current.rootElementRef.current) {
                            throw new Error(
                                "MUI: No grid root element available."
                            );
                        }

                        previousGridState.current =
                            apiRef.current.exportState(); // It appends that the visibility model is not exported, especially if columnVisibility is not controlled

                        previousColumnVisibility.current =
                            gridColumnVisibilityModelSelector(apiRef);

                        if (props.pagination) {
                            const visibleRowCount =
                                gridVisibleRowCountSelector(apiRef);
                            apiRef.current.setPageSize(visibleRowCount);
                        }

                        await updateGridColumnsForPrint(
                            options == null ? void 0 : options.fields,
                            options == null ? void 0 : options.allColumns
                        );
                        apiRef.current.unstable_disableVirtualization();
                        const printWindow = buildPrintWindow(
                            options == null ? void 0 : options.fileName
                        );
                        doc.current.body.appendChild(printWindow);

                        if (false) {
                        } else {
                            printWindow.onload = () =>
                                handlePrintWindowLoad(printWindow, options);

                            printWindow.contentWindow.onafterprint = () =>
                                handlePrintWindowAfterPrint(printWindow);
                        }
                    },
                    [
                        props,
                        logger,
                        apiRef,
                        buildPrintWindow,
                        handlePrintWindowLoad,
                        handlePrintWindowAfterPrint,
                        updateGridColumnsForPrint,
                    ]
                );
                const printExportApi = {
                    exportDataAsPrint,
                };
                useGridApiMethod(apiRef, printExportApi, "GridPrintExportApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/models/gridFeatureMode.js
            const GridFeatureModeConstant = {
                client: "client",
                server: "server",
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/models/gridFilterItem.js
            /**
             * Filter item definition interface.
             */
            var GridLinkOperator;

            (function (GridLinkOperator) {
                GridLinkOperator["And"] = "and";
                GridLinkOperator["Or"] = "or";
            })(GridLinkOperator || (GridLinkOperator = {})); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterState.js

            const getDefaultGridFilterModel = () => ({
                items: [],
                linkOperator: GridLinkOperator.And,
            }); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/core/strategyProcessing/useGridRegisterStrategyProcessor.js
            const useGridRegisterStrategyProcessor = (
                apiRef,
                strategyName,
                group,
                processor
            ) => {
                const registerPreProcessor = react.useCallback(() => {
                    apiRef.current.unstable_registerStrategyProcessor(
                        strategyName,
                        group,
                        processor
                    );
                }, [apiRef, processor, group, strategyName]);
                useFirstRender(() => {
                    registerPreProcessor();
                });
                const isFirstRender = react.useRef(true);
                react.useEffect(() => {
                    if (isFirstRender.current) {
                        isFirstRender.current = false;
                    } else {
                        registerPreProcessor();
                    }
                }, [registerPreProcessor]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js
            /**
             * Adds default values to the optional fields of a filter items.
             * @param {GridFilterItem} item The raw filter item.
             * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.
             * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operatorValue.
             * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.
             */
            const cleanFilterItem = (item, apiRef) => {
                const cleanItem = (0, esm_extends /* default */.Z)({}, item);

                if (cleanItem.id == null) {
                    cleanItem.id = Math.round(Math.random() * 1e5);
                }

                if (cleanItem.operatorValue == null) {
                    // we select a default operator
                    const column = apiRef.current.getColumn(
                        cleanItem.columnField
                    );
                    cleanItem.operatorValue =
                        column && column.filterOperators[0].value;
                }

                return cleanItem;
            };

            const filterModelDisableMultiColumnsFilteringWarning = (0,
            warning /* buildWarning */.b)(
                [
                    "MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.",
                    "If you are using the community version of the `DataGrid`, this prop is always `true`.",
                ],
                "error"
            );
            const filterModelMissingItemIdWarning = (0,
            warning /* buildWarning */.b)(
                "MUI: The 'id' field is required on `filterModel.items` when you use multiple filters.",
                "error"
            );
            const filterModelMissingItemOperatorWarning = (0,
            warning /* buildWarning */.b)([
                "MUI: One of your filtering item have no `operatorValue` provided.",
                "This property will become required on `@mui/x-data-grid@6.X`.",
            ]);
            const sanitizeFilterModel = (
                model,
                disableMultipleColumnsFiltering,
                apiRef
            ) => {
                const hasSeveralItems = model.items.length > 1;
                let items;

                if (hasSeveralItems && disableMultipleColumnsFiltering) {
                    filterModelDisableMultiColumnsFilteringWarning();
                    items = [model.items[0]];
                } else {
                    items = model.items;
                }

                const hasItemsWithoutIds =
                    hasSeveralItems && items.some((item) => item.id == null);
                const hasItemWithoutOperator = items.some(
                    (item) => item.operatorValue == null
                );

                if (hasItemsWithoutIds) {
                    filterModelMissingItemIdWarning();
                }

                if (hasItemWithoutOperator) {
                    filterModelMissingItemOperatorWarning();
                }

                if (hasItemWithoutOperator || hasItemsWithoutIds) {
                    return (0, esm_extends /* default */.Z)({}, model, {
                        items: items.map((item) =>
                            cleanFilterItem(item, apiRef)
                        ),
                    });
                }

                if (model.items !== items) {
                    return (0, esm_extends /* default */.Z)({}, model, {
                        items,
                    });
                }

                return model;
            };
            const mergeStateWithFilterModel =
                (filterModel, disableMultipleColumnsFiltering, apiRef) =>
                (state) =>
                    (0, esm_extends /* default */.Z)({}, state, {
                        filter: (0, esm_extends /* default */.Z)(
                            {},
                            state.filter,
                            {
                                filterModel: sanitizeFilterModel(
                                    filterModel,
                                    disableMultipleColumnsFiltering,
                                    apiRef
                                ),
                            }
                        ),
                    });
            /**
             * Generates a method to easily check if a row is matching the current filter model.
             * @param {GridFilterModel} filterModel The model with which we want to filter the rows.
             * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.
             * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.
             */

            const buildAggregatedFilterApplier = (filterModel, apiRef) => {
                const { items, linkOperator = GridLinkOperator.And } =
                    filterModel;

                const getFilterCallbackFromItem = (filterItem) => {
                    if (!filterItem.columnField || !filterItem.operatorValue) {
                        return null;
                    }

                    const column = apiRef.current.getColumn(
                        filterItem.columnField
                    );

                    if (!column) {
                        return null;
                    }

                    let parsedValue;

                    if (column.valueParser) {
                        var _filterItem$value;

                        const parser = column.valueParser;
                        parsedValue = Array.isArray(filterItem.value)
                            ? (_filterItem$value = filterItem.value) == null
                                ? void 0
                                : _filterItem$value.map((x) => parser(x))
                            : parser(filterItem.value);
                    } else {
                        parsedValue = filterItem.value;
                    }

                    const newFilterItem = (0, esm_extends /* default */.Z)(
                        {},
                        filterItem,
                        {
                            value: parsedValue,
                        }
                    );

                    const filterOperators = column.filterOperators;

                    if (!(filterOperators != null && filterOperators.length)) {
                        throw new Error(
                            `MUI: No filter operators found for column '${column.field}'.`
                        );
                    }

                    const filterOperator = filterOperators.find(
                        (operator) =>
                            operator.value === newFilterItem.operatorValue
                    );

                    if (!filterOperator) {
                        throw new Error(
                            `MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operatorValue}'.`
                        );
                    }

                    const applyFilterOnRow = filterOperator.getApplyFilterFn(
                        newFilterItem,
                        column
                    );

                    if (typeof applyFilterOnRow !== "function") {
                        return null;
                    }

                    const fn = (rowId) => {
                        const cellParams = apiRef.current.getCellParams(
                            rowId,
                            newFilterItem.columnField
                        );
                        return applyFilterOnRow(cellParams);
                    };

                    return {
                        fn,
                        item: newFilterItem,
                    };
                };

                const appliers = items
                    .map(getFilterCallbackFromItem)
                    .filter((callback) => !!callback);

                if (appliers.length === 0) {
                    return null;
                }

                return (rowId, shouldApplyFilter) => {
                    const filteredAppliers = shouldApplyFilter
                        ? appliers.filter((applier) =>
                              shouldApplyFilter(applier.item)
                          )
                        : appliers; // Return `false` as soon as we have a failing filter

                    if (linkOperator === GridLinkOperator.And) {
                        return filteredAppliers.every((applier) =>
                            applier.fn(rowId)
                        );
                    } // Return `true` as soon as we have a passing filter

                    return filteredAppliers.some((applier) =>
                        applier.fn(rowId)
                    );
                };
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/filter/useGridFilter.js
            const filterStateInitializer = (state, props, apiRef) => {
                var _ref,
                    _props$filterModel,
                    _props$initialState,
                    _props$initialState$f;

                const filterModel =
                    (_ref =
                        (_props$filterModel = props.filterModel) != null
                            ? _props$filterModel
                            : (_props$initialState = props.initialState) == null
                            ? void 0
                            : (_props$initialState$f =
                                  _props$initialState.filter) == null
                            ? void 0
                            : _props$initialState$f.filterModel) != null
                        ? _ref
                        : getDefaultGridFilterModel();
                return (0, esm_extends /* default */.Z)({}, state, {
                    filter: {
                        filterModel: sanitizeFilterModel(
                            filterModel,
                            props.disableMultipleColumnsFiltering,
                            apiRef
                        ),
                        visibleRowsLookup: {},
                        filteredDescendantCountLookup: {},
                    },
                });
            };
            /**
             * @requires useGridColumns (method, event)
             * @requires useGridParamsApi (method)
             * @requires useGridRows (event)
             */

            const useGridFilter = (apiRef, props) => {
                var _props$componentsProp2;

                const logger = useGridLogger(apiRef, "useGridFilter");
                apiRef.current.unstable_updateControlState({
                    stateId: "filter",
                    propModel: props.filterModel,
                    propOnChange: props.onFilterModelChange,
                    stateSelector: gridFilterModelSelector,
                    changeEvent:
                        gridEvents /* GridEvents.filterModelChange */.t
                            .filterModelChange,
                });
                const updateFilteredRows = react.useCallback(() => {
                    apiRef.current.setState((state) => {
                        const filterModel = gridFilterModelSelector(
                            state,
                            apiRef.current.instanceId
                        );
                        const isRowMatchingFilters =
                            props.filterMode === GridFeatureModeConstant.client
                                ? buildAggregatedFilterApplier(
                                      filterModel,
                                      apiRef
                                  )
                                : null;
                        const filteringResult =
                            apiRef.current.unstable_applyStrategyProcessor(
                                "filtering",
                                {
                                    isRowMatchingFilters,
                                }
                            );
                        return (0, esm_extends /* default */.Z)({}, state, {
                            filter: (0, esm_extends /* default */.Z)(
                                {},
                                state.filter,
                                filteringResult
                            ),
                        });
                    });
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.filteredRowsSet */.t
                            .filteredRowsSet
                    );
                }, [props.filterMode, apiRef]);
                /**
                 * API METHODS
                 */

                const applyFilters = react.useCallback(() => {
                    updateFilteredRows();
                    apiRef.current.forceUpdate();
                }, [apiRef, updateFilteredRows]);
                const upsertFilterItem = react.useCallback(
                    (item) => {
                        const filterModel = gridFilterModelSelector(apiRef);
                        const items = [...filterModel.items];
                        const itemIndex = items.findIndex(
                            (filterItem) => filterItem.id === item.id
                        );

                        if (itemIndex === -1) {
                            items.push(item);
                        } else {
                            items[itemIndex] = item;
                        }

                        apiRef.current.setFilterModel(
                            (0, esm_extends /* default */.Z)({}, filterModel, {
                                items,
                            })
                        );
                    },
                    [apiRef]
                );
                const deleteFilterItem = react.useCallback(
                    (itemToDelete) => {
                        const filterModel = gridFilterModelSelector(apiRef);
                        const items = filterModel.items.filter(
                            (item) => item.id !== itemToDelete.id
                        );

                        if (items.length === filterModel.items.length) {
                            return;
                        }

                        apiRef.current.setFilterModel(
                            (0, esm_extends /* default */.Z)({}, filterModel, {
                                items,
                            })
                        );
                    },
                    [apiRef]
                );
                const showFilterPanel = react.useCallback(
                    (targetColumnField) => {
                        logger.debug("Displaying filter panel");

                        if (targetColumnField) {
                            const filterModel = gridFilterModelSelector(apiRef);
                            const filterItemsWithValue =
                                filterModel.items.filter(
                                    (item) => item.value !== undefined
                                );
                            let newFilterItems;
                            const filterItemOnTarget =
                                filterItemsWithValue.find(
                                    (item) =>
                                        item.columnField === targetColumnField
                                );

                            if (filterItemOnTarget) {
                                newFilterItems = filterItemsWithValue;
                            } else if (props.disableMultipleColumnsFiltering) {
                                newFilterItems = [
                                    {
                                        columnField: targetColumnField,
                                    },
                                ];
                            } else {
                                newFilterItems = [
                                    ...filterItemsWithValue,
                                    {
                                        columnField: targetColumnField,
                                    },
                                ];
                            }

                            apiRef.current.setFilterModel(
                                (0, esm_extends /* default */.Z)(
                                    {},
                                    filterModel,
                                    {
                                        items: newFilterItems,
                                    }
                                )
                            );
                        }

                        apiRef.current.showPreferences(
                            GridPreferencePanelsValue.filters
                        );
                    },
                    [apiRef, logger, props.disableMultipleColumnsFiltering]
                );
                const hideFilterPanel = react.useCallback(() => {
                    logger.debug("Hiding filter panel");
                    apiRef.current.hidePreferences();
                }, [apiRef, logger]);
                const setFilterLinkOperator = react.useCallback(
                    (linkOperator) => {
                        const filterModel = gridFilterModelSelector(apiRef);

                        if (filterModel.linkOperator === linkOperator) {
                            return;
                        }

                        apiRef.current.setFilterModel(
                            (0, esm_extends /* default */.Z)({}, filterModel, {
                                linkOperator,
                            })
                        );
                    },
                    [apiRef]
                );
                const setFilterModel = react.useCallback(
                    (model) => {
                        const currentModel = gridFilterModelSelector(apiRef);

                        if (currentModel !== model) {
                            logger.debug("Setting filter model");
                            apiRef.current.setState(
                                mergeStateWithFilterModel(
                                    model,
                                    props.disableMultipleColumnsFiltering,
                                    apiRef
                                )
                            );
                            apiRef.current.unstable_applyFilters();
                        }
                    },
                    [apiRef, logger, props.disableMultipleColumnsFiltering]
                );
                const getVisibleRowModels = react.useCallback(() => {
                    const visibleSortedRows =
                        gridVisibleSortedRowEntriesSelector(apiRef);
                    return new Map(
                        visibleSortedRows.map((row) => [row.id, row.model])
                    );
                }, [apiRef]);
                const filterApi = {
                    setFilterLinkOperator,
                    unstable_applyFilters: applyFilters,
                    deleteFilterItem,
                    upsertFilterItem,
                    setFilterModel,
                    showFilterPanel,
                    hideFilterPanel,
                    getVisibleRowModels,
                };
                useGridApiMethod(apiRef, filterApi, "GridFilterApi");
                /**
                 * PRE-PROCESSING
                 */

                const stateExportPreProcessing = react.useCallback(
                    (prevState) => {
                        const filterModelToExport =
                            gridFilterModelSelector(apiRef);

                        if (
                            filterModelToExport.items.length === 0 &&
                            filterModelToExport.linkOperator ===
                                getDefaultGridFilterModel().linkOperator
                        ) {
                            return prevState;
                        }

                        return (0, esm_extends /* default */.Z)({}, prevState, {
                            filter: {
                                filterModel: filterModelToExport,
                            },
                        });
                    },
                    [apiRef]
                );
                const stateRestorePreProcessing = react.useCallback(
                    (params, context) => {
                        var _context$stateToResto;

                        const filterModel =
                            (_context$stateToResto =
                                context.stateToRestore.filter) == null
                                ? void 0
                                : _context$stateToResto.filterModel;

                        if (filterModel == null) {
                            return params;
                        }

                        apiRef.current.setState(
                            mergeStateWithFilterModel(
                                filterModel,
                                props.disableMultipleColumnsFiltering,
                                apiRef
                            )
                        );
                        return (0, esm_extends /* default */.Z)({}, params, {
                            callbacks: [
                                ...params.callbacks,
                                apiRef.current.unstable_applyFilters,
                            ],
                        });
                    },
                    [apiRef, props.disableMultipleColumnsFiltering]
                );
                const preferencePanelPreProcessing = react.useCallback(
                    (initialValue, value) => {
                        if (value === GridPreferencePanelsValue.filters) {
                            var _props$componentsProp;

                            const FilterPanel = props.components.FilterPanel;
                            return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                FilterPanel,
                                (0, esm_extends /* default */.Z)(
                                    {},
                                    (_props$componentsProp =
                                        props.componentsProps) == null
                                        ? void 0
                                        : _props$componentsProp.filterPanel
                                )
                            );
                        }

                        return initialValue;
                    },
                    [
                        props.components.FilterPanel,
                        (_props$componentsProp2 = props.componentsProps) == null
                            ? void 0
                            : _props$componentsProp2.filterPanel,
                    ]
                );
                const flatFilteringMethod = react.useCallback(
                    (params) => {
                        if (
                            props.filterMode ===
                                GridFeatureModeConstant.client &&
                            params.isRowMatchingFilters
                        ) {
                            const rowIds = gridRowIdsSelector(apiRef);
                            const filteredRowsLookup = {};

                            for (let i = 0; i < rowIds.length; i += 1) {
                                const rowId = rowIds[i];
                                filteredRowsLookup[rowId] =
                                    params.isRowMatchingFilters(rowId);
                            }

                            return {
                                filteredRowsLookup,
                                // For flat tree, the `visibleRowsLookup` and the `filteredRowsLookup` since no row is collapsed.
                                visibleRowsLookup: filteredRowsLookup,
                                filteredDescendantCountLookup: {},
                            };
                        }

                        return {
                            visibleRowsLookup: {},
                            filteredRowsLookup: {},
                            filteredDescendantCountLookup: {},
                        };
                    },
                    [apiRef, props.filterMode]
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "exportState",
                    stateExportPreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "restoreState",
                    stateRestorePreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "preferencePanel",
                    preferencePanelPreProcessing
                );
                useGridRegisterStrategyProcessor(
                    apiRef,
                    GRID_DEFAULT_STRATEGY,
                    "filtering",
                    flatFilteringMethod
                );
                /**
                 * EVENTS
                 */

                const handleColumnsChange = react.useCallback(() => {
                    logger.debug(
                        "onColUpdated - GridColumns changed, applying filters"
                    );
                    const filterModel = gridFilterModelSelector(apiRef);
                    const filterableColumnsLookup =
                        gridFilterableColumnLookupSelector(apiRef);
                    const newFilterItems = filterModel.items.filter(
                        (item) =>
                            item.columnField &&
                            filterableColumnsLookup[item.columnField]
                    );

                    if (newFilterItems.length < filterModel.items.length) {
                        apiRef.current.setFilterModel(
                            (0, esm_extends /* default */.Z)({}, filterModel, {
                                items: newFilterItems,
                            })
                        );
                    }
                }, [apiRef, logger]);
                const handleStrategyProcessorChange = react.useCallback(
                    (methodName) => {
                        if (methodName === "filtering") {
                            apiRef.current.unstable_applyFilters();
                        }
                    },
                    [apiRef]
                ); // Do not call `apiRef.current.forceUpdate` to avoid re-render before updating the sorted rows.
                // Otherwise, the state is not consistent during the render

                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowsSet */.t.rowsSet,
                    updateFilteredRows
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowExpansionChange */.t
                        .rowExpansionChange,
                    apiRef.current.unstable_applyFilters
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnsChange */.t.columnsChange,
                    handleColumnsChange
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.activeStrategyProcessorChange */.t
                        .activeStrategyProcessorChange,
                    handleStrategyProcessorChange
                );
                /**
                 * 1ST RENDER
                 */

                useFirstRender(() => {
                    apiRef.current.unstable_applyFilters();
                });
                /**
                 * EFFECTS
                 */

                react.useEffect(() => {
                    if (props.filterModel !== undefined) {
                        apiRef.current.setFilterModel(props.filterModel);
                    }
                }, [apiRef, logger, props.filterModel]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/utils/useGridVisibleRows.js
            const getVisibleRows = (apiRef, props) => {
                let rows;
                let range;

                if (props.pagination && props.paginationMode === "client") {
                    range = gridPaginationRowRangeSelector(apiRef);
                    rows =
                        gridPaginatedVisibleSortedGridRowEntriesSelector(
                            apiRef
                        );
                } else {
                    rows = gridVisibleSortedRowEntriesSelector(apiRef);

                    if (rows.length === 0) {
                        range = null;
                    } else {
                        range = {
                            firstRowIndex: 0,
                            lastRowIndex: rows.length - 1,
                        };
                    }
                }

                return {
                    rows,
                    range,
                };
            };
            /**
             * Computes the list of rows that are reachable by scroll.
             * Depending on whether pagination is enabled, it will return the rows in the current page.
             * - If the pagination is disabled or in server mode, it equals all the visible rows.
             * - If the row tree has several layers, it contains up to `state.pageSize` top level rows and all their descendants.
             * - If the row tree is flat, it only contains up to `state.pageSize` rows.
             */

            const useGridVisibleRows = (apiRef, props) => {
                const response = getVisibleRows(apiRef, props);
                return react.useMemo(
                    () => ({
                        rows: response.rows,
                        range: response.range,
                    }),
                    [response.rows, response.range]
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/focus/useGridFocus.js
            const focusStateInitializer = (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    focus: {
                        cell: null,
                        columnHeader: null,
                    },
                    tabIndex: {
                        cell: null,
                        columnHeader: null,
                    },
                });
            /**
             * @requires useGridParamsApi (method)
             * @requires useGridRows (method)
             * @requires useGridEditing (event)
             */

            const useGridFocus = (apiRef, props) => {
                const logger = useGridLogger(apiRef, "useGridFocus");
                const lastClickedCell = react.useRef(null);
                const setCellFocus = react.useCallback(
                    (id, field) => {
                        // The row might have been deleted
                        if (!apiRef.current.getRow(id)) {
                            return;
                        }

                        const focusedCell = gridFocusCellSelector(apiRef);

                        if (
                            (focusedCell == null ? void 0 : focusedCell.id) ===
                                id &&
                            focusedCell.field === field
                        ) {
                            return;
                        }

                        apiRef.current.setState((state) => {
                            logger.debug(
                                `Focusing on cell with id=${id} and field=${field}`
                            );
                            return (0, esm_extends /* default */.Z)({}, state, {
                                tabIndex: {
                                    cell: {
                                        id,
                                        field,
                                    },
                                    columnHeader: null,
                                },
                                focus: {
                                    cell: {
                                        id,
                                        field,
                                    },
                                    columnHeader: null,
                                },
                            });
                        });
                        apiRef.current.forceUpdate();
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.cellFocusIn */.t
                                .cellFocusIn,
                            apiRef.current.getCellParams(id, field)
                        );
                    },
                    [apiRef, logger]
                );
                const setColumnHeaderFocus = react.useCallback(
                    (field, event = {}) => {
                        const cell = gridFocusCellSelector(apiRef);

                        if (cell) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellFocusOut */.t
                                    .cellFocusOut,
                                apiRef.current.getCellParams(
                                    cell.id,
                                    cell.field
                                ),
                                event
                            );
                        }

                        apiRef.current.setState((state) => {
                            logger.debug(
                                `Focusing on column header with colIndex=${field}`
                            );
                            return (0, esm_extends /* default */.Z)({}, state, {
                                tabIndex: {
                                    columnHeader: {
                                        field,
                                    },
                                    cell: null,
                                },
                                focus: {
                                    columnHeader: {
                                        field,
                                    },
                                    cell: null,
                                },
                            });
                        });
                        apiRef.current.forceUpdate();
                    },
                    [apiRef, logger]
                );
                const moveFocusToRelativeCell = react.useCallback(
                    (id, field, direction) => {
                        let columnIndexToFocus =
                            apiRef.current.getColumnIndex(field);
                        let rowIndexToFocus =
                            apiRef.current.getRowIndexRelativeToVisibleRows(id);
                        const visibleColumns =
                            gridVisibleColumnDefinitionsSelector(apiRef);

                        if (direction === "right") {
                            columnIndexToFocus += 1;
                        } else if (direction === "left") {
                            columnIndexToFocus -= 1;
                        } else {
                            rowIndexToFocus += 1;
                        }

                        const currentPage = getVisibleRows(apiRef, {
                            pagination: props.pagination,
                            paginationMode: props.paginationMode,
                        });

                        if (columnIndexToFocus >= visibleColumns.length) {
                            // Go to next row if we are after the last column
                            rowIndexToFocus += 1;

                            if (rowIndexToFocus < currentPage.rows.length) {
                                // Go to first column of the next row if there's one more row
                                columnIndexToFocus = 0;
                            }
                        } else if (columnIndexToFocus < 0) {
                            // Go to previous row if we are before the first column
                            rowIndexToFocus -= 1;

                            if (rowIndexToFocus >= 0) {
                                // Go to last column of the previous if there's one more row
                                columnIndexToFocus = visibleColumns.length - 1;
                            }
                        }

                        rowIndexToFocus = clamp(
                            rowIndexToFocus,
                            0,
                            currentPage.rows.length - 1
                        );
                        columnIndexToFocus = clamp(
                            columnIndexToFocus,
                            0,
                            visibleColumns.length - 1
                        );
                        const rowToFocus = currentPage.rows[rowIndexToFocus];
                        const columnToFocus =
                            visibleColumns[columnIndexToFocus];
                        apiRef.current.setCellFocus(
                            rowToFocus.id,
                            columnToFocus.field
                        );
                    },
                    [apiRef, props.pagination, props.paginationMode]
                );
                const handleCellDoubleClick = react.useCallback(
                    ({ id, field }) => {
                        apiRef.current.setCellFocus(id, field);
                    },
                    [apiRef]
                );
                const handleCellKeyDown = react.useCallback(
                    (params, event) => {
                        // GRID_CELL_NAVIGATION_KEY_DOWN handles the focus on Enter, Tab and navigation keys
                        if (
                            event.key === "Enter" ||
                            event.key === "Tab" ||
                            isNavigationKey(event.key)
                        ) {
                            return;
                        }

                        apiRef.current.setCellFocus(params.id, params.field);
                    },
                    [apiRef]
                );
                const handleColumnHeaderFocus = react.useCallback(
                    ({ field }, event) => {
                        if (event.target !== event.currentTarget) {
                            return;
                        }

                        apiRef.current.setColumnHeaderFocus(field, event);
                    },
                    [apiRef]
                );
                const handleBlur = react.useCallback(() => {
                    logger.debug(`Clearing focus`);
                    apiRef.current.setState((state) =>
                        (0, esm_extends /* default */.Z)({}, state, {
                            focus: {
                                cell: null,
                                columnHeader: null,
                            },
                        })
                    );
                }, [logger, apiRef]);
                const handleCellMouseUp = react.useCallback((params) => {
                    lastClickedCell.current = params;
                }, []);
                const handleDocumentClick = react.useCallback(
                    (event) => {
                        const cellParams = lastClickedCell.current;
                        lastClickedCell.current = null;
                        const focusedCell = gridFocusCellSelector(apiRef);

                        if (!focusedCell) {
                            if (cellParams) {
                                apiRef.current.setCellFocus(
                                    cellParams.id,
                                    cellParams.field
                                );
                            }

                            return;
                        }

                        if (
                            (cellParams == null ? void 0 : cellParams.id) ===
                                focusedCell.id &&
                            (cellParams == null ? void 0 : cellParams.field) ===
                                focusedCell.field
                        ) {
                            return;
                        }

                        const cellElement = apiRef.current.getCellElement(
                            focusedCell.id,
                            focusedCell.field
                        );

                        if (
                            cellElement != null &&
                            cellElement.contains(event.target)
                        ) {
                            return;
                        } // The row might have been deleted during the click

                        if (!apiRef.current.getRow(focusedCell.id)) {
                            return;
                        } // There's a focused cell but another cell was clicked
                        // Publishes an event to notify that the focus was lost

                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.cellFocusOut */.t
                                .cellFocusOut,
                            apiRef.current.getCellParams(
                                focusedCell.id,
                                focusedCell.field
                            ),
                            event
                        );

                        if (cellParams) {
                            apiRef.current.setCellFocus(
                                cellParams.id,
                                cellParams.field
                            );
                        } else {
                            apiRef.current.setState((state) =>
                                (0, esm_extends /* default */.Z)({}, state, {
                                    focus: {
                                        cell: null,
                                        columnHeader: null,
                                    },
                                })
                            );
                            apiRef.current.forceUpdate();
                        }
                    },
                    [apiRef]
                );
                const handleCellModeChange = react.useCallback(
                    (params) => {
                        if (params.cellMode === "view") {
                            return;
                        }

                        const cell = gridFocusCellSelector(apiRef);

                        if (
                            (cell == null ? void 0 : cell.id) !== params.id ||
                            (cell == null ? void 0 : cell.field) !==
                                params.field
                        ) {
                            apiRef.current.setCellFocus(
                                params.id,
                                params.field
                            );
                        }
                    },
                    [apiRef]
                );
                useGridApiMethod(
                    apiRef,
                    {
                        setCellFocus,
                        setColumnHeaderFocus,
                        unstable_moveFocusToRelativeCell:
                            moveFocusToRelativeCell,
                    },
                    "GridFocusApi"
                );
                react.useEffect(() => {
                    const cell = gridFocusCellSelector(apiRef);

                    if (cell) {
                        const updatedRow = apiRef.current.getRow(cell.id);

                        if (!updatedRow) {
                            apiRef.current.setState((state) =>
                                (0, esm_extends /* default */.Z)({}, state, {
                                    focus: {
                                        cell: null,
                                        columnHeader: null,
                                    },
                                })
                            );
                        }
                    }
                }, [apiRef, props.rows]);
                react.useEffect(() => {
                    const doc = (0, utils_ownerDocument /* default */.Z)(
                        apiRef.current.rootElementRef.current
                    );
                    doc.addEventListener("click", handleDocumentClick);
                    return () => {
                        doc.removeEventListener("click", handleDocumentClick);
                    };
                }, [apiRef, handleDocumentClick]);
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderBlur */.t
                        .columnHeaderBlur,
                    handleBlur
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellDoubleClick */.t
                        .cellDoubleClick,
                    handleCellDoubleClick
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellMouseUp */.t.cellMouseUp,
                    handleCellMouseUp
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    handleCellKeyDown
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellModeChange */.t.cellModeChange,
                    handleCellModeChange
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderFocus */.t
                        .columnHeaderFocus,
                    handleColumnHeaderFocus
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/constants/gridDetailPanelToggleField.js
            // Can't import from pro package - hence duplication
            const GRID_DETAIL_PANEL_TOGGLE_FIELD = "__detail_panel_toggle__"; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/keyboardNavigation/useGridKeyboardNavigation.js
            /**
             * @requires useGridSorting (method) - can be after
             * @requires useGridFilter (state) - can be after
             * @requires useGridColumns (state, method) - can be after
             * @requires useGridDimensions (method) - can be after
             * @requires useGridFocus (method) - can be after
             * @requires useGridScroll (method) - can be after
             * @requires useGridColumnSpanning (method) - can be after
             */

            const useGridKeyboardNavigation = (apiRef, props) => {
                const logger = useGridLogger(
                    apiRef,
                    "useGridKeyboardNavigation"
                );
                const currentPage = useGridVisibleRows(apiRef, props);
                /**
                 * @param {number} colIndex Index of the column to focus
                 * @param {number} rowIndex index of the row to focus
                 * @param {string} closestColumnToUse Which closest column cell to use when the cell is spanned by `colSpan`.
                 */

                const goToCell = react.useCallback(
                    (colIndex, rowIndex, closestColumnToUse = "left") => {
                        var _visibleSortedRows$ro;

                        const visibleSortedRows =
                            gridVisibleSortedRowEntriesSelector(apiRef);
                        const rowId =
                            (_visibleSortedRows$ro =
                                visibleSortedRows[rowIndex]) == null
                                ? void 0
                                : _visibleSortedRows$ro.id;
                        const nextCellColSpanInfo =
                            apiRef.current.unstable_getCellColSpanInfo(
                                rowId,
                                colIndex
                            );

                        if (
                            nextCellColSpanInfo &&
                            nextCellColSpanInfo.spannedByColSpan
                        ) {
                            if (closestColumnToUse === "left") {
                                colIndex =
                                    nextCellColSpanInfo.leftVisibleCellIndex;
                            } else if (closestColumnToUse === "right") {
                                colIndex =
                                    nextCellColSpanInfo.rightVisibleCellIndex;
                            }
                        }

                        logger.debug(
                            `Navigating to cell row ${rowIndex}, col ${colIndex}`
                        );
                        apiRef.current.scrollToIndexes({
                            colIndex,
                            rowIndex,
                        });
                        const field =
                            apiRef.current.getVisibleColumns()[colIndex].field;
                        apiRef.current.setCellFocus(rowId, field);
                    },
                    [apiRef, logger]
                );
                const goToHeader = react.useCallback(
                    (colIndex, event) => {
                        logger.debug(`Navigating to header col ${colIndex}`);
                        apiRef.current.scrollToIndexes({
                            colIndex,
                        });
                        const field =
                            apiRef.current.getVisibleColumns()[colIndex].field;
                        apiRef.current.setColumnHeaderFocus(field, event);
                    },
                    [apiRef, logger]
                );
                const handleCellNavigationKeyDown = react.useCallback(
                    (params, event) => {
                        const dimensions = apiRef.current.getRootDimensions();

                        if (!currentPage.range || !dimensions) {
                            return;
                        }

                        const viewportPageSize =
                            apiRef.current.unstable_getViewportPageSize();
                        const visibleSortedRows =
                            gridVisibleSortedRowEntriesSelector(apiRef);
                        const colIndexBefore = params.field
                            ? apiRef.current.getColumnIndex(params.field)
                            : 0;
                        const rowIndexBefore = visibleSortedRows.findIndex(
                            (row) => row.id === params.id
                        );
                        const firstRowIndexInPage =
                            currentPage.range.firstRowIndex;
                        const lastRowIndexInPage =
                            currentPage.range.lastRowIndex;
                        const firstColIndex = 0;
                        const lastColIndex =
                            gridVisibleColumnDefinitionsSelector(apiRef)
                                .length - 1;
                        let shouldPreventDefault = true;

                        switch (event.key) {
                            case "ArrowDown":
                            case "Enter": {
                                // "Enter" is only triggered by the row / cell editing feature
                                if (rowIndexBefore < lastRowIndexInPage) {
                                    goToCell(
                                        colIndexBefore,
                                        rowIndexBefore + 1
                                    );
                                }

                                break;
                            }

                            case "ArrowUp": {
                                if (rowIndexBefore > firstRowIndexInPage) {
                                    goToCell(
                                        colIndexBefore,
                                        rowIndexBefore - 1
                                    );
                                } else {
                                    goToHeader(colIndexBefore, event);
                                }

                                break;
                            }

                            case "ArrowRight": {
                                if (colIndexBefore < lastColIndex) {
                                    goToCell(
                                        colIndexBefore + 1,
                                        rowIndexBefore,
                                        "right"
                                    );
                                }

                                break;
                            }

                            case "ArrowLeft": {
                                if (colIndexBefore > firstColIndex) {
                                    goToCell(
                                        colIndexBefore - 1,
                                        rowIndexBefore
                                    );
                                }

                                break;
                            }

                            case "Tab": {
                                // "Tab" is only triggered by the row / cell editing feature
                                if (
                                    event.shiftKey &&
                                    colIndexBefore > firstColIndex
                                ) {
                                    goToCell(
                                        colIndexBefore - 1,
                                        rowIndexBefore,
                                        "left"
                                    );
                                } else if (
                                    !event.shiftKey &&
                                    colIndexBefore < lastColIndex
                                ) {
                                    goToCell(
                                        colIndexBefore + 1,
                                        rowIndexBefore,
                                        "right"
                                    );
                                }

                                break;
                            }

                            case " ": {
                                const field = params.field;

                                if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
                                    break;
                                }

                                const colDef = params.colDef;

                                if (colDef && colDef.type === "treeDataGroup") {
                                    break;
                                }

                                if (
                                    !event.shiftKey &&
                                    rowIndexBefore < lastRowIndexInPage
                                ) {
                                    goToCell(
                                        colIndexBefore,
                                        Math.min(
                                            rowIndexBefore + viewportPageSize,
                                            lastRowIndexInPage
                                        )
                                    );
                                }

                                break;
                            }

                            case "PageDown": {
                                if (rowIndexBefore < lastRowIndexInPage) {
                                    goToCell(
                                        colIndexBefore,
                                        Math.min(
                                            rowIndexBefore + viewportPageSize,
                                            lastRowIndexInPage
                                        )
                                    );
                                }

                                break;
                            }

                            case "PageUp": {
                                // Go to the first row before going to header
                                const nextRowIndex = Math.max(
                                    rowIndexBefore - viewportPageSize,
                                    firstRowIndexInPage
                                );

                                if (
                                    nextRowIndex !== rowIndexBefore &&
                                    nextRowIndex >= firstRowIndexInPage
                                ) {
                                    goToCell(colIndexBefore, nextRowIndex);
                                } else {
                                    goToHeader(colIndexBefore, event);
                                }

                                break;
                            }

                            case "Home": {
                                if (
                                    event.ctrlKey ||
                                    event.metaKey ||
                                    event.shiftKey
                                ) {
                                    goToCell(
                                        firstColIndex,
                                        firstRowIndexInPage
                                    );
                                } else {
                                    goToCell(firstColIndex, rowIndexBefore);
                                }

                                break;
                            }

                            case "End": {
                                if (
                                    event.ctrlKey ||
                                    event.metaKey ||
                                    event.shiftKey
                                ) {
                                    goToCell(lastColIndex, lastRowIndexInPage);
                                } else {
                                    goToCell(lastColIndex, rowIndexBefore);
                                }

                                break;
                            }

                            default: {
                                shouldPreventDefault = false;
                            }
                        }

                        if (shouldPreventDefault) {
                            event.preventDefault();
                        }
                    },
                    [apiRef, currentPage, goToCell, goToHeader]
                );
                const handleColumnHeaderKeyDown = react.useCallback(
                    (params, event) => {
                        var _currentPage$range$fi,
                            _currentPage$range,
                            _currentPage$range$la,
                            _currentPage$range2;

                        const headerTitleNode =
                            event.currentTarget.querySelector(
                                `.${gridClasses_gridClasses.columnHeaderTitleContainerContent}`
                            );
                        const isFromInsideContent =
                            !!headerTitleNode &&
                            headerTitleNode.contains(event.target);

                        if (
                            isFromInsideContent &&
                            params.field !==
                                GRID_CHECKBOX_SELECTION_COL_DEF.field
                        ) {
                            // When focus is on a nested input, keyboard events have no effect to avoid conflicts with native events.
                            // There is one exception for the checkBoxHeader
                            return;
                        }

                        const dimensions = apiRef.current.getRootDimensions();

                        if (!dimensions) {
                            return;
                        }

                        const viewportPageSize =
                            apiRef.current.unstable_getViewportPageSize();
                        const colIndexBefore = params.field
                            ? apiRef.current.getColumnIndex(params.field)
                            : 0;
                        const firstRowIndexInPage =
                            (_currentPage$range$fi =
                                (_currentPage$range = currentPage.range) == null
                                    ? void 0
                                    : _currentPage$range.firstRowIndex) != null
                                ? _currentPage$range$fi
                                : null;
                        const lastRowIndexInPage =
                            (_currentPage$range$la =
                                (_currentPage$range2 = currentPage.range) ==
                                null
                                    ? void 0
                                    : _currentPage$range2.lastRowIndex) != null
                                ? _currentPage$range$la
                                : null;
                        const firstColIndex = 0;
                        const lastColIndex =
                            gridVisibleColumnDefinitionsSelector(apiRef)
                                .length - 1;
                        let shouldPreventDefault = true;

                        switch (event.key) {
                            case "ArrowDown": {
                                if (firstRowIndexInPage !== null) {
                                    goToCell(
                                        colIndexBefore,
                                        firstRowIndexInPage
                                    );
                                }

                                break;
                            }

                            case "ArrowRight": {
                                if (colIndexBefore < lastColIndex) {
                                    goToHeader(colIndexBefore + 1, event);
                                }

                                break;
                            }

                            case "ArrowLeft": {
                                if (colIndexBefore > firstColIndex) {
                                    goToHeader(colIndexBefore - 1, event);
                                }

                                break;
                            }

                            case "PageDown": {
                                if (
                                    firstRowIndexInPage !== null &&
                                    lastRowIndexInPage !== null
                                ) {
                                    goToCell(
                                        colIndexBefore,
                                        Math.min(
                                            firstRowIndexInPage +
                                                viewportPageSize,
                                            lastRowIndexInPage
                                        )
                                    );
                                }

                                break;
                            }

                            case "Home": {
                                goToHeader(firstColIndex, event);
                                break;
                            }

                            case "End": {
                                goToHeader(lastColIndex, event);
                                break;
                            }

                            case "Enter": {
                                if (event.ctrlKey || event.metaKey) {
                                    apiRef.current.toggleColumnMenu(
                                        params.field
                                    );
                                }

                                break;
                            }

                            case " ": {
                                // prevent Space event from scrolling
                                break;
                            }

                            default: {
                                shouldPreventDefault = false;
                            }
                        }

                        if (shouldPreventDefault) {
                            event.preventDefault();
                        }
                    },
                    [apiRef, currentPage, goToCell, goToHeader]
                );
                const handleCellKeyDown = react.useCallback(
                    (params, event) => {
                        // Ignore portal
                        if (!event.currentTarget.contains(event.target)) {
                            return;
                        } // Get the most recent params because the cell mode may have changed by another listener

                        const cellParams = apiRef.current.getCellParams(
                            params.id,
                            params.field
                        );

                        if (
                            cellParams.cellMode !== GridCellModes.Edit &&
                            isNavigationKey(event.key)
                        ) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellNavigationKeyDown */
                                    .t.cellNavigationKeyDown,
                                cellParams,
                                event
                            );
                        }
                    },
                    [apiRef]
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellNavigationKeyDown */.t
                        .cellNavigationKeyDown,
                    handleCellNavigationKeyDown
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderKeyDown */.t
                        .columnHeaderKeyDown,
                    handleColumnHeaderKeyDown
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    handleCellKeyDown
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/pagination/useGridPageSize.js
            const defaultPageSize = (autoPageSize) => (autoPageSize ? 0 : 100);

            const mergeStateWithPageSize = (pageSize) => (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    pagination: (0, esm_extends /* default */.Z)(
                        {},
                        state.pagination,
                        {
                            pageSize,
                        }
                    ),
                });
            /**
             * @requires useGridDimensions (event) - can be after
             */

            const useGridPageSize = (apiRef, props) => {
                var _props$initialState2, _props$initialState2$;

                const logger = useGridLogger(apiRef, "useGridPageSize");
                const rowHeight = useGridSelector(
                    apiRef,
                    gridDensityRowHeightSelector
                );
                apiRef.current.unstable_updateControlState({
                    stateId: "pageSize",
                    propModel: props.pageSize,
                    propOnChange: props.onPageSizeChange,
                    stateSelector: gridPageSizeSelector,
                    changeEvent:
                        gridEvents /* GridEvents.pageSizeChange */.t
                            .pageSizeChange,
                });
                /**
                 * API METHODS
                 */

                const setPageSize = react.useCallback(
                    (pageSize) => {
                        if (pageSize === gridPageSizeSelector(apiRef)) {
                            return;
                        }

                        logger.debug(`Setting page size to ${pageSize}`);
                        apiRef.current.setState(
                            mergeStateWithPageSize(pageSize)
                        );
                        apiRef.current.forceUpdate();
                    },
                    [apiRef, logger]
                );
                const pageSizeApi = {
                    setPageSize,
                };
                useGridApiMethod(apiRef, pageSizeApi, "GridPageSizeApi");
                /**
                 * PRE-PROCESSING
                 */

                const stateExportPreProcessing = react.useCallback(
                    (prevState) => {
                        var _props$initialState, _props$initialState$p;

                        const pageSizeToExport = gridPageSizeSelector(apiRef);
                        const shouldExportPageSize = // Always export if the page size is controlled
                            props.pageSize != null || // Always export if the page size has been initialized
                            ((_props$initialState = props.initialState) == null
                                ? void 0
                                : (_props$initialState$p =
                                      _props$initialState.pagination) == null
                                ? void 0
                                : _props$initialState$p.pageSize) != null || // Export if the page size value is not equal to the default value
                            pageSizeToExport !==
                                defaultPageSize(props.autoPageSize);

                        if (!shouldExportPageSize) {
                            return prevState;
                        }

                        return (0, esm_extends /* default */.Z)({}, prevState, {
                            pagination: (0, esm_extends /* default */.Z)(
                                {},
                                prevState.pagination,
                                {
                                    pageSize: pageSizeToExport,
                                }
                            ),
                        });
                    },
                    [
                        apiRef,
                        props.pageSize,
                        (_props$initialState2 = props.initialState) == null
                            ? void 0
                            : (_props$initialState2$ =
                                  _props$initialState2.pagination) == null
                            ? void 0
                            : _props$initialState2$.pageSize,
                        props.autoPageSize,
                    ]
                );
                /**
                 * TODO: Add error if `prop.autoHeight = true`
                 */

                const stateRestorePreProcessing = react.useCallback(
                    (params, context) => {
                        var _context$stateToResto;

                        const pageSize =
                            (_context$stateToResto =
                                context.stateToRestore.pagination) == null
                                ? void 0
                                : _context$stateToResto.pageSize;

                        if (pageSize != null) {
                            apiRef.current.setState(
                                mergeStateWithPageSize(pageSize)
                            );
                        }

                        return params;
                    },
                    [apiRef]
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "exportState",
                    stateExportPreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "restoreState",
                    stateRestorePreProcessing
                );
                /**
                 * EVENTS
                 */

                const handleUpdateAutoPageSize = react.useCallback(() => {
                    const dimensions = apiRef.current.getRootDimensions();

                    if (!props.autoPageSize || !dimensions) {
                        return;
                    }

                    const maximumPageSizeWithoutScrollBar = Math.floor(
                        dimensions.viewportInnerSize.height / rowHeight
                    );
                    apiRef.current.setPageSize(maximumPageSizeWithoutScrollBar);
                }, [apiRef, props.autoPageSize, rowHeight]);
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.viewportInnerSizeChange */.t
                        .viewportInnerSizeChange,
                    handleUpdateAutoPageSize
                );
                /**
                 * EFFECTS
                 */

                react.useEffect(() => {
                    if (props.pageSize != null && !props.autoPageSize) {
                        apiRef.current.setPageSize(props.pageSize);
                    }
                }, [apiRef, props.autoPageSize, props.pageSize]);
                react.useEffect(() => {
                    handleUpdateAutoPageSize();
                }, [handleUpdateAutoPageSize]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/pagination/useGridPage.js
            const getPageCount = (rowCount, pageSize) => {
                if (pageSize > 0 && rowCount > 0) {
                    return Math.ceil(rowCount / pageSize);
                }

                return 0;
            };

            const applyValidPage = (paginationState) => {
                if (!paginationState.pageCount) {
                    return paginationState;
                }

                return (0, esm_extends /* default */.Z)({}, paginationState, {
                    page: Math.max(
                        Math.min(
                            paginationState.page,
                            paginationState.pageCount - 1
                        ),
                        0
                    ),
                });
            };

            const mergeStateWithPage = (page) => (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    pagination: applyValidPage(
                        (0, esm_extends /* default */.Z)({}, state.pagination, {
                            page,
                        })
                    ),
                });

            const noRowCountInServerMode = (0, warning /* buildWarning */.b)(
                [
                    "MUI: the 'rowCount' prop is undefined while using paginationMode='server'",
                    "For more detail, see http://mui.com/components/data-grid/pagination/#basic-implementation",
                ],
                "error"
            );
            /**
             * @requires useGridPageSize (event)
             */

            const useGridPage = (apiRef, props) => {
                var _props$initialState2, _props$initialState2$;

                const logger = useGridLogger(apiRef, "useGridPage");
                const visibleTopLevelRowCount = useGridSelector(
                    apiRef,
                    gridVisibleTopLevelRowCountSelector
                );
                apiRef.current.unstable_updateControlState({
                    stateId: "page",
                    propModel: props.page,
                    propOnChange: props.onPageChange,
                    stateSelector: gridPageSelector,
                    changeEvent:
                        gridEvents /* GridEvents.pageChange */.t.pageChange,
                });
                /**
                 * API METHODS
                 */

                const setPage = react.useCallback(
                    (page) => {
                        logger.debug(`Setting page to ${page}`);
                        apiRef.current.setState(mergeStateWithPage(page));
                        apiRef.current.forceUpdate();
                    },
                    [apiRef, logger]
                );
                const pageApi = {
                    setPage,
                };
                useGridApiMethod(apiRef, pageApi, "GridPageApi");
                /**
                 * PRE-PROCESSING
                 */

                const stateExportPreProcessing = react.useCallback(
                    (prevState) => {
                        var _props$initialState, _props$initialState$p;

                        const pageToExport = gridPageSelector(apiRef);
                        const shouldExportPage = // Always export if the page is controlled
                            props.page != null || // Always export if the page has been initialized
                            ((_props$initialState = props.initialState) == null
                                ? void 0
                                : (_props$initialState$p =
                                      _props$initialState.pagination) == null
                                ? void 0
                                : _props$initialState$p.page) != null || // Export if the page value is not equal to the default value
                            pageToExport !== 0;

                        if (!shouldExportPage) {
                            return prevState;
                        }

                        return (0, esm_extends /* default */.Z)({}, prevState, {
                            pagination: (0, esm_extends /* default */.Z)(
                                {},
                                prevState.pagination,
                                {
                                    page: pageToExport,
                                }
                            ),
                        });
                    },
                    [
                        apiRef,
                        props.page,
                        (_props$initialState2 = props.initialState) == null
                            ? void 0
                            : (_props$initialState2$ =
                                  _props$initialState2.pagination) == null
                            ? void 0
                            : _props$initialState2$.page,
                    ]
                );
                const stateRestorePreProcessing = react.useCallback(
                    (params, context) => {
                        var _context$stateToResto, _context$stateToResto2;

                        // We apply the constraint even if the page did not change in case the pageSize changed.
                        const page =
                            (_context$stateToResto =
                                (_context$stateToResto2 =
                                    context.stateToRestore.pagination) == null
                                    ? void 0
                                    : _context$stateToResto2.page) != null
                                ? _context$stateToResto
                                : gridPageSelector(apiRef);
                        apiRef.current.setState(mergeStateWithPage(page));
                        return params;
                    },
                    [apiRef]
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "exportState",
                    stateExportPreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "restoreState",
                    stateRestorePreProcessing
                );
                /**
                 * EVENTS
                 */

                const handlePageSizeChange = (pageSize) => {
                    apiRef.current.setState((state) => {
                        const pageCount = getPageCount(
                            state.pagination.rowCount,
                            pageSize
                        );
                        return (0, esm_extends /* default */.Z)({}, state, {
                            pagination: applyValidPage(
                                (0, esm_extends /* default */.Z)(
                                    {},
                                    state.pagination,
                                    {
                                        pageCount,
                                        page: state.pagination.page,
                                    }
                                )
                            ),
                        });
                    });
                    apiRef.current.forceUpdate();
                };

                const handlePageChange = () =>
                    apiRef.current.scrollToIndexes({
                        rowIndex:
                            gridPageSelector(apiRef) *
                            gridPageSizeSelector(apiRef),
                    });

                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.pageSizeChange */.t.pageSizeChange,
                    handlePageSizeChange
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.pageChange */.t.pageChange,
                    handlePageChange
                );
                /**
                 * EFFECTS
                 */

                react.useEffect(() => {
                    if (false) {
                    }
                }, [props.rowCount, props.paginationMode]);
                react.useEffect(() => {
                    apiRef.current.setState((state) => {
                        const rowCount =
                            props.rowCount !== undefined
                                ? props.rowCount
                                : visibleTopLevelRowCount;
                        const pageCount = getPageCount(
                            rowCount,
                            state.pagination.pageSize
                        );
                        const page =
                            props.page == null
                                ? state.pagination.page
                                : props.page;
                        return (0, esm_extends /* default */.Z)({}, state, {
                            pagination: applyValidPage(
                                (0, esm_extends /* default */.Z)(
                                    {},
                                    state.pagination,
                                    {
                                        page,
                                        rowCount,
                                        pageCount,
                                    }
                                )
                            ),
                        });
                    });
                    apiRef.current.forceUpdate();
                }, [
                    visibleTopLevelRowCount,
                    props.rowCount,
                    props.page,
                    props.paginationMode,
                    apiRef,
                ]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/pagination/useGridPagination.js
            const paginationStateInitializer = (state, props) => {
                var _props$initialState,
                    _props$initialState$p,
                    _ref,
                    _props$page,
                    _props$initialState2,
                    _props$initialState2$,
                    _props$rowCount,
                    _props$rowCount2;

                let pageSize;

                if (props.pageSize != null) {
                    pageSize = props.pageSize;
                } else if (
                    ((_props$initialState = props.initialState) == null
                        ? void 0
                        : (_props$initialState$p =
                              _props$initialState.pagination) == null
                        ? void 0
                        : _props$initialState$p.pageSize) != null
                ) {
                    pageSize = props.initialState.pagination.pageSize;
                } else {
                    pageSize = defaultPageSize(props.autoPageSize);
                }

                return (0, esm_extends /* default */.Z)({}, state, {
                    pagination: {
                        pageSize,
                        page:
                            (_ref =
                                (_props$page = props.page) != null
                                    ? _props$page
                                    : (_props$initialState2 =
                                          props.initialState) == null
                                    ? void 0
                                    : (_props$initialState2$ =
                                          _props$initialState2.pagination) ==
                                      null
                                    ? void 0
                                    : _props$initialState2$.page) != null
                                ? _ref
                                : 0,
                        pageCount: getPageCount(
                            (_props$rowCount = props.rowCount) != null
                                ? _props$rowCount
                                : 0,
                            pageSize
                        ),
                        rowCount:
                            (_props$rowCount2 = props.rowCount) != null
                                ? _props$rowCount2
                                : 0,
                    },
                });
            };
            /**
             * @requires useGridFilter (state)
             * @requires useGridDimensions (event) - can be after
             */

            const useGridPagination = (apiRef, props) => {
                useGridPageSize(apiRef, props);
                useGridPage(apiRef, props);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/preferencesPanel/gridPreferencePanelSelector.js
            const gridPreferencePanelStateSelector = (state) =>
                state.preferencePanel; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/preferencesPanel/useGridPreferencesPanel.js
            const preferencePanelStateInitializer = (state, props) => {
                var _props$initialState$p, _props$initialState;

                return (0, esm_extends /* default */.Z)({}, state, {
                    preferencePanel:
                        (_props$initialState$p =
                            (_props$initialState = props.initialState) == null
                                ? void 0
                                : _props$initialState.preferencePanel) != null
                            ? _props$initialState$p
                            : {
                                  open: false,
                              },
                });
            };
            /**
             * TODO: Add a single `setPreferencePanel` method to avoid multiple `setState`
             */

            const useGridPreferencesPanel = (apiRef) => {
                const logger = useGridLogger(apiRef, "useGridPreferencesPanel");
                const preferencePanelState = useGridSelector(
                    apiRef,
                    gridPreferencePanelStateSelector
                );
                const hideTimeout = react.useRef();
                const immediateTimeout = react.useRef();
                /**
                 * API METHODS
                 */

                const hidePreferences = react.useCallback(() => {
                    logger.debug("Hiding Preferences Panel");

                    if (preferencePanelState.openedPanelValue) {
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.preferencePanelClose */.t
                                .preferencePanelClose,
                            {
                                openedPanelValue:
                                    preferencePanelState.openedPanelValue,
                            }
                        );
                    }

                    apiRef.current.setState((state) =>
                        (0, esm_extends /* default */.Z)({}, state, {
                            preferencePanel: {
                                open: false,
                            },
                        })
                    );
                    apiRef.current.forceUpdate();
                }, [apiRef, logger, preferencePanelState.openedPanelValue]); // This is to prevent the preferences from closing when you open a select box or another panel,
                // The issue is in MUI core V4 => Fixed in V5

                const doNotHidePanel = react.useCallback(() => {
                    immediateTimeout.current = setTimeout(
                        () => clearTimeout(hideTimeout.current),
                        0
                    );
                }, []); // This is a hack for the issue with Core V4, by delaying hiding the panel on the clickAwayListener,
                // we can cancel the action if the trigger element still need the panel...

                const hidePreferencesDelayed = react.useCallback(() => {
                    hideTimeout.current = setTimeout(hidePreferences, 100);
                }, [hidePreferences]);
                const showPreferences = react.useCallback(
                    (newValue) => {
                        logger.debug("Opening Preferences Panel");
                        doNotHidePanel();
                        apiRef.current.setState((state) =>
                            (0, esm_extends /* default */.Z)({}, state, {
                                preferencePanel: (0,
                                esm_extends /* default */.Z)(
                                    {},
                                    state.preferencePanel,
                                    {
                                        open: true,
                                        openedPanelValue: newValue,
                                    }
                                ),
                            })
                        );
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.preferencePanelOpen */.t
                                .preferencePanelOpen,
                            {
                                openedPanelValue: newValue,
                            }
                        );
                        apiRef.current.forceUpdate();
                    },
                    [logger, doNotHidePanel, apiRef]
                );
                useGridApiMethod(
                    apiRef,
                    {
                        showPreferences,
                        hidePreferences: hidePreferencesDelayed,
                    },
                    "ColumnMenuApi"
                );
                /**
                 * PRE-PROCESSING
                 */

                const stateExportPreProcessing = react.useCallback(
                    (prevState) => {
                        const preferencePanelToExport =
                            gridPreferencePanelStateSelector(
                                apiRef.current.state
                            );

                        if (
                            !preferencePanelToExport.open &&
                            !preferencePanelToExport.openedPanelValue
                        ) {
                            return prevState;
                        }

                        return (0, esm_extends /* default */.Z)({}, prevState, {
                            preferencePanel: preferencePanelToExport,
                        });
                    },
                    [apiRef]
                );
                const stateRestorePreProcessing = react.useCallback(
                    (params, context) => {
                        const preferencePanel =
                            context.stateToRestore.preferencePanel;

                        if (preferencePanel != null) {
                            apiRef.current.setState((state) =>
                                (0, esm_extends /* default */.Z)({}, state, {
                                    preferencePanel,
                                })
                            );
                        }

                        return params;
                    },
                    [apiRef]
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "exportState",
                    stateExportPreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "restoreState",
                    stateRestorePreProcessing
                );
                /**
                 * EFFECTS
                 */

                react.useEffect(() => {
                    return () => {
                        clearTimeout(hideTimeout.current);
                        clearTimeout(immediateTimeout.current);
                    };
                }, []);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/editRows/gridEditRowsSelector.js
            // TODO v6: rename to gridEditingStateSelector
            const gridEditRowsStateSelector = (state) => state.editRows; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/editRows/useGridCellEditing.old.js
            function isPromise(promise) {
                return typeof promise.then === "function";
            }

            const useCellEditing = (apiRef, props) => {
                var _props$experimentalFe2;

                const logger = useGridLogger(apiRef, "useGridEditRows");

                const buildCallback =
                    (callback) =>
                    (...args) => {
                        if (props.editMode === GridEditModes.Cell) {
                            callback(...args);
                        }
                    };

                const setCellMode = react.useCallback(
                    (id, field, mode) => {
                        if (apiRef.current.getCellMode(id, field) === mode) {
                            return;
                        }

                        logger.debug(
                            `Switching cell id: ${id} field: ${field} to mode: ${mode}`
                        );
                        apiRef.current.setState((state) => {
                            const newEditRowsState = (0,
                            esm_extends /* default */.Z)({}, state.editRows);

                            newEditRowsState[id] = (0,
                            esm_extends /* default */.Z)(
                                {},
                                newEditRowsState[id]
                            );

                            if (mode === GridCellModes.Edit) {
                                newEditRowsState[id][field] = {
                                    value: apiRef.current.getCellValue(
                                        id,
                                        field
                                    ),
                                };
                            } else {
                                delete newEditRowsState[id][field];

                                if (!Object.keys(newEditRowsState[id]).length) {
                                    delete newEditRowsState[id];
                                }
                            }

                            return (0, esm_extends /* default */.Z)({}, state, {
                                editRows: newEditRowsState,
                            });
                        });
                        apiRef.current.forceUpdate();
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.cellModeChange */.t
                                .cellModeChange,
                            apiRef.current.getCellParams(id, field)
                        );
                    },
                    [apiRef, logger]
                );
                const getCellMode = react.useCallback(
                    (id, field) => {
                        const editRowsState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        const isEditing =
                            editRowsState[id] && editRowsState[id][field];
                        return isEditing
                            ? GridCellModes.Edit
                            : GridCellModes.View;
                    },
                    [apiRef]
                ); // TODO v6: it should always return a promise

                const commitCellChange = react.useCallback(
                    (params, event = {}) => {
                        var _props$experimentalFe;

                        const { id, field } = params;
                        apiRef.current.unstable_runPendingEditCellValueMutation(
                            id,
                            field
                        );
                        const model = apiRef.current.getEditRowsModel();

                        if (!model[id] || !model[id][field]) {
                            throw new Error(
                                `MUI: Cell at id: ${id} and field: ${field} is not in edit mode.`
                            );
                        }

                        const editCellProps = model[id][field];
                        const column = apiRef.current.getColumn(field);
                        const row = apiRef.current.getRow(id);

                        if (
                            (_props$experimentalFe =
                                props.experimentalFeatures) != null &&
                            _props$experimentalFe.preventCommitWhileValidating
                        ) {
                            const cellProps = model[id][field];

                            if (cellProps.isValidating || cellProps.error) {
                                return false;
                            }
                        }

                        const commitParams = (0, esm_extends /* default */.Z)(
                            {},
                            params,
                            {
                                value: editCellProps.value,
                            }
                        );

                        let hasError = !!editCellProps.error;

                        if (
                            !hasError &&
                            typeof column.preProcessEditCellProps === "function"
                        ) {
                            const result = column.preProcessEditCellProps({
                                id,
                                row,
                                props: editCellProps,
                            });

                            if (isPromise(result)) {
                                return result.then((newEditCellProps) => {
                                    apiRef.current.unstable_setEditCellProps({
                                        id,
                                        field,
                                        props: newEditCellProps,
                                    });

                                    if (newEditCellProps.error) {
                                        return false;
                                    }

                                    apiRef.current.publishEvent(
                                        gridEvents /* GridEvents.cellEditCommit */
                                            .t.cellEditCommit,
                                        commitParams,
                                        event
                                    );
                                    return true;
                                });
                            }

                            apiRef.current.unstable_setEditCellProps({
                                id,
                                field,
                                props: result,
                            });
                            hasError = !!result.error;
                        }

                        if (!hasError) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellEditCommit */.t
                                    .cellEditCommit,
                                commitParams,
                                event
                            );
                            return true;
                        }

                        return false;
                    },
                    [
                        apiRef,
                        (_props$experimentalFe2 = props.experimentalFeatures) ==
                        null
                            ? void 0
                            : _props$experimentalFe2.preventCommitWhileValidating,
                    ]
                );
                const setCellEditingEditCellValue = react.useCallback(
                    (params) => {
                        const column = apiRef.current.getColumn(params.field);
                        const row = apiRef.current.getRow(params.id);
                        return new Promise((resolve) => {
                            let newEditCellProps = {
                                value: params.value,
                            };
                            const model = apiRef.current.getEditRowsModel();
                            const editCellProps =
                                model[params.id][params.field];

                            if (
                                typeof column.preProcessEditCellProps !==
                                "function"
                            ) {
                                apiRef.current.unstable_setEditCellProps(
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        params,
                                        {
                                            props: newEditCellProps,
                                        }
                                    )
                                );
                                resolve(true);
                                return;
                            } // setEditCellProps runs the value parser and returns the updated props

                            newEditCellProps =
                                apiRef.current.unstable_setEditCellProps(
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        params,
                                        {
                                            props: (0,
                                            esm_extends /* default */.Z)(
                                                {},
                                                editCellProps,
                                                {
                                                    isValidating: true,
                                                }
                                            ),
                                        }
                                    )
                                );
                            Promise.resolve(
                                column.preProcessEditCellProps({
                                    id: params.id,
                                    row,
                                    props: (0, esm_extends /* default */.Z)(
                                        {},
                                        newEditCellProps,
                                        {
                                            value: apiRef.current.unstable_parseValue(
                                                params.id,
                                                params.field,
                                                params.value
                                            ),
                                        }
                                    ),
                                })
                            ).then((newEditCellPropsProcessed) => {
                                apiRef.current.unstable_setEditCellProps(
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        params,
                                        {
                                            props: (0,
                                            esm_extends /* default */.Z)(
                                                {},
                                                newEditCellPropsProcessed,
                                                {
                                                    isValidating: false,
                                                }
                                            ),
                                        }
                                    )
                                );
                                resolve(!newEditCellPropsProcessed.error);
                            });
                        });
                    },
                    [apiRef]
                );
                const cellEditingApi = {
                    setCellMode,
                    getCellMode,
                    commitCellChange,
                    unstable_setCellEditingEditCellValue:
                        setCellEditingEditCellValue,
                };
                useGridApiMethod(apiRef, cellEditingApi, "EditRowApi");
                const handleCellKeyDown = react.useCallback(
                    async (params, event) => {
                        const { id, field, cellMode, isEditable } = params;

                        if (!isEditable) {
                            return;
                        }

                        const isEditMode = cellMode === GridCellModes.Edit;
                        const isModifierKeyPressed =
                            event.ctrlKey || event.metaKey || event.altKey;

                        if (
                            !isEditMode &&
                            isCellEnterEditModeKeys(event.key) &&
                            !isModifierKeyPressed &&
                            !(event.key === " " && event.shiftKey)
                        ) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellEditStart */.t
                                    .cellEditStart,
                                params,
                                event
                            );
                        }

                        if (!isEditMode && isDeleteKeys(event.key)) {
                            apiRef.current.setEditCellValue({
                                id,
                                field,
                                value: "",
                            });
                            apiRef.current.commitCellChange(
                                {
                                    id,
                                    field,
                                },
                                event
                            );
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellEditStop */.t
                                    .cellEditStop,
                                params,
                                event
                            );
                        }

                        if (isEditMode && isCellEditCommitKeys(event.key)) {
                            const commitParams = {
                                id,
                                field,
                            };
                            const isValid =
                                await apiRef.current.commitCellChange(
                                    commitParams,
                                    event
                                );

                            if (!isValid) {
                                return;
                            }
                        }

                        if (isEditMode && isCellExitEditModeKeys(event.key)) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellEditStop */.t
                                    .cellEditStop,
                                params,
                                event
                            );
                        }
                    },
                    [apiRef]
                );
                const handleCellDoubleClick = react.useCallback(
                    (params, event) => {
                        if (!params.isEditable) {
                            return;
                        }

                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.cellEditStart */.t
                                .cellEditStart,
                            params,
                            event
                        );
                    },
                    [apiRef]
                );

                const commitPropsAndExit = async (params, event) => {
                    if (params.cellMode === GridCellModes.View) {
                        return;
                    }

                    await apiRef.current.commitCellChange(params, event);
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.cellEditStop */.t.cellEditStop,
                        params,
                        event
                    );
                };

                const handleCellFocusOut = (0,
                useEventCallback /* default */.Z)((params, event) => {
                    commitPropsAndExit(params, event);
                });
                const handleColumnHeaderDragStart = (0,
                useEventCallback /* default */.Z)(() => {
                    const cell = gridFocusCellSelector(apiRef);

                    if (!cell) {
                        return;
                    }

                    const params = apiRef.current.getCellParams(
                        cell.id,
                        cell.field
                    );
                    commitPropsAndExit(params, {});
                });
                const handleCellEditStart = react.useCallback(
                    (params, event) => {
                        if (!params.isEditable) {
                            return;
                        }

                        apiRef.current.setCellMode(
                            params.id,
                            params.field,
                            GridCellModes.Edit
                        );

                        if (
                            isKeyboardEvent(event) &&
                            isPrintableKey(event.key)
                        ) {
                            apiRef.current.unstable_setEditCellProps({
                                id: params.id,
                                field: params.field,
                                props: {
                                    value: "",
                                },
                            });
                        }
                    },
                    [apiRef]
                );
                const handleCellEditStop = react.useCallback(
                    (params, event) => {
                        apiRef.current.setCellMode(
                            params.id,
                            params.field,
                            GridCellModes.View
                        );

                        if (!isKeyboardEvent(event)) {
                            return;
                        }

                        if (isCellEditCommitKeys(event.key)) {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellNavigationKeyDown */
                                    .t.cellNavigationKeyDown,
                                params,
                                event
                            );
                            return;
                        }

                        if (event.key === "Escape" || isDeleteKeys(event.key)) {
                            apiRef.current.setCellFocus(
                                params.id,
                                params.field
                            );
                        }
                    },
                    [apiRef]
                );
                const handleCellEditCommit = react.useCallback(
                    (params) => {
                        const { id, field } = params;
                        const model = apiRef.current.getEditRowsModel();
                        const { value } = model[id][field];
                        logger.debug(
                            `Setting cell id: ${id} field: ${field} to value: ${
                                value == null ? void 0 : value.toString()
                            }`
                        );
                        const row = apiRef.current.getRow(id);

                        if (row) {
                            const column = apiRef.current.getColumn(
                                params.field
                            );

                            let rowUpdate = (0, esm_extends /* default */.Z)(
                                {},
                                row,
                                {
                                    [field]: value,
                                }
                            );

                            if (column.valueSetter) {
                                rowUpdate = column.valueSetter({
                                    row,
                                    value,
                                });
                            }

                            apiRef.current.updateRows([rowUpdate]);
                        }
                    },
                    [apiRef, logger]
                );
                const handleEditCellPropsChange = react.useCallback(
                    (params) => {
                        const row = apiRef.current.getRow(params.id);
                        const column = apiRef.current.getColumn(params.field);
                        const editCellProps = column.preProcessEditCellProps
                            ? column.preProcessEditCellProps({
                                  id: params.id,
                                  row,
                                  props: params.props,
                              })
                            : params.props;

                        if (isPromise(editCellProps)) {
                            editCellProps.then((newEditCellProps) => {
                                apiRef.current.unstable_setEditCellProps(
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        params,
                                        {
                                            props: newEditCellProps,
                                        }
                                    )
                                );
                            });
                        } else {
                            apiRef.current.unstable_setEditCellProps(
                                (0, esm_extends /* default */.Z)({}, params, {
                                    props: editCellProps,
                                })
                            );
                        }
                    },
                    [apiRef]
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    buildCallback(handleCellKeyDown)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellDoubleClick */.t
                        .cellDoubleClick,
                    buildCallback(handleCellDoubleClick)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellFocusOut */.t.cellFocusOut,
                    buildCallback(handleCellFocusOut)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderDragStart */.t
                        .columnHeaderDragStart,
                    buildCallback(handleColumnHeaderDragStart)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStart */.t.cellEditStart,
                    buildCallback(handleCellEditStart)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStop */.t.cellEditStop,
                    buildCallback(handleCellEditStop)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditCommit */.t.cellEditCommit,
                    buildCallback(handleCellEditCommit)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.editCellPropsChange */.t
                        .editCellPropsChange,
                    buildCallback(handleEditCellPropsChange)
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditCommit */.t.cellEditCommit,
                    props.onCellEditCommit
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStart */.t.cellEditStart,
                    props.onCellEditStart
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStop */.t.cellEditStop,
                    props.onCellEditStop
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/editRows/useGridRowEditing.old.js
            const useGridRowEditing = (apiRef, props) => {
                var _props$experimentalFe2, _props$experimentalFe4;

                const focusTimeout = react.useRef(null);
                const nextFocusedCell = react.useRef(null);
                const columns = useGridSelector(
                    apiRef,
                    gridColumnDefinitionsSelector
                );

                const buildCallback =
                    (callback) =>
                    (...args) => {
                        if (props.editMode === GridEditModes.Row) {
                            callback(...args);
                        }
                    };

                const setRowMode = react.useCallback(
                    (id, mode) => {
                        if (mode === apiRef.current.getRowMode(id)) {
                            return;
                        }

                        apiRef.current.setState((state) => {
                            const newEditRowsState = (0,
                            esm_extends /* default */.Z)({}, state.editRows);

                            if (mode === GridRowModes.Edit) {
                                newEditRowsState[id] = {};
                                columns.forEach((column) => {
                                    const cellParams =
                                        apiRef.current.getCellParams(
                                            id,
                                            column.field
                                        );

                                    if (cellParams.isEditable) {
                                        newEditRowsState[id][column.field] = {
                                            value: cellParams.value,
                                        };
                                    }
                                });
                            } else {
                                delete newEditRowsState[id];
                            }

                            return (0, esm_extends /* default */.Z)({}, state, {
                                editRows: newEditRowsState,
                            });
                        });
                        apiRef.current.forceUpdate();
                    },
                    [apiRef, columns]
                );
                const getRowMode = react.useCallback(
                    (id) => {
                        if (props.editMode === GridEditModes.Cell) {
                            return GridRowModes.View;
                        }

                        const editRowsState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        return editRowsState[id]
                            ? GridRowModes.Edit
                            : GridRowModes.View;
                    },
                    [apiRef, props.editMode]
                );
                const commitRowChange = react.useCallback(
                    (id, event = {}) => {
                        var _props$experimentalFe;

                        if (props.editMode === GridEditModes.Cell) {
                            throw new Error(
                                `MUI: You can't commit changes when the edit mode is 'cell'.`
                            );
                        }

                        apiRef.current.unstable_runPendingEditCellValueMutation(
                            id
                        );
                        const model = apiRef.current.getEditRowsModel();
                        const editRowProps = model[id];

                        if (!editRowProps) {
                            throw new Error(
                                `MUI: Row at id: ${id} is not being edited.`
                            );
                        }

                        if (
                            (_props$experimentalFe =
                                props.experimentalFeatures) != null &&
                            _props$experimentalFe.preventCommitWhileValidating
                        ) {
                            const isValid = Object.keys(editRowProps).reduce(
                                (acc, field) => {
                                    return (
                                        acc &&
                                        !editRowProps[field].isValidating &&
                                        !editRowProps[field].error
                                    );
                                },
                                true
                            );

                            if (!isValid) {
                                return false;
                            }
                        }

                        const hasFieldWithError = Object.values(
                            editRowProps
                        ).some((value) => !!value.error);

                        if (hasFieldWithError) {
                            return false;
                        }

                        const fieldsWithValidator = Object.keys(
                            editRowProps
                        ).filter((field) => {
                            const column = apiRef.current.getColumn(field);
                            return (
                                typeof column.preProcessEditCellProps ===
                                "function"
                            );
                        });

                        if (fieldsWithValidator.length > 0) {
                            const row = apiRef.current.getRow(id);
                            const validatorErrors = fieldsWithValidator.map(
                                async (field) => {
                                    const column =
                                        apiRef.current.getColumn(field);
                                    const newEditCellProps =
                                        await Promise.resolve(
                                            column.preProcessEditCellProps({
                                                id,
                                                row,
                                                props: editRowProps[field],
                                            })
                                        );
                                    apiRef.current.unstable_setEditCellProps({
                                        id,
                                        field,
                                        props: newEditCellProps,
                                    });
                                    return newEditCellProps.error;
                                }
                            );
                            return Promise.all(validatorErrors).then(
                                (errors) => {
                                    if (errors.some((error) => !!error)) {
                                        return false;
                                    }

                                    apiRef.current.publishEvent(
                                        gridEvents /* GridEvents.rowEditCommit */
                                            .t.rowEditCommit,
                                        id,
                                        event
                                    );
                                    return true;
                                }
                            );
                        }

                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.rowEditCommit */.t
                                .rowEditCommit,
                            id,
                            event
                        );
                        return true;
                    },
                    [
                        apiRef,
                        props.editMode,
                        (_props$experimentalFe2 = props.experimentalFeatures) ==
                        null
                            ? void 0
                            : _props$experimentalFe2.preventCommitWhileValidating,
                    ]
                );
                const setRowEditingEditCellValue = react.useCallback(
                    (params) => {
                        const model = apiRef.current.getEditRowsModel();
                        const editRow = model[params.id];
                        const row = apiRef.current.getRow(params.id);
                        let isValid = true;
                        return new Promise((resolve) => {
                            Object.keys(editRow).forEach(async (field) => {
                                const column = apiRef.current.getColumn(field);
                                let editCellProps =
                                    field === params.field
                                        ? {
                                              value: params.value,
                                          }
                                        : editRow[field]; // setEditCellProps runs the value parser and returns the updated props

                                editCellProps =
                                    apiRef.current.unstable_setEditCellProps({
                                        id: params.id,
                                        field,
                                        props: (0, esm_extends /* default */.Z)(
                                            {},
                                            editCellProps,
                                            {
                                                isValidating: true,
                                            }
                                        ),
                                    });

                                if (column.preProcessEditCellProps) {
                                    editCellProps = await Promise.resolve(
                                        column.preProcessEditCellProps({
                                            id: params.id,
                                            row,
                                            props: (0,
                                            esm_extends /* default */.Z)(
                                                {},
                                                editCellProps,
                                                {
                                                    value:
                                                        field === params.field
                                                            ? apiRef.current.unstable_parseValue(
                                                                  params.id,
                                                                  field,
                                                                  params.value
                                                              )
                                                            : editCellProps.value,
                                                }
                                            ),
                                        })
                                    );
                                }

                                if (editCellProps.error) {
                                    isValid = false;
                                }

                                apiRef.current.unstable_setEditCellProps({
                                    id: params.id,
                                    field,
                                    props: (0, esm_extends /* default */.Z)(
                                        {},
                                        editCellProps,
                                        {
                                            isValidating: false,
                                        }
                                    ),
                                });
                            });
                            resolve(isValid);
                        });
                    },
                    [apiRef]
                );
                const rowEditingApi = {
                    setRowMode,
                    getRowMode,
                    commitRowChange,
                    unstable_setRowEditingEditCellValue:
                        setRowEditingEditCellValue,
                };
                useGridApiMethod(apiRef, rowEditingApi, "EditRowApi");
                const handleCellKeyDown = react.useCallback(
                    async (params, event) => {
                        const { cellMode, isEditable } = params;

                        if (!isEditable) {
                            return;
                        }

                        const isEditMode = cellMode === GridCellModes.Edit;
                        const rowParams = apiRef.current.getRowParams(
                            params.id
                        );

                        if (isEditMode) {
                            if (event.key === "Enter") {
                                var _props$experimentalFe3;

                                // TODO: check the return before firing GridEvents.rowEditStop
                                // On cell editing, it won't exits the edit mode with error
                                const isValid =
                                    await apiRef.current.commitRowChange(
                                        params.id
                                    );

                                if (
                                    !isValid &&
                                    (_props$experimentalFe3 =
                                        props.experimentalFeatures) != null &&
                                    _props$experimentalFe3.preventCommitWhileValidating
                                ) {
                                    return;
                                }

                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.rowEditStop */.t
                                        .rowEditStop,
                                    rowParams,
                                    event
                                );
                            } else if (event.key === "Escape") {
                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.rowEditStop */.t
                                        .rowEditStop,
                                    rowParams,
                                    event
                                );
                            }
                        } else if (event.key === "Enter") {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.rowEditStart */.t
                                    .rowEditStart,
                                rowParams,
                                event
                            );
                        }
                    },
                    [
                        apiRef,
                        (_props$experimentalFe4 = props.experimentalFeatures) ==
                        null
                            ? void 0
                            : _props$experimentalFe4.preventCommitWhileValidating,
                    ]
                );
                const handleCellDoubleClick = react.useCallback(
                    (params, event) => {
                        if (!params.isEditable) {
                            return;
                        }

                        const rowParams = apiRef.current.getRowParams(
                            params.id
                        );
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.rowEditStart */.t
                                .rowEditStart,
                            rowParams,
                            event
                        );
                    },
                    [apiRef]
                );
                const handleEditCellPropsChange = react.useCallback(
                    (params) => {
                        const row = apiRef.current.getRow(params.id);
                        const model = apiRef.current.getEditRowsModel();
                        const editRow = model[params.id];
                        Object.keys(editRow).forEach(async (field) => {
                            const column = apiRef.current.getColumn(field);

                            if (column.preProcessEditCellProps) {
                                const editCellProps =
                                    field === params.field
                                        ? params.props
                                        : editRow[field];
                                const newEditCellProps = await Promise.resolve(
                                    column.preProcessEditCellProps({
                                        id: params.id,
                                        row,
                                        props: editCellProps,
                                    })
                                );
                                apiRef.current.unstable_setEditCellProps({
                                    id: params.id,
                                    field,
                                    props: newEditCellProps,
                                });
                            } else if (field === params.field) {
                                apiRef.current.unstable_setEditCellProps(
                                    params
                                );
                            }
                        });
                    },
                    [apiRef]
                );
                const handleRowEditStart = react.useCallback(
                    (params) => {
                        apiRef.current.setRowMode(params.id, GridRowModes.Edit);
                    },
                    [apiRef]
                );
                const handleRowEditStop = react.useCallback(
                    (params, event) => {
                        apiRef.current.setRowMode(params.id, GridRowModes.View);

                        if (event.key === "Enter") {
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.cellNavigationKeyDown */
                                    .t.cellNavigationKeyDown,
                                params,
                                event
                            );
                        }
                    },
                    [apiRef]
                );
                const handleRowEditCommit = react.useCallback(
                    (id) => {
                        const model = apiRef.current.getEditRowsModel();
                        const editRow = model[id];

                        if (!editRow) {
                            throw new Error(
                                `MUI: Row at id: ${id} is not being edited.`
                            );
                        }

                        const row = apiRef.current.getRow(id);

                        if (row) {
                            let rowUpdate = (0, esm_extends /* default */.Z)(
                                {},
                                row
                            );

                            Object.keys(editRow).forEach((field) => {
                                const column = apiRef.current.getColumn(field);
                                const value = editRow[field].value;

                                if (column.valueSetter) {
                                    rowUpdate = column.valueSetter({
                                        row: rowUpdate,
                                        value,
                                    });
                                } else {
                                    rowUpdate[field] = value;
                                }
                            });
                            apiRef.current.updateRows([rowUpdate]);
                        }
                    },
                    [apiRef]
                );
                const handleCellFocusIn = react.useCallback((params) => {
                    nextFocusedCell.current = params;
                }, []);

                const commitPropsAndExit = async (params, event) => {
                    if (params.cellMode === GridCellModes.View) {
                        return;
                    }

                    nextFocusedCell.current = null;
                    focusTimeout.current = setTimeout(async () => {
                        var _nextFocusedCell$curr;

                        if (
                            ((_nextFocusedCell$curr =
                                nextFocusedCell.current) == null
                                ? void 0
                                : _nextFocusedCell$curr.id) !== params.id
                        ) {
                            await apiRef.current.commitRowChange(
                                params.id,
                                event
                            );
                            const rowParams = apiRef.current.getRowParams(
                                params.id
                            );
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.rowEditStop */.t
                                    .rowEditStop,
                                rowParams,
                                event
                            );
                        }
                    });
                };

                const handleCellFocusOut = (0,
                useEventCallback /* default */.Z)((params, event) => {
                    commitPropsAndExit(params, event);
                });
                const handleColumnHeaderDragStart = (0,
                useEventCallback /* default */.Z)(() => {
                    const cell = gridFocusCellSelector(apiRef);

                    if (!cell) {
                        return;
                    }

                    const params = apiRef.current.getCellParams(
                        cell.id,
                        cell.field
                    );
                    commitPropsAndExit(params, {});
                });
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    buildCallback(handleCellKeyDown)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellDoubleClick */.t
                        .cellDoubleClick,
                    buildCallback(handleCellDoubleClick)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.editCellPropsChange */.t
                        .editCellPropsChange,
                    buildCallback(handleEditCellPropsChange)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStart */.t.rowEditStart,
                    buildCallback(handleRowEditStart)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStop */.t.rowEditStop,
                    buildCallback(handleRowEditStop)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditCommit */.t.rowEditCommit,
                    buildCallback(handleRowEditCommit)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellFocusIn */.t.cellFocusIn,
                    buildCallback(handleCellFocusIn)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellFocusOut */.t.cellFocusOut,
                    buildCallback(handleCellFocusOut)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderDragStart */.t
                        .columnHeaderDragStart,
                    buildCallback(handleColumnHeaderDragStart)
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditCommit */.t.rowEditCommit,
                    props.onRowEditCommit
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStart */.t.rowEditStart,
                    props.onRowEditStart
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStop */.t.rowEditStop,
                    props.onRowEditStop
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/editRows/useGridEditing.old.js
            const editingStateInitializer = (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    editRows: {},
                });
            /**
             * @requires useGridFocus - can be after, async only
             * @requires useGridParamsApi (method)
             * @requires useGridColumns (state)
             */

            function useGridEditing_old_useGridEditing(apiRef, props) {
                var _props$experimentalFe2;

                const logger = useGridLogger(apiRef, "useGridEditRows");
                useCellEditing(apiRef, props);
                useGridRowEditing(apiRef, props);
                const debounceMap = react.useRef({});
                apiRef.current.unstable_updateControlState({
                    stateId: "editRows",
                    propModel: props.editRowsModel,
                    propOnChange: props.onEditRowsModelChange,
                    stateSelector: gridEditRowsStateSelector,
                    changeEvent:
                        gridEvents /* GridEvents.editRowsModelChange */.t
                            .editRowsModelChange,
                });
                const isCellEditable = react.useCallback(
                    (params) =>
                        !params.rowNode.isAutoGenerated &&
                        !!params.colDef.editable &&
                        !!params.colDef.renderEditCell &&
                        (!props.isCellEditable || props.isCellEditable(params)), // eslint-disable-next-line react-hooks/exhaustive-deps
                    [props.isCellEditable]
                );

                const maybeDebounce = (id, field, debounceMs, callback) => {
                    if (!debounceMs) {
                        callback();
                        return;
                    }

                    if (!debounceMap.current[id]) {
                        debounceMap.current[id] = {};
                    }

                    if (debounceMap.current[id][field]) {
                        const [timeout] = debounceMap.current[id][field];
                        clearTimeout(timeout);
                    }

                    const callbackToRunImmediately = () => {
                        callback();
                        const [timeout] = debounceMap.current[id][field];
                        clearTimeout(timeout);
                        delete debounceMap.current[id][field];
                    };

                    const timeout = setTimeout(() => {
                        callback();
                        delete debounceMap.current[id][field];
                    }, debounceMs);
                    debounceMap.current[id][field] = [
                        timeout,
                        callbackToRunImmediately,
                    ];
                };

                const runPendingEditCellValueMutation = react.useCallback(
                    (id, field) => {
                        if (!debounceMap.current[id]) {
                            return;
                        }

                        if (!field) {
                            Object.keys(debounceMap.current[id]).forEach(
                                (debouncedField) => {
                                    const [, callback] =
                                        debounceMap.current[id][debouncedField];
                                    callback();
                                }
                            );
                        } else if (debounceMap.current[id][field]) {
                            const [, callback] = debounceMap.current[id][field];
                            callback();
                        }
                    },
                    []
                );
                const setEditCellValue = react.useCallback(
                    (params, event = {}) => {
                        maybeDebounce(
                            params.id,
                            params.field,
                            params.debounceMs,
                            () => {
                                var _props$experimentalFe;

                                if (
                                    (_props$experimentalFe =
                                        props.experimentalFeatures) != null &&
                                    _props$experimentalFe.preventCommitWhileValidating
                                ) {
                                    if (props.editMode === "row") {
                                        return apiRef.current.unstable_setRowEditingEditCellValue(
                                            params
                                        );
                                    }

                                    return apiRef.current.unstable_setCellEditingEditCellValue(
                                        params
                                    );
                                }

                                const newParams = {
                                    id: params.id,
                                    field: params.field,
                                    props: {
                                        value: params.value,
                                    },
                                };
                                return apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.editCellPropsChange */
                                        .t.editCellPropsChange,
                                    newParams,
                                    event
                                );
                            }
                        );
                    },
                    [
                        apiRef,
                        props.editMode,
                        (_props$experimentalFe2 = props.experimentalFeatures) ==
                        null
                            ? void 0
                            : _props$experimentalFe2.preventCommitWhileValidating,
                    ]
                );
                const parseValue = react.useCallback(
                    (id, field, value) => {
                        const column = apiRef.current.getColumn(field);
                        return column.valueParser
                            ? column.valueParser(
                                  value,
                                  apiRef.current.getCellParams(id, field)
                              )
                            : value;
                    },
                    [apiRef]
                );
                const setEditCellProps = react.useCallback(
                    (params) => {
                        const { id, field, props: editProps } = params;
                        logger.debug(
                            `Setting cell props on id: ${id} field: ${field}`
                        );
                        apiRef.current.setState((state) => {
                            const editRowsModel = (0,
                            esm_extends /* default */.Z)({}, state.editRows);

                            editRowsModel[id] = (0,
                            esm_extends /* default */.Z)(
                                {},
                                state.editRows[id]
                            );
                            editRowsModel[id][field] = (0,
                            esm_extends /* default */.Z)({}, editProps, {
                                value: parseValue(id, field, editProps.value),
                            });
                            return (0, esm_extends /* default */.Z)({}, state, {
                                editRows: editRowsModel,
                            });
                        });
                        apiRef.current.forceUpdate();
                        const editRowsState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        return editRowsState[id][field];
                    },
                    [apiRef, logger, parseValue]
                );
                const setEditRowsModel = react.useCallback(
                    (model) => {
                        const currentModel = gridEditRowsStateSelector(
                            apiRef.current.state
                        );

                        if (currentModel !== model) {
                            logger.debug(`Setting editRows model`);
                            apiRef.current.setState((state) =>
                                (0, esm_extends /* default */.Z)({}, state, {
                                    editRows: model,
                                })
                            );
                            apiRef.current.forceUpdate();
                        }
                    },
                    [apiRef, logger]
                );
                const getEditRowsModel = react.useCallback(
                    () => gridEditRowsStateSelector(apiRef.current.state),
                    [apiRef]
                );
                const preventTextSelection = react.useCallback(
                    (params, event) => {
                        const isMoreThanOneClick = event.detail > 1;

                        if (
                            params.isEditable &&
                            params.cellMode === GridCellModes.View &&
                            isMoreThanOneClick
                        ) {
                            // If we click more than one time, then we prevent the default behavior of selecting the text cell.
                            event.preventDefault();
                        }
                    },
                    []
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellMouseDown */.t.cellMouseDown,
                    preventTextSelection
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.editCellPropsChange */.t
                        .editCellPropsChange,
                    props.onEditCellPropsChange
                ); // TODO v6: remove, use `preProcessEditCellProps` instead

                const editingSharedApi = {
                    isCellEditable,
                    setEditRowsModel,
                    getEditRowsModel,
                    setEditCellValue,
                    unstable_setEditCellProps: setEditCellProps,
                    unstable_parseValue: parseValue,
                    unstable_runPendingEditCellValueMutation:
                        runPendingEditCellValueMutation,
                };
                useGridApiMethod(apiRef, editingSharedApi, "EditRowApi");
                react.useEffect(() => {
                    if (props.editRowsModel !== undefined) {
                        apiRef.current.setEditRowsModel(props.editRowsModel);
                    }
                }, [apiRef, props.editRowsModel]);
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/models/params/gridEditCellParams.js
            // TODO v6 - remove

            /**
             * Params passed to `apiRef.current.setEditCellValue`.
             */
            // TODO v6 - remove
            // TODO v6 - remove
            var GridCellEditStartReasons;
            /**
             * Params passed to the `cellEditStart` event.
             */

            (function (GridCellEditStartReasons) {
                GridCellEditStartReasons["enterKeyDown"] = "enterKeyDown";
                GridCellEditStartReasons["cellDoubleClick"] = "cellDoubleClick";
                GridCellEditStartReasons["printableKeyDown"] =
                    "printableKeyDown";
                GridCellEditStartReasons["deleteKeyDown"] = "deleteKeyDown";
            })(GridCellEditStartReasons || (GridCellEditStartReasons = {}));

            var GridCellEditStopReasons;
            /**
             * Params passed to the `cellEditStop event.
             */

            (function (GridCellEditStopReasons) {
                GridCellEditStopReasons["cellFocusOut"] = "cellFocusOut";
                GridCellEditStopReasons["escapeKeyDown"] = "escapeKeyDown";
                GridCellEditStopReasons["enterKeyDown"] = "enterKeyDown";
                GridCellEditStopReasons["tabKeyDown"] = "tabKeyDown";
                GridCellEditStopReasons["shiftTabKeyDown"] = "shiftTabKeyDown";
            })(GridCellEditStopReasons || (GridCellEditStopReasons = {})); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/editRows/useGridCellEditing.new.js

            // https://github.com/mui/mui-x/pull/3738#discussion_r798504277

            const missingOnProcessRowUpdateErrorWarning = (0,
            warning /* buildWarning */.b)(
                [
                    "MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.",
                    "To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.",
                    "For more detail, see http://mui.com/components/data-grid/editing/#persistence.",
                ],
                "error"
            );
            const useGridCellEditing = (apiRef, props) => {
                const { processRowUpdate, onProcessRowUpdateError } = props;

                const runIfEditModeIsCell =
                    (callback) =>
                    (...args) => {
                        if (props.editMode === GridEditModes.Cell) {
                            callback(...args);
                        }
                    };

                const throwIfNotEditable = react.useCallback(
                    (id, field) => {
                        const params = apiRef.current.getCellParams(id, field);

                        if (!apiRef.current.isCellEditable(params)) {
                            throw new Error(
                                `MUI: The cell with id=${id} and field=${field} is not editable.`
                            );
                        }
                    },
                    [apiRef]
                );
                const throwIfNotInMode = react.useCallback(
                    (id, field, mode) => {
                        if (apiRef.current.getCellMode(id, field) !== mode) {
                            throw new Error(
                                `MUI: The cell with id=${id} and field=${field} is not in ${mode} mode.`
                            );
                        }
                    },
                    [apiRef]
                );
                const handleCellDoubleClick = react.useCallback(
                    (params, event) => {
                        if (!params.isEditable) {
                            return;
                        }

                        if (params.cellMode === GridCellModes.Edit) {
                            return;
                        }

                        const newParams = (0, esm_extends /* default */.Z)(
                            {},
                            params,
                            {
                                reason: GridCellEditStartReasons.cellDoubleClick,
                            }
                        );

                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.cellEditStart */.t
                                .cellEditStart,
                            newParams,
                            event
                        );
                    },
                    [apiRef]
                );
                const handleCellFocusOut = react.useCallback(
                    (params, event) => {
                        if (params.cellMode === GridCellModes.View) {
                            return;
                        }

                        const newParams = (0, esm_extends /* default */.Z)(
                            {},
                            params,
                            {
                                reason: GridCellEditStopReasons.cellFocusOut,
                            }
                        );

                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.cellEditStop */.t
                                .cellEditStop,
                            newParams,
                            event
                        );
                    },
                    [apiRef]
                );
                const handleCellKeyDown = react.useCallback(
                    (params, event) => {
                        if (params.cellMode === GridCellModes.Edit) {
                            let reason;

                            if (event.key === "Escape") {
                                reason = GridCellEditStopReasons.escapeKeyDown;
                            } else if (event.key === "Enter") {
                                reason = GridCellEditStopReasons.enterKeyDown;
                            } else if (event.key === "Tab") {
                                reason = event.shiftKey
                                    ? GridCellEditStopReasons.shiftTabKeyDown
                                    : GridCellEditStopReasons.tabKeyDown;
                                event.preventDefault(); // Prevent going to the next element in the tab sequence
                            }

                            if (reason) {
                                const newParams = (0,
                                esm_extends /* default */.Z)({}, params, {
                                    reason,
                                });

                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.cellEditStop */.t
                                        .cellEditStop,
                                    newParams,
                                    event
                                );
                            }
                        } else if (params.isEditable) {
                            let reason;

                            if (isPrintableKey(event.key)) {
                                if (
                                    event.shiftKey ||
                                    event.ctrlKey ||
                                    event.metaKey ||
                                    event.altKey
                                ) {
                                    return;
                                }

                                reason =
                                    GridCellEditStartReasons.printableKeyDown;
                            } else if (event.key === "Enter") {
                                reason = GridCellEditStartReasons.enterKeyDown;
                            } else if (event.key === "Delete") {
                                reason = GridCellEditStartReasons.deleteKeyDown;
                            }

                            if (reason) {
                                const newParams = (0,
                                esm_extends /* default */.Z)({}, params, {
                                    reason,
                                });

                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.cellEditStart */.t
                                        .cellEditStart,
                                    newParams,
                                    event
                                );
                            }
                        }
                    },
                    [apiRef]
                );
                const handleCellEditStart = react.useCallback(
                    (params, event) => {
                        const { id, field, reason } = params;
                        apiRef.current.startCellEditMode(params);

                        if (
                            reason === GridCellEditStartReasons.deleteKeyDown ||
                            reason === GridCellEditStartReasons.printableKeyDown
                        ) {
                            apiRef.current.setEditCellValue(
                                {
                                    id,
                                    field,
                                    value: "",
                                },
                                event
                            );
                        }
                    },
                    [apiRef]
                );
                const handleCellEditStop = react.useCallback(
                    (params) => {
                        const { id, field, reason } = params;
                        let cellToFocusAfter;

                        if (reason === GridCellEditStopReasons.enterKeyDown) {
                            cellToFocusAfter = "below";
                        } else if (
                            reason === GridCellEditStopReasons.tabKeyDown
                        ) {
                            cellToFocusAfter = "right";
                        } else if (
                            reason === GridCellEditStopReasons.shiftTabKeyDown
                        ) {
                            cellToFocusAfter = "left";
                        }

                        let ignoreModifications = reason === "escapeKeyDown";
                        const editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );

                        if (editingState[id][field].isProcessingProps) {
                            // The user wants to stop editing the cell but we can't wait for the props to be processed.
                            // In this case, discard the modifications.
                            ignoreModifications = true;
                        }

                        apiRef.current.stopCellEditMode({
                            id,
                            field,
                            ignoreModifications,
                            cellToFocusAfter,
                        });
                    },
                    [apiRef]
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellDoubleClick */.t
                        .cellDoubleClick,
                    runIfEditModeIsCell(handleCellDoubleClick)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellFocusOut */.t.cellFocusOut,
                    runIfEditModeIsCell(handleCellFocusOut)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    runIfEditModeIsCell(handleCellKeyDown)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStart */.t.cellEditStart,
                    runIfEditModeIsCell(handleCellEditStart)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStop */.t.cellEditStop,
                    runIfEditModeIsCell(handleCellEditStop)
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStart */.t.cellEditStart,
                    props.onCellEditStart
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellEditStop */.t.cellEditStop,
                    props.onCellEditStop
                );
                const getCellMode = react.useCallback(
                    (id, field) => {
                        const editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        const isEditing =
                            editingState[id] && editingState[id][field];
                        return isEditing
                            ? GridCellModes.Edit
                            : GridCellModes.View;
                    },
                    [apiRef]
                );
                const updateOrDeleteFieldState = react.useCallback(
                    (id, field, newProps) => {
                        apiRef.current.setState((state) => {
                            const newEditingState = (0,
                            esm_extends /* default */.Z)({}, state.editRows);

                            if (newProps !== null) {
                                newEditingState[id] = (0,
                                esm_extends /* default */.Z)(
                                    {},
                                    newEditingState[id],
                                    {
                                        [field]: (0,
                                        esm_extends /* default */.Z)(
                                            {},
                                            newProps
                                        ),
                                    }
                                );
                            } else {
                                delete newEditingState[id][field];

                                if (
                                    Object.keys(newEditingState[id]).length ===
                                    0
                                ) {
                                    delete newEditingState[id];
                                }
                            }

                            return (0, esm_extends /* default */.Z)({}, state, {
                                editRows: newEditingState,
                            });
                        });
                        apiRef.current.forceUpdate();
                    },
                    [apiRef]
                );
                const startCellEditMode = react.useCallback(
                    (params) => {
                        const { id, field } = params;
                        throwIfNotEditable(id, field);
                        throwIfNotInMode(id, field, GridCellModes.View);
                        const newProps = {
                            value: apiRef.current.getCellValue(id, field),
                            error: false,
                            isProcessingProps: false,
                        };
                        updateOrDeleteFieldState(id, field, newProps);
                        apiRef.current.setCellFocus(id, field);
                    },
                    [
                        apiRef,
                        throwIfNotEditable,
                        throwIfNotInMode,
                        updateOrDeleteFieldState,
                    ]
                );
                const stopCellEditMode = react.useCallback(
                    (params) => {
                        const {
                            id,
                            field,
                            ignoreModifications,
                            cellToFocusAfter = "none",
                        } = params;
                        throwIfNotInMode(id, field, GridCellModes.Edit);
                        apiRef.current.unstable_runPendingEditCellValueMutation(
                            id,
                            field
                        );

                        const updateFocusedCellIfNeeded = () => {
                            if (cellToFocusAfter !== "none") {
                                apiRef.current.unstable_moveFocusToRelativeCell(
                                    id,
                                    field,
                                    cellToFocusAfter
                                );
                            }
                        };

                        if (ignoreModifications) {
                            updateFocusedCellIfNeeded();
                            updateOrDeleteFieldState(id, field, null);
                            return;
                        }

                        const editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        const { error, isProcessingProps } =
                            editingState[id][field];

                        if (error || isProcessingProps) {
                            return;
                        }

                        const rowUpdate =
                            apiRef.current.unstable_getRowWithUpdatedValuesFromCellEditing(
                                id,
                                field
                            );

                        if (processRowUpdate) {
                            const handleError = (errorThrown) => {
                                if (onProcessRowUpdateError) {
                                    onProcessRowUpdateError(errorThrown);
                                } else {
                                    missingOnProcessRowUpdateErrorWarning();
                                }
                            };

                            try {
                                const row = apiRef.current.getRow(id);
                                Promise.resolve(
                                    processRowUpdate(rowUpdate, row)
                                )
                                    .then((finalRowUpdate) => {
                                        apiRef.current.updateRows([
                                            finalRowUpdate,
                                        ]);
                                        updateFocusedCellIfNeeded();
                                        updateOrDeleteFieldState(
                                            id,
                                            field,
                                            null
                                        );
                                    })
                                    .catch(handleError);
                            } catch (errorThrown) {
                                handleError(errorThrown);
                            }
                        } else {
                            apiRef.current.updateRows([rowUpdate]);
                            updateFocusedCellIfNeeded();
                            updateOrDeleteFieldState(id, field, null);
                        }
                    },
                    [
                        apiRef,
                        onProcessRowUpdateError,
                        processRowUpdate,
                        throwIfNotInMode,
                        updateOrDeleteFieldState,
                    ]
                );
                const setCellEditingEditCellValue = react.useCallback(
                    async (params) => {
                        const { id, field, value } = params;
                        throwIfNotEditable(id, field);
                        throwIfNotInMode(id, field, GridCellModes.Edit);
                        const column = apiRef.current.getColumn(field);
                        const row = apiRef.current.getRow(id);
                        let parsedValue = value;

                        if (column.valueParser) {
                            parsedValue = column.valueParser(
                                value,
                                apiRef.current.getCellParams(id, field)
                            );
                        }

                        let editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );

                        let newProps = (0, esm_extends /* default */.Z)(
                            {},
                            editingState[id][field],
                            {
                                value: parsedValue,
                            }
                        );

                        if (column.preProcessEditCellProps) {
                            const hasChanged =
                                value !== editingState[id][field].value;
                            newProps = (0, esm_extends /* default */.Z)(
                                {},
                                newProps,
                                {
                                    isProcessingProps: true,
                                }
                            );
                            updateOrDeleteFieldState(id, field, newProps);
                            newProps = await Promise.resolve(
                                column.preProcessEditCellProps({
                                    id,
                                    row,
                                    props: newProps,
                                    hasChanged,
                                })
                            );
                        } // Check again if the cell is in edit mode because the user may have
                        // discarded the changes while the props were being processed.

                        if (
                            apiRef.current.getCellMode(id, field) ===
                            GridCellModes.View
                        ) {
                            return false;
                        }

                        editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        newProps = (0, esm_extends /* default */.Z)(
                            {},
                            newProps,
                            {
                                isProcessingProps: false,
                            }
                        ); // We don't update the value with the one coming from the props pre-processing
                        // because when the promise resolves it may be already outdated. The only
                        // exception to this rule is when there's no pre-processing.

                        newProps.value = column.preProcessEditCellProps
                            ? editingState[id][field].value
                            : parsedValue;
                        updateOrDeleteFieldState(id, field, newProps);
                        editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        return !editingState[id][field].error;
                    },
                    [
                        apiRef,
                        throwIfNotEditable,
                        throwIfNotInMode,
                        updateOrDeleteFieldState,
                    ]
                );
                const getRowWithUpdatedValuesFromCellEditing =
                    react.useCallback(
                        (id, field) => {
                            const column = apiRef.current.getColumn(field);
                            const editingState = gridEditRowsStateSelector(
                                apiRef.current.state
                            );
                            const { value } = editingState[id][field];
                            const row = apiRef.current.getRow(id);
                            return column.valueSetter
                                ? column.valueSetter({
                                      value,
                                      row,
                                  })
                                : (0, esm_extends /* default */.Z)({}, row, {
                                      [field]: value,
                                  });
                        },
                        [apiRef]
                    );
                const editingApi = {
                    getCellMode,
                    startCellEditMode,
                    stopCellEditMode,
                    unstable_setCellEditingEditCellValue:
                        setCellEditingEditCellValue,
                    unstable_getRowWithUpdatedValuesFromCellEditing:
                        getRowWithUpdatedValuesFromCellEditing,
                };
                useGridApiMethod(apiRef, editingApi, "EditingApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/models/params/gridRowParams.js
            /**
             * Object passed as parameter in the row callbacks.
             */

            /**
             * Object passed as parameter in the row `getRowClassName` callback prop.
             */

            /**
             * Object passed as parameter in the row `getRowHeight` callback prop.
             */

            /**
             * The getRowHeight return value.
             */
            var GridRowEditStartReasons;
            /**
             * Params passed to the `rowEditStart` event.
             */

            (function (GridRowEditStartReasons) {
                GridRowEditStartReasons["enterKeyDown"] = "enterKeyDown";
                GridRowEditStartReasons["cellDoubleClick"] = "cellDoubleClick";
                GridRowEditStartReasons["printableKeyDown"] =
                    "printableKeyDown";
                GridRowEditStartReasons["deleteKeyDown"] = "deleteKeyDown";
            })(GridRowEditStartReasons || (GridRowEditStartReasons = {}));

            var GridRowEditStopReasons;

            (function (GridRowEditStopReasons) {
                GridRowEditStopReasons["rowFocusOut"] = "rowFocusOut";
                GridRowEditStopReasons["escapeKeyDown"] = "escapeKeyDown";
                GridRowEditStopReasons["enterKeyDown"] = "enterKeyDown";
                GridRowEditStopReasons["tabKeyDown"] = "tabKeyDown";
                GridRowEditStopReasons["shiftTabKeyDown"] = "shiftTabKeyDown";
            })(GridRowEditStopReasons || (GridRowEditStopReasons = {})); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/editRows/useGridRowEditing.new.js

            // https://github.com/mui/mui-x/pull/3738#discussion_r798504277

            const useGridRowEditing_new_missingOnProcessRowUpdateErrorWarning =
                (0, warning /* buildWarning */.b)(
                    [
                        "MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.",
                        "To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.",
                        "For more detail, see http://mui.com/components/data-grid/editing/#persistence.",
                    ],
                    "error"
                );
            const useGridRowEditing_new_useGridRowEditing = (apiRef, props) => {
                const focusTimeout = react.useRef(null);
                const nextFocusedCell = react.useRef(null);
                const { processRowUpdate, onProcessRowUpdateError } = props;

                const runIfEditModeIsRow =
                    (callback) =>
                    (...args) => {
                        if (props.editMode === GridEditModes.Row) {
                            callback(...args);
                        }
                    };

                const throwIfNotEditable = react.useCallback(
                    (id, field) => {
                        const params = apiRef.current.getCellParams(id, field);

                        if (!apiRef.current.isCellEditable(params)) {
                            throw new Error(
                                `MUI: The cell with id=${id} and field=${field} is not editable.`
                            );
                        }
                    },
                    [apiRef]
                );
                const throwIfNotInMode = react.useCallback(
                    (id, mode) => {
                        if (apiRef.current.getRowMode(id) !== mode) {
                            throw new Error(
                                `MUI: The row with id=${id} is not in ${mode} mode.`
                            );
                        }
                    },
                    [apiRef]
                );
                const handleCellDoubleClick = react.useCallback(
                    (params, event) => {
                        if (!params.isEditable) {
                            return;
                        }

                        if (
                            apiRef.current.getRowMode(params.id) ===
                            GridRowModes.Edit
                        ) {
                            return;
                        }

                        const rowParams = apiRef.current.getRowParams(
                            params.id
                        );

                        const newParams = (0, esm_extends /* default */.Z)(
                            {},
                            rowParams,
                            {
                                field: params.field,
                                reason: GridRowEditStartReasons.cellDoubleClick,
                            }
                        );

                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.rowEditStart */.t
                                .rowEditStart,
                            newParams,
                            event
                        );
                    },
                    [apiRef]
                );
                const handleCellFocusIn = react.useCallback((params) => {
                    nextFocusedCell.current = params;
                }, []);
                const handleCellFocusOut = react.useCallback(
                    (params, event) => {
                        if (!params.isEditable) {
                            return;
                        }

                        if (
                            apiRef.current.getRowMode(params.id) ===
                            GridRowModes.View
                        ) {
                            return;
                        } // The mechanism to detect if we can stop editing a row is different from
                        // the cell editing. Instead of triggering it when clicking outside a cell,
                        // we must check if another cell in the same row was not clicked. To achieve
                        // that, first we keep track of all cells that gained focus. When a cell loses
                        // focus we check if the next cell that received focus is from a different row.

                        nextFocusedCell.current = null;
                        focusTimeout.current = setTimeout(() => {
                            var _nextFocusedCell$curr;

                            focusTimeout.current = null;

                            if (
                                ((_nextFocusedCell$curr =
                                    nextFocusedCell.current) == null
                                    ? void 0
                                    : _nextFocusedCell$curr.id) !== params.id
                            ) {
                                const rowParams = apiRef.current.getRowParams(
                                    params.id
                                );

                                const newParams = (0,
                                esm_extends /* default */.Z)({}, rowParams, {
                                    field: params.field,
                                    reason: GridRowEditStopReasons.rowFocusOut,
                                });

                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.rowEditStop */.t
                                        .rowEditStop,
                                    newParams,
                                    event
                                );
                            }
                        });
                    },
                    [apiRef]
                );
                react.useEffect(() => {
                    return () => {
                        clearTimeout(focusTimeout.current);
                    };
                }, []);
                const handleCellKeyDown = react.useCallback(
                    (params, event) => {
                        if (params.cellMode === GridRowModes.Edit) {
                            let reason;

                            if (event.key === "Escape") {
                                reason = GridRowEditStopReasons.escapeKeyDown;
                            } else if (event.key === "Enter") {
                                reason = GridRowEditStopReasons.enterKeyDown;
                            } else if (event.key === "Tab") {
                                const columnFields = gridColumnFieldsSelector(
                                    apiRef
                                ).filter((field) =>
                                    apiRef.current.isCellEditable(
                                        apiRef.current.getCellParams(
                                            params.id,
                                            field
                                        )
                                    )
                                );

                                if (event.shiftKey) {
                                    if (params.field === columnFields[0]) {
                                        // Exit if user pressed Shift+Tab on the first field
                                        reason =
                                            GridRowEditStopReasons.shiftTabKeyDown;
                                    }
                                } else if (
                                    params.field ===
                                    columnFields[columnFields.length - 1]
                                ) {
                                    // Exit if user pressed Tab on the last field
                                    reason = GridRowEditStopReasons.tabKeyDown;
                                }

                                if (reason) {
                                    event.preventDefault(); // Prevent going to the next element in the tab sequence
                                }
                            }

                            if (reason) {
                                const rowParams = apiRef.current.getRowParams(
                                    params.id
                                );

                                const newParams = (0,
                                esm_extends /* default */.Z)({}, rowParams, {
                                    reason,
                                    field: params.field,
                                });

                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.rowEditStop */.t
                                        .rowEditStop,
                                    newParams,
                                    event
                                );
                            }
                        } else if (params.isEditable) {
                            let reason;

                            if (isPrintableKey(event.key)) {
                                if (
                                    event.shiftKey ||
                                    event.ctrlKey ||
                                    event.metaKey ||
                                    event.altKey
                                ) {
                                    return;
                                }

                                reason =
                                    GridRowEditStartReasons.printableKeyDown;
                            } else if (event.key === "Enter") {
                                reason = GridRowEditStartReasons.enterKeyDown;
                            } else if (event.key === "Delete") {
                                reason = GridRowEditStartReasons.deleteKeyDown;
                            }

                            if (reason) {
                                const rowParams = apiRef.current.getRowParams(
                                    params.id
                                );

                                const newParams = (0,
                                esm_extends /* default */.Z)({}, rowParams, {
                                    field: params.field,
                                    reason,
                                });

                                apiRef.current.publishEvent(
                                    gridEvents /* GridEvents.rowEditStart */.t
                                        .rowEditStart,
                                    newParams,
                                    event
                                );
                            }
                        }
                    },
                    [apiRef]
                );
                const handleRowEditStart = react.useCallback(
                    (params, event) => {
                        const { id, field, reason } = params;
                        apiRef.current.startRowEditMode({
                            id,
                            fieldToFocus: field,
                        });

                        if (
                            reason === GridRowEditStartReasons.deleteKeyDown ||
                            reason === GridRowEditStartReasons.printableKeyDown
                        ) {
                            apiRef.current.setEditCellValue(
                                {
                                    id,
                                    field: field,
                                    value: "",
                                },
                                event
                            );
                        }
                    },
                    [apiRef]
                );
                const handleRowEditStop = react.useCallback(
                    (params) => {
                        const { id, reason, field } = params;
                        apiRef.current.unstable_runPendingEditCellValueMutation(
                            id
                        );
                        let cellToFocusAfter;

                        if (reason === GridRowEditStopReasons.enterKeyDown) {
                            cellToFocusAfter = "below";
                        } else if (
                            reason === GridRowEditStopReasons.tabKeyDown
                        ) {
                            cellToFocusAfter = "right";
                        } else if (
                            reason === GridRowEditStopReasons.shiftTabKeyDown
                        ) {
                            cellToFocusAfter = "left";
                        }

                        let ignoreModifications = reason === "escapeKeyDown";
                        const editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );

                        if (!ignoreModifications) {
                            // The user wants to stop editing the cell but we can't wait for the props to be processed.
                            // In this case, discard the modifications if any field is processing its props.
                            ignoreModifications = Object.values(
                                editingState[id]
                            ).some((fieldProps) => {
                                return fieldProps.isProcessingProps;
                            });
                        }

                        apiRef.current.stopRowEditMode({
                            id,
                            ignoreModifications,
                            field,
                            cellToFocusAfter,
                        });
                    },
                    [apiRef]
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellDoubleClick */.t
                        .cellDoubleClick,
                    runIfEditModeIsRow(handleCellDoubleClick)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellFocusIn */.t.cellFocusIn,
                    runIfEditModeIsRow(handleCellFocusIn)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellFocusOut */.t.cellFocusOut,
                    runIfEditModeIsRow(handleCellFocusOut)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    runIfEditModeIsRow(handleCellKeyDown)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStart */.t.rowEditStart,
                    runIfEditModeIsRow(handleRowEditStart)
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStop */.t.rowEditStop,
                    runIfEditModeIsRow(handleRowEditStop)
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStart */.t.rowEditStart,
                    props.onRowEditStart
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowEditStop */.t.rowEditStop,
                    props.onRowEditStop
                );
                const getRowMode = react.useCallback(
                    (id) => {
                        if (props.editMode === GridEditModes.Cell) {
                            return GridRowModes.View;
                        }

                        const editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        const isEditing =
                            editingState[id] &&
                            Object.keys(editingState[id]).length > 0;
                        return isEditing
                            ? GridRowModes.Edit
                            : GridRowModes.View;
                    },
                    [apiRef, props.editMode]
                );
                const updateOrDeleteRowState = react.useCallback(
                    (id, newProps) => {
                        apiRef.current.setState((state) => {
                            const newEditingState = (0,
                            esm_extends /* default */.Z)({}, state.editRows);

                            if (newProps !== null) {
                                newEditingState[id] = newProps;
                            } else {
                                delete newEditingState[id];
                            }

                            return (0, esm_extends /* default */.Z)({}, state, {
                                editRows: newEditingState,
                            });
                        });
                        apiRef.current.forceUpdate();
                    },
                    [apiRef]
                );
                const updateOrDeleteFieldState = react.useCallback(
                    (id, field, newProps) => {
                        apiRef.current.setState((state) => {
                            const newEditingState = (0,
                            esm_extends /* default */.Z)({}, state.editRows);

                            if (newProps !== null) {
                                newEditingState[id] = (0,
                                esm_extends /* default */.Z)(
                                    {},
                                    newEditingState[id],
                                    {
                                        [field]: (0,
                                        esm_extends /* default */.Z)(
                                            {},
                                            newProps
                                        ),
                                    }
                                );
                            } else {
                                delete newEditingState[id][field];

                                if (
                                    Object.keys(newEditingState[id]).length ===
                                    0
                                ) {
                                    delete newEditingState[id];
                                }
                            }

                            return (0, esm_extends /* default */.Z)({}, state, {
                                editRows: newEditingState,
                            });
                        });
                        apiRef.current.forceUpdate();
                    },
                    [apiRef]
                );
                const startRowEditMode = react.useCallback(
                    (params) => {
                        const { id, fieldToFocus } = params;
                        throwIfNotInMode(id, GridRowModes.View);

                        if (
                            apiRef.current.getRowMode(id) === GridRowModes.Edit
                        ) {
                            throw new Error(
                                `MUI: The cell with id=${id} is already in edit mode.`
                            );
                        }

                        const columnFields = gridColumnFieldsSelector(apiRef);
                        const newProps = columnFields.reduce((acc, field) => {
                            const cellParams = apiRef.current.getCellParams(
                                id,
                                field
                            );

                            if (!cellParams.isEditable) {
                                return acc;
                            }

                            acc[field] = {
                                value: apiRef.current.getCellValue(id, field),
                                error: false,
                                isProcessingProps: false,
                            };
                            return acc;
                        }, {});
                        updateOrDeleteRowState(id, newProps);

                        if (fieldToFocus) {
                            apiRef.current.setCellFocus(id, fieldToFocus);
                        }
                    },
                    [apiRef, throwIfNotInMode, updateOrDeleteRowState]
                );
                const stopRowEditMode = react.useCallback(
                    (params) => {
                        const {
                            id,
                            ignoreModifications,
                            field: focusedField,
                            cellToFocusAfter = "none",
                        } = params;
                        throwIfNotInMode(id, GridRowModes.Edit);
                        apiRef.current.unstable_runPendingEditCellValueMutation(
                            id
                        );

                        const updateFocusedCellIfNeeded = () => {
                            if (cellToFocusAfter !== "none" && focusedField) {
                                apiRef.current.unstable_moveFocusToRelativeCell(
                                    id,
                                    focusedField,
                                    cellToFocusAfter
                                );
                            }
                        };

                        if (ignoreModifications) {
                            updateFocusedCellIfNeeded();
                            updateOrDeleteRowState(id, null);
                            return;
                        }

                        const editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        const row = apiRef.current.getRow(id);
                        const isSomeFieldProcessingProps = Object.values(
                            editingState[id]
                        ).some((fieldProps) => fieldProps.isProcessingProps);

                        if (isSomeFieldProcessingProps) {
                            return;
                        }

                        const hasSomeFieldWithError = Object.values(
                            editingState[id]
                        ).some((fieldProps) => fieldProps.error);

                        if (hasSomeFieldWithError) {
                            return;
                        }

                        const rowUpdate =
                            apiRef.current.unstable_getRowWithUpdatedValuesFromRowEditing(
                                id
                            );

                        if (processRowUpdate) {
                            const handleError = (errorThrown) => {
                                if (onProcessRowUpdateError) {
                                    onProcessRowUpdateError(errorThrown);
                                } else {
                                    useGridRowEditing_new_missingOnProcessRowUpdateErrorWarning();
                                }
                            };

                            try {
                                Promise.resolve(
                                    processRowUpdate(rowUpdate, row)
                                )
                                    .then((finalRowUpdate) => {
                                        apiRef.current.updateRows([
                                            finalRowUpdate,
                                        ]);
                                        updateFocusedCellIfNeeded();
                                        updateOrDeleteRowState(id, null);
                                    })
                                    .catch(handleError);
                            } catch (errorThrown) {
                                handleError(errorThrown);
                            }
                        } else {
                            apiRef.current.updateRows([rowUpdate]);
                            updateFocusedCellIfNeeded();
                            updateOrDeleteRowState(id, null);
                        }
                    },
                    [
                        apiRef,
                        onProcessRowUpdateError,
                        processRowUpdate,
                        throwIfNotInMode,
                        updateOrDeleteRowState,
                    ]
                );
                const setRowEditingEditCellValue = react.useCallback(
                    (params) => {
                        const { id, field, value } = params;
                        throwIfNotEditable(id, field);
                        const column = apiRef.current.getColumn(field);
                        const row = apiRef.current.getRow(id);
                        let parsedValue = value;

                        if (column.valueParser) {
                            parsedValue = column.valueParser(
                                value,
                                apiRef.current.getCellParams(id, field)
                            );
                        }

                        let editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );

                        let newProps = (0, esm_extends /* default */.Z)(
                            {},
                            editingState[id][field],
                            {
                                value: parsedValue,
                            }
                        );

                        if (!column.preProcessEditCellProps) {
                            updateOrDeleteFieldState(id, field, newProps);
                        }

                        return new Promise((resolve) => {
                            const promises = [];

                            if (column.preProcessEditCellProps) {
                                const hasChanged =
                                    newProps.value !==
                                    editingState[id][field].value;
                                newProps = (0, esm_extends /* default */.Z)(
                                    {},
                                    newProps,
                                    {
                                        isProcessingProps: true,
                                    }
                                );
                                updateOrDeleteFieldState(id, field, newProps);

                                const _editingState$id = editingState[id],
                                    otherFieldsProps = (0,
                                    objectWithoutPropertiesLoose /* default */.Z)(
                                        _editingState$id,
                                        [field].map(_toPropertyKey)
                                    );

                                const promise = Promise.resolve(
                                    column.preProcessEditCellProps({
                                        id,
                                        row,
                                        props: newProps,
                                        hasChanged,
                                        otherFieldsProps,
                                    })
                                ).then((processedProps) => {
                                    // Check again if the row is in edit mode because the user may have
                                    // discarded the changes while the props were being processed.
                                    if (
                                        apiRef.current.getRowMode(id) ===
                                        GridRowModes.View
                                    ) {
                                        resolve(false);
                                        return;
                                    }

                                    editingState = gridEditRowsStateSelector(
                                        apiRef.current.state
                                    );
                                    processedProps = (0,
                                    esm_extends /* default */.Z)(
                                        {},
                                        processedProps,
                                        {
                                            isProcessingProps: false,
                                        }
                                    ); // We don't reuse the value from the props pre-processing because when the
                                    // promise resolves it may be already outdated. The only exception to this rule
                                    // is when there's no pre-processing.

                                    processedProps.value =
                                        column.preProcessEditCellProps
                                            ? editingState[id][field].value
                                            : parsedValue;
                                    updateOrDeleteFieldState(
                                        id,
                                        field,
                                        processedProps
                                    );
                                });
                                promises.push(promise);
                            }

                            Object.entries(editingState[id]).forEach(
                                ([thisField, fieldProps]) => {
                                    if (thisField === field) {
                                        return;
                                    }

                                    const fieldColumn =
                                        apiRef.current.getColumn(thisField);

                                    if (!fieldColumn.preProcessEditCellProps) {
                                        return;
                                    }

                                    fieldProps = (0,
                                    esm_extends /* default */.Z)(
                                        {},
                                        fieldProps,
                                        {
                                            isProcessingProps: true,
                                        }
                                    );
                                    updateOrDeleteFieldState(
                                        id,
                                        thisField,
                                        fieldProps
                                    );
                                    editingState = gridEditRowsStateSelector(
                                        apiRef.current.state
                                    );

                                    const _editingState$id2 = editingState[id],
                                        otherFieldsProps = (0,
                                        objectWithoutPropertiesLoose /* default */.Z)(
                                            _editingState$id2,
                                            [thisField].map(_toPropertyKey)
                                        );

                                    const promise = Promise.resolve(
                                        fieldColumn.preProcessEditCellProps({
                                            id,
                                            row,
                                            props: fieldProps,
                                            hasChanged: false,
                                            otherFieldsProps,
                                        })
                                    ).then((processedProps) => {
                                        // Check again if the row is in edit mode because the user may have
                                        // discarded the changes while the props were being processed.
                                        if (
                                            apiRef.current.getRowMode(id) ===
                                            GridRowModes.View
                                        ) {
                                            resolve(false);
                                            return;
                                        }

                                        processedProps = (0,
                                        esm_extends /* default */.Z)(
                                            {},
                                            processedProps,
                                            {
                                                isProcessingProps: false,
                                            }
                                        );
                                        updateOrDeleteFieldState(
                                            id,
                                            thisField,
                                            processedProps
                                        );
                                    });
                                    promises.push(promise);
                                }
                            );
                            Promise.all(promises).then(() => {
                                if (
                                    apiRef.current.getRowMode(id) ===
                                    GridRowModes.Edit
                                ) {
                                    editingState = gridEditRowsStateSelector(
                                        apiRef.current.state
                                    );
                                    resolve(!editingState[id][field].error);
                                } else {
                                    resolve(false);
                                }
                            });
                        });
                    },
                    [apiRef, throwIfNotEditable, updateOrDeleteFieldState]
                );
                const getRowWithUpdatedValuesFromRowEditing = react.useCallback(
                    (id) => {
                        const editingState = gridEditRowsStateSelector(
                            apiRef.current.state
                        );
                        const row = apiRef.current.getRow(id);

                        let rowUpdate = (0, esm_extends /* default */.Z)(
                            {},
                            row
                        );

                        Object.entries(editingState[id]).forEach(
                            ([field, fieldProps]) => {
                                const column = apiRef.current.getColumn(field);

                                if (column.valueSetter) {
                                    rowUpdate = column.valueSetter({
                                        value: fieldProps.value,
                                        row: rowUpdate,
                                    });
                                } else {
                                    rowUpdate[field] = fieldProps.value;
                                }
                            }
                        );
                        return rowUpdate;
                    },
                    [apiRef]
                );
                const editingApi = {
                    getRowMode,
                    startRowEditMode,
                    stopRowEditMode,
                    unstable_setRowEditingEditCellValue:
                        setRowEditingEditCellValue,
                    unstable_getRowWithUpdatedValuesFromRowEditing:
                        getRowWithUpdatedValuesFromRowEditing,
                };
                useGridApiMethod(apiRef, editingApi, "EditingApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/editRows/useGridEditing.new.js
            const useGridEditing_new_editingStateInitializer = (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    editRows: {},
                });
            const useGridEditing_new_useGridEditing = (apiRef, props) => {
                useGridCellEditing(apiRef, props);
                useGridRowEditing_new_useGridRowEditing(apiRef, props);
                const debounceMap = react.useRef({});
                const { isCellEditable: isCellEditableProp } = props;
                const isCellEditable = react.useCallback(
                    (params) => {
                        if (params.rowNode.isAutoGenerated) {
                            return false;
                        }

                        if (!params.colDef.editable) {
                            return false;
                        }

                        if (!params.colDef.renderEditCell) {
                            return false;
                        }

                        if (isCellEditableProp) {
                            return isCellEditableProp(params);
                        }

                        return true;
                    },
                    [isCellEditableProp]
                );

                const maybeDebounce = (id, field, debounceMs, callback) => {
                    if (!debounceMs) {
                        callback();
                        return;
                    }

                    if (!debounceMap.current[id]) {
                        debounceMap.current[id] = {};
                    }

                    if (debounceMap.current[id][field]) {
                        const [timeout] = debounceMap.current[id][field];
                        clearTimeout(timeout);
                    } // To run the callback immediatelly without waiting the timeout

                    const runImmediately = () => {
                        const [timeout] = debounceMap.current[id][field];
                        clearTimeout(timeout);
                        callback();
                        delete debounceMap.current[id][field];
                    };

                    const timeout = setTimeout(() => {
                        callback();
                        delete debounceMap.current[id][field];
                    }, debounceMs);
                    debounceMap.current[id][field] = [timeout, runImmediately];
                };

                react.useEffect(() => {
                    const debounces = debounceMap.current;
                    return () => {
                        Object.entries(debounces).forEach(([id, fields]) => {
                            Object.keys(fields).forEach((field) => {
                                const [timeout] = debounces[id][field];
                                clearTimeout(timeout);
                                delete debounces[id][field];
                            });
                        });
                    };
                }, []);
                const runPendingEditCellValueMutation = react.useCallback(
                    (id, field) => {
                        if (!debounceMap.current[id]) {
                            return;
                        }

                        if (!field) {
                            Object.keys(debounceMap.current[id]).forEach(
                                (debouncedField) => {
                                    const [, runCallback] =
                                        debounceMap.current[id][debouncedField];
                                    runCallback();
                                }
                            );
                        } else if (debounceMap.current[id][field]) {
                            const [, runCallback] =
                                debounceMap.current[id][field];
                            runCallback();
                        }
                    },
                    []
                );
                const setEditCellValue = react.useCallback(
                    (params) => {
                        const { id, field, debounceMs } = params;
                        return new Promise((resolve) => {
                            maybeDebounce(id, field, debounceMs, async () => {
                                const setEditCellValueToCall =
                                    props.editMode === GridEditModes.Row
                                        ? apiRef.current
                                              .unstable_setRowEditingEditCellValue
                                        : apiRef.current
                                              .unstable_setCellEditingEditCellValue; // Check if the cell is in edit mode
                                // By the time this callback runs the user may have cancelled the editing

                                if (
                                    apiRef.current.getCellMode(id, field) ===
                                    GridCellModes.Edit
                                ) {
                                    const result = await setEditCellValueToCall(
                                        params
                                    );
                                    resolve(result);
                                }
                            });
                        });
                    },
                    [apiRef, props.editMode]
                );
                const getRowWithUpdatedValues = react.useCallback(
                    (id, field) => {
                        return props.editMode === GridEditModes.Cell
                            ? apiRef.current.unstable_getRowWithUpdatedValuesFromCellEditing(
                                  id,
                                  field
                              )
                            : apiRef.current.unstable_getRowWithUpdatedValuesFromRowEditing(
                                  id
                              );
                    },
                    [apiRef, props.editMode]
                );
                const editingSharedApi = {
                    isCellEditable,
                    setEditCellValue,
                    unstable_runPendingEditCellValueMutation:
                        runPendingEditCellValueMutation,
                    unstable_getRowWithUpdatedValues: getRowWithUpdatedValues,
                };
                useGridApiMethod(apiRef, editingSharedApi, "EditingApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/rows/gridRowsUtils.js
            /**
             * A helper function to check if the id provided is valid.
             * @param {GridRowId} id Id as [[GridRowId]].
             * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].
             * @param {string} detailErrorMessage A custom error message to display for invalid IDs
             */
            function checkGridRowIdIsValid(
                id,
                row,
                detailErrorMessage = "A row was provided without id in the rows prop:"
            ) {
                if (id == null) {
                    throw new Error(
                        [
                            "MUI: The data grid component requires all rows to have a unique `id` property.",
                            "Alternatively, you can use the `getRowId` prop to specify a custom id for each row.",
                            detailErrorMessage,
                            JSON.stringify(row),
                        ].join("\n")
                    );
                }
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js
            function getGridRowId(rowModel, getRowId, detailErrorMessage) {
                const id = getRowId ? getRowId(rowModel) : rowModel.id;
                checkGridRowIdIsValid(id, rowModel, detailErrorMessage);
                return id;
            }

            const convertGridRowsPropToState = ({
                prevState,
                rows,
                getRowId,
            }) => {
                let value;

                if (rows) {
                    value = {
                        idRowsLookup: {},
                        ids: [],
                    };

                    for (let i = 0; i < rows.length; i += 1) {
                        const row = rows[i];
                        const id = getGridRowId(row, getRowId);
                        value.idRowsLookup[id] = row;
                        value.ids.push(id);
                    }
                } else {
                    value = prevState.value;
                }

                return {
                    value,
                    rowsBeforePartialUpdates:
                        rows != null
                            ? rows
                            : prevState.rowsBeforePartialUpdates,
                };
            };

            const getRowsStateFromCache = (
                rowsCache,
                previousTree,
                apiRef,
                rowCountProp,
                loadingProp
            ) => {
                const { value } = rowsCache.state;
                const rowCount = rowCountProp != null ? rowCountProp : 0;
                const groupingResponse =
                    apiRef.current.unstable_applyStrategyProcessor(
                        "rowTreeCreation",
                        (0, esm_extends /* default */.Z)({}, value, {
                            previousTree,
                        })
                    );
                const dataTopLevelRowCount =
                    groupingResponse.treeDepth === 1
                        ? groupingResponse.ids.length
                        : Object.values(groupingResponse.tree).filter(
                              (node) => node.parent == null
                          ).length;
                return (0, esm_extends /* default */.Z)({}, groupingResponse, {
                    loading: loadingProp,
                    totalRowCount: Math.max(
                        rowCount,
                        groupingResponse.ids.length
                    ),
                    totalTopLevelRowCount: Math.max(
                        rowCount,
                        dataTopLevelRowCount
                    ),
                });
            };

            const rowsStateInitializer = (state, props, apiRef) => {
                const rowsCache = {
                    state: convertGridRowsPropToState({
                        rows: props.rows,
                        getRowId: props.getRowId,
                        prevState: {
                            value: {
                                idRowsLookup: {},
                                ids: [],
                            },
                            rowsBeforePartialUpdates: [],
                        },
                    }),
                    timeout: null,
                    lastUpdateMs: Date.now(),
                };
                return (0, esm_extends /* default */.Z)({}, state, {
                    rows: getRowsStateFromCache(
                        rowsCache,
                        null,
                        apiRef,
                        props.rowCount,
                        props.loading
                    ),
                    rowsCache, // TODO remove from state
                });
            };
            const useGridRows = (apiRef, props) => {
                if (false) {
                }

                const logger = useGridLogger(apiRef, "useGridRows");
                const rowsCache = react.useRef(apiRef.current.state.rowsCache); // To avoid listing rowsCache as useEffect dep

                const currentPage = useGridVisibleRows(apiRef, props);
                const getRow = react.useCallback(
                    (id) => {
                        var _ref;

                        return (_ref = gridRowsLookupSelector(apiRef)[id]) !=
                            null
                            ? _ref
                            : null;
                    },
                    [apiRef]
                );
                const lookup = react.useMemo(
                    () =>
                        currentPage.rows.reduce((acc, { id }, index) => {
                            acc[id] = index;
                            return acc;
                        }, {}),
                    [currentPage.rows]
                );
                const throttledRowsChange = react.useCallback(
                    (newState, throttle) => {
                        const run = () => {
                            rowsCache.current.timeout = null;
                            rowsCache.current.lastUpdateMs = Date.now();
                            apiRef.current.setState((state) =>
                                (0, esm_extends /* default */.Z)({}, state, {
                                    rows: getRowsStateFromCache(
                                        rowsCache.current,
                                        gridRowTreeSelector(apiRef),
                                        apiRef,
                                        props.rowCount,
                                        props.loading
                                    ),
                                })
                            );
                            apiRef.current.publishEvent(
                                gridEvents /* GridEvents.rowsSet */.t.rowsSet
                            );
                            apiRef.current.forceUpdate();
                        };

                        if (rowsCache.current.timeout) {
                            clearTimeout(rowsCache.current.timeout);
                        }

                        rowsCache.current.state = newState;
                        rowsCache.current.timeout = null;

                        if (!throttle) {
                            run();
                            return;
                        }

                        const throttleRemainingTimeMs =
                            props.throttleRowsMs -
                            (Date.now() - rowsCache.current.lastUpdateMs);

                        if (throttleRemainingTimeMs > 0) {
                            rowsCache.current.timeout = setTimeout(
                                run,
                                throttleRemainingTimeMs
                            );
                            return;
                        }

                        run();
                    },
                    [
                        props.throttleRowsMs,
                        props.rowCount,
                        props.loading,
                        apiRef,
                    ]
                );
                /**
                 * API METHODS
                 */

                const setRows = react.useCallback(
                    (rows) => {
                        logger.debug(
                            `Updating all rows, new length ${rows.length}`
                        );
                        throttledRowsChange(
                            convertGridRowsPropToState({
                                rows,
                                prevState: rowsCache.current.state,
                                getRowId: props.getRowId,
                            }),
                            true
                        );
                    },
                    [logger, props.getRowId, throttledRowsChange]
                );
                const updateRows = react.useCallback(
                    (updates) => {
                        if (
                            props.signature === GridSignature.DataGrid &&
                            updates.length > 1
                        ) {
                            // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.
                            throw new Error(
                                [
                                    "MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.",
                                    "You need to upgrade to the DataGridPro component to unlock this feature.",
                                ].join("\n")
                            );
                        } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.

                        const uniqUpdates = new Map();
                        updates.forEach((update) => {
                            const id = getGridRowId(
                                update,
                                props.getRowId,
                                "A row was provided without id when calling updateRows():"
                            );

                            if (uniqUpdates.has(id)) {
                                uniqUpdates.set(
                                    id,
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        uniqUpdates.get(id),
                                        update
                                    )
                                );
                            } else {
                                uniqUpdates.set(id, update);
                            }
                        });
                        const deletedRowIds = [];
                        const newStateValue = {
                            idRowsLookup: (0, esm_extends /* default */.Z)(
                                {},
                                rowsCache.current.state.value.idRowsLookup
                            ),
                            ids: [...rowsCache.current.state.value.ids],
                        };
                        uniqUpdates.forEach((partialRow, id) => {
                            // eslint-disable-next-line no-underscore-dangle
                            if (partialRow._action === "delete") {
                                delete newStateValue.idRowsLookup[id];
                                deletedRowIds.push(id);
                                return;
                            }

                            const oldRow = apiRef.current.getRow(id);

                            if (!oldRow) {
                                newStateValue.idRowsLookup[id] = partialRow;
                                newStateValue.ids.push(id);
                                return;
                            }

                            newStateValue.idRowsLookup[id] = (0,
                            esm_extends /* default */.Z)(
                                {},
                                apiRef.current.getRow(id),
                                partialRow
                            );
                        });

                        if (deletedRowIds.length > 0) {
                            newStateValue.ids = newStateValue.ids.filter(
                                (id) => !deletedRowIds.includes(id)
                            );
                        }

                        const state = (0, esm_extends /* default */.Z)(
                            {},
                            rowsCache.current.state,
                            {
                                value: newStateValue,
                            }
                        );

                        throttledRowsChange(state, true);
                    },
                    [
                        apiRef,
                        props.getRowId,
                        throttledRowsChange,
                        props.signature,
                    ]
                );
                const getRowModels = react.useCallback(() => {
                    const allRows = gridRowIdsSelector(apiRef);
                    const idRowsLookup = gridRowsLookupSelector(apiRef);
                    return new Map(allRows.map((id) => [id, idRowsLookup[id]]));
                }, [apiRef]);
                const getRowsCount = react.useCallback(
                    () => gridRowCountSelector(apiRef),
                    [apiRef]
                );
                const getAllRowIds = react.useCallback(
                    () => gridRowIdsSelector(apiRef),
                    [apiRef]
                );
                const getRowIndexRelativeToVisibleRows = react.useCallback(
                    (id) => lookup[id],
                    [lookup]
                );
                const setRowChildrenExpansion = react.useCallback(
                    (id, isExpanded) => {
                        const currentNode = apiRef.current.getRowNode(id);

                        if (!currentNode) {
                            throw new Error(`MUI: No row with id #${id} found`);
                        }

                        const newNode = (0, esm_extends /* default */.Z)(
                            {},
                            currentNode,
                            {
                                childrenExpanded: isExpanded,
                            }
                        );

                        apiRef.current.setState((state) => {
                            return (0, esm_extends /* default */.Z)({}, state, {
                                rows: (0, esm_extends /* default */.Z)(
                                    {},
                                    state.rows,
                                    {
                                        tree: (0, esm_extends /* default */.Z)(
                                            {},
                                            state.rows.tree,
                                            {
                                                [id]: newNode,
                                            }
                                        ),
                                    }
                                ),
                            });
                        });
                        apiRef.current.forceUpdate();
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.rowExpansionChange */.t
                                .rowExpansionChange,
                            newNode
                        );
                    },
                    [apiRef]
                );
                const getRowNode = react.useCallback(
                    (id) => {
                        var _gridRowTreeSelector$;

                        return (_gridRowTreeSelector$ =
                            gridRowTreeSelector(apiRef)[id]) != null
                            ? _gridRowTreeSelector$
                            : null;
                    },
                    [apiRef]
                );
                const setRowIndex = react.useCallback(
                    (rowId, targetIndex) => {
                        const allRows = gridRowIdsSelector(apiRef);
                        const oldIndex = allRows.findIndex(
                            (row) => row === rowId
                        );

                        if (oldIndex === targetIndex) {
                            return;
                        }

                        logger.debug(
                            `Moving row ${rowId} to index ${targetIndex}`
                        );
                        const updatedRows = [...allRows];
                        updatedRows.splice(
                            targetIndex,
                            0,
                            updatedRows.splice(oldIndex, 1)[0]
                        );
                        apiRef.current.setState((state) =>
                            (0, esm_extends /* default */.Z)({}, state, {
                                rows: (0, esm_extends /* default */.Z)(
                                    {},
                                    state.rows,
                                    {
                                        ids: updatedRows,
                                    }
                                ),
                            })
                        );
                        apiRef.current.applySorting();
                    },
                    [apiRef, logger]
                );
                const rowApi = {
                    getRow,
                    getRowModels,
                    getRowsCount,
                    getAllRowIds,
                    setRows,
                    setRowIndex,
                    updateRows,
                    setRowChildrenExpansion,
                    getRowNode,
                    getRowIndexRelativeToVisibleRows,
                };
                /**
                 * EVENTS
                 */

                const groupRows = react.useCallback(() => {
                    logger.info(
                        `Row grouping pre-processing have changed, regenerating the row tree`
                    );
                    let rows;

                    if (
                        rowsCache.current.state.rowsBeforePartialUpdates ===
                        props.rows
                    ) {
                        // The `props.rows` has not changed since the last row grouping
                        // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping
                        rows = undefined;
                    } else {
                        // The `props.rows` has changed since the last row grouping
                        // We must use the new `props.rows` on the new grouping
                        // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render
                        rows = props.rows;
                    }

                    throttledRowsChange(
                        convertGridRowsPropToState({
                            rows,
                            getRowId: props.getRowId,
                            prevState: rowsCache.current.state,
                        }),
                        false
                    );
                }, [logger, throttledRowsChange, props.getRowId, props.rows]);
                const handleStrategyProcessorChange = react.useCallback(
                    (methodName) => {
                        if (methodName === "rowTreeCreation") {
                            groupRows();
                        }
                    },
                    [groupRows]
                );
                const handleStrategyActivityChange = react.useCallback(() => {
                    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.
                    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.
                    if (
                        apiRef.current.unstable_getActiveStrategy("rowTree") !==
                        gridRowGroupingNameSelector(apiRef)
                    ) {
                        groupRows();
                    }
                }, [apiRef, groupRows]);
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.activeStrategyProcessorChange */.t
                        .activeStrategyProcessorChange,
                    handleStrategyProcessorChange
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.strategyAvailabilityChange */.t
                        .strategyAvailabilityChange,
                    handleStrategyActivityChange
                );
                useGridApiMethod(apiRef, rowApi, "GridRowApi");
                /**
                 * EFFECTS
                 */

                react.useEffect(() => {
                    return () => {
                        if (rowsCache.current.timeout !== null) {
                            // eslint-disable-next-line react-hooks/exhaustive-deps
                            clearTimeout(rowsCache.current.timeout);
                        }
                    };
                }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`
                // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one

                const isFirstRender = react.useRef(true);
                react.useEffect(() => {
                    if (isFirstRender.current) {
                        isFirstRender.current = false;
                        return;
                    } // The new rows have already been applied (most likely in the `GridEvents.rowGroupsPreProcessingChange` listener)

                    if (
                        rowsCache.current.state.rowsBeforePartialUpdates ===
                        props.rows
                    ) {
                        return;
                    }

                    logger.debug(
                        `Updating all rows, new length ${props.rows.length}`
                    );
                    throttledRowsChange(
                        convertGridRowsPropToState({
                            rows: props.rows,
                            getRowId: props.getRowId,
                            prevState: rowsCache.current.state,
                        }),
                        false
                    );
                }, [
                    props.rows,
                    props.rowCount,
                    props.getRowId,
                    logger,
                    throttledRowsChange,
                ]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowsPreProcessors.js
            const flatRowTreeCreationMethod = ({
                ids,
                idRowsLookup,
                previousTree,
            }) => {
                const tree = {};

                for (let i = 0; i < ids.length; i += 1) {
                    const rowId = ids[i];

                    if (previousTree && previousTree[rowId]) {
                        tree[rowId] = previousTree[rowId];
                    } else {
                        tree[rowId] = {
                            id: rowId,
                            depth: 0,
                            parent: null,
                            groupingKey: "",
                            groupingField: null,
                        };
                    }
                }

                return {
                    groupingName: GRID_DEFAULT_STRATEGY,
                    tree,
                    treeDepth: 1,
                    idRowsLookup,
                    ids,
                };
            };

            const useGridRowsPreProcessors = (apiRef) => {
                useGridRegisterStrategyProcessor(
                    apiRef,
                    GRID_DEFAULT_STRATEGY,
                    "rowTreeCreation",
                    flatRowTreeCreationMethod
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/utils/domUtils.js
            function isOverflown(element) {
                return (
                    element.scrollHeight > element.clientHeight ||
                    element.scrollWidth > element.clientWidth
                );
            }
            function findParentElementFromClassName(elem, className) {
                return elem.closest(`.${className}`);
            }
            function getRowEl(cell) {
                if (!cell) {
                    return null;
                }

                return findParentElementFromClassName(cell, gridClasses.row);
            } // TODO remove

            function isGridCellRoot(elem) {
                return (
                    elem != null && elem.classList.contains(gridClasses.cell)
                );
            }
            function isGridHeaderCellRoot(elem) {
                return (
                    elem != null &&
                    elem.classList.contains(gridClasses.columnHeader)
                );
            }

            function escapeOperandAttributeSelector(operand) {
                return operand.replace(/["\\]/g, "\\$&");
            }

            function getGridColumnHeaderElement(root, field) {
                return root.querySelector(
                    `[role="columnheader"][data-field="${escapeOperandAttributeSelector(
                        field
                    )}"]`
                );
            }
            function getGridRowElement(root, id) {
                return root.querySelector(
                    `.${
                        gridClasses_gridClasses.row
                    }[data-id="${escapeOperandAttributeSelector(String(id))}"]`
                );
            }
            function getGridCellElement(root, { id, field }) {
                const row = getGridRowElement(root, id);

                if (!row) {
                    return null;
                }

                return row.querySelector(
                    `.${
                        gridClasses_gridClasses.cell
                    }[data-field="${escapeOperandAttributeSelector(field)}"]`
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/rows/useGridParamsApi.js
            let warnedOnceMissingColumn = false;

            function warnMissingColumn(field) {
                console.warn(
                    [
                        `MUI: You are calling getValue('${field}') but the column \`${field}\` is not defined.`,
                        `Instead, you can access the data from \`params.row.${field}\`.`,
                    ].join("\n")
                );
                warnedOnceMissingColumn = true;
            }

            const getCellValueWarning = (0, warning /* buildWarning */.b)([
                `MUI: You are calling getValue. This method is deprecated and will be removed in the next major version.`,
                "Instead, you can access the data from `params.row`.",
            ]);
            /**
             * @requires useGridColumns (method)
             * @requires useGridRows (method)
             * @requires useGridFocus (state)
             * @requires useGridEditing (method)
             * TODO: Impossible priority - useGridEditing also needs to be after useGridParamsApi
             * TODO: Impossible priority - useGridFocus also needs to be after useGridParamsApi
             */

            function useGridParamsApi(apiRef) {
                const getColumnHeaderParams = react.useCallback(
                    (field) => ({
                        field,
                        colDef: apiRef.current.getColumn(field),
                    }),
                    [apiRef]
                );
                /**
                 * We want to remove the `getValue` param from `getRowParams`, `getCellParams` and `getBaseCellParams`
                 */

                const getCellValueWithDeprecationWarning = react.useCallback(
                    (...args) => {
                        if (false) {
                        }

                        return apiRef.current.getCellValue(...args);
                    },
                    [apiRef]
                );
                const getRowParams = react.useCallback(
                    (id) => {
                        const row = apiRef.current.getRow(id);

                        if (!row) {
                            throw new Error(`No row with id #${id} found`);
                        }

                        const params = {
                            id,
                            columns: apiRef.current.getAllColumns(),
                            row,
                            // TODO v6: remove
                            getValue: getCellValueWithDeprecationWarning,
                        };
                        return params;
                    },
                    [apiRef, getCellValueWithDeprecationWarning]
                );
                const getBaseCellParams = react.useCallback(
                    (id, field) => {
                        const row = apiRef.current.getRow(id);
                        const rowNode = apiRef.current.getRowNode(id);

                        if (!row || !rowNode) {
                            throw new Error(`No row with id #${id} found`);
                        }

                        const cellFocus = gridFocusCellSelector(apiRef);
                        const cellTabIndex = gridTabIndexCellSelector(apiRef);
                        const params = {
                            id,
                            field,
                            row,
                            rowNode,
                            value: row[field],
                            colDef: apiRef.current.getColumn(field),
                            cellMode: apiRef.current.getCellMode(id, field),
                            // TODO v6: remove
                            getValue: getCellValueWithDeprecationWarning,
                            api: apiRef.current,
                            hasFocus:
                                cellFocus !== null &&
                                cellFocus.field === field &&
                                cellFocus.id === id,
                            tabIndex:
                                cellTabIndex &&
                                cellTabIndex.field === field &&
                                cellTabIndex.id === id
                                    ? 0
                                    : -1,
                        };
                        return params;
                    },
                    [apiRef, getCellValueWithDeprecationWarning]
                );
                const getCellParams = react.useCallback(
                    (id, field) => {
                        const colDef = apiRef.current.getColumn(field);
                        const value = apiRef.current.getCellValue(id, field);
                        const row = apiRef.current.getRow(id);
                        const rowNode = apiRef.current.getRowNode(id);

                        if (!row || !rowNode) {
                            throw new Error(`No row with id #${id} found`);
                        }

                        const cellFocus = gridFocusCellSelector(apiRef);
                        const cellTabIndex = gridTabIndexCellSelector(apiRef);
                        const params = {
                            id,
                            field,
                            row,
                            rowNode,
                            colDef,
                            cellMode: apiRef.current.getCellMode(id, field),
                            // TODO v6: remove
                            getValue: getCellValueWithDeprecationWarning,
                            hasFocus:
                                cellFocus !== null &&
                                cellFocus.field === field &&
                                cellFocus.id === id,
                            tabIndex:
                                cellTabIndex &&
                                cellTabIndex.field === field &&
                                cellTabIndex.id === id
                                    ? 0
                                    : -1,
                            value,
                            formattedValue: value,
                        };

                        if (colDef.valueFormatter) {
                            params.formattedValue = colDef.valueFormatter({
                                id,
                                field: params.field,
                                value: params.value,
                                api: apiRef.current,
                            });
                        }

                        params.isEditable =
                            colDef && apiRef.current.isCellEditable(params);
                        return params;
                    },
                    [apiRef, getCellValueWithDeprecationWarning]
                );
                const getCellValue = react.useCallback(
                    (id, field) => {
                        const colDef = apiRef.current.getColumn(field);

                        if (false) {
                        }

                        if (!colDef || !colDef.valueGetter) {
                            const rowModel = apiRef.current.getRow(id);

                            if (!rowModel) {
                                throw new Error(`No row with id #${id} found`);
                            }

                            return rowModel[field];
                        }

                        return colDef.valueGetter(getBaseCellParams(id, field));
                    },
                    [apiRef, getBaseCellParams]
                );
                const getColumnHeaderElement = react.useCallback(
                    (field) => {
                        if (!apiRef.current.rootElementRef.current) {
                            return null;
                        }

                        return getGridColumnHeaderElement(
                            apiRef.current.rootElementRef.current,
                            field
                        );
                    },
                    [apiRef]
                );
                const getRowElement = react.useCallback(
                    (id) => {
                        if (!apiRef.current.rootElementRef.current) {
                            return null;
                        }

                        return getGridRowElement(
                            apiRef.current.rootElementRef.current,
                            id
                        );
                    },
                    [apiRef]
                );
                const getCellElement = react.useCallback(
                    (id, field) => {
                        if (!apiRef.current.rootElementRef.current) {
                            return null;
                        }

                        return getGridCellElement(
                            apiRef.current.rootElementRef.current,
                            {
                                id,
                                field,
                            }
                        );
                    },
                    [apiRef]
                );
                const paramsApi = {
                    getCellValue,
                    getCellParams,
                    getCellElement,
                    getRowParams,
                    getRowElement,
                    getColumnHeaderParams,
                    getColumnHeaderElement,
                };
                useGridApiMethod(apiRef, paramsApi, "GridParamsApi");
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/selection/useGridSelection.js
            const getSelectionModelPropValue = (
                selectionModelProp,
                prevSelectionModel
            ) => {
                if (selectionModelProp == null) {
                    return selectionModelProp;
                }

                if (Array.isArray(selectionModelProp)) {
                    return selectionModelProp;
                }

                if (
                    prevSelectionModel &&
                    prevSelectionModel[0] === selectionModelProp
                ) {
                    return prevSelectionModel;
                }

                return [selectionModelProp];
            };

            const selectionStateInitializer = (state, props) => {
                var _getSelectionModelPro;

                return (0, esm_extends /* default */.Z)({}, state, {
                    selection:
                        (_getSelectionModelPro = getSelectionModelPropValue(
                            props.selectionModel
                        )) != null
                            ? _getSelectionModelPro
                            : [],
                });
            };
            /**
             * @requires useGridRows (state, method) - can be after
             * @requires useGridParamsApi (method) - can be after
             * @requires useGridFocus (state) - can be after
             * @requires useGridKeyboardNavigation (`cellKeyDown` event must first be consumed by it)
             */

            const useGridSelection = (apiRef, props) => {
                const logger = useGridLogger(apiRef, "useGridSelection");
                const propSelectionModel = react.useMemo(() => {
                    return getSelectionModelPropValue(
                        props.selectionModel,
                        gridSelectionStateSelector(apiRef.current.state)
                    );
                }, [apiRef, props.selectionModel]);
                const lastRowToggled = react.useRef(null);
                apiRef.current.unstable_updateControlState({
                    stateId: "selection",
                    propModel: propSelectionModel,
                    propOnChange: props.onSelectionModelChange,
                    stateSelector: gridSelectionStateSelector,
                    changeEvent:
                        gridEvents /* GridEvents.selectionChange */.t
                            .selectionChange,
                });
                const {
                    checkboxSelection,
                    disableMultipleSelection,
                    disableSelectionOnClick,
                    isRowSelectable,
                    pagination,
                    paginationMode,
                } = props;
                const canHaveMultipleSelection =
                    !disableMultipleSelection || checkboxSelection;
                const visibleRows = useGridVisibleRows(apiRef, props);
                const expandMouseRowRangeSelection = react.useCallback(
                    (id) => {
                        var _lastRowToggled$curre;

                        let endId = id;
                        const startId =
                            (_lastRowToggled$curre = lastRowToggled.current) !=
                            null
                                ? _lastRowToggled$curre
                                : id;
                        const isSelected = apiRef.current.isRowSelected(id);

                        if (isSelected) {
                            const visibleRowIds =
                                gridVisibleSortedRowIdsSelector(apiRef);
                            const startIndex = visibleRowIds.findIndex(
                                (rowId) => rowId === startId
                            );
                            const endIndex = visibleRowIds.findIndex(
                                (rowId) => rowId === endId
                            );

                            if (startIndex === endIndex) {
                                return;
                            }

                            if (startIndex > endIndex) {
                                endId = visibleRowIds[endIndex + 1];
                            } else {
                                endId = visibleRowIds[endIndex - 1];
                            }
                        }

                        lastRowToggled.current = id;
                        apiRef.current.selectRowRange(
                            {
                                startId,
                                endId,
                            },
                            !isSelected
                        );
                    },
                    [apiRef]
                );
                /**
                 * API METHODS
                 */

                const setSelectionModel = react.useCallback(
                    (model) => {
                        const currentModel = gridSelectionStateSelector(
                            apiRef.current.state
                        );

                        if (currentModel !== model) {
                            logger.debug(`Setting selection model`);
                            apiRef.current.setState((state) =>
                                (0, esm_extends /* default */.Z)({}, state, {
                                    selection: model,
                                })
                            );
                            apiRef.current.forceUpdate();
                        }
                    },
                    [apiRef, logger]
                );
                const isRowSelected = react.useCallback(
                    (id) =>
                        gridSelectionStateSelector(
                            apiRef.current.state
                        ).includes(id),
                    [apiRef]
                );
                const getSelectedRows = react.useCallback(
                    () => selectedGridRowsSelector(apiRef),
                    [apiRef]
                );
                const selectRow = react.useCallback(
                    (id, isSelected = true, resetSelection = false) => {
                        if (
                            isRowSelectable &&
                            !isRowSelectable(apiRef.current.getRowParams(id))
                        ) {
                            return;
                        }

                        lastRowToggled.current = id;

                        if (resetSelection) {
                            logger.debug(`Setting selection for row ${id}`);
                            apiRef.current.setSelectionModel(
                                isSelected ? [id] : []
                            );
                        } else {
                            logger.debug(`Toggling selection for row ${id}`);
                            const selection = gridSelectionStateSelector(
                                apiRef.current.state
                            );
                            const newSelection = selection.filter(
                                (el) => el !== id
                            );

                            if (isSelected) {
                                newSelection.push(id);
                            }

                            const isSelectionValid =
                                newSelection.length < 2 ||
                                canHaveMultipleSelection;

                            if (isSelectionValid) {
                                apiRef.current.setSelectionModel(newSelection);
                            }
                        }
                    },
                    [apiRef, isRowSelectable, logger, canHaveMultipleSelection]
                );
                const selectRows = react.useCallback(
                    (ids, isSelected = true, resetSelection = false) => {
                        logger.debug(`Setting selection for several rows`);
                        const selectableIds = isRowSelectable
                            ? ids.filter((id) =>
                                  isRowSelectable(
                                      apiRef.current.getRowParams(id)
                                  )
                              )
                            : ids;
                        let newSelection;

                        if (resetSelection) {
                            newSelection = isSelected ? selectableIds : [];
                        } else {
                            // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project
                            const selectionLookup = (0,
                            esm_extends /* default */.Z)(
                                {},
                                selectedIdsLookupSelector(apiRef)
                            );

                            selectableIds.forEach((id) => {
                                if (isSelected) {
                                    selectionLookup[id] = id;
                                } else {
                                    delete selectionLookup[id];
                                }
                            });
                            newSelection = Object.values(selectionLookup);
                        }

                        const isSelectionValid =
                            newSelection.length < 2 || canHaveMultipleSelection;

                        if (isSelectionValid) {
                            apiRef.current.setSelectionModel(newSelection);
                        }
                    },
                    [apiRef, isRowSelectable, logger, canHaveMultipleSelection]
                );
                const selectRowRange = react.useCallback(
                    ({ startId, endId }, isSelected = true, resetSelection) => {
                        if (
                            !apiRef.current.getRow(startId) ||
                            !apiRef.current.getRow(endId)
                        ) {
                            return;
                        }

                        logger.debug(
                            `Expanding selection from row ${startId} to row ${endId}`
                        ); // Using rows from all pages allow to select a range across several pages

                        const allPagesRowIds =
                            gridVisibleSortedRowIdsSelector(apiRef);
                        const startIndex = allPagesRowIds.indexOf(startId);
                        const endIndex = allPagesRowIds.indexOf(endId);
                        const [start, end] =
                            startIndex > endIndex
                                ? [endIndex, startIndex]
                                : [startIndex, endIndex];
                        const rowsBetweenStartAndEnd = allPagesRowIds.slice(
                            start,
                            end + 1
                        );
                        apiRef.current.selectRows(
                            rowsBetweenStartAndEnd,
                            isSelected,
                            resetSelection
                        );
                    },
                    [apiRef, logger]
                );
                const selectionApi = {
                    selectRow,
                    selectRows,
                    selectRowRange,
                    setSelectionModel,
                    getSelectedRows,
                    isRowSelected,
                };
                useGridApiMethod(apiRef, selectionApi, "GridSelectionApi");
                /**
                 * EVENTS
                 */

                const removeOutdatedSelection = react.useCallback(() => {
                    const currentSelection = gridSelectionStateSelector(
                        apiRef.current.state
                    );
                    const rowsLookup = gridRowsLookupSelector(apiRef); // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project

                    const selectionLookup = (0, esm_extends /* default */.Z)(
                        {},
                        selectedIdsLookupSelector(apiRef)
                    );

                    let hasChanged = false;
                    currentSelection.forEach((id) => {
                        if (!rowsLookup[id]) {
                            delete selectionLookup[id];
                            hasChanged = true;
                        }
                    });

                    if (hasChanged) {
                        apiRef.current.setSelectionModel(
                            Object.values(selectionLookup)
                        );
                    }
                }, [apiRef]);
                const handleSingleRowSelection = react.useCallback(
                    (id, event) => {
                        const hasCtrlKey = event.metaKey || event.ctrlKey; // multiple selection is only allowed if:
                        // - it is a checkboxSelection
                        // - it is a keyboard selection
                        // - CTRL is pressed

                        const isMultipleSelectionDisabled =
                            !checkboxSelection &&
                            !hasCtrlKey &&
                            !isKeyboardEvent(event);
                        const resetSelection =
                            !canHaveMultipleSelection ||
                            isMultipleSelectionDisabled;
                        const isSelected = apiRef.current.isRowSelected(id);

                        if (resetSelection) {
                            apiRef.current.selectRow(
                                id,
                                !isMultipleSelectionDisabled
                                    ? !isSelected
                                    : true,
                                true
                            );
                        } else {
                            apiRef.current.selectRow(id, !isSelected, false);
                        }
                    },
                    [apiRef, canHaveMultipleSelection, checkboxSelection]
                );
                const handleCellClick = react.useCallback(
                    (params, event) => {
                        if (disableSelectionOnClick) {
                            return;
                        }

                        if (
                            params.field ===
                            GRID_CHECKBOX_SELECTION_COL_DEF.field
                        ) {
                            // click on checkbox should not trigger row selection
                            return;
                        }

                        if (params.field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
                            // click to open the detail panel should not select the row
                            return;
                        }

                        if (params.field) {
                            const column = apiRef.current.getColumn(
                                params.field
                            );

                            if (column.type === GRID_ACTIONS_COLUMN_TYPE) {
                                return;
                            }
                        }

                        if (
                            event.shiftKey &&
                            (canHaveMultipleSelection || checkboxSelection)
                        ) {
                            expandMouseRowRangeSelection(params.id);
                        } else {
                            handleSingleRowSelection(params.id, event);
                        }
                    },
                    [
                        disableSelectionOnClick,
                        canHaveMultipleSelection,
                        checkboxSelection,
                        apiRef,
                        expandMouseRowRangeSelection,
                        handleSingleRowSelection,
                    ]
                );
                const preventSelectionOnShift = react.useCallback(
                    (params, event) => {
                        if (canHaveMultipleSelection && event.shiftKey) {
                            var _window$getSelection;

                            (_window$getSelection = window.getSelection()) ==
                            null
                                ? void 0
                                : _window$getSelection.removeAllRanges();
                        }
                    },
                    [canHaveMultipleSelection]
                );
                const handleRowSelectionCheckboxChange = react.useCallback(
                    (params, event) => {
                        if (event.nativeEvent.shiftKey) {
                            expandMouseRowRangeSelection(params.id);
                        } else {
                            apiRef.current.selectRow(params.id, params.value);
                        }
                    },
                    [apiRef, expandMouseRowRangeSelection]
                );
                const handleHeaderSelectionCheckboxChange = react.useCallback(
                    (params) => {
                        const shouldLimitSelectionToCurrentPage =
                            props.checkboxSelectionVisibleOnly &&
                            props.pagination;
                        const rowsToBeSelected =
                            shouldLimitSelectionToCurrentPage
                                ? gridPaginatedVisibleSortedGridRowIdsSelector(
                                      apiRef
                                  )
                                : gridVisibleSortedRowIdsSelector(apiRef);
                        apiRef.current.selectRows(
                            rowsToBeSelected,
                            params.value
                        );
                    },
                    [
                        apiRef,
                        props.checkboxSelectionVisibleOnly,
                        props.pagination,
                    ]
                );
                const handleCellKeyDown = react.useCallback(
                    (params, event) => {
                        // Get the most recent cell mode because it may have been changed by another listener
                        if (
                            apiRef.current.getCellMode(
                                params.id,
                                params.field
                            ) === GridCellModes.Edit
                        ) {
                            return;
                        } // Ignore portal
                        // Do not apply shortcuts if the focus is not on the cell root component

                        if (!event.currentTarget.contains(event.target)) {
                            return;
                        }

                        if (isNavigationKey(event.key) && event.shiftKey) {
                            // The cell that has focus after the keyboard navigation
                            const focusCell = gridFocusCellSelector(apiRef);

                            if (focusCell && focusCell.id !== params.id) {
                                event.preventDefault();
                                const isNextRowSelected =
                                    apiRef.current.isRowSelected(focusCell.id);

                                if (!canHaveMultipleSelection) {
                                    apiRef.current.selectRow(
                                        focusCell.id,
                                        !isNextRowSelected,
                                        true
                                    );
                                    return;
                                }

                                const newRowIndex =
                                    apiRef.current.getRowIndexRelativeToVisibleRows(
                                        focusCell.id
                                    );
                                const previousRowIndex =
                                    apiRef.current.getRowIndexRelativeToVisibleRows(
                                        params.id
                                    );
                                let start;
                                let end;

                                if (newRowIndex > previousRowIndex) {
                                    if (isNextRowSelected) {
                                        // We are navigating to the bottom of the page and adding selected rows
                                        start = previousRowIndex;
                                        end = newRowIndex - 1;
                                    } else {
                                        // We are navigating to the bottom of the page and removing selected rows
                                        start = previousRowIndex;
                                        end = newRowIndex;
                                    }
                                } else {
                                    // eslint-disable-next-line no-lonely-if
                                    if (isNextRowSelected) {
                                        // We are navigating to the top of the page and removing selected rows
                                        start = newRowIndex + 1;
                                        end = previousRowIndex;
                                    } else {
                                        // We are navigating to the top of the page and adding selected rows
                                        start = newRowIndex;
                                        end = previousRowIndex;
                                    }
                                }

                                const rowsBetweenStartAndEnd = visibleRows.rows
                                    .slice(start, end + 1)
                                    .map((row) => row.id);
                                apiRef.current.selectRows(
                                    rowsBetweenStartAndEnd,
                                    !isNextRowSelected
                                );
                                return;
                            }
                        }

                        if (event.key === " " && event.shiftKey) {
                            event.preventDefault();
                            handleSingleRowSelection(params.id, event);
                            return;
                        }

                        if (
                            event.key.toLowerCase() === "a" &&
                            (event.ctrlKey || event.metaKey)
                        ) {
                            event.preventDefault();
                            selectRows(apiRef.current.getAllRowIds(), true);
                        }
                    },
                    [
                        apiRef,
                        handleSingleRowSelection,
                        selectRows,
                        visibleRows.rows,
                        canHaveMultipleSelection,
                    ]
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.sortedRowsSet */.t.sortedRowsSet,
                    removeOutdatedSelection
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellClick */.t.cellClick,
                    handleCellClick
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowSelectionCheckboxChange */.t
                        .rowSelectionCheckboxChange,
                    handleRowSelectionCheckboxChange
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.headerSelectionCheckboxChange */.t
                        .headerSelectionCheckboxChange,
                    handleHeaderSelectionCheckboxChange
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellMouseDown */.t.cellMouseDown,
                    preventSelectionOnShift
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    handleCellKeyDown
                );
                /**
                 * EFFECTS
                 */

                react.useEffect(() => {
                    if (propSelectionModel !== undefined) {
                        apiRef.current.setSelectionModel(propSelectionModel);
                    }
                }, [apiRef, propSelectionModel]);
                const isStateControlled = propSelectionModel != null;
                react.useEffect(() => {
                    if (isStateControlled) {
                        return;
                    } // isRowSelectable changed

                    const currentSelection = gridSelectionStateSelector(
                        apiRef.current.state
                    );

                    if (isRowSelectable) {
                        const newSelection = currentSelection.filter((id) =>
                            isRowSelectable(apiRef.current.getRowParams(id))
                        );

                        if (newSelection.length < currentSelection.length) {
                            apiRef.current.setSelectionModel(newSelection);
                        }
                    }
                }, [apiRef, isRowSelectable, isStateControlled]);
                react.useEffect(() => {
                    const currentSelection = gridSelectionStateSelector(
                        apiRef.current.state
                    );

                    if (
                        !canHaveMultipleSelection &&
                        currentSelection.length > 1
                    ) {
                        const { rows: currentPageRows } = getVisibleRows(
                            apiRef,
                            {
                                pagination,
                                paginationMode,
                            }
                        );
                        const currentPageRowsLookup = currentPageRows.reduce(
                            (acc, { id }) => {
                                acc[id] = true;
                                return acc;
                            },
                            {}
                        );
                        const firstSelectableRow = currentSelection.find(
                            (id) => {
                                let isSelectable = true;

                                if (isRowSelectable) {
                                    isSelectable = isRowSelectable(
                                        apiRef.current.getRowParams(id)
                                    );
                                }

                                return (
                                    isSelectable && currentPageRowsLookup[id]
                                ); // Check if the row is in the current page
                            }
                        );
                        apiRef.current.setSelectionModel(
                            firstSelectableRow !== undefined
                                ? [firstSelectableRow]
                                : []
                        );
                    }
                }, [
                    apiRef,
                    canHaveMultipleSelection,
                    checkboxSelection,
                    disableMultipleSelection,
                    isRowSelectable,
                    pagination,
                    paginationMode,
                ]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/selection/useGridSelectionPreProcessors.js
            const useGridSelectionPreProcessors_useUtilityClasses = (
                ownerState
            ) => {
                const { classes } = ownerState;
                return react.useMemo(() => {
                    const slots = {
                        cellCheckbox: ["cellCheckbox"],
                        columnHeaderCheckbox: ["columnHeaderCheckbox"],
                    };
                    return (0, composeClasses /* default */.Z)(
                        slots,
                        getDataGridUtilityClass,
                        classes
                    );
                }, [classes]);
            };

            const useGridSelectionPreProcessors = (apiRef, props) => {
                const ownerState = {
                    classes: props.classes,
                };
                const classes =
                    useGridSelectionPreProcessors_useUtilityClasses(ownerState);
                const updateSelectionColumn = react.useCallback(
                    (columnsState) => {
                        const selectionColumn = (0,
                        esm_extends /* default */.Z)(
                            {},
                            GRID_CHECKBOX_SELECTION_COL_DEF,
                            {
                                cellClassName: classes.cellCheckbox,
                                headerClassName: classes.columnHeaderCheckbox,
                                headerName: apiRef.current.getLocaleText(
                                    "checkboxSelectionHeaderName"
                                ),
                            }
                        );

                        const shouldHaveSelectionColumn =
                            props.checkboxSelection;
                        const haveSelectionColumn =
                            columnsState.lookup[selectionColumn.field] != null;

                        if (shouldHaveSelectionColumn && !haveSelectionColumn) {
                            columnsState.lookup[selectionColumn.field] =
                                selectionColumn;
                            columnsState.all = [
                                selectionColumn.field,
                                ...columnsState.all,
                            ];
                        } else if (
                            !shouldHaveSelectionColumn &&
                            haveSelectionColumn
                        ) {
                            delete columnsState.lookup[selectionColumn.field];
                            columnsState.all = columnsState.all.filter(
                                (field) => field !== selectionColumn.field
                            );
                        }

                        return columnsState;
                    },
                    [apiRef, classes, props.checkboxSelection]
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "hydrateColumns",
                    updateSelectionColumn
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/sorting/useGridSorting.js
            const sortingStateInitializer = (state, props) => {
                var _ref,
                    _props$sortModel,
                    _props$initialState,
                    _props$initialState$s;

                const sortModel =
                    (_ref =
                        (_props$sortModel = props.sortModel) != null
                            ? _props$sortModel
                            : (_props$initialState = props.initialState) == null
                            ? void 0
                            : (_props$initialState$s =
                                  _props$initialState.sorting) == null
                            ? void 0
                            : _props$initialState$s.sortModel) != null
                        ? _ref
                        : [];
                return (0, esm_extends /* default */.Z)({}, state, {
                    sorting: {
                        sortModel: (0,
                        gridSortingUtils /* sanitizeSortModel */.Te)(
                            sortModel,
                            props.disableMultipleColumnsSorting
                        ),
                        sortedRows: [],
                    },
                });
            };
            /**
             * @requires useGridRows (event)
             * @requires useGridColumns (event)
             */

            const useGridSorting = (apiRef, props) => {
                const logger = useGridLogger(apiRef, "useGridSorting");
                apiRef.current.unstable_updateControlState({
                    stateId: "sortModel",
                    propModel: props.sortModel,
                    propOnChange: props.onSortModelChange,
                    stateSelector: gridSortModelSelector,
                    changeEvent:
                        gridEvents /* GridEvents.sortModelChange */.t
                            .sortModelChange,
                });
                const upsertSortModel = react.useCallback(
                    (field, sortItem) => {
                        const sortModel = gridSortModelSelector(apiRef);
                        const existingIdx = sortModel.findIndex(
                            (c) => c.field === field
                        );
                        let newSortModel = [...sortModel];

                        if (existingIdx > -1) {
                            if (!sortItem) {
                                newSortModel.splice(existingIdx, 1);
                            } else {
                                newSortModel.splice(existingIdx, 1, sortItem);
                            }
                        } else {
                            newSortModel = [...sortModel, sortItem];
                        }

                        return newSortModel;
                    },
                    [apiRef]
                );
                const createSortItem = react.useCallback(
                    (col, directionOverride) => {
                        var _col$sortingOrder2;

                        const sortModel = gridSortModelSelector(apiRef);
                        const existing = sortModel.find(
                            (c) => c.field === col.field
                        );

                        if (existing) {
                            var _col$sortingOrder;

                            const nextSort =
                                directionOverride === undefined
                                    ? (0,
                                      gridSortingUtils /* getNextGridSortDirection */.vY)(
                                          (_col$sortingOrder =
                                              col.sortingOrder) != null
                                              ? _col$sortingOrder
                                              : props.sortingOrder,
                                          existing.sort
                                      )
                                    : directionOverride;
                            return nextSort == null
                                ? undefined
                                : (0, esm_extends /* default */.Z)(
                                      {},
                                      existing,
                                      {
                                          sort: nextSort,
                                      }
                                  );
                        }

                        return {
                            field: col.field,
                            sort:
                                directionOverride === undefined
                                    ? (0,
                                      gridSortingUtils /* getNextGridSortDirection */.vY)(
                                          (_col$sortingOrder2 =
                                              col.sortingOrder) != null
                                              ? _col$sortingOrder2
                                              : props.sortingOrder
                                      )
                                    : directionOverride,
                        };
                    },
                    [apiRef, props.sortingOrder]
                );
                /**
                 * API METHODS
                 */

                const applySorting = react.useCallback(() => {
                    apiRef.current.setState((state) => {
                        if (
                            props.sortingMode === GridFeatureModeConstant.server
                        ) {
                            logger.debug(
                                "Skipping sorting rows as sortingMode = server"
                            );
                            return (0, esm_extends /* default */.Z)({}, state, {
                                sorting: (0, esm_extends /* default */.Z)(
                                    {},
                                    state.sorting,
                                    {
                                        sortedRows: gridRowIdsSelector(
                                            state,
                                            apiRef.current.instanceId
                                        ),
                                    }
                                ),
                            });
                        }

                        const sortModel = gridSortModelSelector(
                            state,
                            apiRef.current.instanceId
                        );
                        const sortRowList = (0,
                        gridSortingUtils /* buildAggregatedSortingApplier */.oX)(
                            sortModel,
                            apiRef
                        );
                        const sortedRows =
                            apiRef.current.unstable_applyStrategyProcessor(
                                "sorting",
                                {
                                    sortRowList,
                                }
                            );
                        return (0, esm_extends /* default */.Z)({}, state, {
                            sorting: (0, esm_extends /* default */.Z)(
                                {},
                                state.sorting,
                                {
                                    sortedRows,
                                }
                            ),
                        });
                    });
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.sortedRowsSet */.t
                            .sortedRowsSet
                    );
                    apiRef.current.forceUpdate();
                }, [apiRef, logger, props.sortingMode]);
                const setSortModel = react.useCallback(
                    (model) => {
                        const currentModel = gridSortModelSelector(apiRef);

                        if (currentModel !== model) {
                            logger.debug(`Setting sort model`);
                            apiRef.current.setState(
                                (0,
                                gridSortingUtils /* mergeStateWithSortModel */.E8)(
                                    model,
                                    props.disableMultipleColumnsSorting
                                )
                            );
                            apiRef.current.forceUpdate();
                            apiRef.current.applySorting();
                        }
                    },
                    [apiRef, logger, props.disableMultipleColumnsSorting]
                );
                const sortColumn = react.useCallback(
                    (column, direction, allowMultipleSorting) => {
                        if (!column.sortable) {
                            return;
                        }

                        const sortItem = createSortItem(column, direction);
                        let sortModel;

                        if (
                            !allowMultipleSorting ||
                            props.disableMultipleColumnsSorting
                        ) {
                            sortModel = !sortItem ? [] : [sortItem];
                        } else {
                            sortModel = upsertSortModel(column.field, sortItem);
                        }

                        apiRef.current.setSortModel(sortModel);
                    },
                    [
                        apiRef,
                        upsertSortModel,
                        createSortItem,
                        props.disableMultipleColumnsSorting,
                    ]
                );
                const getSortModel = react.useCallback(
                    () => gridSortModelSelector(apiRef),
                    [apiRef]
                );
                const getSortedRows = react.useCallback(() => {
                    const sortedRows = gridSortedRowEntriesSelector(apiRef);
                    return sortedRows.map((row) => row.model);
                }, [apiRef]);
                const getSortedRowIds = react.useCallback(
                    () => gridSortedRowIdsSelector(apiRef),
                    [apiRef]
                );
                const getRowIndex = react.useCallback(
                    (id) => apiRef.current.getSortedRowIds().indexOf(id),
                    [apiRef]
                );
                const getRowIdFromRowIndex = react.useCallback(
                    (index) => apiRef.current.getSortedRowIds()[index],
                    [apiRef]
                );
                const sortApi = {
                    getSortModel,
                    getSortedRows,
                    getSortedRowIds,
                    getRowIndex,
                    getRowIdFromRowIndex,
                    setSortModel,
                    sortColumn,
                    applySorting,
                };
                useGridApiMethod(apiRef, sortApi, "GridSortApi");
                /**
                 * PRE-PROCESSING
                 */

                const stateExportPreProcessing = react.useCallback(
                    (prevState) => {
                        const sortModelToExport = gridSortModelSelector(apiRef);

                        if (sortModelToExport.length === 0) {
                            return prevState;
                        }

                        return (0, esm_extends /* default */.Z)({}, prevState, {
                            sorting: {
                                sortModel: sortModelToExport,
                            },
                        });
                    },
                    [apiRef]
                );
                const stateRestorePreProcessing = react.useCallback(
                    (params, context) => {
                        var _context$stateToResto;

                        const sortModel =
                            (_context$stateToResto =
                                context.stateToRestore.sorting) == null
                                ? void 0
                                : _context$stateToResto.sortModel;

                        if (sortModel == null) {
                            return params;
                        }

                        apiRef.current.setState(
                            (0,
                            gridSortingUtils /* mergeStateWithSortModel */.E8)(
                                sortModel,
                                props.disableMultipleColumnsSorting
                            )
                        );
                        return (0, esm_extends /* default */.Z)({}, params, {
                            callbacks: [
                                ...params.callbacks,
                                apiRef.current.applySorting,
                            ],
                        });
                    },
                    [apiRef, props.disableMultipleColumnsSorting]
                );
                const flatSortingMethod = react.useCallback(
                    (params) => {
                        if (!params.sortRowList) {
                            return gridRowIdsSelector(apiRef);
                        }

                        const rowTree = gridRowTreeSelector(apiRef);
                        return params.sortRowList(Object.values(rowTree));
                    },
                    [apiRef]
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "exportState",
                    stateExportPreProcessing
                );
                useGridRegisterPipeProcessor(
                    apiRef,
                    "restoreState",
                    stateRestorePreProcessing
                );
                useGridRegisterStrategyProcessor(
                    apiRef,
                    GRID_DEFAULT_STRATEGY,
                    "sorting",
                    flatSortingMethod
                );
                /**
                 * EVENTS
                 */

                const handleColumnHeaderClick = react.useCallback(
                    ({ colDef }, event) => {
                        const allowMultipleSorting =
                            event.shiftKey || event.metaKey || event.ctrlKey;
                        sortColumn(colDef, undefined, allowMultipleSorting);
                    },
                    [sortColumn]
                );
                const handleColumnHeaderKeyDown = react.useCallback(
                    ({ colDef }, event) => {
                        // CTRL + Enter opens the column menu
                        if (
                            isEnterKey(event.key) &&
                            !event.ctrlKey &&
                            !event.metaKey
                        ) {
                            sortColumn(colDef, undefined, event.shiftKey);
                        }
                    },
                    [sortColumn]
                );
                const handleColumnsChange = react.useCallback(() => {
                    // When the columns change we check that the sorted columns are still part of the dataset
                    const sortModel = gridSortModelSelector(apiRef);
                    const latestColumns = gridColumnLookupSelector(apiRef);

                    if (sortModel.length > 0) {
                        const newModel = sortModel.filter(
                            (sortItem) => latestColumns[sortItem.field]
                        );

                        if (newModel.length < sortModel.length) {
                            apiRef.current.setSortModel(newModel);
                        }
                    }
                }, [apiRef]);
                const handleStrategyProcessorChange = react.useCallback(
                    (methodName) => {
                        if (methodName === "sorting") {
                            apiRef.current.applySorting();
                        }
                    },
                    [apiRef]
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderClick */.t
                        .columnHeaderClick,
                    handleColumnHeaderClick
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderKeyDown */.t
                        .columnHeaderKeyDown,
                    handleColumnHeaderKeyDown
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowsSet */.t.rowsSet,
                    apiRef.current.applySorting
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnsChange */.t.columnsChange,
                    handleColumnsChange
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.activeStrategyProcessorChange */.t
                        .activeStrategyProcessorChange,
                    handleStrategyProcessorChange
                );
                /**
                 * 1ST RENDER
                 */

                useFirstRender(() => {
                    apiRef.current.applySorting();
                });
                /**
                 * EFFECTS
                 */

                react.useEffect(() => {
                    if (props.sortModel !== undefined) {
                        apiRef.current.setSortModel(props.sortModel);
                    }
                }, [apiRef, props.sortModel]);
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/scroll/useGridScroll.js
            // Logic copied from https://www.w3.org/TR/wai-aria-practices/examples/listbox/js/listbox.js
            // Similar to https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView

            function scrollIntoView(dimensions) {
                const { clientHeight, scrollTop, offsetHeight, offsetTop } =
                    dimensions;
                const elementBottom = offsetTop + offsetHeight;

                if (elementBottom - clientHeight > scrollTop) {
                    return elementBottom - clientHeight;
                }

                if (offsetTop < scrollTop) {
                    return offsetTop;
                }

                return undefined;
            }
            /**
             * @requires useGridPagination (state) - can be after, async only
             * @requires useGridColumns (state) - can be after, async only
             * @requires useGridRows (state) - can be after, async only
             * @requires useGridRowsMeta (state) - can be after, async only
             * @requires useGridFilter (state)
             * @requires useGridColumnSpanning (method)
             */

            const useGridScroll = (apiRef, props) => {
                const logger = useGridLogger(apiRef, "useGridScroll");
                const colRef = apiRef.current.columnHeadersElementRef;
                const windowRef = apiRef.current.windowRef;
                const visibleSortedRows = useGridSelector(
                    apiRef,
                    gridVisibleSortedRowEntriesSelector
                );
                const scrollToIndexes = react.useCallback(
                    (params) => {
                        const totalRowCount = gridRowCountSelector(apiRef);
                        const visibleColumns =
                            gridVisibleColumnDefinitionsSelector(apiRef);
                        const scrollToHeader = params.rowIndex == null;

                        if (
                            (!scrollToHeader && totalRowCount === 0) ||
                            visibleColumns.length === 0
                        ) {
                            return false;
                        }

                        logger.debug(
                            `Scrolling to cell at row ${params.rowIndex}, col: ${params.colIndex} `
                        );
                        let scrollCoordinates = {};

                        if (params.colIndex != null) {
                            const columnPositions =
                                gridColumnPositionsSelector(apiRef);
                            let cellWidth;

                            if (typeof params.rowIndex !== "undefined") {
                                var _visibleSortedRows$pa;

                                const rowId =
                                    (_visibleSortedRows$pa =
                                        visibleSortedRows[params.rowIndex]) ==
                                    null
                                        ? void 0
                                        : _visibleSortedRows$pa.id;
                                const cellColSpanInfo =
                                    apiRef.current.unstable_getCellColSpanInfo(
                                        rowId,
                                        params.colIndex
                                    );

                                if (
                                    cellColSpanInfo &&
                                    !cellColSpanInfo.spannedByColSpan
                                ) {
                                    cellWidth = cellColSpanInfo.cellProps.width;
                                }
                            }

                            if (typeof cellWidth === "undefined") {
                                cellWidth =
                                    visibleColumns[params.colIndex]
                                        .computedWidth;
                            }

                            scrollCoordinates.left = scrollIntoView({
                                clientHeight: windowRef.current.clientWidth,
                                scrollTop: windowRef.current.scrollLeft,
                                offsetHeight: cellWidth,
                                offsetTop: columnPositions[params.colIndex],
                            });
                        }

                        if (params.rowIndex != null) {
                            const rowsMeta = gridRowsMetaSelector(
                                apiRef.current.state
                            );
                            const page = gridPageSelector(apiRef);
                            const pageSize = gridPageSizeSelector(apiRef);
                            const elementIndex = !props.pagination
                                ? params.rowIndex
                                : params.rowIndex - page * pageSize;
                            const targetOffsetHeight = rowsMeta.positions[
                                elementIndex + 1
                            ]
                                ? rowsMeta.positions[elementIndex + 1] -
                                  rowsMeta.positions[elementIndex]
                                : rowsMeta.currentPageTotalHeight -
                                  rowsMeta.positions[elementIndex];
                            scrollCoordinates.top = scrollIntoView({
                                clientHeight: windowRef.current.clientHeight,
                                scrollTop: windowRef.current.scrollTop,
                                offsetHeight: targetOffsetHeight,
                                offsetTop: rowsMeta.positions[elementIndex],
                            });
                        }

                        scrollCoordinates =
                            apiRef.current.unstable_applyPipeProcessors(
                                "scrollToIndexes",
                                scrollCoordinates,
                                params
                            );

                        if (
                            typeof scrollCoordinates.left !== undefined ||
                            typeof scrollCoordinates.top !== undefined
                        ) {
                            apiRef.current.scroll(scrollCoordinates);
                            return true;
                        }

                        return false;
                    },
                    [
                        logger,
                        apiRef,
                        windowRef,
                        props.pagination,
                        visibleSortedRows,
                    ]
                );
                const scroll = react.useCallback(
                    (params) => {
                        if (
                            windowRef.current &&
                            params.left != null &&
                            colRef.current
                        ) {
                            colRef.current.scrollLeft = params.left;
                            windowRef.current.scrollLeft = params.left;
                            logger.debug(`Scrolling left: ${params.left}`);
                        }

                        if (windowRef.current && params.top != null) {
                            windowRef.current.scrollTop = params.top;
                            logger.debug(`Scrolling top: ${params.top}`);
                        }

                        logger.debug(
                            `Scrolling, updating container, and viewport`
                        );
                    },
                    [windowRef, colRef, logger]
                );
                const getScrollPosition = react.useCallback(() => {
                    if (!(windowRef != null && windowRef.current)) {
                        return {
                            top: 0,
                            left: 0,
                        };
                    }

                    return {
                        top: windowRef.current.scrollTop,
                        left: windowRef.current.scrollLeft,
                    };
                }, [windowRef]);
                const scrollApi = {
                    scroll,
                    scrollToIndexes,
                    getScrollPosition,
                };
                useGridApiMethod(apiRef, scrollApi, "GridScrollApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/events/useGridEvents.js
            /**
             * @requires useGridFocus (event) - can be after, async only
             * @requires useGridColumns (event) - can be after, async only
             */
            function useGridEvents(apiRef, props) {
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderClick */.t
                        .columnHeaderClick,
                    props.onColumnHeaderClick
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderDoubleClick */.t
                        .columnHeaderDoubleClick,
                    props.onColumnHeaderDoubleClick
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderOver */.t
                        .columnHeaderOver,
                    props.onColumnHeaderOver
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderOut */.t
                        .columnHeaderOut,
                    props.onColumnHeaderOut
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderEnter */.t
                        .columnHeaderEnter,
                    props.onColumnHeaderEnter
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderLeave */.t
                        .columnHeaderLeave,
                    props.onColumnHeaderLeave
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnOrderChange */.t
                        .columnOrderChange,
                    props.onColumnOrderChange
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellClick */.t.cellClick,
                    props.onCellClick
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellDoubleClick */.t
                        .cellDoubleClick,
                    props.onCellDoubleClick
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellKeyDown */.t.cellKeyDown,
                    props.onCellKeyDown
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.cellFocusOut */.t.cellFocusOut,
                    props.onCellFocusOut
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.preferencePanelClose */.t
                        .preferencePanelClose,
                    props.onPreferencePanelClose
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.preferencePanelOpen */.t
                        .preferencePanelOpen,
                    props.onPreferencePanelOpen
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowDoubleClick */.t.rowDoubleClick,
                    props.onRowDoubleClick
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowClick */.t.rowClick,
                    props.onRowClick
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.componentError */.t.componentError,
                    props.onError
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.stateChange */.t.stateChange,
                    props.onStateChange
                );
            }
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/debounce.js
            var debounce = __webpack_require__(7144); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/dimensions/useGridDimensions.js
            const isTestEnvironment = "production" === "test";

            const hasScroll = ({ content, container, scrollBarSize }) => {
                const hasScrollXIfNoYScrollBar =
                    content.width > container.width;
                const hasScrollYIfNoXScrollBar =
                    content.height > container.height;
                let hasScrollX = false;
                let hasScrollY = false;

                if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {
                    hasScrollX = hasScrollXIfNoYScrollBar;
                    hasScrollY =
                        content.height + (hasScrollX ? scrollBarSize : 0) >
                        container.height; // We recalculate the scroll x to consider the size of the y scrollbar.

                    if (hasScrollY) {
                        hasScrollX =
                            content.width + scrollBarSize > container.width;
                    }
                }

                return {
                    hasScrollX,
                    hasScrollY,
                };
            };

            function useGridDimensions(apiRef, props) {
                const logger = useGridLogger(apiRef, "useResizeContainer");
                const warningShown = react.useRef(false);
                const rootDimensionsRef = react.useRef(null);
                const fullDimensionsRef = react.useRef(null);
                const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
                const headerHeight = useGridSelector(
                    apiRef,
                    gridDensityHeaderHeightSelector
                );
                const updateGridDimensionsRef = react.useCallback(() => {
                    var _apiRef$current$rootE;

                    const rootElement =
                        (_apiRef$current$rootE =
                            apiRef.current.rootElementRef) == null
                            ? void 0
                            : _apiRef$current$rootE.current;
                    const columnsTotalWidth =
                        gridColumnsTotalWidthSelector(apiRef);

                    if (!rootDimensionsRef.current) {
                        return;
                    }

                    let scrollBarSize;

                    if (props.scrollbarSize != null) {
                        scrollBarSize = props.scrollbarSize;
                    } else if (!columnsTotalWidth || !rootElement) {
                        scrollBarSize = 0;
                    } else {
                        const doc = (0, utils_ownerDocument /* default */.Z)(
                            rootElement
                        );
                        const scrollDiv = doc.createElement("div");
                        scrollDiv.style.width = "99px";
                        scrollDiv.style.height = "99px";
                        scrollDiv.style.position = "absolute";
                        scrollDiv.style.overflow = "scroll";
                        scrollDiv.className = "scrollDiv";
                        rootElement.appendChild(scrollDiv);
                        scrollBarSize =
                            scrollDiv.offsetWidth - scrollDiv.clientWidth;
                        rootElement.removeChild(scrollDiv);
                    }

                    const viewportOuterSize = {
                        width: rootDimensionsRef.current.width,
                        height: props.autoHeight
                            ? rowsMeta.currentPageTotalHeight
                            : rootDimensionsRef.current.height - headerHeight,
                    };
                    const { hasScrollX, hasScrollY } = hasScroll({
                        content: {
                            width: Math.round(columnsTotalWidth),
                            height: rowsMeta.currentPageTotalHeight,
                        },
                        container: viewportOuterSize,
                        scrollBarSize,
                    });
                    const viewportInnerSize = {
                        width:
                            viewportOuterSize.width -
                            (hasScrollY ? scrollBarSize : 0),
                        height:
                            viewportOuterSize.height -
                            (hasScrollX ? scrollBarSize : 0),
                    };
                    const newFullDimensions = {
                        viewportOuterSize,
                        viewportInnerSize,
                        hasScrollX,
                        hasScrollY,
                    };
                    const prevDimensions = fullDimensionsRef.current;
                    fullDimensionsRef.current = newFullDimensions;

                    if (
                        newFullDimensions.viewportInnerSize.width !==
                            (prevDimensions == null
                                ? void 0
                                : prevDimensions.viewportInnerSize.width) ||
                        newFullDimensions.viewportInnerSize.height !==
                            (prevDimensions == null
                                ? void 0
                                : prevDimensions.viewportInnerSize.height)
                    ) {
                        apiRef.current.publishEvent(
                            gridEvents /* GridEvents.viewportInnerSizeChange */
                                .t.viewportInnerSizeChange,
                            newFullDimensions.viewportInnerSize
                        );
                    }
                }, [
                    apiRef,
                    props.scrollbarSize,
                    props.autoHeight,
                    headerHeight,
                    rowsMeta.currentPageTotalHeight,
                ]);
                const resize = react.useCallback(() => {
                    updateGridDimensionsRef();
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.debouncedResize */.t
                            .debouncedResize,
                        rootDimensionsRef.current
                    );
                }, [apiRef, updateGridDimensionsRef]);
                const getRootDimensions = react.useCallback(
                    () => fullDimensionsRef.current,
                    []
                );
                const getViewportPageSize = react.useCallback(() => {
                    const dimensions = apiRef.current.getRootDimensions();

                    if (!dimensions) {
                        return 0;
                    }

                    const currentPage = getVisibleRows(apiRef, {
                        pagination: props.pagination,
                        paginationMode: props.paginationMode,
                    }); // TODO: Use a combination of scrollTop, dimensions.viewportInnerSize.height and rowsMeta.possitions
                    // to find out the maximum number of rows that can fit in the visible part of the grid

                    if (props.getRowHeight) {
                        const renderContext =
                            apiRef.current.unstable_getRenderContext();
                        const viewportPageSize =
                            renderContext.lastRowIndex -
                            renderContext.firstRowIndex;
                        return Math.min(
                            viewportPageSize - 1,
                            currentPage.rows.length
                        );
                    }

                    const maximumPageSizeWithoutScrollBar = Math.floor(
                        dimensions.viewportInnerSize.height /
                            gridDensityRowHeightSelector(apiRef)
                    );
                    return Math.min(
                        maximumPageSizeWithoutScrollBar,
                        currentPage.rows.length
                    );
                }, [
                    apiRef,
                    props.pagination,
                    props.paginationMode,
                    props.getRowHeight,
                ]);
                const dimensionsApi = {
                    resize,
                    getRootDimensions,
                    unstable_getViewportPageSize: getViewportPageSize,
                    unstable_updateGridDimensionsRef: updateGridDimensionsRef,
                };
                useGridApiMethod(apiRef, dimensionsApi, "GridDimensionsApi");
                const debounceResize = react.useMemo(
                    () => (0, debounce /* default */.Z)(resize, 60),
                    [resize]
                );
                const isFirstSizing = react.useRef(true);
                const handleResize = react.useCallback(
                    (size) => {
                        rootDimensionsRef.current = size; // jsdom has no layout capabilities

                        const isJSDOM = /jsdom/.test(
                            window.navigator.userAgent
                        );

                        if (
                            size.height === 0 &&
                            !warningShown.current &&
                            !props.autoHeight &&
                            !isJSDOM
                        ) {
                            logger.warn(
                                [
                                    "The parent of the grid has an empty height.",
                                    "You need to make sure the container has an intrinsic height.",
                                    "The grid displays with a height of 0px.",
                                    "",
                                    "You can find a solution in the docs:",
                                    "https://mui.com/x/react-data-grid/layout/",
                                ].join("\n")
                            );
                            warningShown.current = true;
                        }

                        if (
                            size.width === 0 &&
                            !warningShown.current &&
                            !isJSDOM
                        ) {
                            logger.warn(
                                [
                                    "The parent of the grid has an empty width.",
                                    "You need to make sure the container has an intrinsic width.",
                                    "The grid displays with a width of 0px.",
                                    "",
                                    "You can find a solution in the docs:",
                                    "https://mui.com/x/react-data-grid/layout/",
                                ].join("\n")
                            );
                            warningShown.current = true;
                        }

                        if (isTestEnvironment) {
                            // We don't need to debounce the resize for tests.
                            resize();
                            isFirstSizing.current = false;
                            return;
                        }

                        if (isFirstSizing.current) {
                            // We want to initialize the grid dimensions as soon as possible to avoid flickering
                            resize();
                            isFirstSizing.current = false;
                            return;
                        }

                        debounceResize();
                    },
                    [props.autoHeight, debounceResize, logger, resize]
                );
                (0, useEnhancedEffect /* default */.Z)(
                    () => updateGridDimensionsRef(),
                    [updateGridDimensionsRef]
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.sortedRowsSet */.t.sortedRowsSet,
                    updateGridDimensionsRef
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.pageChange */.t.pageChange,
                    updateGridDimensionsRef
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.pageSizeChange */.t.pageSizeChange,
                    updateGridDimensionsRef
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnsChange */.t.columnsChange,
                    updateGridDimensionsRef
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.resize */.t.resize,
                    handleResize
                );
                useGridApiOptionHandler(
                    apiRef,
                    gridEvents /* GridEvents.debouncedResize */.t
                        .debouncedResize,
                    props.onResize
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowsMeta.js
            const rowsMetaStateInitializer = (state) =>
                (0, esm_extends /* default */.Z)({}, state, {
                    rowsMeta: {
                        currentPageTotalHeight: 0,
                        positions: [],
                    },
                });
            /**
             * @requires useGridPageSize (method)
             * @requires useGridPage (method)
             */

            const useGridRowsMeta = (apiRef, props) => {
                const { getRowHeight, getRowSpacing } = props;
                const rowsHeightLookup = react.useRef({});
                const rowHeight = useGridSelector(
                    apiRef,
                    gridDensityRowHeightSelector
                );
                const filterState = useGridSelector(
                    apiRef,
                    gridFilterStateSelector
                );
                const paginationState = useGridSelector(
                    apiRef,
                    gridPaginationSelector
                );
                const sortingState = useGridSelector(
                    apiRef,
                    gridSortingStateSelector
                );
                const currentPage = useGridVisibleRows(apiRef, props);
                const hydrateRowsMeta = react.useCallback(() => {
                    apiRef.current.setState((state) => {
                        const positions = [];
                        const densityFactor = gridDensityFactorSelector(
                            state,
                            apiRef.current.instanceId
                        );
                        const currentRowHeight = gridDensityRowHeightSelector(
                            state,
                            apiRef.current.instanceId
                        );
                        const currentPageTotalHeight = currentPage.rows.reduce(
                            (acc, row) => {
                                positions.push(acc);
                                let baseRowHeight;
                                const isResized =
                                    (rowsHeightLookup.current[row.id] &&
                                        rowsHeightLookup.current[row.id]
                                            .isResized) ||
                                    false;

                                if (isResized) {
                                    // do not recalculate resized row height and use the value from the lookup
                                    baseRowHeight =
                                        rowsHeightLookup.current[row.id].value;
                                } else {
                                    baseRowHeight = currentRowHeight;

                                    if (getRowHeight) {
                                        var _getRowHeight;

                                        // Default back to base rowHeight if getRowHeight returns null or undefined.
                                        baseRowHeight =
                                            (_getRowHeight = getRowHeight(
                                                (0,
                                                esm_extends /* default */.Z)(
                                                    {},
                                                    row,
                                                    {
                                                        densityFactor,
                                                    }
                                                )
                                            )) != null
                                                ? _getRowHeight
                                                : currentRowHeight;
                                    }
                                } // We use an object to make simple to check if a height is already added or not

                                const initialHeights = {
                                    base: baseRowHeight,
                                };

                                if (getRowSpacing) {
                                    var _spacing$top, _spacing$bottom;

                                    const indexRelativeToCurrentPage =
                                        apiRef.current.getRowIndexRelativeToVisibleRows(
                                            row.id
                                        );
                                    const spacing = getRowSpacing(
                                        (0, esm_extends /* default */.Z)(
                                            {},
                                            row,
                                            {
                                                isFirstVisible:
                                                    indexRelativeToCurrentPage ===
                                                    0,
                                                isLastVisible:
                                                    indexRelativeToCurrentPage ===
                                                    currentPage.rows.length - 1,
                                                indexRelativeToCurrentPage,
                                            }
                                        )
                                    );
                                    initialHeights.spacingTop =
                                        (_spacing$top = spacing.top) != null
                                            ? _spacing$top
                                            : 0;
                                    initialHeights.spacingBottom =
                                        (_spacing$bottom = spacing.bottom) !=
                                        null
                                            ? _spacing$bottom
                                            : 0;
                                }

                                const sizes =
                                    apiRef.current.unstable_applyPipeProcessors(
                                        "rowHeight",
                                        initialHeights,
                                        row
                                    );
                                const finalRowHeight = Object.values(
                                    sizes
                                ).reduce((acc2, value) => acc2 + value, 0);
                                rowsHeightLookup.current[row.id] = {
                                    value: baseRowHeight,
                                    sizes,
                                    isResized,
                                };
                                return acc + finalRowHeight;
                            },
                            0
                        );
                        return (0, esm_extends /* default */.Z)({}, state, {
                            rowsMeta: {
                                currentPageTotalHeight,
                                positions,
                            },
                        });
                    });
                    apiRef.current.forceUpdate();
                }, [apiRef, currentPage.rows, getRowSpacing, getRowHeight]);

                const getTargetRowHeight = (rowId) => {
                    var _rowsHeightLookup$cur;

                    return (
                        ((_rowsHeightLookup$cur =
                            rowsHeightLookup.current[rowId]) == null
                            ? void 0
                            : _rowsHeightLookup$cur.value) || rowHeight
                    );
                };

                const getRowInternalSizes = (rowId) => {
                    var _rowsHeightLookup$cur2;

                    return (_rowsHeightLookup$cur2 =
                        rowsHeightLookup.current[rowId]) == null
                        ? void 0
                        : _rowsHeightLookup$cur2.sizes;
                };

                const setRowHeight = react.useCallback(
                    (id, height) => {
                        rowsHeightLookup.current[id] = {
                            value: height,
                            isResized: true,
                            sizes: (0, esm_extends /* default */.Z)(
                                {},
                                rowsHeightLookup.current[id].sizes,
                                {
                                    base: height,
                                }
                            ),
                        };
                        hydrateRowsMeta();
                    },
                    [hydrateRowsMeta]
                ); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.
                // Because of variable row height this is needed for the virtualization

                react.useEffect(() => {
                    hydrateRowsMeta();
                }, [
                    rowHeight,
                    filterState,
                    paginationState,
                    sortingState,
                    hydrateRowsMeta,
                ]);
                useGridRegisterPipeApplier(
                    apiRef,
                    "rowHeight",
                    hydrateRowsMeta
                );
                const rowsMetaApi = {
                    unstable_getRowHeight: getTargetRowHeight,
                    unstable_getRowInternalSizes: getRowInternalSizes,
                    unstable_setRowHeight: setRowHeight,
                };
                useGridApiMethod(apiRef, rowsMetaApi, "GridRowsMetaApi");
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/statePersistence/useGridStatePersistence.js
            const useGridStatePersistence = (apiRef) => {
                const exportState = react.useCallback(() => {
                    const stateToExport =
                        apiRef.current.unstable_applyPipeProcessors(
                            "exportState",
                            {}
                        );
                    return stateToExport;
                }, [apiRef]);
                const restoreState = react.useCallback(
                    (stateToRestore) => {
                        const response =
                            apiRef.current.unstable_applyPipeProcessors(
                                "restoreState",
                                {
                                    callbacks: [],
                                },
                                {
                                    stateToRestore,
                                }
                            );
                        response.callbacks.forEach((callback) => {
                            callback();
                        });
                        apiRef.current.forceUpdate();
                    },
                    [apiRef]
                );
                const statePersistenceApi = {
                    exportState,
                    restoreState,
                };
                useGridApiMethod(
                    apiRef,
                    statePersistenceApi,
                    "GridStatePersistenceApi"
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/columns/useGridColumnSpanning.js
            /**
             * @requires useGridColumns (method, event)
             * @requires useGridParamsApi (method)
             */
            const useGridColumnSpanning = (apiRef) => {
                const lookup = react.useRef({});
                const setCellColSpanInfo = react.useCallback(
                    (rowId, columnIndex, cellColSpanInfo) => {
                        const sizes = lookup.current;

                        if (!sizes[rowId]) {
                            sizes[rowId] = {};
                        }

                        sizes[rowId][columnIndex] = cellColSpanInfo;
                    },
                    []
                );
                const getCellColSpanInfo = react.useCallback(
                    (rowId, columnIndex) => {
                        var _lookup$current$rowId;

                        return (_lookup$current$rowId =
                            lookup.current[rowId]) == null
                            ? void 0
                            : _lookup$current$rowId[columnIndex];
                    },
                    []
                ); // Calculate `colSpan` for the cell.

                const calculateCellColSpan = react.useCallback(
                    (params) => {
                        const {
                            columnIndex,
                            rowId,
                            minFirstColumnIndex,
                            maxLastColumnIndex,
                        } = params;
                        const visibleColumns =
                            apiRef.current.getVisibleColumns();
                        const columnsLength = visibleColumns.length;
                        const column = visibleColumns[columnIndex];
                        const colSpan =
                            typeof column.colSpan === "function"
                                ? column.colSpan(
                                      apiRef.current.getCellParams(
                                          rowId,
                                          column.field
                                      )
                                  )
                                : column.colSpan;

                        if (!colSpan || colSpan === 1) {
                            setCellColSpanInfo(rowId, columnIndex, {
                                spannedByColSpan: false,
                                cellProps: {
                                    colSpan: 1,
                                    width: column.computedWidth,
                                },
                            });
                            return {
                                colSpan: 1,
                            };
                        }

                        let width = column.computedWidth;

                        for (let j = 1; j < colSpan; j += 1) {
                            const nextColumnIndex = columnIndex + j; // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).

                            if (
                                nextColumnIndex >= minFirstColumnIndex &&
                                nextColumnIndex < maxLastColumnIndex
                            ) {
                                const nextColumn =
                                    visibleColumns[nextColumnIndex];
                                width += nextColumn.computedWidth;
                                setCellColSpanInfo(rowId, columnIndex + j, {
                                    spannedByColSpan: true,
                                    rightVisibleCellIndex: Math.min(
                                        columnIndex + colSpan,
                                        columnsLength - 1
                                    ),
                                    leftVisibleCellIndex: columnIndex,
                                });
                            }

                            setCellColSpanInfo(rowId, columnIndex, {
                                spannedByColSpan: false,
                                cellProps: {
                                    colSpan,
                                    width,
                                },
                            });
                        }

                        return {
                            colSpan,
                        };
                    },
                    [apiRef, setCellColSpanInfo]
                ); // Calculate `colSpan` for each cell in the row

                const calculateColSpan = react.useCallback(
                    ({ rowId, minFirstColumn, maxLastColumn }) => {
                        for (
                            let i = minFirstColumn;
                            i < maxLastColumn;
                            i += 1
                        ) {
                            const cellProps = calculateCellColSpan({
                                columnIndex: i,
                                rowId,
                                minFirstColumnIndex: minFirstColumn,
                                maxLastColumnIndex: maxLastColumn,
                            });

                            if (cellProps.colSpan > 1) {
                                i += cellProps.colSpan - 1;
                            }
                        }
                    },
                    [calculateCellColSpan]
                );
                const columnSpanningApi = {
                    unstable_getCellColSpanInfo: getCellColSpanInfo,
                    unstable_calculateColSpan: calculateColSpan,
                };
                useGridApiMethod(
                    apiRef,
                    columnSpanningApi,
                    "GridColumnSpanningAPI"
                );
                const handleColumnReorderChange = react.useCallback(() => {
                    // `colSpan` needs to be recalculated after column reordering
                    lookup.current = {};
                }, []);
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnOrderChange */.t
                        .columnOrderChange,
                    handleColumnReorderChange
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/DataGrid/useDataGridComponent.js
            const useDataGridComponent = (props) => {
                var _props$experimentalFe, _props$experimentalFe2;

                const apiRef = useGridInitialization(undefined, props);
                /**
                 * Register all pre-processors called during state initialization here.
                 */

                useGridSelectionPreProcessors(apiRef, props);
                useGridRowsPreProcessors(apiRef);
                /**
                 * Register all state initializers here.
                 */

                useGridInitializeState(
                    selectionStateInitializer,
                    apiRef,
                    props
                );
                useGridInitializeState(columnsStateInitializer, apiRef, props);
                useGridInitializeState(rowsStateInitializer, apiRef, props);
                useGridInitializeState(
                    (_props$experimentalFe = props.experimentalFeatures) !=
                        null && _props$experimentalFe.newEditingApi
                        ? useGridEditing_new_editingStateInitializer
                        : editingStateInitializer,
                    apiRef,
                    props
                );
                useGridInitializeState(focusStateInitializer, apiRef, props);
                useGridInitializeState(sortingStateInitializer, apiRef, props);
                useGridInitializeState(
                    preferencePanelStateInitializer,
                    apiRef,
                    props
                );
                useGridInitializeState(filterStateInitializer, apiRef, props);
                useGridInitializeState(densityStateInitializer, apiRef, props);
                useGridInitializeState(
                    paginationStateInitializer,
                    apiRef,
                    props
                );
                useGridInitializeState(rowsMetaStateInitializer, apiRef, props);
                useGridInitializeState(
                    columnMenuStateInitializer,
                    apiRef,
                    props
                );
                useGridKeyboardNavigation(apiRef, props);
                useGridSelection(apiRef, props);
                useGridColumns(apiRef, props);
                useGridRows(apiRef, props);
                useGridParamsApi(apiRef);
                useGridColumnSpanning(apiRef);
                const useGridEditing =
                    (_props$experimentalFe2 = props.experimentalFeatures) !=
                        null && _props$experimentalFe2.newEditingApi
                        ? useGridEditing_new_useGridEditing
                        : useGridEditing_old_useGridEditing;
                useGridEditing(apiRef, props);
                useGridFocus(apiRef, props);
                useGridPreferencesPanel(apiRef);
                useGridFilter(apiRef, props);
                useGridSorting(apiRef, props);
                useGridDensity(apiRef, props);
                useGridPagination(apiRef, props);
                useGridRowsMeta(apiRef, props);
                useGridScroll(apiRef, props);
                useGridColumnMenu(apiRef);
                useGridCsvExport(apiRef);
                useGridPrintExport(apiRef, props);
                useGridClipboard(apiRef);
                useGridDimensions(apiRef, props);
                useGridEvents(apiRef, props);
                useGridStatePersistence(apiRef);
                return apiRef;
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/constants/localeTextConstants.js
            const GRID_DEFAULT_LOCALE_TEXT = {
                // Root
                noRowsLabel: "No rows",
                noResultsOverlayLabel: "No results found.",
                errorOverlayDefaultLabel: "An error occurred.",
                // Density selector toolbar button text
                toolbarDensity: "Density",
                toolbarDensityLabel: "Density",
                toolbarDensityCompact: "Compact",
                toolbarDensityStandard: "Standard",
                toolbarDensityComfortable: "Comfortable",
                // Columns selector toolbar button text
                toolbarColumns: "Columns",
                toolbarColumnsLabel: "Select columns",
                // Filters toolbar button text
                toolbarFilters: "Filters",
                toolbarFiltersLabel: "Show filters",
                toolbarFiltersTooltipHide: "Hide filters",
                toolbarFiltersTooltipShow: "Show filters",
                toolbarFiltersTooltipActive: (count) =>
                    count !== 1
                        ? `${count} active filters`
                        : `${count} active filter`,
                // Export selector toolbar button text
                toolbarExport: "Export",
                toolbarExportLabel: "Export",
                toolbarExportCSV: "Download as CSV",
                toolbarExportPrint: "Print",
                // Columns panel text
                columnsPanelTextFieldLabel: "Find column",
                columnsPanelTextFieldPlaceholder: "Column title",
                columnsPanelDragIconLabel: "Reorder column",
                columnsPanelShowAllButton: "Show all",
                columnsPanelHideAllButton: "Hide all",
                // Filter panel text
                filterPanelAddFilter: "Add filter",
                filterPanelDeleteIconLabel: "Delete",
                filterPanelLinkOperator: "Logic operator",
                filterPanelOperators: "Operator",
                // TODO v6: rename to filterPanelOperator
                filterPanelOperatorAnd: "And",
                filterPanelOperatorOr: "Or",
                filterPanelColumns: "Columns",
                filterPanelInputLabel: "Value",
                filterPanelInputPlaceholder: "Filter value",
                // Filter operators text
                filterOperatorContains: "contains",
                filterOperatorEquals: "equals",
                filterOperatorStartsWith: "starts with",
                filterOperatorEndsWith: "ends with",
                filterOperatorIs: "is",
                filterOperatorNot: "is not",
                filterOperatorAfter: "is after",
                filterOperatorOnOrAfter: "is on or after",
                filterOperatorBefore: "is before",
                filterOperatorOnOrBefore: "is on or before",
                filterOperatorIsEmpty: "is empty",
                filterOperatorIsNotEmpty: "is not empty",
                filterOperatorIsAnyOf: "is any of",
                // Filter values text
                filterValueAny: "any",
                filterValueTrue: "true",
                filterValueFalse: "false",
                // Column menu text
                columnMenuLabel: "Menu",
                columnMenuShowColumns: "Show columns",
                columnMenuFilter: "Filter",
                columnMenuHideColumn: "Hide",
                columnMenuUnsort: "Unsort",
                columnMenuSortAsc: "Sort by ASC",
                columnMenuSortDesc: "Sort by DESC",
                // Column header text
                columnHeaderFiltersTooltipActive: (count) =>
                    count !== 1
                        ? `${count} active filters`
                        : `${count} active filter`,
                columnHeaderFiltersLabel: "Show filters",
                columnHeaderSortIconLabel: "Sort",
                // Rows selected footer text
                footerRowSelected: (count) =>
                    count !== 1
                        ? `${count.toLocaleString()} rows selected`
                        : `${count.toLocaleString()} row selected`,
                // Total row amount footer text
                footerTotalRows: "Total Rows:",
                // Total visible row amount footer text
                footerTotalVisibleRows: (visibleCount, totalCount) =>
                    `${visibleCount.toLocaleString()} of ${totalCount.toLocaleString()}`,
                // Checkbox selection text
                checkboxSelectionHeaderName: "Checkbox selection",
                checkboxSelectionSelectAllRows: "Select all rows",
                checkboxSelectionUnselectAllRows: "Unselect all rows",
                checkboxSelectionSelectRow: "Select row",
                checkboxSelectionUnselectRow: "Unselect row",
                // Boolean cell text
                booleanCellTrueLabel: "yes",
                booleanCellFalseLabel: "no",
                // Actions cell more text
                actionsCellMore: "more",
                // Column pinning text
                pinToLeft: "Pin to left",
                pinToRight: "Pin to right",
                unpin: "Unpin",
                // Tree Data
                treeDataGroupingHeaderName: "Group",
                treeDataExpand: "see children",
                treeDataCollapse: "hide children",
                // Grouping columns
                groupingColumnHeaderName: "Group",
                groupColumn: (name) => `Group by ${name}`,
                unGroupColumn: (name) => `Stop grouping by ${name}`,
                // Master/detail
                expandDetailPanel: "Expand",
                collapseDetailPanel: "Collapse",
                // Used core components translation keys
                MuiTablePagination: {},
                // Row reordering text
                rowReorderingHeaderName: "Row reordering",
            };
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/useControlled.js
            var useControlled = __webpack_require__(9299);
            // EXTERNAL MODULE: ./node_modules/@mui/material/ButtonBase/ButtonBase.js + 7 modules
            var ButtonBase = __webpack_require__(7739); // CONCATENATED MODULE: ./node_modules/@mui/material/internal/switchBaseClasses.js
            function getSwitchBaseUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "PrivateSwitchBase",
                    slot
                );
            }
            const switchBaseClasses = (0,
            generateUtilityClasses /* default */.Z)("PrivateSwitchBase", [
                "root",
                "checked",
                "disabled",
                "input",
                "edgeStart",
                "edgeEnd",
            ]);
            /* harmony default export */ var internal_switchBaseClasses =
                /* unused pure expression or super */ null && switchBaseClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/internal/SwitchBase.js
            const SwitchBase_excluded = [
                "autoFocus",
                "checked",
                "checkedIcon",
                "className",
                "defaultChecked",
                "disabled",
                "disableFocusRipple",
                "edge",
                "icon",
                "id",
                "inputProps",
                "inputRef",
                "name",
                "onBlur",
                "onChange",
                "onFocus",
                "readOnly",
                "required",
                "tabIndex",
                "type",
                "value",
            ];

            const SwitchBase_useUtilityClasses = (ownerState) => {
                const { classes, checked, disabled, edge } = ownerState;
                const slots = {
                    root: [
                        "root",
                        checked && "checked",
                        disabled && "disabled",
                        edge && `edge${(0, capitalize /* default */.Z)(edge)}`,
                    ],
                    input: ["input"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getSwitchBaseUtilityClass,
                    classes
                );
            };

            const SwitchBaseRoot = (0, styled /* default */.ZP)(
                ButtonBase /* default */.Z
            )(({ ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        padding: 9,
                        borderRadius: "50%",
                    },
                    ownerState.edge === "start" && {
                        marginLeft: ownerState.size === "small" ? -3 : -12,
                    },
                    ownerState.edge === "end" && {
                        marginRight: ownerState.size === "small" ? -3 : -12,
                    }
                )
            );
            const SwitchBaseInput = (0, styled /* default */.ZP)("input")({
                cursor: "inherit",
                position: "absolute",
                opacity: 0,
                width: "100%",
                height: "100%",
                top: 0,
                left: 0,
                margin: 0,
                padding: 0,
                zIndex: 1,
            });
            /**
             * @ignore - internal component.
             */

            const SwitchBase = /*#__PURE__*/ react.forwardRef(
                function SwitchBase(props, ref) {
                    const {
                            autoFocus,
                            checked: checkedProp,
                            checkedIcon,
                            className,
                            defaultChecked,
                            disabled: disabledProp,
                            disableFocusRipple = false,
                            edge = false,
                            icon,
                            id,
                            inputProps,
                            inputRef,
                            name,
                            onBlur,
                            onChange,
                            onFocus,
                            readOnly,
                            required,
                            tabIndex,
                            type,
                            value,
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            SwitchBase_excluded
                        );

                    const [checked, setCheckedState] = (0,
                    useControlled /* default */.Z)({
                        controlled: checkedProp,
                        default: Boolean(defaultChecked),
                        name: "SwitchBase",
                        state: "checked",
                    });
                    const muiFormControl = (0,
                    useFormControl /* default */.Z)();

                    const handleFocus = (event) => {
                        if (onFocus) {
                            onFocus(event);
                        }

                        if (muiFormControl && muiFormControl.onFocus) {
                            muiFormControl.onFocus(event);
                        }
                    };

                    const handleBlur = (event) => {
                        if (onBlur) {
                            onBlur(event);
                        }

                        if (muiFormControl && muiFormControl.onBlur) {
                            muiFormControl.onBlur(event);
                        }
                    };

                    const handleInputChange = (event) => {
                        // Workaround for https://github.com/facebook/react/issues/9023
                        if (event.nativeEvent.defaultPrevented) {
                            return;
                        }

                        const newChecked = event.target.checked;
                        setCheckedState(newChecked);

                        if (onChange) {
                            // TODO v6: remove the second argument.
                            onChange(event, newChecked);
                        }
                    };

                    let disabled = disabledProp;

                    if (muiFormControl) {
                        if (typeof disabled === "undefined") {
                            disabled = muiFormControl.disabled;
                        }
                    }

                    const hasLabelFor = type === "checkbox" || type === "radio";

                    const ownerState = (0, esm_extends /* default */.Z)(
                        {},
                        props,
                        {
                            checked,
                            disabled,
                            disableFocusRipple,
                            edge,
                        }
                    );

                    const classes = SwitchBase_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        SwitchBaseRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                component: "span",
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                                centerRipple: true,
                                focusRipple: !disableFocusRipple,
                                disabled: disabled,
                                tabIndex: null,
                                role: undefined,
                                onFocus: handleFocus,
                                onBlur: handleBlur,
                                ownerState: ownerState,
                                ref: ref,
                            },
                            other,
                            {
                                children: [
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        SwitchBaseInput,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                autoFocus: autoFocus,
                                                checked: checkedProp,
                                                defaultChecked: defaultChecked,
                                                className: classes.input,
                                                disabled: disabled,
                                                id: hasLabelFor && id,
                                                name: name,
                                                onChange: handleInputChange,
                                                readOnly: readOnly,
                                                ref: inputRef,
                                                required: required,
                                                ownerState: ownerState,
                                                tabIndex: tabIndex,
                                                type: type,
                                            },
                                            type === "checkbox" &&
                                                value === undefined
                                                ? {}
                                                : {
                                                      value,
                                                  },
                                            inputProps
                                        )
                                    ),
                                    checked ? checkedIcon : icon,
                                ],
                            }
                        )
                    );
                }
            ); // NB: If changed, please update Checkbox, Switch and Radio
            // so that the API documentation is updated.

            false ? 0 : void 0;
            /* harmony default export */ var internal_SwitchBase = SwitchBase; // CONCATENATED MODULE: ./node_modules/@mui/material/internal/svg-icons/CheckBoxOutlineBlank.js
            /**
             * @ignore - internal component.
             */

            /* harmony default export */ var CheckBoxOutlineBlank = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z",
                }),
                "CheckBoxOutlineBlank"
            ); // CONCATENATED MODULE: ./node_modules/@mui/material/internal/svg-icons/CheckBox.js
            /**
             * @ignore - internal component.
             */

            /* harmony default export */ var CheckBox = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z",
                }),
                "CheckBox"
            ); // CONCATENATED MODULE: ./node_modules/@mui/material/internal/svg-icons/IndeterminateCheckBox.js
            /**
             * @ignore - internal component.
             */

            /* harmony default export */ var IndeterminateCheckBox = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z",
                }),
                "IndeterminateCheckBox"
            ); // CONCATENATED MODULE: ./node_modules/@mui/material/Checkbox/checkboxClasses.js
            function getCheckboxUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiCheckbox",
                    slot
                );
            }
            const checkboxClasses = (0, generateUtilityClasses /* default */.Z)(
                "MuiCheckbox",
                [
                    "root",
                    "checked",
                    "disabled",
                    "indeterminate",
                    "colorPrimary",
                    "colorSecondary",
                ]
            );
            /* harmony default export */ var Checkbox_checkboxClasses =
                checkboxClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/Checkbox/Checkbox.js
            const Checkbox_excluded = [
                "checkedIcon",
                "color",
                "icon",
                "indeterminate",
                "indeterminateIcon",
                "inputProps",
                "size",
            ];

            const Checkbox_useUtilityClasses = (ownerState) => {
                const { classes, indeterminate, color } = ownerState;
                const slots = {
                    root: [
                        "root",
                        indeterminate && "indeterminate",
                        `color${(0, capitalize /* default */.Z)(color)}`,
                    ],
                };
                const composedClasses = (0, composeClasses /* default */.Z)(
                    slots,
                    getCheckboxUtilityClass,
                    classes
                );
                return (0, esm_extends /* default */.Z)(
                    {},
                    classes,
                    composedClasses
                );
            };

            const CheckboxRoot = (0, styled /* default */.ZP)(
                internal_SwitchBase,
                {
                    shouldForwardProp: (prop) =>
                        (0, styled /* rootShouldForwardProp */.FO)(prop) ||
                        prop === "classes",
                    name: "MuiCheckbox",
                    slot: "Root",
                    overridesResolver: (props, styles) => {
                        const { ownerState } = props;
                        return [
                            styles.root,
                            ownerState.indeterminate && styles.indeterminate,
                            ownerState.color !== "default" &&
                                styles[
                                    `color${(0, capitalize /* default */.Z)(
                                        ownerState.color
                                    )}`
                                ],
                        ];
                    },
                }
            )(({ theme, ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        color: theme.palette.text.secondary,
                    },
                    !ownerState.disableRipple && {
                        "&:hover": {
                            backgroundColor: (0,
                            colorManipulator /* alpha */.Fq)(
                                ownerState.color === "default"
                                    ? theme.palette.action.active
                                    : theme.palette[ownerState.color].main,
                                theme.palette.action.hoverOpacity
                            ),
                            // Reset on touch devices, it doesn't add specificity
                            "@media (hover: none)": {
                                backgroundColor: "transparent",
                            },
                        },
                    },
                    ownerState.color !== "default" && {
                        [`&.${Checkbox_checkboxClasses.checked}, &.${Checkbox_checkboxClasses.indeterminate}`]:
                            {
                                color: theme.palette[ownerState.color].main,
                            },
                        [`&.${Checkbox_checkboxClasses.disabled}`]: {
                            color: theme.palette.action.disabled,
                        },
                    }
                )
            );

            const defaultCheckedIcon = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                CheckBox,
                {}
            );

            const defaultIcon = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                CheckBoxOutlineBlank,
                {}
            );

            const defaultIndeterminateIcon = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                IndeterminateCheckBox,
                {}
            );

            const Checkbox = /*#__PURE__*/ react.forwardRef(function Checkbox(
                inProps,
                ref
            ) {
                var _icon$props$fontSize, _indeterminateIcon$pr;

                const props = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiCheckbox",
                });

                const {
                        checkedIcon = defaultCheckedIcon,
                        color = "primary",
                        icon: iconProp = defaultIcon,
                        indeterminate = false,
                        indeterminateIcon:
                            indeterminateIconProp = defaultIndeterminateIcon,
                        inputProps,
                        size = "medium",
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        Checkbox_excluded
                    );

                const icon = indeterminate ? indeterminateIconProp : iconProp;
                const indeterminateIcon = indeterminate
                    ? indeterminateIconProp
                    : checkedIcon;

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    color,
                    indeterminate,
                    size,
                });

                const classes = Checkbox_useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    CheckboxRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            type: "checkbox",
                            inputProps: (0, esm_extends /* default */.Z)(
                                {
                                    "data-indeterminate": indeterminate,
                                },
                                inputProps
                            ),
                            icon: /*#__PURE__*/ react.cloneElement(icon, {
                                fontSize:
                                    (_icon$props$fontSize =
                                        icon.props.fontSize) != null
                                        ? _icon$props$fontSize
                                        : size,
                            }),
                            checkedIcon: /*#__PURE__*/ react.cloneElement(
                                indeterminateIcon,
                                {
                                    fontSize:
                                        (_indeterminateIcon$pr =
                                            indeterminateIcon.props.fontSize) !=
                                        null
                                            ? _indeterminateIcon$pr
                                            : size,
                                }
                            ),
                            ownerState: ownerState,
                            ref: ref,
                        },
                        other,
                        {
                            classes: classes,
                        }
                    )
                );
            });
            false ? 0 : void 0;
            /* harmony default export */ var Checkbox_Checkbox = Checkbox; // CONCATENATED MODULE: ./node_modules/@mui/material/Switch/switchClasses.js
            function getSwitchUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiSwitch",
                    slot
                );
            }
            const switchClasses = (0, generateUtilityClasses /* default */.Z)(
                "MuiSwitch",
                [
                    "root",
                    "edgeStart",
                    "edgeEnd",
                    "switchBase",
                    "colorPrimary",
                    "colorSecondary",
                    "sizeSmall",
                    "sizeMedium",
                    "checked",
                    "disabled",
                    "input",
                    "thumb",
                    "track",
                ]
            );
            /* harmony default export */ var Switch_switchClasses =
                switchClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/Switch/Switch.js
            const Switch_excluded = [
                "className",
                "color",
                "edge",
                "size",
                "sx",
            ];
            // @inheritedComponent IconButton

            const Switch_useUtilityClasses = (ownerState) => {
                const { classes, edge, size, color, checked, disabled } =
                    ownerState;
                const slots = {
                    root: [
                        "root",
                        edge && `edge${(0, capitalize /* default */.Z)(edge)}`,
                        `size${(0, capitalize /* default */.Z)(size)}`,
                    ],
                    switchBase: [
                        "switchBase",
                        `color${(0, capitalize /* default */.Z)(color)}`,
                        checked && "checked",
                        disabled && "disabled",
                    ],
                    thumb: ["thumb"],
                    track: ["track"],
                    input: ["input"],
                };
                const composedClasses = (0, composeClasses /* default */.Z)(
                    slots,
                    getSwitchUtilityClass,
                    classes
                );
                return (0, esm_extends /* default */.Z)(
                    {},
                    classes,
                    composedClasses
                );
            };

            const SwitchRoot = (0, styled /* default */.ZP)("span", {
                name: "MuiSwitch",
                slot: "Root",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.root,
                        ownerState.edge &&
                            styles[
                                `edge${(0, capitalize /* default */.Z)(
                                    ownerState.edge
                                )}`
                            ],
                        styles[
                            `size${(0, capitalize /* default */.Z)(
                                ownerState.size
                            )}`
                        ],
                    ];
                },
            })(({ ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        display: "inline-flex",
                        width: 34 + 12 * 2,
                        height: 14 + 12 * 2,
                        overflow: "hidden",
                        padding: 12,
                        boxSizing: "border-box",
                        position: "relative",
                        flexShrink: 0,
                        zIndex: 0,
                        // Reset the stacking context.
                        verticalAlign: "middle",
                        // For correct alignment with the text.
                        "@media print": {
                            colorAdjust: "exact",
                        },
                    },
                    ownerState.edge === "start" && {
                        marginLeft: -8,
                    },
                    ownerState.edge === "end" && {
                        marginRight: -8,
                    },
                    ownerState.size === "small" && {
                        width: 40,
                        height: 24,
                        padding: 7,
                        [`& .${Switch_switchClasses.thumb}`]: {
                            width: 16,
                            height: 16,
                        },
                        [`& .${Switch_switchClasses.switchBase}`]: {
                            padding: 4,
                            [`&.${Switch_switchClasses.checked}`]: {
                                transform: "translateX(16px)",
                            },
                        },
                    }
                )
            );
            const SwitchSwitchBase = (0, styled /* default */.ZP)(
                internal_SwitchBase,
                {
                    name: "MuiSwitch",
                    slot: "SwitchBase",
                    overridesResolver: (props, styles) => {
                        const { ownerState } = props;
                        return [
                            styles.switchBase,
                            {
                                [`& .${Switch_switchClasses.input}`]:
                                    styles.input,
                            },
                            ownerState.color !== "default" &&
                                styles[
                                    `color${(0, capitalize /* default */.Z)(
                                        ownerState.color
                                    )}`
                                ],
                        ];
                    },
                }
            )(
                ({ theme }) => ({
                    position: "absolute",
                    top: 0,
                    left: 0,
                    zIndex: 1,
                    // Render above the focus ripple.
                    color:
                        theme.palette.mode === "light"
                            ? theme.palette.common.white
                            : theme.palette.grey[300],
                    transition: theme.transitions.create(
                        ["left", "transform"],
                        {
                            duration: theme.transitions.duration.shortest,
                        }
                    ),
                    [`&.${Switch_switchClasses.checked}`]: {
                        transform: "translateX(20px)",
                    },
                    [`&.${Switch_switchClasses.disabled}`]: {
                        color:
                            theme.palette.mode === "light"
                                ? theme.palette.grey[100]
                                : theme.palette.grey[600],
                    },
                    [`&.${Switch_switchClasses.checked} + .${Switch_switchClasses.track}`]:
                        {
                            opacity: 0.5,
                        },
                    [`&.${Switch_switchClasses.disabled} + .${Switch_switchClasses.track}`]:
                        {
                            opacity:
                                theme.palette.mode === "light" ? 0.12 : 0.2,
                        },
                    [`& .${Switch_switchClasses.input}`]: {
                        left: "-100%",
                        width: "300%",
                    },
                }),
                ({ theme, ownerState }) =>
                    (0, esm_extends /* default */.Z)(
                        {
                            "&:hover": {
                                backgroundColor: (0,
                                colorManipulator /* alpha */.Fq)(
                                    theme.palette.action.active,
                                    theme.palette.action.hoverOpacity
                                ),
                                // Reset on touch devices, it doesn't add specificity
                                "@media (hover: none)": {
                                    backgroundColor: "transparent",
                                },
                            },
                        },
                        ownerState.color !== "default" && {
                            [`&.${Switch_switchClasses.checked}`]: {
                                color: theme.palette[ownerState.color].main,
                                "&:hover": {
                                    backgroundColor: (0,
                                    colorManipulator /* alpha */.Fq)(
                                        theme.palette[ownerState.color].main,
                                        theme.palette.action.hoverOpacity
                                    ),
                                    "@media (hover: none)": {
                                        backgroundColor: "transparent",
                                    },
                                },
                                [`&.${Switch_switchClasses.disabled}`]: {
                                    color:
                                        theme.palette.mode === "light"
                                            ? (0,
                                              colorManipulator /* lighten */.$n)(
                                                  theme.palette[
                                                      ownerState.color
                                                  ].main,
                                                  0.62
                                              )
                                            : (0,
                                              colorManipulator /* darken */._j)(
                                                  theme.palette[
                                                      ownerState.color
                                                  ].main,
                                                  0.55
                                              ),
                                },
                            },
                            [`&.${Switch_switchClasses.checked} + .${Switch_switchClasses.track}`]:
                                {
                                    backgroundColor:
                                        theme.palette[ownerState.color].main,
                                },
                        }
                    )
            );
            const SwitchTrack = (0, styled /* default */.ZP)("span", {
                name: "MuiSwitch",
                slot: "Track",
                overridesResolver: (props, styles) => styles.track,
            })(({ theme }) => ({
                height: "100%",
                width: "100%",
                borderRadius: 14 / 2,
                zIndex: -1,
                transition: theme.transitions.create(
                    ["opacity", "background-color"],
                    {
                        duration: theme.transitions.duration.shortest,
                    }
                ),
                backgroundColor:
                    theme.palette.mode === "light"
                        ? theme.palette.common.black
                        : theme.palette.common.white,
                opacity: theme.palette.mode === "light" ? 0.38 : 0.3,
            }));
            const SwitchThumb = (0, styled /* default */.ZP)("span", {
                name: "MuiSwitch",
                slot: "Thumb",
                overridesResolver: (props, styles) => styles.thumb,
            })(({ theme }) => ({
                boxShadow: theme.shadows[1],
                backgroundColor: "currentColor",
                width: 20,
                height: 20,
                borderRadius: "50%",
            }));
            const Switch = /*#__PURE__*/ react.forwardRef(function Switch(
                inProps,
                ref
            ) {
                const props = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiSwitch",
                });

                const {
                        className,
                        color = "primary",
                        edge = false,
                        size = "medium",
                        sx,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        Switch_excluded
                    );

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    color,
                    edge,
                    size,
                });

                const classes = Switch_useUtilityClasses(ownerState);

                const icon = /*#__PURE__*/ (0, jsx_runtime.jsx)(SwitchThumb, {
                    className: classes.thumb,
                    ownerState: ownerState,
                });

                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(SwitchRoot, {
                    className: (0, clsx_m /* default */.Z)(
                        classes.root,
                        className
                    ),
                    sx: sx,
                    ownerState: ownerState,
                    children: [
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            SwitchSwitchBase,
                            (0, esm_extends /* default */.Z)(
                                {
                                    type: "checkbox",
                                    icon: icon,
                                    checkedIcon: icon,
                                    ref: ref,
                                    ownerState: ownerState,
                                },
                                other,
                                {
                                    classes: (0, esm_extends /* default */.Z)(
                                        {},
                                        classes,
                                        {
                                            root: classes.switchBase,
                                        }
                                    ),
                                }
                            )
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(SwitchTrack, {
                            className: classes.track,
                            ownerState: ownerState,
                        }),
                    ],
                });
            });
            false ? 0 : void 0;
            /* harmony default export */ var Switch_Switch = Switch;
            // EXTERNAL MODULE: ./node_modules/@mui/utils/esm/resolveProps.js
            var resolveProps = __webpack_require__(7925); // CONCATENATED MODULE: ./node_modules/@mui/material/Button/buttonClasses.js
            function getButtonUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiButton",
                    slot
                );
            }
            const buttonClasses = (0, generateUtilityClasses /* default */.Z)(
                "MuiButton",
                [
                    "root",
                    "text",
                    "textInherit",
                    "textPrimary",
                    "textSecondary",
                    "outlined",
                    "outlinedInherit",
                    "outlinedPrimary",
                    "outlinedSecondary",
                    "contained",
                    "containedInherit",
                    "containedPrimary",
                    "containedSecondary",
                    "disableElevation",
                    "focusVisible",
                    "disabled",
                    "colorInherit",
                    "textSizeSmall",
                    "textSizeMedium",
                    "textSizeLarge",
                    "outlinedSizeSmall",
                    "outlinedSizeMedium",
                    "outlinedSizeLarge",
                    "containedSizeSmall",
                    "containedSizeMedium",
                    "containedSizeLarge",
                    "sizeMedium",
                    "sizeSmall",
                    "sizeLarge",
                    "fullWidth",
                    "startIcon",
                    "endIcon",
                    "iconSizeSmall",
                    "iconSizeMedium",
                    "iconSizeLarge",
                ]
            );
            /* harmony default export */ var Button_buttonClasses =
                buttonClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/ButtonGroup/ButtonGroupContext.js
            /**
             * @ignore - internal component.
             */
            const ButtonGroupContext = /*#__PURE__*/ react.createContext({});

            if (false) {
            }

            /* harmony default export */ var ButtonGroup_ButtonGroupContext =
                ButtonGroupContext; // CONCATENATED MODULE: ./node_modules/@mui/material/Button/Button.js
            const Button_excluded = [
                "children",
                "color",
                "component",
                "className",
                "disabled",
                "disableElevation",
                "disableFocusRipple",
                "endIcon",
                "focusVisibleClassName",
                "fullWidth",
                "size",
                "startIcon",
                "type",
                "variant",
            ];

            const Button_useUtilityClasses = (ownerState) => {
                const {
                    color,
                    disableElevation,
                    fullWidth,
                    size,
                    variant,
                    classes,
                } = ownerState;
                const slots = {
                    root: [
                        "root",
                        variant,
                        `${variant}${(0, capitalize /* default */.Z)(color)}`,
                        `size${(0, capitalize /* default */.Z)(size)}`,
                        `${variant}Size${(0, capitalize /* default */.Z)(
                            size
                        )}`,
                        color === "inherit" && "colorInherit",
                        disableElevation && "disableElevation",
                        fullWidth && "fullWidth",
                    ],
                    label: ["label"],
                    startIcon: [
                        "startIcon",
                        `iconSize${(0, capitalize /* default */.Z)(size)}`,
                    ],
                    endIcon: [
                        "endIcon",
                        `iconSize${(0, capitalize /* default */.Z)(size)}`,
                    ],
                };
                const composedClasses = (0, composeClasses /* default */.Z)(
                    slots,
                    getButtonUtilityClass,
                    classes
                );
                return (0, esm_extends /* default */.Z)(
                    {},
                    classes,
                    composedClasses
                );
            };

            const commonIconStyles = (ownerState) =>
                (0, esm_extends /* default */.Z)(
                    {},
                    ownerState.size === "small" && {
                        "& > *:nth-of-type(1)": {
                            fontSize: 18,
                        },
                    },
                    ownerState.size === "medium" && {
                        "& > *:nth-of-type(1)": {
                            fontSize: 20,
                        },
                    },
                    ownerState.size === "large" && {
                        "& > *:nth-of-type(1)": {
                            fontSize: 22,
                        },
                    }
                );

            const ButtonRoot = (0, styled /* default */.ZP)(
                ButtonBase /* default */.Z,
                {
                    shouldForwardProp: (prop) =>
                        (0, styled /* rootShouldForwardProp */.FO)(prop) ||
                        prop === "classes",
                    name: "MuiButton",
                    slot: "Root",
                    overridesResolver: (props, styles) => {
                        const { ownerState } = props;
                        return [
                            styles.root,
                            styles[ownerState.variant],
                            styles[
                                `${ownerState.variant}${(0,
                                capitalize /* default */.Z)(ownerState.color)}`
                            ],
                            styles[
                                `size${(0, capitalize /* default */.Z)(
                                    ownerState.size
                                )}`
                            ],
                            styles[
                                `${ownerState.variant}Size${(0,
                                capitalize /* default */.Z)(ownerState.size)}`
                            ],
                            ownerState.color === "inherit" &&
                                styles.colorInherit,
                            ownerState.disableElevation &&
                                styles.disableElevation,
                            ownerState.fullWidth && styles.fullWidth,
                        ];
                    },
                }
            )(
                ({ theme, ownerState }) => {
                    var _theme$palette$getCon, _theme$palette;

                    return (0, esm_extends /* default */.Z)(
                        {},
                        theme.typography.button,
                        {
                            minWidth: 64,
                            padding: "6px 16px",
                            borderRadius: (theme.vars || theme).shape
                                .borderRadius,
                            transition: theme.transitions.create(
                                [
                                    "background-color",
                                    "box-shadow",
                                    "border-color",
                                    "color",
                                ],
                                {
                                    duration: theme.transitions.duration.short,
                                }
                            ),
                            "&:hover": (0, esm_extends /* default */.Z)(
                                {
                                    textDecoration: "none",
                                    backgroundColor: theme.vars
                                        ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})`
                                        : (0, colorManipulator /* alpha */.Fq)(
                                              theme.palette.text.primary,
                                              theme.palette.action.hoverOpacity
                                          ),
                                    // Reset on touch devices, it doesn't add specificity
                                    "@media (hover: none)": {
                                        backgroundColor: "transparent",
                                    },
                                },
                                ownerState.variant === "text" &&
                                    ownerState.color !== "inherit" && {
                                        backgroundColor: theme.vars
                                            ? `rgba(${
                                                  theme.vars.palette[
                                                      ownerState.color
                                                  ].mainChannel
                                              } / ${
                                                  theme.vars.palette.action
                                                      .hoverOpacity
                                              })`
                                            : (0,
                                              colorManipulator /* alpha */.Fq)(
                                                  theme.palette[
                                                      ownerState.color
                                                  ].main,
                                                  theme.palette.action
                                                      .hoverOpacity
                                              ),
                                        // Reset on touch devices, it doesn't add specificity
                                        "@media (hover: none)": {
                                            backgroundColor: "transparent",
                                        },
                                    },
                                ownerState.variant === "outlined" &&
                                    ownerState.color !== "inherit" && {
                                        border: `1px solid ${
                                            (theme.vars || theme).palette[
                                                ownerState.color
                                            ].main
                                        }`,
                                        backgroundColor: theme.vars
                                            ? `rgba(${
                                                  theme.vars.palette[
                                                      ownerState.color
                                                  ].mainChannel
                                              } / ${
                                                  theme.vars.palette.action
                                                      .hoverOpacity
                                              })`
                                            : (0,
                                              colorManipulator /* alpha */.Fq)(
                                                  theme.palette[
                                                      ownerState.color
                                                  ].main,
                                                  theme.palette.action
                                                      .hoverOpacity
                                              ),
                                        // Reset on touch devices, it doesn't add specificity
                                        "@media (hover: none)": {
                                            backgroundColor: "transparent",
                                        },
                                    },
                                ownerState.variant === "contained" && {
                                    backgroundColor: (theme.vars || theme)
                                        .palette.grey.A100,
                                    boxShadow: (theme.vars || theme).shadows[4],
                                    // Reset on touch devices, it doesn't add specificity
                                    "@media (hover: none)": {
                                        boxShadow: (theme.vars || theme)
                                            .shadows[2],
                                        backgroundColor: (theme.vars || theme)
                                            .palette.grey[300],
                                    },
                                },
                                ownerState.variant === "contained" &&
                                    ownerState.color !== "inherit" && {
                                        backgroundColor: (theme.vars || theme)
                                            .palette[ownerState.color].dark,
                                        // Reset on touch devices, it doesn't add specificity
                                        "@media (hover: none)": {
                                            backgroundColor: (
                                                theme.vars || theme
                                            ).palette[ownerState.color].main,
                                        },
                                    }
                            ),
                            "&:active": (0, esm_extends /* default */.Z)(
                                {},
                                ownerState.variant === "contained" && {
                                    boxShadow: (theme.vars || theme).shadows[8],
                                }
                            ),
                            [`&.${Button_buttonClasses.focusVisible}`]: (0,
                            esm_extends /* default */.Z)(
                                {},
                                ownerState.variant === "contained" && {
                                    boxShadow: (theme.vars || theme).shadows[6],
                                }
                            ),
                            [`&.${Button_buttonClasses.disabled}`]: (0,
                            esm_extends /* default */.Z)(
                                {
                                    color: (theme.vars || theme).palette.action
                                        .disabled,
                                },
                                ownerState.variant === "outlined" && {
                                    border: `1px solid ${
                                        (theme.vars || theme).palette.action
                                            .disabledBackground
                                    }`,
                                },
                                ownerState.variant === "outlined" &&
                                    ownerState.color === "secondary" && {
                                        border: `1px solid ${
                                            (theme.vars || theme).palette.action
                                                .disabled
                                        }`,
                                    },
                                ownerState.variant === "contained" && {
                                    color: (theme.vars || theme).palette.action
                                        .disabled,
                                    boxShadow: (theme.vars || theme).shadows[0],
                                    backgroundColor: (theme.vars || theme)
                                        .palette.action.disabledBackground,
                                }
                            ),
                        },
                        ownerState.variant === "text" && {
                            padding: "6px 8px",
                        },
                        ownerState.variant === "text" &&
                            ownerState.color !== "inherit" && {
                                color: (theme.vars || theme).palette[
                                    ownerState.color
                                ].main,
                            },
                        ownerState.variant === "outlined" && {
                            padding: "5px 15px",
                            border: "1px solid currentColor",
                        },
                        ownerState.variant === "outlined" &&
                            ownerState.color !== "inherit" && {
                                color: (theme.vars || theme).palette[
                                    ownerState.color
                                ].main,
                                border: theme.vars
                                    ? `1px solid rgba(${
                                          theme.vars.palette[ownerState.color]
                                              .mainChannel
                                      } / 0.5)`
                                    : `1px solid ${(0,
                                      colorManipulator /* alpha */.Fq)(
                                          theme.palette[ownerState.color].main,
                                          0.5
                                      )}`,
                            },
                        ownerState.variant === "contained" && {
                            color: theme.vars // this is safe because grey does not change between default light/dark mode
                                ? theme.vars.palette.text.primary
                                : (_theme$palette$getCon = (_theme$palette =
                                      theme.palette).getContrastText) == null
                                ? void 0
                                : _theme$palette$getCon.call(
                                      _theme$palette,
                                      theme.palette.grey[300]
                                  ),
                            backgroundColor: (theme.vars || theme).palette
                                .grey[300],
                            boxShadow: (theme.vars || theme).shadows[2],
                        },
                        ownerState.variant === "contained" &&
                            ownerState.color !== "inherit" && {
                                color: (theme.vars || theme).palette[
                                    ownerState.color
                                ].contrastText,
                                backgroundColor: (theme.vars || theme).palette[
                                    ownerState.color
                                ].main,
                            },
                        ownerState.color === "inherit" && {
                            color: "inherit",
                            borderColor: "currentColor",
                        },
                        ownerState.size === "small" &&
                            ownerState.variant === "text" && {
                                padding: "4px 5px",
                                fontSize: theme.typography.pxToRem(13),
                            },
                        ownerState.size === "large" &&
                            ownerState.variant === "text" && {
                                padding: "8px 11px",
                                fontSize: theme.typography.pxToRem(15),
                            },
                        ownerState.size === "small" &&
                            ownerState.variant === "outlined" && {
                                padding: "3px 9px",
                                fontSize: theme.typography.pxToRem(13),
                            },
                        ownerState.size === "large" &&
                            ownerState.variant === "outlined" && {
                                padding: "7px 21px",
                                fontSize: theme.typography.pxToRem(15),
                            },
                        ownerState.size === "small" &&
                            ownerState.variant === "contained" && {
                                padding: "4px 10px",
                                fontSize: theme.typography.pxToRem(13),
                            },
                        ownerState.size === "large" &&
                            ownerState.variant === "contained" && {
                                padding: "8px 22px",
                                fontSize: theme.typography.pxToRem(15),
                            },
                        ownerState.fullWidth && {
                            width: "100%",
                        }
                    );
                },
                ({ ownerState }) =>
                    ownerState.disableElevation && {
                        boxShadow: "none",
                        "&:hover": {
                            boxShadow: "none",
                        },
                        [`&.${Button_buttonClasses.focusVisible}`]: {
                            boxShadow: "none",
                        },
                        "&:active": {
                            boxShadow: "none",
                        },
                        [`&.${Button_buttonClasses.disabled}`]: {
                            boxShadow: "none",
                        },
                    }
            );
            const ButtonStartIcon = (0, styled /* default */.ZP)("span", {
                name: "MuiButton",
                slot: "StartIcon",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.startIcon,
                        styles[
                            `iconSize${(0, capitalize /* default */.Z)(
                                ownerState.size
                            )}`
                        ],
                    ];
                },
            })(({ ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        display: "inherit",
                        marginRight: 8,
                        marginLeft: -4,
                    },
                    ownerState.size === "small" && {
                        marginLeft: -2,
                    },
                    commonIconStyles(ownerState)
                )
            );
            const ButtonEndIcon = (0, styled /* default */.ZP)("span", {
                name: "MuiButton",
                slot: "EndIcon",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.endIcon,
                        styles[
                            `iconSize${(0, capitalize /* default */.Z)(
                                ownerState.size
                            )}`
                        ],
                    ];
                },
            })(({ ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        display: "inherit",
                        marginRight: -4,
                        marginLeft: 8,
                    },
                    ownerState.size === "small" && {
                        marginRight: -2,
                    },
                    commonIconStyles(ownerState)
                )
            );
            const Button = /*#__PURE__*/ react.forwardRef(function Button(
                inProps,
                ref
            ) {
                // props priority: `inProps` > `contextProps` > `themeDefaultProps`
                const contextProps = react.useContext(
                    ButtonGroup_ButtonGroupContext
                );
                const resolvedProps = (0, resolveProps /* default */.Z)(
                    contextProps,
                    inProps
                );
                const props = (0, useThemeProps /* default */.Z)({
                    props: resolvedProps,
                    name: "MuiButton",
                });

                const {
                        children,
                        color = "primary",
                        component = "button",
                        className,
                        disabled = false,
                        disableElevation = false,
                        disableFocusRipple = false,
                        endIcon: endIconProp,
                        focusVisibleClassName,
                        fullWidth = false,
                        size = "medium",
                        startIcon: startIconProp,
                        type,
                        variant = "text",
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        Button_excluded
                    );

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    color,
                    component,
                    disabled,
                    disableElevation,
                    disableFocusRipple,
                    fullWidth,
                    size,
                    type,
                    variant,
                });

                const classes = Button_useUtilityClasses(ownerState);

                const startIcon =
                    startIconProp &&
                    /*#__PURE__*/ (0, jsx_runtime.jsx)(ButtonStartIcon, {
                        className: classes.startIcon,
                        ownerState: ownerState,
                        children: startIconProp,
                    });

                const endIcon =
                    endIconProp &&
                    /*#__PURE__*/ (0, jsx_runtime.jsx)(ButtonEndIcon, {
                        className: classes.endIcon,
                        ownerState: ownerState,
                        children: endIconProp,
                    });

                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    ButtonRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            ownerState: ownerState,
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                contextProps.className
                            ),
                            component: component,
                            disabled: disabled,
                            focusRipple: !disableFocusRipple,
                            focusVisibleClassName: (0, clsx_m /* default */.Z)(
                                classes.focusVisible,
                                focusVisibleClassName
                            ),
                            ref: ref,
                            type: type,
                        },
                        other,
                        {
                            classes: classes,
                            children: [startIcon, children, endIcon],
                        }
                    )
                );
            });
            false ? 0 : void 0;
            /* harmony default export */ var Button_Button = Button;
            // EXTERNAL MODULE: ./node_modules/@mui/material/Tooltip/Tooltip.js + 1 modules
            var Tooltip = __webpack_require__(4386); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/cell/GridCell.js
            const GridCell_excluded = [
                "align",
                "children",
                "colIndex",
                "colDef",
                "cellMode",
                "field",
                "formattedValue",
                "hasFocus",
                "height",
                "isEditable",
                "rowId",
                "tabIndex",
                "value",
                "width",
                "className",
                "showRightBorder",
                "extendRowFullWidth",
                "row",
                "colSpan",
                "onClick",
                "onDoubleClick",
                "onMouseDown",
                "onMouseUp",
                "onKeyDown",
                "onDragEnter",
                "onDragOver",
            ];

            /* eslint-disable jsx-a11y/no-noninteractive-element-interactions */

            // Based on https://stackoverflow.com/a/59518678
            let cachedSupportsPreventScroll;

            function doesSupportPreventScroll() {
                if (cachedSupportsPreventScroll === undefined) {
                    document.createElement("div").focus({
                        get preventScroll() {
                            cachedSupportsPreventScroll = true;
                            return false;
                        },
                    });
                }

                return cachedSupportsPreventScroll;
            }

            const GridCell_useUtilityClasses = (ownerState) => {
                const { align, showRightBorder, isEditable, classes } =
                    ownerState;
                const slots = {
                    root: [
                        "cell",
                        `cell--text${(0, capitalize /* default */.Z)(align)}`,
                        isEditable && "cell--editable",
                        showRightBorder && "withBorder",
                    ],
                    content: ["cellContent"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            let GridCell_warnedOnce = false;

            function GridCell(props) {
                var _rootProps$experiment;

                const {
                        align,
                        children,
                        colIndex,
                        cellMode,
                        field,
                        formattedValue,
                        hasFocus,
                        height,
                        isEditable,
                        rowId,
                        tabIndex,
                        value,
                        width,
                        className,
                        showRightBorder,
                        colSpan,
                        onClick,
                        onDoubleClick,
                        onMouseDown,
                        onMouseUp,
                        onKeyDown,
                        onDragEnter,
                        onDragOver,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridCell_excluded
                    );

                const valueToRender =
                    formattedValue == null ? value : formattedValue;
                const cellRef = react.useRef(null);
                const focusElementRef = react.useRef(null);
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const ownerState = {
                    align,
                    showRightBorder,
                    isEditable,
                    classes: rootProps.classes,
                };
                const classes = GridCell_useUtilityClasses(ownerState);
                const publishMouseUp = react.useCallback(
                    (eventName) => (event) => {
                        const params = apiRef.current.getCellParams(
                            rowId,
                            field || ""
                        );
                        apiRef.current.publishEvent(eventName, params, event);

                        if (onMouseUp) {
                            onMouseUp(event);
                        }
                    },
                    [apiRef, field, onMouseUp, rowId]
                );
                const publish = react.useCallback(
                    (eventName, propHandler) => (event) => {
                        // Ignore portal
                        if (!event.currentTarget.contains(event.target)) {
                            return;
                        } // The row might have been deleted during the click

                        if (!apiRef.current.getRow(rowId)) {
                            return;
                        }

                        const params = apiRef.current.getCellParams(
                            rowId,
                            field || ""
                        );
                        apiRef.current.publishEvent(eventName, params, event);

                        if (propHandler) {
                            propHandler(event);
                        }
                    },
                    [apiRef, field, rowId]
                );
                const style = {
                    minWidth: width,
                    maxWidth: width,
                    minHeight: height,
                    maxHeight: height,
                };
                react.useLayoutEffect(() => {
                    if (!hasFocus || cellMode === GridCellModes.Edit) {
                        return;
                    }

                    const doc = (0, utils_ownerDocument /* default */.Z)(
                        apiRef.current.rootElementRef.current
                    );

                    if (
                        cellRef.current &&
                        !cellRef.current.contains(doc.activeElement)
                    ) {
                        const focusableElement =
                            cellRef.current.querySelector('[tabindex="0"]');
                        const elementToFocus =
                            focusElementRef.current ||
                            focusableElement ||
                            cellRef.current;

                        if (doesSupportPreventScroll()) {
                            elementToFocus.focus({
                                preventScroll: true,
                            });
                        } else {
                            const scrollPosition =
                                apiRef.current.getScrollPosition();
                            elementToFocus.focus();
                            apiRef.current.scroll(scrollPosition);
                        }
                    }
                }, [hasFocus, cellMode, apiRef]);
                let handleFocus = other.onFocus;

                if (false) {
                }

                const column = apiRef.current.getColumn(field);
                const managesOwnFocus = column.type === "actions";

                const renderChildren = () => {
                    if (children == null) {
                        return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                            className: classes.content,
                            children:
                                valueToRender == null
                                    ? void 0
                                    : valueToRender.toString(),
                        });
                    }

                    if (
                        /*#__PURE__*/ react.isValidElement(children) &&
                        managesOwnFocus
                    ) {
                        return /*#__PURE__*/ react.cloneElement(children, {
                            focusElementRef,
                        });
                    }

                    return children;
                };

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    "div",
                    (0, esm_extends /* default */.Z)(
                        {
                            ref: cellRef,
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                classes.root
                            ),
                            role: "cell",
                            "data-field": field,
                            "data-colindex": colIndex,
                            "aria-colindex": colIndex + 1,
                            "aria-colspan": colSpan,
                            style: style,
                            tabIndex:
                                (cellMode === "view" || !isEditable) &&
                                !managesOwnFocus
                                    ? tabIndex
                                    : -1,
                            onClick: publish(
                                gridEvents /* GridEvents.cellClick */.t
                                    .cellClick,
                                onClick
                            ),
                            onDoubleClick: publish(
                                gridEvents /* GridEvents.cellDoubleClick */.t
                                    .cellDoubleClick,
                                onDoubleClick
                            ),
                            onMouseDown: publish(
                                gridEvents /* GridEvents.cellMouseDown */.t
                                    .cellMouseDown,
                                onMouseDown
                            ),
                            onMouseUp: publishMouseUp(
                                gridEvents /* GridEvents.cellMouseUp */.t
                                    .cellMouseUp
                            ),
                            onKeyDown: publish(
                                gridEvents /* GridEvents.cellKeyDown */.t
                                    .cellKeyDown,
                                onKeyDown
                            ),
                            onDragEnter: publish(
                                gridEvents /* GridEvents.cellDragEnter */.t
                                    .cellDragEnter,
                                onDragEnter
                            ),
                            onDragOver: publish(
                                gridEvents /* GridEvents.cellDragOver */.t
                                    .cellDragOver,
                                onDragOver
                            ),
                        },
                        other,
                        {
                            onFocus: handleFocus,
                            children: renderChildren(),
                        }
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/utils/esm/usePreviousProps.js

            const usePreviousProps = (value) => {
                const ref = react.useRef({});
                react.useEffect(() => {
                    ref.current = value;
                });
                return ref.current;
            };

            /* harmony default export */ var esm_usePreviousProps =
                usePreviousProps;
            // EXTERNAL MODULE: ./node_modules/@mui/base/utils/appendOwnerState.js
            var appendOwnerState = __webpack_require__(238); // CONCATENATED MODULE: ./node_modules/@mui/base/BadgeUnstyled/useBadge.js
            function useBadge(props) {
                const {
                    badgeContent: badgeContentProp,
                    invisible: invisibleProp = false,
                    max: maxProp = 99,
                    showZero = false,
                } = props;
                const prevProps = esm_usePreviousProps({
                    badgeContent: badgeContentProp,
                    max: maxProp,
                });
                let invisible = invisibleProp;

                if (
                    invisibleProp === false &&
                    badgeContentProp === 0 &&
                    !showZero
                ) {
                    invisible = true;
                }

                const { badgeContent, max = maxProp } = invisible
                    ? prevProps
                    : props;
                const displayValue =
                    badgeContent && Number(badgeContent) > max
                        ? `${max}+`
                        : badgeContent;
                return {
                    badgeContent,
                    invisible,
                    max,
                    displayValue,
                };
            } // CONCATENATED MODULE: ./node_modules/@mui/base/BadgeUnstyled/badgeUnstyledClasses.js
            function getBadgeUnstyledUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "BaseBadge",
                    slot
                );
            }
            const badgeUnstyledClasses = (0,
            generateUtilityClasses /* default */.Z)("BaseBadge", [
                "root",
                "badge",
                "invisible",
            ]);
            /* harmony default export */ var BadgeUnstyled_badgeUnstyledClasses =
                /* unused pure expression or super */ null &&
                badgeUnstyledClasses; // CONCATENATED MODULE: ./node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.js
            const BadgeUnstyled_excluded = [
                "badgeContent",
                "component",
                "children",
                "className",
                "components",
                "componentsProps",
                "invisible",
                "max",
                "showZero",
            ];

            const BadgeUnstyled_useUtilityClasses = (ownerState) => {
                const { invisible } = ownerState;
                const slots = {
                    root: ["root"],
                    badge: ["badge", invisible && "invisible"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getBadgeUnstyledUtilityClass,
                    undefined
                );
            };

            const BadgeUnstyled = /*#__PURE__*/ react.forwardRef(
                function BadgeUnstyled(props, ref) {
                    const {
                            component,
                            children,
                            className,
                            components = {},
                            componentsProps = {},
                            max: maxProp = 99,
                            showZero = false,
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            BadgeUnstyled_excluded
                        );

                    const { badgeContent, max, displayValue, invisible } =
                        useBadge(
                            (0, esm_extends /* default */.Z)({}, props, {
                                max: maxProp,
                            })
                        );

                    const ownerState = (0, esm_extends /* default */.Z)(
                        {},
                        props,
                        {
                            badgeContent,
                            invisible,
                            max,
                            showZero,
                        }
                    );

                    const classes = BadgeUnstyled_useUtilityClasses(ownerState);
                    const Root = component || components.Root || "span";
                    const rootProps = (0, appendOwnerState /* default */.Z)(
                        Root,
                        (0, esm_extends /* default */.Z)(
                            {},
                            other,
                            componentsProps.root
                        ),
                        ownerState
                    );
                    const Badge = components.Badge || "span";
                    const badgeProps = (0, appendOwnerState /* default */.Z)(
                        Badge,
                        componentsProps.badge,
                        ownerState
                    );
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        Root,
                        (0, esm_extends /* default */.Z)(
                            {},
                            rootProps,
                            {
                                ref: ref,
                            },
                            other,
                            {
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    rootProps.className,
                                    className
                                ),
                                children: [
                                    children,
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        Badge,
                                        (0, esm_extends /* default */.Z)(
                                            {},
                                            badgeProps,
                                            {
                                                className: (0,
                                                clsx_m /* default */.Z)(
                                                    classes.badge,
                                                    badgeProps.className
                                                ),
                                                children: displayValue,
                                            }
                                        )
                                    ),
                                ],
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var BadgeUnstyled_BadgeUnstyled =
                BadgeUnstyled;
            // EXTERNAL MODULE: ./node_modules/@mui/material/utils/shouldSpreadAdditionalProps.js
            var shouldSpreadAdditionalProps = __webpack_require__(6285); // CONCATENATED MODULE: ./node_modules/@mui/material/Badge/badgeClasses.js
            function getBadgeUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiBadge",
                    slot
                );
            }
            const badgeClasses = (0, generateUtilityClasses /* default */.Z)(
                "MuiBadge",
                [
                    "root",
                    "badge",
                    "dot",
                    "standard",
                    "anchorOriginTopRight",
                    "anchorOriginBottomRight",
                    "anchorOriginTopLeft",
                    "anchorOriginBottomLeft",
                    "invisible",
                    "colorError",
                    "colorInfo",
                    "colorPrimary",
                    "colorSecondary",
                    "colorSuccess",
                    "colorWarning",
                    "overlapRectangular",
                    "overlapCircular", // TODO: v6 remove the overlap value from these class keys
                    "anchorOriginTopLeftCircular",
                    "anchorOriginTopLeftRectangular",
                    "anchorOriginTopRightCircular",
                    "anchorOriginTopRightRectangular",
                    "anchorOriginBottomLeftCircular",
                    "anchorOriginBottomLeftRectangular",
                    "anchorOriginBottomRightCircular",
                    "anchorOriginBottomRightRectangular",
                ]
            );
            /* harmony default export */ var Badge_badgeClasses = badgeClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/Badge/Badge.js
            const Badge_excluded = [
                "anchorOrigin",
                "className",
                "component",
                "components",
                "componentsProps",
                "overlap",
                "color",
                "invisible",
                "max",
                "badgeContent",
                "showZero",
                "variant",
            ];

            const RADIUS_STANDARD = 10;
            const RADIUS_DOT = 4;

            const Badge_useUtilityClasses = (ownerState) => {
                const {
                    color,
                    anchorOrigin,
                    invisible,
                    overlap,
                    variant,
                    classes = {},
                } = ownerState;
                const slots = {
                    root: ["root"],
                    badge: [
                        "badge",
                        variant,
                        invisible && "invisible",
                        `anchorOrigin${(0, capitalize /* default */.Z)(
                            anchorOrigin.vertical
                        )}${(0, capitalize /* default */.Z)(
                            anchorOrigin.horizontal
                        )}`,
                        `anchorOrigin${(0, capitalize /* default */.Z)(
                            anchorOrigin.vertical
                        )}${(0, capitalize /* default */.Z)(
                            anchorOrigin.horizontal
                        )}${(0, capitalize /* default */.Z)(overlap)}`,
                        `overlap${(0, capitalize /* default */.Z)(overlap)}`,
                        color !== "default" &&
                            `color${(0, capitalize /* default */.Z)(color)}`,
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getBadgeUtilityClass,
                    classes
                );
            };

            const BadgeRoot = (0, styled /* default */.ZP)("span", {
                name: "MuiBadge",
                slot: "Root",
                overridesResolver: (props, styles) => styles.root,
            })({
                position: "relative",
                display: "inline-flex",
                // For correct alignment with the text.
                verticalAlign: "middle",
                flexShrink: 0,
            });
            const BadgeBadge = (0, styled /* default */.ZP)("span", {
                name: "MuiBadge",
                slot: "Badge",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.badge,
                        styles[ownerState.variant],
                        styles[
                            `anchorOrigin${(0, capitalize /* default */.Z)(
                                ownerState.anchorOrigin.vertical
                            )}${(0, capitalize /* default */.Z)(
                                ownerState.anchorOrigin.horizontal
                            )}${(0, capitalize /* default */.Z)(
                                ownerState.overlap
                            )}`
                        ],
                        ownerState.color !== "default" &&
                            styles[
                                `color${(0, capitalize /* default */.Z)(
                                    ownerState.color
                                )}`
                            ],
                        ownerState.invisible && styles.invisible,
                    ];
                },
            })(({ theme, ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        display: "flex",
                        flexDirection: "row",
                        flexWrap: "wrap",
                        justifyContent: "center",
                        alignContent: "center",
                        alignItems: "center",
                        position: "absolute",
                        boxSizing: "border-box",
                        fontFamily: theme.typography.fontFamily,
                        fontWeight: theme.typography.fontWeightMedium,
                        fontSize: theme.typography.pxToRem(12),
                        minWidth: RADIUS_STANDARD * 2,
                        lineHeight: 1,
                        padding: "0 6px",
                        height: RADIUS_STANDARD * 2,
                        borderRadius: RADIUS_STANDARD,
                        zIndex: 1,
                        // Render the badge on top of potential ripples.
                        transition: theme.transitions.create("transform", {
                            easing: theme.transitions.easing.easeInOut,
                            duration: theme.transitions.duration.enteringScreen,
                        }),
                    },
                    ownerState.color !== "default" && {
                        backgroundColor: (theme.vars || theme).palette[
                            ownerState.color
                        ].main,
                        color: (theme.vars || theme).palette[ownerState.color]
                            .contrastText,
                    },
                    ownerState.variant === "dot" && {
                        borderRadius: RADIUS_DOT,
                        height: RADIUS_DOT * 2,
                        minWidth: RADIUS_DOT * 2,
                        padding: 0,
                    },
                    ownerState.anchorOrigin.vertical === "top" &&
                        ownerState.anchorOrigin.horizontal === "right" &&
                        ownerState.overlap === "rectangular" && {
                            top: 0,
                            right: 0,
                            transform: "scale(1) translate(50%, -50%)",
                            transformOrigin: "100% 0%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(50%, -50%)",
                            },
                        },
                    ownerState.anchorOrigin.vertical === "bottom" &&
                        ownerState.anchorOrigin.horizontal === "right" &&
                        ownerState.overlap === "rectangular" && {
                            bottom: 0,
                            right: 0,
                            transform: "scale(1) translate(50%, 50%)",
                            transformOrigin: "100% 100%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(50%, 50%)",
                            },
                        },
                    ownerState.anchorOrigin.vertical === "top" &&
                        ownerState.anchorOrigin.horizontal === "left" &&
                        ownerState.overlap === "rectangular" && {
                            top: 0,
                            left: 0,
                            transform: "scale(1) translate(-50%, -50%)",
                            transformOrigin: "0% 0%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(-50%, -50%)",
                            },
                        },
                    ownerState.anchorOrigin.vertical === "bottom" &&
                        ownerState.anchorOrigin.horizontal === "left" &&
                        ownerState.overlap === "rectangular" && {
                            bottom: 0,
                            left: 0,
                            transform: "scale(1) translate(-50%, 50%)",
                            transformOrigin: "0% 100%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(-50%, 50%)",
                            },
                        },
                    ownerState.anchorOrigin.vertical === "top" &&
                        ownerState.anchorOrigin.horizontal === "right" &&
                        ownerState.overlap === "circular" && {
                            top: "14%",
                            right: "14%",
                            transform: "scale(1) translate(50%, -50%)",
                            transformOrigin: "100% 0%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(50%, -50%)",
                            },
                        },
                    ownerState.anchorOrigin.vertical === "bottom" &&
                        ownerState.anchorOrigin.horizontal === "right" &&
                        ownerState.overlap === "circular" && {
                            bottom: "14%",
                            right: "14%",
                            transform: "scale(1) translate(50%, 50%)",
                            transformOrigin: "100% 100%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(50%, 50%)",
                            },
                        },
                    ownerState.anchorOrigin.vertical === "top" &&
                        ownerState.anchorOrigin.horizontal === "left" &&
                        ownerState.overlap === "circular" && {
                            top: "14%",
                            left: "14%",
                            transform: "scale(1) translate(-50%, -50%)",
                            transformOrigin: "0% 0%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(-50%, -50%)",
                            },
                        },
                    ownerState.anchorOrigin.vertical === "bottom" &&
                        ownerState.anchorOrigin.horizontal === "left" &&
                        ownerState.overlap === "circular" && {
                            bottom: "14%",
                            left: "14%",
                            transform: "scale(1) translate(-50%, 50%)",
                            transformOrigin: "0% 100%",
                            [`&.${Badge_badgeClasses.invisible}`]: {
                                transform: "scale(0) translate(-50%, 50%)",
                            },
                        },
                    ownerState.invisible && {
                        transition: theme.transitions.create("transform", {
                            easing: theme.transitions.easing.easeInOut,
                            duration: theme.transitions.duration.leavingScreen,
                        }),
                    }
                )
            );
            const Badge = /*#__PURE__*/ react.forwardRef(function Badge(
                inProps,
                ref
            ) {
                var _componentsProps$root,
                    _componentsProps$root2,
                    _componentsProps$badg,
                    _componentsProps$badg2;

                const props = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiBadge",
                });

                const {
                        anchorOrigin: anchorOriginProp = {
                            vertical: "top",
                            horizontal: "right",
                        },
                        className,
                        component = "span",
                        components = {},
                        componentsProps = {},
                        overlap: overlapProp = "rectangular",
                        color: colorProp = "default",
                        invisible: invisibleProp = false,
                        max,
                        badgeContent: badgeContentProp,
                        showZero = false,
                        variant: variantProp = "standard",
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        Badge_excluded
                    );

                const prevProps = esm_usePreviousProps({
                    anchorOrigin: anchorOriginProp,
                    color: colorProp,
                    overlap: overlapProp,
                    variant: variantProp,
                });
                let invisible = invisibleProp;

                if (
                    invisibleProp === false &&
                    ((badgeContentProp === 0 && !showZero) ||
                        (badgeContentProp == null && variantProp !== "dot"))
                ) {
                    invisible = true;
                }

                const {
                    color = colorProp,
                    overlap = overlapProp,
                    anchorOrigin = anchorOriginProp,
                    variant = variantProp,
                } = invisible ? prevProps : props;

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    anchorOrigin,
                    invisible,
                    color,
                    overlap,
                    variant,
                });

                const classes = Badge_useUtilityClasses(ownerState);
                let displayValue;

                if (variant !== "dot") {
                    displayValue =
                        badgeContentProp && Number(badgeContentProp) > max
                            ? `${max}+`
                            : badgeContentProp;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    BadgeUnstyled_BadgeUnstyled,
                    (0, esm_extends /* default */.Z)(
                        {
                            invisible: invisibleProp,
                            badgeContent: displayValue,
                            showZero: showZero,
                            max: max,
                        },
                        other,
                        {
                            components: (0, esm_extends /* default */.Z)(
                                {
                                    Root: BadgeRoot,
                                    Badge: BadgeBadge,
                                },
                                components
                            ),
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                classes.root,
                                (_componentsProps$root =
                                    componentsProps.root) == null
                                    ? void 0
                                    : _componentsProps$root.className
                            ),
                            componentsProps: {
                                root: (0, esm_extends /* default */.Z)(
                                    {},
                                    componentsProps.root,
                                    (0,
                                    shouldSpreadAdditionalProps /* default */.Z)(
                                        components.Root
                                    ) && {
                                        as: component,
                                        ownerState: (0,
                                        esm_extends /* default */.Z)(
                                            {},
                                            (_componentsProps$root2 =
                                                componentsProps.root) == null
                                                ? void 0
                                                : _componentsProps$root2.ownerState,
                                            {
                                                anchorOrigin,
                                                color,
                                                overlap,
                                                variant,
                                            }
                                        ),
                                    }
                                ),
                                badge: (0, esm_extends /* default */.Z)(
                                    {},
                                    componentsProps.badge,
                                    {
                                        className: (0, clsx_m /* default */.Z)(
                                            classes.badge,
                                            (_componentsProps$badg =
                                                componentsProps.badge) == null
                                                ? void 0
                                                : _componentsProps$badg.className
                                        ),
                                    },
                                    (0,
                                    shouldSpreadAdditionalProps /* default */.Z)(
                                        components.Badge
                                    ) && {
                                        ownerState: (0,
                                        esm_extends /* default */.Z)(
                                            {},
                                            (_componentsProps$badg2 =
                                                componentsProps.badge) == null
                                                ? void 0
                                                : _componentsProps$badg2.ownerState,
                                            {
                                                anchorOrigin,
                                                color,
                                                overlap,
                                                variant,
                                            }
                                        ),
                                    }
                                ),
                            },
                            ref: ref,
                        }
                    )
                );
            });
            false ? 0 : void 0;
            /* harmony default export */ var Badge_Badge = Badge; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridIconButtonContainer.js
            const GridIconButtonContainer_excluded = ["className"];

            const GridIconButtonContainer_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["iconButtonContainer"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridIconButtonContainerRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "IconButtonContainer",
                    overridesResolver: (props, styles) =>
                        styles.iconButtonContainer,
                }
            )(() => ({
                display: "flex",
                visibility: "hidden",
                width: 0,
            }));
            const GridIconButtonContainer = /*#__PURE__*/ react.forwardRef(
                function GridIconButtonContainer(props, ref) {
                    const { className } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridIconButtonContainer_excluded
                        );

                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridIconButtonContainer_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridIconButtonContainerRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnHeaderFilterIconButton.js
            const GridColumnHeaderFilterIconButton_useUtilityClasses = (
                ownerState
            ) => {
                const { classes } = ownerState;
                const slots = {
                    icon: ["filterIcon"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            function GridColumnHeaderFilterIconButton(props) {
                var _rootProps$components;

                const { counter, field, onClick } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    classes: rootProps.classes,
                });

                const classes =
                    GridColumnHeaderFilterIconButton_useUtilityClasses(
                        ownerState
                    );
                const toggleFilter = react.useCallback(
                    (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        const { open, openedPanelValue } =
                            gridPreferencePanelStateSelector(
                                apiRef.current.state
                            );

                        if (
                            open &&
                            openedPanelValue ===
                                GridPreferencePanelsValue.filters
                        ) {
                            apiRef.current.hideFilterPanel();
                        } else {
                            apiRef.current.showFilterPanel();
                        }

                        if (onClick) {
                            onClick(
                                apiRef.current.getColumnHeaderParams(field),
                                event
                            );
                        }
                    },
                    [apiRef, field, onClick]
                );

                if (!counter) {
                    return null;
                }

                const iconButton = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    IconButton /* default */.Z,
                    {
                        onClick: toggleFilter,
                        color: "default",
                        "aria-label": apiRef.current.getLocaleText(
                            "columnHeaderFiltersLabel"
                        ),
                        size: "small",
                        tabIndex: -1,
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            rootProps.components.ColumnFilteredIcon,
                            {
                                className: classes.icon,
                                fontSize: "small",
                            }
                        ),
                    }
                );

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    rootProps.components.BaseTooltip,
                    (0, esm_extends /* default */.Z)(
                        {
                            title: apiRef.current.getLocaleText(
                                "columnHeaderFiltersTooltipActive"
                            )(counter),
                            enterDelay: 1000,
                        },
                        (_rootProps$components = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components.baseTooltip,
                        {
                            children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                                GridIconButtonContainer,
                                {
                                    children: [
                                        counter > 1 &&
                                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                                Badge_Badge,
                                                {
                                                    badgeContent: counter,
                                                    color: "default",
                                                    children: iconButton,
                                                }
                                            ),
                                        counter === 1 && iconButton,
                                    ],
                                }
                            ),
                        }
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/columnMenu/GridColumnMenuContainer.js

            const GridColumnMenuContainer_excluded = [
                "hideMenu",
                "currentColumn",
                "open",
                "id",
                "labelledby",
                "className",
                "children",
            ];

            const GridColumnMenuContainer = /*#__PURE__*/ react.forwardRef(
                function GridColumnMenuContainer(props, ref) {
                    const {
                            hideMenu,
                            open,
                            id,
                            labelledby,
                            className,
                            children,
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridColumnMenuContainer_excluded
                        );

                    const handleListKeyDown = react.useCallback(
                        (event) => {
                            if (isTabKey(event.key)) {
                                event.preventDefault();
                            }

                            if (isHideMenuKey(event.key)) {
                                hideMenu(event);
                            }
                        },
                        [hideMenu]
                    );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        MenuList /* default */.Z,
                        (0, esm_extends /* default */.Z)(
                            {
                                id: id,
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    gridClasses_gridClasses.menuList,
                                    className
                                ),
                                "aria-labelledby": labelledby,
                                onKeyDown: handleListKeyDown,
                                autoFocus: open,
                            },
                            other,
                            {
                                children: children,
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/columnMenu/GridColumnsMenuItem.js

            const GridColumnsMenuItem = (props) => {
                const { onClick } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const showColumns = react.useCallback(
                    (event) => {
                        onClick(event);
                        apiRef.current.showPreferences(
                            GridPreferencePanelsValue.columns
                        );
                    },
                    [apiRef, onClick]
                );

                if (rootProps.disableColumnSelector) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    MenuItem /* default */.Z,
                    {
                        onClick: showColumns,
                        children: apiRef.current.getLocaleText(
                            "columnMenuShowColumns"
                        ),
                    }
                );
            };

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/columnMenu/GridFilterMenuItem.js

            const GridFilterMenuItem = (props) => {
                const { column, onClick } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const showFilter = react.useCallback(
                    (event) => {
                        onClick(event);
                        apiRef.current.showFilterPanel(
                            column == null ? void 0 : column.field
                        );
                    },
                    [apiRef, column == null ? void 0 : column.field, onClick]
                );

                if (
                    rootProps.disableColumnFilter ||
                    !(column != null && column.filterable)
                ) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    MenuItem /* default */.Z,
                    {
                        onClick: showFilter,
                        children:
                            apiRef.current.getLocaleText("columnMenuFilter"),
                    }
                );
            };

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/columnMenu/HideGridColMenuItem.js

            const HideGridColMenuItem = (props) => {
                const { column, onClick } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const timeoutRef = react.useRef();
                const visibleColumns =
                    gridVisibleColumnDefinitionsSelector(apiRef);
                const columnsWithMenu = visibleColumns.filter(
                    (col) => col.disableColumnMenu !== true
                ); // do not allow to hide the last column with menu

                const disabled = columnsWithMenu.length === 1;
                const toggleColumn = react.useCallback(
                    (event) => {
                        /**
                         * Disabled `MenuItem` would trigger `click` event
                         * after imperative `.click()` call on HTML element.
                         * Also, click is triggered in testing environment as well.
                         */
                        if (disabled) {
                            return;
                        }

                        onClick(event); // time for the transition

                        timeoutRef.current = setTimeout(() => {
                            apiRef.current.setColumnVisibility(
                                column == null ? void 0 : column.field,
                                false
                            );
                        }, 100);
                    },
                    [
                        apiRef,
                        column == null ? void 0 : column.field,
                        onClick,
                        disabled,
                    ]
                );
                react.useEffect(() => {
                    return () => clearTimeout(timeoutRef.current);
                }, []);

                if (rootProps.disableColumnSelector) {
                    return null;
                }

                if (column.hideable === false) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    MenuItem /* default */.Z,
                    {
                        onClick: toggleColumn,
                        disabled: disabled,
                        children: apiRef.current.getLocaleText(
                            "columnMenuHideColumn"
                        ),
                    }
                );
            };

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/columnMenu/SortGridMenuItems.js

            const SortGridMenuItems = (props) => {
                const { column, onClick } = props;
                const apiRef = useGridApiContext();
                const sortModel = useGridSelector(
                    apiRef,
                    gridSortModelSelector
                );
                const sortDirection = react.useMemo(() => {
                    if (!column) {
                        return null;
                    }

                    const sortItem = sortModel.find(
                        (item) => item.field === column.field
                    );
                    return sortItem == null ? void 0 : sortItem.sort;
                }, [column, sortModel]);
                const onSortMenuItemClick = react.useCallback(
                    (event) => {
                        onClick(event);
                        const direction =
                            event.currentTarget.getAttribute("data-value") ||
                            null;
                        apiRef.current.sortColumn(column, direction);
                    },
                    [apiRef, column, onClick]
                );

                if (!column || !column.sortable) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(react.Fragment, {
                    children: [
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            MenuItem /* default */.Z,
                            {
                                onClick: onSortMenuItemClick,
                                disabled: sortDirection == null,
                                children:
                                    apiRef.current.getLocaleText(
                                        "columnMenuUnsort"
                                    ),
                            }
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            MenuItem /* default */.Z,
                            {
                                onClick: onSortMenuItemClick,
                                "data-value": "asc",
                                disabled: sortDirection === "asc",
                                children:
                                    apiRef.current.getLocaleText(
                                        "columnMenuSortAsc"
                                    ),
                            }
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            MenuItem /* default */.Z,
                            {
                                onClick: onSortMenuItemClick,
                                "data-value": "desc",
                                disabled: sortDirection === "desc",
                                children:
                                    apiRef.current.getLocaleText(
                                        "columnMenuSortDesc"
                                    ),
                            }
                        ),
                    ],
                });
            };

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/columnMenu/GridColumnMenu.js

            const GridColumnMenu = /*#__PURE__*/ react.forwardRef(
                function GridColumnMenu(props, ref) {
                    const { hideMenu, currentColumn } = props;
                    const apiRef = useGridApiContext();
                    const defaultButtons = [
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(SortGridMenuItems, {
                            onClick: hideMenu,
                            column: currentColumn,
                        }),
                        /*#__PURE__*/
                        // TODO update types to allow `onClick` and `column` to be optional
                        (0, jsx_runtime.jsx)(GridFilterMenuItem, {
                            onClick: hideMenu,
                            column: currentColumn,
                        }),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            HideGridColMenuItem,
                            {
                                onClick: hideMenu,
                                column: currentColumn,
                            }
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            GridColumnsMenuItem,
                            {
                                onClick: hideMenu,
                                column: currentColumn,
                            }
                        ),
                    ];
                    const preProcessedButtons =
                        apiRef.current.unstable_applyPipeProcessors(
                            "columnMenu",
                            defaultButtons,
                            currentColumn
                        );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridColumnMenuContainer,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            props,
                            {
                                children: preProcessedButtons.map(
                                    (button, index) =>
                                        /*#__PURE__*/ react.cloneElement(
                                            button,
                                            {
                                                key: index,
                                                onClick: hideMenu,
                                                column: currentColumn,
                                            }
                                        )
                                ),
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridRowCount.js

            const GridRowCount_excluded = [
                "className",
                "rowCount",
                "visibleRowCount",
            ];

            const GridRowCount_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["rowCount"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridRowCountRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "RowCount",
                overridesResolver: (props, styles) => styles.rowCount,
            })(({ theme }) => ({
                alignItems: "center",
                display: "flex",
                margin: theme.spacing(0, 2),
            }));
            const GridRowCount = /*#__PURE__*/ react.forwardRef(
                function GridRowCount(props, ref) {
                    const { className, rowCount, visibleRowCount } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridRowCount_excluded
                        );

                    const apiRef = useGridApiContext();
                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes = GridRowCount_useUtilityClasses(ownerState);

                    if (rowCount === 0) {
                        return null;
                    }

                    const text =
                        visibleRowCount < rowCount
                            ? apiRef.current.getLocaleText(
                                  "footerTotalVisibleRows"
                              )(visibleRowCount, rowCount)
                            : rowCount.toLocaleString();
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        GridRowCountRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other,
                            {
                                children: [
                                    apiRef.current.getLocaleText(
                                        "footerTotalRows"
                                    ),
                                    " ",
                                    text,
                                ],
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridSelectedRowCount.js

            const GridSelectedRowCount_excluded = [
                "className",
                "selectedRowCount",
            ];

            const GridSelectedRowCount_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["selectedRowCount"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridSelectedRowCountRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "SelectedRowCount",
                    overridesResolver: (props, styles) =>
                        styles.selectedRowCount,
                }
            )(({ theme }) => ({
                alignItems: "center",
                display: "flex",
                margin: theme.spacing(0, 2),
                visibility: "hidden",
                width: 0,
                height: 0,
                [theme.breakpoints.up("sm")]: {
                    visibility: "visible",
                    width: "auto",
                    height: "auto",
                },
            }));
            const GridSelectedRowCount = /*#__PURE__*/ react.forwardRef(
                function GridSelectedRowCount(props, ref) {
                    const { className, selectedRowCount } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridSelectedRowCount_excluded
                        );

                    const apiRef = useGridApiContext();
                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridSelectedRowCount_useUtilityClasses(ownerState);
                    const rowSelectedText =
                        apiRef.current.getLocaleText("footerRowSelected")(
                            selectedRowCount
                        );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridSelectedRowCountRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other,
                            {
                                children: rowSelectedText,
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/containers/GridFooterContainer.js

            const GridFooterContainer_excluded = ["className"];

            const GridFooterContainer_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["footerContainer"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridFooterContainerRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "FooterContainer",
                    overridesResolver: (props, styles) =>
                        styles.footerContainer,
                }
            )(({ theme }) => {
                const borderColor =
                    theme.palette.mode === "light"
                        ? (0, colorManipulator /* lighten */.$n)(
                              (0, colorManipulator /* alpha */.Fq)(
                                  theme.palette.divider,
                                  1
                              ),
                              0.88
                          )
                        : (0, colorManipulator /* darken */._j)(
                              (0, colorManipulator /* alpha */.Fq)(
                                  theme.palette.divider,
                                  1
                              ),
                              0.68
                          );
                return {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    minHeight: 52,
                    // Match TablePagination min height
                    borderTop: `1px solid ${borderColor}`,
                };
            });
            const GridFooterContainer = /*#__PURE__*/ react.forwardRef(
                function GridFooterContainer(props, ref) {
                    const { className } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridFooterContainer_excluded
                        );

                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridFooterContainer_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridFooterContainerRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridFooter.js
            const GridFooter = /*#__PURE__*/ react.forwardRef(
                function GridFooter(props, ref) {
                    var _rootProps$components;

                    const apiRef = useGridApiContext();
                    const rootProps = useGridRootProps();
                    const totalTopLevelRowCount = useGridSelector(
                        apiRef,
                        gridTopLevelRowCountSelector
                    );
                    const selectedRowCount = useGridSelector(
                        apiRef,
                        selectedGridRowsCountSelector
                    );
                    const visibleTopLevelRowCount = useGridSelector(
                        apiRef,
                        gridVisibleTopLevelRowCountSelector
                    );
                    const selectedRowCountElement =
                        !rootProps.hideFooterSelectedRowCount &&
                        selectedRowCount > 0
                            ? /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                  GridSelectedRowCount,
                                  {
                                      selectedRowCount: selectedRowCount,
                                  }
                              )
                            : /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {});
                    const rowCountElement =
                        !rootProps.hideFooterRowCount && !rootProps.pagination
                            ? /*#__PURE__*/ (0, jsx_runtime.jsx)(GridRowCount, {
                                  rowCount: totalTopLevelRowCount,
                                  visibleRowCount: visibleTopLevelRowCount,
                              })
                            : null;

                    const paginationElement =
                        rootProps.pagination &&
                        !rootProps.hideFooterPagination &&
                        rootProps.components.Pagination &&
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            rootProps.components.Pagination,
                            (0, esm_extends /* default */.Z)(
                                {},
                                (_rootProps$components =
                                    rootProps.componentsProps) == null
                                    ? void 0
                                    : _rootProps$components.pagination
                            )
                        );

                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        GridFooterContainer,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            props,
                            {
                                children: [
                                    selectedRowCountElement,
                                    rowCountElement,
                                    paginationElement,
                                ],
                            }
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridHeader.js
            const GridHeader = /*#__PURE__*/ react.forwardRef(
                function GridHeader(props, ref) {
                    var _rootProps$components, _rootProps$components2;

                    const rootProps = useGridRootProps();
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        "div",
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            props,
                            {
                                children: [
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        rootProps.components.PreferencesPanel,
                                        (0, esm_extends /* default */.Z)(
                                            {},
                                            (_rootProps$components =
                                                rootProps.componentsProps) ==
                                                null
                                                ? void 0
                                                : _rootProps$components.preferencesPanel
                                        )
                                    ),
                                    rootProps.components.Toolbar &&
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            rootProps.components.Toolbar,
                                            (0, esm_extends /* default */.Z)(
                                                {},
                                                (_rootProps$components2 =
                                                    rootProps.componentsProps) ==
                                                    null
                                                    ? void 0
                                                    : _rootProps$components2.toolbar
                                            )
                                        ),
                                ],
                            }
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/GridPreferencesPanel.js
            const GridPreferencesPanel = /*#__PURE__*/ react.forwardRef(
                function GridPreferencesPanel(props, ref) {
                    var _preferencePanelState,
                        _rootProps$components,
                        _rootProps$components2;

                    const apiRef = useGridApiContext();
                    const columns = useGridSelector(
                        apiRef,
                        gridColumnDefinitionsSelector
                    );
                    const rootProps = useGridRootProps();
                    const preferencePanelState = useGridSelector(
                        apiRef,
                        gridPreferencePanelStateSelector
                    );
                    const panelContent =
                        apiRef.current.unstable_applyPipeProcessors(
                            "preferencePanel",
                            null,
                            (_preferencePanelState =
                                preferencePanelState.openedPanelValue) != null
                                ? _preferencePanelState
                                : GridPreferencePanelsValue.filters
                        );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        rootProps.components.Panel,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                as: rootProps.components.BasePopper,
                                open:
                                    columns.length > 0 &&
                                    preferencePanelState.open,
                            },
                            (_rootProps$components =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components.panel,
                            props,
                            (_rootProps$components2 =
                                rootProps.componentsProps) == null
                                ? void 0
                                : _rootProps$components2.basePopper,
                            {
                                children: panelContent,
                            }
                        )
                    );
                }
            );
            // EXTERNAL MODULE: ./node_modules/@emotion/react/dist/emotion-react.browser.esm.js
            var emotion_react_browser_esm = __webpack_require__(917); // CONCATENATED MODULE: ./node_modules/@mui/material/CircularProgress/circularProgressClasses.js
            function getCircularProgressUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiCircularProgress",
                    slot
                );
            }
            const circularProgressClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiCircularProgress", [
                "root",
                "determinate",
                "indeterminate",
                "colorPrimary",
                "colorSecondary",
                "svg",
                "circle",
                "circleDeterminate",
                "circleIndeterminate",
                "circleDisableShrink",
            ]);
            /* harmony default export */ var CircularProgress_circularProgressClasses =
                /* unused pure expression or super */ null &&
                circularProgressClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/CircularProgress/CircularProgress.js
            const CircularProgress_excluded = [
                "className",
                "color",
                "disableShrink",
                "size",
                "style",
                "thickness",
                "value",
                "variant",
            ];

            let _ = (t) => t,
                _t,
                _t2,
                _t3,
                _t4;

            const SIZE = 44;
            const circularRotateKeyframe = (0,
            emotion_react_browser_esm /* keyframes */.F4)(
                _t ||
                    (_t = _`
0% {
transform: rotate(0deg);
}

100% {
transform: rotate(360deg);
}
`)
            );
            const circularDashKeyframe = (0,
            emotion_react_browser_esm /* keyframes */.F4)(
                _t2 ||
                    (_t2 = _`
0% {
stroke-dasharray: 1px, 200px;
stroke-dashoffset: 0;
}

50% {
stroke-dasharray: 100px, 200px;
stroke-dashoffset: -15px;
}

100% {
stroke-dasharray: 100px, 200px;
stroke-dashoffset: -125px;
}
`)
            );

            const CircularProgress_useUtilityClasses = (ownerState) => {
                const { classes, variant, color, disableShrink } = ownerState;
                const slots = {
                    root: [
                        "root",
                        variant,
                        `color${(0, capitalize /* default */.Z)(color)}`,
                    ],
                    svg: ["svg"],
                    circle: [
                        "circle",
                        `circle${(0, capitalize /* default */.Z)(variant)}`,
                        disableShrink && "circleDisableShrink",
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getCircularProgressUtilityClass,
                    classes
                );
            };

            const CircularProgressRoot = (0, styled /* default */.ZP)("span", {
                name: "MuiCircularProgress",
                slot: "Root",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.root,
                        styles[ownerState.variant],
                        styles[
                            `color${(0, capitalize /* default */.Z)(
                                ownerState.color
                            )}`
                        ],
                    ];
                },
            })(
                ({ ownerState, theme }) =>
                    (0, esm_extends /* default */.Z)(
                        {
                            display: "inline-block",
                        },
                        ownerState.variant === "determinate" && {
                            transition: theme.transitions.create("transform"),
                        },
                        ownerState.color !== "inherit" && {
                            color: (theme.vars || theme).palette[
                                ownerState.color
                            ].main,
                        }
                    ),
                ({ ownerState }) =>
                    ownerState.variant === "indeterminate" &&
                    (0, emotion_react_browser_esm /* css */.iv)(
                        _t3 ||
                            (_t3 = _`
  animation: ${0} 1.4s linear infinite;
`),
                        circularRotateKeyframe
                    )
            );
            const CircularProgressSVG = (0, styled /* default */.ZP)("svg", {
                name: "MuiCircularProgress",
                slot: "Svg",
                overridesResolver: (props, styles) => styles.svg,
            })({
                display: "block", // Keeps the progress centered
            });
            const CircularProgressCircle = (0, styled /* default */.ZP)(
                "circle",
                {
                    name: "MuiCircularProgress",
                    slot: "Circle",
                    overridesResolver: (props, styles) => {
                        const { ownerState } = props;
                        return [
                            styles.circle,
                            styles[
                                `circle${(0, capitalize /* default */.Z)(
                                    ownerState.variant
                                )}`
                            ],
                            ownerState.disableShrink &&
                                styles.circleDisableShrink,
                        ];
                    },
                }
            )(
                ({ ownerState, theme }) =>
                    (0, esm_extends /* default */.Z)(
                        {
                            stroke: "currentColor",
                        },
                        ownerState.variant === "determinate" && {
                            transition:
                                theme.transitions.create("stroke-dashoffset"),
                        },
                        ownerState.variant === "indeterminate" && {
                            // Some default value that looks fine waiting for the animation to kicks in.
                            strokeDasharray: "80px, 200px",
                            strokeDashoffset: 0, // Add the unit to fix a Edge 16 and below bug.
                        }
                    ),
                ({ ownerState }) =>
                    ownerState.variant === "indeterminate" &&
                    !ownerState.disableShrink &&
                    (0, emotion_react_browser_esm /* css */.iv)(
                        _t4 ||
                            (_t4 = _`
  animation: ${0} 1.4s ease-in-out infinite;
`),
                        circularDashKeyframe
                    )
            );
            /**
             * ## ARIA
             *
             * If the progress bar is describing the loading progress of a particular region of a page,
             * you should use `aria-describedby` to point to the progress bar, and set the `aria-busy`
             * attribute to `true` on that region until it has finished loading.
             */

            const CircularProgress = /*#__PURE__*/ react.forwardRef(
                function CircularProgress(inProps, ref) {
                    const props = (0, useThemeProps /* default */.Z)({
                        props: inProps,
                        name: "MuiCircularProgress",
                    });

                    const {
                            className,
                            color = "primary",
                            disableShrink = false,
                            size = 40,
                            style,
                            thickness = 3.6,
                            value = 0,
                            variant = "indeterminate",
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            CircularProgress_excluded
                        );

                    const ownerState = (0, esm_extends /* default */.Z)(
                        {},
                        props,
                        {
                            color,
                            disableShrink,
                            size,
                            thickness,
                            value,
                            variant,
                        }
                    );

                    const classes =
                        CircularProgress_useUtilityClasses(ownerState);
                    const circleStyle = {};
                    const rootStyle = {};
                    const rootProps = {};

                    if (variant === "determinate") {
                        const circumference =
                            2 * Math.PI * ((SIZE - thickness) / 2);
                        circleStyle.strokeDasharray = circumference.toFixed(3);
                        rootProps["aria-valuenow"] = Math.round(value);
                        circleStyle.strokeDashoffset = `${(
                            ((100 - value) / 100) *
                            circumference
                        ).toFixed(3)}px`;
                        rootStyle.transform = "rotate(-90deg)";
                    }

                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        CircularProgressRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                                style: (0, esm_extends /* default */.Z)(
                                    {
                                        width: size,
                                        height: size,
                                    },
                                    rootStyle,
                                    style
                                ),
                                ownerState: ownerState,
                                ref: ref,
                                role: "progressbar",
                            },
                            rootProps,
                            other,
                            {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    CircularProgressSVG,
                                    {
                                        className: classes.svg,
                                        ownerState: ownerState,
                                        viewBox: `${SIZE / 2} ${
                                            SIZE / 2
                                        } ${SIZE} ${SIZE}`,
                                        children: /*#__PURE__*/ (0,
                                        jsx_runtime.jsx)(
                                            CircularProgressCircle,
                                            {
                                                className: classes.circle,
                                                style: circleStyle,
                                                ownerState: ownerState,
                                                cx: SIZE,
                                                cy: SIZE,
                                                r: (SIZE - thickness) / 2,
                                                fill: "none",
                                                strokeWidth: thickness,
                                            }
                                        ),
                                    }
                                ),
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var CircularProgress_CircularProgress =
                CircularProgress; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/containers/GridOverlay.js
            const GridOverlay_excluded = ["className"];

            const GridOverlay_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["overlay"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridOverlayRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "Overlay",
                overridesResolver: (props, styles) => styles.overlay,
            })(({ theme }) => ({
                display: "flex",
                height: "100%",
                alignSelf: "center",
                alignItems: "center",
                justifyContent: "center",
                backgroundColor: (0, colorManipulator /* alpha */.Fq)(
                    theme.palette.background.default,
                    theme.palette.action.disabledOpacity
                ),
            }));
            const GridOverlay = /*#__PURE__*/ react.forwardRef(
                function GridOverlay(props, ref) {
                    const { className } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridOverlay_excluded
                        );

                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes = GridOverlay_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridOverlayRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridLoadingOverlay.js

            const GridLoadingOverlay = /*#__PURE__*/ react.forwardRef(
                function GridLoadingOverlay(props, ref) {
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridOverlay,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            props,
                            {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    CircularProgress_CircularProgress,
                                    {}
                                ),
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridNoRowsOverlay.js

            const GridNoRowsOverlay = /*#__PURE__*/ react.forwardRef(
                function GridNoRowsOverlay(props, ref) {
                    const apiRef = useGridApiContext();
                    const noRowsLabel =
                        apiRef.current.getLocaleText("noRowsLabel");
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridOverlay,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            props,
                            {
                                children: noRowsLabel,
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;

            // EXTERNAL MODULE: ./node_modules/@mui/base/utils/isHostComponent.js
            var isHostComponent = __webpack_require__(8442); // CONCATENATED MODULE: ./node_modules/@mui/material/Table/TableContext.js
            /**
             * @ignore - internal component.
             */

            const TableContext = /*#__PURE__*/ react.createContext();

            if (false) {
            }

            /* harmony default export */ var Table_TableContext = TableContext; // CONCATENATED MODULE: ./node_modules/@mui/material/Table/Tablelvl2Context.js
            /**
             * @ignore - internal component.
             */

            const Tablelvl2Context = /*#__PURE__*/ react.createContext();

            if (false) {
            }

            /* harmony default export */ var Table_Tablelvl2Context =
                Tablelvl2Context; // CONCATENATED MODULE: ./node_modules/@mui/material/TableCell/tableCellClasses.js
            function getTableCellUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiTableCell",
                    slot
                );
            }
            const tableCellClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiTableCell", [
                "root",
                "head",
                "body",
                "footer",
                "sizeSmall",
                "sizeMedium",
                "paddingCheckbox",
                "paddingNone",
                "alignLeft",
                "alignCenter",
                "alignRight",
                "alignJustify",
                "stickyHeader",
            ]);
            /* harmony default export */ var TableCell_tableCellClasses =
                tableCellClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/TableCell/TableCell.js
            const TableCell_excluded = [
                "align",
                "className",
                "component",
                "padding",
                "scope",
                "size",
                "sortDirection",
                "variant",
            ];

            const TableCell_useUtilityClasses = (ownerState) => {
                const { classes, variant, align, padding, size, stickyHeader } =
                    ownerState;
                const slots = {
                    root: [
                        "root",
                        variant,
                        stickyHeader && "stickyHeader",
                        align !== "inherit" &&
                            `align${(0, capitalize /* default */.Z)(align)}`,
                        padding !== "normal" &&
                            `padding${(0, capitalize /* default */.Z)(
                                padding
                            )}`,
                        `size${(0, capitalize /* default */.Z)(size)}`,
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getTableCellUtilityClass,
                    classes
                );
            };

            const TableCellRoot = (0, styled /* default */.ZP)("td", {
                name: "MuiTableCell",
                slot: "Root",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.root,
                        styles[ownerState.variant],
                        styles[
                            `size${(0, capitalize /* default */.Z)(
                                ownerState.size
                            )}`
                        ],
                        ownerState.padding !== "normal" &&
                            styles[
                                `padding${(0, capitalize /* default */.Z)(
                                    ownerState.padding
                                )}`
                            ],
                        ownerState.align !== "inherit" &&
                            styles[
                                `align${(0, capitalize /* default */.Z)(
                                    ownerState.align
                                )}`
                            ],
                        ownerState.stickyHeader && styles.stickyHeader,
                    ];
                },
            })(({ theme, ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {},
                    theme.typography.body2,
                    {
                        display: "table-cell",
                        verticalAlign: "inherit",
                        // Workaround for a rendering bug with spanned columns in Chrome 62.0.
                        // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
                        borderBottom: `1px solid
${
    theme.palette.mode === "light"
        ? (0, colorManipulator /* lighten */.$n)(
              (0, colorManipulator /* alpha */.Fq)(theme.palette.divider, 1),
              0.88
          )
        : (0, colorManipulator /* darken */._j)(
              (0, colorManipulator /* alpha */.Fq)(theme.palette.divider, 1),
              0.68
          )
}`,
                        textAlign: "left",
                        padding: 16,
                    },
                    ownerState.variant === "head" && {
                        color: theme.palette.text.primary,
                        lineHeight: theme.typography.pxToRem(24),
                        fontWeight: theme.typography.fontWeightMedium,
                    },
                    ownerState.variant === "body" && {
                        color: theme.palette.text.primary,
                    },
                    ownerState.variant === "footer" && {
                        color: theme.palette.text.secondary,
                        lineHeight: theme.typography.pxToRem(21),
                        fontSize: theme.typography.pxToRem(12),
                    },
                    ownerState.size === "small" && {
                        padding: "6px 16px",
                        [`&.${TableCell_tableCellClasses.paddingCheckbox}`]: {
                            width: 24,
                            // prevent the checkbox column from growing
                            padding: "0 12px 0 16px",
                            "& > *": {
                                padding: 0,
                            },
                        },
                    },
                    ownerState.padding === "checkbox" && {
                        width: 48,
                        // prevent the checkbox column from growing
                        padding: "0 0 0 4px",
                    },
                    ownerState.padding === "none" && {
                        padding: 0,
                    },
                    ownerState.align === "left" && {
                        textAlign: "left",
                    },
                    ownerState.align === "center" && {
                        textAlign: "center",
                    },
                    ownerState.align === "right" && {
                        textAlign: "right",
                        flexDirection: "row-reverse",
                    },
                    ownerState.align === "justify" && {
                        textAlign: "justify",
                    },
                    ownerState.stickyHeader && {
                        position: "sticky",
                        top: 0,
                        zIndex: 2,
                        backgroundColor: theme.palette.background.default,
                    }
                )
            );
            /**
             * The component renders a `<th>` element when the parent context is a header
             * or otherwise a `<td>` element.
             */

            const TableCell = /*#__PURE__*/ react.forwardRef(function TableCell(
                inProps,
                ref
            ) {
                const props = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiTableCell",
                });

                const {
                        align = "inherit",
                        className,
                        component: componentProp,
                        padding: paddingProp,
                        scope: scopeProp,
                        size: sizeProp,
                        sortDirection,
                        variant: variantProp,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        TableCell_excluded
                    );

                const table = react.useContext(Table_TableContext);
                const tablelvl2 = react.useContext(Table_Tablelvl2Context);
                const isHeadCell = tablelvl2 && tablelvl2.variant === "head";
                let component;

                if (componentProp) {
                    component = componentProp;
                } else {
                    component = isHeadCell ? "th" : "td";
                }

                let scope = scopeProp;

                if (!scope && isHeadCell) {
                    scope = "col";
                }

                const variant = variantProp || (tablelvl2 && tablelvl2.variant);

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    align,
                    component,
                    padding:
                        paddingProp ||
                        (table && table.padding ? table.padding : "normal"),
                    size:
                        sizeProp ||
                        (table && table.size ? table.size : "medium"),
                    sortDirection,
                    stickyHeader:
                        variant === "head" && table && table.stickyHeader,
                    variant,
                });

                const classes = TableCell_useUtilityClasses(ownerState);
                let ariaSort = null;

                if (sortDirection) {
                    ariaSort =
                        sortDirection === "asc" ? "ascending" : "descending";
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    TableCellRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            as: component,
                            ref: ref,
                            className: (0, clsx_m /* default */.Z)(
                                classes.root,
                                className
                            ),
                            "aria-sort": ariaSort,
                            scope: scope,
                            ownerState: ownerState,
                        },
                        other
                    )
                );
            });
            false ? 0 : void 0;
            /* harmony default export */ var TableCell_TableCell = TableCell; // CONCATENATED MODULE: ./node_modules/@mui/material/Toolbar/toolbarClasses.js
            function getToolbarUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiToolbar",
                    slot
                );
            }
            const toolbarClasses = (0, generateUtilityClasses /* default */.Z)(
                "MuiToolbar",
                ["root", "gutters", "regular", "dense"]
            );
            /* harmony default export */ var Toolbar_toolbarClasses =
                /* unused pure expression or super */ null && toolbarClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/Toolbar/Toolbar.js
            const Toolbar_excluded = [
                "className",
                "component",
                "disableGutters",
                "variant",
            ];

            const Toolbar_useUtilityClasses = (ownerState) => {
                const { classes, disableGutters, variant } = ownerState;
                const slots = {
                    root: ["root", !disableGutters && "gutters", variant],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getToolbarUtilityClass,
                    classes
                );
            };

            const ToolbarRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiToolbar",
                slot: "Root",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        styles.root,
                        !ownerState.disableGutters && styles.gutters,
                        styles[ownerState.variant],
                    ];
                },
            })(
                ({ theme, ownerState }) =>
                    (0, esm_extends /* default */.Z)(
                        {
                            position: "relative",
                            display: "flex",
                            alignItems: "center",
                        },
                        !ownerState.disableGutters && {
                            paddingLeft: theme.spacing(2),
                            paddingRight: theme.spacing(2),
                            [theme.breakpoints.up("sm")]: {
                                paddingLeft: theme.spacing(3),
                                paddingRight: theme.spacing(3),
                            },
                        },
                        ownerState.variant === "dense" && {
                            minHeight: 48,
                        }
                    ),
                ({ theme, ownerState }) =>
                    ownerState.variant === "regular" && theme.mixins.toolbar
            );
            const Toolbar = /*#__PURE__*/ react.forwardRef(function Toolbar(
                inProps,
                ref
            ) {
                const props = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiToolbar",
                });

                const {
                        className,
                        component = "div",
                        disableGutters = false,
                        variant = "regular",
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        Toolbar_excluded
                    );

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    component,
                    disableGutters,
                    variant,
                });

                const classes = Toolbar_useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    ToolbarRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            as: component,
                            className: (0, clsx_m /* default */.Z)(
                                classes.root,
                                className
                            ),
                            ref: ref,
                            ownerState: ownerState,
                        },
                        other
                    )
                );
            });
            false ? 0 : void 0;
            /* harmony default export */ var Toolbar_Toolbar = Toolbar; // CONCATENATED MODULE: ./node_modules/@mui/material/internal/svg-icons/KeyboardArrowLeft.js
            /**
             * @ignore - internal component.
             */

            /* harmony default export */ var KeyboardArrowLeft = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z",
                }),
                "KeyboardArrowLeft"
            ); // CONCATENATED MODULE: ./node_modules/@mui/material/internal/svg-icons/KeyboardArrowRight.js
            /**
             * @ignore - internal component.
             */

            /* harmony default export */ var KeyboardArrowRight = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z",
                }),
                "KeyboardArrowRight"
            );
            // EXTERNAL MODULE: ./node_modules/@mui/material/styles/useTheme.js
            var useTheme = __webpack_require__(2734); // CONCATENATED MODULE: ./node_modules/@mui/material/internal/svg-icons/LastPage.js
            /**
             * @ignore - internal component.
             */

            /* harmony default export */ var LastPage = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z",
                }),
                "LastPage"
            ); // CONCATENATED MODULE: ./node_modules/@mui/material/internal/svg-icons/FirstPage.js
            /**
             * @ignore - internal component.
             */

            /* harmony default export */ var FirstPage = (0,
            createSvgIcon /* default */.Z)(
                /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                    d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z",
                }),
                "FirstPage"
            ); // CONCATENATED MODULE: ./node_modules/@mui/material/TablePagination/TablePaginationActions.js
            var _LastPageIcon,
                _FirstPageIcon,
                _KeyboardArrowRight,
                _KeyboardArrowLeft,
                _KeyboardArrowLeft2,
                _KeyboardArrowRight2,
                _FirstPageIcon2,
                _LastPageIcon2;

            const TablePaginationActions_excluded = [
                "backIconButtonProps",
                "count",
                "getItemAriaLabel",
                "nextIconButtonProps",
                "onPageChange",
                "page",
                "rowsPerPage",
                "showFirstButton",
                "showLastButton",
            ];

            /**
             * @ignore - internal component.
             */

            const TablePaginationActions = /*#__PURE__*/ react.forwardRef(
                function TablePaginationActions(props, ref) {
                    const {
                            backIconButtonProps,
                            count,
                            getItemAriaLabel,
                            nextIconButtonProps,
                            onPageChange,
                            page,
                            rowsPerPage,
                            showFirstButton,
                            showLastButton,
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            TablePaginationActions_excluded
                        );

                    const theme = (0, useTheme /* default */.Z)();

                    const handleFirstPageButtonClick = (event) => {
                        onPageChange(event, 0);
                    };

                    const handleBackButtonClick = (event) => {
                        onPageChange(event, page - 1);
                    };

                    const handleNextButtonClick = (event) => {
                        onPageChange(event, page + 1);
                    };

                    const handleLastPageButtonClick = (event) => {
                        onPageChange(
                            event,
                            Math.max(0, Math.ceil(count / rowsPerPage) - 1)
                        );
                    };

                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        "div",
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            other,
                            {
                                children: [
                                    showFirstButton &&
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            IconButton /* default */.Z,
                                            {
                                                onClick:
                                                    handleFirstPageButtonClick,
                                                disabled: page === 0,
                                                "aria-label": getItemAriaLabel(
                                                    "first",
                                                    page
                                                ),
                                                title: getItemAriaLabel(
                                                    "first",
                                                    page
                                                ),
                                                children:
                                                    theme.direction === "rtl"
                                                        ? _LastPageIcon ||
                                                          (_LastPageIcon =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  LastPage,
                                                                  {}
                                                              ))
                                                        : _FirstPageIcon ||
                                                          (_FirstPageIcon =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  FirstPage,
                                                                  {}
                                                              )),
                                            }
                                        ),
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        IconButton /* default */.Z,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                onClick: handleBackButtonClick,
                                                disabled: page === 0,
                                                color: "inherit",
                                                "aria-label": getItemAriaLabel(
                                                    "previous",
                                                    page
                                                ),
                                                title: getItemAriaLabel(
                                                    "previous",
                                                    page
                                                ),
                                            },
                                            backIconButtonProps,
                                            {
                                                children:
                                                    theme.direction === "rtl"
                                                        ? _KeyboardArrowRight ||
                                                          (_KeyboardArrowRight =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  KeyboardArrowRight,
                                                                  {}
                                                              ))
                                                        : _KeyboardArrowLeft ||
                                                          (_KeyboardArrowLeft =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  KeyboardArrowLeft,
                                                                  {}
                                                              )),
                                            }
                                        )
                                    ),
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        IconButton /* default */.Z,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                onClick: handleNextButtonClick,
                                                disabled:
                                                    count !== -1
                                                        ? page >=
                                                          Math.ceil(
                                                              count /
                                                                  rowsPerPage
                                                          ) -
                                                              1
                                                        : false,
                                                color: "inherit",
                                                "aria-label": getItemAriaLabel(
                                                    "next",
                                                    page
                                                ),
                                                title: getItemAriaLabel(
                                                    "next",
                                                    page
                                                ),
                                            },
                                            nextIconButtonProps,
                                            {
                                                children:
                                                    theme.direction === "rtl"
                                                        ? _KeyboardArrowLeft2 ||
                                                          (_KeyboardArrowLeft2 =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  KeyboardArrowLeft,
                                                                  {}
                                                              ))
                                                        : _KeyboardArrowRight2 ||
                                                          (_KeyboardArrowRight2 =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  KeyboardArrowRight,
                                                                  {}
                                                              )),
                                            }
                                        )
                                    ),
                                    showLastButton &&
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            IconButton /* default */.Z,
                                            {
                                                onClick:
                                                    handleLastPageButtonClick,
                                                disabled:
                                                    page >=
                                                    Math.ceil(
                                                        count / rowsPerPage
                                                    ) -
                                                        1,
                                                "aria-label": getItemAriaLabel(
                                                    "last",
                                                    page
                                                ),
                                                title: getItemAriaLabel(
                                                    "last",
                                                    page
                                                ),
                                                children:
                                                    theme.direction === "rtl"
                                                        ? _FirstPageIcon2 ||
                                                          (_FirstPageIcon2 =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  FirstPage,
                                                                  {}
                                                              ))
                                                        : _LastPageIcon2 ||
                                                          (_LastPageIcon2 =
                                                              /*#__PURE__*/ (0,
                                                              jsx_runtime.jsx)(
                                                                  LastPage,
                                                                  {}
                                                              )),
                                            }
                                        ),
                                ],
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var TablePagination_TablePaginationActions =
                TablePaginationActions; // CONCATENATED MODULE: ./node_modules/@mui/material/TablePagination/tablePaginationClasses.js
            function getTablePaginationUtilityClass(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiTablePagination",
                    slot
                );
            }
            const tablePaginationClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiTablePagination", [
                "root",
                "toolbar",
                "spacer",
                "selectLabel",
                "selectRoot",
                "select",
                "selectIcon",
                "input",
                "menuItem",
                "displayedRows",
                "actions",
            ]);
            /* harmony default export */ var TablePagination_tablePaginationClasses =
                tablePaginationClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/TablePagination/TablePagination.js
            var _InputBase;

            const TablePagination_excluded = [
                "ActionsComponent",
                "backIconButtonProps",
                "className",
                "colSpan",
                "component",
                "count",
                "getItemAriaLabel",
                "labelDisplayedRows",
                "labelRowsPerPage",
                "nextIconButtonProps",
                "onPageChange",
                "onRowsPerPageChange",
                "page",
                "rowsPerPage",
                "rowsPerPageOptions",
                "SelectProps",
                "showFirstButton",
                "showLastButton",
            ];

            const TablePaginationRoot = (0, styled /* default */.ZP)(
                TableCell_TableCell,
                {
                    name: "MuiTablePagination",
                    slot: "Root",
                    overridesResolver: (props, styles) => styles.root,
                }
            )(({ theme }) => ({
                overflow: "auto",
                color: theme.palette.text.primary,
                fontSize: theme.typography.pxToRem(14),
                // Increase the specificity to override TableCell.
                "&:last-child": {
                    padding: 0,
                },
            }));
            const TablePaginationToolbar = (0, styled /* default */.ZP)(
                Toolbar_Toolbar,
                {
                    name: "MuiTablePagination",
                    slot: "Toolbar",
                    overridesResolver: (props, styles) =>
                        (0, esm_extends /* default */.Z)(
                            {
                                [`& .${TablePagination_tablePaginationClasses.actions}`]:
                                    styles.actions,
                            },
                            styles.toolbar
                        ),
                }
            )(({ theme }) => ({
                minHeight: 52,
                paddingRight: 2,
                [`${theme.breakpoints.up("xs")} and (orientation: landscape)`]:
                    {
                        minHeight: 52,
                    },
                [theme.breakpoints.up("sm")]: {
                    minHeight: 52,
                    paddingRight: 2,
                },
                [`& .${TablePagination_tablePaginationClasses.actions}`]: {
                    flexShrink: 0,
                    marginLeft: 20,
                },
            }));
            const TablePaginationSpacer = (0, styled /* default */.ZP)("div", {
                name: "MuiTablePagination",
                slot: "Spacer",
                overridesResolver: (props, styles) => styles.spacer,
            })({
                flex: "1 1 100%",
            });
            const TablePaginationSelectLabel = (0, styled /* default */.ZP)(
                "p",
                {
                    name: "MuiTablePagination",
                    slot: "SelectLabel",
                    overridesResolver: (props, styles) => styles.selectLabel,
                }
            )(({ theme }) =>
                (0, esm_extends /* default */.Z)({}, theme.typography.body2, {
                    flexShrink: 0,
                })
            );
            const TablePaginationSelect = (0, styled /* default */.ZP)(
                Select /* default */.Z,
                {
                    name: "MuiTablePagination",
                    slot: "Select",
                    overridesResolver: (props, styles) =>
                        (0, esm_extends /* default */.Z)(
                            {
                                [`& .${TablePagination_tablePaginationClasses.selectIcon}`]:
                                    styles.selectIcon,
                                [`& .${TablePagination_tablePaginationClasses.select}`]:
                                    styles.select,
                            },
                            styles.input,
                            styles.selectRoot
                        ),
                }
            )({
                color: "inherit",
                fontSize: "inherit",
                flexShrink: 0,
                marginRight: 32,
                marginLeft: 8,
                [`& .${TablePagination_tablePaginationClasses.select}`]: {
                    paddingLeft: 8,
                    paddingRight: 24,
                    textAlign: "right",
                    textAlignLast: "right", // Align <select> on Chrome.
                },
            });
            const TablePaginationMenuItem = (0, styled /* default */.ZP)(
                MenuItem /* default */.Z,
                {
                    name: "MuiTablePagination",
                    slot: "MenuItem",
                    overridesResolver: (props, styles) => styles.menuItem,
                }
            )({});
            const TablePaginationDisplayedRows = (0, styled /* default */.ZP)(
                "p",
                {
                    name: "MuiTablePagination",
                    slot: "DisplayedRows",
                    overridesResolver: (props, styles) => styles.displayedRows,
                }
            )(({ theme }) =>
                (0, esm_extends /* default */.Z)({}, theme.typography.body2, {
                    flexShrink: 0,
                })
            );

            function defaultLabelDisplayedRows({ from, to, count }) {
                return `${from}${to} of ${
                    count !== -1 ? count : `more than ${to}`
                }`;
            }

            function defaultGetAriaLabel(type) {
                return `Go to ${type} page`;
            }

            const TablePagination_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["root"],
                    toolbar: ["toolbar"],
                    spacer: ["spacer"],
                    selectLabel: ["selectLabel"],
                    select: ["select"],
                    input: ["input"],
                    selectIcon: ["selectIcon"],
                    menuItem: ["menuItem"],
                    displayedRows: ["displayedRows"],
                    actions: ["actions"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getTablePaginationUtilityClass,
                    classes
                );
            };
            /**
             * A `TableCell` based component for placing inside `TableFooter` for pagination.
             */

            const TablePagination = /*#__PURE__*/ react.forwardRef(
                function TablePagination(inProps, ref) {
                    const props = (0, useThemeProps /* default */.Z)({
                        props: inProps,
                        name: "MuiTablePagination",
                    });

                    const {
                            ActionsComponent = TablePagination_TablePaginationActions,
                            backIconButtonProps,
                            className,
                            colSpan: colSpanProp,
                            component = TableCell_TableCell,
                            count,
                            getItemAriaLabel = defaultGetAriaLabel,
                            labelDisplayedRows = defaultLabelDisplayedRows,
                            labelRowsPerPage = "Rows per page:",
                            nextIconButtonProps,
                            onPageChange,
                            onRowsPerPageChange,
                            page,
                            rowsPerPage,
                            rowsPerPageOptions = [10, 25, 50, 100],
                            SelectProps = {},
                            showFirstButton = false,
                            showLastButton = false,
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            TablePagination_excluded
                        );

                    const ownerState = props;
                    const classes =
                        TablePagination_useUtilityClasses(ownerState);
                    const MenuItemComponent = SelectProps.native
                        ? "option"
                        : TablePaginationMenuItem;
                    let colSpan;

                    if (
                        component === TableCell_TableCell ||
                        component === "td"
                    ) {
                        colSpan = colSpanProp || 1000; // col-span over everything
                    }

                    const selectId = (0, useId /* default */.Z)(SelectProps.id);
                    const labelId = (0, useId /* default */.Z)(
                        SelectProps.labelId
                    );

                    const getLabelDisplayedRowsTo = () => {
                        if (count === -1) {
                            return (page + 1) * rowsPerPage;
                        }

                        return rowsPerPage === -1
                            ? count
                            : Math.min(count, (page + 1) * rowsPerPage);
                    };

                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        TablePaginationRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                colSpan: colSpan,
                                ref: ref,
                                as: component,
                                ownerState: ownerState,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other,
                            {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                                    TablePaginationToolbar,
                                    {
                                        className: classes.toolbar,
                                        children: [
                                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                                TablePaginationSpacer,
                                                {
                                                    className: classes.spacer,
                                                }
                                            ),
                                            rowsPerPageOptions.length > 1 &&
                                                /*#__PURE__*/ (0,
                                                jsx_runtime.jsx)(
                                                    TablePaginationSelectLabel,
                                                    {
                                                        className:
                                                            classes.selectLabel,
                                                        id: labelId,
                                                        children:
                                                            labelRowsPerPage,
                                                    }
                                                ),
                                            rowsPerPageOptions.length > 1 &&
                                                /*#__PURE__*/ (0,
                                                jsx_runtime.jsx)(
                                                    TablePaginationSelect,
                                                    (0,
                                                    esm_extends /* default */.Z)(
                                                        {
                                                            variant: "standard",
                                                            input:
                                                                _InputBase ||
                                                                (_InputBase =
                                                                    /*#__PURE__*/ (0,
                                                                    jsx_runtime.jsx)(
                                                                        InputBase /* default */.ZP,
                                                                        {}
                                                                    )),
                                                            value: rowsPerPage,
                                                            onChange:
                                                                onRowsPerPageChange,
                                                            id: selectId,
                                                            labelId: labelId,
                                                        },
                                                        SelectProps,
                                                        {
                                                            classes: (0,
                                                            esm_extends /* default */.Z)(
                                                                {},
                                                                SelectProps.classes,
                                                                {
                                                                    // TODO v5 remove `classes.input`
                                                                    root: (0,
                                                                    clsx_m /* default */.Z)(
                                                                        classes.input,
                                                                        classes.selectRoot,
                                                                        (
                                                                            SelectProps.classes ||
                                                                            {}
                                                                        ).root
                                                                    ),
                                                                    select: (0,
                                                                    clsx_m /* default */.Z)(
                                                                        classes.select,
                                                                        (
                                                                            SelectProps.classes ||
                                                                            {}
                                                                        ).select
                                                                    ),
                                                                    // TODO v5 remove `selectIcon`
                                                                    icon: (0,
                                                                    clsx_m /* default */.Z)(
                                                                        classes.selectIcon,
                                                                        (
                                                                            SelectProps.classes ||
                                                                            {}
                                                                        ).icon
                                                                    ),
                                                                }
                                                            ),
                                                            children:
                                                                rowsPerPageOptions.map(
                                                                    (
                                                                        rowsPerPageOption
                                                                    ) =>
                                                                        /*#__PURE__*/ (0,
                                                                        react.createElement)(
                                                                            MenuItemComponent,
                                                                            (0,
                                                                            esm_extends /* default */.Z)(
                                                                                {},
                                                                                !(0,
                                                                                isHostComponent /* default */.Z)(
                                                                                    MenuItemComponent
                                                                                ) && {
                                                                                    ownerState,
                                                                                },
                                                                                {
                                                                                    className:
                                                                                        classes.menuItem,
                                                                                    key: rowsPerPageOption.label
                                                                                        ? rowsPerPageOption.label
                                                                                        : rowsPerPageOption,
                                                                                    value: rowsPerPageOption.value
                                                                                        ? rowsPerPageOption.value
                                                                                        : rowsPerPageOption,
                                                                                }
                                                                            ),
                                                                            rowsPerPageOption.label
                                                                                ? rowsPerPageOption.label
                                                                                : rowsPerPageOption
                                                                        )
                                                                ),
                                                        }
                                                    )
                                                ),
                                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                                TablePaginationDisplayedRows,
                                                {
                                                    className:
                                                        classes.displayedRows,
                                                    children:
                                                        labelDisplayedRows({
                                                            from:
                                                                count === 0
                                                                    ? 0
                                                                    : page *
                                                                          rowsPerPage +
                                                                      1,
                                                            to: getLabelDisplayedRowsTo(),
                                                            count:
                                                                count === -1
                                                                    ? -1
                                                                    : count,
                                                            page,
                                                        }),
                                                }
                                            ),
                                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                                ActionsComponent,
                                                {
                                                    className: classes.actions,
                                                    backIconButtonProps:
                                                        backIconButtonProps,
                                                    count: count,
                                                    nextIconButtonProps:
                                                        nextIconButtonProps,
                                                    onPageChange: onPageChange,
                                                    page: page,
                                                    rowsPerPage: rowsPerPage,
                                                    showFirstButton:
                                                        showFirstButton,
                                                    showLastButton:
                                                        showLastButton,
                                                    getItemAriaLabel:
                                                        getItemAriaLabel,
                                                }
                                            ),
                                        ],
                                    }
                                ),
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var TablePagination_TablePagination =
                TablePagination; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridPagination.js
            const GridPaginationRoot = (0, styled /* default */.ZP)(
                TablePagination_TablePagination
            )(({ theme }) => ({
                [`& .${TablePagination_tablePaginationClasses.selectLabel}`]: {
                    display: "none",
                    [theme.breakpoints.up("sm")]: {
                        display: "block",
                    },
                },
                [`& .${TablePagination_tablePaginationClasses.input}`]: {
                    display: "none",
                    [theme.breakpoints.up("sm")]: {
                        display: "inline-flex",
                    },
                },
            }));
            const GridPagination = /*#__PURE__*/ react.forwardRef(
                function GridPagination(props, ref) {
                    var _rootProps$rowsPerPag;

                    const apiRef = useGridApiContext();
                    const rootProps = useGridRootProps();
                    const paginationState = useGridSelector(
                        apiRef,
                        gridPaginationSelector
                    );
                    const lastPage = react.useMemo(
                        () =>
                            Math.floor(
                                paginationState.rowCount /
                                    (paginationState.pageSize || 1)
                            ),
                        [paginationState.rowCount, paginationState.pageSize]
                    );
                    const handlePageSizeChange = react.useCallback(
                        (event) => {
                            const newPageSize = Number(event.target.value);
                            apiRef.current.setPageSize(newPageSize);
                        },
                        [apiRef]
                    );
                    const handlePageChange = react.useCallback(
                        (event, page) => {
                            apiRef.current.setPage(page);
                        },
                        [apiRef]
                    );

                    if (false) {
                        var _rootProps$pageSize2, _rootProps$pageSize;
                    }

                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridPaginationRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref, // @ts-ignore
                                component: "div",
                                count: paginationState.rowCount,
                                page:
                                    paginationState.page <= lastPage
                                        ? paginationState.page
                                        : lastPage,
                                rowsPerPageOptions:
                                    (_rootProps$rowsPerPag =
                                        rootProps.rowsPerPageOptions) != null &&
                                    _rootProps$rowsPerPag.includes(
                                        paginationState.pageSize
                                    )
                                        ? rootProps.rowsPerPageOptions
                                        : [],
                                rowsPerPage: paginationState.pageSize,
                                onPageChange: handlePageChange,
                                onRowsPerPageChange: handlePageSizeChange,
                            },
                            apiRef.current.getLocaleText("MuiTablePagination"),
                            props
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/GridPanelContent.js
            const GridPanelContent_excluded = ["className"];

            const GridPanelContent_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["panelContent"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridPanelContentRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "PanelContent",
                overridesResolver: (props, styles) => styles.panelContent,
            })({
                display: "flex",
                flexDirection: "column",
                overflow: "auto",
                flex: "1 1",
                maxHeight: 400,
            });
            function GridPanelContent(props) {
                const { className } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridPanelContent_excluded
                    );

                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridPanelContent_useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridPanelContentRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                classes.root
                            ),
                        },
                        other
                    )
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/GridPanelFooter.js
            const GridPanelFooter_excluded = ["className"];

            const GridPanelFooter_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["panelFooter"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridPanelFooterRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "PanelFooter",
                overridesResolver: (props, styles) => styles.panelFooter,
            })(({ theme }) => ({
                padding: theme.spacing(0.5),
                display: "flex",
                justifyContent: "space-between",
            }));
            function GridPanelFooter(props) {
                const { className } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridPanelFooter_excluded
                    );

                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridPanelFooter_useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridPanelFooterRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                classes.root
                            ),
                        },
                        other
                    )
                );
            }
            // EXTERNAL MODULE: ./node_modules/@mui/base/TrapFocus/TrapFocus.js
            var TrapFocus = __webpack_require__(9410); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/GridPanelWrapper.js
            const GridPanelWrapper_excluded = ["className"];

            const GridPanelWrapper_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["panelWrapper"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridPanelWrapperRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "PanelWrapper",
                overridesResolver: (props, styles) => styles.panelWrapper,
            })({
                display: "flex",
                flexDirection: "column",
                flex: 1,
                "&:focus": {
                    outline: 0,
                },
            });

            const isEnabled = () => true;

            function GridPanelWrapper(props) {
                const { className } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridPanelWrapper_excluded
                    );

                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridPanelWrapper_useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    TrapFocus /* default */.Z,
                    {
                        open: true,
                        disableEnforceFocus: true,
                        isEnabled: isEnabled,
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            GridPanelWrapperRoot,
                            (0, esm_extends /* default */.Z)(
                                {
                                    tabIndex: -1,
                                    className: (0, clsx_m /* default */.Z)(
                                        className,
                                        classes.root
                                    ),
                                },
                                other
                            )
                        ),
                    }
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterForm.js

            const GridFilterForm_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["filterForm"],
                    deleteIcon: ["filterFormDeleteIcon"],
                    linkOperatorInput: ["filterFormLinkOperatorInput"],
                    columnInput: ["filterFormColumnInput"],
                    operatorInput: ["filterFormOperatorInput"],
                    valueInput: ["filterFormValueInput"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridFilterFormRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "FilterForm",
                overridesResolver: (props, styles) => styles.filterForm,
            })(({ theme }) => ({
                display: "flex",
                padding: theme.spacing(1),
            }));
            const FilterFormDeleteIcon = (0, styled /* default */.ZP)(
                FormControl_FormControl,
                {
                    name: "MuiDataGrid",
                    slot: "FilterFormDeleteIcon",
                    overridesResolver: (_, styles) =>
                        styles.filterFormDeleteIcon,
                }
            )(({ theme }) => ({
                flexShrink: 0,
                justifyContent: "flex-end",
                marginRight: theme.spacing(0.5),
                marginBottom: theme.spacing(0.2),
            }));
            const FilterFormLinkOperatorInput = (0, styled /* default */.ZP)(
                FormControl_FormControl,
                {
                    name: "MuiDataGrid",
                    slot: "FilterFormLinkOperatorInput",
                    overridesResolver: (_, styles) =>
                        styles.filterFormLinkOperatorInput,
                }
            )({
                minWidth: 55,
                marginRight: 5,
                justifyContent: "end",
            });
            const FilterFormColumnInput = (0, styled /* default */.ZP)(
                FormControl_FormControl,
                {
                    name: "MuiDataGrid",
                    slot: "FilterFormColumnInput",
                    overridesResolver: (_, styles) =>
                        styles.filterFormColumnInput,
                }
            )({
                width: 150,
            });
            const FilterFormOperatorInput = (0, styled /* default */.ZP)(
                FormControl_FormControl,
                {
                    name: "MuiDataGrid",
                    slot: "FilterFormOperatorInput",
                    overridesResolver: (_, styles) =>
                        styles.filterFormOperatorInput,
                }
            )({
                width: 120,
            });
            const FilterFormValueInput = (0, styled /* default */.ZP)(
                FormControl_FormControl,
                {
                    name: "MuiDataGrid",
                    slot: "FilterFormValueInput",
                    overridesResolver: (_, styles) =>
                        styles.filterFormValueInput,
                }
            )({
                width: 190,
            });

            const getLinkOperatorLocaleKey = (linkOperator) => {
                switch (linkOperator) {
                    case GridLinkOperator.And:
                        return "filterPanelOperatorAnd";

                    case GridLinkOperator.Or:
                        return "filterPanelOperatorOr";

                    default:
                        throw new Error(
                            "MUI: Invalid `linkOperator` property in the `GridFilterPanel`."
                        );
                }
            };

            const getColumnLabel = (col) => col.headerName || col.field;

            const collator = new Intl.Collator();

            function GridFilterForm(props) {
                var _rootProps$components,
                    _rootProps$components2,
                    _baseSelectProps$nati,
                    _rootProps$components3,
                    _rootProps$components4,
                    _rootProps$components5,
                    _currentColumn$filter2;

                const {
                    item,
                    hasMultipleFilters,
                    deleteFilter,
                    applyFilterChanges,
                    multiFilterOperator,
                    showMultiFilterOperators,
                    disableMultiFilterOperator,
                    applyMultiFilterOperatorChanges,
                    focusElementRef,
                    linkOperators = [GridLinkOperator.And, GridLinkOperator.Or],
                    columnsSort,
                    deleteIconProps = {},
                    linkOperatorInputProps = {},
                    operatorInputProps = {},
                    columnInputProps = {},
                    valueInputProps = {},
                } = props;
                const apiRef = useGridApiContext();
                const filterableColumns = useGridSelector(
                    apiRef,
                    gridFilterableColumnDefinitionsSelector
                );
                const columnSelectId = (0, useId /* default */.Z)();
                const columnSelectLabelId = (0, useId /* default */.Z)();
                const operatorSelectId = (0, useId /* default */.Z)();
                const operatorSelectLabelId = (0, useId /* default */.Z)();
                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridFilterForm_useUtilityClasses(ownerState);
                const valueRef = react.useRef(null);
                const filterSelectorRef = react.useRef(null);
                const hasLinkOperatorColumn =
                    hasMultipleFilters && linkOperators.length > 0;
                const baseFormControlProps =
                    ((_rootProps$components = rootProps.componentsProps) == null
                        ? void 0
                        : _rootProps$components.baseFormControl) || {};
                const baseSelectProps =
                    ((_rootProps$components2 = rootProps.componentsProps) ==
                    null
                        ? void 0
                        : _rootProps$components2.baseSelect) || {};
                const isBaseSelectNative =
                    (_baseSelectProps$nati = baseSelectProps.native) != null
                        ? _baseSelectProps$nati
                        : true;
                const OptionComponent = isBaseSelectNative
                    ? "option"
                    : MenuItem /* default */.Z;
                const sortedFilterableColumns = react.useMemo(() => {
                    switch (columnsSort) {
                        case "asc":
                            return filterableColumns.sort((a, b) =>
                                collator.compare(
                                    getColumnLabel(a),
                                    getColumnLabel(b)
                                )
                            );

                        case "desc":
                            return filterableColumns.sort(
                                (a, b) =>
                                    -collator.compare(
                                        getColumnLabel(a),
                                        getColumnLabel(b)
                                    )
                            );

                        default:
                            return filterableColumns;
                    }
                }, [filterableColumns, columnsSort]);
                const currentColumn = item.columnField
                    ? apiRef.current.getColumn(item.columnField)
                    : null;
                const currentOperator = react.useMemo(() => {
                    var _currentColumn$filter;

                    if (!item.operatorValue || !currentColumn) {
                        return null;
                    }

                    return (_currentColumn$filter =
                        currentColumn.filterOperators) == null
                        ? void 0
                        : _currentColumn$filter.find(
                              (operator) =>
                                  operator.value === item.operatorValue
                          );
                }, [item, currentColumn]);
                const changeColumn = react.useCallback(
                    (event) => {
                        const columnField = event.target.value;
                        const column = apiRef.current.getColumn(columnField);

                        if (column.field === currentColumn.field) {
                            // column did not change
                            return;
                        } // try to keep the same operator when column change

                        const newOperator =
                            column.filterOperators.find(
                                (operator) =>
                                    operator.value === item.operatorValue
                            ) || column.filterOperators[0]; // Erase filter value if the input component is modified

                        const eraseItemValue =
                            !newOperator.InputComponent ||
                            newOperator.InputComponent !==
                                (currentOperator == null
                                    ? void 0
                                    : currentOperator.InputComponent);
                        applyFilterChanges(
                            (0, esm_extends /* default */.Z)({}, item, {
                                columnField,
                                operatorValue: newOperator.value,
                                value: eraseItemValue ? undefined : item.value,
                            })
                        );
                    },
                    [
                        apiRef,
                        applyFilterChanges,
                        item,
                        currentColumn,
                        currentOperator,
                    ]
                );
                const changeOperator = react.useCallback(
                    (event) => {
                        const operatorValue = event.target.value;
                        const newOperator =
                            currentColumn == null
                                ? void 0
                                : currentColumn.filterOperators.find(
                                      (operator) =>
                                          operator.value === operatorValue
                                  );
                        const eraseItemValue =
                            !(
                                newOperator != null &&
                                newOperator.InputComponent
                            ) ||
                            (newOperator == null
                                ? void 0
                                : newOperator.InputComponent) !==
                                (currentOperator == null
                                    ? void 0
                                    : currentOperator.InputComponent);
                        applyFilterChanges(
                            (0, esm_extends /* default */.Z)({}, item, {
                                operatorValue,
                                value: eraseItemValue ? undefined : item.value,
                            })
                        );
                    },
                    [applyFilterChanges, item, currentColumn, currentOperator]
                );
                const changeLinkOperator = react.useCallback(
                    (event) => {
                        const linkOperator =
                            event.target.value ===
                            GridLinkOperator.And.toString()
                                ? GridLinkOperator.And
                                : GridLinkOperator.Or;
                        applyMultiFilterOperatorChanges(linkOperator);
                    },
                    [applyMultiFilterOperatorChanges]
                );

                const handleDeleteFilter = () => {
                    if (rootProps.disableMultipleColumnsFiltering) {
                        if (item.value === undefined) {
                            deleteFilter(item);
                        } else {
                            // TODO v6: simplify the behavior by always remove the filter form
                            applyFilterChanges(
                                (0, esm_extends /* default */.Z)({}, item, {
                                    value: undefined,
                                })
                            );
                        }
                    } else {
                        deleteFilter(item);
                    }
                };

                react.useImperativeHandle(
                    focusElementRef,
                    () => ({
                        focus: () => {
                            if (
                                currentOperator != null &&
                                currentOperator.InputComponent
                            ) {
                                var _valueRef$current;

                                valueRef == null
                                    ? void 0
                                    : (_valueRef$current = valueRef.current) ==
                                      null
                                    ? void 0
                                    : _valueRef$current.focus();
                            } else {
                                filterSelectorRef.current.focus();
                            }
                        },
                    }),
                    [currentOperator]
                );
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(GridFilterFormRoot, {
                    className: classes.root,
                    children: [
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            FilterFormDeleteIcon,
                            (0, esm_extends /* default */.Z)(
                                {
                                    variant: "standard",
                                    as: rootProps.components.BaseFormControl,
                                },
                                baseFormControlProps,
                                deleteIconProps,
                                {
                                    className: (0, clsx_m /* default */.Z)(
                                        classes.deleteIcon,
                                        baseFormControlProps.className,
                                        deleteIconProps.className
                                    ),
                                    children: /*#__PURE__*/ (0,
                                    jsx_runtime.jsx)(
                                        IconButton /* default */.Z,
                                        {
                                            "aria-label":
                                                apiRef.current.getLocaleText(
                                                    "filterPanelDeleteIconLabel"
                                                ),
                                            title: apiRef.current.getLocaleText(
                                                "filterPanelDeleteIconLabel"
                                            ),
                                            onClick: handleDeleteFilter,
                                            size: "small",
                                            children: /*#__PURE__*/ (0,
                                            jsx_runtime.jsx)(
                                                rootProps.components
                                                    .FilterPanelDeleteIcon,
                                                {
                                                    fontSize: "small",
                                                }
                                            ),
                                        }
                                    ),
                                }
                            )
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            FilterFormLinkOperatorInput,
                            (0, esm_extends /* default */.Z)(
                                {
                                    variant: "standard",
                                    as: rootProps.components.BaseFormControl,
                                },
                                baseFormControlProps,
                                linkOperatorInputProps,
                                {
                                    sx: (0, esm_extends /* default */.Z)(
                                        {
                                            display: hasLinkOperatorColumn
                                                ? "flex"
                                                : "none",
                                            visibility: showMultiFilterOperators
                                                ? "visible"
                                                : "hidden",
                                        },
                                        baseFormControlProps.sx || {},
                                        linkOperatorInputProps.sx || {}
                                    ),
                                    className: (0, clsx_m /* default */.Z)(
                                        classes.linkOperatorInput,
                                        baseFormControlProps.className,
                                        linkOperatorInputProps.className
                                    ),
                                    children: /*#__PURE__*/ (0,
                                    jsx_runtime.jsx)(
                                        rootProps.components.BaseSelect,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                inputProps: {
                                                    "aria-label":
                                                        apiRef.current.getLocaleText(
                                                            "filterPanelLinkOperator"
                                                        ),
                                                },
                                                value: multiFilterOperator,
                                                onChange: changeLinkOperator,
                                                disabled:
                                                    !!disableMultiFilterOperator ||
                                                    linkOperators.length === 1,
                                                native: isBaseSelectNative,
                                            },
                                            (_rootProps$components3 =
                                                rootProps.componentsProps) ==
                                                null
                                                ? void 0
                                                : _rootProps$components3.baseSelect,
                                            {
                                                children: linkOperators.map(
                                                    (linkOperator) =>
                                                        /*#__PURE__*/ (0,
                                                        jsx_runtime.jsx)(
                                                            OptionComponent,
                                                            {
                                                                value: linkOperator.toString(),
                                                                children:
                                                                    apiRef.current.getLocaleText(
                                                                        getLinkOperatorLocaleKey(
                                                                            linkOperator
                                                                        )
                                                                    ),
                                                            },
                                                            linkOperator.toString()
                                                        )
                                                ),
                                            }
                                        )
                                    ),
                                }
                            )
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                            FilterFormColumnInput,
                            (0, esm_extends /* default */.Z)(
                                {
                                    variant: "standard",
                                    as: rootProps.components.BaseFormControl,
                                },
                                baseFormControlProps,
                                columnInputProps,
                                {
                                    className: (0, clsx_m /* default */.Z)(
                                        classes.columnInput,
                                        baseFormControlProps.className,
                                        columnInputProps.className
                                    ),
                                    children: [
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            InputLabel_InputLabel,
                                            {
                                                htmlFor: columnSelectId,
                                                id: columnSelectLabelId,
                                                children:
                                                    apiRef.current.getLocaleText(
                                                        "filterPanelColumns"
                                                    ),
                                            }
                                        ),
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            rootProps.components.BaseSelect,
                                            (0, esm_extends /* default */.Z)(
                                                {
                                                    labelId:
                                                        columnSelectLabelId,
                                                    id: columnSelectId,
                                                    label: apiRef.current.getLocaleText(
                                                        "filterPanelColumns"
                                                    ),
                                                    value:
                                                        item.columnField || "",
                                                    onChange: changeColumn,
                                                    native: isBaseSelectNative,
                                                },
                                                (_rootProps$components4 =
                                                    rootProps.componentsProps) ==
                                                    null
                                                    ? void 0
                                                    : _rootProps$components4.baseSelect,
                                                {
                                                    children:
                                                        sortedFilterableColumns.map(
                                                            (col) =>
                                                                /*#__PURE__*/ (0,
                                                                jsx_runtime.jsx)(
                                                                    OptionComponent,
                                                                    {
                                                                        value: col.field,
                                                                        children:
                                                                            getColumnLabel(
                                                                                col
                                                                            ),
                                                                    },
                                                                    col.field
                                                                )
                                                        ),
                                                }
                                            )
                                        ),
                                    ],
                                }
                            )
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                            FilterFormOperatorInput,
                            (0, esm_extends /* default */.Z)(
                                {
                                    variant: "standard",
                                    as: rootProps.components.BaseFormControl,
                                },
                                baseFormControlProps,
                                operatorInputProps,
                                {
                                    className: (0, clsx_m /* default */.Z)(
                                        classes.operatorInput,
                                        baseFormControlProps.className,
                                        operatorInputProps.className
                                    ),
                                    children: [
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            InputLabel_InputLabel,
                                            {
                                                htmlFor: operatorSelectId,
                                                id: operatorSelectLabelId,
                                                children:
                                                    apiRef.current.getLocaleText(
                                                        "filterPanelOperators"
                                                    ),
                                            }
                                        ),
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            rootProps.components.BaseSelect,
                                            (0, esm_extends /* default */.Z)(
                                                {
                                                    labelId:
                                                        operatorSelectLabelId,
                                                    label: apiRef.current.getLocaleText(
                                                        "filterPanelOperators"
                                                    ),
                                                    id: operatorSelectId,
                                                    value: item.operatorValue,
                                                    onChange: changeOperator,
                                                    native: isBaseSelectNative,
                                                    inputRef: filterSelectorRef,
                                                },
                                                (_rootProps$components5 =
                                                    rootProps.componentsProps) ==
                                                    null
                                                    ? void 0
                                                    : _rootProps$components5.baseSelect,
                                                {
                                                    children:
                                                        currentColumn == null
                                                            ? void 0
                                                            : (_currentColumn$filter2 =
                                                                  currentColumn.filterOperators) ==
                                                              null
                                                            ? void 0
                                                            : _currentColumn$filter2.map(
                                                                  (operator) =>
                                                                      /*#__PURE__*/ (0,
                                                                      jsx_runtime.jsx)(
                                                                          OptionComponent,
                                                                          {
                                                                              value: operator.value,
                                                                              children:
                                                                                  operator.label ||
                                                                                  apiRef.current.getLocaleText(
                                                                                      `filterOperator${(0,
                                                                                      capitalize /* default */.Z)(
                                                                                          operator.value
                                                                                      )}`
                                                                                  ),
                                                                          },
                                                                          operator.value
                                                                      )
                                                              ),
                                                }
                                            )
                                        ),
                                    ],
                                }
                            )
                        ),
                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            FilterFormValueInput,
                            (0, esm_extends /* default */.Z)(
                                {
                                    variant: "standard",
                                    as: rootProps.components.BaseFormControl,
                                },
                                baseFormControlProps,
                                valueInputProps,
                                {
                                    className: (0, clsx_m /* default */.Z)(
                                        classes.valueInput,
                                        baseFormControlProps.className,
                                        valueInputProps.className
                                    ),
                                    children:
                                        currentOperator != null &&
                                        currentOperator.InputComponent
                                            ? /*#__PURE__*/ (0,
                                              jsx_runtime.jsx)(
                                                  currentOperator.InputComponent,
                                                  (0,
                                                  esm_extends /* default */.Z)(
                                                      {
                                                          apiRef: apiRef,
                                                          item: item,
                                                          applyValue:
                                                              applyFilterChanges,
                                                          focusElementRef:
                                                              valueRef,
                                                      },
                                                      currentOperator.InputComponentProps
                                                  )
                                              )
                                            : null,
                                }
                            )
                        ),
                    ],
                });
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterPanel.js

            const GridFilterPanel_excluded = [
                "linkOperators",
                "columnsSort",
                "filterFormProps",
            ];

            function GridFilterPanel(props) {
                var _rootProps$components;

                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const filterModel = useGridSelector(
                    apiRef,
                    gridFilterModelSelector
                );
                const filterableColumns = useGridSelector(
                    apiRef,
                    gridFilterableColumnDefinitionsSelector
                );
                const lastFilterRef = react.useRef(null);

                const {
                        linkOperators = [
                            GridLinkOperator.And,
                            GridLinkOperator.Or,
                        ],
                        columnsSort,
                        filterFormProps,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridFilterPanel_excluded
                    );

                const applyFilter = react.useCallback(
                    (item) => {
                        apiRef.current.upsertFilterItem(item);
                    },
                    [apiRef]
                );
                const applyFilterLinkOperator = react.useCallback(
                    (operator) => {
                        apiRef.current.setFilterLinkOperator(operator);
                    },
                    [apiRef]
                );
                const getDefaultItem = react.useCallback(() => {
                    const firstColumnWithOperator = filterableColumns.find(
                        (colDef) => {
                            var _colDef$filterOperato;

                            return (_colDef$filterOperato =
                                colDef.filterOperators) == null
                                ? void 0
                                : _colDef$filterOperato.length;
                        }
                    );

                    if (!firstColumnWithOperator) {
                        return null;
                    }

                    return {
                        columnField: firstColumnWithOperator.field,
                        operatorValue:
                            firstColumnWithOperator.filterOperators[0].value,
                        id: Math.round(Math.random() * 1e5),
                    };
                }, [filterableColumns]);
                const items = react.useMemo(() => {
                    if (filterModel.items.length) {
                        return filterModel.items;
                    }

                    const defaultItem = getDefaultItem();
                    return defaultItem ? [defaultItem] : [];
                }, [filterModel.items, getDefaultItem]);
                const hasMultipleFilters = items.length > 1;

                const addNewFilter = () => {
                    const defaultItem = getDefaultItem();

                    if (!defaultItem) {
                        return;
                    }

                    apiRef.current.setFilterModel(
                        (0, esm_extends /* default */.Z)({}, filterModel, {
                            items: [...items, defaultItem],
                        })
                    );
                };

                const deleteFilter = react.useCallback(
                    (item) => {
                        const shouldCloseFilterPanel = items.length === 1;
                        apiRef.current.deleteFilterItem(item);

                        if (shouldCloseFilterPanel) {
                            apiRef.current.hideFilterPanel();
                        }
                    },
                    [apiRef, items.length]
                );
                react.useEffect(() => {
                    if (
                        linkOperators.length > 0 &&
                        filterModel.linkOperator &&
                        !linkOperators.includes(filterModel.linkOperator)
                    ) {
                        applyFilterLinkOperator(linkOperators[0]);
                    }
                }, [
                    linkOperators,
                    applyFilterLinkOperator,
                    filterModel.linkOperator,
                ]);
                react.useEffect(() => {
                    if (items.length > 0) {
                        lastFilterRef.current.focus();
                    }
                }, [items.length]);
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    GridPanelWrapper,
                    (0, esm_extends /* default */.Z)({}, other, {
                        children: [
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                GridPanelContent,
                                {
                                    children: items.map((item, index) =>
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            GridFilterForm,
                                            (0, esm_extends /* default */.Z)(
                                                {
                                                    item: item,
                                                    applyFilterChanges:
                                                        applyFilter,
                                                    deleteFilter: deleteFilter,
                                                    hasMultipleFilters:
                                                        hasMultipleFilters,
                                                    showMultiFilterOperators:
                                                        index > 0,
                                                    multiFilterOperator:
                                                        filterModel.linkOperator,
                                                    disableMultiFilterOperator:
                                                        index !== 1,
                                                    applyMultiFilterOperatorChanges:
                                                        applyFilterLinkOperator,
                                                    focusElementRef:
                                                        index ===
                                                        items.length - 1
                                                            ? lastFilterRef
                                                            : null,
                                                    linkOperators:
                                                        linkOperators,
                                                    columnsSort: columnsSort,
                                                },
                                                filterFormProps
                                            ),
                                            item.id == null ? index : item.id
                                        )
                                    ),
                                }
                            ),
                            !rootProps.disableMultipleColumnsFiltering &&
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    GridPanelFooter,
                                    {
                                        children: /*#__PURE__*/ (0,
                                        jsx_runtime.jsx)(
                                            rootProps.components.BaseButton,
                                            (0, esm_extends /* default */.Z)(
                                                {
                                                    onClick: addNewFilter,
                                                    startIcon: /*#__PURE__*/ (0,
                                                    jsx_runtime.jsx)(
                                                        GridAddIcon,
                                                        {}
                                                    ),
                                                    color: "primary",
                                                },
                                                (_rootProps$components =
                                                    rootProps.componentsProps) ==
                                                    null
                                                    ? void 0
                                                    : _rootProps$components.baseButton,
                                                {
                                                    children:
                                                        apiRef.current.getLocaleText(
                                                            "filterPanelAddFilter"
                                                        ),
                                                }
                                            )
                                        ),
                                    }
                                ),
                        ],
                    })
                );
            }

            false ? 0 : void 0;

            // EXTERNAL MODULE: ./node_modules/@mui/material/Typography/Typography.js + 1 modules
            var Typography = __webpack_require__(5861); // CONCATENATED MODULE: ./node_modules/@mui/material/FormControlLabel/formControlLabelClasses.js
            function getFormControlLabelUtilityClasses(slot) {
                return (0, generateUtilityClass /* default */.Z)(
                    "MuiFormControlLabel",
                    slot
                );
            }
            const formControlLabelClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiFormControlLabel", [
                "root",
                "labelPlacementStart",
                "labelPlacementTop",
                "labelPlacementBottom",
                "disabled",
                "label",
                "error",
            ]);
            /* harmony default export */ var FormControlLabel_formControlLabelClasses =
                formControlLabelClasses; // CONCATENATED MODULE: ./node_modules/@mui/material/FormControlLabel/FormControlLabel.js
            const FormControlLabel_excluded = [
                "checked",
                "className",
                "componentsProps",
                "control",
                "disabled",
                "disableTypography",
                "inputRef",
                "label",
                "labelPlacement",
                "name",
                "onChange",
                "value",
            ];

            const FormControlLabel_useUtilityClasses = (ownerState) => {
                const { classes, disabled, labelPlacement, error } = ownerState;
                const slots = {
                    root: [
                        "root",
                        disabled && "disabled",
                        `labelPlacement${(0, capitalize /* default */.Z)(
                            labelPlacement
                        )}`,
                        error && "error",
                    ],
                    label: ["label", disabled && "disabled"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getFormControlLabelUtilityClasses,
                    classes
                );
            };

            const FormControlLabelRoot = (0, styled /* default */.ZP)("label", {
                name: "MuiFormControlLabel",
                slot: "Root",
                overridesResolver: (props, styles) => {
                    const { ownerState } = props;
                    return [
                        {
                            [`& .${FormControlLabel_formControlLabelClasses.label}`]:
                                styles.label,
                        },
                        styles.root,
                        styles[
                            `labelPlacement${(0, capitalize /* default */.Z)(
                                ownerState.labelPlacement
                            )}`
                        ],
                    ];
                },
            })(({ theme, ownerState }) =>
                (0, esm_extends /* default */.Z)(
                    {
                        display: "inline-flex",
                        alignItems: "center",
                        cursor: "pointer",
                        // For correct alignment with the text.
                        verticalAlign: "middle",
                        WebkitTapHighlightColor: "transparent",
                        marginLeft: -11,
                        marginRight: 16,
                        // used for row presentation of radio/checkbox
                        [`&.${FormControlLabel_formControlLabelClasses.disabled}`]:
                            {
                                cursor: "default",
                            },
                    },
                    ownerState.labelPlacement === "start" && {
                        flexDirection: "row-reverse",
                        marginLeft: 16,
                        // used for row presentation of radio/checkbox
                        marginRight: -11,
                    },
                    ownerState.labelPlacement === "top" && {
                        flexDirection: "column-reverse",
                        marginLeft: 16,
                    },
                    ownerState.labelPlacement === "bottom" && {
                        flexDirection: "column",
                        marginLeft: 16,
                    },
                    {
                        [`& .${FormControlLabel_formControlLabelClasses.label}`]:
                            {
                                [`&.${FormControlLabel_formControlLabelClasses.disabled}`]:
                                    {
                                        color: theme.palette.text.disabled,
                                    },
                            },
                    }
                )
            );
            /**
             * Drop-in replacement of the `Radio`, `Switch` and `Checkbox` component.
             * Use this component if you want to display an extra label.
             */

            const FormControlLabel = /*#__PURE__*/ react.forwardRef(
                function FormControlLabel(inProps, ref) {
                    const props = (0, useThemeProps /* default */.Z)({
                        props: inProps,
                        name: "MuiFormControlLabel",
                    });

                    const {
                            className,
                            componentsProps = {},
                            control,
                            disabled: disabledProp,
                            disableTypography,
                            label: labelProp,
                            labelPlacement = "end",
                        } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            FormControlLabel_excluded
                        );

                    const muiFormControl = (0,
                    useFormControl /* default */.Z)();
                    let disabled = disabledProp;

                    if (
                        typeof disabled === "undefined" &&
                        typeof control.props.disabled !== "undefined"
                    ) {
                        disabled = control.props.disabled;
                    }

                    if (typeof disabled === "undefined" && muiFormControl) {
                        disabled = muiFormControl.disabled;
                    }

                    const controlProps = {
                        disabled,
                    };
                    [
                        "checked",
                        "name",
                        "onChange",
                        "value",
                        "inputRef",
                    ].forEach((key) => {
                        if (
                            typeof control.props[key] === "undefined" &&
                            typeof props[key] !== "undefined"
                        ) {
                            controlProps[key] = props[key];
                        }
                    });
                    const fcs = (0, formControlState /* default */.Z)({
                        props,
                        muiFormControl,
                        states: ["error"],
                    });

                    const ownerState = (0, esm_extends /* default */.Z)(
                        {},
                        props,
                        {
                            disabled,
                            labelPlacement,
                            error: fcs.error,
                        }
                    );

                    const classes =
                        FormControlLabel_useUtilityClasses(ownerState);
                    let label = labelProp;

                    if (
                        label != null &&
                        label.type !== Typography /* default */.Z &&
                        !disableTypography
                    ) {
                        label = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            Typography /* default */.Z,
                            (0, esm_extends /* default */.Z)(
                                {
                                    component: "span",
                                    className: classes.label,
                                },
                                componentsProps.typography,
                                {
                                    children: label,
                                }
                            )
                        );
                    }

                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        FormControlLabelRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                                ownerState: ownerState,
                                ref: ref,
                            },
                            other,
                            {
                                children: [
                                    /*#__PURE__*/ react.cloneElement(
                                        control,
                                        controlProps
                                    ),
                                    label,
                                ],
                            }
                        )
                    );
                }
            );
            false ? 0 : void 0;
            /* harmony default export */ var FormControlLabel_FormControlLabel =
                FormControlLabel; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/GridPanelHeader.js
            const GridPanelHeader_excluded = ["className"];

            const GridPanelHeader_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["panelHeader"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridPanelHeaderRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "PanelHeader",
                overridesResolver: (props, styles) => styles.panelHeader,
            })(({ theme }) => ({
                padding: theme.spacing(1),
            }));
            function GridPanelHeader(props) {
                const { className } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridPanelHeader_excluded
                    );

                const rootProps = useGridRootProps();
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridPanelHeader_useUtilityClasses(ownerState);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridPanelHeaderRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                classes.root
                            ),
                        },
                        other
                    )
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/constants/envConstants.js
            /* provided dependency */ var process = __webpack_require__(3454);
            // A guide to feature toggling.
            //
            // The feature toggle is:
            // - independent from the NODE_ENV
            // - isn't pruning code in production, as the objective is to eventually ship the code.
            // - doesn't allow to cherry-pick which feature to enable
            //
            // By default, the experimental features are only enabled in:
            // - the local environment
            // - the pull request previews
            //
            // Reviewers can force the value with the local storage and the GRID_EXPERIMENTAL_ENABLED key:
            // - 'true' => force it to be enabled
            // - 'false' => force it to be disabled
            //
            // Developers (users) are discouraged to enable the experimental feature by setting the GRID_EXPERIMENTAL_ENABLED env.
            // Instead, prefer exposing experimental APIs, for instance, a prop or a new `unstable_` module.

            let experimentalEnabled = false;

            if (
                typeof process !== "undefined" &&
                process.env.GRID_EXPERIMENTAL_ENABLED !== undefined &&
                localStorageAvailable() &&
                window.localStorage.getItem("GRID_EXPERIMENTAL_ENABLED")
            ) {
                experimentalEnabled =
                    window.localStorage.getItem("GRID_EXPERIMENTAL_ENABLED") ===
                    "true";
            } else if (typeof process !== "undefined") {
                experimentalEnabled =
                    process.env.GRID_EXPERIMENTAL_ENABLED === "true";
            }

            const GRID_EXPERIMENTAL_ENABLED = experimentalEnabled; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/GridColumnsPanel.js
            const GridColumnsPanel_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["columnsPanel"],
                    columnsPanelRow: ["columnsPanelRow"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridColumnsPanelRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "ColumnsPanel",
                overridesResolver: (props, styles) => styles.columnsPanel,
            })(() => ({
                padding: "8px 0px 8px 8px",
            }));
            const GridColumnsPanelRowRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "ColumnsPanelRow",
                    overridesResolver: (props, styles) =>
                        styles.columnsPanelRow,
                }
            )(({ theme }) => ({
                display: "flex",
                justifyContent: "space-between",
                padding: "1px 8px 1px 7px",
                [`& .${Switch_switchClasses.root}`]: {
                    marginRight: theme.spacing(0.5),
                },
            }));
            const GridIconButtonRoot = (0, styled /* default */.ZP)(
                IconButton /* default */.Z
            )({
                justifyContent: "flex-end",
            });
            function GridColumnsPanel(props) {
                var _rootProps$components,
                    _rootProps$components3,
                    _rootProps$components4;

                const apiRef = useGridApiContext();
                const searchInputRef = react.useRef(null);
                const columns = useGridSelector(
                    apiRef,
                    gridColumnDefinitionsSelector
                );
                const columnVisibilityModel = useGridSelector(
                    apiRef,
                    gridColumnVisibilityModelSelector
                );
                const rootProps = useGridRootProps();
                const [searchValue, setSearchValue] = react.useState("");
                const ownerState = {
                    classes: rootProps.classes,
                };
                const classes = GridColumnsPanel_useUtilityClasses(ownerState);

                const toggleColumn = (event) => {
                    const { name: field } = event.target;
                    apiRef.current.setColumnVisibility(
                        field,
                        columnVisibilityModel[field] === false
                    );
                };

                const toggleAllColumns = react.useCallback(
                    (isVisible) => {
                        // TODO v6: call `setColumnVisibilityModel` directly
                        apiRef.current.updateColumns(
                            columns.map((col) => {
                                if (col.hideable !== false) {
                                    return {
                                        field: col.field,
                                        hide: !isVisible,
                                    };
                                }

                                return col;
                            })
                        );
                    },
                    [apiRef, columns]
                );
                const handleSearchValueChange = react.useCallback((event) => {
                    setSearchValue(event.target.value);
                }, []);
                const currentColumns = react.useMemo(() => {
                    if (!searchValue) {
                        return columns;
                    }

                    const searchValueToCheck = searchValue.toLowerCase();
                    return columns.filter(
                        (column) =>
                            (column.headerName || column.field)
                                .toLowerCase()
                                .indexOf(searchValueToCheck) > -1
                    );
                }, [columns, searchValue]);
                react.useEffect(() => {
                    searchInputRef.current.focus();
                }, []);
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    GridPanelWrapper,
                    (0, esm_extends /* default */.Z)({}, props, {
                        children: [
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                GridPanelHeader,
                                {
                                    children: /*#__PURE__*/ (0,
                                    jsx_runtime.jsx)(
                                        rootProps.components.BaseTextField,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                label: apiRef.current.getLocaleText(
                                                    "columnsPanelTextFieldLabel"
                                                ),
                                                placeholder:
                                                    apiRef.current.getLocaleText(
                                                        "columnsPanelTextFieldPlaceholder"
                                                    ),
                                                inputRef: searchInputRef,
                                                value: searchValue,
                                                onChange:
                                                    handleSearchValueChange,
                                                variant: "standard",
                                                fullWidth: true,
                                            },
                                            (_rootProps$components =
                                                rootProps.componentsProps) ==
                                                null
                                                ? void 0
                                                : _rootProps$components.baseTextField
                                        )
                                    ),
                                }
                            ),
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                GridPanelContent,
                                {
                                    children: /*#__PURE__*/ (0,
                                    jsx_runtime.jsx)(GridColumnsPanelRoot, {
                                        className: classes.root,
                                        children: currentColumns.map(
                                            (column) => {
                                                var _rootProps$components2;

                                                return /*#__PURE__*/ (0,
                                                jsx_runtime.jsxs)(
                                                    GridColumnsPanelRowRoot,
                                                    {
                                                        className:
                                                            classes.columnsPanelRow,
                                                        children: [
                                                            /*#__PURE__*/ (0,
                                                            jsx_runtime.jsx)(
                                                                FormControlLabel_FormControlLabel,
                                                                {
                                                                    control:
                                                                        /*#__PURE__*/ (0,
                                                                        jsx_runtime.jsx)(
                                                                            rootProps
                                                                                .components
                                                                                .BaseSwitch,
                                                                            (0,
                                                                            esm_extends /* default */.Z)(
                                                                                {
                                                                                    disabled:
                                                                                        column.hideable ===
                                                                                        false,
                                                                                    checked:
                                                                                        columnVisibilityModel[
                                                                                            column
                                                                                                .field
                                                                                        ] !==
                                                                                        false,
                                                                                    onClick:
                                                                                        toggleColumn,
                                                                                    name: column.field,
                                                                                    color: "primary",
                                                                                    size: "small",
                                                                                },
                                                                                (_rootProps$components2 =
                                                                                    rootProps.componentsProps) ==
                                                                                    null
                                                                                    ? void 0
                                                                                    : _rootProps$components2.baseSwitch
                                                                            )
                                                                        ),
                                                                    label:
                                                                        column.headerName ||
                                                                        column.field,
                                                                }
                                                            ),
                                                            !rootProps.disableColumnReorder &&
                                                                GRID_EXPERIMENTAL_ENABLED &&
                                                                /*#__PURE__*/ (0,
                                                                jsx_runtime.jsx)(
                                                                    GridIconButtonRoot,
                                                                    {
                                                                        draggable: true,
                                                                        "aria-label":
                                                                            apiRef.current.getLocaleText(
                                                                                "columnsPanelDragIconLabel"
                                                                            ),
                                                                        title: apiRef.current.getLocaleText(
                                                                            "columnsPanelDragIconLabel"
                                                                        ),
                                                                        size: "small",
                                                                        disabled: true,
                                                                        children:
                                                                            /*#__PURE__*/ (0,
                                                                            jsx_runtime.jsx)(
                                                                                GridDragIcon,
                                                                                {}
                                                                            ),
                                                                    }
                                                                ),
                                                        ],
                                                    },
                                                    column.field
                                                );
                                            }
                                        ),
                                    }),
                                }
                            ),
                            /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                                GridPanelFooter,
                                {
                                    children: [
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            rootProps.components.BaseButton,
                                            (0, esm_extends /* default */.Z)(
                                                {
                                                    onClick: () =>
                                                        toggleAllColumns(false),
                                                    color: "primary",
                                                },
                                                (_rootProps$components3 =
                                                    rootProps.componentsProps) ==
                                                    null
                                                    ? void 0
                                                    : _rootProps$components3.baseButton,
                                                {
                                                    children:
                                                        apiRef.current.getLocaleText(
                                                            "columnsPanelHideAllButton"
                                                        ),
                                                }
                                            )
                                        ),
                                        /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                            rootProps.components.BaseButton,
                                            (0, esm_extends /* default */.Z)(
                                                {
                                                    onClick: () =>
                                                        toggleAllColumns(true),
                                                    color: "primary",
                                                },
                                                (_rootProps$components4 =
                                                    rootProps.componentsProps) ==
                                                    null
                                                    ? void 0
                                                    : _rootProps$components4.baseButton,
                                                {
                                                    children:
                                                        apiRef.current.getLocaleText(
                                                            "columnsPanelShowAllButton"
                                                        ),
                                                }
                                            )
                                        ),
                                    ],
                                }
                            ),
                        ],
                    })
                );
            } // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/panel/GridPanel.js
            const GridPanel_excluded = ["children", "className", "classes"];

            const gridPanelClasses = (0,
            generateUtilityClasses /* default */.Z)("MuiDataGrid", [
                "panel",
                "paper",
            ]);
            const GridPanelRoot = (0, styled /* default */.ZP)(
                Popper /* default */.Z,
                {
                    name: "MuiDataGrid",
                    slot: "Panel",
                    overridesResolver: (props, styles) => styles.panel,
                }
            )(({ theme }) => ({
                zIndex: theme.zIndex.modal,
            }));
            const GridPaperRoot = (0, styled /* default */.ZP)(
                Paper /* default */.Z,
                {
                    name: "MuiDataGrid",
                    slot: "Paper",
                    overridesResolver: (props, styles) => styles.paper,
                }
            )(({ theme }) => ({
                backgroundColor: theme.palette.background.paper,
                minWidth: 300,
                maxHeight: 450,
                display: "flex",
            }));
            const GridPanel = /*#__PURE__*/ react.forwardRef((props, ref) => {
                var _apiRef$current$colum;

                const { children, className } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridPanel_excluded
                    );

                const apiRef = useGridApiContext();
                const classes = gridPanelClasses;
                const [isPlaced, setIsPlaced] = react.useState(false);
                const handleClickAway = react.useCallback(() => {
                    apiRef.current.hidePreferences();
                }, [apiRef]);
                const handleKeyDown = react.useCallback(
                    (event) => {
                        if (isEscapeKey(event.key)) {
                            apiRef.current.hidePreferences();
                        }
                    },
                    [apiRef]
                );
                const modifiers = react.useMemo(
                    () => [
                        {
                            name: "flip",
                            enabled: false,
                        },
                        {
                            name: "isPlaced",
                            enabled: true,
                            phase: "main",
                            fn: () => {
                                setIsPlaced(true);
                            },
                            effect: () => () => {
                                setIsPlaced(false);
                            },
                        },
                    ],
                    []
                );
                const anchorEl =
                    (_apiRef$current$colum =
                        apiRef.current.columnHeadersContainerElementRef) == null
                        ? void 0
                        : _apiRef$current$colum.current;

                if (!anchorEl) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    GridPanelRoot,
                    (0, esm_extends /* default */.Z)(
                        {
                            ref: ref,
                            placement: "bottom-start",
                            className: (0, clsx_m /* default */.Z)(
                                className,
                                classes.panel
                            ),
                            anchorEl: anchorEl,
                            modifiers: modifiers,
                        },
                        other,
                        {
                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                ClickAwayListener_ClickAwayListener,
                                {
                                    mouseEvent: "onMouseUp",
                                    onClickAway: handleClickAway,
                                    children: /*#__PURE__*/ (0,
                                    jsx_runtime.jsx)(GridPaperRoot, {
                                        className: classes.paper,
                                        elevation: 8,
                                        onKeyDown: handleKeyDown,
                                        children: isPlaced && children,
                                    }),
                                }
                            ),
                        }
                    )
                );
            });
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridRow.js

            const GridRow_excluded = [
                "selected",
                "rowId",
                "row",
                "index",
                "style",
                "rowHeight",
                "className",
                "visibleColumns",
                "renderedColumns",
                "containerWidth",
                "firstColumnToRender",
                "lastColumnToRender",
                "cellFocus",
                "cellTabIndex",
                "editRowsState",
                "isLastVisible",
                "onClick",
                "onDoubleClick",
                "onMouseEnter",
                "onMouseLeave",
            ];

            /* eslint-disable jsx-a11y/click-events-have-key-events */

            /* eslint-disable jsx-a11y/interactive-supports-focus */

            const GridRow_useUtilityClasses = (ownerState) => {
                const { editable, editing, selected, isLastVisible, classes } =
                    ownerState;
                const slots = {
                    root: [
                        "row",
                        selected && "selected",
                        editable && "row--editable",
                        editing && "row--editing",
                        isLastVisible && "row--lastVisible",
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const EmptyCell = ({ width, height }) => {
                if (!width || !height) {
                    return null;
                }

                const style = {
                    width,
                    height,
                };
                return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                    className: "MuiDataGrid-cell",
                    style: style,
                }); // TODO change to .MuiDataGrid-emptyCell or .MuiDataGrid-rowFiller
            };

            function GridRow(props) {
                var _apiRef$current$getRo;

                const {
                        selected,
                        rowId,
                        row,
                        index,
                        style: styleProp,
                        rowHeight,
                        className,
                        visibleColumns,
                        renderedColumns,
                        containerWidth,
                        firstColumnToRender,
                        cellFocus,
                        cellTabIndex,
                        editRowsState,
                        isLastVisible = false,
                        onClick,
                        onDoubleClick,
                        onMouseEnter,
                        onMouseLeave,
                    } = props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridRow_excluded
                    );

                const ariaRowIndex = index + 2; // 1 for the header row and 1 as it's 1-based

                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const currentPage = useGridVisibleRows(apiRef, rootProps);
                const columnsTotalWidth = useGridSelector(
                    apiRef,
                    gridColumnsTotalWidthSelector
                );
                const { hasScrollX, hasScrollY } =
                    (_apiRef$current$getRo =
                        apiRef.current.getRootDimensions()) != null
                        ? _apiRef$current$getRo
                        : {
                              hasScrollX: false,
                              hasScrollY: false,
                          };
                const ownerState = {
                    selected,
                    isLastVisible,
                    classes: rootProps.classes,
                    editing:
                        apiRef.current.getRowMode(rowId) === GridRowModes.Edit,
                    editable: rootProps.editMode === GridEditModes.Row,
                };
                const classes = GridRow_useUtilityClasses(ownerState);
                const publish = react.useCallback(
                    (eventName, propHandler) => (event) => {
                        // Ignore portal
                        // The target is not an element when triggered by a Select inside the cell
                        // See https://github.com/mui/material-ui/issues/10534
                        if (
                            event.target.nodeType === 1 &&
                            !event.currentTarget.contains(event.target)
                        ) {
                            return;
                        } // The row might have been deleted

                        if (!apiRef.current.getRow(rowId)) {
                            return;
                        }

                        apiRef.current.publishEvent(
                            eventName,
                            apiRef.current.getRowParams(rowId),
                            event
                        );

                        if (propHandler) {
                            propHandler(event);
                        }
                    },
                    [apiRef, rowId]
                );
                const publishClick = react.useCallback(
                    (event) => {
                        const cell = findParentElementFromClassName(
                            event.target,
                            gridClasses_gridClasses.cell
                        );
                        const field =
                            cell == null
                                ? void 0
                                : cell.getAttribute("data-field"); // Check if the field is available because the cell that fills the empty
                        // space of the row has no field.

                        if (field) {
                            // User clicked in the checkbox added by checkboxSelection
                            if (
                                field === GRID_CHECKBOX_SELECTION_COL_DEF.field
                            ) {
                                return;
                            } // User opened a detail panel

                            if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
                                return;
                            } // User reorders a row

                            if (field === "__reorder__") {
                                return;
                            } // User is editing a cell

                            if (
                                apiRef.current.getCellMode(rowId, field) ===
                                GridCellModes.Edit
                            ) {
                                return;
                            } // User clicked a button from the "actions" column type

                            const column = apiRef.current.getColumn(field);

                            if (column.type === GRID_ACTIONS_COLUMN_TYPE) {
                                return;
                            }
                        }

                        publish(
                            gridEvents /* GridEvents.rowClick */.t.rowClick,
                            onClick
                        )(event);
                    },
                    [apiRef, onClick, publish, rowId]
                );

                const style = (0, esm_extends /* default */.Z)({}, styleProp, {
                    maxHeight: rowHeight,
                    minHeight: rowHeight,
                });

                const sizes =
                    apiRef.current.unstable_getRowInternalSizes(rowId);

                if (sizes != null && sizes.spacingTop) {
                    const property =
                        rootProps.rowSpacingType === "border"
                            ? "borderTopWidth"
                            : "marginTop";
                    style[property] = sizes.spacingTop;
                }

                if (sizes != null && sizes.spacingBottom) {
                    const property =
                        rootProps.rowSpacingType === "border"
                            ? "borderBottomWidth"
                            : "marginBottom";
                    style[property] = sizes.spacingBottom;
                }

                let rowClassName = null;

                if (typeof rootProps.getRowClassName === "function") {
                    const indexRelativeToCurrentPage =
                        index - currentPage.range.firstRowIndex;

                    const rowParams = (0, esm_extends /* default */.Z)(
                        {},
                        apiRef.current.getRowParams(rowId),
                        {
                            isFirstVisible: indexRelativeToCurrentPage === 0,
                            isLastVisible:
                                indexRelativeToCurrentPage ===
                                currentPage.rows.length - 1,
                            indexRelativeToCurrentPage,
                        }
                    );

                    rowClassName = rootProps.getRowClassName(rowParams);
                }

                const cells = [];

                for (let i = 0; i < renderedColumns.length; i += 1) {
                    const column = renderedColumns[i];
                    const indexRelativeToAllColumns = firstColumnToRender + i;
                    const isLastColumn =
                        indexRelativeToAllColumns === visibleColumns.length - 1;
                    const removeLastBorderRight =
                        isLastColumn && hasScrollX && !hasScrollY;
                    const showRightBorder = !isLastColumn
                        ? rootProps.showCellRightBorder
                        : !removeLastBorderRight &&
                          rootProps.disableExtendRowFullWidth;
                    const cellParams = apiRef.current.getCellParams(
                        rowId,
                        column.field
                    );
                    const classNames = [];

                    if (column.cellClassName) {
                        classNames.push(
                            (0, clsx_m /* default */.Z)(
                                typeof column.cellClassName === "function"
                                    ? column.cellClassName(cellParams)
                                    : column.cellClassName
                            )
                        );
                    }

                    const editCellState = editRowsState[rowId]
                        ? editRowsState[rowId][column.field]
                        : null;
                    let content = null;

                    if (editCellState == null && column.renderCell) {
                        var _rootProps$classes;

                        content = column.renderCell(
                            (0, esm_extends /* default */.Z)({}, cellParams, {
                                api: apiRef.current,
                            })
                        ); // TODO move to GridCell

                        classNames.push(
                            (0, clsx_m /* default */.Z)(
                                gridClasses_gridClasses["cell--withRenderer"],
                                (_rootProps$classes = rootProps.classes) == null
                                    ? void 0
                                    : _rootProps$classes["cell--withRenderer"]
                            )
                        );
                    }

                    if (editCellState != null && column.renderEditCell) {
                        var _rootProps$classes2;

                        let updatedRow = row;

                        if (apiRef.current.unstable_getRowWithUpdatedValues) {
                            // Only the new editing API has this method
                            updatedRow =
                                apiRef.current.unstable_getRowWithUpdatedValues(
                                    rowId,
                                    column.field
                                );
                        }

                        const params = (0, esm_extends /* default */.Z)(
                            {},
                            cellParams,
                            {
                                row: updatedRow,
                            },
                            editCellState,
                            {
                                api: apiRef.current,
                            }
                        );

                        content = column.renderEditCell(params); // TODO move to GridCell

                        classNames.push(
                            (0, clsx_m /* default */.Z)(
                                gridClasses_gridClasses["cell--editing"],
                                (_rootProps$classes2 = rootProps.classes) ==
                                    null
                                    ? void 0
                                    : _rootProps$classes2["cell--editing"]
                            )
                        );
                    }

                    if (rootProps.getCellClassName) {
                        // TODO move to GridCell
                        classNames.push(rootProps.getCellClassName(cellParams));
                    }

                    const hasFocus =
                        cellFocus !== null &&
                        cellFocus.id === rowId &&
                        cellFocus.field === column.field;
                    const tabIndex =
                        cellTabIndex !== null &&
                        cellTabIndex.id === rowId &&
                        cellTabIndex.field === column.field &&
                        cellParams.cellMode === "view"
                            ? 0
                            : -1;
                    const cellColSpanInfo =
                        apiRef.current.unstable_getCellColSpanInfo(
                            rowId,
                            indexRelativeToAllColumns
                        );

                    if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {
                        var _rootProps$components;

                        const { colSpan, width } = cellColSpanInfo.cellProps;
                        cells.push(
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                rootProps.components.Cell,
                                (0, esm_extends /* default */.Z)(
                                    {
                                        value: cellParams.value,
                                        field: column.field,
                                        width: width,
                                        rowId: rowId,
                                        height: rowHeight,
                                        showRightBorder: showRightBorder,
                                        formattedValue:
                                            cellParams.formattedValue,
                                        align: column.align || "left",
                                        cellMode: cellParams.cellMode,
                                        colIndex: indexRelativeToAllColumns,
                                        isEditable: cellParams.isEditable,
                                        hasFocus: hasFocus,
                                        tabIndex: tabIndex,
                                        className: (0, clsx_m /* default */.Z)(
                                            classNames
                                        ),
                                        colSpan: colSpan,
                                    },
                                    (_rootProps$components =
                                        rootProps.componentsProps) == null
                                        ? void 0
                                        : _rootProps$components.cell,
                                    {
                                        children: content,
                                    }
                                ),
                                column.field
                            )
                        );
                    }
                }

                const emptyCellWidth = containerWidth - columnsTotalWidth;
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    "div",
                    (0, esm_extends /* default */.Z)(
                        {
                            "data-id": rowId,
                            "data-rowindex": index,
                            role: "row",
                            className: (0, clsx_m /* default */.Z)(
                                rowClassName,
                                classes.root,
                                className
                            ),
                            "aria-rowindex": ariaRowIndex,
                            "aria-selected": selected,
                            style: style,
                            onClick: publishClick,
                            onDoubleClick: publish(
                                gridEvents /* GridEvents.rowDoubleClick */.t
                                    .rowDoubleClick,
                                onDoubleClick
                            ),
                            onMouseEnter: publish(
                                gridEvents /* GridEvents.rowMouseEnter */.t
                                    .rowMouseEnter,
                                onMouseEnter
                            ),
                            onMouseLeave: publish(
                                gridEvents /* GridEvents.rowMouseLeave */.t
                                    .rowMouseLeave,
                                onMouseLeave
                            ),
                        },
                        other,
                        {
                            children: [
                                cells,
                                emptyCellWidth > 0 &&
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        EmptyCell,
                                        {
                                            width: emptyCellWidth,
                                            height: rowHeight,
                                        }
                                    ),
                            ],
                        }
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnUnsortedIcon.js

            const GridColumnUnsortedIcon_excluded = ["sortingOrder"];

            const GridColumnUnsortedIcon = /*#__PURE__*/ react.memo(
                function GridColumnHeaderSortIcon(props) {
                    const { sortingOrder } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridColumnUnsortedIcon_excluded
                        );

                    const rootProps = useGridRootProps();
                    const [nextSortDirection] = sortingOrder;
                    const Icon =
                        nextSortDirection === "asc"
                            ? rootProps.components.ColumnSortedAscendingIcon
                            : rootProps.components.ColumnSortedDescendingIcon;
                    return Icon
                        ? /*#__PURE__*/ (0, jsx_runtime.jsx)(
                              Icon,
                              (0, esm_extends /* default */.Z)({}, other)
                          )
                        : null;
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/ErrorOverlay.js
            const ErrorOverlay_excluded = ["message", "hasError", "errorInfo"];

            // TODO v6: rename to GridErrorOverlay
            const ErrorOverlay = /*#__PURE__*/ react.forwardRef(
                function ErrorOverlay(props, ref) {
                    const { message } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            ErrorOverlay_excluded
                        );

                    const apiRef = useGridApiContext();
                    const defaultLabel = apiRef.current.getLocaleText(
                        "errorOverlayDefaultLabel"
                    );
                    const rowHeight = useGridSelector(
                        apiRef,
                        gridDensityRowHeightSelector
                    );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridOverlay,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                sx: {
                                    width: "100%",
                                    minHeight: 2 * rowHeight,
                                },
                            },
                            other,
                            {
                                children: message || defaultLabel,
                            }
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridNoResultsOverlay.js
            const GridNoResultsOverlay = /*#__PURE__*/ react.forwardRef(
                function GridNoResultsOverlay(props, ref) {
                    const apiRef = useGridApiContext();
                    const noResultsOverlayLabel = apiRef.current.getLocaleText(
                        "noResultsOverlayLabel"
                    );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridOverlay,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            props,
                            {
                                children: noResultsOverlayLabel,
                            }
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/constants/defaultGridSlotsComponents.js
            const DEFAULT_GRID_ICON_SLOTS_COMPONENTS = {
                BooleanCellTrueIcon: GridCheckIcon,
                BooleanCellFalseIcon: GridCloseIcon,
                ColumnMenuIcon: GridTripleDotsVerticalIcon,
                OpenFilterButtonIcon: GridFilterListIcon,
                FilterPanelDeleteIcon: GridCloseIcon,
                ColumnFilteredIcon: GridFilterAltIcon,
                ColumnSelectorIcon: GridColumnIcon,
                ColumnUnsortedIcon: GridColumnUnsortedIcon,
                ColumnSortedAscendingIcon: GridArrowUpwardIcon,
                ColumnSortedDescendingIcon: GridArrowDownwardIcon,
                ColumnResizeIcon: GridSeparatorIcon,
                DensityCompactIcon: GridViewHeadlineIcon,
                DensityStandardIcon: GridTableRowsIcon,
                DensityComfortableIcon: GridViewStreamIcon,
                ExportIcon: GridSaveAltIcon,
                MoreActionsIcon: GridMoreVertIcon,
                TreeDataCollapseIcon: GridExpandMoreIcon,
                TreeDataExpandIcon: GridKeyboardArrowRight,
                GroupingCriteriaCollapseIcon: GridExpandMoreIcon,
                GroupingCriteriaExpandIcon: GridKeyboardArrowRight,
                DetailPanelExpandIcon: GridAddIcon,
                DetailPanelCollapseIcon: GridRemoveIcon,
                RowReorderIcon: GridDragIcon,
            };
            /**
             * TODO: Differentiate community and pro value and interface
             */

            const DATA_GRID_DEFAULT_SLOTS_COMPONENTS = (0,
            esm_extends /* default */.Z)(
                {},
                DEFAULT_GRID_ICON_SLOTS_COMPONENTS,
                {
                    BaseCheckbox: Checkbox_Checkbox,
                    BaseTextField: TextField_TextField,
                    BaseFormControl: FormControl_FormControl,
                    BaseSelect: Select /* default */.Z,
                    BaseSwitch: Switch_Switch,
                    BaseButton: Button_Button,
                    BaseTooltip: Tooltip /* default */.Z,
                    BasePopper: Popper /* default */.Z,
                    Cell: GridCell,
                    ColumnHeaderFilterIconButton:
                        GridColumnHeaderFilterIconButton,
                    ColumnMenu: GridColumnMenu,
                    ErrorOverlay: ErrorOverlay,
                    Footer: GridFooter,
                    Header: GridHeader,
                    Toolbar: null,
                    PreferencesPanel: GridPreferencesPanel,
                    LoadingOverlay: GridLoadingOverlay,
                    NoResultsOverlay: GridNoResultsOverlay,
                    NoRowsOverlay: GridNoRowsOverlay,
                    Pagination: GridPagination,
                    FilterPanel: GridFilterPanel,
                    ColumnsPanel: GridColumnsPanel,
                    Panel: GridPanel,
                    Row: GridRow,
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/DataGrid/useDataGridProps.js
            const DATA_GRID_FORCED_PROPS = {
                apiRef: undefined,
                disableMultipleColumnsFiltering: true,
                disableMultipleColumnsSorting: true,
                disableMultipleSelection: true,
                throttleRowsMs: undefined,
                hideFooterRowCount: false,
                pagination: true,
                checkboxSelectionVisibleOnly: false,
                disableColumnReorder: true,
                disableColumnResize: true,
                signature: "DataGrid",
            };
            const MAX_PAGE_SIZE = 100;
            /**
             * The default values of `DataGridPropsWithDefaultValues` to inject in the props of DataGrid.
             */

            const DATA_GRID_PROPS_DEFAULT_VALUES = {
                autoHeight: false,
                autoPageSize: false,
                checkboxSelection: false,
                checkboxSelectionVisibleOnly: false,
                columnBuffer: 3,
                rowBuffer: 3,
                columnThreshold: 3,
                rowThreshold: 3,
                density: GridDensityTypes.Standard,
                disableExtendRowFullWidth: false,
                disableColumnFilter: false,
                disableColumnMenu: false,
                disableColumnSelector: false,
                disableDensitySelector: false,
                disableMultipleColumnsFiltering: false,
                disableMultipleSelection: false,
                disableMultipleColumnsSorting: false,
                disableSelectionOnClick: false,
                disableVirtualization: false,
                editMode: GridEditModes.Cell,
                filterMode: GridFeatureModeConstant.client,
                headerHeight: 56,
                hideFooter: false,
                hideFooterPagination: false,
                hideFooterRowCount: false,
                hideFooterSelectedRowCount: false,
                logger: console,
                logLevel: true ? "error" : 0,
                pagination: false,
                paginationMode: GridFeatureModeConstant.client,
                rowHeight: 52,
                rowsPerPageOptions: [25, 50, 100],
                rowSpacingType: "margin",
                showCellRightBorder: false,
                showColumnRightBorder: false,
                sortingOrder: ["asc", "desc", null],
                sortingMode: GridFeatureModeConstant.client,
                throttleRowsMs: 0,
                disableColumnReorder: false,
                disableColumnResize: false,
            };
            const useDataGridProps = (inProps) => {
                if (inProps.pageSize > MAX_PAGE_SIZE) {
                    throw new Error(
                        `'props.pageSize' cannot exceed 100 in DataGrid.`
                    );
                }

                const themedProps = (0, useThemeProps /* default */.Z)({
                    props: inProps,
                    name: "MuiDataGrid",
                });
                const localeText = react.useMemo(
                    () =>
                        (0, esm_extends /* default */.Z)(
                            {},
                            GRID_DEFAULT_LOCALE_TEXT,
                            themedProps.localeText
                        ),
                    [themedProps.localeText]
                );
                const components = react.useMemo(() => {
                    const overrides = themedProps.components;

                    if (!overrides) {
                        return (0, esm_extends /* default */.Z)(
                            {},
                            DATA_GRID_DEFAULT_SLOTS_COMPONENTS
                        );
                    }

                    const mergedComponents = {};
                    Object.entries(DATA_GRID_DEFAULT_SLOTS_COMPONENTS).forEach(
                        ([key, defaultComponent]) => {
                            mergedComponents[key] =
                                overrides[key] === undefined
                                    ? defaultComponent
                                    : overrides[key];
                        }
                    );
                    return mergedComponents;
                }, [themedProps.components]);
                return react.useMemo(
                    () =>
                        (0, esm_extends /* default */.Z)(
                            {},
                            DATA_GRID_PROPS_DEFAULT_VALUES,
                            themedProps,
                            {
                                localeText,
                                components,
                            },
                            DATA_GRID_FORCED_PROPS
                        ),
                    [themedProps, localeText, components]
                );
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/virtualization/GridVirtualScroller.js
            const GridVirtualScroller_excluded = ["className"];

            const GridVirtualScroller_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["virtualScroller"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const VirtualScrollerRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "VirtualScroller",
                overridesResolver: (props, styles) => styles.virtualScroller,
            })({
                overflow: "auto",
                // See https://github.com/mui/mui-x/issues/4360
                position: "relative",
                "@media print": {
                    overflow: "hidden",
                },
            });
            const GridVirtualScroller = /*#__PURE__*/ react.forwardRef(
                function GridVirtualScroller(props, ref) {
                    const { className } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridVirtualScroller_excluded
                        );

                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridVirtualScroller_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        VirtualScrollerRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/virtualization/GridVirtualScrollerContent.js

            const GridVirtualScrollerContent_excluded = ["className", "style"];

            const GridVirtualScrollerContent_useUtilityClasses = (
                ownerState
            ) => {
                const { classes, overflowedContent } = ownerState;
                const slots = {
                    root: [
                        "virtualScrollerContent",
                        overflowedContent &&
                            "virtualScrollerContent--overflowed",
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const VirtualScrollerContentRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "VirtualScrollerContent",
                    overridesResolver: (props, styles) =>
                        styles.virtualScrollerContent,
                }
            )({});
            const GridVirtualScrollerContent = /*#__PURE__*/ react.forwardRef(
                function GridVirtualScrollerContent(props, ref) {
                    const { className, style } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridVirtualScrollerContent_excluded
                        );

                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                        overflowedContent:
                            !rootProps.autoHeight &&
                            (style == null ? void 0 : style.minHeight) ===
                                "auto",
                    };
                    const classes =
                        GridVirtualScrollerContent_useUtilityClasses(
                            ownerState
                        );
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        VirtualScrollerContentRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                                style: style,
                            },
                            other
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/virtualization/GridVirtualScrollerRenderZone.js

            const GridVirtualScrollerRenderZone_excluded = ["className"];

            const GridVirtualScrollerRenderZone_useUtilityClasses = (
                ownerState
            ) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["virtualScrollerRenderZone"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const VirtualScrollerRenderZoneRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "VirtualScrollerRenderZone",
                    overridesResolver: (props, styles) =>
                        styles.virtualScrollerRenderZone,
                }
            )({
                position: "absolute",
                display: "flex",
                // Prevents margin collapsing when using `getRowSpacing`
                flexDirection: "column",
            });
            const GridVirtualScrollerRenderZone =
                /*#__PURE__*/ react.forwardRef(
                    function GridVirtualScrollerRenderZone(props, ref) {
                        const { className } = props,
                            other = (0,
                            objectWithoutPropertiesLoose /* default */.Z)(
                                props,
                                GridVirtualScrollerRenderZone_excluded
                            );

                        const rootProps = useGridRootProps();
                        const ownerState = {
                            classes: rootProps.classes,
                        };
                        const classes =
                            GridVirtualScrollerRenderZone_useUtilityClasses(
                                ownerState
                            );
                        return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                            VirtualScrollerRenderZoneRoot,
                            (0, esm_extends /* default */.Z)(
                                {
                                    ref: ref,
                                    className: (0, clsx_m /* default */.Z)(
                                        classes.root,
                                        className
                                    ),
                                },
                                other
                            )
                        );
                    }
                );

            // EXTERNAL MODULE: ./node_modules/react-dom/index.js
            var react_dom = __webpack_require__(3935); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js
            const useGridVirtualScroller_excluded = ["style"];

            // Uses binary search to avoid looping through all possible positions

            function getIndexFromScroll(
                offset,
                positions,
                sliceStart = 0,
                sliceEnd = positions.length
            ) {
                if (positions.length <= 0) {
                    return -1;
                }

                if (sliceStart >= sliceEnd) {
                    return sliceStart;
                }

                const pivot =
                    sliceStart + Math.floor((sliceEnd - sliceStart) / 2);
                const itemOffset = positions[pivot];
                return offset <= itemOffset
                    ? getIndexFromScroll(offset, positions, sliceStart, pivot)
                    : getIndexFromScroll(
                          offset,
                          positions,
                          pivot + 1,
                          sliceEnd
                      );
            }
            const getRenderableIndexes = ({
                firstIndex,
                lastIndex,
                buffer,
                minFirstIndex,
                maxLastIndex,
            }) => {
                return [
                    clamp(firstIndex - buffer, minFirstIndex, maxLastIndex),
                    clamp(lastIndex + buffer, minFirstIndex, maxLastIndex),
                ];
            };
            const useGridVirtualScroller = (props) => {
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const visibleColumns = useGridSelector(
                    apiRef,
                    gridVisibleColumnDefinitionsSelector
                );
                const {
                    ref,
                    disableVirtualization,
                    onRenderZonePositioning,
                    renderZoneMinColumnIndex = 0,
                    renderZoneMaxColumnIndex = visibleColumns.length,
                    getRowProps,
                } = props;
                const columnPositions = useGridSelector(
                    apiRef,
                    gridColumnPositionsSelector
                );
                const columnsTotalWidth = useGridSelector(
                    apiRef,
                    gridColumnsTotalWidthSelector
                );
                const rowHeight = useGridSelector(
                    apiRef,
                    gridDensityRowHeightSelector
                );
                const cellFocus = useGridSelector(
                    apiRef,
                    gridFocusCellSelector
                );
                const cellTabIndex = useGridSelector(
                    apiRef,
                    gridTabIndexCellSelector
                );
                const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
                const editRowsState = useGridSelector(
                    apiRef,
                    gridEditRowsStateSelector
                );
                const selectedRowsLookup = useGridSelector(
                    apiRef,
                    selectedIdsLookupSelector
                );
                const currentPage = useGridVisibleRows(apiRef, rootProps);
                const renderZoneRef = react.useRef(null);
                const rootRef = react.useRef(null);
                const handleRef = (0, useForkRef /* default */.Z)(ref, rootRef);
                const [renderContext, setRenderContext] = react.useState(null);
                const prevRenderContext = react.useRef(renderContext);
                const scrollPosition = react.useRef({
                    top: 0,
                    left: 0,
                });
                const [containerWidth, setContainerWidth] =
                    react.useState(null);
                const prevTotalWidth = react.useRef(columnsTotalWidth);
                const computeRenderContext = react.useCallback(() => {
                    if (disableVirtualization) {
                        return {
                            firstRowIndex: 0,
                            lastRowIndex: currentPage.rows.length,
                            firstColumnIndex: 0,
                            lastColumnIndex: visibleColumns.length,
                        };
                    }

                    const { top, left } = scrollPosition.current;
                    const firstRowIndex = getIndexFromScroll(
                        top,
                        rowsMeta.positions
                    );
                    const lastRowIndex = rootProps.autoHeight
                        ? firstRowIndex + currentPage.rows.length
                        : getIndexFromScroll(
                              top + rootRef.current.clientHeight,
                              rowsMeta.positions
                          );
                    const firstColumnIndex = getIndexFromScroll(
                        left,
                        columnPositions
                    );
                    const lastColumnIndex = getIndexFromScroll(
                        left + containerWidth,
                        columnPositions
                    );
                    return {
                        firstRowIndex,
                        lastRowIndex,
                        firstColumnIndex,
                        lastColumnIndex,
                    };
                }, [
                    disableVirtualization,
                    rowsMeta.positions,
                    rootProps.autoHeight,
                    currentPage.rows.length,
                    columnPositions,
                    containerWidth,
                    visibleColumns.length,
                ]);
                react.useEffect(() => {
                    if (disableVirtualization) {
                        renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;
                    } else {
                        // TODO a scroll reset should not be necessary
                        rootRef.current.scrollLeft = 0;
                        rootRef.current.scrollTop = 0;
                    }
                }, [disableVirtualization]);
                react.useEffect(() => {
                    setContainerWidth(rootRef.current.clientWidth);
                }, [rowsMeta.currentPageTotalHeight]);
                const handleResize = react.useCallback(() => {
                    if (rootRef.current) {
                        setContainerWidth(rootRef.current.clientWidth);
                    }
                }, []);
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.resize */.t.resize,
                    handleResize
                );
                const updateRenderZonePosition = react.useCallback(
                    (nextRenderContext) => {
                        const [firstRowToRender, lastRowToRender] =
                            getRenderableIndexes({
                                firstIndex: nextRenderContext.firstRowIndex,
                                lastIndex: nextRenderContext.lastRowIndex,
                                minFirstIndex: 0,
                                maxLastIndex: currentPage.rows.length,
                                buffer: rootProps.rowBuffer,
                            });
                        const [initialFirstColumnToRender] =
                            getRenderableIndexes({
                                firstIndex: nextRenderContext.firstColumnIndex,
                                lastIndex: nextRenderContext.lastColumnIndex,
                                minFirstIndex: renderZoneMinColumnIndex,
                                maxLastIndex: renderZoneMaxColumnIndex,
                                buffer: rootProps.columnBuffer,
                            });
                        const firstColumnToRender =
                            getFirstNonSpannedColumnToRender({
                                firstColumnToRender: initialFirstColumnToRender,
                                apiRef,
                                firstRowToRender,
                                lastRowToRender,
                                visibleRows: currentPage.rows,
                            });
                        const top = gridRowsMetaSelector(apiRef.current.state)
                            .positions[firstRowToRender];
                        const left =
                            gridColumnPositionsSelector(apiRef)[
                                firstColumnToRender
                            ]; // Call directly the selector because it might be outdated when this method is called

                        renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;

                        if (typeof onRenderZonePositioning === "function") {
                            onRenderZonePositioning({
                                top,
                                left,
                            });
                        }
                    },
                    [
                        apiRef,
                        currentPage.rows,
                        onRenderZonePositioning,
                        renderZoneMinColumnIndex,
                        renderZoneMaxColumnIndex,
                        rootProps.columnBuffer,
                        rootProps.rowBuffer,
                    ]
                );
                react.useLayoutEffect(() => {
                    if (renderContext) {
                        updateRenderZonePosition(renderContext);
                    }
                }, [renderContext, updateRenderZonePosition]);
                const updateRenderContext = react.useCallback(
                    (nextRenderContext) => {
                        setRenderContext(nextRenderContext);
                        prevRenderContext.current = nextRenderContext;
                    },
                    [setRenderContext, prevRenderContext]
                );
                react.useEffect(() => {
                    if (containerWidth == null) {
                        return;
                    }

                    const initialRenderContext = computeRenderContext();
                    updateRenderContext(initialRenderContext);
                    const { top, left } = scrollPosition.current;
                    const params = {
                        top,
                        left,
                        renderContext: initialRenderContext,
                    };
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.rowsScroll */.t.rowsScroll,
                        params
                    );
                }, [
                    apiRef,
                    computeRenderContext,
                    containerWidth,
                    updateRenderContext,
                ]);

                const handleScroll = (event) => {
                    const { scrollTop, scrollLeft } = event.currentTarget;
                    scrollPosition.current.top = scrollTop;
                    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start

                    if (
                        scrollLeft < 0 ||
                        scrollTop < 0 ||
                        !prevRenderContext.current
                    ) {
                        return;
                    } // When virtualization is disabled, the context never changes during scroll

                    const nextRenderContext = disableVirtualization
                        ? prevRenderContext.current
                        : computeRenderContext();
                    const topRowsScrolledSincePreviousRender = Math.abs(
                        nextRenderContext.firstRowIndex -
                            prevRenderContext.current.firstRowIndex
                    );
                    const bottomRowsScrolledSincePreviousRender = Math.abs(
                        nextRenderContext.lastRowIndex -
                            prevRenderContext.current.lastRowIndex
                    );
                    const topColumnsScrolledSincePreviousRender = Math.abs(
                        nextRenderContext.firstColumnIndex -
                            prevRenderContext.current.firstColumnIndex
                    );
                    const bottomColumnsScrolledSincePreviousRender = Math.abs(
                        nextRenderContext.lastColumnIndex -
                            prevRenderContext.current.lastColumnIndex
                    );
                    const shouldSetState =
                        topRowsScrolledSincePreviousRender >=
                            rootProps.rowThreshold ||
                        bottomRowsScrolledSincePreviousRender >=
                            rootProps.rowThreshold ||
                        topColumnsScrolledSincePreviousRender >=
                            rootProps.columnThreshold ||
                        bottomColumnsScrolledSincePreviousRender >=
                            rootProps.columnThreshold ||
                        prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling

                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.rowsScroll */.t.rowsScroll,
                        {
                            top: scrollTop,
                            left: scrollLeft,
                            renderContext: shouldSetState
                                ? nextRenderContext
                                : prevRenderContext.current,
                        },
                        event
                    );

                    if (shouldSetState) {
                        // Prevents batching render context changes
                        react_dom.flushSync(() => {
                            updateRenderContext(nextRenderContext);
                        });
                        prevTotalWidth.current = columnsTotalWidth;
                    }
                };

                const handleWheel = (event) => {
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.virtualScrollerWheel */.t
                            .virtualScrollerWheel,
                        {},
                        event
                    );
                };

                const handleTouchMove = (event) => {
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.virtualScrollerTouchMove */.t
                            .virtualScrollerTouchMove,
                        {},
                        event
                    );
                };

                const getRows = (
                    params = {
                        renderContext,
                    }
                ) => {
                    const {
                        renderContext: nextRenderContext,
                        minFirstColumn = renderZoneMinColumnIndex,
                        maxLastColumn = renderZoneMaxColumnIndex,
                        availableSpace = containerWidth,
                    } = params;

                    if (
                        !currentPage.range ||
                        !nextRenderContext ||
                        availableSpace == null
                    ) {
                        return null;
                    }

                    const rowBuffer = !disableVirtualization
                        ? rootProps.rowBuffer
                        : 0;
                    const columnBuffer = !disableVirtualization
                        ? rootProps.columnBuffer
                        : 0;
                    const [firstRowToRender, lastRowToRender] =
                        getRenderableIndexes({
                            firstIndex: nextRenderContext.firstRowIndex,
                            lastIndex: nextRenderContext.lastRowIndex,
                            minFirstIndex: 0,
                            maxLastIndex: currentPage.rows.length,
                            buffer: rowBuffer,
                        });
                    const renderedRows = [];

                    for (
                        let i = firstRowToRender;
                        i < lastRowToRender;
                        i += 1
                    ) {
                        const row = currentPage.rows[i];
                        renderedRows.push(row);
                        apiRef.current.unstable_calculateColSpan({
                            rowId: row.id,
                            minFirstColumn,
                            maxLastColumn,
                        });
                    }

                    const [initialFirstColumnToRender, lastColumnToRender] =
                        getRenderableIndexes({
                            firstIndex: nextRenderContext.firstColumnIndex,
                            lastIndex: nextRenderContext.lastColumnIndex,
                            minFirstIndex: minFirstColumn,
                            maxLastIndex: maxLastColumn,
                            buffer: columnBuffer,
                        });
                    const firstColumnToRender =
                        getFirstNonSpannedColumnToRender({
                            firstColumnToRender: initialFirstColumnToRender,
                            apiRef,
                            firstRowToRender,
                            lastRowToRender,
                            visibleRows: currentPage.rows,
                        });
                    const renderedColumns = visibleColumns.slice(
                        firstColumnToRender,
                        lastColumnToRender
                    );
                    const rows = [];

                    for (let i = 0; i < renderedRows.length; i += 1) {
                        var _rootProps$components;

                        const { id, model } = renderedRows[i];
                        const lastVisibleRowIndex =
                            firstRowToRender + i ===
                            currentPage.rows.length - 1;
                        const targetRowHeight =
                            apiRef.current.unstable_getRowHeight(id);
                        let isSelected;

                        if (selectedRowsLookup[id] == null) {
                            isSelected = false;
                        } else if (
                            typeof rootProps.isRowSelectable === "function"
                        ) {
                            isSelected = rootProps.isRowSelectable(
                                apiRef.current.getRowParams(id)
                            );
                        } else {
                            isSelected = true;
                        }

                        rows.push(
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                rootProps.components.Row,
                                (0, esm_extends /* default */.Z)(
                                    {
                                        row: model,
                                        rowId: id,
                                        rowHeight: targetRowHeight,
                                        cellFocus: cellFocus, // TODO move to inside the row
                                        cellTabIndex: cellTabIndex, // TODO move to inside the row
                                        editRowsState: editRowsState, // TODO move to inside the row
                                        renderedColumns: renderedColumns,
                                        visibleColumns: visibleColumns,
                                        firstColumnToRender:
                                            firstColumnToRender,
                                        lastColumnToRender: lastColumnToRender,
                                        selected: isSelected,
                                        index:
                                            currentPage.range.firstRowIndex +
                                            firstRowToRender +
                                            i,
                                        containerWidth: availableSpace,
                                        isLastVisible: lastVisibleRowIndex,
                                    },
                                    typeof getRowProps === "function"
                                        ? getRowProps(id, model)
                                        : {},
                                    (_rootProps$components =
                                        rootProps.componentsProps) == null
                                        ? void 0
                                        : _rootProps$components.row
                                ),
                                id
                            )
                        );
                    }

                    return rows;
                };

                const needsHorizontalScrollbar =
                    containerWidth && columnsTotalWidth > containerWidth;
                const contentSize = react.useMemo(() => {
                    // In cases where the columns exceed the available width,
                    // the horizontal scrollbar should be shown even when there're no rows.
                    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.
                    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);
                    let shouldExtendContent = false;

                    if (
                        rootRef != null &&
                        rootRef.current &&
                        height <=
                            (rootRef == null
                                ? void 0
                                : rootRef.current.clientHeight)
                    ) {
                        shouldExtendContent = true;
                    }

                    const size = {
                        width: needsHorizontalScrollbar
                            ? columnsTotalWidth
                            : "auto",
                        height,
                        minHeight: shouldExtendContent ? "100%" : "auto",
                    };

                    if (rootProps.autoHeight && currentPage.rows.length === 0) {
                        size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.
                    }

                    return size;
                }, [
                    rootRef,
                    columnsTotalWidth,
                    rowsMeta.currentPageTotalHeight,
                    currentPage.rows.length,
                    needsHorizontalScrollbar,
                    rootProps.autoHeight,
                    rowHeight,
                ]);
                react.useEffect(() => {
                    apiRef.current.publishEvent(
                        gridEvents /* GridEvents.virtualScrollerContentSizeChange */
                            .t.virtualScrollerContentSizeChange
                    );
                }, [apiRef, contentSize]);

                if (rootProps.autoHeight && currentPage.rows.length === 0) {
                    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.
                }

                const rootStyle = {};

                if (!needsHorizontalScrollbar) {
                    rootStyle.overflowX = "hidden";
                }

                const getRenderContext = react.useCallback(() => {
                    return prevRenderContext.current;
                }, []);
                apiRef.current.unstable_getRenderContext = getRenderContext;
                return {
                    renderContext,
                    updateRenderZonePosition,
                    getRows,
                    getRootProps: (_ref = {}) => {
                        let { style = {} } = _ref,
                            other = (0,
                            objectWithoutPropertiesLoose /* default */.Z)(
                                _ref,
                                useGridVirtualScroller_excluded
                            );

                        return (0, esm_extends /* default */.Z)(
                            {
                                ref: handleRef,
                                onScroll: handleScroll,
                                onWheel: handleWheel,
                                onTouchMove: handleTouchMove,
                                style: (0, esm_extends /* default */.Z)(
                                    {},
                                    style,
                                    rootStyle
                                ),
                            },
                            other
                        );
                    },
                    getContentProps: ({ style = {} } = {}) => ({
                        style: (0, esm_extends /* default */.Z)(
                            {},
                            style,
                            contentSize
                        ),
                    }),
                    getRenderZoneProps: () => ({
                        ref: renderZoneRef,
                    }),
                };
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/DataGridVirtualScroller.js
            const DataGridVirtualScroller_excluded = [
                "className",
                "disableVirtualization",
            ];

            const DataGridVirtualScroller = /*#__PURE__*/ react.forwardRef(
                function DataGridVirtualScroller(props, ref) {
                    const { className, disableVirtualization } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            DataGridVirtualScroller_excluded
                        );

                    const {
                        getRootProps,
                        getContentProps,
                        getRenderZoneProps,
                        getRows,
                    } = useGridVirtualScroller({
                        ref,
                        disableVirtualization,
                    });
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridVirtualScroller,
                        (0, esm_extends /* default */.Z)(
                            {
                                className: className,
                            },
                            getRootProps(other),
                            {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    GridVirtualScrollerContent,
                                    (0, esm_extends /* default */.Z)(
                                        {},
                                        getContentProps(),
                                        {
                                            children: /*#__PURE__*/ (0,
                                            jsx_runtime.jsx)(
                                                GridVirtualScrollerRenderZone,
                                                (0,
                                                esm_extends /* default */.Z)(
                                                    {},
                                                    getRenderZoneProps(),
                                                    {
                                                        children: getRows(),
                                                    }
                                                )
                                            ),
                                        }
                                    )
                                ),
                            }
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnHeaderSortIcon.js

            const GridColumnHeaderSortIcon_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    icon: ["sortIcon"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            function getIcon(icons, direction, className, sortingOrder) {
                let Icon;
                const iconProps = {};

                if (direction === "asc") {
                    Icon = icons.ColumnSortedAscendingIcon;
                } else if (direction === "desc") {
                    Icon = icons.ColumnSortedDescendingIcon;
                } else {
                    Icon = icons.ColumnUnsortedIcon;
                    iconProps.sortingOrder = sortingOrder;
                }

                return Icon
                    ? /*#__PURE__*/ (0, jsx_runtime.jsx)(
                          Icon,
                          (0, esm_extends /* default */.Z)(
                              {
                                  fontSize: "small",
                                  className: className,
                              },
                              iconProps
                          )
                      )
                    : null;
            }

            function GridColumnHeaderSortIconRaw(props) {
                const { direction, index, sortingOrder } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    classes: rootProps.classes,
                });

                const classes =
                    GridColumnHeaderSortIcon_useUtilityClasses(ownerState);
                const iconElement = getIcon(
                    rootProps.components,
                    direction,
                    classes.icon,
                    sortingOrder
                );

                if (!iconElement) {
                    return null;
                }

                const iconButton = /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    IconButton /* default */.Z,
                    {
                        tabIndex: -1,
                        "aria-label": apiRef.current.getLocaleText(
                            "columnHeaderSortIconLabel"
                        ),
                        title: apiRef.current.getLocaleText(
                            "columnHeaderSortIconLabel"
                        ),
                        size: "small",
                        children: iconElement,
                    }
                );

                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    GridIconButtonContainer,
                    {
                        children: [
                            index != null &&
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    Badge_Badge,
                                    {
                                        badgeContent: index,
                                        color: "default",
                                        children: iconButton,
                                    }
                                ),
                            index == null && iconButton,
                        ],
                    }
                );
            }

            const GridColumnHeaderSortIcon = /*#__PURE__*/ react.memo(
                GridColumnHeaderSortIconRaw
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnHeaderTitle.js

            const GridColumnHeaderTitle_excluded = ["className"];

            const GridColumnHeaderTitle_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["columnHeaderTitle"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridColumnHeaderTitleRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "ColumnHeaderTitle",
                    overridesResolver: (props, styles) =>
                        styles.columnHeaderTitle,
                }
            )(({ theme }) => ({
                textOverflow: "ellipsis",
                overflow: "hidden",
                whiteSpace: "nowrap",
                fontWeight: theme.typography.fontWeightMedium,
            }));
            const ColumnHeaderInnerTitle = /*#__PURE__*/ react.forwardRef(
                function ColumnHeaderInnerTitle(props, ref) {
                    const { className } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridColumnHeaderTitle_excluded
                        );

                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridColumnHeaderTitle_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridColumnHeaderTitleRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    classes.root,
                                    className
                                ),
                            },
                            other
                        )
                    );
                }
            );

            // No React.memo here as if we display the sort icon, we need to recalculate the isOver
            function GridColumnHeaderTitle(props) {
                var _rootProps$components;

                const { label, description, columnWidth } = props;
                const rootProps = useGridRootProps();
                const titleRef = react.useRef(null);
                const [tooltip, setTooltip] = react.useState("");
                react.useEffect(() => {
                    if (!description && titleRef && titleRef.current) {
                        const isOver = isOverflown(titleRef.current);

                        if (isOver) {
                            setTooltip(label);
                        } else {
                            setTooltip("");
                        }
                    }
                }, [titleRef, columnWidth, description, label]);
                return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                    rootProps.components.BaseTooltip,
                    (0, esm_extends /* default */.Z)(
                        {
                            title: description || tooltip,
                        },
                        (_rootProps$components = rootProps.componentsProps) ==
                            null
                            ? void 0
                            : _rootProps$components.baseTooltip,
                        {
                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                ColumnHeaderInnerTitle,
                                {
                                    ref: titleRef,
                                    children: label,
                                }
                            ),
                        }
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnHeaderSeparator.js

            const GridColumnHeaderSeparator_excluded = [
                "resizable",
                "resizing",
                "height",
                "side",
            ];

            var GridColumnHeaderSeparatorSides;

            (function (GridColumnHeaderSeparatorSides) {
                GridColumnHeaderSeparatorSides["Left"] = "left";
                GridColumnHeaderSeparatorSides["Right"] = "right";
            })(
                GridColumnHeaderSeparatorSides ||
                    (GridColumnHeaderSeparatorSides = {})
            );

            const GridColumnHeaderSeparator_useUtilityClasses = (
                ownerState
            ) => {
                const { resizable, resizing, classes, side } = ownerState;
                const slots = {
                    root: [
                        "columnSeparator",
                        resizable && "columnSeparator--resizable",
                        resizing && "columnSeparator--resizing",
                        side &&
                            `columnSeparator--side${(0,
                            capitalize /* default */.Z)(side)}`,
                    ],
                    icon: ["iconSeparator"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            function GridColumnHeaderSeparatorRaw(props) {
                const { height, side = GridColumnHeaderSeparatorSides.Right } =
                        props,
                    other = (0, objectWithoutPropertiesLoose /* default */.Z)(
                        props,
                        GridColumnHeaderSeparator_excluded
                    );

                const rootProps = useGridRootProps();

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    side,
                    classes: rootProps.classes,
                });

                const classes =
                    GridColumnHeaderSeparator_useUtilityClasses(ownerState);
                const stopClick = react.useCallback((event) => {
                    event.preventDefault();
                    event.stopPropagation();
                }, []);
                return (
                    /*#__PURE__*/
                    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
                    (0, jsx_runtime.jsx)(
                        "div",
                        (0, esm_extends /* default */.Z)(
                            {
                                className: classes.root,
                                style: {
                                    minHeight: height,
                                    opacity: rootProps.showColumnRightBorder
                                        ? 0
                                        : 1,
                                },
                            },
                            other,
                            {
                                onClick: stopClick,
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    rootProps.components.ColumnResizeIcon,
                                    {
                                        className: classes.icon,
                                    }
                                ),
                            }
                        )
                    )
                );
            }

            const GridColumnHeaderSeparator = /*#__PURE__*/ react.memo(
                GridColumnHeaderSeparatorRaw
            );
            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/ColumnHeaderMenuIcon.js

            const ColumnHeaderMenuIcon_useUtilityClasses = (ownerState) => {
                const { classes, open } = ownerState;
                const slots = {
                    root: ["menuIcon", open && "menuOpen"],
                    button: ["menuIconButton"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const ColumnHeaderMenuIcon = /*#__PURE__*/ react.memo((props) => {
                const {
                    column,
                    open,
                    columnMenuId,
                    columnMenuButtonId,
                    iconButtonRef,
                } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    classes: rootProps.classes,
                });

                const classes =
                    ColumnHeaderMenuIcon_useUtilityClasses(ownerState);
                const handleMenuIconClick = react.useCallback(
                    (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        apiRef.current.toggleColumnMenu(column.field);
                    },
                    [apiRef, column.field]
                );
                return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                    className: classes.root,
                    children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        IconButton /* default */.Z,
                        {
                            ref: iconButtonRef,
                            tabIndex: -1,
                            className: classes.button,
                            "aria-label":
                                apiRef.current.getLocaleText("columnMenuLabel"),
                            title: apiRef.current.getLocaleText(
                                "columnMenuLabel"
                            ),
                            size: "small",
                            onClick: handleMenuIconClick,
                            "aria-expanded": open ? "true" : undefined,
                            "aria-haspopup": "true",
                            "aria-controls": columnMenuId,
                            id: columnMenuButtonId,
                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                rootProps.components.ColumnMenuIcon,
                                {
                                    fontSize: "small",
                                }
                            ),
                        }
                    ),
                });
            }); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/menu/columnMenu/GridColumnHeaderMenu.js
            function GridColumnHeaderMenu({
                columnMenuId,
                columnMenuButtonId,
                ContentComponent,
                contentComponentProps,
                field,
                open,
                target,
                onExited,
            }) {
                const apiRef = useGridApiContext();
                const currentColumn = apiRef.current.getColumn(field);
                const hideMenu = react.useCallback(
                    (event) => {
                        // Prevent triggering the sorting
                        event.stopPropagation();
                        apiRef.current.hideColumnMenu();
                    },
                    [apiRef]
                );

                if (!target) {
                    return null;
                }

                return /*#__PURE__*/ (0, jsx_runtime.jsx)(GridMenu, {
                    placement: `bottom-${
                        currentColumn.align === "right" ? "start" : "end"
                    }`,
                    open: open,
                    target: target,
                    onClickAway: hideMenu,
                    onExited: onExited,
                    children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        ContentComponent,
                        (0, esm_extends /* default */.Z)(
                            {
                                currentColumn: currentColumn,
                                hideMenu: hideMenu,
                                open: open,
                                id: columnMenuId,
                                labelledby: columnMenuButtonId,
                            },
                            contentComponentProps
                        )
                    ),
                });
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnHeaderItem.js

            const GridColumnHeaderItem_useUtilityClasses = (ownerState) => {
                const {
                    column,
                    classes,
                    isDragging,
                    sortDirection,
                    showRightBorder,
                    filterItemsCounter,
                } = ownerState;
                const isColumnSorted = sortDirection != null;
                const isColumnFiltered =
                    filterItemsCounter != null && filterItemsCounter > 0; // todo refactor to a prop on col isNumeric or ?? ie: coltype===price wont work

                const isColumnNumeric = column.type === "number";
                const slots = {
                    root: [
                        "columnHeader",
                        column.headerAlign === "left" &&
                            "columnHeader--alignLeft",
                        column.headerAlign === "center" &&
                            "columnHeader--alignCenter",
                        column.headerAlign === "right" &&
                            "columnHeader--alignRight",
                        column.sortable && "columnHeader--sortable",
                        isDragging && "columnHeader--moving",
                        isColumnSorted && "columnHeader--sorted",
                        isColumnFiltered && "columnHeader--filtered",
                        isColumnNumeric && "columnHeader--numeric",
                        showRightBorder && "withBorder",
                    ],
                    draggableContainer: ["columnHeaderDraggableContainer"],
                    titleContainer: ["columnHeaderTitleContainer"],
                    titleContainerContent: [
                        "columnHeaderTitleContainerContent",
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            function GridColumnHeaderItem(props) {
                var _apiRef$current$getRo,
                    _column$sortingOrder,
                    _rootProps$components,
                    _column$headerName,
                    _rootProps$components2;

                const {
                    column,
                    columnMenuOpen,
                    colIndex,
                    headerHeight,
                    isResizing,
                    isLastColumn,
                    sortDirection,
                    sortIndex,
                    filterItemsCounter,
                    hasFocus,
                    tabIndex,
                    extendRowFullWidth,
                    disableReorder,
                    separatorSide,
                } = props;
                const apiRef = useGridApiContext();
                const rootProps = useGridRootProps();
                const headerCellRef = react.useRef(null);
                const columnMenuId = (0, useId /* default */.Z)();
                const columnMenuButtonId = (0, useId /* default */.Z)();
                const iconButtonRef = react.useRef(null);
                const [showColumnMenuIcon, setShowColumnMenuIcon] =
                    react.useState(columnMenuOpen);
                const { hasScrollX, hasScrollY } =
                    (_apiRef$current$getRo =
                        apiRef.current.getRootDimensions()) != null
                        ? _apiRef$current$getRo
                        : {
                              hasScrollX: false,
                              hasScrollY: false,
                          };
                let headerComponent = null;

                if (column.renderHeader) {
                    headerComponent = column.renderHeader(
                        apiRef.current.getColumnHeaderParams(column.field)
                    );
                }

                const publish = react.useCallback(
                    (eventName) => (event) => {
                        // Ignore portal
                        // See https://github.com/mui/mui-x/issues/1721
                        if (!event.currentTarget.contains(event.target)) {
                            return;
                        }

                        apiRef.current.publishEvent(
                            eventName,
                            apiRef.current.getColumnHeaderParams(column.field),
                            event
                        );
                    },
                    [apiRef, column.field]
                );
                const mouseEventsHandlers = {
                    onClick: publish(
                        gridEvents /* GridEvents.columnHeaderClick */.t
                            .columnHeaderClick
                    ),
                    onDoubleClick: publish(
                        gridEvents /* GridEvents.columnHeaderDoubleClick */.t
                            .columnHeaderDoubleClick
                    ),
                    onMouseOver: publish(
                        gridEvents /* GridEvents.columnHeaderOver */.t
                            .columnHeaderOver
                    ),
                    // TODO remove as it's not used
                    onMouseOut: publish(
                        gridEvents /* GridEvents.columnHeaderOut */.t
                            .columnHeaderOut
                    ),
                    // TODO remove as it's not used
                    onMouseEnter: publish(
                        gridEvents /* GridEvents.columnHeaderEnter */.t
                            .columnHeaderEnter
                    ),
                    // TODO remove as it's not used
                    onMouseLeave: publish(
                        gridEvents /* GridEvents.columnHeaderLeave */.t
                            .columnHeaderLeave
                    ),
                    // TODO remove as it's not used
                    onKeyDown: publish(
                        gridEvents /* GridEvents.columnHeaderKeyDown */.t
                            .columnHeaderKeyDown
                    ),
                    onFocus: publish(
                        gridEvents /* GridEvents.columnHeaderFocus */.t
                            .columnHeaderFocus
                    ),
                    onBlur: publish(
                        gridEvents /* GridEvents.columnHeaderBlur */.t
                            .columnHeaderBlur
                    ),
                };
                const draggableEventHandlers = {
                    onDragStart: publish(
                        gridEvents /* GridEvents.columnHeaderDragStart */.t
                            .columnHeaderDragStart
                    ),
                    onDragEnter: publish(
                        gridEvents /* GridEvents.columnHeaderDragEnter */.t
                            .columnHeaderDragEnter
                    ),
                    onDragOver: publish(
                        gridEvents /* GridEvents.columnHeaderDragOver */.t
                            .columnHeaderDragOver
                    ),
                    onDragEnd: publish(
                        gridEvents /* GridEvents.columnHeaderDragEnd */.t
                            .columnHeaderDragEnd
                    ),
                };
                const removeLastBorderRight =
                    isLastColumn && hasScrollX && !hasScrollY;
                const showRightBorder = !isLastColumn
                    ? rootProps.showColumnRightBorder
                    : !removeLastBorderRight && !extendRowFullWidth;

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    classes: rootProps.classes,
                    showRightBorder,
                });

                const classes =
                    GridColumnHeaderItem_useUtilityClasses(ownerState);
                const width = column.computedWidth;
                let ariaSort;

                if (sortDirection != null) {
                    ariaSort =
                        sortDirection === "asc" ? "ascending" : "descending";
                }

                react.useEffect(() => {
                    if (!showColumnMenuIcon) {
                        setShowColumnMenuIcon(columnMenuOpen);
                    }
                }, [showColumnMenuIcon, columnMenuOpen]);
                const handleExited = react.useCallback(() => {
                    setShowColumnMenuIcon(false);
                }, []);

                const columnMenuIconButton =
                    !rootProps.disableColumnMenu &&
                    !column.disableColumnMenu &&
                    /*#__PURE__*/ (0, jsx_runtime.jsx)(ColumnHeaderMenuIcon, {
                        column: column,
                        columnMenuId: columnMenuId,
                        columnMenuButtonId: columnMenuButtonId,
                        open: showColumnMenuIcon,
                        iconButtonRef: iconButtonRef,
                    });

                const sortingOrder =
                    (_column$sortingOrder = column.sortingOrder) != null
                        ? _column$sortingOrder
                        : rootProps.sortingOrder;

                const columnTitleIconButtons = /*#__PURE__*/ (0,
                jsx_runtime.jsxs)(react.Fragment, {
                    children: [
                        !rootProps.disableColumnFilter &&
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                rootProps.components
                                    .ColumnHeaderFilterIconButton,
                                (0, esm_extends /* default */.Z)(
                                    {
                                        field: column.field,
                                        counter: filterItemsCounter,
                                    },
                                    (_rootProps$components =
                                        rootProps.componentsProps) == null
                                        ? void 0
                                        : _rootProps$components.columnHeaderFilterIconButton
                                )
                            ),
                        column.sortable &&
                            !column.hideSortIcons &&
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                GridColumnHeaderSortIcon,
                                {
                                    direction: sortDirection,
                                    index: sortIndex,
                                    sortingOrder: sortingOrder,
                                }
                            ),
                    ],
                });

                react.useLayoutEffect(() => {
                    const columnMenuState = apiRef.current.state.columnMenu;

                    if (hasFocus && !columnMenuState.open) {
                        const focusableElement =
                            headerCellRef.current.querySelector(
                                '[tabindex="0"]'
                            );
                        const elementToFocus =
                            focusableElement || headerCellRef.current;
                        elementToFocus == null
                            ? void 0
                            : elementToFocus.focus();
                        apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
                    }
                }, [apiRef, hasFocus]);
                const headerClassName =
                    typeof column.headerClassName === "function"
                        ? column.headerClassName({
                              field: column.field,
                              colDef: column,
                          })
                        : column.headerClassName;
                return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                    "div",
                    (0, esm_extends /* default */.Z)(
                        {
                            ref: headerCellRef,
                            className: (0, clsx_m /* default */.Z)(
                                classes.root,
                                headerClassName
                            ),
                            "data-field": column.field,
                            style: {
                                width,
                                minWidth: width,
                                maxWidth: width,
                            },
                            role: "columnheader",
                            tabIndex: tabIndex,
                            "aria-colindex": colIndex + 1,
                            "aria-sort": ariaSort,
                        },
                        mouseEventsHandlers,
                        {
                            children: [
                                /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                                    "div",
                                    (0, esm_extends /* default */.Z)(
                                        {
                                            className:
                                                classes.draggableContainer,
                                            draggable:
                                                !rootProps.disableColumnReorder &&
                                                !disableReorder &&
                                                !column.disableReorder,
                                        },
                                        draggableEventHandlers,
                                        {
                                            children: [
                                                /*#__PURE__*/ (0,
                                                jsx_runtime.jsxs)("div", {
                                                    className:
                                                        classes.titleContainer,
                                                    children: [
                                                        /*#__PURE__*/ (0,
                                                        jsx_runtime.jsx)(
                                                            "div",
                                                            {
                                                                className:
                                                                    classes.titleContainerContent,
                                                                children:
                                                                    headerComponent ||
                                                                    /*#__PURE__*/ (0,
                                                                    jsx_runtime.jsx)(
                                                                        GridColumnHeaderTitle,
                                                                        {
                                                                            label:
                                                                                (_column$headerName =
                                                                                    column.headerName) !=
                                                                                null
                                                                                    ? _column$headerName
                                                                                    : column.field,
                                                                            description:
                                                                                column.description,
                                                                            columnWidth:
                                                                                width,
                                                                        }
                                                                    ),
                                                            }
                                                        ),
                                                        columnTitleIconButtons,
                                                    ],
                                                }),
                                                columnMenuIconButton,
                                            ],
                                        }
                                    )
                                ),
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    GridColumnHeaderSeparator,
                                    {
                                        resizable:
                                            !rootProps.disableColumnResize &&
                                            !!column.resizable,
                                        resizing: isResizing,
                                        height: headerHeight,
                                        onMouseDown: publish(
                                            gridEvents /* GridEvents.columnSeparatorMouseDown */
                                                .t.columnSeparatorMouseDown
                                        ),
                                        side: separatorSide,
                                    }
                                ),
                                /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                    GridColumnHeaderMenu,
                                    {
                                        columnMenuId: columnMenuId,
                                        columnMenuButtonId: columnMenuButtonId,
                                        field: column.field,
                                        open: columnMenuOpen,
                                        target: iconButtonRef.current,
                                        ContentComponent:
                                            rootProps.components.ColumnMenu,
                                        contentComponentProps:
                                            (_rootProps$components2 =
                                                rootProps.componentsProps) ==
                                            null
                                                ? void 0
                                                : _rootProps$components2.columnMenu,
                                        onExited: handleExited,
                                    }
                                ),
                            ],
                        }
                    )
                );
            }

            false ? 0 : void 0; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/hooks/features/columnHeaders/useGridColumnHeaders.js

            function isUIEvent(event) {
                return !!event.target;
            }

            const useGridColumnHeaders = (props) => {
                const { innerRef: innerRefProp, minColumnIndex = 0 } = props;
                const [dragCol, setDragCol] = react.useState("");
                const [resizeCol, setResizeCol] = react.useState("");
                const apiRef = useGridApiContext();
                const visibleColumns = useGridSelector(
                    apiRef,
                    gridVisibleColumnDefinitionsSelector
                );
                const columnPositions = useGridSelector(
                    apiRef,
                    gridColumnPositionsSelector
                );
                const tabIndexState = useGridSelector(
                    apiRef,
                    gridTabIndexColumnHeaderSelector
                );
                const cellTabIndexState = useGridSelector(
                    apiRef,
                    gridTabIndexCellSelector
                );
                const columnHeaderFocus = useGridSelector(
                    apiRef,
                    gridFocusColumnHeaderSelector
                );
                const headerHeight = useGridSelector(
                    apiRef,
                    gridDensityHeaderHeightSelector
                );
                const filterColumnLookup = useGridSelector(
                    apiRef,
                    gridFilterActiveItemsLookupSelector
                );
                const sortColumnLookup = useGridSelector(
                    apiRef,
                    gridSortColumnLookupSelector
                );
                const columnMenuState = useGridSelector(
                    apiRef,
                    gridColumnMenuSelector
                );
                const rootProps = useGridRootProps();
                const innerRef = react.useRef(null);
                const handleInnerRef = (0, useForkRef /* default */.Z)(
                    innerRefProp,
                    innerRef
                );
                const [renderContext, setRenderContext] = react.useState(null);
                const prevRenderContext = react.useRef(renderContext);
                const prevScrollLeft = react.useRef(0);
                const currentPage = useGridVisibleRows(apiRef, rootProps);
                react.useEffect(() => {
                    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
                }, [apiRef]); // memoize `getFirstColumnIndexToRender`, since it's called on scroll

                const getFirstColumnIndexToRenderRef = react.useRef(
                    defaultMemoize(getFirstColumnIndexToRender, {
                        equalityCheck: (a, b) =>
                            [
                                "firstColumnIndex",
                                "minColumnIndex",
                                "columnBuffer",
                            ].every((key) => a[key] === b[key]),
                    })
                );
                const updateInnerPosition = react.useCallback(
                    (nextRenderContext) => {
                        const [firstRowToRender, lastRowToRender] =
                            getRenderableIndexes({
                                firstIndex: nextRenderContext.firstRowIndex,
                                lastIndex: nextRenderContext.lastRowIndex,
                                minFirstIndex: 0,
                                maxLastIndex: currentPage.rows.length,
                                buffer: rootProps.rowBuffer,
                            });
                        const firstColumnToRender =
                            getFirstColumnIndexToRenderRef.current({
                                firstColumnIndex:
                                    nextRenderContext.firstColumnIndex,
                                minColumnIndex,
                                columnBuffer: rootProps.columnBuffer,
                                firstRowToRender,
                                lastRowToRender,
                                apiRef,
                                visibleRows: currentPage.rows,
                            });
                        const offset =
                            firstColumnToRender > 0
                                ? prevScrollLeft.current -
                                  columnPositions[firstColumnToRender]
                                : prevScrollLeft.current;
                        innerRef.current.style.transform = `translate3d(${-offset}px, 0px, 0px)`;
                    },
                    [
                        columnPositions,
                        minColumnIndex,
                        rootProps.columnBuffer,
                        apiRef,
                        currentPage.rows,
                        rootProps.rowBuffer,
                    ]
                );
                react.useLayoutEffect(() => {
                    if (renderContext) {
                        updateInnerPosition(renderContext);
                    }
                }, [renderContext, updateInnerPosition]);
                const handleScroll = react.useCallback(
                    (
                        { left, renderContext: nextRenderContext = null },
                        event
                    ) => {
                        var _prevRenderContext$cu, _prevRenderContext$cu2;

                        if (!innerRef.current) {
                            return;
                        } // Ignore vertical scroll.
                        // Excepts the first event which sets the previous render context.

                        if (
                            prevScrollLeft.current === left &&
                            ((_prevRenderContext$cu =
                                prevRenderContext.current) == null
                                ? void 0
                                : _prevRenderContext$cu.firstColumnIndex) ===
                                (nextRenderContext == null
                                    ? void 0
                                    : nextRenderContext.firstColumnIndex) &&
                            ((_prevRenderContext$cu2 =
                                prevRenderContext.current) == null
                                ? void 0
                                : _prevRenderContext$cu2.lastColumnIndex) ===
                                (nextRenderContext == null
                                    ? void 0
                                    : nextRenderContext.lastColumnIndex)
                        ) {
                            return;
                        }

                        prevScrollLeft.current = left; // We can only update the position when we guarantee that the render context has been
                        // rendered. This is achieved using ReactDOM.flushSync or when the context doesn't change.

                        let canUpdateInnerPosition = false;

                        if (
                            nextRenderContext !== prevRenderContext.current ||
                            !prevRenderContext.current
                        ) {
                            // ReactDOM.flushSync cannot be called on `scroll` events fired inside effects
                            if (isUIEvent(event)) {
                                // To prevent flickering, the inner position can only be updated after the new context has
                                // been rendered. ReactDOM.flushSync ensures that the state changes will happen before
                                // updating the position.
                                react_dom.flushSync(() => {
                                    setRenderContext(nextRenderContext);
                                });
                                canUpdateInnerPosition = true;
                            } else {
                                setRenderContext(nextRenderContext);
                            }

                            prevRenderContext.current = nextRenderContext;
                        } else {
                            canUpdateInnerPosition = true;
                        } // Pass directly the render context to avoid waiting for the next render

                        if (nextRenderContext && canUpdateInnerPosition) {
                            updateInnerPosition(nextRenderContext);
                        }
                    },
                    [updateInnerPosition]
                );
                const handleColumnResizeStart = react.useCallback(
                    (params) => setResizeCol(params.field),
                    []
                );
                const handleColumnResizeStop = react.useCallback(
                    () => setResizeCol(""),
                    []
                );
                const handleColumnReorderStart = react.useCallback(
                    (params) => setDragCol(params.field),
                    []
                );
                const handleColumnReorderStop = react.useCallback(
                    () => setDragCol(""),
                    []
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnResizeStart */.t
                        .columnResizeStart,
                    handleColumnResizeStart
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnResizeStop */.t
                        .columnResizeStop,
                    handleColumnResizeStop
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderDragStart */.t
                        .columnHeaderDragStart,
                    handleColumnReorderStart
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderDragEnd */.t
                        .columnHeaderDragEnd,
                    handleColumnReorderStop
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowsScroll */.t.rowsScroll,
                    handleScroll
                );

                const getColumns = (params, other = {}) => {
                    const {
                        renderContext: nextRenderContext = renderContext,
                        minFirstColumn = minColumnIndex,
                        maxLastColumn = visibleColumns.length,
                    } = params || {};

                    if (!nextRenderContext) {
                        return null;
                    }

                    const columns = [];
                    const [firstRowToRender, lastRowToRender] =
                        getRenderableIndexes({
                            firstIndex: nextRenderContext.firstRowIndex,
                            lastIndex: nextRenderContext.lastRowIndex,
                            minFirstIndex: 0,
                            maxLastIndex: currentPage.rows.length,
                            buffer: rootProps.rowBuffer,
                        });
                    const firstColumnToRender =
                        getFirstColumnIndexToRenderRef.current({
                            firstColumnIndex:
                                nextRenderContext.firstColumnIndex,
                            minColumnIndex: minFirstColumn,
                            columnBuffer: rootProps.columnBuffer,
                            apiRef,
                            firstRowToRender,
                            lastRowToRender,
                            visibleRows: currentPage.rows,
                        });
                    const lastColumnToRender = Math.min(
                        nextRenderContext.lastColumnIndex +
                            rootProps.columnBuffer,
                        maxLastColumn
                    );
                    const renderedColumns = visibleColumns.slice(
                        firstColumnToRender,
                        lastColumnToRender
                    );

                    for (let i = 0; i < renderedColumns.length; i += 1) {
                        const column = renderedColumns[i];
                        const columnIndex = firstColumnToRender + i;
                        const isFirstColumn = columnIndex === 0;
                        const hasTabbableElement = !(
                            tabIndexState === null && cellTabIndexState === null
                        );
                        const tabIndex =
                            (tabIndexState !== null &&
                                tabIndexState.field === column.field) ||
                            (isFirstColumn && !hasTabbableElement)
                                ? 0
                                : -1;
                        const hasFocus =
                            columnHeaderFocus !== null &&
                            columnHeaderFocus.field === column.field;
                        const open =
                            columnMenuState.open &&
                            columnMenuState.field === column.field;
                        columns.push(
                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                GridColumnHeaderItem,
                                (0, esm_extends /* default */.Z)(
                                    {},
                                    sortColumnLookup[column.field],
                                    {
                                        columnMenuOpen: open,
                                        filterItemsCounter:
                                            filterColumnLookup[column.field] &&
                                            filterColumnLookup[column.field]
                                                .length,
                                        headerHeight: headerHeight,
                                        isDragging: column.field === dragCol,
                                        column: column,
                                        colIndex: columnIndex,
                                        isResizing: resizeCol === column.field,
                                        isLastColumn:
                                            columnIndex ===
                                            visibleColumns.length - 1,
                                        extendRowFullWidth:
                                            !rootProps.disableExtendRowFullWidth,
                                        hasFocus: hasFocus,
                                        tabIndex: tabIndex,
                                    },
                                    other
                                ),
                                column.field
                            )
                        );
                    }

                    return columns;
                };

                const rootStyle = {
                    minHeight: headerHeight,
                    maxHeight: headerHeight,
                    lineHeight: `${headerHeight}px`,
                };
                return {
                    renderContext,
                    getColumns,
                    isDragging: !!dragCol,
                    getRootProps: (other = {}) =>
                        (0, esm_extends /* default */.Z)(
                            {
                                style: rootStyle,
                            },
                            other
                        ),
                    getInnerProps: () => ({
                        ref: handleInnerRef,
                        "aria-rowindex": 1,
                        role: "row",
                    }),
                };
            }; // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/GridScrollArea.js
            const CLIFF = 1;
            const SLOP = 1.5;

            const GridScrollArea_useUtilityClasses = (ownerState) => {
                const { scrollDirection, classes } = ownerState;
                const slots = {
                    root: ["scrollArea", `scrollArea--${scrollDirection}`],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridScrollAreaRawRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "ScrollArea",
                overridesResolver: (props, styles) => [
                    {
                        [`&.${gridClasses_gridClasses["scrollArea--left"]}`]:
                            styles["scrollArea--left"],
                    },
                    {
                        [`&.${gridClasses_gridClasses["scrollArea--right"]}`]:
                            styles["scrollArea--right"],
                    },
                    styles.scrollArea,
                ],
            })(() => ({
                position: "absolute",
                top: 0,
                zIndex: 101,
                width: 20,
                bottom: 0,
                [`&.${gridClasses_gridClasses["scrollArea--left"]}`]: {
                    left: 0,
                },
                [`&.${gridClasses_gridClasses["scrollArea--right"]}`]: {
                    right: 0,
                },
            }));

            function GridScrollAreaRaw(props) {
                const { scrollDirection } = props;
                const rootRef = react.useRef(null);
                const apiRef = useGridApiContext();
                const timeout = react.useRef();
                const [dragging, setDragging] = react.useState(false);
                const height = useGridSelector(
                    apiRef,
                    gridDensityHeaderHeightSelector
                );
                const scrollPosition = react.useRef({
                    left: 0,
                    top: 0,
                });
                const rootProps = useGridRootProps();

                const ownerState = (0, esm_extends /* default */.Z)({}, props, {
                    classes: rootProps.classes,
                });

                const classes = GridScrollArea_useUtilityClasses(ownerState);
                const handleScrolling = react.useCallback(
                    (newScrollPosition) => {
                        scrollPosition.current = newScrollPosition;
                    },
                    []
                );
                const handleDragOver = react.useCallback(
                    (event) => {
                        let offset;

                        if (scrollDirection === "left") {
                            offset =
                                event.clientX -
                                rootRef.current.getBoundingClientRect().right;
                        } else if (scrollDirection === "right") {
                            offset = Math.max(
                                1,
                                event.clientX -
                                    rootRef.current.getBoundingClientRect().left
                            );
                        } else {
                            throw new Error("MUI: Wrong drag direction");
                        }

                        offset = (offset - CLIFF) * SLOP + CLIFF;
                        clearTimeout(timeout.current); // Avoid freeze and inertia.

                        timeout.current = setTimeout(() => {
                            apiRef.current.scroll({
                                left: scrollPosition.current.left + offset,
                                top: scrollPosition.current.top,
                            });
                        });
                    },
                    [scrollDirection, apiRef]
                );
                react.useEffect(() => {
                    return () => {
                        clearTimeout(timeout.current);
                    };
                }, []);
                const toggleDragging = react.useCallback(() => {
                    setDragging((prevDragging) => !prevDragging);
                }, []);
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.rowsScroll */.t.rowsScroll,
                    handleScrolling
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderDragStart */.t
                        .columnHeaderDragStart,
                    toggleDragging
                );
                useGridApiEventHandler(
                    apiRef,
                    gridEvents /* GridEvents.columnHeaderDragEnd */.t
                        .columnHeaderDragEnd,
                    toggleDragging
                );
                return dragging
                    ? /*#__PURE__*/ (0, jsx_runtime.jsx)(
                          GridScrollAreaRawRoot,
                          {
                              ref: rootRef,
                              className: (0, clsx_m /* default */.Z)(
                                  classes.root
                              ),
                              onDragOver: handleDragOver,
                              style: {
                                  height,
                              },
                          }
                      )
                    : null;
            }

            false ? 0 : void 0;
            const GridScrollArea = /*#__PURE__*/ react.memo(GridScrollAreaRaw); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnHeaders.js

            const GridColumnHeaders_excluded = ["className"];

            const GridColumnHeaders_useUtilityClasses = (ownerState) => {
                const { classes } = ownerState;
                const slots = {
                    root: ["columnHeaders"],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridColumnHeadersRoot = (0, styled /* default */.ZP)("div", {
                name: "MuiDataGrid",
                slot: "ColumnHeaders",
                overridesResolver: (props, styles) => styles.columnHeaders,
            })(({ theme }) => {
                const borderColor =
                    theme.palette.mode === "light"
                        ? (0, colorManipulator /* lighten */.$n)(
                              (0, colorManipulator /* alpha */.Fq)(
                                  theme.palette.divider,
                                  1
                              ),
                              0.88
                          )
                        : (0, colorManipulator /* darken */._j)(
                              (0, colorManipulator /* alpha */.Fq)(
                                  theme.palette.divider,
                                  1
                              ),
                              0.68
                          );
                return {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    overflow: "hidden",
                    display: "flex",
                    alignItems: "center",
                    borderBottom: `1px solid ${borderColor}`,
                    borderTopLeftRadius: theme.shape.borderRadius,
                    borderTopRightRadius: theme.shape.borderRadius,
                };
            });
            const GridColumnHeaders = /*#__PURE__*/ react.forwardRef(
                function GridColumnHeaders(props, ref) {
                    const { className } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridColumnHeaders_excluded
                        );

                    const rootProps = useGridRootProps();
                    const ownerState = {
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridColumnHeaders_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridColumnHeadersRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    className,
                                    classes.root
                                ),
                            },
                            other
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/columnHeaders/GridColumnHeadersInner.js
            const GridColumnHeadersInner_excluded = ["isDragging", "className"];

            const GridColumnHeadersInner_useUtilityClasses = (ownerState) => {
                const { isDragging, hasScrollX, classes } = ownerState;
                const slots = {
                    root: [
                        "columnHeadersInner",
                        isDragging && "columnHeaderDropZone",
                        hasScrollX && "columnHeadersInner--scrollable",
                    ],
                };
                return (0, composeClasses /* default */.Z)(
                    slots,
                    getDataGridUtilityClass,
                    classes
                );
            };

            const GridColumnHeadersInnerRoot = (0, styled /* default */.ZP)(
                "div",
                {
                    name: "MuiDataGrid",
                    slot: "columnHeadersInner",
                    overridesResolver: (props, styles) => [
                        {
                            [`&.${gridClasses_gridClasses.columnHeaderDropZone}`]:
                                styles.columnHeaderDropZone,
                        },
                        styles.columnHeadersInner,
                    ],
                }
            )(() => ({
                display: "flex",
                alignItems: "center",
                [`&.${gridClasses_gridClasses.columnHeaderDropZone} .${gridClasses_gridClasses.columnHeaderDraggableContainer}`]:
                    {
                        cursor: "move",
                    },
                [`&.${gridClasses_gridClasses["columnHeadersInner--scrollable"]} .${gridClasses_gridClasses.columnHeader}:last-child`]:
                    {
                        borderRight: "none",
                    },
            }));
            const GridColumnHeadersInner = /*#__PURE__*/ react.forwardRef(
                function GridColumnHeadersInner(props, ref) {
                    var _apiRef$current$getRo, _apiRef$current$getRo2;

                    const { isDragging, className } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            GridColumnHeadersInner_excluded
                        );

                    const apiRef = useGridApiContext();
                    const rootProps = useGridRootProps();
                    const ownerState = {
                        isDragging,
                        hasScrollX:
                            (_apiRef$current$getRo =
                                (_apiRef$current$getRo2 =
                                    apiRef.current.getRootDimensions()) == null
                                    ? void 0
                                    : _apiRef$current$getRo2.hasScrollX) != null
                                ? _apiRef$current$getRo
                                : false,
                        classes: rootProps.classes,
                    };
                    const classes =
                        GridColumnHeadersInner_useUtilityClasses(ownerState);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridColumnHeadersInnerRoot,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                                className: (0, clsx_m /* default */.Z)(
                                    className,
                                    classes.root
                                ),
                            },
                            other
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/components/DataGridColumnHeaders.js
            const DataGridColumnHeaders_excluded = ["innerRef", "className"];

            const DataGridColumnHeaders = /*#__PURE__*/ react.forwardRef(
                function GridColumnsHeader(props, ref) {
                    const { innerRef } = props,
                        other = (0,
                        objectWithoutPropertiesLoose /* default */.Z)(
                            props,
                            DataGridColumnHeaders_excluded
                        );

                    const {
                        isDragging,
                        getRootProps,
                        getInnerProps,
                        getColumns,
                    } = useGridColumnHeaders({
                        innerRef,
                    });
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(
                        GridColumnHeaders,
                        (0, esm_extends /* default */.Z)(
                            {
                                ref: ref,
                            },
                            getRootProps(other),
                            {
                                children: [
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        GridScrollArea,
                                        {
                                            scrollDirection: "left",
                                        }
                                    ),
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        GridColumnHeadersInner,
                                        (0, esm_extends /* default */.Z)(
                                            {
                                                isDragging: isDragging,
                                            },
                                            getInnerProps(),
                                            {
                                                children: getColumns(),
                                            }
                                        )
                                    ),
                                    /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                        GridScrollArea,
                                        {
                                            scrollDirection: "right",
                                        }
                                    ),
                                ],
                            }
                        )
                    );
                }
            ); // CONCATENATED MODULE: ./node_modules/@mui/x-data-grid/DataGrid/DataGrid.js
            const DataGridRaw = /*#__PURE__*/ react.forwardRef(
                function DataGrid(inProps, ref) {
                    const props = useDataGridProps(inProps);
                    const apiRef = useDataGridComponent(props);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(
                        GridContextProvider,
                        {
                            apiRef: apiRef,
                            props: props,
                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                GridRoot,
                                {
                                    className: props.className,
                                    style: props.style,
                                    sx: props.sx,
                                    ref: ref,
                                    children: /*#__PURE__*/ (0,
                                    jsx_runtime.jsxs)(GridErrorHandler, {
                                        children: [
                                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                                GridHeaderPlaceholder,
                                                {}
                                            ),
                                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                                GridBody,
                                                {
                                                    ColumnHeadersComponent:
                                                        DataGridColumnHeaders,
                                                    VirtualScrollerComponent:
                                                        DataGridVirtualScroller,
                                                }
                                            ),
                                            /*#__PURE__*/ (0, jsx_runtime.jsx)(
                                                GridFooterPlaceholder,
                                                {}
                                            ),
                                        ],
                                    }),
                                }
                            ),
                        }
                    );
                }
            );
            const DataGrid = /*#__PURE__*/ react.memo(DataGridRaw);
            DataGridRaw.propTypes = {
                // ----------------------------- Warning --------------------------------
                // | These PropTypes are generated from the TypeScript type definitions |
                // | To update them edit the TypeScript types and run "yarn proptypes"  |
                // ----------------------------------------------------------------------

                /**
                 * The label of the grid.
                 */
                "aria-label": prop_types_default().string,

                /**
                 * The id of the element containing a label for the grid.
                 */
                "aria-labelledby": prop_types_default().string,

                /**
                 * If `true`, the grid height is dynamic and follow the number of rows in the grid.
                 * @default false
                 */
                autoHeight: prop_types_default().bool,

                /**
                 * If `true`, the pageSize is calculated according to the container size and the max number of rows to avoid rendering a vertical scroll bar.
                 * @default false
                 */
                autoPageSize: prop_types_default().bool,

                /**
                 * If `true`, the grid get a first column with a checkbox that allows to select rows.
                 * @default false
                 */
                checkboxSelection: prop_types_default().bool,

                /**
                 * Override or extend the styles applied to the component.
                 */
                classes: prop_types_default().object,

                /**
                 * Number of extra columns to be rendered before/after the visible slice.
                 * @default 3
                 */
                columnBuffer: prop_types_default().number,

                /**
                 * Set of columns of type [[GridColumns]].
                 */
                columns: chainPropTypes(
                    prop_types_default().array.isRequired,
                    (props) => {
                        // @ts-ignore because otherwise `build:api` doesn't work
                        if (
                            props.columns &&
                            props.columns.some((column) => column.resizable)
                        ) {
                            return new Error(
                                [
                                    `MUI: \`column.resizable = true\` is not a valid prop.`,
                                    "Column resizing is not available in the MIT version.",
                                    "",
                                    "You need to upgrade to the DataGridPro component to unlock this feature.",
                                ].join("\n")
                            );
                        }

                        return null;
                    }
                ),

                /**
                 * Number of rows from the `columnBuffer` that can be visible before a new slice is rendered.
                 * @default 3
                 */
                columnThreshold: prop_types_default().number,

                /**
                 * Extend native column types with your new column types.
                 */
                columnTypes: prop_types_default().object,

                /**
                 * Set the column visibility model of the grid.
                 * If defined, the grid will ignore the `hide` property in [[GridColDef]].
                 */
                columnVisibilityModel: prop_types_default().object,

                /**
                 * Overrideable components.
                 */
                components: prop_types_default().object,

                /**
                 * Overrideable components props dynamically passed to the component at rendering.
                 */
                componentsProps: prop_types_default().object,

                /**
                 * Set the density of the grid.
                 * @default "standard"
                 */
                density: prop_types_default().oneOf([
                    "comfortable",
                    "compact",
                    "standard",
                ]),

                /**
                 * If `true`, column filters are disabled.
                 * @default false
                 */
                disableColumnFilter: prop_types_default().bool,

                /**
                 * If `true`, the column menu is disabled.
                 * @default false
                 */
                disableColumnMenu: prop_types_default().bool,

                /**
                 * If `true`, hiding/showing columns is disabled.
                 * @default false
                 */
                disableColumnSelector: prop_types_default().bool,

                /**
                 * If `true`, the density selector is disabled.
                 * @default false
                 */
                disableDensitySelector: prop_types_default().bool,

                /**
                 * If `true`, rows will not be extended to fill the full width of the grid container.
                 * @default false
                 */
                disableExtendRowFullWidth: prop_types_default().bool,

                /**
                 * If `true`, the selection on click on a row or cell is disabled.
                 * @default false
                 */
                disableSelectionOnClick: prop_types_default().bool,

                /**
                 * If `true`, the virtualization is disabled.
                 * @default false
                 */
                disableVirtualization: prop_types_default().bool,

                /**
                 * Controls whether to use the cell or row editing.
                 * @default "cell"
                 */
                editMode: prop_types_default().oneOf(["cell", "row"]),

                /**
                 * Set the edit rows model of the grid.
                 */
                editRowsModel: prop_types_default().object,

                /**
                 * An error that will turn the grid into its error state and display the error component.
                 */
                error: prop_types_default().any,

                /**
                 * Features under development.
                 * For each feature, if the flag is not explicitly set to `true`, the feature will be fully disabled and any property / method call will not have any effect.
                 */
                experimentalFeatures: prop_types_default().shape({
                    newEditingApi: prop_types_default().bool,
                    preventCommitWhileValidating: prop_types_default().bool,
                    warnIfFocusStateIsNotSynced: prop_types_default().bool,
                }),

                /**
                 * Filtering can be processed on the server or client-side.
                 * Set it to 'server' if you would like to handle filtering on the server-side.
                 * @default "client"
                 */
                filterMode: prop_types_default().oneOf(["client", "server"]),

                /**
                 * Set the filter model of the grid.
                 */
                filterModel: prop_types_default().shape({
                    items: prop_types_default().arrayOf(
                        prop_types_default().shape({
                            columnField: prop_types_default().string.isRequired,
                            id: prop_types_default().oneOfType([
                                prop_types_default().number,
                                prop_types_default().string,
                            ]),
                            operatorValue: prop_types_default().string,
                            value: prop_types_default().any,
                        })
                    ).isRequired,
                    linkOperator: prop_types_default().oneOf(["and", "or"]),
                }),

                /**
                 * Function that applies CSS classes dynamically on cells.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @returns {string} The CSS class to apply to the cell.
                 */
                getCellClassName: prop_types_default().func,

                /**
                 * Function that returns the element to render in row detail.
                 * @param {GridRowParams} params With all properties from [[GridRowParams]].
                 * @returns {JSX.Element} The row detail element.
                 */
                getDetailPanelContent: prop_types_default().func,

                /**
                 * Function that applies CSS classes dynamically on rows.
                 * @param {GridRowClassNameParams} params With all properties from [[GridRowClassNameParams]].
                 * @returns {string} The CSS class to apply to the row.
                 */
                getRowClassName: prop_types_default().func,

                /**
                 * Function that sets the row height per row.
                 * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
                 * @returns {GridRowHeightReturnValue} The row height value. If `null` or `undefined` then the default row height is applied.
                 */
                getRowHeight: prop_types_default().func,

                /**
                 * Return the id of a given [[GridRowModel]].
                 */
                getRowId: prop_types_default().func,

                /**
                 * Function that allows to specify the spacing between rows.
                 * @param {GridRowSpacingParams} params With all properties from [[GridRowSpacingParams]].
                 * @returns {GridRowSpacing} The row spacing values.
                 */
                getRowSpacing: prop_types_default().func,

                /**
                 * Set the height in pixel of the column headers in the grid.
                 * @default 56
                 */
                headerHeight: prop_types_default().number,

                /**
                 * If `true`, the footer component is hidden.
                 * @default false
                 */
                hideFooter: prop_types_default().bool,

                /**
                 * If `true`, the pagination component in the footer is hidden.
                 * @default false
                 */
                hideFooterPagination: prop_types_default().bool,

                /**
                 * If `true`, the selected row count in the footer is hidden.
                 * @default false
                 */
                hideFooterSelectedRowCount: prop_types_default().bool,

                /**
                 * The initial state of the DataGrid.
                 * The data in it will be set in the state on initialization but will not be controlled.
                 * If one of the data in `initialState` is also being controlled, then the control state wins.
                 */
                initialState: prop_types_default().object,

                /**
                 * Callback fired when a cell is rendered, returns true if the cell is editable.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @returns {boolean} A boolean indicating if the cell is editable.
                 */
                isCellEditable: prop_types_default().func,

                /**
                 * Determines if a row can be selected.
                 * @param {GridRowParams} params With all properties from [[GridRowParams]].
                 * @returns {boolean} A boolean indicating if the cell is selectable.
                 */
                isRowSelectable: prop_types_default().func,

                /**
                 * If `true`, a  loading overlay is displayed.
                 */
                loading: prop_types_default().bool,

                /**
                 * Set the locale text of the grid.
                 * You can find all the translation keys supported in [the source](https://github.com/mui/mui-x/blob/HEAD/packages/grid/x-data-grid/src/constants/localeTextConstants.ts) in the GitHub repository.
                 */
                localeText: prop_types_default().object,

                /**
                 * Pass a custom logger in the components that implements the [[Logger]] interface.
                 * @default console
                 */
                logger: prop_types_default().shape({
                    debug: prop_types_default().func.isRequired,
                    error: prop_types_default().func.isRequired,
                    info: prop_types_default().func.isRequired,
                    warn: prop_types_default().func.isRequired,
                }),

                /**
                 * Allows to pass the logging level or false to turn off logging.
                 * @default "debug"
                 */
                logLevel: prop_types_default().oneOf([
                    "debug",
                    "error",
                    "info",
                    "warn",
                    false,
                ]),

                /**
                 * Nonce of the inline styles for [Content Security Policy](https://www.w3.org/TR/2016/REC-CSP2-20161215/#script-src-the-nonce-attribute).
                 */
                nonce: prop_types_default().string,

                /**
                 * Callback fired when any cell is clicked.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onCellClick: prop_types_default().func,

                /**
                 * Callback fired when a double click event comes from a cell element.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onCellDoubleClick: prop_types_default().func,

                /**
                 * Callback fired when the cell changes are committed.
                 * @param {GridCellEditCommitParams} params With all properties from [[GridCellEditCommitParams]].
                 * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onCellEditCommit: prop_types_default().func,

                /**
                 * Callback fired when the cell turns to edit mode.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
                 */
                onCellEditStart: prop_types_default().func,

                /**
                 * Callback fired when the cell turns to view mode.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
                 */
                onCellEditStop: prop_types_default().func,

                /**
                 * Callback fired when a cell loses focus.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @param {MuiEvent<MuiBaseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onCellFocusOut: prop_types_default().func,

                /**
                 * Callback fired when a keydown event comes from a cell element.
                 * @param {GridCellParams} params With all properties from [[GridCellParams]].
                 * @param {MuiEvent<React.KeyboardEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onCellKeyDown: prop_types_default().func,

                /**
                 * Callback fired when a click event comes from a column header element.
                 * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnHeaderClick: prop_types_default().func,

                /**
                 * Callback fired when a double click event comes from a column header element.
                 * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnHeaderDoubleClick: prop_types_default().func,

                /**
                 * Callback fired when a mouse enter event comes from a column header element.
                 * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnHeaderEnter: prop_types_default().func,

                /**
                 * Callback fired when a mouse leave event comes from a column header element.
                 * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnHeaderLeave: prop_types_default().func,

                /**
                 * Callback fired when a mouseout event comes from a column header element.
                 * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnHeaderOut: prop_types_default().func,

                /**
                 * Callback fired when a mouseover event comes from a column header element.
                 * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnHeaderOver: prop_types_default().func,

                /**
                 * Callback fired when a column is reordered.
                 * @param {GridColumnOrderChangeParams} params With all properties from [[GridColumnOrderChangeParams]].
                 * @param {MuiEvent<{}>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnOrderChange: prop_types_default().func,

                /**
                 * Callback fired when a column visibility changes.
                 * Only works when no `columnVisibilityModel` is provided and if we change the visibility of a single column at a time.
                 * @param {GridColumnVisibilityChangeParams} params With all properties from [[GridColumnVisibilityChangeParams]].
                 * @param {MuiEvent<{}>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 * @deprecated Use `onColumnVisibilityModelChange` instead.
                 */
                onColumnVisibilityChange: prop_types_default().func,

                /**
                 * Callback fired when the column visibility model changes.
                 * @param {GridColumnVisibilityModel} model The new model.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onColumnVisibilityModelChange: prop_types_default().func,

                /**
                 * Callback fired when the edit cell value changes.
                 * @param {GridEditCellPropsParams} params With all properties from [[GridEditCellPropsParams]].
                 * @param {MuiEvent<React.SyntheticEvent>} event The event that caused this prop to be called.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 * @deprecated use `preProcessEditCellProps` from the [`GridColDef`](/x/api/data-grid/grid-col-def/)
                 */
                onEditCellPropsChange: prop_types_default().func,

                /**
                 * Callback fired when the `editRowsModel` changes.
                 * @param {GridEditRowsModel} editRowsModel With all properties from [[GridEditRowsModel]].
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onEditRowsModelChange: prop_types_default().func,

                /**
                 * Callback fired when an exception is thrown in the grid.
                 * @param {any} args The arguments passed to the `showError` call.
                 * @param {MuiEvent<{}>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onError: prop_types_default().func,

                /**
                 * Callback fired when the Filter model changes before the filters are applied.
                 * @param {GridFilterModel} model With all properties from [[GridFilterModel]].
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onFilterModelChange: prop_types_default().func,

                /**
                 * Callback fired when the current page has changed.
                 * @param {number} page Index of the page displayed on the Grid.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onPageChange: prop_types_default().func,

                /**
                 * Callback fired when the page size has changed.
                 * @param {number} pageSize Size of the page displayed on the Grid.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onPageSizeChange: prop_types_default().func,

                /**
                 * Callback fired when the preferences panel is closed.
                 * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
                 * @param {MuiEvent<{}>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onPreferencePanelClose: prop_types_default().func,

                /**
                 * Callback fired when the preferences panel is opened.
                 * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
                 * @param {MuiEvent<{}>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onPreferencePanelOpen: prop_types_default().func,

                /**
                 * Callback called when `processRowUpdate` throws an error or rejects.
                 * @param {any} error The error thrown.
                 */
                onProcessRowUpdateError: prop_types_default().func,

                /**
                 * Callback fired when the grid is resized.
                 * @param {ElementSize} containerSize With all properties from [[ElementSize]].
                 * @param {MuiEvent<{}>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onResize: prop_types_default().func,

                /**
                 * Callback fired when a row is clicked.
                 * Not called if the target clicked is an interactive element added by the built-in columns.
                 * @param {GridRowParams} params With all properties from [[GridRowParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onRowClick: prop_types_default().func,

                /**
                 * Callback fired when a double click event comes from a row container element.
                 * @param {GridRowParams} params With all properties from [[RowParams]].
                 * @param {MuiEvent<React.MouseEvent>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onRowDoubleClick: prop_types_default().func,

                /**
                 * Callback fired when the row changes are committed.
                 * @param {GridRowId} id The row id.
                 * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
                 */
                onRowEditCommit: prop_types_default().func,

                /**
                 * Callback fired when the row turns to edit mode.
                 * @param {GridRowParams} params With all properties from [[GridRowParams]].
                 * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
                 */
                onRowEditStart: prop_types_default().func,

                /**
                 * Callback fired when the row turns to view mode.
                 * @param {GridRowParams} params With all properties from [[GridRowParams]].
                 * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
                 */
                onRowEditStop: prop_types_default().func,

                /**
                 * Callback fired when the selection state of one or multiple rows changes.
                 * @param {GridSelectionModel} selectionModel With all the row ids [[GridSelectionModel]].
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onSelectionModelChange: prop_types_default().func,

                /**
                 * Callback fired when the sort model changes before a column is sorted.
                 * @param {GridSortModel} model With all properties from [[GridSortModel]].
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 */
                onSortModelChange: prop_types_default().func,

                /**
                 * Callback fired when the state of the grid is updated.
                 * @param {GridState} state The new state.
                 * @param {MuiEvent<{}>} event The event object.
                 * @param {GridCallbackDetails} details Additional details for this callback.
                 * @internal
                 */
                onStateChange: prop_types_default().func,

                /**
                 * The zero-based index of the current page.
                 * @default 0
                 */
                page: prop_types_default().number,

                /**
                 * Set the number of rows in one page.
                 * If some of the rows have children (for instance in the tree data), this number represents the amount of top level rows wanted on each page.
                 * @default 100
                 */
                pageSize: chainPropTypes(
                    prop_types_default().number,
                    (props) => {
                        if (props.pageSize && props.pageSize > MAX_PAGE_SIZE) {
                            return new Error(
                                [
                                    `MUI: \`<DataGrid pageSize={${props.pageSize}} />\` is not a valid prop.`,
                                    `Only page size below ${MAX_PAGE_SIZE} is available in the MIT version.`,
                                    "",
                                    "You need to upgrade to the DataGridPro component to unlock this feature.",
                                ].join("\n")
                            );
                        }

                        return null;
                    }
                ),
                pagination: (props) => {
                    if (props.pagination === false) {
                        return new Error(
                            [
                                "MUI: `<DataGrid pagination={false} />` is not a valid prop.",
                                "Infinite scrolling is not available in the MIT version.",
                                "",
                                "You need to upgrade to the DataGridPro component to disable the pagination.",
                            ].join("\n")
                        );
                    }

                    return null;
                },

                /**
                 * Pagination can be processed on the server or client-side.
                 * Set it to 'client' if you would like to handle the pagination on the client-side.
                 * Set it to 'server' if you would like to handle the pagination on the server-side.
                 * @default "client"
                 */
                paginationMode: prop_types_default().oneOf([
                    "client",
                    "server",
                ]),

                /**
                 * Callback called before updating a row with new values in the row and cell editing.
                 * Only applied if `props.experimentalFeatures.newEditingApi: true`.
                 * @template R
                 * @param {R} newRow Row object with the new values.
                 * @param {R} oldRow Row object with the old values.
                 * @returns {Promise<R> | R} The final values to update the row.
                 */
                processRowUpdate: prop_types_default().func,

                /**
                 * Number of extra rows to be rendered before/after the visible slice.
                 * @default 3
                 */
                rowBuffer: prop_types_default().number,

                /**
                 * Set the total number of rows, if it is different from the length of the value `rows` prop.
                 * If some rows have children (for instance in the tree data), this number represents the amount of top level rows.
                 */
                rowCount: prop_types_default().number,

                /**
                 * Set the height in pixel of a row in the grid.
                 * @default 52
                 */
                rowHeight: prop_types_default().number,

                /**
                 * Set of rows of type [[GridRowsProp]].
                 */
                rows: prop_types_default().array.isRequired,

                /**
                 * Sets the type of space between rows added by `getRowSpacing`.
                 * @default "margin"
                 */
                rowSpacingType: prop_types_default().oneOf([
                    "border",
                    "margin",
                ]),

                /**
                 * Select the pageSize dynamically using the component UI.
                 * @default [25, 50, 100]
                 */
                rowsPerPageOptions: prop_types_default().arrayOf(
                    prop_types_default().number
                ),

                /**
                 * Number of rows from the `rowBuffer` that can be visible before a new slice is rendered.
                 * @default 3
                 */
                rowThreshold: prop_types_default().number,

                /**
                 * Override the height/width of the grid inner scrollbar.
                 */
                scrollbarSize: prop_types_default().number,

                /**
                 * Set the selection model of the grid.
                 */
                selectionModel: chainPropTypes(
                    prop_types_default().oneOfType([
                        prop_types_default().number,
                        prop_types_default().string,
                        prop_types_default().array,
                    ]),
                    (props) => {
                        if (
                            !props.checkboxSelection &&
                            Array.isArray(props.selectionModel) &&
                            props.selectionModel.length > 1
                        ) {
                            return new Error(
                                [
                                    `MUI: \`<DataGrid selectionModel={${JSON.stringify(
                                        props.selectionModel
                                    )}} />\` is not a valid prop.`,
                                    "selectionModel can only be of 1 item in DataGrid.",
                                    "",
                                    "You need to upgrade to the DataGridPro component to unlock multiple selection.",
                                ].join("\n")
                            );
                        }

                        return null;
                    }
                ),

                /**
                 * If `true`, the right border of the cells are displayed.
                 * @default false
                 */
                showCellRightBorder: prop_types_default().bool,

                /**
                 * If `true`, the right border of the column headers are displayed.
                 * @default false
                 */
                showColumnRightBorder: prop_types_default().bool,

                /**
                 * Sorting can be processed on the server or client-side.
                 * Set it to 'client' if you would like to handle sorting on the client-side.
                 * Set it to 'server' if you would like to handle sorting on the server-side.
                 * @default "client"
                 */
                sortingMode: prop_types_default().oneOf(["client", "server"]),

                /**
                 * The order of the sorting sequence.
                 * @default ['asc', 'desc', null]
                 */
                sortingOrder: prop_types_default().arrayOf(
                    prop_types_default().oneOf(["asc", "desc"])
                ),

                /**
                 * Set the sort model of the grid.
                 */
                sortModel: prop_types_default().arrayOf(
                    prop_types_default().shape({
                        field: prop_types_default().string.isRequired,
                        sort: prop_types_default().oneOf(["asc", "desc"]),
                    })
                ),

                /**
                 * The system prop that allows defining system overrides as well as additional CSS styles.
                 */
                sx: prop_types_default().oneOfType([
                    prop_types_default().arrayOf(
                        prop_types_default().oneOfType([
                            prop_types_default().func,
                            prop_types_default().object,
                            prop_types_default().bool,
                        ])
                    ),
                    prop_types_default().func,
                    prop_types_default().object,
                ]),
            };

            /***/
        },
    },
]);
