"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [
        544
    ],
    {
        5215: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
            for(var match, match1, result, version, browserApi, videojs$1, FakeWeakMap, _supportsPassive, EVENT_MAP, canPlayType, Vhs$1, global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8908), global_window__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_0__), global_document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9144), global_document__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(global_document__WEBPACK_IMPORTED_MODULE_1__), _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7462), _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(7326), _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(4578), safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5974), safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_2__), keycode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7537), keycode__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(keycode__WEBPACK_IMPORTED_MODULE_3__), _videojs_xhr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9603), _videojs_xhr__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_videojs_xhr__WEBPACK_IMPORTED_MODULE_4__), videojs_vtt_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3407), videojs_vtt_js__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(videojs_vtt_js__WEBPACK_IMPORTED_MODULE_5__), _babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(8852), _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(136), _videojs_vhs_utils_es_resolve_url_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(779), m3u8_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9323), _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2260), _videojs_vhs_utils_es_media_types_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(8485), mpd_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(973), mux_js_lib_tools_parse_sidx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4221), mux_js_lib_tools_parse_sidx__WEBPACK_IMPORTED_MODULE_10___default = __webpack_require__.n(mux_js_lib_tools_parse_sidx__WEBPACK_IMPORTED_MODULE_10__), _videojs_vhs_utils_es_id3_helpers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(8925), _videojs_vhs_utils_es_containers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(6185), _videojs_vhs_utils_es_byte_helpers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(562), mux_js_lib_utils_clock__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1489), version$5 = "7.17.0", hooks_ = {}, hooks = function(type, fn) {
                return hooks_[type] = hooks_[type] || [], fn && (hooks_[type] = hooks_[type].concat(fn)), hooks_[type];
            }, removeHook = function(type, fn) {
                var index = hooks(type).indexOf(fn);
                return !(index <= -1) && (hooks_[type] = hooks_[type].slice(), hooks_[type].splice(index, 1), !0);
            }, FullscreenApi = {
                prefixed: !0
            }, apiMap = [
                [
                    "requestFullscreen",
                    "exitFullscreen",
                    "fullscreenElement",
                    "fullscreenEnabled",
                    "fullscreenchange",
                    "fullscreenerror",
                    "fullscreen"
                ],
                [
                    "webkitRequestFullscreen",
                    "webkitExitFullscreen",
                    "webkitFullscreenElement",
                    "webkitFullscreenEnabled",
                    "webkitfullscreenchange",
                    "webkitfullscreenerror",
                    "-webkit-full-screen"
                ],
                [
                    "mozRequestFullScreen",
                    "mozCancelFullScreen",
                    "mozFullScreenElement",
                    "mozFullScreenEnabled",
                    "mozfullscreenchange",
                    "mozfullscreenerror",
                    "-moz-full-screen"
                ],
                [
                    "msRequestFullscreen",
                    "msExitFullscreen",
                    "msFullscreenElement",
                    "msFullscreenEnabled",
                    "MSFullscreenChange",
                    "MSFullscreenError",
                    "-ms-fullscreen"
                ]
            ], specApi = apiMap[0], i = 0; i < apiMap.length; i++)if (apiMap[i][1] in global_document__WEBPACK_IMPORTED_MODULE_1___default()) {
                browserApi = apiMap[i];
                break;
            }
            if (browserApi) {
                for(var _i = 0; _i < browserApi.length; _i++)FullscreenApi[specApi[_i]] = browserApi[_i];
                FullscreenApi.prefixed = browserApi[0] !== specApi[0];
            }
            var history = [], log$1 = function createLogger$1(name) {
                var logByType, level = "info", log = function() {
                    for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    logByType("log", level, args);
                };
                return logByType = function(type, level, args) {
                    var lvl = log.levels[level], lvlRegExp = RegExp("^(" + lvl + ")$");
                    if ("log" !== type && args.unshift(type.toUpperCase() + ":"), args.unshift(name + ":"), history) {
                        history.push([].concat(args));
                        var splice = history.length - 1000;
                        history.splice(0, splice > 0 ? splice : 0);
                    }
                    if (global_window__WEBPACK_IMPORTED_MODULE_0___default().console) {
                        var fn = global_window__WEBPACK_IMPORTED_MODULE_0___default().console[type];
                        fn || "debug" !== type || (fn = global_window__WEBPACK_IMPORTED_MODULE_0___default().console.info || global_window__WEBPACK_IMPORTED_MODULE_0___default().console.log), fn && lvl && lvlRegExp.test(type) && fn[Array.isArray(args) ? "apply" : "call"](global_window__WEBPACK_IMPORTED_MODULE_0___default().console, args);
                    }
                }, log.createLogger = function(subname) {
                    return createLogger$1(name + ": " + subname);
                }, log.levels = {
                    all: "debug|log|warn|error",
                    off: "",
                    debug: "debug|log|warn|error",
                    info: "log|warn|error",
                    warn: "warn|error",
                    error: "error",
                    DEFAULT: level
                }, log.level = function(lvl) {
                    if ("string" == typeof lvl) {
                        if (!log.levels.hasOwnProperty(lvl)) throw Error('"' + lvl + '" in not a valid log level');
                        level = lvl;
                    }
                    return level;
                }, log.history = function() {
                    return history ? [].concat(history) : [];
                }, log.history.filter = function(fname) {
                    return (history || []).filter(function(historyItem) {
                        return RegExp(".*" + fname + ".*").test(historyItem[0]);
                    });
                }, log.history.clear = function() {
                    history && (history.length = 0);
                }, log.history.disable = function() {
                    null !== history && (history.length = 0, history = null);
                }, log.history.enable = function() {
                    null === history && (history = []);
                }, log.error = function() {
                    for(var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
                    return logByType("error", level, args);
                }, log.warn = function() {
                    for(var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3];
                    return logByType("warn", level, args);
                }, log.debug = function() {
                    for(var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++)args[_key4] = arguments[_key4];
                    return logByType("debug", level, args);
                }, log;
            }("VIDEOJS"), createLogger = log$1.createLogger, toString = Object.prototype.toString, keys = function(object) {
                return isObject(object) ? Object.keys(object) : [];
            };
            function each(object, fn) {
                keys(object).forEach(function(key) {
                    return fn(object[key], key);
                });
            }
            function assign(target) {
                for(var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)sources[_key - 1] = arguments[_key];
                return Object.assign ? _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__.Z.apply(void 0, [
                    target
                ].concat(sources)) : (sources.forEach(function(source) {
                    source && each(source, function(value, key) {
                        target[key] = value;
                    });
                }), target);
            }
            function isObject(value) {
                return !!value && "object" == typeof value;
            }
            function isPlain(value) {
                return isObject(value) && "[object Object]" === toString.call(value) && value.constructor === Object;
            }
            function computedStyle(el, prop) {
                if (!el || !prop) return "";
                if ("function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().getComputedStyle) {
                    var computedStyleValue;
                    try {
                        computedStyleValue = global_window__WEBPACK_IMPORTED_MODULE_0___default().getComputedStyle(el);
                    } catch (e) {
                        return "";
                    }
                    return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
                }
                return "";
            }
            var USER_AGENT = global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator && global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator.userAgent || "", webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT), appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null, IS_IPOD = /iPod/i.test(USER_AGENT), IOS_VERSION = (match = USER_AGENT.match(/OS (\d+)_/i)) && match[1] ? match[1] : null, IS_ANDROID = /Android/i.test(USER_AGENT), ANDROID_VERSION = function() {
                var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
                if (!match) return null;
                var major = match[1] && parseFloat(match[1]), minor = match[2] && parseFloat(match[2]);
                return major && minor ? parseFloat(match[1] + "." + match[2]) : major || null;
            }(), IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537, IS_FIREFOX = /Firefox/i.test(USER_AGENT), IS_EDGE = /Edg/i.test(USER_AGENT), IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT)), CHROME_VERSION = (match1 = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/)) && match1[2] ? parseFloat(match1[2]) : null, IE_VERSION = (!(version = (result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT)) && parseFloat(result[1])) && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT) && (version = 11.0), version), IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE, IS_WINDOWS = /Windows/i.test(USER_AGENT), TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in global_window__WEBPACK_IMPORTED_MODULE_0___default() || global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator.maxTouchPoints || global_window__WEBPACK_IMPORTED_MODULE_0___default().DocumentTouch && global_window__WEBPACK_IMPORTED_MODULE_0___default().document instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().DocumentTouch)), IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT), IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD, IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD, IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME, browser = Object.freeze({
                __proto__: null,
                IS_IPOD: IS_IPOD,
                IOS_VERSION: IOS_VERSION,
                IS_ANDROID: IS_ANDROID,
                ANDROID_VERSION: ANDROID_VERSION,
                IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
                IS_FIREFOX: IS_FIREFOX,
                IS_EDGE: IS_EDGE,
                IS_CHROME: IS_CHROME,
                CHROME_VERSION: CHROME_VERSION,
                IE_VERSION: IE_VERSION,
                IS_SAFARI: IS_SAFARI,
                IS_WINDOWS: IS_WINDOWS,
                TOUCH_ENABLED: TOUCH_ENABLED,
                IS_IPAD: IS_IPAD,
                IS_IPHONE: IS_IPHONE,
                IS_IOS: IS_IOS,
                IS_ANY_SAFARI: IS_ANY_SAFARI
            });
            function isNonBlankString(str) {
                return "string" == typeof str && Boolean(str.trim());
            }
            function throwIfWhitespace(str) {
                if (str.indexOf(" ") >= 0) throw Error("class has illegal whitespace characters");
            }
            function isReal() {
                return global_document__WEBPACK_IMPORTED_MODULE_1___default() === global_window__WEBPACK_IMPORTED_MODULE_0___default().document;
            }
            function isEl(value) {
                return isObject(value) && 1 === value.nodeType;
            }
            function isInFrame() {
                try {
                    return global_window__WEBPACK_IMPORTED_MODULE_0___default().parent !== global_window__WEBPACK_IMPORTED_MODULE_0___default().self;
                } catch (x) {
                    return !0;
                }
            }
            function createQuerier(method) {
                return function(selector, context) {
                    if (!isNonBlankString(selector)) return global_document__WEBPACK_IMPORTED_MODULE_1___default()[method](null);
                    isNonBlankString(context) && (context = global_document__WEBPACK_IMPORTED_MODULE_1___default().querySelector(context));
                    var ctx = isEl(context) ? context : global_document__WEBPACK_IMPORTED_MODULE_1___default();
                    return ctx[method] && ctx[method](selector);
                };
            }
            function createEl(tagName, properties, attributes, content) {
                void 0 === tagName && (tagName = "div"), void 0 === properties && (properties = {}), void 0 === attributes && (attributes = {});
                var el = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement(tagName);
                return Object.getOwnPropertyNames(properties).forEach(function(propName) {
                    var val = properties[propName];
                    -1 !== propName.indexOf("aria-") || "role" === propName || "type" === propName ? (log$1.warn("Setting attributes in the second argument of createEl()\nhas been deprecated. Use the third argument instead.\ncreateEl(type, properties, attributes). Attempting to set " + propName + " to " + val + "."), el.setAttribute(propName, val)) : "textContent" === propName ? textContent(el, val) : (el[propName] !== val || "tabIndex" === propName) && (el[propName] = val);
                }), Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
                    el.setAttribute(attrName, attributes[attrName]);
                }), content && appendContent(el, content), el;
            }
            function textContent(el, text) {
                return void 0 === el.textContent ? el.innerText = text : el.textContent = text, el;
            }
            function prependTo(child, parent) {
                parent.firstChild ? parent.insertBefore(child, parent.firstChild) : parent.appendChild(child);
            }
            function hasClass(element, classToCheck) {
                return (throwIfWhitespace(classToCheck), element.classList) ? element.classList.contains(classToCheck) : RegExp("(^|\\s)" + classToCheck + "($|\\s)").test(element.className);
            }
            function addClass(element, classToAdd) {
                return element.classList ? element.classList.add(classToAdd) : hasClass(element, classToAdd) || (element.className = (element.className + " " + classToAdd).trim()), element;
            }
            function removeClass(element, classToRemove) {
                return element ? (element.classList ? element.classList.remove(classToRemove) : (throwIfWhitespace(classToRemove), element.className = element.className.split(/\s+/).filter(function(c) {
                    return c !== classToRemove;
                }).join(" ")), element) : (log$1.warn("removeClass was called with an element that doesn't exist"), null);
            }
            function toggleClass(element, classToToggle, predicate) {
                var has = hasClass(element, classToToggle);
                if ("function" == typeof predicate && (predicate = predicate(element, classToToggle)), "boolean" != typeof predicate && (predicate = !has), predicate !== has) return predicate ? addClass(element, classToToggle) : removeClass(element, classToToggle), element;
            }
            function setAttributes(el, attributes) {
                Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
                    var attrValue = attributes[attrName];
                    null == attrValue || !1 === attrValue ? el.removeAttribute(attrName) : el.setAttribute(attrName, !0 === attrValue ? "" : attrValue);
                });
            }
            function getAttributes(tag) {
                var obj = {};
                if (tag && tag.attributes && tag.attributes.length > 0) for(var attrs = tag.attributes, i = attrs.length - 1; i >= 0; i--){
                    var attrName = attrs[i].name, attrVal = attrs[i].value;
                    ("boolean" == typeof tag[attrName] || -1 !== ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,".indexOf("," + attrName + ",")) && (attrVal = null !== attrVal), obj[attrName] = attrVal;
                }
                return obj;
            }
            function getAttribute(el, attribute) {
                return el.getAttribute(attribute);
            }
            function setAttribute(el, attribute, value) {
                el.setAttribute(attribute, value);
            }
            function removeAttribute(el, attribute) {
                el.removeAttribute(attribute);
            }
            function blockTextSelection() {
                global_document__WEBPACK_IMPORTED_MODULE_1___default().body.focus(), global_document__WEBPACK_IMPORTED_MODULE_1___default().onselectstart = function() {
                    return !1;
                };
            }
            function unblockTextSelection() {
                global_document__WEBPACK_IMPORTED_MODULE_1___default().onselectstart = function() {
                    return !0;
                };
            }
            function getBoundingClientRect(el) {
                if (el && el.getBoundingClientRect && el.parentNode) {
                    var rect = el.getBoundingClientRect(), result = {};
                    return [
                        "bottom",
                        "height",
                        "left",
                        "right",
                        "top",
                        "width"
                    ].forEach(function(k) {
                        void 0 !== rect[k] && (result[k] = rect[k]);
                    }), result.height || (result.height = parseFloat(computedStyle(el, "height"))), result.width || (result.width = parseFloat(computedStyle(el, "width"))), result;
                }
            }
            function findPosition(el) {
                if (!el || el && !el.offsetParent) return {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                };
                for(var width = el.offsetWidth, height = el.offsetHeight, left = 0, top = 0; el.offsetParent && el !== global_document__WEBPACK_IMPORTED_MODULE_1___default()[FullscreenApi.fullscreenElement];)left += el.offsetLeft, top += el.offsetTop, el = el.offsetParent;
                return {
                    left: left,
                    top: top,
                    width: width,
                    height: height
                };
            }
            function getPointerPosition(el, event) {
                var translated = {
                    x: 0,
                    y: 0
                };
                if (IS_IOS) for(var item = el; item && "html" !== item.nodeName.toLowerCase();){
                    var transform = computedStyle(item, "transform");
                    if (/^matrix/.test(transform)) {
                        var values = transform.slice(7, -1).split(/,\s/).map(Number);
                        translated.x += values[4], translated.y += values[5];
                    } else if (/^matrix3d/.test(transform)) {
                        var _values = transform.slice(9, -1).split(/,\s/).map(Number);
                        translated.x += _values[12], translated.y += _values[13];
                    }
                    item = item.parentNode;
                }
                var position = {}, boxTarget = findPosition(event.target), box = findPosition(el), boxW = box.width, boxH = box.height, offsetY = event.offsetY - (box.top - boxTarget.top), offsetX = event.offsetX - (box.left - boxTarget.left);
                return event.changedTouches && (offsetX = event.changedTouches[0].pageX - box.left, offsetY = event.changedTouches[0].pageY + box.top, IS_IOS && (offsetX -= translated.x, offsetY -= translated.y)), position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH)), position.x = Math.max(0, Math.min(1, offsetX / boxW)), position;
            }
            function isTextNode(value) {
                return isObject(value) && 3 === value.nodeType;
            }
            function emptyEl(el) {
                for(; el.firstChild;)el.removeChild(el.firstChild);
                return el;
            }
            function normalizeContent(content) {
                return "function" == typeof content && (content = content()), (Array.isArray(content) ? content : [
                    content
                ]).map(function(value) {
                    return ("function" == typeof value && (value = value()), isEl(value) || isTextNode(value)) ? value : "string" == typeof value && /\S/.test(value) ? global_document__WEBPACK_IMPORTED_MODULE_1___default().createTextNode(value) : void 0;
                }).filter(function(value) {
                    return value;
                });
            }
            function appendContent(el, content) {
                return normalizeContent(content).forEach(function(node) {
                    return el.appendChild(node);
                }), el;
            }
            function insertContent(el, content) {
                return appendContent(emptyEl(el), content);
            }
            function isSingleLeftClick(event) {
                return void 0 === event.button && void 0 === event.buttons || 0 === event.button && void 0 === event.buttons || "mouseup" === event.type && 0 === event.button && 0 === event.buttons || 0 === event.button && 1 === event.buttons;
            }
            var $ = createQuerier("querySelector"), $$ = createQuerier("querySelectorAll"), Dom = Object.freeze({
                __proto__: null,
                isReal: isReal,
                isEl: isEl,
                isInFrame: isInFrame,
                createEl: createEl,
                textContent: textContent,
                prependTo: prependTo,
                hasClass: hasClass,
                addClass: addClass,
                removeClass: removeClass,
                toggleClass: toggleClass,
                setAttributes: setAttributes,
                getAttributes: getAttributes,
                getAttribute: getAttribute,
                setAttribute: setAttribute,
                removeAttribute: removeAttribute,
                blockTextSelection: blockTextSelection,
                unblockTextSelection: unblockTextSelection,
                getBoundingClientRect: getBoundingClientRect,
                findPosition: findPosition,
                getPointerPosition: getPointerPosition,
                isTextNode: isTextNode,
                emptyEl: emptyEl,
                normalizeContent: normalizeContent,
                appendContent: appendContent,
                insertContent: insertContent,
                isSingleLeftClick: isSingleLeftClick,
                $: $,
                $$: $$
            }), _windowLoaded = !1, autoSetup = function() {
                if (!1 !== videojs$1.options.autoSetup) {
                    var vids = Array.prototype.slice.call(global_document__WEBPACK_IMPORTED_MODULE_1___default().getElementsByTagName("video")), audios = Array.prototype.slice.call(global_document__WEBPACK_IMPORTED_MODULE_1___default().getElementsByTagName("audio")), divs = Array.prototype.slice.call(global_document__WEBPACK_IMPORTED_MODULE_1___default().getElementsByTagName("video-js")), mediaEls = vids.concat(audios, divs);
                    if (mediaEls && mediaEls.length > 0) for(var i = 0, e = mediaEls.length; i < e; i++){
                        var mediaEl = mediaEls[i];
                        if (mediaEl && mediaEl.getAttribute) void 0 === mediaEl.player && null !== mediaEl.getAttribute("data-setup") && videojs$1(mediaEl);
                        else {
                            autoSetupTimeout(1);
                            break;
                        }
                    }
                    else _windowLoaded || autoSetupTimeout(1);
                }
            };
            function autoSetupTimeout(wait, vjs) {
                isReal() && (vjs && (videojs$1 = vjs), global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(autoSetup, wait));
            }
            function setWindowLoaded() {
                _windowLoaded = !0, global_window__WEBPACK_IMPORTED_MODULE_0___default().removeEventListener("load", setWindowLoaded);
            }
            isReal() && ("complete" === global_document__WEBPACK_IMPORTED_MODULE_1___default().readyState ? setWindowLoaded() : global_window__WEBPACK_IMPORTED_MODULE_0___default().addEventListener("load", setWindowLoaded));
            var createStyleElement = function(className) {
                var style = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("style");
                return style.className = className, style;
            }, setTextContent = function(el, content) {
                el.styleSheet ? el.styleSheet.cssText = content : el.textContent = content;
            }, _guid = 3;
            global_window__WEBPACK_IMPORTED_MODULE_0___default().WeakMap || (FakeWeakMap = function() {
                function FakeWeakMap() {
                    this.vdata = "vdata" + Math.floor(global_window__WEBPACK_IMPORTED_MODULE_0___default().performance && global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now() || Date.now()), this.data = {};
                }
                var _proto = FakeWeakMap.prototype;
                return _proto.set = function(key, value) {
                    var access = key[this.vdata] || _guid++;
                    return key[this.vdata] || (key[this.vdata] = access), this.data[access] = value, this;
                }, _proto.get = function(key) {
                    var access = key[this.vdata];
                    if (access) return this.data[access];
                    log$1("We have no data for this element", key);
                }, _proto.has = function(key) {
                    return key[this.vdata] in this.data;
                }, _proto.delete = function(key) {
                    var access = key[this.vdata];
                    access && (delete this.data[access], delete key[this.vdata]);
                }, FakeWeakMap;
            }());
            var DomData = global_window__WEBPACK_IMPORTED_MODULE_0___default().WeakMap ? new WeakMap() : new FakeWeakMap();
            function _cleanUpEvents(elem, type) {
                if (DomData.has(elem)) {
                    var data = DomData.get(elem);
                    0 === data.handlers[type].length && (delete data.handlers[type], elem.removeEventListener ? elem.removeEventListener(type, data.dispatcher, !1) : elem.detachEvent && elem.detachEvent("on" + type, data.dispatcher)), Object.getOwnPropertyNames(data.handlers).length <= 0 && (delete data.handlers, delete data.dispatcher, delete data.disabled), 0 === Object.getOwnPropertyNames(data).length && DomData.delete(elem);
                }
            }
            function _handleMultipleEvents(fn, elem, types, callback) {
                types.forEach(function(type) {
                    fn(elem, type, callback);
                });
            }
            function fixEvent(event) {
                if (event.fixed_) return event;
                function returnTrue() {
                    return !0;
                }
                function returnFalse() {
                    return !1;
                }
                if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
                    var old = event || global_window__WEBPACK_IMPORTED_MODULE_0___default().event;
                    for(var key in event = {}, old)"layerX" === key || "layerY" === key || "keyLocation" === key || "webkitMovementX" === key || "webkitMovementY" === key || "returnValue" === key && old.preventDefault || (event[key] = old[key]);
                    if (event.target || (event.target = event.srcElement || global_document__WEBPACK_IMPORTED_MODULE_1___default()), event.relatedTarget || (event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement), event.preventDefault = function() {
                        old.preventDefault && old.preventDefault(), event.returnValue = !1, old.returnValue = !1, event.defaultPrevented = !0;
                    }, event.defaultPrevented = !1, event.stopPropagation = function() {
                        old.stopPropagation && old.stopPropagation(), event.cancelBubble = !0, old.cancelBubble = !0, event.isPropagationStopped = returnTrue;
                    }, event.isPropagationStopped = returnFalse, event.stopImmediatePropagation = function() {
                        old.stopImmediatePropagation && old.stopImmediatePropagation(), event.isImmediatePropagationStopped = returnTrue, event.stopPropagation();
                    }, event.isImmediatePropagationStopped = returnFalse, null !== event.clientX && void 0 !== event.clientX) {
                        var doc = global_document__WEBPACK_IMPORTED_MODULE_1___default().documentElement, body = global_document__WEBPACK_IMPORTED_MODULE_1___default().body;
                        event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                    }
                    event.which = event.charCode || event.keyCode, null !== event.button && void 0 !== event.button && (event.button = 1 & event.button ? 0 : 4 & event.button ? 1 : 2 & event.button ? 2 : 0);
                }
                return event.fixed_ = !0, event;
            }
            var supportsPassive = function() {
                if ("boolean" != typeof _supportsPassive) {
                    _supportsPassive = !1;
                    try {
                        var opts = Object.defineProperty({}, "passive", {
                            get: function() {
                                _supportsPassive = !0;
                            }
                        });
                        global_window__WEBPACK_IMPORTED_MODULE_0___default().addEventListener("test", null, opts), global_window__WEBPACK_IMPORTED_MODULE_0___default().removeEventListener("test", null, opts);
                    } catch (e) {}
                }
                return _supportsPassive;
            }, passiveEvents = [
                "touchstart",
                "touchmove"
            ];
            function on(elem, type, fn) {
                if (Array.isArray(type)) return _handleMultipleEvents(on, elem, type, fn);
                DomData.has(elem) || DomData.set(elem, {});
                var data = DomData.get(elem);
                if (data.handlers || (data.handlers = {}), data.handlers[type] || (data.handlers[type] = []), fn.guid || (fn.guid = _guid++), data.handlers[type].push(fn), data.dispatcher || (data.disabled = !1, data.dispatcher = function(event, hash) {
                    if (!data.disabled) {
                        event = fixEvent(event);
                        var handlers = data.handlers[event.type];
                        if (handlers) for(var handlersCopy = handlers.slice(0), m = 0, n = handlersCopy.length; m < n && !event.isImmediatePropagationStopped(); m++)try {
                            handlersCopy[m].call(elem, event, hash);
                        } catch (e) {
                            log$1.error(e);
                        }
                    }
                }), 1 === data.handlers[type].length) {
                    if (elem.addEventListener) {
                        var options = !1;
                        supportsPassive() && passiveEvents.indexOf(type) > -1 && (options = {
                            passive: !0
                        }), elem.addEventListener(type, data.dispatcher, options);
                    } else elem.attachEvent && elem.attachEvent("on" + type, data.dispatcher);
                }
            }
            function off(elem, type, fn) {
                if (DomData.has(elem)) {
                    var data = DomData.get(elem);
                    if (data.handlers) {
                        if (Array.isArray(type)) return _handleMultipleEvents(off, elem, type, fn);
                        var removeType = function(el, t) {
                            data.handlers[t] = [], _cleanUpEvents(el, t);
                        };
                        if (void 0 === type) {
                            for(var t in data.handlers)Object.prototype.hasOwnProperty.call(data.handlers || {}, t) && removeType(elem, t);
                            return;
                        }
                        var handlers = data.handlers[type];
                        if (handlers) {
                            if (!fn) {
                                removeType(elem, type);
                                return;
                            }
                            if (fn.guid) for(var n = 0; n < handlers.length; n++)handlers[n].guid === fn.guid && handlers.splice(n--, 1);
                            _cleanUpEvents(elem, type);
                        }
                    }
                }
            }
            function trigger(elem, event, hash) {
                var elemData = DomData.has(elem) ? DomData.get(elem) : {}, parent = elem.parentNode || elem.ownerDocument;
                if ("string" == typeof event ? event = {
                    type: event,
                    target: elem
                } : event.target || (event.target = elem), event = fixEvent(event), elemData.dispatcher && elemData.dispatcher.call(elem, event, hash), parent && !event.isPropagationStopped() && !0 === event.bubbles) trigger.call(null, parent, event, hash);
                else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
                    DomData.has(event.target) || DomData.set(event.target, {});
                    var targetData = DomData.get(event.target);
                    event.target[event.type] && (targetData.disabled = !0, "function" == typeof event.target[event.type] && event.target[event.type](), targetData.disabled = !1);
                }
                return !event.defaultPrevented;
            }
            function one(elem, type, fn) {
                if (Array.isArray(type)) return _handleMultipleEvents(one, elem, type, fn);
                var func = function func() {
                    off(elem, type, func), fn.apply(this, arguments);
                };
                func.guid = fn.guid = fn.guid || _guid++, on(elem, type, func);
            }
            function any(elem, type, fn) {
                var func = function func() {
                    off(elem, type, func), fn.apply(this, arguments);
                };
                func.guid = fn.guid = fn.guid || _guid++, on(elem, type, func);
            }
            var Events = Object.freeze({
                __proto__: null,
                fixEvent: fixEvent,
                on: on,
                off: off,
                trigger: trigger,
                one: one,
                any: any
            }), bind = function(context, fn, uid) {
                fn.guid || (fn.guid = _guid++);
                var bound = fn.bind(context);
                return bound.guid = uid ? uid + "_" + fn.guid : fn.guid, bound;
            }, throttle = function(fn, wait) {
                var last = global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now();
                return function() {
                    var now = global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now();
                    now - last >= wait && (fn.apply(void 0, arguments), last = now);
                };
            }, debounce = function(func, wait, immediate, context) {
                void 0 === context && (context = global_window__WEBPACK_IMPORTED_MODULE_0___default());
                var timeout, debounced = function() {
                    var self1 = this, args = arguments, _later = function() {
                        timeout = null, _later = null, immediate || func.apply(self1, args);
                    };
                    !timeout && immediate && func.apply(self1, args), context.clearTimeout(timeout), timeout = context.setTimeout(_later, wait);
                };
                return debounced.cancel = function() {
                    context.clearTimeout(timeout), timeout = null;
                }, debounced;
            }, EventTarget$2 = function() {};
            EventTarget$2.prototype.allowedEvents_ = {}, EventTarget$2.prototype.on = function(type, fn) {
                var ael = this.addEventListener;
                this.addEventListener = function() {}, on(this, type, fn), this.addEventListener = ael;
            }, EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on, EventTarget$2.prototype.off = function(type, fn) {
                off(this, type, fn);
            }, EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off, EventTarget$2.prototype.one = function(type, fn) {
                var ael = this.addEventListener;
                this.addEventListener = function() {}, one(this, type, fn), this.addEventListener = ael;
            }, EventTarget$2.prototype.any = function(type, fn) {
                var ael = this.addEventListener;
                this.addEventListener = function() {}, any(this, type, fn), this.addEventListener = ael;
            }, EventTarget$2.prototype.trigger = function(event) {
                var type = event.type || event;
                "string" == typeof event && (event = {
                    type: type
                }), event = fixEvent(event), this.allowedEvents_[type] && this["on" + type] && this["on" + type](event), trigger(this, event);
            }, EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger, EventTarget$2.prototype.queueTrigger = function(event) {
                var _this = this;
                EVENT_MAP || (EVENT_MAP = new Map());
                var type = event.type || event, map = EVENT_MAP.get(this);
                map || (map = new Map(), EVENT_MAP.set(this, map));
                var oldTimeout = map.get(type);
                map.delete(type), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(oldTimeout);
                var timeout = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                    0 === map.size && (map = null, EVENT_MAP.delete(_this)), _this.trigger(event);
                }, 0);
                map.set(type, timeout);
            };
            var objName = function(obj) {
                return "function" == typeof obj.name ? obj.name() : "string" == typeof obj.name ? obj.name : obj.name_ ? obj.name_ : obj.constructor && obj.constructor.name ? obj.constructor.name : typeof obj;
            }, isEvented = function(object) {
                return object instanceof EventTarget$2 || !!object.eventBusEl_ && [
                    "on",
                    "one",
                    "off",
                    "trigger"
                ].every(function(k) {
                    return "function" == typeof object[k];
                });
            }, addEventedCallback = function(target, callback) {
                isEvented(target) ? callback() : (target.eventedCallbacks || (target.eventedCallbacks = []), target.eventedCallbacks.push(callback));
            }, isValidEventType = function(type) {
                return "string" == typeof type && /\S/.test(type) || Array.isArray(type) && !!type.length;
            }, validateTarget = function(target, obj, fnName) {
                if (!target || !target.nodeName && !isEvented(target)) throw Error("Invalid target for " + objName(obj) + "#" + fnName + "; must be a DOM node or evented object.");
            }, validateEventType = function(type, obj, fnName) {
                if (!isValidEventType(type)) throw Error("Invalid event type for " + objName(obj) + "#" + fnName + "; must be a non-empty string or array.");
            }, validateListener = function(listener, obj, fnName) {
                if ("function" != typeof listener) throw Error("Invalid listener for " + objName(obj) + "#" + fnName + "; must be a function.");
            }, normalizeListenArgs = function(self1, args, fnName) {
                var target, type, listener, isTargetingSelf = args.length < 3 || args[0] === self1 || args[0] === self1.eventBusEl_;
                return isTargetingSelf ? (target = self1.eventBusEl_, args.length >= 3 && args.shift(), type = args[0], listener = args[1]) : (target = args[0], type = args[1], listener = args[2]), validateTarget(target, self1, fnName), validateEventType(type, self1, fnName), validateListener(listener, self1, fnName), {
                    isTargetingSelf: isTargetingSelf,
                    target: target,
                    type: type,
                    listener: listener = bind(self1, listener)
                };
            }, listen = function(target, method, type, listener) {
                validateTarget(target, target, method), target.nodeName ? Events[method](target, type, listener) : target[method](type, listener);
            }, EventedMixin = {
                on: function() {
                    for(var _this = this, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    var _normalizeListenArgs = normalizeListenArgs(this, args, "on"), isTargetingSelf = _normalizeListenArgs.isTargetingSelf, target = _normalizeListenArgs.target, type = _normalizeListenArgs.type, listener = _normalizeListenArgs.listener;
                    if (listen(target, "on", type, listener), !isTargetingSelf) {
                        var removeListenerOnDispose = function() {
                            return _this.off(target, type, listener);
                        };
                        removeListenerOnDispose.guid = listener.guid;
                        var removeRemoverOnTargetDispose = function() {
                            return _this.off("dispose", removeListenerOnDispose);
                        };
                        removeRemoverOnTargetDispose.guid = listener.guid, listen(this, "on", "dispose", removeListenerOnDispose), listen(target, "on", "dispose", removeRemoverOnTargetDispose);
                    }
                },
                one: function() {
                    for(var _this2 = this, _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
                    var _normalizeListenArgs2 = normalizeListenArgs(this, args, "one"), isTargetingSelf = _normalizeListenArgs2.isTargetingSelf, target = _normalizeListenArgs2.target, type = _normalizeListenArgs2.type, listener = _normalizeListenArgs2.listener;
                    if (isTargetingSelf) listen(target, "one", type, listener);
                    else {
                        var wrapper = function wrapper() {
                            _this2.off(target, type, wrapper);
                            for(var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++)largs[_key3] = arguments[_key3];
                            listener.apply(null, largs);
                        };
                        wrapper.guid = listener.guid, listen(target, "one", type, wrapper);
                    }
                },
                any: function() {
                    for(var _this3 = this, _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++)args[_key4] = arguments[_key4];
                    var _normalizeListenArgs3 = normalizeListenArgs(this, args, "any"), isTargetingSelf = _normalizeListenArgs3.isTargetingSelf, target = _normalizeListenArgs3.target, type = _normalizeListenArgs3.type, listener = _normalizeListenArgs3.listener;
                    if (isTargetingSelf) listen(target, "any", type, listener);
                    else {
                        var wrapper = function wrapper() {
                            _this3.off(target, type, wrapper);
                            for(var _len5 = arguments.length, largs = Array(_len5), _key5 = 0; _key5 < _len5; _key5++)largs[_key5] = arguments[_key5];
                            listener.apply(null, largs);
                        };
                        wrapper.guid = listener.guid, listen(target, "any", type, wrapper);
                    }
                },
                off: function(targetOrType, typeOrListener, listener) {
                    !targetOrType || isValidEventType(targetOrType) ? off(this.eventBusEl_, targetOrType, typeOrListener) : (validateTarget(targetOrType, this, "off"), validateEventType(typeOrListener, this, "off"), validateListener(listener, this, "off"), listener = bind(this, listener), this.off("dispose", listener), targetOrType.nodeName ? (off(targetOrType, typeOrListener, listener), off(targetOrType, "dispose", listener)) : isEvented(targetOrType) && (targetOrType.off(typeOrListener, listener), targetOrType.off("dispose", listener)));
                },
                trigger: function(event, hash) {
                    if (validateTarget(this.eventBusEl_, this, "trigger"), !isValidEventType(event && "string" != typeof event ? event.type : event)) {
                        var error = "Invalid event type for " + objName(this) + "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
                        if (event) (this.log || log$1).error(error);
                        else throw Error(error);
                    }
                    return trigger(this.eventBusEl_, event, hash);
                }
            };
            function evented(target, options) {
                void 0 === options && (options = {});
                var eventBusKey = options.eventBusKey;
                if (eventBusKey) {
                    if (!target[eventBusKey].nodeName) throw Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
                    target.eventBusEl_ = target[eventBusKey];
                } else target.eventBusEl_ = createEl("span", {
                    className: "vjs-event-bus"
                });
                return assign(target, EventedMixin), target.eventedCallbacks && target.eventedCallbacks.forEach(function(callback) {
                    callback();
                }), target.on("dispose", function() {
                    target.off(), [
                        target,
                        target.el_,
                        target.eventBusEl_
                    ].forEach(function(val) {
                        val && DomData.has(val) && DomData.delete(val);
                    }), global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                        target.eventBusEl_ = null;
                    }, 0);
                }), target;
            }
            var StatefulMixin = {
                state: {},
                setState: function(stateUpdates) {
                    var changes, _this = this;
                    return "function" == typeof stateUpdates && (stateUpdates = stateUpdates()), each(stateUpdates, function(value, key) {
                        _this.state[key] !== value && ((changes = changes || {})[key] = {
                            from: _this.state[key],
                            to: value
                        }), _this.state[key] = value;
                    }), changes && isEvented(this) && this.trigger({
                        changes: changes,
                        type: "statechanged"
                    }), changes;
                }
            };
            function stateful(target, defaultState) {
                return assign(target, StatefulMixin), target.state = assign({}, target.state, defaultState), "function" == typeof target.handleStateChanged && isEvented(target) && target.on("statechanged", target.handleStateChanged), target;
            }
            var toLowerCase = function(string) {
                return "string" != typeof string ? string : string.replace(/./, function(w) {
                    return w.toLowerCase();
                });
            }, toTitleCase$1 = function(string) {
                return "string" != typeof string ? string : string.replace(/./, function(w) {
                    return w.toUpperCase();
                });
            };
            function mergeOptions$3() {
                for(var result = {}, _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++)sources[_key] = arguments[_key];
                return sources.forEach(function(source) {
                    source && each(source, function(value, key) {
                        if (!isPlain(value)) {
                            result[key] = value;
                            return;
                        }
                        isPlain(result[key]) || (result[key] = {}), result[key] = mergeOptions$3(result[key], value);
                    });
                }), result;
            }
            var MapSham = function() {
                function MapSham() {
                    this.map_ = {};
                }
                var _proto = MapSham.prototype;
                return _proto.has = function(key) {
                    return key in this.map_;
                }, _proto.delete = function(key) {
                    var has = this.has(key);
                    return delete this.map_[key], has;
                }, _proto.set = function(key, value) {
                    return this.map_[key] = value, this;
                }, _proto.forEach = function(callback, thisArg) {
                    for(var key in this.map_)callback.call(thisArg, this.map_[key], key, this);
                }, MapSham;
            }(), Map$1 = global_window__WEBPACK_IMPORTED_MODULE_0___default().Map ? global_window__WEBPACK_IMPORTED_MODULE_0___default().Map : MapSham, SetSham = function() {
                function SetSham() {
                    this.set_ = {};
                }
                var _proto = SetSham.prototype;
                return _proto.has = function(key) {
                    return key in this.set_;
                }, _proto.delete = function(key) {
                    var has = this.has(key);
                    return delete this.set_[key], has;
                }, _proto.add = function(key) {
                    return this.set_[key] = 1, this;
                }, _proto.forEach = function(callback, thisArg) {
                    for(var key in this.set_)callback.call(thisArg, key, key, this);
                }, SetSham;
            }(), Set = global_window__WEBPACK_IMPORTED_MODULE_0___default().Set ? global_window__WEBPACK_IMPORTED_MODULE_0___default().Set : SetSham, Component$1 = function() {
                function Component(player, options, ready) {
                    if (!player && this.play ? this.player_ = player = this : this.player_ = player, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = mergeOptions$3({}, this.options_), options = this.options_ = mergeOptions$3(this.options_, options), this.id_ = options.id || options.el && options.el.id, !this.id_) {
                        var id = player && player.id && player.id() || "no_player";
                        this.id_ = id + "_component_" + _guid++;
                    }
                    this.name_ = options.name || null, options.el ? this.el_ = options.el : !1 !== options.createEl && (this.el_ = this.createEl()), !1 !== options.evented && (evented(this, {
                        eventBusKey: this.el_ ? "el_" : null
                    }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), stateful(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = new Set(), this.setIntervalIds_ = new Set(), this.rafIds_ = new Set(), this.namedRafs_ = new Map$1(), this.clearingTimersOnDispose_ = !1, !1 !== options.initChildren && this.initChildren(), this.ready(ready), !1 !== options.reportTouchActivity && this.enableTouchActivity();
                }
                var _proto = Component.prototype;
                return _proto.dispose = function() {
                    if (!this.isDisposed_) {
                        if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({
                            type: "dispose",
                            bubbles: !1
                        }), this.isDisposed_ = !0, this.children_) for(var i = this.children_.length - 1; i >= 0; i--)this.children_[i].dispose && this.children_[i].dispose();
                        this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && this.el_.parentNode.removeChild(this.el_), this.el_ = null), this.player_ = null;
                    }
                }, _proto.isDisposed = function() {
                    return Boolean(this.isDisposed_);
                }, _proto.player = function() {
                    return this.player_;
                }, _proto.options = function(obj) {
                    return obj && (this.options_ = mergeOptions$3(this.options_, obj)), this.options_;
                }, _proto.el = function() {
                    return this.el_;
                }, _proto.createEl = function(tagName, properties, attributes) {
                    return createEl(tagName, properties, attributes);
                }, _proto.localize = function(string, tokens, defaultValue) {
                    void 0 === defaultValue && (defaultValue = string);
                    var code = this.player_.language && this.player_.language(), languages = this.player_.languages && this.player_.languages(), language = languages && languages[code], primaryCode = code && code.split("-")[0], primaryLang = languages && languages[primaryCode], localizedString = defaultValue;
                    return language && language[string] ? localizedString = language[string] : primaryLang && primaryLang[string] && (localizedString = primaryLang[string]), tokens && (localizedString = localizedString.replace(/\{(\d+)\}/g, function(match, index) {
                        var value = tokens[index - 1], ret = value;
                        return void 0 === value && (ret = match), ret;
                    })), localizedString;
                }, _proto.handleLanguagechange = function() {}, _proto.contentEl = function() {
                    return this.contentEl_ || this.el_;
                }, _proto.id = function() {
                    return this.id_;
                }, _proto.name = function() {
                    return this.name_;
                }, _proto.children = function() {
                    return this.children_;
                }, _proto.getChildById = function(id) {
                    return this.childIndex_[id];
                }, _proto.getChild = function(name) {
                    if (name) return this.childNameIndex_[name];
                }, _proto.getDescendant = function() {
                    for(var _len = arguments.length, names = Array(_len), _key = 0; _key < _len; _key++)names[_key] = arguments[_key];
                    names = names.reduce(function(acc, n) {
                        return acc.concat(n);
                    }, []);
                    for(var currentChild = this, i = 0; i < names.length; i++)if (!(currentChild = currentChild.getChild(names[i])) || !currentChild.getChild) return;
                    return currentChild;
                }, _proto.addChild = function(child, options, index) {
                    if (void 0 === options && (options = {}), void 0 === index && (index = this.children_.length), "string" == typeof child) {
                        componentName = toTitleCase$1(child);
                        var component, componentName, componentClassName = options.componentClass || componentName;
                        options.name = componentName;
                        var ComponentClass = Component.getComponent(componentClassName);
                        if (!ComponentClass) throw Error("Component " + componentClassName + " does not exist");
                        if ("function" != typeof ComponentClass) return null;
                        component = new ComponentClass(this.player_ || this, options);
                    } else component = child;
                    if (component.parentComponent_ && component.parentComponent_.removeChild(component), this.children_.splice(index, 0, component), component.parentComponent_ = this, "function" == typeof component.id && (this.childIndex_[component.id()] = component), (componentName = componentName || component.name && toTitleCase$1(component.name())) && (this.childNameIndex_[componentName] = component, this.childNameIndex_[toLowerCase(componentName)] = component), "function" == typeof component.el && component.el()) {
                        var refNode = null;
                        this.children_[index + 1] && (this.children_[index + 1].el_ ? refNode = this.children_[index + 1].el_ : isEl(this.children_[index + 1]) && (refNode = this.children_[index + 1])), this.contentEl().insertBefore(component.el(), refNode);
                    }
                    return component;
                }, _proto.removeChild = function(component) {
                    if ("string" == typeof component && (component = this.getChild(component)), component && this.children_) {
                        for(var childFound = !1, i = this.children_.length - 1; i >= 0; i--)if (this.children_[i] === component) {
                            childFound = !0, this.children_.splice(i, 1);
                            break;
                        }
                        if (childFound) {
                            component.parentComponent_ = null, this.childIndex_[component.id()] = null, this.childNameIndex_[toTitleCase$1(component.name())] = null, this.childNameIndex_[toLowerCase(component.name())] = null;
                            var compEl = component.el();
                            compEl && compEl.parentNode === this.contentEl() && this.contentEl().removeChild(component.el());
                        }
                    }
                }, _proto.initChildren = function() {
                    var _this = this, children = this.options_.children;
                    if (children) {
                        var workingChildren, parentOptions = this.options_, Tech = Component.getComponent("Tech");
                        (workingChildren = Array.isArray(children) ? children : Object.keys(children)).concat(Object.keys(this.options_).filter(function(child) {
                            return !workingChildren.some(function(wchild) {
                                return "string" == typeof wchild ? child === wchild : child === wchild.name;
                            });
                        })).map(function(child) {
                            var name, opts;
                            return "string" == typeof child ? opts = children[name = child] || _this.options_[name] || {} : (name = child.name, opts = child), {
                                name: name,
                                opts: opts
                            };
                        }).filter(function(child) {
                            var c = Component.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
                            return c && !Tech.isTech(c);
                        }).forEach(function(child) {
                            var name = child.name, opts = child.opts;
                            if (void 0 !== parentOptions[name] && (opts = parentOptions[name]), !1 !== opts) {
                                !0 === opts && (opts = {}), opts.playerOptions = _this.options_.playerOptions;
                                var newChild = _this.addChild(name, opts);
                                newChild && (_this[name] = newChild);
                            }
                        });
                    }
                }, _proto.buildCSSClass = function() {
                    return "";
                }, _proto.ready = function(fn, sync) {
                    if (void 0 === sync && (sync = !1), fn) {
                        if (!this.isReady_) {
                            this.readyQueue_ = this.readyQueue_ || [], this.readyQueue_.push(fn);
                            return;
                        }
                        sync ? fn.call(this) : this.setTimeout(fn, 1);
                    }
                }, _proto.triggerReady = function() {
                    this.isReady_ = !0, this.setTimeout(function() {
                        var readyQueue = this.readyQueue_;
                        this.readyQueue_ = [], readyQueue && readyQueue.length > 0 && readyQueue.forEach(function(fn) {
                            fn.call(this);
                        }, this), this.trigger("ready");
                    }, 1);
                }, _proto.$ = function(selector, context) {
                    return $(selector, context || this.contentEl());
                }, _proto.$$ = function(selector, context) {
                    return $$(selector, context || this.contentEl());
                }, _proto.hasClass = function(classToCheck) {
                    return hasClass(this.el_, classToCheck);
                }, _proto.addClass = function(classToAdd) {
                    addClass(this.el_, classToAdd);
                }, _proto.removeClass = function(classToRemove) {
                    removeClass(this.el_, classToRemove);
                }, _proto.toggleClass = function(classToToggle, predicate) {
                    toggleClass(this.el_, classToToggle, predicate);
                }, _proto.show = function() {
                    this.removeClass("vjs-hidden");
                }, _proto.hide = function() {
                    this.addClass("vjs-hidden");
                }, _proto.lockShowing = function() {
                    this.addClass("vjs-lock-showing");
                }, _proto.unlockShowing = function() {
                    this.removeClass("vjs-lock-showing");
                }, _proto.getAttribute = function(attribute) {
                    return getAttribute(this.el_, attribute);
                }, _proto.setAttribute = function(attribute, value) {
                    setAttribute(this.el_, attribute, value);
                }, _proto.removeAttribute = function(attribute) {
                    removeAttribute(this.el_, attribute);
                }, _proto.width = function(num, skipListeners) {
                    return this.dimension("width", num, skipListeners);
                }, _proto.height = function(num, skipListeners) {
                    return this.dimension("height", num, skipListeners);
                }, _proto.dimensions = function(width, height) {
                    this.width(width, !0), this.height(height);
                }, _proto.dimension = function(widthOrHeight, num, skipListeners) {
                    if (void 0 !== num) {
                        (null === num || num != num) && (num = 0), -1 !== ("" + num).indexOf("%") || -1 !== ("" + num).indexOf("px") ? this.el_.style[widthOrHeight] = num : "auto" === num ? this.el_.style[widthOrHeight] = "" : this.el_.style[widthOrHeight] = num + "px", skipListeners || this.trigger("componentresize");
                        return;
                    }
                    if (!this.el_) return 0;
                    var val = this.el_.style[widthOrHeight], pxIndex = val.indexOf("px");
                    return -1 !== pxIndex ? parseInt(val.slice(0, pxIndex), 10) : parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
                }, _proto.currentDimension = function(widthOrHeight) {
                    var computedWidthOrHeight = 0;
                    if ("width" !== widthOrHeight && "height" !== widthOrHeight) throw Error("currentDimension only accepts width or height value");
                    if (0 === (computedWidthOrHeight = parseFloat(computedWidthOrHeight = computedStyle(this.el_, widthOrHeight))) || isNaN(computedWidthOrHeight)) {
                        var rule = "offset" + toTitleCase$1(widthOrHeight);
                        computedWidthOrHeight = this.el_[rule];
                    }
                    return computedWidthOrHeight;
                }, _proto.currentDimensions = function() {
                    return {
                        width: this.currentDimension("width"),
                        height: this.currentDimension("height")
                    };
                }, _proto.currentWidth = function() {
                    return this.currentDimension("width");
                }, _proto.currentHeight = function() {
                    return this.currentDimension("height");
                }, _proto.focus = function() {
                    this.el_.focus();
                }, _proto.blur = function() {
                    this.el_.blur();
                }, _proto.handleKeyDown = function(event) {
                    this.player_ && (event.stopPropagation(), this.player_.handleKeyDown(event));
                }, _proto.handleKeyPress = function(event) {
                    this.handleKeyDown(event);
                }, _proto.emitTapEvents = function() {
                    var couldBeTap, touchStart = 0, firstTouch = null;
                    this.on("touchstart", function(event) {
                        1 === event.touches.length && (firstTouch = {
                            pageX: event.touches[0].pageX,
                            pageY: event.touches[0].pageY
                        }, touchStart = global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now(), couldBeTap = !0);
                    }), this.on("touchmove", function(event) {
                        if (event.touches.length > 1) couldBeTap = !1;
                        else if (firstTouch) {
                            var xdiff = event.touches[0].pageX - firstTouch.pageX, ydiff = event.touches[0].pageY - firstTouch.pageY;
                            Math.sqrt(xdiff * xdiff + ydiff * ydiff) > 10 && (couldBeTap = !1);
                        }
                    });
                    var noTap = function() {
                        couldBeTap = !1;
                    };
                    this.on("touchleave", noTap), this.on("touchcancel", noTap), this.on("touchend", function(event) {
                        firstTouch = null, !0 === couldBeTap && global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now() - touchStart < 200 && (event.preventDefault(), this.trigger("tap"));
                    });
                }, _proto.enableTouchActivity = function() {
                    if (this.player() && this.player().reportUserActivity) {
                        var touchHolding, report = bind(this.player(), this.player().reportUserActivity);
                        this.on("touchstart", function() {
                            report(), this.clearInterval(touchHolding), touchHolding = this.setInterval(report, 250);
                        });
                        var touchEnd = function(event) {
                            report(), this.clearInterval(touchHolding);
                        };
                        this.on("touchmove", report), this.on("touchend", touchEnd), this.on("touchcancel", touchEnd);
                    }
                }, _proto.setTimeout = function(fn, timeout) {
                    var timeoutId, _this2 = this;
                    return fn = bind(this, fn), this.clearTimersOnDispose_(), timeoutId = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                        _this2.setTimeoutIds_.has(timeoutId) && _this2.setTimeoutIds_.delete(timeoutId), fn();
                    }, timeout), this.setTimeoutIds_.add(timeoutId), timeoutId;
                }, _proto.clearTimeout = function(timeoutId) {
                    return this.setTimeoutIds_.has(timeoutId) && (this.setTimeoutIds_.delete(timeoutId), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(timeoutId)), timeoutId;
                }, _proto.setInterval = function(fn, interval) {
                    fn = bind(this, fn), this.clearTimersOnDispose_();
                    var intervalId = global_window__WEBPACK_IMPORTED_MODULE_0___default().setInterval(fn, interval);
                    return this.setIntervalIds_.add(intervalId), intervalId;
                }, _proto.clearInterval = function(intervalId) {
                    return this.setIntervalIds_.has(intervalId) && (this.setIntervalIds_.delete(intervalId), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearInterval(intervalId)), intervalId;
                }, _proto.requestAnimationFrame = function(fn) {
                    var id, _this3 = this;
                    return this.supportsRaf_ ? (this.clearTimersOnDispose_(), fn = bind(this, fn), id = global_window__WEBPACK_IMPORTED_MODULE_0___default().requestAnimationFrame(function() {
                        _this3.rafIds_.has(id) && _this3.rafIds_.delete(id), fn();
                    }), this.rafIds_.add(id), id) : this.setTimeout(fn, 1000 / 60);
                }, _proto.requestNamedAnimationFrame = function(name, fn) {
                    var _this4 = this;
                    if (!this.namedRafs_.has(name)) {
                        this.clearTimersOnDispose_(), fn = bind(this, fn);
                        var id = this.requestAnimationFrame(function() {
                            fn(), _this4.namedRafs_.has(name) && _this4.namedRafs_.delete(name);
                        });
                        return this.namedRafs_.set(name, id), name;
                    }
                }, _proto.cancelNamedAnimationFrame = function(name) {
                    this.namedRafs_.has(name) && (this.cancelAnimationFrame(this.namedRafs_.get(name)), this.namedRafs_.delete(name));
                }, _proto.cancelAnimationFrame = function(id) {
                    return this.supportsRaf_ ? (this.rafIds_.has(id) && (this.rafIds_.delete(id), global_window__WEBPACK_IMPORTED_MODULE_0___default().cancelAnimationFrame(id)), id) : this.clearTimeout(id);
                }, _proto.clearTimersOnDispose_ = function() {
                    var _this5 = this;
                    this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", function() {
                        [
                            [
                                "namedRafs_",
                                "cancelNamedAnimationFrame"
                            ],
                            [
                                "rafIds_",
                                "cancelAnimationFrame"
                            ],
                            [
                                "setTimeoutIds_",
                                "clearTimeout"
                            ],
                            [
                                "setIntervalIds_",
                                "clearInterval"
                            ]
                        ].forEach(function(_ref) {
                            var idName = _ref[0], cancelName = _ref[1];
                            _this5[idName].forEach(function(val, key) {
                                return _this5[cancelName](key);
                            });
                        }), _this5.clearingTimersOnDispose_ = !1;
                    }));
                }, Component.registerComponent = function(name, ComponentToRegister) {
                    if ("string" != typeof name || !name) throw Error('Illegal component name, "' + name + '"; must be a non-empty string.');
                    var Tech = Component.getComponent("Tech"), isTech = Tech && Tech.isTech(ComponentToRegister), isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);
                    if (isTech || !isComp) throw Error('Illegal component, "' + name + '"; ' + (isTech ? "techs must be registered using Tech.registerTech()" : "must be a Component subclass") + ".");
                    name = toTitleCase$1(name), Component.components_ || (Component.components_ = {});
                    var Player = Component.getComponent("Player");
                    if ("Player" === name && Player && Player.players) {
                        var players = Player.players, playerNames = Object.keys(players);
                        if (players && playerNames.length > 0 && playerNames.map(function(pname) {
                            return players[pname];
                        }).every(Boolean)) throw Error("Can not register Player component after player has been created.");
                    }
                    return Component.components_[name] = ComponentToRegister, Component.components_[toLowerCase(name)] = ComponentToRegister, ComponentToRegister;
                }, Component.getComponent = function(name) {
                    if (name && Component.components_) return Component.components_[name];
                }, Component;
            }();
            function getRange(fnName, valueIndex, ranges, rangeIndex) {
                return !function(fnName, index, maxIndex) {
                    if ("number" != typeof index || index < 0 || index > maxIndex) throw Error("Failed to execute '" + fnName + "' on 'TimeRanges': The index provided (" + index + ") is non-numeric or out of bounds (0-" + maxIndex + ").");
                }(fnName, rangeIndex, ranges.length - 1), ranges[rangeIndex][valueIndex];
            }
            function createTimeRangesObj(ranges) {
                var timeRangesObj;
                return timeRangesObj = void 0 === ranges || 0 === ranges.length ? {
                    length: 0,
                    start: function() {
                        throw Error("This TimeRanges object is empty");
                    },
                    end: function() {
                        throw Error("This TimeRanges object is empty");
                    }
                } : {
                    length: ranges.length,
                    start: getRange.bind(null, "start", 0, ranges),
                    end: getRange.bind(null, "end", 1, ranges)
                }, global_window__WEBPACK_IMPORTED_MODULE_0___default().Symbol && global_window__WEBPACK_IMPORTED_MODULE_0___default().Symbol.iterator && (timeRangesObj[global_window__WEBPACK_IMPORTED_MODULE_0___default().Symbol.iterator] = function() {
                    return (ranges || []).values();
                }), timeRangesObj;
            }
            function createTimeRanges(start, end) {
                return Array.isArray(start) ? createTimeRangesObj(start) : void 0 === start || void 0 === end ? createTimeRangesObj() : createTimeRangesObj([
                    [
                        start,
                        end
                    ]
                ]);
            }
            function bufferedPercent(buffered, duration) {
                var start, end, bufferedDuration = 0;
                if (!duration) return 0;
                buffered && buffered.length || (buffered = createTimeRanges(0, 0));
                for(var i = 0; i < buffered.length; i++)start = buffered.start(i), (end = buffered.end(i)) > duration && (end = duration), bufferedDuration += end - start;
                return bufferedDuration / duration;
            }
            function MediaError(value) {
                if (value instanceof MediaError) return value;
                "number" == typeof value ? this.code = value : "string" == typeof value ? this.message = value : isObject(value) && ("number" == typeof value.code && (this.code = value.code), assign(this, value)), this.message || (this.message = MediaError.defaultMessages[this.code] || "");
            }
            Component$1.prototype.supportsRaf_ = "function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().requestAnimationFrame && "function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().cancelAnimationFrame, Component$1.registerComponent("Component", Component$1), MediaError.prototype.code = 0, MediaError.prototype.message = "", MediaError.prototype.status = null, MediaError.errorTypes = [
                "MEDIA_ERR_CUSTOM",
                "MEDIA_ERR_ABORTED",
                "MEDIA_ERR_NETWORK",
                "MEDIA_ERR_DECODE",
                "MEDIA_ERR_SRC_NOT_SUPPORTED",
                "MEDIA_ERR_ENCRYPTED"
            ], MediaError.defaultMessages = {
                1: "You aborted the media playback",
                2: "A network error caused the media download to fail part-way.",
                3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
                4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
                5: "The media is encrypted and we do not have the keys to decrypt it."
            };
            for(var errNum = 0; errNum < MediaError.errorTypes.length; errNum++)MediaError[MediaError.errorTypes[errNum]] = errNum, MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
            function isPromise(value) {
                return null != value && "function" == typeof value.then;
            }
            function silencePromise(value) {
                isPromise(value) && value.then(null, function(e) {});
            }
            var trackToJson_ = function(track) {
                return [
                    "kind",
                    "label",
                    "language",
                    "id",
                    "inBandMetadataTrackDispatchType",
                    "mode",
                    "src"
                ].reduce(function(acc, prop, i) {
                    return track[prop] && (acc[prop] = track[prop]), acc;
                }, {
                    cues: track.cues && Array.prototype.map.call(track.cues, function(cue) {
                        return {
                            startTime: cue.startTime,
                            endTime: cue.endTime,
                            text: cue.text,
                            id: cue.id
                        };
                    })
                });
            }, textTrackConverter = {
                textTracksToJson: function(tech) {
                    var trackEls = tech.$$("track"), trackObjs = Array.prototype.map.call(trackEls, function(t) {
                        return t.track;
                    });
                    return Array.prototype.map.call(trackEls, function(trackEl) {
                        var json = trackToJson_(trackEl.track);
                        return trackEl.src && (json.src = trackEl.src), json;
                    }).concat(Array.prototype.filter.call(tech.textTracks(), function(track) {
                        return -1 === trackObjs.indexOf(track);
                    }).map(trackToJson_));
                },
                jsonToTextTracks: function(json, tech) {
                    return json.forEach(function(track) {
                        var addedTrack = tech.addRemoteTextTrack(track).track;
                        !track.src && track.cues && track.cues.forEach(function(cue) {
                            return addedTrack.addCue(cue);
                        });
                    }), tech.textTracks();
                },
                trackToJson_: trackToJson_
            }, MODAL_CLASS_NAME = "vjs-modal-dialog", ModalDialog = function(_Component) {
                function ModalDialog(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).handleKeyDown_ = function(e) {
                        return _this.handleKeyDown(e);
                    }, _this.close_ = function(e) {
                        return _this.close(e);
                    }, _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = !1, _this.closeable(!_this.options_.uncloseable), _this.content(_this.options_.content), _this.contentEl_ = createEl("div", {
                        className: MODAL_CLASS_NAME + "-content"
                    }, {
                        role: "document"
                    }), _this.descEl_ = createEl("p", {
                        className: MODAL_CLASS_NAME + "-description vjs-control-text",
                        id: _this.el().getAttribute("aria-describedby")
                    }), textContent(_this.descEl_, _this.description()), _this.el_.appendChild(_this.descEl_), _this.el_.appendChild(_this.contentEl_), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ModalDialog, _Component);
                var _proto = ModalDialog.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: this.buildCSSClass(),
                        tabIndex: -1
                    }, {
                        "aria-describedby": this.id() + "_description",
                        "aria-hidden": "true",
                        "aria-label": this.label(),
                        role: "dialog"
                    });
                }, _proto.dispose = function() {
                    this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, _Component.prototype.dispose.call(this);
                }, _proto.buildCSSClass = function() {
                    return MODAL_CLASS_NAME + " vjs-hidden " + _Component.prototype.buildCSSClass.call(this);
                }, _proto.label = function() {
                    return this.localize(this.options_.label || "Modal Window");
                }, _proto.description = function() {
                    var desc = this.options_.description || this.localize("This is a modal window.");
                    return this.closeable() && (desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")), desc;
                }, _proto.open = function() {
                    if (!this.opened_) {
                        var player = this.player();
                        this.trigger("beforemodalopen"), this.opened_ = !0, !this.options_.fillAlways && (this.hasBeenOpened_ || this.hasBeenFilled_) || this.fill(), this.wasPlaying_ = !player.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && player.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = player.controls(), player.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0;
                    }
                }, _proto.opened = function(value) {
                    return "boolean" == typeof value && this[value ? "open" : "close"](), this.opened_;
                }, _proto.close = function() {
                    if (this.opened_) {
                        var player = this.player();
                        this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && player.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && player.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger("modalclose"), this.conditionalBlur_(), this.options_.temporary && this.dispose();
                    }
                }, _proto.closeable = function(value) {
                    if ("boolean" == typeof value) {
                        var closeable = this.closeable_ = !!value, close = this.getChild("closeButton");
                        if (closeable && !close) {
                            var temp = this.contentEl_;
                            this.contentEl_ = this.el_, close = this.addChild("closeButton", {
                                controlText: "Close Modal Dialog"
                            }), this.contentEl_ = temp, this.on(close, "close", this.close_);
                        }
                        !closeable && close && (this.off(close, "close", this.close_), this.removeChild(close), close.dispose());
                    }
                    return this.closeable_;
                }, _proto.fill = function() {
                    this.fillWith(this.content());
                }, _proto.fillWith = function(content) {
                    var contentEl = this.contentEl(), parentEl = contentEl.parentNode, nextSiblingEl = contentEl.nextSibling;
                    this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, parentEl.removeChild(contentEl), this.empty(), insertContent(contentEl, content), this.trigger("modalfill"), nextSiblingEl ? parentEl.insertBefore(contentEl, nextSiblingEl) : parentEl.appendChild(contentEl);
                    var closeButton = this.getChild("closeButton");
                    closeButton && parentEl.appendChild(closeButton.el_);
                }, _proto.empty = function() {
                    this.trigger("beforemodalempty"), emptyEl(this.contentEl()), this.trigger("modalempty");
                }, _proto.content = function(value) {
                    return void 0 !== value && (this.content_ = value), this.content_;
                }, _proto.conditionalFocus_ = function() {
                    var activeEl = global_document__WEBPACK_IMPORTED_MODULE_1___default().activeElement, playerEl = this.player_.el_;
                    this.previouslyActiveEl_ = null, (playerEl.contains(activeEl) || playerEl === activeEl) && (this.previouslyActiveEl_ = activeEl, this.focus());
                }, _proto.conditionalBlur_ = function() {
                    this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null);
                }, _proto.handleKeyDown = function(event) {
                    if (event.stopPropagation(), keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Escape") && this.closeable()) {
                        event.preventDefault(), this.close();
                        return;
                    }
                    if (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Tab")) {
                        for(var focusIndex, focusableEls = this.focusableEls_(), activeEl = this.el_.querySelector(":focus"), i = 0; i < focusableEls.length; i++)if (activeEl === focusableEls[i]) {
                            focusIndex = i;
                            break;
                        }
                        global_document__WEBPACK_IMPORTED_MODULE_1___default().activeElement === this.el_ && (focusIndex = 0), event.shiftKey && 0 === focusIndex ? (focusableEls[focusableEls.length - 1].focus(), event.preventDefault()) : event.shiftKey || focusIndex !== focusableEls.length - 1 || (focusableEls[0].focus(), event.preventDefault());
                    }
                }, _proto.focusableEls_ = function() {
                    var allChildren = this.el_.querySelectorAll("*");
                    return Array.prototype.filter.call(allChildren, function(child) {
                        return (child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLAnchorElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLAreaElement) && child.hasAttribute("href") || (child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLInputElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLSelectElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLTextAreaElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLIFrameElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLObjectElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLEmbedElement || child.hasAttribute("tabindex") && -1 !== child.getAttribute("tabindex") || child.hasAttribute("contenteditable");
                    });
                }, ModalDialog;
            }(Component$1);
            ModalDialog.prototype.options_ = {
                pauseOnOpen: !0,
                temporary: !0
            }, Component$1.registerComponent("ModalDialog", ModalDialog);
            var TrackList = function(_EventTarget) {
                function TrackList(tracks) {
                    var _this;
                    void 0 === tracks && (tracks = []), (_this = _EventTarget.call(this) || this).tracks_ = [], Object.defineProperty((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), "length", {
                        get: function() {
                            return this.tracks_.length;
                        }
                    });
                    for(var i = 0; i < tracks.length; i++)_this.addTrack(tracks[i]);
                    return _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TrackList, _EventTarget);
                var _proto = TrackList.prototype;
                return _proto.addTrack = function(track) {
                    var _this2 = this, index = this.tracks_.length;
                    "" + index in this || Object.defineProperty(this, index, {
                        get: function() {
                            return this.tracks_[index];
                        }
                    }), -1 === this.tracks_.indexOf(track) && (this.tracks_.push(track), this.trigger({
                        track: track,
                        type: "addtrack",
                        target: this
                    })), track.labelchange_ = function() {
                        _this2.trigger({
                            track: track,
                            type: "labelchange",
                            target: _this2
                        });
                    }, isEvented(track) && track.addEventListener("labelchange", track.labelchange_);
                }, _proto.removeTrack = function(rtrack) {
                    for(var track, i = 0, l = this.length; i < l; i++)if (this[i] === rtrack) {
                        (track = this[i]).off && track.off(), this.tracks_.splice(i, 1);
                        break;
                    }
                    track && this.trigger({
                        track: track,
                        type: "removetrack",
                        target: this
                    });
                }, _proto.getTrackById = function(id) {
                    for(var result = null, i = 0, l = this.length; i < l; i++){
                        var track = this[i];
                        if (track.id === id) {
                            result = track;
                            break;
                        }
                    }
                    return result;
                }, TrackList;
            }(EventTarget$2);
            for(var event in TrackList.prototype.allowedEvents_ = {
                change: "change",
                addtrack: "addtrack",
                removetrack: "removetrack",
                labelchange: "labelchange"
            }, TrackList.prototype.allowedEvents_)TrackList.prototype["on" + event] = null;
            var disableOthers$1 = function(list, track) {
                for(var i = 0; i < list.length; i++)Object.keys(list[i]).length && track.id !== list[i].id && (list[i].enabled = !1);
            }, AudioTrackList = function(_TrackList) {
                function AudioTrackList(tracks) {
                    var _this;
                    void 0 === tracks && (tracks = []);
                    for(var i = tracks.length - 1; i >= 0; i--)if (tracks[i].enabled) {
                        disableOthers$1(tracks, tracks[i]);
                        break;
                    }
                    return (_this = _TrackList.call(this, tracks) || this).changing_ = !1, _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(AudioTrackList, _TrackList);
                var _proto = AudioTrackList.prototype;
                return _proto.addTrack = function(track) {
                    var _this2 = this;
                    track.enabled && disableOthers$1(this, track), _TrackList.prototype.addTrack.call(this, track), track.addEventListener && (track.enabledChange_ = function() {
                        _this2.changing_ || (_this2.changing_ = !0, disableOthers$1(_this2, track), _this2.changing_ = !1, _this2.trigger("change"));
                    }, track.addEventListener("enabledchange", track.enabledChange_));
                }, _proto.removeTrack = function(rtrack) {
                    _TrackList.prototype.removeTrack.call(this, rtrack), rtrack.removeEventListener && rtrack.enabledChange_ && (rtrack.removeEventListener("enabledchange", rtrack.enabledChange_), rtrack.enabledChange_ = null);
                }, AudioTrackList;
            }(TrackList), disableOthers = function(list, track) {
                for(var i = 0; i < list.length; i++)Object.keys(list[i]).length && track.id !== list[i].id && (list[i].selected = !1);
            }, VideoTrackList = function(_TrackList) {
                function VideoTrackList(tracks) {
                    var _this;
                    void 0 === tracks && (tracks = []);
                    for(var i = tracks.length - 1; i >= 0; i--)if (tracks[i].selected) {
                        disableOthers(tracks, tracks[i]);
                        break;
                    }
                    return (_this = _TrackList.call(this, tracks) || this).changing_ = !1, Object.defineProperty((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), "selectedIndex", {
                        get: function() {
                            for(var _i = 0; _i < this.length; _i++)if (this[_i].selected) return _i;
                            return -1;
                        },
                        set: function() {}
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VideoTrackList, _TrackList);
                var _proto = VideoTrackList.prototype;
                return _proto.addTrack = function(track) {
                    var _this2 = this;
                    track.selected && disableOthers(this, track), _TrackList.prototype.addTrack.call(this, track), track.addEventListener && (track.selectedChange_ = function() {
                        _this2.changing_ || (_this2.changing_ = !0, disableOthers(_this2, track), _this2.changing_ = !1, _this2.trigger("change"));
                    }, track.addEventListener("selectedchange", track.selectedChange_));
                }, _proto.removeTrack = function(rtrack) {
                    _TrackList.prototype.removeTrack.call(this, rtrack), rtrack.removeEventListener && rtrack.selectedChange_ && (rtrack.removeEventListener("selectedchange", rtrack.selectedChange_), rtrack.selectedChange_ = null);
                }, VideoTrackList;
            }(TrackList), TextTrackList = function(_TrackList) {
                function TextTrackList() {
                    return _TrackList.apply(this, arguments) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TextTrackList, _TrackList);
                var _proto = TextTrackList.prototype;
                return _proto.addTrack = function(track) {
                    var _this = this;
                    _TrackList.prototype.addTrack.call(this, track), this.queueChange_ || (this.queueChange_ = function() {
                        return _this.queueTrigger("change");
                    }), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = function() {
                        return _this.trigger("selectedlanguagechange");
                    }), track.addEventListener("modechange", this.queueChange_), -1 === [
                        "metadata",
                        "chapters"
                    ].indexOf(track.kind) && track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
                }, _proto.removeTrack = function(rtrack) {
                    _TrackList.prototype.removeTrack.call(this, rtrack), rtrack.removeEventListener && (this.queueChange_ && rtrack.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_ && rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_));
                }, TextTrackList;
            }(TrackList), HtmlTrackElementList = function() {
                function HtmlTrackElementList(trackElements) {
                    void 0 === trackElements && (trackElements = []), this.trackElements_ = [], Object.defineProperty(this, "length", {
                        get: function() {
                            return this.trackElements_.length;
                        }
                    });
                    for(var i = 0, length = trackElements.length; i < length; i++)this.addTrackElement_(trackElements[i]);
                }
                var _proto = HtmlTrackElementList.prototype;
                return _proto.addTrackElement_ = function(trackElement) {
                    var index = this.trackElements_.length;
                    "" + index in this || Object.defineProperty(this, index, {
                        get: function() {
                            return this.trackElements_[index];
                        }
                    }), -1 === this.trackElements_.indexOf(trackElement) && this.trackElements_.push(trackElement);
                }, _proto.getTrackElementByTrack_ = function(track) {
                    for(var trackElement_, i = 0, length = this.trackElements_.length; i < length; i++)if (track === this.trackElements_[i].track) {
                        trackElement_ = this.trackElements_[i];
                        break;
                    }
                    return trackElement_;
                }, _proto.removeTrackElement_ = function(trackElement) {
                    for(var i = 0, length = this.trackElements_.length; i < length; i++)if (trackElement === this.trackElements_[i]) {
                        this.trackElements_[i].track && "function" == typeof this.trackElements_[i].track.off && this.trackElements_[i].track.off(), "function" == typeof this.trackElements_[i].off && this.trackElements_[i].off(), this.trackElements_.splice(i, 1);
                        break;
                    }
                }, HtmlTrackElementList;
            }(), TextTrackCueList = function() {
                function TextTrackCueList(cues) {
                    TextTrackCueList.prototype.setCues_.call(this, cues), Object.defineProperty(this, "length", {
                        get: function() {
                            return this.length_;
                        }
                    });
                }
                var _proto = TextTrackCueList.prototype;
                return _proto.setCues_ = function(cues) {
                    var oldLength = this.length || 0, i = 0, l = cues.length;
                    this.cues_ = cues, this.length_ = cues.length;
                    var defineProp = function(index) {
                        "" + index in this || Object.defineProperty(this, "" + index, {
                            get: function() {
                                return this.cues_[index];
                            }
                        });
                    };
                    if (oldLength < l) for(i = oldLength; i < l; i++)defineProp.call(this, i);
                }, _proto.getCueById = function(id) {
                    for(var result = null, i = 0, l = this.length; i < l; i++){
                        var cue = this[i];
                        if (cue.id === id) {
                            result = cue;
                            break;
                        }
                    }
                    return result;
                }, TextTrackCueList;
            }(), VideoTrackKind = {
                alternative: "alternative",
                captions: "captions",
                main: "main",
                sign: "sign",
                subtitles: "subtitles",
                commentary: "commentary"
            }, AudioTrackKind = {
                alternative: "alternative",
                descriptions: "descriptions",
                main: "main",
                "main-desc": "main-desc",
                translation: "translation",
                commentary: "commentary"
            }, TextTrackKind = {
                subtitles: "subtitles",
                captions: "captions",
                descriptions: "descriptions",
                chapters: "chapters",
                metadata: "metadata"
            }, TextTrackMode = {
                disabled: "disabled",
                hidden: "hidden",
                showing: "showing"
            }, Track = function(_EventTarget) {
                function Track(options) {
                    void 0 === options && (options = {}), _this = _EventTarget.call(this) || this;
                    var _this, trackProps = {
                        id: options.id || "vjs_track_" + _guid++,
                        kind: options.kind || "",
                        language: options.language || ""
                    }, label = options.label || "", _loop = function(key) {
                        Object.defineProperty((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), key, {
                            get: function() {
                                return trackProps[key];
                            },
                            set: function() {}
                        });
                    };
                    for(var key in trackProps)_loop(key);
                    return Object.defineProperty((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), "label", {
                        get: function() {
                            return label;
                        },
                        set: function(newLabel) {
                            newLabel !== label && (label = newLabel, this.trigger("labelchange"));
                        }
                    }), _this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Track, _EventTarget), Track;
            }(EventTarget$2), parseUrl = function(url) {
                var props = [
                    "protocol",
                    "hostname",
                    "port",
                    "pathname",
                    "search",
                    "hash",
                    "host"
                ], a = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("a");
                a.href = url;
                for(var details = {}, i = 0; i < props.length; i++)details[props[i]] = a[props[i]];
                return "http:" === details.protocol && (details.host = details.host.replace(/:80$/, "")), "https:" === details.protocol && (details.host = details.host.replace(/:443$/, "")), details.protocol || (details.protocol = global_window__WEBPACK_IMPORTED_MODULE_0___default().location.protocol), details.host || (details.host = global_window__WEBPACK_IMPORTED_MODULE_0___default().location.host), details;
            }, getAbsoluteURL = function(url) {
                if (!url.match(/^https?:\/\//)) {
                    var a = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("a");
                    a.href = url, url = a.href;
                }
                return url;
            }, getFileExtension = function(path) {
                if ("string" == typeof path) {
                    var pathParts = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/.exec(path);
                    if (pathParts) return pathParts.pop().toLowerCase();
                }
                return "";
            }, isCrossOrigin = function(url, winLoc) {
                void 0 === winLoc && (winLoc = global_window__WEBPACK_IMPORTED_MODULE_0___default().location);
                var urlInfo = parseUrl(url);
                return (":" === urlInfo.protocol ? winLoc.protocol : urlInfo.protocol) + urlInfo.host !== winLoc.protocol + winLoc.host;
            }, Url = Object.freeze({
                __proto__: null,
                parseUrl: parseUrl,
                getAbsoluteURL: getAbsoluteURL,
                getFileExtension: getFileExtension,
                isCrossOrigin: isCrossOrigin
            }), parseCues = function(srcContent, track) {
                var parser = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).WebVTT.Parser(global_window__WEBPACK_IMPORTED_MODULE_0___default(), global_window__WEBPACK_IMPORTED_MODULE_0___default().vttjs, global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT.StringDecoder()), errors = [];
                parser.oncue = function(cue) {
                    track.addCue(cue);
                }, parser.onparsingerror = function(error) {
                    errors.push(error);
                }, parser.onflush = function() {
                    track.trigger({
                        type: "loadeddata",
                        target: track
                    });
                }, parser.parse(srcContent), errors.length > 0 && (global_window__WEBPACK_IMPORTED_MODULE_0___default().console && global_window__WEBPACK_IMPORTED_MODULE_0___default().console.groupCollapsed && global_window__WEBPACK_IMPORTED_MODULE_0___default().console.groupCollapsed("Text Track parsing errors for " + track.src), errors.forEach(function(error) {
                    return log$1.error(error);
                }), global_window__WEBPACK_IMPORTED_MODULE_0___default().console && global_window__WEBPACK_IMPORTED_MODULE_0___default().console.groupEnd && global_window__WEBPACK_IMPORTED_MODULE_0___default().console.groupEnd()), parser.flush();
            }, loadTrack = function(src, track) {
                var opts = {
                    uri: src
                }, crossOrigin = isCrossOrigin(src);
                crossOrigin && (opts.cors = crossOrigin);
                var withCredentials = "use-credentials" === track.tech_.crossOrigin();
                withCredentials && (opts.withCredentials = withCredentials), _videojs_xhr__WEBPACK_IMPORTED_MODULE_4___default()(opts, bind(this, function(err, response, responseBody) {
                    if (err) return log$1.error(err, response);
                    track.loaded_ = !0, "function" != typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT ? track.tech_ && track.tech_.any([
                        "vttjsloaded",
                        "vttjserror"
                    ], function(event) {
                        if ("vttjserror" === event.type) {
                            log$1.error("vttjs failed to load, stopping trying to process " + track.src);
                            return;
                        }
                        return parseCues(responseBody, track);
                    }) : parseCues(responseBody, track);
                }));
            }, TextTrack = function(_Track) {
                function TextTrack(options) {
                    if (void 0 === options && (options = {}), !options.tech) throw Error("A tech was not provided.");
                    var _this, settings = mergeOptions$3(options, {
                        kind: TextTrackKind[options.kind] || "subtitles",
                        language: options.language || options.srclang || ""
                    }), mode = TextTrackMode[settings.mode] || "disabled", default_ = settings.default;
                    ("metadata" === settings.kind || "chapters" === settings.kind) && (mode = "hidden"), (_this = _Track.call(this, settings) || this).tech_ = settings.tech, _this.cues_ = [], _this.activeCues_ = [], _this.preload_ = !1 !== _this.tech_.preloadTextTracks;
                    var cues = new TextTrackCueList(_this.cues_), activeCues = new TextTrackCueList(_this.activeCues_), changed = !1, timeupdateHandler = bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), function() {
                        !(!this.tech_.isReady_ || this.tech_.isDisposed()) && (this.activeCues = this.activeCues, changed && (this.trigger("cuechange"), changed = !1));
                    });
                    return _this.tech_.one("dispose", function() {
                        _this.tech_.off("timeupdate", timeupdateHandler);
                    }), "disabled" !== mode && _this.tech_.on("timeupdate", timeupdateHandler), Object.defineProperties((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), {
                        default: {
                            get: function() {
                                return default_;
                            },
                            set: function() {}
                        },
                        mode: {
                            get: function() {
                                return mode;
                            },
                            set: function(newMode) {
                                TextTrackMode[newMode] && mode !== newMode && (mode = newMode, this.preload_ || "disabled" === mode || 0 !== this.cues.length || loadTrack(this.src, this), this.tech_.off("timeupdate", timeupdateHandler), "disabled" !== mode && this.tech_.on("timeupdate", timeupdateHandler), this.trigger("modechange"));
                            }
                        },
                        cues: {
                            get: function() {
                                return this.loaded_ ? cues : null;
                            },
                            set: function() {}
                        },
                        activeCues: {
                            get: function() {
                                if (!this.loaded_) return null;
                                if (0 === this.cues.length) return activeCues;
                                for(var ct = this.tech_.currentTime(), active = [], i = 0, l = this.cues.length; i < l; i++){
                                    var cue = this.cues[i];
                                    cue.startTime <= ct && cue.endTime >= ct ? active.push(cue) : cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct && active.push(cue);
                                }
                                if (changed = !1, active.length !== this.activeCues_.length) changed = !0;
                                else for(var _i = 0; _i < active.length; _i++)-1 === this.activeCues_.indexOf(active[_i]) && (changed = !0);
                                return this.activeCues_ = active, activeCues.setCues_(this.activeCues_), activeCues;
                            },
                            set: function() {}
                        }
                    }), settings.src ? (_this.src = settings.src, _this.preload_ || (_this.loaded_ = !0), (_this.preload_ || "subtitles" !== settings.kind && "captions" !== settings.kind) && loadTrack(_this.src, (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this))) : _this.loaded_ = !0, _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TextTrack, _Track);
                var _proto = TextTrack.prototype;
                return _proto.addCue = function(originalCue) {
                    var cue = originalCue;
                    if (global_window__WEBPACK_IMPORTED_MODULE_0___default().vttjs && !(originalCue instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default().vttjs.VTTCue)) {
                        for(var prop in cue = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text), originalCue)prop in cue || (cue[prop] = originalCue[prop]);
                        cue.id = originalCue.id, cue.originalCue_ = originalCue;
                    }
                    for(var tracks = this.tech_.textTracks(), i = 0; i < tracks.length; i++)tracks[i] !== this && tracks[i].removeCue(cue);
                    this.cues_.push(cue), this.cues.setCues_(this.cues_);
                }, _proto.removeCue = function(_removeCue) {
                    for(var i = this.cues_.length; i--;){
                        var cue = this.cues_[i];
                        if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
                            this.cues_.splice(i, 1), this.cues.setCues_(this.cues_);
                            break;
                        }
                    }
                }, TextTrack;
            }(Track);
            TextTrack.prototype.allowedEvents_ = {
                cuechange: "cuechange"
            };
            var AudioTrack = function(_Track) {
                function AudioTrack(options) {
                    void 0 === options && (options = {});
                    var _this, settings = mergeOptions$3(options, {
                        kind: AudioTrackKind[options.kind] || ""
                    });
                    _this = _Track.call(this, settings) || this;
                    var enabled = !1;
                    return Object.defineProperty((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), "enabled", {
                        get: function() {
                            return enabled;
                        },
                        set: function(newEnabled) {
                            "boolean" == typeof newEnabled && newEnabled !== enabled && (enabled = newEnabled, this.trigger("enabledchange"));
                        }
                    }), settings.enabled && (_this.enabled = settings.enabled), _this.loaded_ = !0, _this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(AudioTrack, _Track), AudioTrack;
            }(Track), VideoTrack = function(_Track) {
                function VideoTrack(options) {
                    void 0 === options && (options = {});
                    var _this, settings = mergeOptions$3(options, {
                        kind: VideoTrackKind[options.kind] || ""
                    });
                    _this = _Track.call(this, settings) || this;
                    var selected = !1;
                    return Object.defineProperty((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), "selected", {
                        get: function() {
                            return selected;
                        },
                        set: function(newSelected) {
                            "boolean" == typeof newSelected && newSelected !== selected && (selected = newSelected, this.trigger("selectedchange"));
                        }
                    }), settings.selected && (_this.selected = settings.selected), _this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VideoTrack, _Track), VideoTrack;
            }(Track), HTMLTrackElement = function(_EventTarget) {
                function HTMLTrackElement(options) {
                    void 0 === options && (options = {}), _this = _EventTarget.call(this) || this;
                    var _this, readyState, track = new TextTrack(options);
                    return _this.kind = track.kind, _this.src = track.src, _this.srclang = track.language, _this.label = track.label, _this.default = track.default, Object.defineProperties((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), {
                        readyState: {
                            get: function() {
                                return readyState;
                            }
                        },
                        track: {
                            get: function() {
                                return track;
                            }
                        }
                    }), readyState = 0, track.addEventListener("loadeddata", function() {
                        readyState = 2, _this.trigger({
                            type: "load",
                            target: (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)
                        });
                    }), _this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(HTMLTrackElement, _EventTarget), HTMLTrackElement;
            }(EventTarget$2);
            HTMLTrackElement.prototype.allowedEvents_ = {
                load: "load"
            }, HTMLTrackElement.NONE = 0, HTMLTrackElement.LOADING = 1, HTMLTrackElement.LOADED = 2, HTMLTrackElement.ERROR = 3;
            var NORMAL = {
                audio: {
                    ListClass: AudioTrackList,
                    TrackClass: AudioTrack,
                    capitalName: "Audio"
                },
                video: {
                    ListClass: VideoTrackList,
                    TrackClass: VideoTrack,
                    capitalName: "Video"
                },
                text: {
                    ListClass: TextTrackList,
                    TrackClass: TextTrack,
                    capitalName: "Text"
                }
            };
            Object.keys(NORMAL).forEach(function(type) {
                NORMAL[type].getterName = type + "Tracks", NORMAL[type].privateName = type + "Tracks_";
            });
            var REMOTE = {
                remoteText: {
                    ListClass: TextTrackList,
                    TrackClass: TextTrack,
                    capitalName: "RemoteText",
                    getterName: "remoteTextTracks",
                    privateName: "remoteTextTracks_"
                },
                remoteTextEl: {
                    ListClass: HtmlTrackElementList,
                    TrackClass: HTMLTrackElement,
                    capitalName: "RemoteTextTrackEls",
                    getterName: "remoteTextTrackEls",
                    privateName: "remoteTextTrackEls_"
                }
            }, ALL = (0, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__.Z)({}, NORMAL, REMOTE);
            REMOTE.names = Object.keys(REMOTE), NORMAL.names = Object.keys(NORMAL), ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
            var Tech = function(_Component) {
                function Tech(options, ready) {
                    var _this;
                    return void 0 === options && (options = {}), void 0 === ready && (ready = function() {}), options.reportTouchActivity = !1, (_this = _Component.call(this, null, options, ready) || this).onDurationChange_ = function(e) {
                        return _this.onDurationChange(e);
                    }, _this.trackProgress_ = function(e) {
                        return _this.trackProgress(e);
                    }, _this.trackCurrentTime_ = function(e) {
                        return _this.trackCurrentTime(e);
                    }, _this.stopTrackingCurrentTime_ = function(e) {
                        return _this.stopTrackingCurrentTime(e);
                    }, _this.disposeSourceHandler_ = function(e) {
                        return _this.disposeSourceHandler(e);
                    }, _this.hasStarted_ = !1, _this.on("playing", function() {
                        this.hasStarted_ = !0;
                    }), _this.on("loadstart", function() {
                        this.hasStarted_ = !1;
                    }), ALL.names.forEach(function(name) {
                        var props = ALL[name];
                        options && options[props.getterName] && (_this[props.privateName] = options[props.getterName]);
                    }), _this.featuresProgressEvents || _this.manualProgressOn(), _this.featuresTimeupdateEvents || _this.manualTimeUpdatesOn(), [
                        "Text",
                        "Audio",
                        "Video"
                    ].forEach(function(track) {
                        !1 === options["native" + track + "Tracks"] && (_this["featuresNative" + track + "Tracks"] = !1);
                    }), !1 === options.nativeCaptions || !1 === options.nativeTextTracks ? _this.featuresNativeTextTracks = !1 : (!0 === options.nativeCaptions || !0 === options.nativeTextTracks) && (_this.featuresNativeTextTracks = !0), _this.featuresNativeTextTracks || _this.emulateTextTracks(), _this.preloadTextTracks = !1 !== options.preloadTextTracks, _this.autoRemoteTextTracks_ = new ALL.text.ListClass(), _this.initTrackListeners(), options.nativeControlsForTouch || _this.emitTapEvents(), _this.constructor && (_this.name_ = _this.constructor.name || "Unknown Tech"), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Tech, _Component);
                var _proto = Tech.prototype;
                return _proto.triggerSourceset = function(src) {
                    var _this2 = this;
                    this.isReady_ || this.one("ready", function() {
                        return _this2.setTimeout(function() {
                            return _this2.triggerSourceset(src);
                        }, 1);
                    }), this.trigger({
                        src: src,
                        type: "sourceset"
                    });
                }, _proto.manualProgressOn = function() {
                    this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_);
                }, _proto.manualProgressOff = function() {
                    this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_);
                }, _proto.trackProgress = function(event) {
                    this.stopTrackingProgress(), this.progressInterval = this.setInterval(bind(this, function() {
                        var numBufferedPercent = this.bufferedPercent();
                        this.bufferedPercent_ !== numBufferedPercent && this.trigger("progress"), this.bufferedPercent_ = numBufferedPercent, 1 === numBufferedPercent && this.stopTrackingProgress();
                    }), 500);
                }, _proto.onDurationChange = function(event) {
                    this.duration_ = this.duration();
                }, _proto.buffered = function() {
                    return createTimeRanges(0, 0);
                }, _proto.bufferedPercent = function() {
                    return bufferedPercent(this.buffered(), this.duration_);
                }, _proto.stopTrackingProgress = function() {
                    this.clearInterval(this.progressInterval);
                }, _proto.manualTimeUpdatesOn = function() {
                    this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_);
                }, _proto.manualTimeUpdatesOff = function() {
                    this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_);
                }, _proto.trackCurrentTime = function() {
                    this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval(function() {
                        this.trigger({
                            type: "timeupdate",
                            target: this,
                            manuallyTriggered: !0
                        });
                    }, 250);
                }, _proto.stopTrackingCurrentTime = function() {
                    this.clearInterval(this.currentTimeInterval), this.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    });
                }, _proto.dispose = function() {
                    this.clearTracks(NORMAL.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), _Component.prototype.dispose.call(this);
                }, _proto.clearTracks = function(types) {
                    var _this3 = this;
                    (types = [].concat(types)).forEach(function(type) {
                        for(var list = _this3[type + "Tracks"]() || [], i = list.length; i--;){
                            var track = list[i];
                            "text" === type && _this3.removeRemoteTextTrack(track), list.removeTrack(track);
                        }
                    });
                }, _proto.cleanupAutoTextTracks = function() {
                    for(var list = this.autoRemoteTextTracks_ || [], i = list.length; i--;){
                        var track = list[i];
                        this.removeRemoteTextTrack(track);
                    }
                }, _proto.reset = function() {}, _proto.crossOrigin = function() {}, _proto.setCrossOrigin = function() {}, _proto.error = function(err) {
                    return void 0 !== err && (this.error_ = new MediaError(err), this.trigger("error")), this.error_;
                }, _proto.played = function() {
                    return this.hasStarted_ ? createTimeRanges(0, 0) : createTimeRanges();
                }, _proto.play = function() {}, _proto.setScrubbing = function() {}, _proto.scrubbing = function() {}, _proto.setCurrentTime = function() {
                    this.manualTimeUpdates && this.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    });
                }, _proto.initTrackListeners = function() {
                    var _this4 = this;
                    NORMAL.names.forEach(function(name) {
                        var props = NORMAL[name], trackListChanges = function() {
                            _this4.trigger(name + "trackchange");
                        }, tracks = _this4[props.getterName]();
                        tracks.addEventListener("removetrack", trackListChanges), tracks.addEventListener("addtrack", trackListChanges), _this4.on("dispose", function() {
                            tracks.removeEventListener("removetrack", trackListChanges), tracks.removeEventListener("addtrack", trackListChanges);
                        });
                    });
                }, _proto.addWebVttScript_ = function() {
                    var _this5 = this;
                    if (!global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT) {
                        if (global_document__WEBPACK_IMPORTED_MODULE_1___default().body.contains(this.el())) {
                            if (!this.options_["vtt.js"] && isPlain(videojs_vtt_js__WEBPACK_IMPORTED_MODULE_5___default()) && Object.keys(videojs_vtt_js__WEBPACK_IMPORTED_MODULE_5___default()).length > 0) {
                                this.trigger("vttjsloaded");
                                return;
                            }
                            var script = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("script");
                            script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", script.onload = function() {
                                _this5.trigger("vttjsloaded");
                            }, script.onerror = function() {
                                _this5.trigger("vttjserror");
                            }, this.on("dispose", function() {
                                script.onload = null, script.onerror = null;
                            }), global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT = !0, this.el().parentNode.appendChild(script);
                        } else this.ready(this.addWebVttScript_);
                    }
                }, _proto.emulateTextTracks = function() {
                    var _this6 = this, tracks = this.textTracks(), remoteTracks = this.remoteTextTracks(), handleAddTrack = function(e) {
                        return tracks.addTrack(e.track);
                    }, handleRemoveTrack = function(e) {
                        return tracks.removeTrack(e.track);
                    };
                    remoteTracks.on("addtrack", handleAddTrack), remoteTracks.on("removetrack", handleRemoveTrack), this.addWebVttScript_();
                    var updateDisplay = function() {
                        return _this6.trigger("texttrackchange");
                    }, textTracksChanges = function() {
                        updateDisplay();
                        for(var i = 0; i < tracks.length; i++){
                            var track = tracks[i];
                            track.removeEventListener("cuechange", updateDisplay), "showing" === track.mode && track.addEventListener("cuechange", updateDisplay);
                        }
                    };
                    textTracksChanges(), tracks.addEventListener("change", textTracksChanges), tracks.addEventListener("addtrack", textTracksChanges), tracks.addEventListener("removetrack", textTracksChanges), this.on("dispose", function() {
                        remoteTracks.off("addtrack", handleAddTrack), remoteTracks.off("removetrack", handleRemoveTrack), tracks.removeEventListener("change", textTracksChanges), tracks.removeEventListener("addtrack", textTracksChanges), tracks.removeEventListener("removetrack", textTracksChanges);
                        for(var i = 0; i < tracks.length; i++)tracks[i].removeEventListener("cuechange", updateDisplay);
                    });
                }, _proto.addTextTrack = function(kind, label, language) {
                    var options, tracks, track;
                    if (!kind) throw Error("TextTrack kind is required but was not provided");
                    return void 0 === options && (options = {}), tracks = this.textTracks(), options.kind = kind, label && (options.label = label), language && (options.language = language), options.tech = this, track = new ALL.text.TrackClass(options), tracks.addTrack(track), track;
                }, _proto.createRemoteTextTrack = function(options) {
                    var track = mergeOptions$3(options, {
                        tech: this
                    });
                    return new REMOTE.remoteTextEl.TrackClass(track);
                }, _proto.addRemoteTextTrack = function(options, manualCleanup) {
                    var _this7 = this;
                    void 0 === options && (options = {});
                    var htmlTrackElement = this.createRemoteTextTrack(options);
                    return !0 !== manualCleanup && !1 !== manualCleanup && (log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js'), manualCleanup = !0), this.remoteTextTrackEls().addTrackElement_(htmlTrackElement), this.remoteTextTracks().addTrack(htmlTrackElement.track), !0 !== manualCleanup && this.ready(function() {
                        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
                    }), htmlTrackElement;
                }, _proto.removeRemoteTextTrack = function(track) {
                    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
                    this.remoteTextTrackEls().removeTrackElement_(trackElement), this.remoteTextTracks().removeTrack(track), this.autoRemoteTextTracks_.removeTrack(track);
                }, _proto.getVideoPlaybackQuality = function() {
                    return {};
                }, _proto.requestPictureInPicture = function() {
                    var PromiseClass = this.options_.Promise || global_window__WEBPACK_IMPORTED_MODULE_0___default().Promise;
                    if (PromiseClass) return PromiseClass.reject();
                }, _proto.disablePictureInPicture = function() {
                    return !0;
                }, _proto.setDisablePictureInPicture = function() {}, _proto.setPoster = function() {}, _proto.playsinline = function() {}, _proto.setPlaysinline = function() {}, _proto.overrideNativeAudioTracks = function() {}, _proto.overrideNativeVideoTracks = function() {}, _proto.canPlayType = function() {
                    return "";
                }, Tech.canPlayType = function() {
                    return "";
                }, Tech.canPlaySource = function(srcObj, options) {
                    return Tech.canPlayType(srcObj.type);
                }, Tech.isTech = function(component) {
                    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
                }, Tech.registerTech = function(name, tech) {
                    if (Tech.techs_ || (Tech.techs_ = {}), !Tech.isTech(tech)) throw Error("Tech " + name + " must be a Tech");
                    if (!Tech.canPlayType) throw Error("Techs must have a static canPlayType method on them");
                    if (!Tech.canPlaySource) throw Error("Techs must have a static canPlaySource method on them");
                    return name = toTitleCase$1(name), Tech.techs_[name] = tech, Tech.techs_[toLowerCase(name)] = tech, "Tech" !== name && Tech.defaultTechOrder_.push(name), tech;
                }, Tech.getTech = function(name) {
                    return name ? Tech.techs_ && Tech.techs_[name] ? Tech.techs_[name] : (name = toTitleCase$1(name), global_window__WEBPACK_IMPORTED_MODULE_0___default() && global_window__WEBPACK_IMPORTED_MODULE_0___default().videojs && global_window__WEBPACK_IMPORTED_MODULE_0___default().videojs[name]) ? (log$1.warn("The " + name + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)"), global_window__WEBPACK_IMPORTED_MODULE_0___default().videojs[name]) : void 0 : void 0;
                }, Tech;
            }(Component$1);
            ALL.names.forEach(function(name) {
                var props = ALL[name];
                Tech.prototype[props.getterName] = function() {
                    return this[props.privateName] = this[props.privateName] || new props.ListClass(), this[props.privateName];
                };
            }), Tech.prototype.featuresVolumeControl = !0, Tech.prototype.featuresMuteControl = !0, Tech.prototype.featuresFullscreenResize = !1, Tech.prototype.featuresPlaybackRate = !1, Tech.prototype.featuresProgressEvents = !1, Tech.prototype.featuresSourceset = !1, Tech.prototype.featuresTimeupdateEvents = !1, Tech.prototype.featuresNativeTextTracks = !1, Tech.withSourceHandlers = function(_Tech) {
                _Tech.registerSourceHandler = function(handler, index) {
                    var handlers = _Tech.sourceHandlers;
                    handlers || (handlers = _Tech.sourceHandlers = []), void 0 === index && (index = handlers.length), handlers.splice(index, 0, handler);
                }, _Tech.canPlayType = function(type) {
                    for(var can, handlers = _Tech.sourceHandlers || [], i = 0; i < handlers.length; i++)if (can = handlers[i].canPlayType(type)) return can;
                    return "";
                }, _Tech.selectSourceHandler = function(source, options) {
                    for(var handlers = _Tech.sourceHandlers || [], i = 0; i < handlers.length; i++)if (handlers[i].canHandleSource(source, options)) return handlers[i];
                    return null;
                }, _Tech.canPlaySource = function(srcObj, options) {
                    var sh = _Tech.selectSourceHandler(srcObj, options);
                    return sh ? sh.canHandleSource(srcObj, options) : "";
                }, [
                    "seekable",
                    "seeking",
                    "duration"
                ].forEach(function(fnName) {
                    var originalFn = this[fnName];
                    "function" == typeof originalFn && (this[fnName] = function() {
                        return this.sourceHandler_ && this.sourceHandler_[fnName] ? this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments) : originalFn.apply(this, arguments);
                    });
                }, _Tech.prototype), _Tech.prototype.setSource = function(source) {
                    var sh = _Tech.selectSourceHandler(source, this.options_);
                    sh || (_Tech.nativeSourceHandler ? sh = _Tech.nativeSourceHandler : log$1.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), sh !== _Tech.nativeSourceHandler && (this.currentSource_ = source), this.sourceHandler_ = sh.handleSource(source, this, this.options_), this.one("dispose", this.disposeSourceHandler_);
                }, _Tech.prototype.disposeSourceHandler = function() {
                    this.currentSource_ && (this.clearTracks([
                        "audio",
                        "video"
                    ]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null);
                };
            }, Component$1.registerComponent("Tech", Tech), Tech.registerTech("Tech", Tech), Tech.defaultTechOrder_ = [];
            var middlewares = {}, middlewareInstances = {}, TERMINATOR = {};
            function mediate(middleware, tech, method, arg) {
                void 0 === arg && (arg = null);
                var callMethod = "call" + toTitleCase$1(method), middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg), terminated = middlewareValue === TERMINATOR, returnValue = terminated ? null : tech[method](middlewareValue);
                return function(mws, method, value, terminated) {
                    for(var i = mws.length - 1; i >= 0; i--){
                        var mw = mws[i];
                        mw[method] && mw[method](terminated, value);
                    }
                }(middleware, method, returnValue, terminated), returnValue;
            }
            var allowedGetters = {
                buffered: 1,
                currentTime: 1,
                duration: 1,
                muted: 1,
                played: 1,
                paused: 1,
                seekable: 1,
                volume: 1,
                ended: 1
            }, allowedSetters = {
                setCurrentTime: 1,
                setMuted: 1,
                setVolume: 1
            }, allowedMediators = {
                play: 1,
                pause: 1
            };
            function middlewareIterator(method) {
                return function(value, mw) {
                    return value === TERMINATOR ? TERMINATOR : mw[method] ? mw[method](value) : value;
                };
            }
            var MimetypesKind = {
                opus: "video/ogg",
                ogv: "video/ogg",
                mp4: "video/mp4",
                mov: "video/mp4",
                m4v: "video/mp4",
                mkv: "video/x-matroska",
                m4a: "audio/mp4",
                mp3: "audio/mpeg",
                aac: "audio/aac",
                caf: "audio/x-caf",
                flac: "audio/flac",
                oga: "audio/ogg",
                wav: "audio/wav",
                m3u8: "application/x-mpegURL",
                jpg: "image/jpeg",
                jpeg: "image/jpeg",
                gif: "image/gif",
                png: "image/png",
                svg: "image/svg+xml",
                webp: "image/webp"
            }, getMimetype = function(src) {
                return void 0 === src && (src = ""), MimetypesKind[getFileExtension(src).toLowerCase()] || "";
            }, findMimetype = function(player, src) {
                if (!src) return "";
                if (player.cache_.source.src === src && player.cache_.source.type) return player.cache_.source.type;
                var matchingSources = player.cache_.sources.filter(function(s) {
                    return s.src === src;
                });
                if (matchingSources.length) return matchingSources[0].type;
                for(var sources = player.$$("source"), i = 0; i < sources.length; i++){
                    var s = sources[i];
                    if (s.type && s.src && s.src === src) return s.type;
                }
                return getMimetype(src);
            }, filterSource = function filterSource(src) {
                if (Array.isArray(src)) {
                    var newsrc = [];
                    src.forEach(function(srcobj) {
                        Array.isArray(srcobj = filterSource(srcobj)) ? newsrc = newsrc.concat(srcobj) : isObject(srcobj) && newsrc.push(srcobj);
                    }), src = newsrc;
                } else src = "string" == typeof src && src.trim() ? [
                    fixSource({
                        src: src
                    })
                ] : isObject(src) && "string" == typeof src.src && src.src && src.src.trim() ? [
                    fixSource(src)
                ] : [];
                return src;
            };
            function fixSource(src) {
                if (!src.type) {
                    var mimetype = getMimetype(src.src);
                    mimetype && (src.type = mimetype);
                }
                return src;
            }
            var MediaLoader = function(_Component) {
                function MediaLoader(player, options, ready) {
                    var _this, options_ = mergeOptions$3({
                        createEl: !1
                    }, options);
                    if (_this = _Component.call(this, player, options_, ready) || this, options.playerOptions.sources && 0 !== options.playerOptions.sources.length) player.src(options.playerOptions.sources);
                    else for(var i = 0, j = options.playerOptions.techOrder; i < j.length; i++){
                        var techName = toTitleCase$1(j[i]), tech = Tech.getTech(techName);
                        if (techName || (tech = Component$1.getComponent(techName)), tech && tech.isSupported()) {
                            player.loadTech_(techName);
                            break;
                        }
                    }
                    return _this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(MediaLoader, _Component), MediaLoader;
            }(Component$1);
            Component$1.registerComponent("MediaLoader", MediaLoader);
            var ClickableComponent = function(_Component) {
                function ClickableComponent(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).handleMouseOver_ = function(e) {
                        return _this.handleMouseOver(e);
                    }, _this.handleMouseOut_ = function(e) {
                        return _this.handleMouseOut(e);
                    }, _this.handleClick_ = function(e) {
                        return _this.handleClick(e);
                    }, _this.handleKeyDown_ = function(e) {
                        return _this.handleKeyDown(e);
                    }, _this.emitTapEvents(), _this.enable(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ClickableComponent, _Component);
                var _proto = ClickableComponent.prototype;
                return _proto.createEl = function(tag, props, attributes) {
                    void 0 === tag && (tag = "div"), void 0 === props && (props = {}), void 0 === attributes && (attributes = {}), props = assign({
                        className: this.buildCSSClass(),
                        tabIndex: 0
                    }, props), "button" === tag && log$1.error("Creating a ClickableComponent with an HTML element of " + tag + " is not supported; use a Button instead."), attributes = assign({
                        role: "button"
                    }, attributes), this.tabIndex_ = props.tabIndex;
                    var el = createEl(tag, props, attributes);
                    return el.appendChild(createEl("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), this.createControlTextEl(el), el;
                }, _proto.dispose = function() {
                    this.controlTextEl_ = null, _Component.prototype.dispose.call(this);
                }, _proto.createControlTextEl = function(el) {
                    return this.controlTextEl_ = createEl("span", {
                        className: "vjs-control-text"
                    }, {
                        "aria-live": "polite"
                    }), el && el.appendChild(this.controlTextEl_), this.controlText(this.controlText_, el), this.controlTextEl_;
                }, _proto.controlText = function(text, el) {
                    if (void 0 === el && (el = this.el()), void 0 === text) return this.controlText_ || "Need Text";
                    var localizedText = this.localize(text);
                    this.controlText_ = text, textContent(this.controlTextEl_, localizedText), this.nonIconControl || this.player_.options_.noUITitleAttributes || el.setAttribute("title", localizedText);
                }, _proto.buildCSSClass = function() {
                    return "vjs-control vjs-button " + _Component.prototype.buildCSSClass.call(this);
                }, _proto.enable = function() {
                    this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), void 0 !== this.tabIndex_ && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on([
                        "tap",
                        "click"
                    ], this.handleClick_), this.on("keydown", this.handleKeyDown_));
                }, _proto.disable = function() {
                    this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), void 0 !== this.tabIndex_ && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off([
                        "tap",
                        "click"
                    ], this.handleClick_), this.off("keydown", this.handleKeyDown_);
                }, _proto.handleLanguagechange = function() {
                    this.controlText(this.controlText_);
                }, _proto.handleClick = function(event) {
                    this.options_.clickHandler && this.options_.clickHandler.call(this, arguments);
                }, _proto.handleKeyDown = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Space") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Enter") ? (event.preventDefault(), event.stopPropagation(), this.trigger("click")) : _Component.prototype.handleKeyDown.call(this, event);
                }, ClickableComponent;
            }(Component$1);
            Component$1.registerComponent("ClickableComponent", ClickableComponent);
            var PosterImage = function(_ClickableComponent) {
                function PosterImage(player, options) {
                    var _this;
                    return (_this = _ClickableComponent.call(this, player, options) || this).update(), _this.update_ = function(e) {
                        return _this.update(e);
                    }, player.on("posterchange", _this.update_), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(PosterImage, _ClickableComponent);
                var _proto = PosterImage.prototype;
                return _proto.dispose = function() {
                    this.player().off("posterchange", this.update_), _ClickableComponent.prototype.dispose.call(this);
                }, _proto.createEl = function() {
                    return createEl("div", {
                        className: "vjs-poster",
                        tabIndex: -1
                    });
                }, _proto.update = function(event) {
                    var url = this.player().poster();
                    this.setSrc(url), url ? this.show() : this.hide();
                }, _proto.setSrc = function(url) {
                    var backgroundImage = "";
                    url && (backgroundImage = 'url("' + url + '")'), this.el_.style.backgroundImage = backgroundImage;
                }, _proto.handleClick = function(event) {
                    if (this.player_.controls()) {
                        var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
                        this.player_.tech(!0) && !((IE_VERSION || IS_EDGE) && sourceIsEncrypted) && this.player_.tech(!0).focus(), this.player_.paused() ? silencePromise(this.player_.play()) : this.player_.pause();
                    }
                }, PosterImage;
            }(ClickableComponent);
            Component$1.registerComponent("PosterImage", PosterImage);
            var darkGray = "#222", lightGray = "#ccc", fontMap = {
                monospace: "monospace",
                sansSerif: "sans-serif",
                serif: "serif",
                monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
                monospaceSerif: '"Courier New", monospace',
                proportionalSansSerif: "sans-serif",
                proportionalSerif: "serif",
                casual: '"Comic Sans MS", Impact, fantasy',
                script: '"Monotype Corsiva", cursive',
                smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
            };
            function constructColor(color, opacity) {
                var hex;
                if (4 === color.length) hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
                else if (7 === color.length) hex = color.slice(1);
                else throw Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
                return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
            }
            function tryUpdateStyle(el, style, rule) {
                try {
                    el.style[style] = rule;
                } catch (e) {
                    return;
                }
            }
            var TextTrackDisplay = function(_Component) {
                function TextTrackDisplay(player, options, ready) {
                    _this = _Component.call(this, player, options, ready) || this;
                    var _this, updateDisplayHandler = function(e) {
                        return _this.updateDisplay(e);
                    };
                    return player.on("loadstart", function(e) {
                        return _this.toggleDisplay(e);
                    }), player.on("texttrackchange", updateDisplayHandler), player.on("loadedmetadata", function(e) {
                        return _this.preselectTrack(e);
                    }), player.ready(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), function() {
                        if (player.tech_ && player.tech_.featuresNativeTextTracks) {
                            this.hide();
                            return;
                        }
                        player.on("fullscreenchange", updateDisplayHandler), player.on("playerresize", updateDisplayHandler), global_window__WEBPACK_IMPORTED_MODULE_0___default().addEventListener("orientationchange", updateDisplayHandler), player.on("dispose", function() {
                            return global_window__WEBPACK_IMPORTED_MODULE_0___default().removeEventListener("orientationchange", updateDisplayHandler);
                        });
                        for(var tracks = this.options_.playerOptions.tracks || [], i = 0; i < tracks.length; i++)this.player_.addRemoteTextTrack(tracks[i], !0);
                        this.preselectTrack();
                    })), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TextTrackDisplay, _Component);
                var _proto = TextTrackDisplay.prototype;
                return _proto.preselectTrack = function() {
                    for(var firstDesc, firstCaptions, preferredTrack, modes = {
                        captions: 1,
                        subtitles: 1
                    }, trackList = this.player_.textTracks(), userPref = this.player_.cache_.selectedLanguage, i = 0; i < trackList.length; i++){
                        var track = trackList[i];
                        userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes ? track.kind === userPref.kind ? preferredTrack = track : preferredTrack || (preferredTrack = track) : userPref && !userPref.enabled ? (preferredTrack = null, firstDesc = null, firstCaptions = null) : track.default && ("descriptions" !== track.kind || firstDesc ? track.kind in modes && !firstCaptions && (firstCaptions = track) : firstDesc = track);
                    }
                    preferredTrack ? preferredTrack.mode = "showing" : firstCaptions ? firstCaptions.mode = "showing" : firstDesc && (firstDesc.mode = "showing");
                }, _proto.toggleDisplay = function() {
                    this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show();
                }, _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-text-track-display"
                    }, {
                        translate: "yes",
                        "aria-live": "off",
                        "aria-atomic": "true"
                    });
                }, _proto.clearDisplay = function() {
                    "function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT && global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT.processCues(global_window__WEBPACK_IMPORTED_MODULE_0___default(), [], this.el_);
                }, _proto.updateDisplay = function() {
                    var tracks = this.player_.textTracks(), allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
                    if (this.clearDisplay(), allowMultipleShowingTracks) {
                        for(var showingTracks = [], _i = 0; _i < tracks.length; ++_i){
                            var track = tracks[_i];
                            "showing" === track.mode && showingTracks.push(track);
                        }
                        this.updateForTrack(showingTracks);
                        return;
                    }
                    for(var descriptionsTrack = null, captionsSubtitlesTrack = null, i = tracks.length; i--;){
                        var _track = tracks[i];
                        "showing" === _track.mode && ("descriptions" === _track.kind ? descriptionsTrack = _track : captionsSubtitlesTrack = _track);
                    }
                    captionsSubtitlesTrack ? ("off" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "off"), this.updateForTrack(captionsSubtitlesTrack)) : descriptionsTrack && ("assertive" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "assertive"), this.updateForTrack(descriptionsTrack));
                }, _proto.updateDisplayState = function(track) {
                    for(var overrides = this.player_.textTrackSettings.getValues(), cues = track.activeCues, i = cues.length; i--;){
                        var cue = cues[i];
                        if (cue) {
                            var cueDiv = cue.displayState;
                            if (overrides.color && (cueDiv.firstChild.style.color = overrides.color), overrides.textOpacity && tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity)), overrides.backgroundColor && (cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor), overrides.backgroundOpacity && tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity)), overrides.windowColor && (overrides.windowOpacity ? tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity)) : cueDiv.style.backgroundColor = overrides.windowColor), overrides.edgeStyle && ("dropshadow" === overrides.edgeStyle ? cueDiv.firstChild.style.textShadow = "2px 2px 3px " + darkGray + ", 2px 2px 4px " + darkGray + ", 2px 2px 5px " + darkGray : "raised" === overrides.edgeStyle ? cueDiv.firstChild.style.textShadow = "1px 1px " + darkGray + ", 2px 2px " + darkGray + ", 3px 3px " + darkGray : "depressed" === overrides.edgeStyle ? cueDiv.firstChild.style.textShadow = "1px 1px " + lightGray + ", 0 1px " + lightGray + ", -1px -1px " + darkGray + ", 0 -1px " + darkGray : "uniform" === overrides.edgeStyle && (cueDiv.firstChild.style.textShadow = "0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray)), overrides.fontPercent && 1 !== overrides.fontPercent) {
                                var fontSize = global_window__WEBPACK_IMPORTED_MODULE_0___default().parseFloat(cueDiv.style.fontSize);
                                cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px", cueDiv.style.height = "auto", cueDiv.style.top = "auto";
                            }
                            overrides.fontFamily && "default" !== overrides.fontFamily && ("small-caps" === overrides.fontFamily ? cueDiv.firstChild.style.fontVariant = "small-caps" : cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily]);
                        }
                    }
                }, _proto.updateForTrack = function(tracks) {
                    if (Array.isArray(tracks) || (tracks = [
                        tracks
                    ]), !("function" != typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT || tracks.every(function(track) {
                        return !track.activeCues;
                    }))) {
                        for(var cues = [], i = 0; i < tracks.length; ++i)for(var track = tracks[i], j = 0; j < track.activeCues.length; ++j)cues.push(track.activeCues[j]);
                        global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT.processCues(global_window__WEBPACK_IMPORTED_MODULE_0___default(), cues, this.el_);
                        for(var _i2 = 0; _i2 < tracks.length; ++_i2){
                            for(var _track2 = tracks[_i2], _j = 0; _j < _track2.activeCues.length; ++_j){
                                var cueEl = _track2.activeCues[_j].displayState;
                                addClass(cueEl, "vjs-text-track-cue"), addClass(cueEl, "vjs-text-track-cue-" + (_track2.language ? _track2.language : _i2)), _track2.language && setAttribute(cueEl, "lang", _track2.language);
                            }
                            this.player_.textTrackSettings && this.updateDisplayState(_track2);
                        }
                    }
                }, TextTrackDisplay;
            }(Component$1);
            Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
            var LoadingSpinner = function(_Component) {
                function LoadingSpinner() {
                    return _Component.apply(this, arguments) || this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(LoadingSpinner, _Component), LoadingSpinner.prototype.createEl = function() {
                    var isAudio = this.player_.isAudio(), playerType = this.localize(isAudio ? "Audio Player" : "Video Player"), controlText = createEl("span", {
                        className: "vjs-control-text",
                        textContent: this.localize("{1} is loading.", [
                            playerType
                        ])
                    }), el = _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-loading-spinner",
                        dir: "ltr"
                    });
                    return el.appendChild(controlText), el;
                }, LoadingSpinner;
            }(Component$1);
            Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
            var Button = function(_ClickableComponent) {
                function Button() {
                    return _ClickableComponent.apply(this, arguments) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Button, _ClickableComponent);
                var _proto = Button.prototype;
                return _proto.createEl = function(tag, props, attributes) {
                    void 0 === props && (props = {}), void 0 === attributes && (attributes = {});
                    var el = createEl("button", props = assign({
                        className: this.buildCSSClass()
                    }, props), attributes = assign({
                        type: "button"
                    }, attributes));
                    return el.appendChild(createEl("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), this.createControlTextEl(el), el;
                }, _proto.addChild = function(child, options) {
                    void 0 === options && (options = {});
                    var className = this.constructor.name;
                    return log$1.warn("Adding an actionable (user controllable) child to a Button (" + className + ") is not supported; use a ClickableComponent instead."), Component$1.prototype.addChild.call(this, child, options);
                }, _proto.enable = function() {
                    _ClickableComponent.prototype.enable.call(this), this.el_.removeAttribute("disabled");
                }, _proto.disable = function() {
                    _ClickableComponent.prototype.disable.call(this), this.el_.setAttribute("disabled", "disabled");
                }, _proto.handleKeyDown = function(event) {
                    if (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Space") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Enter")) {
                        event.stopPropagation();
                        return;
                    }
                    _ClickableComponent.prototype.handleKeyDown.call(this, event);
                }, Button;
            }(ClickableComponent);
            Component$1.registerComponent("Button", Button);
            var BigPlayButton = function(_Button) {
                function BigPlayButton(player, options) {
                    var _this;
                    return (_this = _Button.call(this, player, options) || this).mouseused_ = !1, _this.on("mousedown", function(e) {
                        return _this.handleMouseDown(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(BigPlayButton, _Button);
                var _proto = BigPlayButton.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-big-play-button";
                }, _proto.handleClick = function(event) {
                    var playPromise = this.player_.play();
                    if (this.mouseused_ && event.clientX && event.clientY) {
                        var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
                        silencePromise(playPromise), this.player_.tech(!0) && !((IE_VERSION || IS_EDGE) && sourceIsEncrypted) && this.player_.tech(!0).focus();
                        return;
                    }
                    var cb = this.player_.getChild("controlBar"), playToggle = cb && cb.getChild("playToggle");
                    if (!playToggle) {
                        this.player_.tech(!0).focus();
                        return;
                    }
                    var playFocus = function() {
                        return playToggle.focus();
                    };
                    isPromise(playPromise) ? playPromise.then(playFocus, function() {}) : this.setTimeout(playFocus, 1);
                }, _proto.handleKeyDown = function(event) {
                    this.mouseused_ = !1, _Button.prototype.handleKeyDown.call(this, event);
                }, _proto.handleMouseDown = function(event) {
                    this.mouseused_ = !0;
                }, BigPlayButton;
            }(Button);
            BigPlayButton.prototype.controlText_ = "Play Video", Component$1.registerComponent("BigPlayButton", BigPlayButton);
            var CloseButton = function(_Button) {
                function CloseButton(player, options) {
                    var _this;
                    return (_this = _Button.call(this, player, options) || this).controlText(options && options.controlText || _this.localize("Close")), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(CloseButton, _Button);
                var _proto = CloseButton.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-close-button " + _Button.prototype.buildCSSClass.call(this);
                }, _proto.handleClick = function(event) {
                    this.trigger({
                        type: "close",
                        bubbles: !1
                    });
                }, _proto.handleKeyDown = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Esc") ? (event.preventDefault(), event.stopPropagation(), this.trigger("click")) : _Button.prototype.handleKeyDown.call(this, event);
                }, CloseButton;
            }(Button);
            Component$1.registerComponent("CloseButton", CloseButton);
            var PlayToggle = function(_Button) {
                function PlayToggle(player, options) {
                    var _this;
                    return void 0 === options && (options = {}), _this = _Button.call(this, player, options) || this, options.replay = void 0 === options.replay || options.replay, _this.on(player, "play", function(e) {
                        return _this.handlePlay(e);
                    }), _this.on(player, "pause", function(e) {
                        return _this.handlePause(e);
                    }), options.replay && _this.on(player, "ended", function(e) {
                        return _this.handleEnded(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(PlayToggle, _Button);
                var _proto = PlayToggle.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-play-control " + _Button.prototype.buildCSSClass.call(this);
                }, _proto.handleClick = function(event) {
                    this.player_.paused() ? silencePromise(this.player_.play()) : this.player_.pause();
                }, _proto.handleSeeked = function(event) {
                    this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(event) : this.handlePlay(event);
                }, _proto.handlePlay = function(event) {
                    this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.controlText("Pause");
                }, _proto.handlePause = function(event) {
                    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.controlText("Play");
                }, _proto.handleEnded = function(event) {
                    var _this2 = this;
                    this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.controlText("Replay"), this.one(this.player_, "seeked", function(e) {
                        return _this2.handleSeeked(e);
                    });
                }, PlayToggle;
            }(Button);
            PlayToggle.prototype.controlText_ = "Play", Component$1.registerComponent("PlayToggle", PlayToggle);
            var defaultImplementation = function(seconds, guide) {
                var s = Math.floor((seconds = seconds < 0 ? 0 : seconds) % 60), m = Math.floor(seconds / 60 % 60), h = Math.floor(seconds / 3600);
                return (isNaN(seconds) || seconds === 1 / 0) && (h = m = s = "-"), m = (((h = h > 0 || Math.floor(guide / 3600) > 0 ? h + ":" : "") || Math.floor(guide / 60 % 60) >= 10) && m < 10 ? "0" + m : m) + ":", h + m + (s = s < 10 ? "0" + s : s);
            }, implementation = defaultImplementation;
            function formatTime(seconds, guide) {
                return void 0 === guide && (guide = seconds), implementation(seconds, guide);
            }
            var TimeDisplay = function(_Component) {
                function TimeDisplay(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).on(player, [
                        "timeupdate",
                        "ended"
                    ], function(e) {
                        return _this.updateContent(e);
                    }), _this.updateTextNode_(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TimeDisplay, _Component);
                var _proto = TimeDisplay.prototype;
                return _proto.createEl = function() {
                    var className = this.buildCSSClass(), el = _Component.prototype.createEl.call(this, "div", {
                        className: className + " vjs-time-control vjs-control"
                    }), span = createEl("span", {
                        className: "vjs-control-text",
                        textContent: this.localize(this.labelText_) + "\xA0"
                    }, {
                        role: "presentation"
                    });
                    return el.appendChild(span), this.contentEl_ = createEl("span", {
                        className: className + "-display"
                    }, {
                        "aria-live": "off",
                        role: "presentation"
                    }), el.appendChild(this.contentEl_), el;
                }, _proto.dispose = function() {
                    this.contentEl_ = null, this.textNode_ = null, _Component.prototype.dispose.call(this);
                }, _proto.updateTextNode_ = function(time) {
                    var _this2 = this;
                    void 0 === time && (time = 0), time = formatTime(time), this.formattedTime_ !== time && (this.formattedTime_ = time, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", function() {
                        if (_this2.contentEl_) {
                            var oldNode = _this2.textNode_;
                            oldNode && _this2.contentEl_.firstChild !== oldNode && (oldNode = null, log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.")), _this2.textNode_ = global_document__WEBPACK_IMPORTED_MODULE_1___default().createTextNode(_this2.formattedTime_), _this2.textNode_ && (oldNode ? _this2.contentEl_.replaceChild(_this2.textNode_, oldNode) : _this2.contentEl_.appendChild(_this2.textNode_));
                        }
                    }));
                }, _proto.updateContent = function(event) {}, TimeDisplay;
            }(Component$1);
            TimeDisplay.prototype.labelText_ = "Time", TimeDisplay.prototype.controlText_ = "Time", Component$1.registerComponent("TimeDisplay", TimeDisplay);
            var CurrentTimeDisplay = function(_TimeDisplay) {
                function CurrentTimeDisplay() {
                    return _TimeDisplay.apply(this, arguments) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(CurrentTimeDisplay, _TimeDisplay);
                var _proto = CurrentTimeDisplay.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-current-time";
                }, _proto.updateContent = function(event) {
                    var time;
                    time = this.player_.ended() ? this.player_.duration() : this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(time);
                }, CurrentTimeDisplay;
            }(TimeDisplay);
            CurrentTimeDisplay.prototype.labelText_ = "Current Time", CurrentTimeDisplay.prototype.controlText_ = "Current Time", Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
            var DurationDisplay = function(_TimeDisplay) {
                function DurationDisplay(player, options) {
                    _this = _TimeDisplay.call(this, player, options) || this;
                    var _this, updateContent = function(e) {
                        return _this.updateContent(e);
                    };
                    return _this.on(player, "durationchange", updateContent), _this.on(player, "loadstart", updateContent), _this.on(player, "loadedmetadata", updateContent), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(DurationDisplay, _TimeDisplay);
                var _proto = DurationDisplay.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-duration";
                }, _proto.updateContent = function(event) {
                    var duration = this.player_.duration();
                    this.updateTextNode_(duration);
                }, DurationDisplay;
            }(TimeDisplay);
            DurationDisplay.prototype.labelText_ = "Duration", DurationDisplay.prototype.controlText_ = "Duration", Component$1.registerComponent("DurationDisplay", DurationDisplay);
            var TimeDivider = function(_Component) {
                function TimeDivider() {
                    return _Component.apply(this, arguments) || this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TimeDivider, _Component), TimeDivider.prototype.createEl = function() {
                    var el = _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-time-control vjs-time-divider"
                    }, {
                        "aria-hidden": !0
                    }), div = _Component.prototype.createEl.call(this, "div"), span = _Component.prototype.createEl.call(this, "span", {
                        textContent: "/"
                    });
                    return div.appendChild(span), el.appendChild(div), el;
                }, TimeDivider;
            }(Component$1);
            Component$1.registerComponent("TimeDivider", TimeDivider);
            var RemainingTimeDisplay = function(_TimeDisplay) {
                function RemainingTimeDisplay(player, options) {
                    var _this;
                    return (_this = _TimeDisplay.call(this, player, options) || this).on(player, "durationchange", function(e) {
                        return _this.updateContent(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(RemainingTimeDisplay, _TimeDisplay);
                var _proto = RemainingTimeDisplay.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-remaining-time";
                }, _proto.createEl = function() {
                    var el = _TimeDisplay.prototype.createEl.call(this);
                    return el.insertBefore(createEl("span", {}, {
                        "aria-hidden": !0
                    }, "-"), this.contentEl_), el;
                }, _proto.updateContent = function(event) {
                    var time;
                    "number" == typeof this.player_.duration() && (time = this.player_.ended() ? 0 : this.player_.remainingTimeDisplay ? this.player_.remainingTimeDisplay() : this.player_.remainingTime(), this.updateTextNode_(time));
                }, RemainingTimeDisplay;
            }(TimeDisplay);
            RemainingTimeDisplay.prototype.labelText_ = "Remaining Time", RemainingTimeDisplay.prototype.controlText_ = "Remaining Time", Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
            var LiveDisplay = function(_Component) {
                function LiveDisplay(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).updateShowing(), _this.on(_this.player(), "durationchange", function(e) {
                        return _this.updateShowing(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(LiveDisplay, _Component);
                var _proto = LiveDisplay.prototype;
                return _proto.createEl = function() {
                    var el = _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-live-control vjs-control"
                    });
                    return this.contentEl_ = createEl("div", {
                        className: "vjs-live-display"
                    }, {
                        "aria-live": "off"
                    }), this.contentEl_.appendChild(createEl("span", {
                        className: "vjs-control-text",
                        textContent: this.localize("Stream Type") + "\xA0"
                    })), this.contentEl_.appendChild(global_document__WEBPACK_IMPORTED_MODULE_1___default().createTextNode(this.localize("LIVE"))), el.appendChild(this.contentEl_), el;
                }, _proto.dispose = function() {
                    this.contentEl_ = null, _Component.prototype.dispose.call(this);
                }, _proto.updateShowing = function(event) {
                    this.player().duration() === 1 / 0 ? this.show() : this.hide();
                }, LiveDisplay;
            }(Component$1);
            Component$1.registerComponent("LiveDisplay", LiveDisplay);
            var SeekToLive = function(_Button) {
                function SeekToLive(player, options) {
                    var _this;
                    return (_this = _Button.call(this, player, options) || this).updateLiveEdgeStatus(), _this.player_.liveTracker && (_this.updateLiveEdgeStatusHandler_ = function(e) {
                        return _this.updateLiveEdgeStatus(e);
                    }, _this.on(_this.player_.liveTracker, "liveedgechange", _this.updateLiveEdgeStatusHandler_)), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SeekToLive, _Button);
                var _proto = SeekToLive.prototype;
                return _proto.createEl = function() {
                    var el = _Button.prototype.createEl.call(this, "button", {
                        className: "vjs-seek-to-live-control vjs-control"
                    });
                    return this.textEl_ = createEl("span", {
                        className: "vjs-seek-to-live-text",
                        textContent: this.localize("LIVE")
                    }, {
                        "aria-hidden": "true"
                    }), el.appendChild(this.textEl_), el;
                }, _proto.updateLiveEdgeStatus = function() {
                    !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live"));
                }, _proto.handleClick = function() {
                    this.player_.liveTracker.seekToLiveEdge();
                }, _proto.dispose = function() {
                    this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_), this.textEl_ = null, _Button.prototype.dispose.call(this);
                }, SeekToLive;
            }(Button);
            SeekToLive.prototype.controlText_ = "Seek to live, currently playing live", Component$1.registerComponent("SeekToLive", SeekToLive);
            var clamp = function(number, min, max) {
                return Math.min(max, Math.max(min, isNaN(number = Number(number)) ? min : number));
            }, Slider = function(_Component) {
                function Slider(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).handleMouseDown_ = function(e) {
                        return _this.handleMouseDown(e);
                    }, _this.handleMouseUp_ = function(e) {
                        return _this.handleMouseUp(e);
                    }, _this.handleKeyDown_ = function(e) {
                        return _this.handleKeyDown(e);
                    }, _this.handleClick_ = function(e) {
                        return _this.handleClick(e);
                    }, _this.handleMouseMove_ = function(e) {
                        return _this.handleMouseMove(e);
                    }, _this.update_ = function(e) {
                        return _this.update(e);
                    }, _this.bar = _this.getChild(_this.options_.barName), _this.vertical(!!_this.options_.vertical), _this.enable(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Slider, _Component);
                var _proto = Slider.prototype;
                return _proto.enabled = function() {
                    return this.enabled_;
                }, _proto.enable = function() {
                    this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0);
                }, _proto.disable = function() {
                    if (this.enabled()) {
                        var doc = this.bar.el_.ownerDocument;
                        this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(doc, "mousemove", this.handleMouseMove_), this.off(doc, "mouseup", this.handleMouseUp_), this.off(doc, "touchmove", this.handleMouseMove_), this.off(doc, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1;
                    }
                }, _proto.createEl = function(type, props, attributes) {
                    return void 0 === props && (props = {}), void 0 === attributes && (attributes = {}), props.className = props.className + " vjs-slider", props = assign({
                        tabIndex: 0
                    }, props), attributes = assign({
                        role: "slider",
                        "aria-valuenow": 0,
                        "aria-valuemin": 0,
                        "aria-valuemax": 100,
                        tabIndex: 0
                    }, attributes), _Component.prototype.createEl.call(this, type, props, attributes);
                }, _proto.handleMouseDown = function(event) {
                    var doc = this.bar.el_.ownerDocument;
                    "mousedown" === event.type && event.preventDefault(), "touchstart" !== event.type || IS_CHROME || event.preventDefault(), blockTextSelection(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(doc, "mousemove", this.handleMouseMove_), this.on(doc, "mouseup", this.handleMouseUp_), this.on(doc, "touchmove", this.handleMouseMove_), this.on(doc, "touchend", this.handleMouseUp_), this.handleMouseMove(event);
                }, _proto.handleMouseMove = function(event) {}, _proto.handleMouseUp = function() {
                    var doc = this.bar.el_.ownerDocument;
                    unblockTextSelection(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(doc, "mousemove", this.handleMouseMove_), this.off(doc, "mouseup", this.handleMouseUp_), this.off(doc, "touchmove", this.handleMouseMove_), this.off(doc, "touchend", this.handleMouseUp_), this.update();
                }, _proto.update = function() {
                    var _this2 = this;
                    if (this.el_ && this.bar) {
                        var progress = this.getProgress();
                        return progress === this.progress_ || (this.progress_ = progress, this.requestNamedAnimationFrame("Slider#update", function() {
                            var sizeKey = _this2.vertical() ? "height" : "width";
                            _this2.bar.el().style[sizeKey] = (100 * progress).toFixed(2) + "%";
                        })), progress;
                    }
                }, _proto.getProgress = function() {
                    return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
                }, _proto.calculateDistance = function(event) {
                    var position = getPointerPosition(this.el_, event);
                    return this.vertical() ? position.y : position.x;
                }, _proto.handleKeyDown = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Left") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Down") ? (event.preventDefault(), event.stopPropagation(), this.stepBack()) : keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Right") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Up") ? (event.preventDefault(), event.stopPropagation(), this.stepForward()) : _Component.prototype.handleKeyDown.call(this, event);
                }, _proto.handleClick = function(event) {
                    event.stopPropagation(), event.preventDefault();
                }, _proto.vertical = function(bool) {
                    if (void 0 === bool) return this.vertical_ || !1;
                    this.vertical_ = !!bool, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal");
                }, Slider;
            }(Component$1);
            Component$1.registerComponent("Slider", Slider);
            var percentify = function(time, end) {
                return clamp(time / end * 100, 0, 100).toFixed(2) + "%";
            }, LoadProgressBar = function(_Component) {
                function LoadProgressBar(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).partEls_ = [], _this.on(player, "progress", function(e) {
                        return _this.update(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(LoadProgressBar, _Component);
                var _proto = LoadProgressBar.prototype;
                return _proto.createEl = function() {
                    var el = _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-load-progress"
                    }), wrapper = createEl("span", {
                        className: "vjs-control-text"
                    }), loadedText = createEl("span", {
                        textContent: this.localize("Loaded")
                    }), separator = global_document__WEBPACK_IMPORTED_MODULE_1___default().createTextNode(": ");
                    return this.percentageEl_ = createEl("span", {
                        className: "vjs-control-text-loaded-percentage",
                        textContent: "0%"
                    }), el.appendChild(wrapper), wrapper.appendChild(loadedText), wrapper.appendChild(separator), wrapper.appendChild(this.percentageEl_), el;
                }, _proto.dispose = function() {
                    this.partEls_ = null, this.percentageEl_ = null, _Component.prototype.dispose.call(this);
                }, _proto.update = function(event) {
                    var _this2 = this;
                    this.requestNamedAnimationFrame("LoadProgressBar#update", function() {
                        var liveTracker = _this2.player_.liveTracker, buffered = _this2.player_.buffered(), duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration(), bufferedEnd = _this2.player_.bufferedEnd(), children = _this2.partEls_, percent = percentify(bufferedEnd, duration);
                        _this2.percent_ !== percent && (_this2.el_.style.width = percent, textContent(_this2.percentageEl_, percent), _this2.percent_ = percent);
                        for(var i = 0; i < buffered.length; i++){
                            var start = buffered.start(i), end = buffered.end(i), part = children[i];
                            part || (part = _this2.el_.appendChild(createEl()), children[i] = part), (part.dataset.start !== start || part.dataset.end !== end) && (part.dataset.start = start, part.dataset.end = end, part.style.left = percentify(start, bufferedEnd), part.style.width = percentify(end - start, bufferedEnd));
                        }
                        for(var _i = children.length; _i > buffered.length; _i--)_this2.el_.removeChild(children[_i - 1]);
                        children.length = buffered.length;
                    });
                }, LoadProgressBar;
            }(Component$1);
            Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
            var TimeTooltip = function(_Component) {
                function TimeTooltip(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).update = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.update), 30), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TimeTooltip, _Component);
                var _proto = TimeTooltip.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-time-tooltip"
                    }, {
                        "aria-hidden": "true"
                    });
                }, _proto.update = function(seekBarRect, seekBarPoint, content) {
                    var tooltipRect = findPosition(this.el_), playerRect = getBoundingClientRect(this.player_.el()), seekBarPointPx = seekBarRect.width * seekBarPoint;
                    if (playerRect && tooltipRect) {
                        var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx, spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right), pullTooltipBy = tooltipRect.width / 2;
                        spaceLeftOfPoint < pullTooltipBy ? pullTooltipBy += pullTooltipBy - spaceLeftOfPoint : spaceRightOfPoint < pullTooltipBy && (pullTooltipBy = spaceRightOfPoint), pullTooltipBy < 0 ? pullTooltipBy = 0 : pullTooltipBy > tooltipRect.width && (pullTooltipBy = tooltipRect.width), pullTooltipBy = Math.round(pullTooltipBy), this.el_.style.right = "-" + pullTooltipBy + "px", this.write(content);
                    }
                }, _proto.write = function(content) {
                    textContent(this.el_, content);
                }, _proto.updateTime = function(seekBarRect, seekBarPoint, time, cb) {
                    var _this2 = this;
                    this.requestNamedAnimationFrame("TimeTooltip#updateTime", function() {
                        var content, duration = _this2.player_.duration();
                        if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {
                            var liveWindow = _this2.player_.liveTracker.liveWindow(), secondsBehind = liveWindow - seekBarPoint * liveWindow;
                            content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
                        } else content = formatTime(time, duration);
                        _this2.update(seekBarRect, seekBarPoint, content), cb && cb();
                    });
                }, TimeTooltip;
            }(Component$1);
            Component$1.registerComponent("TimeTooltip", TimeTooltip);
            var PlayProgressBar = function(_Component) {
                function PlayProgressBar(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).update = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.update), 30), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(PlayProgressBar, _Component);
                var _proto = PlayProgressBar.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-play-progress vjs-slider-bar"
                    }, {
                        "aria-hidden": "true"
                    });
                }, _proto.update = function(seekBarRect, seekBarPoint) {
                    var timeTooltip = this.getChild("timeTooltip");
                    if (timeTooltip) {
                        var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                        timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
                    }
                }, PlayProgressBar;
            }(Component$1);
            PlayProgressBar.prototype.options_ = {
                children: []
            }, IS_IOS || IS_ANDROID || PlayProgressBar.prototype.options_.children.push("timeTooltip"), Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
            var MouseTimeDisplay = function(_Component) {
                function MouseTimeDisplay(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).update = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.update), 30), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(MouseTimeDisplay, _Component);
                var _proto = MouseTimeDisplay.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-mouse-display"
                    });
                }, _proto.update = function(seekBarRect, seekBarPoint) {
                    var _this2 = this, time = seekBarPoint * this.player_.duration();
                    this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, function() {
                        _this2.el_.style.left = seekBarRect.width * seekBarPoint + "px";
                    });
                }, MouseTimeDisplay;
            }(Component$1);
            MouseTimeDisplay.prototype.options_ = {
                children: [
                    "timeTooltip"
                ]
            }, Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
            var SeekBar = function(_Slider) {
                function SeekBar(player, options) {
                    var _this;
                    return (_this = _Slider.call(this, player, options) || this).setEventHandlers_(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SeekBar, _Slider);
                var _proto = SeekBar.prototype;
                return _proto.setEventHandlers_ = function() {
                    var _this2 = this;
                    this.update_ = bind(this, this.update), this.update = throttle(this.update_, 30), this.on(this.player_, [
                        "ended",
                        "durationchange",
                        "timeupdate"
                    ], this.update), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = function(e) {
                        return _this2.enableInterval_(e);
                    }, this.disableIntervalHandler_ = function(e) {
                        return _this2.disableInterval_(e);
                    }, this.on(this.player_, [
                        "playing"
                    ], this.enableIntervalHandler_), this.on(this.player_, [
                        "ended",
                        "pause",
                        "waiting"
                    ], this.disableIntervalHandler_), "hidden" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && "visibilityState" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && this.on(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "visibilitychange", this.toggleVisibility_);
                }, _proto.toggleVisibility_ = function(e) {
                    "hidden" === global_document__WEBPACK_IMPORTED_MODULE_1___default().visibilityState ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(e)) : (this.player_.ended() || this.player_.paused() || this.enableInterval_(), this.update());
                }, _proto.enableInterval_ = function() {
                    this.updateInterval || (this.updateInterval = this.setInterval(this.update, 30));
                }, _proto.disableInterval_ = function(e) {
                    this.player_.liveTracker && this.player_.liveTracker.isLive() && e && "ended" !== e.type || !this.updateInterval || (this.clearInterval(this.updateInterval), this.updateInterval = null);
                }, _proto.createEl = function() {
                    return _Slider.prototype.createEl.call(this, "div", {
                        className: "vjs-progress-holder"
                    }, {
                        "aria-label": this.localize("Progress Bar")
                    });
                }, _proto.update = function(event) {
                    var _this3 = this;
                    if ("hidden" !== global_document__WEBPACK_IMPORTED_MODULE_1___default().visibilityState) {
                        var percent = _Slider.prototype.update.call(this);
                        return this.requestNamedAnimationFrame("SeekBar#update", function() {
                            var currentTime = _this3.player_.ended() ? _this3.player_.duration() : _this3.getCurrentTime_(), liveTracker = _this3.player_.liveTracker, duration = _this3.player_.duration();
                            liveTracker && liveTracker.isLive() && (duration = _this3.player_.liveTracker.liveCurrentTime()), _this3.percent_ !== percent && (_this3.el_.setAttribute("aria-valuenow", (100 * percent).toFixed(2)), _this3.percent_ = percent), (_this3.currentTime_ !== currentTime || _this3.duration_ !== duration) && (_this3.el_.setAttribute("aria-valuetext", _this3.localize("progress bar timing: currentTime={1} duration={2}", [
                                formatTime(currentTime, duration),
                                formatTime(duration, duration)
                            ], "{1} of {2}")), _this3.currentTime_ = currentTime, _this3.duration_ = duration), _this3.bar && _this3.bar.update(getBoundingClientRect(_this3.el()), _this3.getProgress());
                        }), percent;
                    }
                }, _proto.userSeek_ = function(ct) {
                    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(ct);
                }, _proto.getCurrentTime_ = function() {
                    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                }, _proto.getPercent = function() {
                    var percent, currentTime = this.getCurrentTime_(), liveTracker = this.player_.liveTracker;
                    return liveTracker && liveTracker.isLive() ? (percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow(), liveTracker.atLiveEdge() && (percent = 1)) : percent = currentTime / this.player_.duration(), percent;
                }, _proto.handleMouseDown = function(event) {
                    isSingleLeftClick(event) && (event.stopPropagation(), this.player_.scrubbing(!0), this.videoWasPlaying = !this.player_.paused(), this.player_.pause(), _Slider.prototype.handleMouseDown.call(this, event));
                }, _proto.handleMouseMove = function(event) {
                    if (isSingleLeftClick(event)) {
                        var newTime, distance = this.calculateDistance(event), liveTracker = this.player_.liveTracker;
                        if (liveTracker && liveTracker.isLive()) {
                            if (distance >= 0.99) {
                                liveTracker.seekToLiveEdge();
                                return;
                            }
                            var seekableStart = liveTracker.seekableStart(), seekableEnd = liveTracker.liveCurrentTime();
                            if ((newTime = seekableStart + distance * liveTracker.liveWindow()) >= seekableEnd && (newTime = seekableEnd), newTime <= seekableStart && (newTime = seekableStart + 0.1), newTime === 1 / 0) return;
                        } else (newTime = distance * this.player_.duration()) === this.player_.duration() && (newTime -= 0.1);
                        this.userSeek_(newTime);
                    }
                }, _proto.enable = function() {
                    _Slider.prototype.enable.call(this);
                    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
                    mouseTimeDisplay && mouseTimeDisplay.show();
                }, _proto.disable = function() {
                    _Slider.prototype.disable.call(this);
                    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
                    mouseTimeDisplay && mouseTimeDisplay.hide();
                }, _proto.handleMouseUp = function(event) {
                    _Slider.prototype.handleMouseUp.call(this, event), event && event.stopPropagation(), this.player_.scrubbing(!1), this.player_.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    }), this.videoWasPlaying ? silencePromise(this.player_.play()) : this.update_();
                }, _proto.stepForward = function() {
                    this.userSeek_(this.player_.currentTime() + 5);
                }, _proto.stepBack = function() {
                    this.userSeek_(this.player_.currentTime() - 5);
                }, _proto.handleAction = function(event) {
                    this.player_.paused() ? this.player_.play() : this.player_.pause();
                }, _proto.handleKeyDown = function(event) {
                    var liveTracker = this.player_.liveTracker;
                    if (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Space") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Enter")) event.preventDefault(), event.stopPropagation(), this.handleAction(event);
                    else if (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Home")) event.preventDefault(), event.stopPropagation(), this.userSeek_(0);
                    else if (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "End")) event.preventDefault(), event.stopPropagation(), liveTracker && liveTracker.isLive() ? this.userSeek_(liveTracker.liveCurrentTime()) : this.userSeek_(this.player_.duration());
                    else if (/^[0-9]$/.test(keycode__WEBPACK_IMPORTED_MODULE_3___default()(event))) {
                        event.preventDefault(), event.stopPropagation();
                        var gotoFraction = (keycode__WEBPACK_IMPORTED_MODULE_3___default().codes[keycode__WEBPACK_IMPORTED_MODULE_3___default()(event)] - keycode__WEBPACK_IMPORTED_MODULE_3___default().codes[0]) * 10.0 / 100.0;
                        liveTracker && liveTracker.isLive() ? this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction) : this.userSeek_(this.player_.duration() * gotoFraction);
                    } else keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "PgDn") ? (event.preventDefault(), event.stopPropagation(), this.userSeek_(this.player_.currentTime() - 60)) : keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "PgUp") ? (event.preventDefault(), event.stopPropagation(), this.userSeek_(this.player_.currentTime() + 60)) : _Slider.prototype.handleKeyDown.call(this, event);
                }, _proto.dispose = function() {
                    this.disableInterval_(), this.off(this.player_, [
                        "ended",
                        "durationchange",
                        "timeupdate"
                    ], this.update), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, [
                        "playing"
                    ], this.enableIntervalHandler_), this.off(this.player_, [
                        "ended",
                        "pause",
                        "waiting"
                    ], this.disableIntervalHandler_), "hidden" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && "visibilityState" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && this.off(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "visibilitychange", this.toggleVisibility_), _Slider.prototype.dispose.call(this);
                }, SeekBar;
            }(Slider);
            SeekBar.prototype.options_ = {
                children: [
                    "loadProgressBar",
                    "playProgressBar"
                ],
                barName: "playProgressBar"
            }, IS_IOS || IS_ANDROID || SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay"), Component$1.registerComponent("SeekBar", SeekBar);
            var ProgressControl = function(_Component) {
                function ProgressControl(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).handleMouseMove = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.handleMouseMove), 30), _this.throttledHandleMouseSeek = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.handleMouseSeek), 30), _this.handleMouseUpHandler_ = function(e) {
                        return _this.handleMouseUp(e);
                    }, _this.handleMouseDownHandler_ = function(e) {
                        return _this.handleMouseDown(e);
                    }, _this.enable(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ProgressControl, _Component);
                var _proto = ProgressControl.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-progress-control vjs-control"
                    });
                }, _proto.handleMouseMove = function(event) {
                    var seekBar = this.getChild("seekBar");
                    if (seekBar) {
                        var playProgressBar = seekBar.getChild("playProgressBar"), mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
                        if (playProgressBar || mouseTimeDisplay) {
                            var seekBarEl = seekBar.el(), seekBarRect = findPosition(seekBarEl), seekBarPoint = getPointerPosition(seekBarEl, event).x;
                            seekBarPoint = clamp(seekBarPoint, 0, 1), mouseTimeDisplay && mouseTimeDisplay.update(seekBarRect, seekBarPoint), playProgressBar && playProgressBar.update(seekBarRect, seekBar.getProgress());
                        }
                    }
                }, _proto.handleMouseSeek = function(event) {
                    var seekBar = this.getChild("seekBar");
                    seekBar && seekBar.handleMouseMove(event);
                }, _proto.enabled = function() {
                    return this.enabled_;
                }, _proto.disable = function() {
                    if (this.children().forEach(function(child) {
                        return child.disable && child.disable();
                    }), this.enabled() && (this.off([
                        "mousedown",
                        "touchstart"
                    ], this.handleMouseDownHandler_), this.off(this.el_, "mousemove", this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing())) {
                        var seekBar = this.getChild("seekBar");
                        this.player_.scrubbing(!1), seekBar.videoWasPlaying && silencePromise(this.player_.play());
                    }
                }, _proto.enable = function() {
                    this.children().forEach(function(child) {
                        return child.enable && child.enable();
                    }), this.enabled() || (this.on([
                        "mousedown",
                        "touchstart"
                    ], this.handleMouseDownHandler_), this.on(this.el_, "mousemove", this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0);
                }, _proto.removeListenersAddedOnMousedownAndTouchstart = function() {
                    var doc = this.el_.ownerDocument;
                    this.off(doc, "mousemove", this.throttledHandleMouseSeek), this.off(doc, "touchmove", this.throttledHandleMouseSeek), this.off(doc, "mouseup", this.handleMouseUpHandler_), this.off(doc, "touchend", this.handleMouseUpHandler_);
                }, _proto.handleMouseDown = function(event) {
                    var doc = this.el_.ownerDocument, seekBar = this.getChild("seekBar");
                    seekBar && seekBar.handleMouseDown(event), this.on(doc, "mousemove", this.throttledHandleMouseSeek), this.on(doc, "touchmove", this.throttledHandleMouseSeek), this.on(doc, "mouseup", this.handleMouseUpHandler_), this.on(doc, "touchend", this.handleMouseUpHandler_);
                }, _proto.handleMouseUp = function(event) {
                    var seekBar = this.getChild("seekBar");
                    seekBar && seekBar.handleMouseUp(event), this.removeListenersAddedOnMousedownAndTouchstart();
                }, ProgressControl;
            }(Component$1);
            ProgressControl.prototype.options_ = {
                children: [
                    "seekBar"
                ]
            }, Component$1.registerComponent("ProgressControl", ProgressControl);
            var PictureInPictureToggle = function(_Button) {
                function PictureInPictureToggle(player, options) {
                    var _this;
                    return (_this = _Button.call(this, player, options) || this).on(player, [
                        "enterpictureinpicture",
                        "leavepictureinpicture"
                    ], function(e) {
                        return _this.handlePictureInPictureChange(e);
                    }), _this.on(player, [
                        "disablepictureinpicturechanged",
                        "loadedmetadata"
                    ], function(e) {
                        return _this.handlePictureInPictureEnabledChange(e);
                    }), _this.disable(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(PictureInPictureToggle, _Button);
                var _proto = PictureInPictureToggle.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-picture-in-picture-control " + _Button.prototype.buildCSSClass.call(this);
                }, _proto.handlePictureInPictureEnabledChange = function() {
                    global_document__WEBPACK_IMPORTED_MODULE_1___default().pictureInPictureEnabled && !1 === this.player_.disablePictureInPicture() ? this.enable() : this.disable();
                }, _proto.handlePictureInPictureChange = function(event) {
                    this.player_.isInPictureInPicture() ? this.controlText("Exit Picture-in-Picture") : this.controlText("Picture-in-Picture"), this.handlePictureInPictureEnabledChange();
                }, _proto.handleClick = function(event) {
                    this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture();
                }, PictureInPictureToggle;
            }(Button);
            PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture", Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
            var FullscreenToggle = function(_Button) {
                function FullscreenToggle(player, options) {
                    var _this;
                    return (_this = _Button.call(this, player, options) || this).on(player, "fullscreenchange", function(e) {
                        return _this.handleFullscreenChange(e);
                    }), !1 === global_document__WEBPACK_IMPORTED_MODULE_1___default()[player.fsApi_.fullscreenEnabled] && _this.disable(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(FullscreenToggle, _Button);
                var _proto = FullscreenToggle.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-fullscreen-control " + _Button.prototype.buildCSSClass.call(this);
                }, _proto.handleFullscreenChange = function(event) {
                    this.player_.isFullscreen() ? this.controlText("Non-Fullscreen") : this.controlText("Fullscreen");
                }, _proto.handleClick = function(event) {
                    this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen();
                }, FullscreenToggle;
            }(Button);
            FullscreenToggle.prototype.controlText_ = "Fullscreen", Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
            var checkVolumeSupport = function(self1, player) {
                player.tech_ && !player.tech_.featuresVolumeControl && self1.addClass("vjs-hidden"), self1.on(player, "loadstart", function() {
                    player.tech_.featuresVolumeControl ? self1.removeClass("vjs-hidden") : self1.addClass("vjs-hidden");
                });
            }, VolumeLevel = function(_Component) {
                function VolumeLevel() {
                    return _Component.apply(this, arguments) || this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VolumeLevel, _Component), VolumeLevel.prototype.createEl = function() {
                    var el = _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-volume-level"
                    });
                    return el.appendChild(_Component.prototype.createEl.call(this, "span", {
                        className: "vjs-control-text"
                    })), el;
                }, VolumeLevel;
            }(Component$1);
            Component$1.registerComponent("VolumeLevel", VolumeLevel);
            var VolumeLevelTooltip = function(_Component) {
                function VolumeLevelTooltip(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).update = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.update), 30), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VolumeLevelTooltip, _Component);
                var _proto = VolumeLevelTooltip.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-volume-tooltip"
                    }, {
                        "aria-hidden": "true"
                    });
                }, _proto.update = function(rangeBarRect, rangeBarPoint, vertical, content) {
                    if (!vertical) {
                        var tooltipRect = getBoundingClientRect(this.el_), playerRect = getBoundingClientRect(this.player_.el()), volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
                        if (!playerRect || !tooltipRect) return;
                        var spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx, spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right), pullTooltipBy = tooltipRect.width / 2;
                        spaceLeftOfPoint < pullTooltipBy ? pullTooltipBy += pullTooltipBy - spaceLeftOfPoint : spaceRightOfPoint < pullTooltipBy && (pullTooltipBy = spaceRightOfPoint), pullTooltipBy < 0 ? pullTooltipBy = 0 : pullTooltipBy > tooltipRect.width && (pullTooltipBy = tooltipRect.width), this.el_.style.right = "-" + pullTooltipBy + "px";
                    }
                    this.write(content + "%");
                }, _proto.write = function(content) {
                    textContent(this.el_, content);
                }, _proto.updateVolume = function(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
                    var _this2 = this;
                    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", function() {
                        _this2.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0)), cb && cb();
                    });
                }, VolumeLevelTooltip;
            }(Component$1);
            Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
            var MouseVolumeLevelDisplay = function(_Component) {
                function MouseVolumeLevelDisplay(player, options) {
                    var _this;
                    return (_this = _Component.call(this, player, options) || this).update = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.update), 30), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(MouseVolumeLevelDisplay, _Component);
                var _proto = MouseVolumeLevelDisplay.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-mouse-display"
                    });
                }, _proto.update = function(rangeBarRect, rangeBarPoint, vertical) {
                    var _this2 = this;
                    this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, 100 * rangeBarPoint, function() {
                        vertical ? _this2.el_.style.bottom = rangeBarRect.height * rangeBarPoint + "px" : _this2.el_.style.left = rangeBarRect.width * rangeBarPoint + "px";
                    });
                }, MouseVolumeLevelDisplay;
            }(Component$1);
            MouseVolumeLevelDisplay.prototype.options_ = {
                children: [
                    "volumeLevelTooltip"
                ]
            }, Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
            var VolumeBar = function(_Slider) {
                function VolumeBar(player, options) {
                    var _this;
                    return (_this = _Slider.call(this, player, options) || this).on("slideractive", function(e) {
                        return _this.updateLastVolume_(e);
                    }), _this.on(player, "volumechange", function(e) {
                        return _this.updateARIAAttributes(e);
                    }), player.ready(function() {
                        return _this.updateARIAAttributes();
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VolumeBar, _Slider);
                var _proto = VolumeBar.prototype;
                return _proto.createEl = function() {
                    return _Slider.prototype.createEl.call(this, "div", {
                        className: "vjs-volume-bar vjs-slider-bar"
                    }, {
                        "aria-label": this.localize("Volume Level"),
                        "aria-live": "polite"
                    });
                }, _proto.handleMouseDown = function(event) {
                    isSingleLeftClick(event) && _Slider.prototype.handleMouseDown.call(this, event);
                }, _proto.handleMouseMove = function(event) {
                    var mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
                    if (mouseVolumeLevelDisplay) {
                        var volumeBarEl = this.el(), volumeBarRect = getBoundingClientRect(volumeBarEl), vertical = this.vertical(), volumeBarPoint = getPointerPosition(volumeBarEl, event);
                        volumeBarPoint = clamp(volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x, 0, 1), mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
                    }
                    isSingleLeftClick(event) && (this.checkMuted(), this.player_.volume(this.calculateDistance(event)));
                }, _proto.checkMuted = function() {
                    this.player_.muted() && this.player_.muted(!1);
                }, _proto.getPercent = function() {
                    return this.player_.muted() ? 0 : this.player_.volume();
                }, _proto.stepForward = function() {
                    this.checkMuted(), this.player_.volume(this.player_.volume() + 0.1);
                }, _proto.stepBack = function() {
                    this.checkMuted(), this.player_.volume(this.player_.volume() - 0.1);
                }, _proto.updateARIAAttributes = function(event) {
                    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
                    this.el_.setAttribute("aria-valuenow", ariaValue), this.el_.setAttribute("aria-valuetext", ariaValue + "%");
                }, _proto.volumeAsPercentage_ = function() {
                    return Math.round(100 * this.player_.volume());
                }, _proto.updateLastVolume_ = function() {
                    var _this2 = this, volumeBeforeDrag = this.player_.volume();
                    this.one("sliderinactive", function() {
                        0 === _this2.player_.volume() && _this2.player_.lastVolume_(volumeBeforeDrag);
                    });
                }, VolumeBar;
            }(Slider);
            VolumeBar.prototype.options_ = {
                children: [
                    "volumeLevel"
                ],
                barName: "volumeLevel"
            }, IS_IOS || IS_ANDROID || VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay"), VolumeBar.prototype.playerEvent = "volumechange", Component$1.registerComponent("VolumeBar", VolumeBar);
            var VolumeControl = function(_Component) {
                function VolumeControl(player, options) {
                    var _this;
                    return void 0 === options && (options = {}), options.vertical = options.vertical || !1, (void 0 === options.volumeBar || isPlain(options.volumeBar)) && (options.volumeBar = options.volumeBar || {}, options.volumeBar.vertical = options.vertical), _this = _Component.call(this, player, options) || this, checkVolumeSupport((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), player), _this.throttledHandleMouseMove = throttle(bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.handleMouseMove), 30), _this.handleMouseUpHandler_ = function(e) {
                        return _this.handleMouseUp(e);
                    }, _this.on("mousedown", function(e) {
                        return _this.handleMouseDown(e);
                    }), _this.on("touchstart", function(e) {
                        return _this.handleMouseDown(e);
                    }), _this.on("mousemove", function(e) {
                        return _this.handleMouseMove(e);
                    }), _this.on(_this.volumeBar, [
                        "focus",
                        "slideractive"
                    ], function() {
                        _this.volumeBar.addClass("vjs-slider-active"), _this.addClass("vjs-slider-active"), _this.trigger("slideractive");
                    }), _this.on(_this.volumeBar, [
                        "blur",
                        "sliderinactive"
                    ], function() {
                        _this.volumeBar.removeClass("vjs-slider-active"), _this.removeClass("vjs-slider-active"), _this.trigger("sliderinactive");
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VolumeControl, _Component);
                var _proto = VolumeControl.prototype;
                return _proto.createEl = function() {
                    var orientationClass = "vjs-volume-horizontal";
                    return this.options_.vertical && (orientationClass = "vjs-volume-vertical"), _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-volume-control vjs-control " + orientationClass
                    });
                }, _proto.handleMouseDown = function(event) {
                    var doc = this.el_.ownerDocument;
                    this.on(doc, "mousemove", this.throttledHandleMouseMove), this.on(doc, "touchmove", this.throttledHandleMouseMove), this.on(doc, "mouseup", this.handleMouseUpHandler_), this.on(doc, "touchend", this.handleMouseUpHandler_);
                }, _proto.handleMouseUp = function(event) {
                    var doc = this.el_.ownerDocument;
                    this.off(doc, "mousemove", this.throttledHandleMouseMove), this.off(doc, "touchmove", this.throttledHandleMouseMove), this.off(doc, "mouseup", this.handleMouseUpHandler_), this.off(doc, "touchend", this.handleMouseUpHandler_);
                }, _proto.handleMouseMove = function(event) {
                    this.volumeBar.handleMouseMove(event);
                }, VolumeControl;
            }(Component$1);
            VolumeControl.prototype.options_ = {
                children: [
                    "volumeBar"
                ]
            }, Component$1.registerComponent("VolumeControl", VolumeControl);
            var checkMuteSupport = function(self1, player) {
                player.tech_ && !player.tech_.featuresMuteControl && self1.addClass("vjs-hidden"), self1.on(player, "loadstart", function() {
                    player.tech_.featuresMuteControl ? self1.removeClass("vjs-hidden") : self1.addClass("vjs-hidden");
                });
            }, MuteToggle = function(_Button) {
                function MuteToggle(player, options) {
                    var _this;
                    return _this = _Button.call(this, player, options) || this, checkMuteSupport((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), player), _this.on(player, [
                        "loadstart",
                        "volumechange"
                    ], function(e) {
                        return _this.update(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(MuteToggle, _Button);
                var _proto = MuteToggle.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-mute-control " + _Button.prototype.buildCSSClass.call(this);
                }, _proto.handleClick = function(event) {
                    var vol = this.player_.volume(), lastVolume = this.player_.lastVolume_();
                    0 === vol ? (this.player_.volume(lastVolume < 0.1 ? 0.1 : lastVolume), this.player_.muted(!1)) : this.player_.muted(!this.player_.muted());
                }, _proto.update = function(event) {
                    this.updateIcon_(), this.updateControlText_();
                }, _proto.updateIcon_ = function() {
                    var vol = this.player_.volume(), level = 3;
                    IS_IOS && this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), 0 === vol || this.player_.muted() ? level = 0 : vol < 0.33 ? level = 1 : vol < 0.67 && (level = 2);
                    for(var i = 0; i < 4; i++)removeClass(this.el_, "vjs-vol-" + i);
                    addClass(this.el_, "vjs-vol-" + level);
                }, _proto.updateControlText_ = function() {
                    var text = this.player_.muted() || 0 === this.player_.volume() ? "Unmute" : "Mute";
                    this.controlText() !== text && this.controlText(text);
                }, MuteToggle;
            }(Button);
            MuteToggle.prototype.controlText_ = "Mute", Component$1.registerComponent("MuteToggle", MuteToggle);
            var VolumePanel = function(_Component) {
                function VolumePanel(player, options) {
                    var _this;
                    return void 0 === options && (options = {}), void 0 !== options.inline ? options.inline = options.inline : options.inline = !0, (void 0 === options.volumeControl || isPlain(options.volumeControl)) && (options.volumeControl = options.volumeControl || {}, options.volumeControl.vertical = !options.inline), (_this = _Component.call(this, player, options) || this).handleKeyPressHandler_ = function(e) {
                        return _this.handleKeyPress(e);
                    }, _this.on(player, [
                        "loadstart"
                    ], function(e) {
                        return _this.volumePanelState_(e);
                    }), _this.on(_this.muteToggle, "keyup", function(e) {
                        return _this.handleKeyPress(e);
                    }), _this.on(_this.volumeControl, "keyup", function(e) {
                        return _this.handleVolumeControlKeyUp(e);
                    }), _this.on("keydown", function(e) {
                        return _this.handleKeyPress(e);
                    }), _this.on("mouseover", function(e) {
                        return _this.handleMouseOver(e);
                    }), _this.on("mouseout", function(e) {
                        return _this.handleMouseOut(e);
                    }), _this.on(_this.volumeControl, [
                        "slideractive"
                    ], _this.sliderActive_), _this.on(_this.volumeControl, [
                        "sliderinactive"
                    ], _this.sliderInactive_), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VolumePanel, _Component);
                var _proto = VolumePanel.prototype;
                return _proto.sliderActive_ = function() {
                    this.addClass("vjs-slider-active");
                }, _proto.sliderInactive_ = function() {
                    this.removeClass("vjs-slider-active");
                }, _proto.volumePanelState_ = function() {
                    this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only");
                }, _proto.createEl = function() {
                    var orientationClass = "vjs-volume-panel-horizontal";
                    return this.options_.inline || (orientationClass = "vjs-volume-panel-vertical"), _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-volume-panel vjs-control " + orientationClass
                    });
                }, _proto.dispose = function() {
                    this.handleMouseOut(), _Component.prototype.dispose.call(this);
                }, _proto.handleVolumeControlKeyUp = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Esc") && this.muteToggle.focus();
                }, _proto.handleMouseOver = function(event) {
                    this.addClass("vjs-hover"), on(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "keyup", this.handleKeyPressHandler_);
                }, _proto.handleMouseOut = function(event) {
                    this.removeClass("vjs-hover"), off(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "keyup", this.handleKeyPressHandler_);
                }, _proto.handleKeyPress = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Esc") && this.handleMouseOut();
                }, VolumePanel;
            }(Component$1);
            VolumePanel.prototype.options_ = {
                children: [
                    "muteToggle",
                    "volumeControl"
                ]
            }, Component$1.registerComponent("VolumePanel", VolumePanel);
            var Menu = function(_Component) {
                function Menu(player, options) {
                    var _this;
                    return _this = _Component.call(this, player, options) || this, options && (_this.menuButton_ = options.menuButton), _this.focusedChild_ = -1, _this.on("keydown", function(e) {
                        return _this.handleKeyDown(e);
                    }), _this.boundHandleBlur_ = function(e) {
                        return _this.handleBlur(e);
                    }, _this.boundHandleTapClick_ = function(e) {
                        return _this.handleTapClick(e);
                    }, _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Menu, _Component);
                var _proto = Menu.prototype;
                return _proto.addEventListenerForItem = function(component) {
                    component instanceof Component$1 && (this.on(component, "blur", this.boundHandleBlur_), this.on(component, [
                        "tap",
                        "click"
                    ], this.boundHandleTapClick_));
                }, _proto.removeEventListenerForItem = function(component) {
                    component instanceof Component$1 && (this.off(component, "blur", this.boundHandleBlur_), this.off(component, [
                        "tap",
                        "click"
                    ], this.boundHandleTapClick_));
                }, _proto.removeChild = function(component) {
                    "string" == typeof component && (component = this.getChild(component)), this.removeEventListenerForItem(component), _Component.prototype.removeChild.call(this, component);
                }, _proto.addItem = function(component) {
                    var childComponent = this.addChild(component);
                    childComponent && this.addEventListenerForItem(childComponent);
                }, _proto.createEl = function() {
                    var contentElType = this.options_.contentElType || "ul";
                    this.contentEl_ = createEl(contentElType, {
                        className: "vjs-menu-content"
                    }), this.contentEl_.setAttribute("role", "menu");
                    var el = _Component.prototype.createEl.call(this, "div", {
                        append: this.contentEl_,
                        className: "vjs-menu"
                    });
                    return el.appendChild(this.contentEl_), on(el, "click", function(event) {
                        event.preventDefault(), event.stopImmediatePropagation();
                    }), el;
                }, _proto.dispose = function() {
                    this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, _Component.prototype.dispose.call(this);
                }, _proto.handleBlur = function(event) {
                    var relatedTarget = event.relatedTarget || global_document__WEBPACK_IMPORTED_MODULE_1___default().activeElement;
                    if (!this.children().some(function(element) {
                        return element.el() === relatedTarget;
                    })) {
                        var btn = this.menuButton_;
                        btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild && btn.unpressButton();
                    }
                }, _proto.handleTapClick = function(event) {
                    if (this.menuButton_) {
                        this.menuButton_.unpressButton();
                        var childComponents = this.children();
                        if (Array.isArray(childComponents)) {
                            var foundComponent = childComponents.filter(function(component) {
                                return component.el() === event.target;
                            })[0];
                            foundComponent && "CaptionSettingsMenuItem" !== foundComponent.name() && this.menuButton_.focus();
                        }
                    }
                }, _proto.handleKeyDown = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Left") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Down") ? (event.preventDefault(), event.stopPropagation(), this.stepForward()) : (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Right") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Up")) && (event.preventDefault(), event.stopPropagation(), this.stepBack());
                }, _proto.stepForward = function() {
                    var stepChild = 0;
                    void 0 !== this.focusedChild_ && (stepChild = this.focusedChild_ + 1), this.focus(stepChild);
                }, _proto.stepBack = function() {
                    var stepChild = 0;
                    void 0 !== this.focusedChild_ && (stepChild = this.focusedChild_ - 1), this.focus(stepChild);
                }, _proto.focus = function(item) {
                    void 0 === item && (item = 0);
                    var children = this.children().slice();
                    children.length && children[0].hasClass("vjs-menu-title") && children.shift(), children.length > 0 && (item < 0 ? item = 0 : item >= children.length && (item = children.length - 1), this.focusedChild_ = item, children[item].el_.focus());
                }, Menu;
            }(Component$1);
            Component$1.registerComponent("Menu", Menu);
            var MenuButton = function(_Component) {
                function MenuButton(player, options) {
                    void 0 === options && (options = {}), (_this = _Component.call(this, player, options) || this).menuButton_ = new Button(player, options), _this.menuButton_.controlText(_this.controlText_), _this.menuButton_.el_.setAttribute("aria-haspopup", "true");
                    var _this, buttonClass = Button.prototype.buildCSSClass();
                    _this.menuButton_.el_.className = _this.buildCSSClass() + " " + buttonClass, _this.menuButton_.removeClass("vjs-control"), _this.addChild(_this.menuButton_), _this.update(), _this.enabled_ = !0;
                    var handleClick = function(e) {
                        return _this.handleClick(e);
                    };
                    return _this.handleMenuKeyUp_ = function(e) {
                        return _this.handleMenuKeyUp(e);
                    }, _this.on(_this.menuButton_, "tap", handleClick), _this.on(_this.menuButton_, "click", handleClick), _this.on(_this.menuButton_, "keydown", function(e) {
                        return _this.handleKeyDown(e);
                    }), _this.on(_this.menuButton_, "mouseenter", function() {
                        _this.addClass("vjs-hover"), _this.menu.show(), on(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "keyup", _this.handleMenuKeyUp_);
                    }), _this.on("mouseleave", function(e) {
                        return _this.handleMouseLeave(e);
                    }), _this.on("keydown", function(e) {
                        return _this.handleSubmenuKeyDown(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(MenuButton, _Component);
                var _proto = MenuButton.prototype;
                return _proto.update = function() {
                    var menu = this.createMenu();
                    this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = menu, this.addChild(menu), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? this.hide() : this.show();
                }, _proto.createMenu = function() {
                    var menu = new Menu(this.player_, {
                        menuButton: this
                    });
                    if (this.hideThreshold_ = 0, this.options_.title) {
                        var titleEl = createEl("li", {
                            className: "vjs-menu-title",
                            textContent: toTitleCase$1(this.options_.title),
                            tabIndex: -1
                        }), titleComponent = new Component$1(this.player_, {
                            el: titleEl
                        });
                        menu.addItem(titleComponent);
                    }
                    if (this.items = this.createItems(), this.items) for(var i = 0; i < this.items.length; i++)menu.addItem(this.items[i]);
                    return menu;
                }, _proto.createItems = function() {}, _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: this.buildWrapperCSSClass()
                    }, {});
                }, _proto.buildWrapperCSSClass = function() {
                    var menuButtonClass = "vjs-menu-button";
                    return !0 === this.options_.inline ? menuButtonClass += "-inline" : menuButtonClass += "-popup", "vjs-menu-button " + menuButtonClass + " " + Button.prototype.buildCSSClass() + " " + _Component.prototype.buildCSSClass.call(this);
                }, _proto.buildCSSClass = function() {
                    var menuButtonClass = "vjs-menu-button";
                    return !0 === this.options_.inline ? menuButtonClass += "-inline" : menuButtonClass += "-popup", "vjs-menu-button " + menuButtonClass + " " + _Component.prototype.buildCSSClass.call(this);
                }, _proto.controlText = function(text, el) {
                    return void 0 === el && (el = this.menuButton_.el()), this.menuButton_.controlText(text, el);
                }, _proto.dispose = function() {
                    this.handleMouseLeave(), _Component.prototype.dispose.call(this);
                }, _proto.handleClick = function(event) {
                    this.buttonPressed_ ? this.unpressButton() : this.pressButton();
                }, _proto.handleMouseLeave = function(event) {
                    this.removeClass("vjs-hover"), off(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "keyup", this.handleMenuKeyUp_);
                }, _proto.focus = function() {
                    this.menuButton_.focus();
                }, _proto.blur = function() {
                    this.menuButton_.blur();
                }, _proto.handleKeyDown = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Esc") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Tab") ? (this.buttonPressed_ && this.unpressButton(), keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Tab") || (event.preventDefault(), this.menuButton_.focus())) : (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Up") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Down")) && !this.buttonPressed_ && (event.preventDefault(), this.pressButton());
                }, _proto.handleMenuKeyUp = function(event) {
                    (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Esc") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Tab")) && this.removeClass("vjs-hover");
                }, _proto.handleSubmenuKeyPress = function(event) {
                    this.handleSubmenuKeyDown(event);
                }, _proto.handleSubmenuKeyDown = function(event) {
                    (keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Esc") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Tab")) && (this.buttonPressed_ && this.unpressButton(), keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Tab") || (event.preventDefault(), this.menuButton_.focus()));
                }, _proto.pressButton = function() {
                    this.enabled_ && (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), IS_IOS && isInFrame() || this.menu.focus());
                }, _proto.unpressButton = function() {
                    this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false"));
                }, _proto.disable = function() {
                    this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable();
                }, _proto.enable = function() {
                    this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable();
                }, MenuButton;
            }(Component$1);
            Component$1.registerComponent("MenuButton", MenuButton);
            var TrackButton = function(_MenuButton) {
                function TrackButton(player, options) {
                    var _this, tracks = options.tracks;
                    if ((_this = _MenuButton.call(this, player, options) || this).items.length <= 1 && _this.hide(), !tracks) return (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this);
                    var updateHandler = bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.update);
                    return tracks.addEventListener("removetrack", updateHandler), tracks.addEventListener("addtrack", updateHandler), tracks.addEventListener("labelchange", updateHandler), _this.player_.on("ready", updateHandler), _this.player_.on("dispose", function() {
                        tracks.removeEventListener("removetrack", updateHandler), tracks.removeEventListener("addtrack", updateHandler), tracks.removeEventListener("labelchange", updateHandler);
                    }), _this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TrackButton, _MenuButton), TrackButton;
            }(MenuButton);
            Component$1.registerComponent("TrackButton", TrackButton);
            var MenuKeys = [
                "Tab",
                "Esc",
                "Up",
                "Down",
                "Right",
                "Left"
            ], MenuItem = function(_ClickableComponent) {
                function MenuItem(player, options) {
                    var _this;
                    return (_this = _ClickableComponent.call(this, player, options) || this).selectable = options.selectable, _this.isSelected_ = options.selected || !1, _this.multiSelectable = options.multiSelectable, _this.selected(_this.isSelected_), _this.selectable ? _this.multiSelectable ? _this.el_.setAttribute("role", "menuitemcheckbox") : _this.el_.setAttribute("role", "menuitemradio") : _this.el_.setAttribute("role", "menuitem"), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(MenuItem, _ClickableComponent);
                var _proto = MenuItem.prototype;
                return _proto.createEl = function(type, props, attrs) {
                    this.nonIconControl = !0;
                    var el = _ClickableComponent.prototype.createEl.call(this, "li", assign({
                        className: "vjs-menu-item",
                        tabIndex: -1
                    }, props), attrs);
                    return el.replaceChild(createEl("span", {
                        className: "vjs-menu-item-text",
                        textContent: this.localize(this.options_.label)
                    }), el.querySelector(".vjs-icon-placeholder")), el;
                }, _proto.handleKeyDown = function(event) {
                    MenuKeys.some(function(key) {
                        return keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, key);
                    }) || _ClickableComponent.prototype.handleKeyDown.call(this, event);
                }, _proto.handleClick = function(event) {
                    this.selected(!0);
                }, _proto.selected = function(_selected) {
                    this.selectable && (_selected ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1));
                }, MenuItem;
            }(ClickableComponent);
            Component$1.registerComponent("MenuItem", MenuItem);
            var TextTrackMenuItem = function(_MenuItem) {
                function TextTrackMenuItem(player, options) {
                    var _this, event, track = options.track, tracks = player.textTracks();
                    options.label = track.label || track.language || "Unknown", options.selected = "showing" === track.mode, (_this = _MenuItem.call(this, player, options) || this).track = track, _this.kinds = (options.kinds || [
                        options.kind || _this.track.kind
                    ]).filter(Boolean);
                    var changeHandler = function() {
                        for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                        _this.handleTracksChange.apply((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), args);
                    }, selectedLanguageChangeHandler = function() {
                        for(var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
                        _this.handleSelectedLanguageChange.apply((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), args);
                    };
                    return player.on([
                        "loadstart",
                        "texttrackchange"
                    ], changeHandler), tracks.addEventListener("change", changeHandler), tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler), _this.on("dispose", function() {
                        player.off([
                            "loadstart",
                            "texttrackchange"
                        ], changeHandler), tracks.removeEventListener("change", changeHandler), tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
                    }), void 0 === tracks.onchange && _this.on([
                        "tap",
                        "click"
                    ], function() {
                        if ("object" != typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().Event) try {
                            event = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).Event("change");
                        } catch (err) {}
                        event || (event = global_document__WEBPACK_IMPORTED_MODULE_1___default().createEvent("Event")).initEvent("change", !0, !0), tracks.dispatchEvent(event);
                    }), _this.handleTracksChange(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TextTrackMenuItem, _MenuItem);
                var _proto = TextTrackMenuItem.prototype;
                return _proto.handleClick = function(event) {
                    var referenceTrack = this.track, tracks = this.player_.textTracks();
                    if (_MenuItem.prototype.handleClick.call(this, event), tracks) for(var i = 0; i < tracks.length; i++){
                        var track = tracks[i];
                        -1 !== this.kinds.indexOf(track.kind) && (track === referenceTrack ? "showing" !== track.mode && (track.mode = "showing") : "disabled" !== track.mode && (track.mode = "disabled"));
                    }
                }, _proto.handleTracksChange = function(event) {
                    var shouldBeSelected = "showing" === this.track.mode;
                    shouldBeSelected !== this.isSelected_ && this.selected(shouldBeSelected);
                }, _proto.handleSelectedLanguageChange = function(event) {
                    if ("showing" === this.track.mode) {
                        var selectedLanguage = this.player_.cache_.selectedLanguage;
                        selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind || (this.player_.cache_.selectedLanguage = {
                            enabled: !0,
                            language: this.track.language,
                            kind: this.track.kind
                        });
                    }
                }, _proto.dispose = function() {
                    this.track = null, _MenuItem.prototype.dispose.call(this);
                }, TextTrackMenuItem;
            }(MenuItem);
            Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
            var OffTextTrackMenuItem = function(_TextTrackMenuItem) {
                function OffTextTrackMenuItem(player, options) {
                    return options.track = {
                        player: player,
                        kind: options.kind,
                        kinds: options.kinds,
                        default: !1,
                        mode: "disabled"
                    }, options.kinds || (options.kinds = [
                        options.kind
                    ]), options.label ? options.track.label = options.label : options.track.label = options.kinds.join(" and ") + " off", options.selectable = !0, options.multiSelectable = !1, _TextTrackMenuItem.call(this, player, options) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(OffTextTrackMenuItem, _TextTrackMenuItem);
                var _proto = OffTextTrackMenuItem.prototype;
                return _proto.handleTracksChange = function(event) {
                    for(var tracks = this.player().textTracks(), shouldBeSelected = !0, i = 0, l = tracks.length; i < l; i++){
                        var track = tracks[i];
                        if (this.options_.kinds.indexOf(track.kind) > -1 && "showing" === track.mode) {
                            shouldBeSelected = !1;
                            break;
                        }
                    }
                    shouldBeSelected !== this.isSelected_ && this.selected(shouldBeSelected);
                }, _proto.handleSelectedLanguageChange = function(event) {
                    for(var tracks = this.player().textTracks(), allHidden = !0, i = 0, l = tracks.length; i < l; i++){
                        var track = tracks[i];
                        if ([
                            "captions",
                            "descriptions",
                            "subtitles"
                        ].indexOf(track.kind) > -1 && "showing" === track.mode) {
                            allHidden = !1;
                            break;
                        }
                    }
                    allHidden && (this.player_.cache_.selectedLanguage = {
                        enabled: !1
                    });
                }, OffTextTrackMenuItem;
            }(TextTrackMenuItem);
            Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
            var TextTrackButton = function(_TrackButton) {
                function TextTrackButton(player, options) {
                    return void 0 === options && (options = {}), options.tracks = player.textTracks(), _TrackButton.call(this, player, options) || this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TextTrackButton, _TrackButton), TextTrackButton.prototype.createItems = function(items, TrackMenuItem) {
                    void 0 === items && (items = []), void 0 === TrackMenuItem && (TrackMenuItem = TextTrackMenuItem), this.label_ && (label = this.label_ + " off"), items.push(new OffTextTrackMenuItem(this.player_, {
                        kinds: this.kinds_,
                        kind: this.kind_,
                        label: label
                    })), this.hideThreshold_ += 1;
                    var label, tracks = this.player_.textTracks();
                    Array.isArray(this.kinds_) || (this.kinds_ = [
                        this.kind_
                    ]);
                    for(var i = 0; i < tracks.length; i++){
                        var track = tracks[i];
                        if (this.kinds_.indexOf(track.kind) > -1) {
                            var item = new TrackMenuItem(this.player_, {
                                track: track,
                                kinds: this.kinds_,
                                kind: this.kind_,
                                selectable: !0,
                                multiSelectable: !1
                            });
                            item.addClass("vjs-" + track.kind + "-menu-item"), items.push(item);
                        }
                    }
                    return items;
                }, TextTrackButton;
            }(TrackButton);
            Component$1.registerComponent("TextTrackButton", TextTrackButton);
            var ChaptersTrackMenuItem = function(_MenuItem) {
                function ChaptersTrackMenuItem(player, options) {
                    var _this, track = options.track, cue = options.cue, currentTime = player.currentTime();
                    return options.selectable = !0, options.multiSelectable = !1, options.label = cue.text, options.selected = cue.startTime <= currentTime && currentTime < cue.endTime, (_this = _MenuItem.call(this, player, options) || this).track = track, _this.cue = cue, track.addEventListener("cuechange", bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.update)), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ChaptersTrackMenuItem, _MenuItem);
                var _proto = ChaptersTrackMenuItem.prototype;
                return _proto.handleClick = function(event) {
                    _MenuItem.prototype.handleClick.call(this), this.player_.currentTime(this.cue.startTime), this.update(this.cue.startTime);
                }, _proto.update = function(event) {
                    var cue = this.cue, currentTime = this.player_.currentTime();
                    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
                }, ChaptersTrackMenuItem;
            }(MenuItem);
            Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
            var ChaptersButton = function(_TextTrackButton) {
                function ChaptersButton(player, options, ready) {
                    return _TextTrackButton.call(this, player, options, ready) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ChaptersButton, _TextTrackButton);
                var _proto = ChaptersButton.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-chapters-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
                }, _proto.buildWrapperCSSClass = function() {
                    return "vjs-chapters-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
                }, _proto.update = function(event) {
                    (!this.track_ || event && ("addtrack" === event.type || "removetrack" === event.type)) && this.setTrack(this.findChaptersTrack()), _TextTrackButton.prototype.update.call(this);
                }, _proto.setTrack = function(track) {
                    if (this.track_ !== track) {
                        if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) {
                            var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                            remoteTextTrackEl && remoteTextTrackEl.removeEventListener("load", this.updateHandler_), this.track_ = null;
                        }
                        if (this.track_ = track, this.track_) {
                            this.track_.mode = "hidden";
                            var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                            _remoteTextTrackEl && _remoteTextTrackEl.addEventListener("load", this.updateHandler_);
                        }
                    }
                }, _proto.findChaptersTrack = function() {
                    for(var tracks = this.player_.textTracks() || [], i = tracks.length - 1; i >= 0; i--){
                        var track = tracks[i];
                        if (track.kind === this.kind_) return track;
                    }
                }, _proto.getMenuCaption = function() {
                    return this.track_ && this.track_.label ? this.track_.label : this.localize(toTitleCase$1(this.kind_));
                }, _proto.createMenu = function() {
                    return this.options_.title = this.getMenuCaption(), _TextTrackButton.prototype.createMenu.call(this);
                }, _proto.createItems = function() {
                    var items = [];
                    if (!this.track_) return items;
                    var cues = this.track_.cues;
                    if (!cues) return items;
                    for(var i = 0, l = cues.length; i < l; i++){
                        var cue = cues[i], mi = new ChaptersTrackMenuItem(this.player_, {
                            track: this.track_,
                            cue: cue
                        });
                        items.push(mi);
                    }
                    return items;
                }, ChaptersButton;
            }(TextTrackButton);
            ChaptersButton.prototype.kind_ = "chapters", ChaptersButton.prototype.controlText_ = "Chapters", Component$1.registerComponent("ChaptersButton", ChaptersButton);
            var DescriptionsButton = function(_TextTrackButton) {
                function DescriptionsButton(player, options, ready) {
                    _this = _TextTrackButton.call(this, player, options, ready) || this;
                    var _this, tracks = player.textTracks(), changeHandler = bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), _this.handleTracksChange);
                    return tracks.addEventListener("change", changeHandler), _this.on("dispose", function() {
                        tracks.removeEventListener("change", changeHandler);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(DescriptionsButton, _TextTrackButton);
                var _proto = DescriptionsButton.prototype;
                return _proto.handleTracksChange = function(event) {
                    for(var tracks = this.player().textTracks(), disabled = !1, i = 0, l = tracks.length; i < l; i++){
                        var track = tracks[i];
                        if (track.kind !== this.kind_ && "showing" === track.mode) {
                            disabled = !0;
                            break;
                        }
                    }
                    disabled ? this.disable() : this.enable();
                }, _proto.buildCSSClass = function() {
                    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
                }, _proto.buildWrapperCSSClass = function() {
                    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
                }, DescriptionsButton;
            }(TextTrackButton);
            DescriptionsButton.prototype.kind_ = "descriptions", DescriptionsButton.prototype.controlText_ = "Descriptions", Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
            var SubtitlesButton = function(_TextTrackButton) {
                function SubtitlesButton(player, options, ready) {
                    return _TextTrackButton.call(this, player, options, ready) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SubtitlesButton, _TextTrackButton);
                var _proto = SubtitlesButton.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
                }, _proto.buildWrapperCSSClass = function() {
                    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
                }, SubtitlesButton;
            }(TextTrackButton);
            SubtitlesButton.prototype.kind_ = "subtitles", SubtitlesButton.prototype.controlText_ = "Subtitles", Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
            var CaptionSettingsMenuItem = function(_TextTrackMenuItem) {
                function CaptionSettingsMenuItem(player, options) {
                    var _this;
                    return options.track = {
                        player: player,
                        kind: options.kind,
                        label: options.kind + " settings",
                        selectable: !1,
                        default: !1,
                        mode: "disabled"
                    }, options.selectable = !1, options.name = "CaptionSettingsMenuItem", (_this = _TextTrackMenuItem.call(this, player, options) || this).addClass("vjs-texttrack-settings"), _this.controlText(", opens " + options.kind + " settings dialog"), _this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(CaptionSettingsMenuItem, _TextTrackMenuItem), CaptionSettingsMenuItem.prototype.handleClick = function(event) {
                    this.player().getChild("textTrackSettings").open();
                }, CaptionSettingsMenuItem;
            }(TextTrackMenuItem);
            Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
            var CaptionsButton = function(_TextTrackButton) {
                function CaptionsButton(player, options, ready) {
                    return _TextTrackButton.call(this, player, options, ready) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(CaptionsButton, _TextTrackButton);
                var _proto = CaptionsButton.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-captions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
                }, _proto.buildWrapperCSSClass = function() {
                    return "vjs-captions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
                }, _proto.createItems = function() {
                    var items = [];
                    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (items.push(new CaptionSettingsMenuItem(this.player_, {
                        kind: this.kind_
                    })), this.hideThreshold_ += 1), _TextTrackButton.prototype.createItems.call(this, items);
                }, CaptionsButton;
            }(TextTrackButton);
            CaptionsButton.prototype.kind_ = "captions", CaptionsButton.prototype.controlText_ = "Captions", Component$1.registerComponent("CaptionsButton", CaptionsButton);
            var SubsCapsMenuItem = function(_TextTrackMenuItem) {
                function SubsCapsMenuItem() {
                    return _TextTrackMenuItem.apply(this, arguments) || this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SubsCapsMenuItem, _TextTrackMenuItem), SubsCapsMenuItem.prototype.createEl = function(type, props, attrs) {
                    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, props, attrs), parentSpan = el.querySelector(".vjs-menu-item-text");
                    return "captions" === this.options_.track.kind && (parentSpan.appendChild(createEl("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), parentSpan.appendChild(createEl("span", {
                        className: "vjs-control-text",
                        textContent: " " + this.localize("Captions")
                    }))), el;
                }, SubsCapsMenuItem;
            }(TextTrackMenuItem);
            Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
            var SubsCapsButton = function(_TextTrackButton) {
                function SubsCapsButton(player, options) {
                    var _this;
                    return void 0 === options && (options = {}), (_this = _TextTrackButton.call(this, player, options) || this).label_ = "subtitles", [
                        "en",
                        "en-us",
                        "en-ca",
                        "fr-ca"
                    ].indexOf(_this.player_.language_) > -1 && (_this.label_ = "captions"), _this.menuButton_.controlText(toTitleCase$1(_this.label_)), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SubsCapsButton, _TextTrackButton);
                var _proto = SubsCapsButton.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
                }, _proto.buildWrapperCSSClass = function() {
                    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
                }, _proto.createItems = function() {
                    var items = [];
                    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (items.push(new CaptionSettingsMenuItem(this.player_, {
                        kind: this.label_
                    })), this.hideThreshold_ += 1), items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
                }, SubsCapsButton;
            }(TextTrackButton);
            SubsCapsButton.prototype.kinds_ = [
                "captions",
                "subtitles"
            ], SubsCapsButton.prototype.controlText_ = "Subtitles", Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
            var AudioTrackMenuItem = function(_MenuItem) {
                function AudioTrackMenuItem(player, options) {
                    var _this, track = options.track, tracks = player.audioTracks();
                    options.label = track.label || track.language || "Unknown", options.selected = track.enabled, (_this = _MenuItem.call(this, player, options) || this).track = track, _this.addClass("vjs-" + track.kind + "-menu-item");
                    var changeHandler = function() {
                        for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                        _this.handleTracksChange.apply((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), args);
                    };
                    return tracks.addEventListener("change", changeHandler), _this.on("dispose", function() {
                        tracks.removeEventListener("change", changeHandler);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(AudioTrackMenuItem, _MenuItem);
                var _proto = AudioTrackMenuItem.prototype;
                return _proto.createEl = function(type, props, attrs) {
                    var el = _MenuItem.prototype.createEl.call(this, type, props, attrs), parentSpan = el.querySelector(".vjs-menu-item-text");
                    return "main-desc" === this.options_.track.kind && (parentSpan.appendChild(_MenuItem.prototype.createEl.call(this, "span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), parentSpan.appendChild(_MenuItem.prototype.createEl.call(this, "span", {
                        className: "vjs-control-text",
                        textContent: this.localize("Descriptions")
                    }))), el;
                }, _proto.handleClick = function(event) {
                    _MenuItem.prototype.handleClick.call(this, event), this.track.enabled = !0;
                }, _proto.handleTracksChange = function(event) {
                    this.selected(this.track.enabled);
                }, AudioTrackMenuItem;
            }(MenuItem);
            Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
            var AudioTrackButton = function(_TrackButton) {
                function AudioTrackButton(player, options) {
                    return void 0 === options && (options = {}), options.tracks = player.audioTracks(), _TrackButton.call(this, player, options) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(AudioTrackButton, _TrackButton);
                var _proto = AudioTrackButton.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-audio-button " + _TrackButton.prototype.buildCSSClass.call(this);
                }, _proto.buildWrapperCSSClass = function() {
                    return "vjs-audio-button " + _TrackButton.prototype.buildWrapperCSSClass.call(this);
                }, _proto.createItems = function(items) {
                    void 0 === items && (items = []), this.hideThreshold_ = 1;
                    for(var tracks = this.player_.audioTracks(), i = 0; i < tracks.length; i++){
                        var track = tracks[i];
                        items.push(new AudioTrackMenuItem(this.player_, {
                            track: track,
                            selectable: !0,
                            multiSelectable: !1
                        }));
                    }
                    return items;
                }, AudioTrackButton;
            }(TrackButton);
            AudioTrackButton.prototype.controlText_ = "Audio Track", Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
            var PlaybackRateMenuItem = function(_MenuItem) {
                function PlaybackRateMenuItem(player, options) {
                    var _this, label = options.rate, rate = parseFloat(label, 10);
                    return options.label = label, options.selected = rate === player.playbackRate(), options.selectable = !0, options.multiSelectable = !1, (_this = _MenuItem.call(this, player, options) || this).label = label, _this.rate = rate, _this.on(player, "ratechange", function(e) {
                        return _this.update(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(PlaybackRateMenuItem, _MenuItem);
                var _proto = PlaybackRateMenuItem.prototype;
                return _proto.handleClick = function(event) {
                    _MenuItem.prototype.handleClick.call(this), this.player().playbackRate(this.rate);
                }, _proto.update = function(event) {
                    this.selected(this.player().playbackRate() === this.rate);
                }, PlaybackRateMenuItem;
            }(MenuItem);
            PlaybackRateMenuItem.prototype.contentElType = "button", Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
            var PlaybackRateMenuButton = function(_MenuButton) {
                function PlaybackRateMenuButton(player, options) {
                    var _this;
                    return (_this = _MenuButton.call(this, player, options) || this).menuButton_.el_.setAttribute("aria-describedby", _this.labelElId_), _this.updateVisibility(), _this.updateLabel(), _this.on(player, "loadstart", function(e) {
                        return _this.updateVisibility(e);
                    }), _this.on(player, "ratechange", function(e) {
                        return _this.updateLabel(e);
                    }), _this.on(player, "playbackrateschange", function(e) {
                        return _this.handlePlaybackRateschange(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(PlaybackRateMenuButton, _MenuButton);
                var _proto = PlaybackRateMenuButton.prototype;
                return _proto.createEl = function() {
                    var el = _MenuButton.prototype.createEl.call(this);
                    return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = createEl("div", {
                        className: "vjs-playback-rate-value",
                        id: this.labelElId_,
                        textContent: "1x"
                    }), el.appendChild(this.labelEl_), el;
                }, _proto.dispose = function() {
                    this.labelEl_ = null, _MenuButton.prototype.dispose.call(this);
                }, _proto.buildCSSClass = function() {
                    return "vjs-playback-rate " + _MenuButton.prototype.buildCSSClass.call(this);
                }, _proto.buildWrapperCSSClass = function() {
                    return "vjs-playback-rate " + _MenuButton.prototype.buildWrapperCSSClass.call(this);
                }, _proto.createItems = function() {
                    for(var rates = this.playbackRates(), items = [], i = rates.length - 1; i >= 0; i--)items.push(new PlaybackRateMenuItem(this.player(), {
                        rate: rates[i] + "x"
                    }));
                    return items;
                }, _proto.updateARIAAttributes = function() {
                    this.el().setAttribute("aria-valuenow", this.player().playbackRate());
                }, _proto.handleClick = function(event) {
                    for(var currentRate = this.player().playbackRate(), rates = this.playbackRates(), newRate = rates[0], i = 0; i < rates.length; i++)if (rates[i] > currentRate) {
                        newRate = rates[i];
                        break;
                    }
                    this.player().playbackRate(newRate);
                }, _proto.handlePlaybackRateschange = function(event) {
                    this.update();
                }, _proto.playbackRates = function() {
                    var player = this.player();
                    return player.playbackRates && player.playbackRates() || [];
                }, _proto.playbackRateSupported = function() {
                    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
                }, _proto.updateVisibility = function(event) {
                    this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden");
                }, _proto.updateLabel = function(event) {
                    this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x");
                }, PlaybackRateMenuButton;
            }(MenuButton);
            PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate", Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
            var Spacer = function(_Component) {
                function Spacer() {
                    return _Component.apply(this, arguments) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Spacer, _Component);
                var _proto = Spacer.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-spacer " + _Component.prototype.buildCSSClass.call(this);
                }, _proto.createEl = function(tag, props, attributes) {
                    return void 0 === tag && (tag = "div"), void 0 === props && (props = {}), void 0 === attributes && (attributes = {}), props.className || (props.className = this.buildCSSClass()), _Component.prototype.createEl.call(this, tag, props, attributes);
                }, Spacer;
            }(Component$1);
            Component$1.registerComponent("Spacer", Spacer);
            var CustomControlSpacer = function(_Spacer) {
                function CustomControlSpacer() {
                    return _Spacer.apply(this, arguments) || this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(CustomControlSpacer, _Spacer);
                var _proto = CustomControlSpacer.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-custom-control-spacer " + _Spacer.prototype.buildCSSClass.call(this);
                }, _proto.createEl = function() {
                    return _Spacer.prototype.createEl.call(this, "div", {
                        className: this.buildCSSClass(),
                        textContent: "\xA0"
                    });
                }, CustomControlSpacer;
            }(Spacer);
            Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
            var ControlBar = function(_Component) {
                function ControlBar() {
                    return _Component.apply(this, arguments) || this;
                }
                return (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ControlBar, _Component), ControlBar.prototype.createEl = function() {
                    return _Component.prototype.createEl.call(this, "div", {
                        className: "vjs-control-bar",
                        dir: "ltr"
                    });
                }, ControlBar;
            }(Component$1);
            ControlBar.prototype.options_ = {
                children: [
                    "playToggle",
                    "volumePanel",
                    "currentTimeDisplay",
                    "timeDivider",
                    "durationDisplay",
                    "progressControl",
                    "liveDisplay",
                    "seekToLive",
                    "remainingTimeDisplay",
                    "customControlSpacer",
                    "playbackRateMenuButton",
                    "chaptersButton",
                    "descriptionsButton",
                    "subsCapsButton",
                    "audioTrackButton",
                    "fullscreenToggle"
                ]
            }, "exitPictureInPicture" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, "pictureInPictureToggle"), Component$1.registerComponent("ControlBar", ControlBar);
            var ErrorDisplay = function(_ModalDialog) {
                function ErrorDisplay(player, options) {
                    var _this;
                    return (_this = _ModalDialog.call(this, player, options) || this).on(player, "error", function(e) {
                        return _this.open(e);
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ErrorDisplay, _ModalDialog);
                var _proto = ErrorDisplay.prototype;
                return _proto.buildCSSClass = function() {
                    return "vjs-error-display " + _ModalDialog.prototype.buildCSSClass.call(this);
                }, _proto.content = function() {
                    var error = this.player().error();
                    return error ? this.localize(error.message) : "";
                }, ErrorDisplay;
            }(ModalDialog);
            ErrorDisplay.prototype.options_ = (0, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__.Z)({}, ModalDialog.prototype.options_, {
                pauseOnOpen: !1,
                fillAlways: !0,
                temporary: !1,
                uncloseable: !0
            }), Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
            var LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings", COLOR_BLACK = [
                "#000",
                "Black"
            ], COLOR_BLUE = [
                "#00F",
                "Blue"
            ], COLOR_CYAN = [
                "#0FF",
                "Cyan"
            ], COLOR_GREEN = [
                "#0F0",
                "Green"
            ], COLOR_MAGENTA = [
                "#F0F",
                "Magenta"
            ], COLOR_RED = [
                "#F00",
                "Red"
            ], COLOR_WHITE = [
                "#FFF",
                "White"
            ], COLOR_YELLOW = [
                "#FF0",
                "Yellow"
            ], OPACITY_OPAQUE = [
                "1",
                "Opaque"
            ], OPACITY_SEMI = [
                "0.5",
                "Semi-Transparent"
            ], OPACITY_TRANS = [
                "0",
                "Transparent"
            ], selectConfigs = {
                backgroundColor: {
                    selector: ".vjs-bg-color > select",
                    id: "captions-background-color-%s",
                    label: "Color",
                    options: [
                        COLOR_BLACK,
                        COLOR_WHITE,
                        COLOR_RED,
                        COLOR_GREEN,
                        COLOR_BLUE,
                        COLOR_YELLOW,
                        COLOR_MAGENTA,
                        COLOR_CYAN
                    ]
                },
                backgroundOpacity: {
                    selector: ".vjs-bg-opacity > select",
                    id: "captions-background-opacity-%s",
                    label: "Transparency",
                    options: [
                        OPACITY_OPAQUE,
                        OPACITY_SEMI,
                        OPACITY_TRANS
                    ]
                },
                color: {
                    selector: ".vjs-fg-color > select",
                    id: "captions-foreground-color-%s",
                    label: "Color",
                    options: [
                        COLOR_WHITE,
                        COLOR_BLACK,
                        COLOR_RED,
                        COLOR_GREEN,
                        COLOR_BLUE,
                        COLOR_YELLOW,
                        COLOR_MAGENTA,
                        COLOR_CYAN
                    ]
                },
                edgeStyle: {
                    selector: ".vjs-edge-style > select",
                    id: "%s",
                    label: "Text Edge Style",
                    options: [
                        [
                            "none",
                            "None"
                        ],
                        [
                            "raised",
                            "Raised"
                        ],
                        [
                            "depressed",
                            "Depressed"
                        ],
                        [
                            "uniform",
                            "Uniform"
                        ],
                        [
                            "dropshadow",
                            "Dropshadow"
                        ]
                    ]
                },
                fontFamily: {
                    selector: ".vjs-font-family > select",
                    id: "captions-font-family-%s",
                    label: "Font Family",
                    options: [
                        [
                            "proportionalSansSerif",
                            "Proportional Sans-Serif"
                        ],
                        [
                            "monospaceSansSerif",
                            "Monospace Sans-Serif"
                        ],
                        [
                            "proportionalSerif",
                            "Proportional Serif"
                        ],
                        [
                            "monospaceSerif",
                            "Monospace Serif"
                        ],
                        [
                            "casual",
                            "Casual"
                        ],
                        [
                            "script",
                            "Script"
                        ],
                        [
                            "small-caps",
                            "Small Caps"
                        ]
                    ]
                },
                fontPercent: {
                    selector: ".vjs-font-percent > select",
                    id: "captions-font-size-%s",
                    label: "Font Size",
                    options: [
                        [
                            "0.50",
                            "50%"
                        ],
                        [
                            "0.75",
                            "75%"
                        ],
                        [
                            "1.00",
                            "100%"
                        ],
                        [
                            "1.25",
                            "125%"
                        ],
                        [
                            "1.50",
                            "150%"
                        ],
                        [
                            "1.75",
                            "175%"
                        ],
                        [
                            "2.00",
                            "200%"
                        ],
                        [
                            "3.00",
                            "300%"
                        ],
                        [
                            "4.00",
                            "400%"
                        ]
                    ],
                    default: 2,
                    parser: function(v) {
                        return "1.00" === v ? null : Number(v);
                    }
                },
                textOpacity: {
                    selector: ".vjs-text-opacity > select",
                    id: "captions-foreground-opacity-%s",
                    label: "Transparency",
                    options: [
                        OPACITY_OPAQUE,
                        OPACITY_SEMI
                    ]
                },
                windowColor: {
                    selector: ".vjs-window-color > select",
                    id: "captions-window-color-%s",
                    label: "Color"
                },
                windowOpacity: {
                    selector: ".vjs-window-opacity > select",
                    id: "captions-window-opacity-%s",
                    label: "Transparency",
                    options: [
                        OPACITY_TRANS,
                        OPACITY_SEMI,
                        OPACITY_OPAQUE
                    ]
                }
            };
            function parseOptionValue(value, parser) {
                if (parser && (value = parser(value)), value && "none" !== value) return value;
            }
            selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
            var TextTrackSettings = function(_ModalDialog) {
                function TextTrackSettings(player, options) {
                    var _this;
                    return options.temporary = !1, (_this = _ModalDialog.call(this, player, options) || this).updateDisplay = _this.updateDisplay.bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), _this.fill(), _this.hasBeenOpened_ = _this.hasBeenFilled_ = !0, _this.endDialog = createEl("p", {
                        className: "vjs-control-text",
                        textContent: _this.localize("End of dialog window.")
                    }), _this.el().appendChild(_this.endDialog), _this.setDefaults(), void 0 === options.persistTextTrackSettings && (_this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings), _this.on(_this.$(".vjs-done-button"), "click", function() {
                        _this.saveSettings(), _this.close();
                    }), _this.on(_this.$(".vjs-default-button"), "click", function() {
                        _this.setDefaults(), _this.updateDisplay();
                    }), each(selectConfigs, function(config) {
                        _this.on(_this.$(config.selector), "change", _this.updateDisplay);
                    }), _this.options_.persistTextTrackSettings && _this.restoreSettings(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TextTrackSettings, _ModalDialog);
                var _proto = TextTrackSettings.prototype;
                return _proto.dispose = function() {
                    this.endDialog = null, _ModalDialog.prototype.dispose.call(this);
                }, _proto.createElSelect_ = function(key, legendId, type) {
                    var _this2 = this;
                    void 0 === legendId && (legendId = ""), void 0 === type && (type = "label");
                    var config = selectConfigs[key], id = config.id.replace("%s", this.id_), selectLabelledbyIds = [
                        legendId,
                        id
                    ].join(" ").trim();
                    return [
                        "<" + type + ' id="' + id + '" class="' + ("label" === type ? "vjs-label" : "") + '">',
                        this.localize(config.label),
                        "</" + type + ">",
                        '<select aria-labelledby="' + selectLabelledbyIds + '">'
                    ].concat(config.options.map(function(o) {
                        var optionId = id + "-" + o[1].replace(/\W+/g, "");
                        return [
                            '<option id="' + optionId + '" value="' + o[0] + '" ',
                            'aria-labelledby="' + selectLabelledbyIds + " " + optionId + '">',
                            _this2.localize(o[1]),
                            "</option>"
                        ].join("");
                    })).concat("</select>").join("");
                }, _proto.createElFgColor_ = function() {
                    var legendId = "captions-text-legend-" + this.id_;
                    return [
                        '<fieldset class="vjs-fg-color vjs-track-setting">',
                        '<legend id="' + legendId + '">',
                        this.localize("Text"),
                        "</legend>",
                        this.createElSelect_("color", legendId),
                        '<span class="vjs-text-opacity vjs-opacity">',
                        this.createElSelect_("textOpacity", legendId),
                        "</span>",
                        "</fieldset>"
                    ].join("");
                }, _proto.createElBgColor_ = function() {
                    var legendId = "captions-background-" + this.id_;
                    return [
                        '<fieldset class="vjs-bg-color vjs-track-setting">',
                        '<legend id="' + legendId + '">',
                        this.localize("Background"),
                        "</legend>",
                        this.createElSelect_("backgroundColor", legendId),
                        '<span class="vjs-bg-opacity vjs-opacity">',
                        this.createElSelect_("backgroundOpacity", legendId),
                        "</span>",
                        "</fieldset>"
                    ].join("");
                }, _proto.createElWinColor_ = function() {
                    var legendId = "captions-window-" + this.id_;
                    return [
                        '<fieldset class="vjs-window-color vjs-track-setting">',
                        '<legend id="' + legendId + '">',
                        this.localize("Window"),
                        "</legend>",
                        this.createElSelect_("windowColor", legendId),
                        '<span class="vjs-window-opacity vjs-opacity">',
                        this.createElSelect_("windowOpacity", legendId),
                        "</span>",
                        "</fieldset>"
                    ].join("");
                }, _proto.createElColors_ = function() {
                    return createEl("div", {
                        className: "vjs-track-settings-colors",
                        innerHTML: [
                            this.createElFgColor_(),
                            this.createElBgColor_(),
                            this.createElWinColor_()
                        ].join("")
                    });
                }, _proto.createElFont_ = function() {
                    return createEl("div", {
                        className: "vjs-track-settings-font",
                        innerHTML: [
                            '<fieldset class="vjs-font-percent vjs-track-setting">',
                            this.createElSelect_("fontPercent", "", "legend"),
                            "</fieldset>",
                            '<fieldset class="vjs-edge-style vjs-track-setting">',
                            this.createElSelect_("edgeStyle", "", "legend"),
                            "</fieldset>",
                            '<fieldset class="vjs-font-family vjs-track-setting">',
                            this.createElSelect_("fontFamily", "", "legend"),
                            "</fieldset>"
                        ].join("")
                    });
                }, _proto.createElControls_ = function() {
                    var defaultsDescription = this.localize("restore all settings to the default values");
                    return createEl("div", {
                        className: "vjs-track-settings-controls",
                        innerHTML: [
                            '<button type="button" class="vjs-default-button" title="' + defaultsDescription + '">',
                            this.localize("Reset"),
                            '<span class="vjs-control-text"> ' + defaultsDescription + "</span>",
                            "</button>",
                            '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"
                        ].join("")
                    });
                }, _proto.content = function() {
                    return [
                        this.createElColors_(),
                        this.createElFont_(),
                        this.createElControls_()
                    ];
                }, _proto.label = function() {
                    return this.localize("Caption Settings Dialog");
                }, _proto.description = function() {
                    return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
                }, _proto.buildCSSClass = function() {
                    return _ModalDialog.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
                }, _proto.getValues = function() {
                    var fn, _this3 = this;
                    return fn = function(accum, config, key) {
                        var el, parser, value = (el = _this3.$(config.selector), parser = config.parser, parseOptionValue(el.options[el.options.selectedIndex].value, parser));
                        return void 0 !== value && (accum[key] = value), accum;
                    }, keys(selectConfigs).reduce(function(accum, key) {
                        return fn(accum, selectConfigs[key], key);
                    }, {});
                }, _proto.setValues = function(values) {
                    var _this4 = this;
                    each(selectConfigs, function(config, key) {
                        !function(el, value, parser) {
                            if (value) {
                                for(var i = 0; i < el.options.length; i++)if (parseOptionValue(el.options[i].value, parser) === value) {
                                    el.selectedIndex = i;
                                    break;
                                }
                            }
                        }(_this4.$(config.selector), values[key], config.parser);
                    });
                }, _proto.setDefaults = function() {
                    var _this5 = this;
                    each(selectConfigs, function(config) {
                        var index = config.hasOwnProperty("default") ? config.default : 0;
                        _this5.$(config.selector).selectedIndex = index;
                    });
                }, _proto.restoreSettings = function() {
                    var values;
                    try {
                        values = JSON.parse(global_window__WEBPACK_IMPORTED_MODULE_0___default().localStorage.getItem(LOCAL_STORAGE_KEY$1));
                    } catch (err) {
                        log$1.warn(err);
                    }
                    values && this.setValues(values);
                }, _proto.saveSettings = function() {
                    if (this.options_.persistTextTrackSettings) {
                        var values = this.getValues();
                        try {
                            Object.keys(values).length ? global_window__WEBPACK_IMPORTED_MODULE_0___default().localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values)) : global_window__WEBPACK_IMPORTED_MODULE_0___default().localStorage.removeItem(LOCAL_STORAGE_KEY$1);
                        } catch (err) {
                            log$1.warn(err);
                        }
                    }
                }, _proto.updateDisplay = function() {
                    var ttDisplay = this.player_.getChild("textTrackDisplay");
                    ttDisplay && ttDisplay.updateDisplay();
                }, _proto.conditionalBlur_ = function() {
                    this.previouslyActiveEl_ = null;
                    var cb = this.player_.controlBar, subsCapsBtn = cb && cb.subsCapsButton, ccBtn = cb && cb.captionsButton;
                    subsCapsBtn ? subsCapsBtn.focus() : ccBtn && ccBtn.focus();
                }, TextTrackSettings;
            }(ModalDialog);
            Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
            var ResizeManager = function(_Component) {
                function ResizeManager(player, options) {
                    var _this, RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || global_window__WEBPACK_IMPORTED_MODULE_0___default().ResizeObserver;
                    null === options.ResizeObserver && (RESIZE_OBSERVER_AVAILABLE = !1);
                    var options_ = mergeOptions$3({
                        createEl: !RESIZE_OBSERVER_AVAILABLE,
                        reportTouchActivity: !1
                    }, options);
                    return (_this = _Component.call(this, player, options_) || this).ResizeObserver = options.ResizeObserver || global_window__WEBPACK_IMPORTED_MODULE_0___default().ResizeObserver, _this.loadListener_ = null, _this.resizeObserver_ = null, _this.debouncedHandler_ = debounce(function() {
                        _this.resizeHandler();
                    }, 100, !1, (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), RESIZE_OBSERVER_AVAILABLE ? (_this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_), _this.resizeObserver_.observe(player.el())) : (_this.loadListener_ = function() {
                        if (_this.el_ && _this.el_.contentWindow) {
                            var debouncedHandler_ = _this.debouncedHandler_, unloadListener_ = _this.unloadListener_ = function() {
                                off(this, "resize", debouncedHandler_), off(this, "unload", unloadListener_), unloadListener_ = null;
                            };
                            on(_this.el_.contentWindow, "unload", unloadListener_), on(_this.el_.contentWindow, "resize", debouncedHandler_);
                        }
                    }, _this.one("load", _this.loadListener_)), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(ResizeManager, _Component);
                var _proto = ResizeManager.prototype;
                return _proto.createEl = function() {
                    return _Component.prototype.createEl.call(this, "iframe", {
                        className: "vjs-resize-manager",
                        tabIndex: -1
                    }, {
                        "aria-hidden": "true"
                    });
                }, _proto.resizeHandler = function() {
                    this.player_ && this.player_.trigger && this.player_.trigger("playerresize");
                }, _proto.dispose = function() {
                    this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, _Component.prototype.dispose.call(this);
                }, ResizeManager;
            }(Component$1);
            Component$1.registerComponent("ResizeManager", ResizeManager);
            var defaults = {
                trackingThreshold: 20,
                liveTolerance: 15
            }, LiveTracker = function(_Component) {
                function LiveTracker(player, options) {
                    var _this, options_ = mergeOptions$3(defaults, options, {
                        createEl: !1
                    });
                    return (_this = _Component.call(this, player, options_) || this).handleVisibilityChange_ = function(e) {
                        return _this.handleVisibilityChange(e);
                    }, _this.trackLiveHandler_ = function() {
                        return _this.trackLive_();
                    }, _this.handlePlay_ = function(e) {
                        return _this.handlePlay(e);
                    }, _this.handleFirstTimeupdate_ = function(e) {
                        return _this.handleFirstTimeupdate(e);
                    }, _this.handleSeeked_ = function(e) {
                        return _this.handleSeeked(e);
                    }, _this.seekToLiveEdge_ = function(e) {
                        return _this.seekToLiveEdge(e);
                    }, _this.reset_(), _this.on(_this.player_, "durationchange", function(e) {
                        return _this.handleDurationchange(e);
                    }), _this.one(_this.player_, "canplay", function() {
                        return _this.toggleTracking();
                    }), IE_VERSION && "hidden" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && "visibilityState" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && _this.on(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "visibilitychange", _this.handleVisibilityChange_), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(LiveTracker, _Component);
                var _proto = LiveTracker.prototype;
                return _proto.handleVisibilityChange = function() {
                    this.player_.duration() === 1 / 0 && (global_document__WEBPACK_IMPORTED_MODULE_1___default().hidden ? this.stopTracking() : this.startTracking());
                }, _proto.trackLive_ = function() {
                    var seekable = this.player_.seekable();
                    if (seekable && seekable.length) {
                        var newTime = Number(global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now().toFixed(4)), deltaTime = -1 === this.lastTime_ ? 0 : (newTime - this.lastTime_) / 1000;
                        this.lastTime_ = newTime, this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
                        var liveCurrentTime = this.liveCurrentTime(), currentTime = this.player_.currentTime(), isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
                        this.timeupdateSeen_ && liveCurrentTime !== 1 / 0 || (isBehind = !1), isBehind !== this.behindLiveEdge_ && (this.behindLiveEdge_ = isBehind, this.trigger("liveedgechange"));
                    }
                }, _proto.handleDurationchange = function() {
                    this.toggleTracking();
                }, _proto.toggleTracking = function() {
                    this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking());
                }, _proto.startTracking = function() {
                    this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, 30), this.trackLive_(), this.on(this.player_, [
                        "play",
                        "pause"
                    ], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_)));
                }, _proto.handleFirstTimeupdate = function() {
                    this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_);
                }, _proto.handleSeeked = function() {
                    var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
                    this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2, this.nextSeekedFromUser_ = !1, this.trackLive_();
                }, _proto.handlePlay = function() {
                    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
                }, _proto.reset_ = function() {
                    this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, [
                        "play",
                        "pause"
                    ], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
                }, _proto.nextSeekedFromUser = function() {
                    this.nextSeekedFromUser_ = !0;
                }, _proto.stopTracking = function() {
                    this.isTracking() && (this.reset_(), this.trigger("liveedgechange"));
                }, _proto.seekableEnd = function() {
                    for(var seekable = this.player_.seekable(), seekableEnds = [], i = seekable ? seekable.length : 0; i--;)seekableEnds.push(seekable.end(i));
                    return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : 1 / 0;
                }, _proto.seekableStart = function() {
                    for(var seekable = this.player_.seekable(), seekableStarts = [], i = seekable ? seekable.length : 0; i--;)seekableStarts.push(seekable.start(i));
                    return seekableStarts.length ? seekableStarts.sort()[0] : 0;
                }, _proto.liveWindow = function() {
                    var liveCurrentTime = this.liveCurrentTime();
                    return liveCurrentTime === 1 / 0 ? 0 : liveCurrentTime - this.seekableStart();
                }, _proto.isLive = function() {
                    return this.isTracking();
                }, _proto.atLiveEdge = function() {
                    return !this.behindLiveEdge();
                }, _proto.liveCurrentTime = function() {
                    return this.pastSeekEnd() + this.seekableEnd();
                }, _proto.pastSeekEnd = function() {
                    var seekableEnd = this.seekableEnd();
                    return -1 !== this.lastSeekEnd_ && seekableEnd !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = seekableEnd, this.pastSeekEnd_;
                }, _proto.behindLiveEdge = function() {
                    return this.behindLiveEdge_;
                }, _proto.isTracking = function() {
                    return "number" == typeof this.trackingInterval_;
                }, _proto.seekToLiveEdge = function() {
                    this.seekedBehindLive_ = !1, this.atLiveEdge() || (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime()));
                }, _proto.dispose = function() {
                    this.off(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "visibilitychange", this.handleVisibilityChange_), this.stopTracking(), _Component.prototype.dispose.call(this);
                }, LiveTracker;
            }(Component$1);
            Component$1.registerComponent("LiveTracker", LiveTracker);
            var sourcesetLoad = function(tech) {
                var el = tech.el();
                if (el.hasAttribute("src")) return tech.triggerSourceset(el.src), !0;
                var sources = tech.$$("source"), srcUrls = [], src = "";
                if (!sources.length) return !1;
                for(var i = 0; i < sources.length; i++){
                    var url = sources[i].src;
                    url && -1 === srcUrls.indexOf(url) && srcUrls.push(url);
                }
                return !!srcUrls.length && (1 === srcUrls.length && (src = srcUrls[0]), tech.triggerSourceset(src), !0);
            }, innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
                get: function() {
                    return this.cloneNode(!0).innerHTML;
                },
                set: function(v) {
                    var dummy = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement(this.nodeName.toLowerCase());
                    dummy.innerHTML = v;
                    for(var docFrag = global_document__WEBPACK_IMPORTED_MODULE_1___default().createDocumentFragment(); dummy.childNodes.length;)docFrag.appendChild(dummy.childNodes[0]);
                    return this.innerText = "", global_window__WEBPACK_IMPORTED_MODULE_0___default().Element.prototype.appendChild.call(this, docFrag), this.innerHTML;
                }
            }), getDescriptor = function(priority, prop) {
                for(var descriptor = {}, i = 0; i < priority.length && (!(descriptor = Object.getOwnPropertyDescriptor(priority[i], prop)) || !descriptor.set || !descriptor.get); i++);
                return descriptor.enumerable = !0, descriptor.configurable = !0, descriptor;
            }, firstSourceWatch = function(tech) {
                var el = tech.el();
                if (!el.resetSourceWatch_) {
                    var old = {}, innerDescriptor = getDescriptor([
                        tech.el(),
                        global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLMediaElement.prototype,
                        global_window__WEBPACK_IMPORTED_MODULE_0___default().Element.prototype,
                        innerHTMLDescriptorPolyfill
                    ], "innerHTML"), appendWrapper = function(appendFn) {
                        return function() {
                            for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                            var retval = appendFn.apply(el, args);
                            return sourcesetLoad(tech), retval;
                        };
                    };
                    [
                        "append",
                        "appendChild",
                        "insertAdjacentHTML"
                    ].forEach(function(k) {
                        el[k] && (old[k] = el[k], el[k] = appendWrapper(old[k]));
                    }), Object.defineProperty(el, "innerHTML", mergeOptions$3(innerDescriptor, {
                        set: appendWrapper(innerDescriptor.set)
                    })), el.resetSourceWatch_ = function() {
                        el.resetSourceWatch_ = null, Object.keys(old).forEach(function(k) {
                            el[k] = old[k];
                        }), Object.defineProperty(el, "innerHTML", innerDescriptor);
                    }, tech.one("sourceset", el.resetSourceWatch_);
                }
            }, srcDescriptorPolyfill = Object.defineProperty({}, "src", {
                get: function() {
                    return this.hasAttribute("src") ? getAbsoluteURL(global_window__WEBPACK_IMPORTED_MODULE_0___default().Element.prototype.getAttribute.call(this, "src")) : "";
                },
                set: function(v) {
                    return global_window__WEBPACK_IMPORTED_MODULE_0___default().Element.prototype.setAttribute.call(this, "src", v), v;
                }
            }), setupSourceset = function(tech) {
                if (tech.featuresSourceset) {
                    var el = tech.el();
                    if (!el.resetSourceset_) {
                        var srcDescriptor = getDescriptor([
                            tech.el(),
                            global_window__WEBPACK_IMPORTED_MODULE_0___default().HTMLMediaElement.prototype,
                            srcDescriptorPolyfill
                        ], "src"), oldSetAttribute = el.setAttribute, oldLoad = el.load;
                        Object.defineProperty(el, "src", mergeOptions$3(srcDescriptor, {
                            set: function(v) {
                                var retval = srcDescriptor.set.call(el, v);
                                return tech.triggerSourceset(el.src), retval;
                            }
                        })), el.setAttribute = function(n, v) {
                            var retval = oldSetAttribute.call(el, n, v);
                            return /src/i.test(n) && tech.triggerSourceset(el.src), retval;
                        }, el.load = function() {
                            var retval = oldLoad.call(el);
                            return sourcesetLoad(tech) || (tech.triggerSourceset(""), firstSourceWatch(tech)), retval;
                        }, el.currentSrc ? tech.triggerSourceset(el.currentSrc) : sourcesetLoad(tech) || firstSourceWatch(tech), el.resetSourceset_ = function() {
                            el.resetSourceset_ = null, el.load = oldLoad, el.setAttribute = oldSetAttribute, Object.defineProperty(el, "src", srcDescriptor), el.resetSourceWatch_ && el.resetSourceWatch_();
                        };
                    }
                }
            }, defineLazyProperty = function(obj, key, getValue, setter) {
                void 0 === setter && (setter = !0);
                var set = function(value) {
                    return Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: !0,
                        writable: !0
                    });
                }, options = {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        var value = getValue();
                        return set(value), value;
                    }
                };
                return setter && (options.set = set), Object.defineProperty(obj, key, options);
            }, Html5 = function(_Tech) {
                function Html5(options, ready) {
                    _this = _Tech.call(this, options, ready) || this;
                    var _this, source = options.source, crossoriginTracks = !1;
                    if (source && (_this.el_.currentSrc !== source.src || options.tag && 3 === options.tag.initNetworkState_) ? _this.setSource(source) : _this.handleLateInit_(_this.el_), options.enableSourceset && _this.setupSourcesetHandling_(), _this.isScrubbing_ = !1, _this.el_.hasChildNodes()) {
                        for(var nodes = _this.el_.childNodes, nodesLength = nodes.length, removeNodes = []; nodesLength--;){
                            var node = nodes[nodesLength];
                            "track" === node.nodeName.toLowerCase() && (_this.featuresNativeTextTracks ? (_this.remoteTextTrackEls().addTrackElement_(node), _this.remoteTextTracks().addTrack(node.track), _this.textTracks().addTrack(node.track), !crossoriginTracks && !_this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src) && (crossoriginTracks = !0)) : removeNodes.push(node));
                        }
                        for(var i = 0; i < removeNodes.length; i++)_this.el_.removeChild(removeNodes[i]);
                    }
                    return _this.proxyNativeTracks_(), _this.featuresNativeTextTracks && crossoriginTracks && log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading."), _this.restoreMetadataTracksInIOSNativePlayer_(), (TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && !0 === options.nativeControlsForTouch && _this.setControls(!0), _this.proxyWebkitFullscreen_(), _this.triggerReady(), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Html5, _Tech);
                var _proto = Html5.prototype;
                return _proto.dispose = function() {
                    this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), Html5.disposeMediaElement(this.el_), this.options_ = null, _Tech.prototype.dispose.call(this);
                }, _proto.setupSourcesetHandling_ = function() {
                    setupSourceset(this);
                }, _proto.restoreMetadataTracksInIOSNativePlayer_ = function() {
                    var metadataTracksPreFullscreenState, textTracks = this.textTracks(), takeMetadataTrackSnapshot = function() {
                        metadataTracksPreFullscreenState = [];
                        for(var i = 0; i < textTracks.length; i++){
                            var track = textTracks[i];
                            "metadata" === track.kind && metadataTracksPreFullscreenState.push({
                                track: track,
                                storedMode: track.mode
                            });
                        }
                    };
                    takeMetadataTrackSnapshot(), textTracks.addEventListener("change", takeMetadataTrackSnapshot), this.on("dispose", function() {
                        return textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
                    });
                    var restoreTrackMode = function restoreTrackMode() {
                        for(var i = 0; i < metadataTracksPreFullscreenState.length; i++){
                            var storedTrack = metadataTracksPreFullscreenState[i];
                            "disabled" === storedTrack.track.mode && storedTrack.track.mode !== storedTrack.storedMode && (storedTrack.track.mode = storedTrack.storedMode);
                        }
                        textTracks.removeEventListener("change", restoreTrackMode);
                    };
                    this.on("webkitbeginfullscreen", function() {
                        textTracks.removeEventListener("change", takeMetadataTrackSnapshot), textTracks.removeEventListener("change", restoreTrackMode), textTracks.addEventListener("change", restoreTrackMode);
                    }), this.on("webkitendfullscreen", function() {
                        textTracks.removeEventListener("change", takeMetadataTrackSnapshot), textTracks.addEventListener("change", takeMetadataTrackSnapshot), textTracks.removeEventListener("change", restoreTrackMode);
                    });
                }, _proto.overrideNative_ = function(type, override) {
                    var _this2 = this;
                    if (override === this["featuresNative" + type + "Tracks"]) {
                        var lowerCaseType = type.toLowerCase();
                        this[lowerCaseType + "TracksListeners_"] && Object.keys(this[lowerCaseType + "TracksListeners_"]).forEach(function(eventName) {
                            _this2.el()[lowerCaseType + "Tracks"].removeEventListener(eventName, _this2[lowerCaseType + "TracksListeners_"][eventName]);
                        }), this["featuresNative" + type + "Tracks"] = !override, this[lowerCaseType + "TracksListeners_"] = null, this.proxyNativeTracksForType_(lowerCaseType);
                    }
                }, _proto.overrideNativeAudioTracks = function(override) {
                    this.overrideNative_("Audio", override);
                }, _proto.overrideNativeVideoTracks = function(override) {
                    this.overrideNative_("Video", override);
                }, _proto.proxyNativeTracksForType_ = function(name) {
                    var _this3 = this, props = NORMAL[name], elTracks = this.el()[props.getterName], techTracks = this[props.getterName]();
                    if (this["featuresNative" + props.capitalName + "Tracks"] && elTracks && elTracks.addEventListener) {
                        var listeners = {
                            change: function(e) {
                                var event = {
                                    type: "change",
                                    target: techTracks,
                                    currentTarget: techTracks,
                                    srcElement: techTracks
                                };
                                techTracks.trigger(event), "text" === name && _this3[REMOTE.remoteText.getterName]().trigger(event);
                            },
                            addtrack: function(e) {
                                techTracks.addTrack(e.track);
                            },
                            removetrack: function(e) {
                                techTracks.removeTrack(e.track);
                            }
                        }, removeOldTracks = function() {
                            for(var removeTracks = [], i = 0; i < techTracks.length; i++){
                                for(var found = !1, j = 0; j < elTracks.length; j++)if (elTracks[j] === techTracks[i]) {
                                    found = !0;
                                    break;
                                }
                                found || removeTracks.push(techTracks[i]);
                            }
                            for(; removeTracks.length;)techTracks.removeTrack(removeTracks.shift());
                        };
                        this[props.getterName + "Listeners_"] = listeners, Object.keys(listeners).forEach(function(eventName) {
                            var listener = listeners[eventName];
                            elTracks.addEventListener(eventName, listener), _this3.on("dispose", function(e) {
                                return elTracks.removeEventListener(eventName, listener);
                            });
                        }), this.on("loadstart", removeOldTracks), this.on("dispose", function(e) {
                            return _this3.off("loadstart", removeOldTracks);
                        });
                    }
                }, _proto.proxyNativeTracks_ = function() {
                    var _this4 = this;
                    NORMAL.names.forEach(function(name) {
                        _this4.proxyNativeTracksForType_(name);
                    });
                }, _proto.createEl = function() {
                    var el = this.options_.tag;
                    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
                        if (el) {
                            var clone = el.cloneNode(!0);
                            el.parentNode && el.parentNode.insertBefore(clone, el), Html5.disposeMediaElement(el), el = clone;
                        } else {
                            el = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("video");
                            var attributes = mergeOptions$3({}, this.options_.tag && getAttributes(this.options_.tag));
                            TOUCH_ENABLED && !0 === this.options_.nativeControlsForTouch || delete attributes.controls, setAttributes(el, assign(attributes, {
                                id: this.options_.techId,
                                class: "vjs-tech"
                            }));
                        }
                        el.playerId = this.options_.playerId;
                    }
                    void 0 !== this.options_.preload && setAttribute(el, "preload", this.options_.preload), void 0 !== this.options_.disablePictureInPicture && (el.disablePictureInPicture = this.options_.disablePictureInPicture);
                    for(var settingsAttrs = [
                        "loop",
                        "muted",
                        "playsinline",
                        "autoplay"
                    ], i = 0; i < settingsAttrs.length; i++){
                        var attr = settingsAttrs[i], value = this.options_[attr];
                        void 0 !== value && (value ? setAttribute(el, attr, attr) : removeAttribute(el, attr), el[attr] = value);
                    }
                    return el;
                }, _proto.handleLateInit_ = function(el) {
                    if (0 !== el.networkState && 3 !== el.networkState) {
                        if (0 === el.readyState) {
                            var loadstartFired = !1, setLoadstartFired = function() {
                                loadstartFired = !0;
                            };
                            this.on("loadstart", setLoadstartFired);
                            var triggerLoadstart = function() {
                                loadstartFired || this.trigger("loadstart");
                            };
                            this.on("loadedmetadata", triggerLoadstart), this.ready(function() {
                                this.off("loadstart", setLoadstartFired), this.off("loadedmetadata", triggerLoadstart), loadstartFired || this.trigger("loadstart");
                            });
                            return;
                        }
                        var eventsToTrigger = [
                            "loadstart"
                        ];
                        eventsToTrigger.push("loadedmetadata"), el.readyState >= 2 && eventsToTrigger.push("loadeddata"), el.readyState >= 3 && eventsToTrigger.push("canplay"), el.readyState >= 4 && eventsToTrigger.push("canplaythrough"), this.ready(function() {
                            eventsToTrigger.forEach(function(type) {
                                this.trigger(type);
                            }, this);
                        });
                    }
                }, _proto.setScrubbing = function(isScrubbing) {
                    this.isScrubbing_ = isScrubbing;
                }, _proto.scrubbing = function() {
                    return this.isScrubbing_;
                }, _proto.setCurrentTime = function(seconds) {
                    try {
                        this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI ? this.el_.fastSeek(seconds) : this.el_.currentTime = seconds;
                    } catch (e) {
                        log$1(e, "Video is not ready. (Video.js)");
                    }
                }, _proto.duration = function() {
                    var _this5 = this;
                    return this.el_.duration === 1 / 0 && IS_ANDROID && IS_CHROME && 0 === this.el_.currentTime ? (this.on("timeupdate", function checkProgress() {
                        _this5.el_.currentTime > 0 && (_this5.el_.duration === 1 / 0 && _this5.trigger("durationchange"), _this5.off("timeupdate", checkProgress));
                    }), NaN) : this.el_.duration || NaN;
                }, _proto.width = function() {
                    return this.el_.offsetWidth;
                }, _proto.height = function() {
                    return this.el_.offsetHeight;
                }, _proto.proxyWebkitFullscreen_ = function() {
                    var _this6 = this;
                    if ("webkitDisplayingFullscreen" in this.el_) {
                        var endFn = function() {
                            this.trigger("fullscreenchange", {
                                isFullscreen: !1
                            });
                        }, beginFn = function() {
                            "webkitPresentationMode" in this.el_ && "picture-in-picture" !== this.el_.webkitPresentationMode && (this.one("webkitendfullscreen", endFn), this.trigger("fullscreenchange", {
                                isFullscreen: !0,
                                nativeIOSFullscreen: !0
                            }));
                        };
                        this.on("webkitbeginfullscreen", beginFn), this.on("dispose", function() {
                            _this6.off("webkitbeginfullscreen", beginFn), _this6.off("webkitendfullscreen", endFn);
                        });
                    }
                }, _proto.supportsFullScreen = function() {
                    if ("function" == typeof this.el_.webkitEnterFullScreen) {
                        var userAgent = global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator && global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator.userAgent || "";
                        if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) return !0;
                    }
                    return !1;
                }, _proto.enterFullScreen = function() {
                    var video = this.el_;
                    if (video.paused && video.networkState <= video.HAVE_METADATA) silencePromise(this.el_.play()), this.setTimeout(function() {
                        video.pause();
                        try {
                            video.webkitEnterFullScreen();
                        } catch (e) {
                            this.trigger("fullscreenerror", e);
                        }
                    }, 0);
                    else try {
                        video.webkitEnterFullScreen();
                    } catch (e) {
                        this.trigger("fullscreenerror", e);
                    }
                }, _proto.exitFullScreen = function() {
                    if (!this.el_.webkitDisplayingFullscreen) {
                        this.trigger("fullscreenerror", Error("The video is not fullscreen"));
                        return;
                    }
                    this.el_.webkitExitFullScreen();
                }, _proto.requestPictureInPicture = function() {
                    return this.el_.requestPictureInPicture();
                }, _proto.src = function(_src) {
                    if (void 0 === _src) return this.el_.src;
                    this.setSrc(_src);
                }, _proto.reset = function() {
                    Html5.resetMediaElement(this.el_);
                }, _proto.currentSrc = function() {
                    return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc;
                }, _proto.setControls = function(val) {
                    this.el_.controls = !!val;
                }, _proto.addTextTrack = function(kind, label, language) {
                    return this.featuresNativeTextTracks ? this.el_.addTextTrack(kind, label, language) : _Tech.prototype.addTextTrack.call(this, kind, label, language);
                }, _proto.createRemoteTextTrack = function(options) {
                    if (!this.featuresNativeTextTracks) return _Tech.prototype.createRemoteTextTrack.call(this, options);
                    var htmlTrackElement = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("track");
                    return options.kind && (htmlTrackElement.kind = options.kind), options.label && (htmlTrackElement.label = options.label), (options.language || options.srclang) && (htmlTrackElement.srclang = options.language || options.srclang), options.default && (htmlTrackElement.default = options.default), options.id && (htmlTrackElement.id = options.id), options.src && (htmlTrackElement.src = options.src), htmlTrackElement;
                }, _proto.addRemoteTextTrack = function(options, manualCleanup) {
                    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);
                    return this.featuresNativeTextTracks && this.el().appendChild(htmlTrackElement), htmlTrackElement;
                }, _proto.removeRemoteTextTrack = function(track) {
                    if (_Tech.prototype.removeRemoteTextTrack.call(this, track), this.featuresNativeTextTracks) for(var tracks = this.$$("track"), i = tracks.length; i--;)(track === tracks[i] || track === tracks[i].track) && this.el().removeChild(tracks[i]);
                }, _proto.getVideoPlaybackQuality = function() {
                    if ("function" == typeof this.el().getVideoPlaybackQuality) return this.el().getVideoPlaybackQuality();
                    var videoPlaybackQuality = {};
                    return void 0 !== this.el().webkitDroppedFrameCount && void 0 !== this.el().webkitDecodedFrameCount && (videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount, videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount), global_window__WEBPACK_IMPORTED_MODULE_0___default().performance && "function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now ? videoPlaybackQuality.creationTime = global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.now() : global_window__WEBPACK_IMPORTED_MODULE_0___default().performance && global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.timing && "number" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.timing.navigationStart && (videoPlaybackQuality.creationTime = global_window__WEBPACK_IMPORTED_MODULE_0___default().Date.now() - global_window__WEBPACK_IMPORTED_MODULE_0___default().performance.timing.navigationStart), videoPlaybackQuality;
                }, Html5;
            }(Tech);
            defineLazyProperty(Html5, "TEST_VID", function() {
                if (isReal()) {
                    var video = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("video"), track = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("track");
                    return track.kind = "captions", track.srclang = "en", track.label = "English", video.appendChild(track), video;
                }
            }), Html5.isSupported = function() {
                try {
                    Html5.TEST_VID.volume = 0.5;
                } catch (e) {
                    return !1;
                }
                return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
            }, Html5.canPlayType = function(type) {
                return Html5.TEST_VID.canPlayType(type);
            }, Html5.canPlaySource = function(srcObj, options) {
                return Html5.canPlayType(srcObj.type);
            }, Html5.canControlVolume = function() {
                try {
                    var volume = Html5.TEST_VID.volume;
                    return Html5.TEST_VID.volume = volume / 2 + 0.1, volume !== Html5.TEST_VID.volume;
                } catch (e) {
                    return !1;
                }
            }, Html5.canMuteVolume = function() {
                try {
                    var muted = Html5.TEST_VID.muted;
                    return Html5.TEST_VID.muted = !muted, Html5.TEST_VID.muted ? setAttribute(Html5.TEST_VID, "muted", "muted") : removeAttribute(Html5.TEST_VID, "muted", "muted"), muted !== Html5.TEST_VID.muted;
                } catch (e) {
                    return !1;
                }
            }, Html5.canControlPlaybackRate = function() {
                if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) return !1;
                try {
                    var playbackRate = Html5.TEST_VID.playbackRate;
                    return Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1, playbackRate !== Html5.TEST_VID.playbackRate;
                } catch (e) {
                    return !1;
                }
            }, Html5.canOverrideAttributes = function() {
                try {
                    var noop = function() {};
                    Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("video"), "src", {
                        get: noop,
                        set: noop
                    }), Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("audio"), "src", {
                        get: noop,
                        set: noop
                    }), Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("video"), "innerHTML", {
                        get: noop,
                        set: noop
                    }), Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("audio"), "innerHTML", {
                        get: noop,
                        set: noop
                    });
                } catch (e) {
                    return !1;
                }
                return !0;
            }, Html5.supportsNativeTextTracks = function() {
                return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
            }, Html5.supportsNativeVideoTracks = function() {
                return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
            }, Html5.supportsNativeAudioTracks = function() {
                return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
            }, Html5.Events = [
                "loadstart",
                "suspend",
                "abort",
                "error",
                "emptied",
                "stalled",
                "loadedmetadata",
                "loadeddata",
                "canplay",
                "canplaythrough",
                "playing",
                "waiting",
                "seeking",
                "seeked",
                "ended",
                "durationchange",
                "timeupdate",
                "progress",
                "play",
                "pause",
                "ratechange",
                "resize",
                "volumechange"
            ], [
                [
                    "featuresVolumeControl",
                    "canControlVolume"
                ],
                [
                    "featuresMuteControl",
                    "canMuteVolume"
                ],
                [
                    "featuresPlaybackRate",
                    "canControlPlaybackRate"
                ],
                [
                    "featuresSourceset",
                    "canOverrideAttributes"
                ],
                [
                    "featuresNativeTextTracks",
                    "supportsNativeTextTracks"
                ],
                [
                    "featuresNativeVideoTracks",
                    "supportsNativeVideoTracks"
                ],
                [
                    "featuresNativeAudioTracks",
                    "supportsNativeAudioTracks"
                ]
            ].forEach(function(_ref) {
                var key = _ref[0], fn = _ref[1];
                defineLazyProperty(Html5.prototype, key, function() {
                    return Html5[fn]();
                }, !0);
            }), Html5.prototype.movingMediaElementInDOM = !IS_IOS, Html5.prototype.featuresFullscreenResize = !0, Html5.prototype.featuresProgressEvents = !0, Html5.prototype.featuresTimeupdateEvents = !0, Html5.patchCanPlayType = function() {
                !(ANDROID_VERSION >= 4.0) || IS_FIREFOX || IS_CHROME || (canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType, Html5.TEST_VID.constructor.prototype.canPlayType = function(type) {
                    return type && /^application\/(?:x-|vnd\.apple\.)mpegurl/i.test(type) ? "maybe" : canPlayType.call(this, type);
                });
            }, Html5.unpatchCanPlayType = function() {
                var r = Html5.TEST_VID.constructor.prototype.canPlayType;
                return canPlayType && (Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType), r;
            }, Html5.patchCanPlayType(), Html5.disposeMediaElement = function(el) {
                if (el) {
                    for(el.parentNode && el.parentNode.removeChild(el); el.hasChildNodes();)el.removeChild(el.firstChild);
                    el.removeAttribute("src"), "function" == typeof el.load && function() {
                        try {
                            el.load();
                        } catch (e) {}
                    }();
                }
            }, Html5.resetMediaElement = function(el) {
                if (el) {
                    for(var sources = el.querySelectorAll("source"), i = sources.length; i--;)el.removeChild(sources[i]);
                    el.removeAttribute("src"), "function" == typeof el.load && function() {
                        try {
                            el.load();
                        } catch (e) {}
                    }();
                }
            }, [
                "muted",
                "defaultMuted",
                "autoplay",
                "controls",
                "loop",
                "playsinline"
            ].forEach(function(prop) {
                Html5.prototype[prop] = function() {
                    return this.el_[prop] || this.el_.hasAttribute(prop);
                };
            }), [
                "muted",
                "defaultMuted",
                "autoplay",
                "loop",
                "playsinline"
            ].forEach(function(prop) {
                Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
                    this.el_[prop] = v, v ? this.el_.setAttribute(prop, prop) : this.el_.removeAttribute(prop);
                };
            }), [
                "paused",
                "currentTime",
                "buffered",
                "volume",
                "poster",
                "preload",
                "error",
                "seeking",
                "seekable",
                "ended",
                "playbackRate",
                "defaultPlaybackRate",
                "disablePictureInPicture",
                "played",
                "networkState",
                "readyState",
                "videoWidth",
                "videoHeight",
                "crossOrigin"
            ].forEach(function(prop) {
                Html5.prototype[prop] = function() {
                    return this.el_[prop];
                };
            }), [
                "volume",
                "src",
                "poster",
                "preload",
                "playbackRate",
                "defaultPlaybackRate",
                "disablePictureInPicture",
                "crossOrigin"
            ].forEach(function(prop) {
                Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
                    this.el_[prop] = v;
                };
            }), [
                "pause",
                "load",
                "play"
            ].forEach(function(prop) {
                Html5.prototype[prop] = function() {
                    return this.el_[prop]();
                };
            }), Tech.withSourceHandlers(Html5), Html5.nativeSourceHandler = {}, Html5.nativeSourceHandler.canPlayType = function(type) {
                try {
                    return Html5.TEST_VID.canPlayType(type);
                } catch (e) {
                    return "";
                }
            }, Html5.nativeSourceHandler.canHandleSource = function(source, options) {
                if (source.type) return Html5.nativeSourceHandler.canPlayType(source.type);
                if (source.src) {
                    var ext = getFileExtension(source.src);
                    return Html5.nativeSourceHandler.canPlayType("video/" + ext);
                }
                return "";
            }, Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
                tech.setSrc(source.src);
            }, Html5.nativeSourceHandler.dispose = function() {}, Html5.registerSourceHandler(Html5.nativeSourceHandler), Tech.registerTech("Html5", Html5);
            var TECH_EVENTS_RETRIGGER = [
                "progress",
                "abort",
                "suspend",
                "emptied",
                "stalled",
                "loadedmetadata",
                "loadeddata",
                "timeupdate",
                "resize",
                "volumechange",
                "texttrackchange"
            ], TECH_EVENTS_QUEUE = {
                canplay: "CanPlay",
                canplaythrough: "CanPlayThrough",
                playing: "Playing",
                seeked: "Seeked"
            }, BREAKPOINT_ORDER = [
                "tiny",
                "xsmall",
                "small",
                "medium",
                "large",
                "xlarge",
                "huge"
            ], BREAKPOINT_CLASSES = {};
            BREAKPOINT_ORDER.forEach(function(k) {
                var v = "x" === k.charAt(0) ? "x-" + k.substring(1) : k;
                BREAKPOINT_CLASSES[k] = "vjs-layout-" + v;
            });
            var DEFAULT_BREAKPOINTS = {
                tiny: 210,
                xsmall: 320,
                small: 425,
                medium: 768,
                large: 1440,
                xlarge: 2560,
                huge: 1 / 0
            }, Player = function(_Component) {
                function Player(tag, options, ready) {
                    if (tag.id = tag.id || options.id || "vjs_video_" + _guid++, (options = assign(Player.getTagSettings(tag), options)).initChildren = !1, options.createEl = !1, options.evented = !1, options.reportTouchActivity = !1, !options.language) {
                        if ("function" == typeof tag.closest) {
                            var _this, closest = tag.closest("[lang]");
                            closest && closest.getAttribute && (options.language = closest.getAttribute("lang"));
                        } else for(var element = tag; element && 1 === element.nodeType;){
                            if (getAttributes(element).hasOwnProperty("lang")) {
                                options.language = element.getAttribute("lang");
                                break;
                            }
                            element = element.parentNode;
                        }
                    }
                    if ((_this = _Component.call(this, null, options, ready) || this).boundDocumentFullscreenChange_ = function(e) {
                        return _this.documentFullscreenChange_(e);
                    }, _this.boundFullWindowOnEscKey_ = function(e) {
                        return _this.fullWindowOnEscKey(e);
                    }, _this.boundUpdateStyleEl_ = function(e) {
                        return _this.updateStyleEl_(e);
                    }, _this.boundApplyInitTime_ = function(e) {
                        return _this.applyInitTime_(e);
                    }, _this.boundUpdateCurrentBreakpoint_ = function(e) {
                        return _this.updateCurrentBreakpoint_(e);
                    }, _this.boundHandleTechClick_ = function(e) {
                        return _this.handleTechClick_(e);
                    }, _this.boundHandleTechDoubleClick_ = function(e) {
                        return _this.handleTechDoubleClick_(e);
                    }, _this.boundHandleTechTouchStart_ = function(e) {
                        return _this.handleTechTouchStart_(e);
                    }, _this.boundHandleTechTouchMove_ = function(e) {
                        return _this.handleTechTouchMove_(e);
                    }, _this.boundHandleTechTouchEnd_ = function(e) {
                        return _this.handleTechTouchEnd_(e);
                    }, _this.boundHandleTechTap_ = function(e) {
                        return _this.handleTechTap_(e);
                    }, _this.isFullscreen_ = !1, _this.log = createLogger(_this.id_), _this.fsApi_ = FullscreenApi, _this.isPosterFromTech_ = !1, _this.queuedCallbacks_ = [], _this.isReady_ = !1, _this.hasStarted_ = !1, _this.userActive_ = !1, _this.debugEnabled_ = !1, !_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) throw Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
                    if (_this.tag = tag, _this.tagAttributes = tag && getAttributes(tag), _this.language(_this.options_.language), options.languages) {
                        var languagesToLower = {};
                        Object.getOwnPropertyNames(options.languages).forEach(function(name) {
                            languagesToLower[name.toLowerCase()] = options.languages[name];
                        }), _this.languages_ = languagesToLower;
                    } else _this.languages_ = Player.prototype.options_.languages;
                    _this.resetCache_(), _this.poster_ = options.poster || "", _this.controls_ = !!options.controls, tag.controls = !1, tag.removeAttribute("controls"), _this.changingSrc_ = !1, _this.playCallbacks_ = [], _this.playTerminatedQueue_ = [], tag.hasAttribute("autoplay") ? _this.autoplay(!0) : _this.autoplay(_this.options_.autoplay), options.plugins && Object.keys(options.plugins).forEach(function(name) {
                        if ("function" != typeof _this[name]) throw Error('plugin "' + name + '" does not exist');
                    }), _this.scrubbing_ = !1, _this.el_ = _this.createEl(), evented((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), {
                        eventBusKey: "el_"
                    }), _this.fsApi_.requestFullscreen && (on(global_document__WEBPACK_IMPORTED_MODULE_1___default(), _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_), _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_)), _this.fluid_ && _this.on([
                        "playerreset",
                        "resize"
                    ], _this.boundUpdateStyleEl_);
                    var playerOptionsCopy = mergeOptions$3(_this.options_);
                    options.plugins && Object.keys(options.plugins).forEach(function(name) {
                        _this[name](options.plugins[name]);
                    }), options.debug && _this.debug(!0), _this.options_.playerOptions = playerOptionsCopy, _this.middleware_ = [], _this.playbackRates(options.playbackRates), _this.initChildren(), _this.isAudio("audio" === tag.nodeName.toLowerCase()), _this.controls() ? _this.addClass("vjs-controls-enabled") : _this.addClass("vjs-controls-disabled"), _this.el_.setAttribute("role", "region"), _this.isAudio() ? _this.el_.setAttribute("aria-label", _this.localize("Audio Player")) : _this.el_.setAttribute("aria-label", _this.localize("Video Player")), _this.isAudio() && _this.addClass("vjs-audio"), _this.flexNotSupported_() && _this.addClass("vjs-no-flex"), TOUCH_ENABLED && _this.addClass("vjs-touch-enabled"), IS_IOS || _this.addClass("vjs-workinghover"), Player.players[_this.id_] = (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this);
                    var majorVersion = version$5.split(".")[0];
                    return _this.addClass("vjs-v" + majorVersion), _this.userActive(!0), _this.reportUserActivity(), _this.one("play", function(e) {
                        return _this.listenForUserActivity_(e);
                    }), _this.on("stageclick", function(e) {
                        return _this.handleStageClick_(e);
                    }), _this.on("keydown", function(e) {
                        return _this.handleKeyDown(e);
                    }), _this.on("languagechange", function(e) {
                        return _this.handleLanguagechange(e);
                    }), _this.breakpoints(_this.options_.breakpoints), _this.responsive(_this.options_.responsive), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(Player, _Component);
                var _proto = Player.prototype;
                return _proto.dispose = function() {
                    var player, _this2 = this;
                    this.trigger("dispose"), this.off("dispose"), off(global_document__WEBPACK_IMPORTED_MODULE_1___default(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), off(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), Player.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), player = this, middlewareInstances[player.id()] = null, ALL.names.forEach(function(name) {
                        var list = _this2[ALL[name].getterName]();
                        list && list.off && list.off();
                    }), _Component.prototype.dispose.call(this);
                }, _proto.createEl = function() {
                    var el, tag = this.tag, playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player"), divEmbed = "video-js" === this.tag.tagName.toLowerCase();
                    playerElIngest ? el = this.el_ = tag.parentNode : divEmbed || (el = this.el_ = _Component.prototype.createEl.call(this, "div"));
                    var attrs = getAttributes(tag);
                    if (divEmbed) {
                        for(el = this.el_ = tag, tag = this.tag = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("video"); el.children.length;)tag.appendChild(el.firstChild);
                        hasClass(el, "video-js") || addClass(el, "video-js"), el.appendChild(tag), playerElIngest = this.playerElIngest_ = el, Object.keys(el).forEach(function(k) {
                            try {
                                tag[k] = el[k];
                            } catch (e) {}
                        });
                    }
                    if (tag.setAttribute("tabindex", "-1"), attrs.tabindex = "-1", (IE_VERSION || IS_CHROME && IS_WINDOWS) && (tag.setAttribute("role", "application"), attrs.role = "application"), tag.removeAttribute("width"), tag.removeAttribute("height"), "width" in attrs && delete attrs.width, "height" in attrs && delete attrs.height, Object.getOwnPropertyNames(attrs).forEach(function(attr) {
                        divEmbed && "class" === attr || el.setAttribute(attr, attrs[attr]), divEmbed && tag.setAttribute(attr, attrs[attr]);
                    }), tag.playerId = tag.id, tag.id += "_html5_api", tag.className = "vjs-tech", tag.player = el.player = this, this.addClass("vjs-paused"), !0 !== global_window__WEBPACK_IMPORTED_MODULE_0___default().VIDEOJS_NO_DYNAMIC_STYLE) {
                        this.styleEl_ = createStyleElement("vjs-styles-dimensions");
                        var defaultsStyleEl = $(".vjs-styles-defaults"), head = $("head");
                        head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
                    }
                    this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
                    for(var links = tag.getElementsByTagName("a"), i = 0; i < links.length; i++){
                        var linkEl = links.item(i);
                        addClass(linkEl, "vjs-hidden"), linkEl.setAttribute("hidden", "hidden");
                    }
                    return tag.initNetworkState_ = tag.networkState, tag.parentNode && !playerElIngest && tag.parentNode.insertBefore(el, tag), prependTo(tag, el), this.children_.unshift(tag), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = el, el;
                }, _proto.crossOrigin = function(value) {
                    if (!value) return this.techGet_("crossOrigin");
                    if ("anonymous" !== value && "use-credentials" !== value) {
                        log$1.warn('crossOrigin must be "anonymous" or "use-credentials", given "' + value + '"');
                        return;
                    }
                    this.techCall_("setCrossOrigin", value);
                }, _proto.width = function(value) {
                    return this.dimension("width", value);
                }, _proto.height = function(value) {
                    return this.dimension("height", value);
                }, _proto.dimension = function(_dimension, value) {
                    var privDimension = _dimension + "_";
                    if (void 0 === value) return this[privDimension] || 0;
                    if ("" === value || "auto" === value) {
                        this[privDimension] = void 0, this.updateStyleEl_();
                        return;
                    }
                    var parsedVal = parseFloat(value);
                    if (isNaN(parsedVal)) {
                        log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
                        return;
                    }
                    this[privDimension] = parsedVal, this.updateStyleEl_();
                }, _proto.fluid = function(bool) {
                    var _this3 = this;
                    if (void 0 === bool) return !!this.fluid_;
                    this.fluid_ = !!bool, isEvented(this) && this.off([
                        "playerreset",
                        "resize"
                    ], this.boundUpdateStyleEl_), bool ? (this.addClass("vjs-fluid"), this.fill(!1), addEventedCallback(this, function() {
                        _this3.on([
                            "playerreset",
                            "resize"
                        ], _this3.boundUpdateStyleEl_);
                    })) : this.removeClass("vjs-fluid"), this.updateStyleEl_();
                }, _proto.fill = function(bool) {
                    if (void 0 === bool) return !!this.fill_;
                    this.fill_ = !!bool, bool ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill");
                }, _proto.aspectRatio = function(ratio) {
                    if (void 0 === ratio) return this.aspectRatio_;
                    if (!/^\d+\:\d+$/.test(ratio)) throw Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
                    this.aspectRatio_ = ratio, this.fluid(!0), this.updateStyleEl_();
                }, _proto.updateStyleEl_ = function() {
                    if (!0 === global_window__WEBPACK_IMPORTED_MODULE_0___default().VIDEOJS_NO_DYNAMIC_STYLE) {
                        var width, height, idClass, _width = "number" == typeof this.width_ ? this.width_ : this.options_.width, _height = "number" == typeof this.height_ ? this.height_ : this.options_.height, techEl = this.tech_ && this.tech_.el();
                        techEl && (_width >= 0 && (techEl.width = _width), _height >= 0 && (techEl.height = _height));
                        return;
                    }
                    var ratioParts = (void 0 !== this.aspectRatio_ && "auto" !== this.aspectRatio_ ? this.aspectRatio_ : this.videoWidth() > 0 ? this.videoWidth() + ":" + this.videoHeight() : "16:9").split(":"), ratioMultiplier = ratioParts[1] / ratioParts[0];
                    width = void 0 !== this.width_ ? this.width_ : void 0 !== this.height_ ? this.height_ / ratioMultiplier : this.videoWidth() || 300, height = void 0 !== this.height_ ? this.height_ : width * ratioMultiplier, idClass = /^[^a-zA-Z]/.test(this.id()) ? "dimensions-" + this.id() : this.id() + "-dimensions", this.addClass(idClass), setTextContent(this.styleEl_, "\n      ." + idClass + " {\n        width: " + width + "px;\n        height: " + height + "px;\n      }\n\n      ." + idClass + ".vjs-fluid {\n        padding-top: " + 100 * ratioMultiplier + "%;\n      }\n    ");
                }, _proto.loadTech_ = function(techName, source) {
                    var _this4 = this;
                    this.tech_ && this.unloadTech_();
                    var titleTechName = toTitleCase$1(techName), camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
                    "Html5" !== titleTechName && this.tag && (Tech.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = titleTechName, this.isReady_ = !1;
                    var autoplay = this.autoplay();
                    ("string" == typeof this.autoplay() || !0 === this.autoplay() && this.options_.normalizeAutoplay) && (autoplay = !1);
                    var techOptions = {
                        source: source,
                        autoplay: autoplay,
                        nativeControlsForTouch: this.options_.nativeControlsForTouch,
                        playerId: this.id(),
                        techId: this.id() + "_" + camelTechName + "_api",
                        playsinline: this.options_.playsinline,
                        preload: this.options_.preload,
                        loop: this.options_.loop,
                        disablePictureInPicture: this.options_.disablePictureInPicture,
                        muted: this.options_.muted,
                        poster: this.poster(),
                        language: this.language(),
                        playerElIngest: this.playerElIngest_ || !1,
                        "vtt.js": this.options_["vtt.js"],
                        canOverridePoster: !!this.options_.techCanOverridePoster,
                        enableSourceset: this.options_.enableSourceset,
                        Promise: this.options_.Promise
                    };
                    ALL.names.forEach(function(name) {
                        var props = ALL[name];
                        techOptions[props.getterName] = _this4[props.privateName];
                    }), assign(techOptions, this.options_[titleTechName]), assign(techOptions, this.options_[camelTechName]), assign(techOptions, this.options_[techName.toLowerCase()]), this.tag && (techOptions.tag = this.tag), source && source.src === this.cache_.src && this.cache_.currentTime > 0 && (techOptions.startTime = this.cache_.currentTime);
                    var TechClass = Tech.getTech(techName);
                    if (!TechClass) throw Error("No Tech named '" + titleTechName + "' exists! '" + titleTechName + "' should be registered using videojs.registerTech()'");
                    this.tech_ = new TechClass(techOptions), this.tech_.ready(bind(this, this.handleTechReady_), !0), textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_), TECH_EVENTS_RETRIGGER.forEach(function(event) {
                        _this4.on(_this4.tech_, event, function(e) {
                            return _this4["handleTech" + toTitleCase$1(event) + "_"](e);
                        });
                    }), Object.keys(TECH_EVENTS_QUEUE).forEach(function(event) {
                        _this4.on(_this4.tech_, event, function(eventObj) {
                            if (0 === _this4.tech_.playbackRate() && _this4.tech_.seeking()) {
                                _this4.queuedCallbacks_.push({
                                    callback: _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"].bind(_this4),
                                    event: eventObj
                                });
                                return;
                            }
                            _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"](eventObj);
                        });
                    }), this.on(this.tech_, "loadstart", function(e) {
                        return _this4.handleTechLoadStart_(e);
                    }), this.on(this.tech_, "sourceset", function(e) {
                        return _this4.handleTechSourceset_(e);
                    }), this.on(this.tech_, "waiting", function(e) {
                        return _this4.handleTechWaiting_(e);
                    }), this.on(this.tech_, "ended", function(e) {
                        return _this4.handleTechEnded_(e);
                    }), this.on(this.tech_, "seeking", function(e) {
                        return _this4.handleTechSeeking_(e);
                    }), this.on(this.tech_, "play", function(e) {
                        return _this4.handleTechPlay_(e);
                    }), this.on(this.tech_, "firstplay", function(e) {
                        return _this4.handleTechFirstPlay_(e);
                    }), this.on(this.tech_, "pause", function(e) {
                        return _this4.handleTechPause_(e);
                    }), this.on(this.tech_, "durationchange", function(e) {
                        return _this4.handleTechDurationChange_(e);
                    }), this.on(this.tech_, "fullscreenchange", function(e, data) {
                        return _this4.handleTechFullscreenChange_(e, data);
                    }), this.on(this.tech_, "fullscreenerror", function(e, err) {
                        return _this4.handleTechFullscreenError_(e, err);
                    }), this.on(this.tech_, "enterpictureinpicture", function(e) {
                        return _this4.handleTechEnterPictureInPicture_(e);
                    }), this.on(this.tech_, "leavepictureinpicture", function(e) {
                        return _this4.handleTechLeavePictureInPicture_(e);
                    }), this.on(this.tech_, "error", function(e) {
                        return _this4.handleTechError_(e);
                    }), this.on(this.tech_, "posterchange", function(e) {
                        return _this4.handleTechPosterChange_(e);
                    }), this.on(this.tech_, "textdata", function(e) {
                        return _this4.handleTechTextData_(e);
                    }), this.on(this.tech_, "ratechange", function(e) {
                        return _this4.handleTechRateChange_(e);
                    }), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode === this.el() || "Html5" === titleTechName && this.tag || prependTo(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null);
                }, _proto.unloadTech_ = function() {
                    var _this5 = this;
                    ALL.names.forEach(function(name) {
                        var props = ALL[name];
                        _this5[props.privateName] = _this5[props.getterName]();
                    }), this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1;
                }, _proto.tech = function(safety) {
                    return void 0 === safety && log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n"), this.tech_;
                }, _proto.addTechControlsListeners_ = function() {
                    this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_);
                }, _proto.removeTechControlsListeners_ = function() {
                    this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
                }, _proto.handleTechReady_ = function() {
                    this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_();
                }, _proto.handleTechLoadStart_ = function() {
                    this.removeClass("vjs-ended"), this.removeClass("vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : (this.trigger("loadstart"), this.trigger("firstplay")), this.manualAutoplay_(!0 === this.autoplay() && this.options_.normalizeAutoplay ? "play" : this.autoplay());
                }, _proto.manualAutoplay_ = function(type) {
                    var promise, _this6 = this;
                    if (this.tech_ && "string" == typeof type) {
                        var resolveMuted = function() {
                            var previouslyMuted = _this6.muted();
                            _this6.muted(!0);
                            var restoreMuted = function() {
                                _this6.muted(previouslyMuted);
                            };
                            _this6.playTerminatedQueue_.push(restoreMuted);
                            var mutedPromise = _this6.play();
                            if (isPromise(mutedPromise)) return mutedPromise.catch(function(err) {
                                throw restoreMuted(), Error("Rejection at manualAutoplay. Restoring muted value. " + (err || ""));
                            });
                        };
                        if ("any" !== type || this.muted() ? promise = "muted" !== type || this.muted() ? this.play() : resolveMuted() : isPromise(promise = this.play()) && (promise = promise.catch(resolveMuted)), isPromise(promise)) return promise.then(function() {
                            _this6.trigger({
                                type: "autoplay-success",
                                autoplay: type
                            });
                        }).catch(function() {
                            _this6.trigger({
                                type: "autoplay-failure",
                                autoplay: type
                            });
                        });
                    }
                }, _proto.updateSourceCaches_ = function(srcObj) {
                    void 0 === srcObj && (srcObj = "");
                    var src = srcObj, type = "";
                    "string" != typeof src && (src = srcObj.src, type = srcObj.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], src && !type && (type = findMimetype(this, src)), this.cache_.source = mergeOptions$3({}, srcObj, {
                        src: src,
                        type: type
                    });
                    for(var matchingSources = this.cache_.sources.filter(function(s) {
                        return s.src && s.src === src;
                    }), sourceElSources = [], sourceEls = this.$$("source"), matchingSourceEls = [], i = 0; i < sourceEls.length; i++){
                        var sourceObj = getAttributes(sourceEls[i]);
                        sourceElSources.push(sourceObj), sourceObj.src && sourceObj.src === src && matchingSourceEls.push(sourceObj.src);
                    }
                    matchingSourceEls.length && !matchingSources.length ? this.cache_.sources = sourceElSources : matchingSources.length || (this.cache_.sources = [
                        this.cache_.source
                    ]), this.cache_.src = src;
                }, _proto.handleTechSourceset_ = function(event) {
                    var _this7 = this;
                    if (!this.changingSrc_) {
                        var updateSourceCaches = function(src) {
                            return _this7.updateSourceCaches_(src);
                        }, playerSrc = this.currentSource().src, eventSrc = event.src;
                        playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc) && (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) && (updateSourceCaches = function() {}), updateSourceCaches(eventSrc), event.src || this.tech_.any([
                            "sourceset",
                            "loadstart"
                        ], function(e) {
                            if ("sourceset" !== e.type) {
                                var techSrc = _this7.techGet("currentSrc");
                                _this7.lastSource_.tech = techSrc, _this7.updateSourceCaches_(techSrc);
                            }
                        });
                    }
                    this.lastSource_ = {
                        player: this.currentSource().src,
                        tech: event.src
                    }, this.trigger({
                        src: event.src,
                        type: "sourceset"
                    });
                }, _proto.hasStarted = function(request) {
                    if (void 0 === request) return this.hasStarted_;
                    request !== this.hasStarted_ && (this.hasStarted_ = request, this.hasStarted_ ? (this.addClass("vjs-has-started"), this.trigger("firstplay")) : this.removeClass("vjs-has-started"));
                }, _proto.handleTechPlay_ = function() {
                    this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play");
                }, _proto.handleTechRateChange_ = function() {
                    this.tech_.playbackRate() > 0 && 0 === this.cache_.lastPlaybackRate && (this.queuedCallbacks_.forEach(function(queued) {
                        return queued.callback(queued.event);
                    }), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange");
                }, _proto.handleTechWaiting_ = function() {
                    var _this8 = this;
                    this.addClass("vjs-waiting"), this.trigger("waiting");
                    var timeWhenWaiting = this.currentTime();
                    this.on("timeupdate", function timeUpdateListener() {
                        timeWhenWaiting !== _this8.currentTime() && (_this8.removeClass("vjs-waiting"), _this8.off("timeupdate", timeUpdateListener));
                    });
                }, _proto.handleTechCanPlay_ = function() {
                    this.removeClass("vjs-waiting"), this.trigger("canplay");
                }, _proto.handleTechCanPlayThrough_ = function() {
                    this.removeClass("vjs-waiting"), this.trigger("canplaythrough");
                }, _proto.handleTechPlaying_ = function() {
                    this.removeClass("vjs-waiting"), this.trigger("playing");
                }, _proto.handleTechSeeking_ = function() {
                    this.addClass("vjs-seeking"), this.trigger("seeking");
                }, _proto.handleTechSeeked_ = function() {
                    this.removeClass("vjs-seeking"), this.removeClass("vjs-ended"), this.trigger("seeked");
                }, _proto.handleTechFirstPlay_ = function() {
                    this.options_.starttime && (log$1.warn("Passing the `starttime` option to the player will be deprecated in 6.0"), this.currentTime(this.options_.starttime)), this.addClass("vjs-has-started"), this.trigger("firstplay");
                }, _proto.handleTechPause_ = function() {
                    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause");
                }, _proto.handleTechEnded_ = function() {
                    this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended");
                }, _proto.handleTechDurationChange_ = function() {
                    this.duration(this.techGet_("duration"));
                }, _proto.handleTechClick_ = function(event) {
                    this.controls_ && (void 0 === this.options_ || void 0 === this.options_.userActions || void 0 === this.options_.userActions.click || !1 !== this.options_.userActions.click) && (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" == typeof this.options_.userActions.click ? this.options_.userActions.click.call(this, event) : this.paused() ? silencePromise(this.play()) : this.pause());
                }, _proto.handleTechDoubleClick_ = function(event) {
                    this.controls_ && (Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), function(el) {
                        return el.contains(event.target);
                    }) || void 0 !== this.options_ && void 0 !== this.options_.userActions && void 0 !== this.options_.userActions.doubleClick && !1 === this.options_.userActions.doubleClick || (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" == typeof this.options_.userActions.doubleClick ? this.options_.userActions.doubleClick.call(this, event) : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen()));
                }, _proto.handleTechTap_ = function() {
                    this.userActive(!this.userActive());
                }, _proto.handleTechTouchStart_ = function() {
                    this.userWasActive = this.userActive();
                }, _proto.handleTechTouchMove_ = function() {
                    this.userWasActive && this.reportUserActivity();
                }, _proto.handleTechTouchEnd_ = function(event) {
                    event.cancelable && event.preventDefault();
                }, _proto.handleStageClick_ = function() {
                    this.reportUserActivity();
                }, _proto.toggleFullscreenClass_ = function() {
                    this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen");
                }, _proto.documentFullscreenChange_ = function(e) {
                    var targetPlayer = e.target.player;
                    if (!targetPlayer || targetPlayer === this) {
                        var el = this.el(), isFs = global_document__WEBPACK_IMPORTED_MODULE_1___default()[this.fsApi_.fullscreenElement] === el;
                        !isFs && el.matches ? isFs = el.matches(":" + this.fsApi_.fullscreen) : !isFs && el.msMatchesSelector && (isFs = el.msMatchesSelector(":" + this.fsApi_.fullscreen)), this.isFullscreen(isFs);
                    }
                }, _proto.handleTechFullscreenChange_ = function(event, data) {
                    data && (data.nativeIOSFullscreen && this.toggleClass("vjs-ios-native-fs"), this.isFullscreen(data.isFullscreen));
                }, _proto.handleTechFullscreenError_ = function(event, err) {
                    this.trigger("fullscreenerror", err);
                }, _proto.togglePictureInPictureClass_ = function() {
                    this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture");
                }, _proto.handleTechEnterPictureInPicture_ = function(event) {
                    this.isInPictureInPicture(!0);
                }, _proto.handleTechLeavePictureInPicture_ = function(event) {
                    this.isInPictureInPicture(!1);
                }, _proto.handleTechError_ = function() {
                    var error = this.tech_.error();
                    this.error(error);
                }, _proto.handleTechTextData_ = function() {
                    var data = null;
                    arguments.length > 1 && (data = arguments[1]), this.trigger("textdata", data);
                }, _proto.getCache = function() {
                    return this.cache_;
                }, _proto.resetCache_ = function() {
                    this.cache_ = {
                        currentTime: 0,
                        initTime: 0,
                        inactivityTimeout: this.options_.inactivityTimeout,
                        duration: NaN,
                        lastVolume: 1,
                        lastPlaybackRate: this.defaultPlaybackRate(),
                        media: null,
                        src: "",
                        source: {},
                        sources: [],
                        playbackRates: [],
                        volume: 1
                    };
                }, _proto.techCall_ = function(method, arg) {
                    this.ready(function() {
                        if (method in allowedSetters) {
                            var middleware;
                            return middleware = this.middleware_, this.tech_[method](middleware.reduce(middlewareIterator(method), arg));
                        }
                        if (method in allowedMediators) return mediate(this.middleware_, this.tech_, method, arg);
                        try {
                            this.tech_ && this.tech_[method](arg);
                        } catch (e) {
                            throw log$1(e), e;
                        }
                    }, !0);
                }, _proto.techGet_ = function(method) {
                    if (this.tech_ && this.tech_.isReady_) {
                        if (method in allowedGetters) {
                            var middleware, tech;
                            return middleware = this.middleware_, tech = this.tech_, middleware.reduceRight(middlewareIterator(method), tech[method]());
                        }
                        if (method in allowedMediators) return mediate(this.middleware_, this.tech_, method);
                        try {
                            return this.tech_[method]();
                        } catch (e) {
                            if (void 0 === this.tech_[method]) throw log$1("Video.js: " + method + " method not defined for " + this.techName_ + " playback technology.", e), e;
                            if ("TypeError" === e.name) throw log$1("Video.js: " + method + " unavailable on " + this.techName_ + " playback technology element.", e), this.tech_.isReady_ = !1, e;
                            throw log$1(e), e;
                        }
                    }
                }, _proto.play = function() {
                    var _this9 = this, PromiseClass = this.options_.Promise || global_window__WEBPACK_IMPORTED_MODULE_0___default().Promise;
                    return PromiseClass ? new PromiseClass(function(resolve) {
                        _this9.play_(resolve);
                    }) : this.play_();
                }, _proto.play_ = function(callback) {
                    var _this10 = this;
                    void 0 === callback && (callback = silencePromise), this.playCallbacks_.push(callback);
                    var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
                    if (this.waitToPlay_ && (this.off([
                        "ready",
                        "loadstart"
                    ], this.waitToPlay_), this.waitToPlay_ = null), !this.isReady_ || !isSrcReady) {
                        this.waitToPlay_ = function(e) {
                            _this10.play_();
                        }, this.one([
                            "ready",
                            "loadstart"
                        ], this.waitToPlay_), !isSrcReady && (IS_ANY_SAFARI || IS_IOS) && this.load();
                        return;
                    }
                    var val = this.techGet_("play");
                    null === val ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(val);
                }, _proto.runPlayTerminatedQueue_ = function() {
                    var queue = this.playTerminatedQueue_.slice(0);
                    this.playTerminatedQueue_ = [], queue.forEach(function(q) {
                        q();
                    });
                }, _proto.runPlayCallbacks_ = function(val) {
                    var callbacks = this.playCallbacks_.slice(0);
                    this.playCallbacks_ = [], this.playTerminatedQueue_ = [], callbacks.forEach(function(cb) {
                        cb(val);
                    });
                }, _proto.pause = function() {
                    this.techCall_("pause");
                }, _proto.paused = function() {
                    return !1 !== this.techGet_("paused");
                }, _proto.played = function() {
                    return this.techGet_("played") || createTimeRanges(0, 0);
                }, _proto.scrubbing = function(isScrubbing) {
                    if (void 0 === isScrubbing) return this.scrubbing_;
                    this.scrubbing_ = !!isScrubbing, this.techCall_("setScrubbing", this.scrubbing_), isScrubbing ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing");
                }, _proto.currentTime = function(seconds) {
                    if (void 0 !== seconds) {
                        if (seconds < 0 && (seconds = 0), !this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
                            this.cache_.initTime = seconds, this.off("canplay", this.boundApplyInitTime_), this.one("canplay", this.boundApplyInitTime_);
                            return;
                        }
                        this.techCall_("setCurrentTime", seconds), this.cache_.initTime = 0;
                        return;
                    }
                    return this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime;
                }, _proto.applyInitTime_ = function() {
                    this.currentTime(this.cache_.initTime);
                }, _proto.duration = function(seconds) {
                    if (void 0 === seconds) return void 0 !== this.cache_.duration ? this.cache_.duration : NaN;
                    (seconds = parseFloat(seconds)) < 0 && (seconds = 1 / 0), seconds === this.cache_.duration || (this.cache_.duration = seconds, seconds === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(seconds) || this.trigger("durationchange"));
                }, _proto.remainingTime = function() {
                    return this.duration() - this.currentTime();
                }, _proto.remainingTimeDisplay = function() {
                    return Math.floor(this.duration()) - Math.floor(this.currentTime());
                }, _proto.buffered = function() {
                    var buffered = this.techGet_("buffered");
                    return buffered && buffered.length || (buffered = createTimeRanges(0, 0)), buffered;
                }, _proto.bufferedPercent = function() {
                    return bufferedPercent(this.buffered(), this.duration());
                }, _proto.bufferedEnd = function() {
                    var buffered = this.buffered(), duration = this.duration(), end = buffered.end(buffered.length - 1);
                    return end > duration && (end = duration), end;
                }, _proto.volume = function(percentAsDecimal) {
                    var vol;
                    if (void 0 !== percentAsDecimal) {
                        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))), this.cache_.volume = vol, this.techCall_("setVolume", vol), vol > 0 && this.lastVolume_(vol);
                        return;
                    }
                    return isNaN(vol = parseFloat(this.techGet_("volume"))) ? 1 : vol;
                }, _proto.muted = function(_muted) {
                    if (void 0 !== _muted) {
                        this.techCall_("setMuted", _muted);
                        return;
                    }
                    return this.techGet_("muted") || !1;
                }, _proto.defaultMuted = function(_defaultMuted) {
                    return void 0 !== _defaultMuted ? this.techCall_("setDefaultMuted", _defaultMuted) : this.techGet_("defaultMuted") || !1;
                }, _proto.lastVolume_ = function(percentAsDecimal) {
                    if (void 0 !== percentAsDecimal && 0 !== percentAsDecimal) {
                        this.cache_.lastVolume = percentAsDecimal;
                        return;
                    }
                    return this.cache_.lastVolume;
                }, _proto.supportsFullScreen = function() {
                    return this.techGet_("supportsFullScreen") || !1;
                }, _proto.isFullscreen = function(isFS) {
                    if (void 0 !== isFS) {
                        var oldValue = this.isFullscreen_;
                        this.isFullscreen_ = Boolean(isFS), this.isFullscreen_ !== oldValue && this.fsApi_.prefixed && this.trigger("fullscreenchange"), this.toggleFullscreenClass_();
                        return;
                    }
                    return this.isFullscreen_;
                }, _proto.requestFullscreen = function(fullscreenOptions) {
                    var PromiseClass = this.options_.Promise || global_window__WEBPACK_IMPORTED_MODULE_0___default().Promise;
                    if (PromiseClass) {
                        var self1 = this;
                        return new PromiseClass(function(resolve, reject) {
                            function offHandler() {
                                self1.off("fullscreenerror", errorHandler), self1.off("fullscreenchange", changeHandler);
                            }
                            function changeHandler() {
                                offHandler(), resolve();
                            }
                            function errorHandler(e, err) {
                                offHandler(), reject(err);
                            }
                            self1.one("fullscreenchange", changeHandler), self1.one("fullscreenerror", errorHandler);
                            var promise = self1.requestFullscreenHelper_(fullscreenOptions);
                            promise && (promise.then(offHandler, offHandler), promise.then(resolve, reject));
                        });
                    }
                    return this.requestFullscreenHelper_();
                }, _proto.requestFullscreenHelper_ = function(fullscreenOptions) {
                    var fsOptions, _this11 = this;
                    if (this.fsApi_.prefixed || (fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {}, void 0 === fullscreenOptions || (fsOptions = fullscreenOptions)), this.fsApi_.requestFullscreen) {
                        var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
                        return promise && promise.then(function() {
                            return _this11.isFullscreen(!0);
                        }, function() {
                            return _this11.isFullscreen(!1);
                        }), promise;
                    }
                    this.tech_.supportsFullScreen() && !0 == !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow();
                }, _proto.exitFullscreen = function() {
                    var PromiseClass = this.options_.Promise || global_window__WEBPACK_IMPORTED_MODULE_0___default().Promise;
                    if (PromiseClass) {
                        var self1 = this;
                        return new PromiseClass(function(resolve, reject) {
                            function offHandler() {
                                self1.off("fullscreenerror", errorHandler), self1.off("fullscreenchange", changeHandler);
                            }
                            function changeHandler() {
                                offHandler(), resolve();
                            }
                            function errorHandler(e, err) {
                                offHandler(), reject(err);
                            }
                            self1.one("fullscreenchange", changeHandler), self1.one("fullscreenerror", errorHandler);
                            var promise = self1.exitFullscreenHelper_();
                            promise && (promise.then(offHandler, offHandler), promise.then(resolve, reject));
                        });
                    }
                    return this.exitFullscreenHelper_();
                }, _proto.exitFullscreenHelper_ = function() {
                    var _this12 = this;
                    if (this.fsApi_.requestFullscreen) {
                        var promise = global_document__WEBPACK_IMPORTED_MODULE_1___default()[this.fsApi_.exitFullscreen]();
                        return promise && silencePromise(promise.then(function() {
                            return _this12.isFullscreen(!1);
                        })), promise;
                    }
                    this.tech_.supportsFullScreen() && !0 == !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow();
                }, _proto.enterFullWindow = function() {
                    this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = global_document__WEBPACK_IMPORTED_MODULE_1___default().documentElement.style.overflow, on(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "keydown", this.boundFullWindowOnEscKey_), global_document__WEBPACK_IMPORTED_MODULE_1___default().documentElement.style.overflow = "hidden", addClass(global_document__WEBPACK_IMPORTED_MODULE_1___default().body, "vjs-full-window"), this.trigger("enterFullWindow");
                }, _proto.fullWindowOnEscKey = function(event) {
                    keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(event, "Esc") && !0 === this.isFullscreen() && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen());
                }, _proto.exitFullWindow = function() {
                    this.isFullscreen(!1), this.isFullWindow = !1, off(global_document__WEBPACK_IMPORTED_MODULE_1___default(), "keydown", this.boundFullWindowOnEscKey_), global_document__WEBPACK_IMPORTED_MODULE_1___default().documentElement.style.overflow = this.docOrigOverflow, removeClass(global_document__WEBPACK_IMPORTED_MODULE_1___default().body, "vjs-full-window"), this.trigger("exitFullWindow");
                }, _proto.disablePictureInPicture = function(value) {
                    if (void 0 === value) return this.techGet_("disablePictureInPicture");
                    this.techCall_("setDisablePictureInPicture", value), this.options_.disablePictureInPicture = value, this.trigger("disablepictureinpicturechanged");
                }, _proto.isInPictureInPicture = function(isPiP) {
                    if (void 0 !== isPiP) {
                        this.isInPictureInPicture_ = !!isPiP, this.togglePictureInPictureClass_();
                        return;
                    }
                    return !!this.isInPictureInPicture_;
                }, _proto.requestPictureInPicture = function() {
                    if ("pictureInPictureEnabled" in global_document__WEBPACK_IMPORTED_MODULE_1___default() && !1 === this.disablePictureInPicture()) return this.techGet_("requestPictureInPicture");
                }, _proto.exitPictureInPicture = function() {
                    if ("pictureInPictureEnabled" in global_document__WEBPACK_IMPORTED_MODULE_1___default()) return global_document__WEBPACK_IMPORTED_MODULE_1___default().exitPictureInPicture();
                }, _proto.handleKeyDown = function(event) {
                    var el, tagName, userActions = this.options_.userActions;
                    userActions && userActions.hotkeys && (tagName = (el = this.el_.ownerDocument.activeElement).tagName.toLowerCase(), el.isContentEditable || ("input" === tagName ? -1 === [
                        "button",
                        "checkbox",
                        "hidden",
                        "radio",
                        "reset",
                        "submit"
                    ].indexOf(el.type) : -1 !== [
                        "textarea"
                    ].indexOf(tagName)) || ("function" == typeof userActions.hotkeys ? userActions.hotkeys.call(this, event) : this.handleHotkeys(event)));
                }, _proto.handleHotkeys = function(event) {
                    var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {}, _hotkeys$fullscreenKe = hotkeys.fullscreenKey, _hotkeys$muteKey = hotkeys.muteKey, _hotkeys$playPauseKey = hotkeys.playPauseKey;
                    if ((void 0 === _hotkeys$fullscreenKe ? function(keydownEvent) {
                        return keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(keydownEvent, "f");
                    } : _hotkeys$fullscreenKe).call(this, event)) {
                        event.preventDefault(), event.stopPropagation();
                        var FSToggle = Component$1.getComponent("FullscreenToggle");
                        !1 !== global_document__WEBPACK_IMPORTED_MODULE_1___default()[this.fsApi_.fullscreenEnabled] && FSToggle.prototype.handleClick.call(this, event);
                    } else (void 0 === _hotkeys$muteKey ? function(keydownEvent) {
                        return keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(keydownEvent, "m");
                    } : _hotkeys$muteKey).call(this, event) ? (event.preventDefault(), event.stopPropagation(), Component$1.getComponent("MuteToggle").prototype.handleClick.call(this, event)) : (void 0 === _hotkeys$playPauseKey ? function(keydownEvent) {
                        return keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(keydownEvent, "k") || keycode__WEBPACK_IMPORTED_MODULE_3___default().isEventKey(keydownEvent, "Space");
                    } : _hotkeys$playPauseKey).call(this, event) && (event.preventDefault(), event.stopPropagation(), Component$1.getComponent("PlayToggle").prototype.handleClick.call(this, event));
                }, _proto.canPlayType = function(type) {
                    for(var can, i = 0, j = this.options_.techOrder; i < j.length; i++){
                        var techName = j[i], tech = Tech.getTech(techName);
                        if (tech || (tech = Component$1.getComponent(techName)), !tech) {
                            log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
                            continue;
                        }
                        if (tech.isSupported() && (can = tech.canPlayType(type))) return can;
                    }
                    return "";
                }, _proto.selectSource = function(sources) {
                    var _this13 = this, techs = this.options_.techOrder.map(function(techName) {
                        return [
                            techName,
                            Tech.getTech(techName)
                        ];
                    }).filter(function(_ref) {
                        var techName = _ref[0], tech = _ref[1];
                        return tech ? tech.isSupported() : (log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.'), !1);
                    }), findFirstPassingTechSourcePair = function(outerArray, innerArray, tester) {
                        var found;
                        return outerArray.some(function(outerChoice) {
                            return innerArray.some(function(innerChoice) {
                                if (found = tester(outerChoice, innerChoice)) return !0;
                            });
                        }), found;
                    }, finder = function(_ref2, source) {
                        var techName = _ref2[0];
                        if (_ref2[1].canPlaySource(source, _this13.options_[techName.toLowerCase()])) return {
                            source: source,
                            tech: techName
                        };
                    };
                    return (this.options_.sourceOrder ? findFirstPassingTechSourcePair(sources, techs, function(a, b) {
                        return finder(b, a);
                    }) : findFirstPassingTechSourcePair(techs, sources, finder)) || !1;
                }, _proto.handleSrc_ = function(source, isRetry) {
                    var _this14 = this;
                    if (void 0 === source) return this.cache_.src || "";
                    this.resetRetryOnError_ && this.resetRetryOnError_();
                    var sources = filterSource(source);
                    if (!sources.length) {
                        this.setTimeout(function() {
                            this.error({
                                code: 4,
                                message: this.localize(this.options_.notSupportedMessage)
                            });
                        }, 0);
                        return;
                    }
                    if (this.changingSrc_ = !0, isRetry || (this.cache_.sources = sources), this.updateSourceCaches_(sources[0]), function(player, src, next) {
                        player.setTimeout(function() {
                            return function setSourceHelper(src, middleware, next, player, acc, lastRun) {
                                void 0 === src && (src = {}), void 0 === middleware && (middleware = []), void 0 === acc && (acc = []), void 0 === lastRun && (lastRun = !1);
                                var _middleware = middleware, mwFactory = _middleware[0], mwrest = _middleware.slice(1);
                                if ("string" == typeof mwFactory) setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
                                else if (mwFactory) {
                                    var mw = function(player, mwFactory) {
                                        var mws = middlewareInstances[player.id()], mw = null;
                                        if (null == mws) return mw = mwFactory(player), middlewareInstances[player.id()] = [
                                            [
                                                mwFactory,
                                                mw
                                            ]
                                        ], mw;
                                        for(var i = 0; i < mws.length; i++){
                                            var _mws$i = mws[i], mwf = _mws$i[0], mwi = _mws$i[1];
                                            mwf === mwFactory && (mw = mwi);
                                        }
                                        return null === mw && (mw = mwFactory(player), mws.push([
                                            mwFactory,
                                            mw
                                        ])), mw;
                                    }(player, mwFactory);
                                    if (!mw.setSource) return acc.push(mw), setSourceHelper(src, mwrest, next, player, acc, lastRun);
                                    mw.setSource(assign({}, src), function(err, _src) {
                                        if (err) return setSourceHelper(src, mwrest, next, player, acc, lastRun);
                                        acc.push(mw), setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
                                    });
                                } else mwrest.length ? setSourceHelper(src, mwrest, next, player, acc, lastRun) : lastRun ? next(src, acc) : setSourceHelper(src, middlewares["*"], next, player, acc, !0);
                            }(src, middlewares[src.type], next, player);
                        }, 1);
                    }(this, sources[0], function(middlewareSource, mws) {
                        if (_this14.middleware_ = mws, isRetry || (_this14.cache_.sources = sources), _this14.updateSourceCaches_(middlewareSource), _this14.src_(middlewareSource)) return sources.length > 1 ? _this14.handleSrc_(sources.slice(1)) : (_this14.changingSrc_ = !1, _this14.setTimeout(function() {
                            this.error({
                                code: 4,
                                message: this.localize(this.options_.notSupportedMessage)
                            });
                        }, 0), void _this14.triggerReady());
                        !function(middleware, tech) {
                            middleware.forEach(function(mw) {
                                return mw.setTech && mw.setTech(tech);
                            });
                        }(mws, _this14.tech_);
                    }), this.options_.retryOnError && sources.length > 1) {
                        var retry = function() {
                            _this14.error(null), _this14.handleSrc_(sources.slice(1), !0);
                        }, stopListeningForErrors = function() {
                            _this14.off("error", retry);
                        };
                        this.one("error", retry), this.one("playing", stopListeningForErrors), this.resetRetryOnError_ = function() {
                            _this14.off("error", retry), _this14.off("playing", stopListeningForErrors);
                        };
                    }
                }, _proto.src = function(source) {
                    return this.handleSrc_(source, !1);
                }, _proto.src_ = function(source) {
                    var str1, str2, _this15 = this, sourceTech = this.selectSource([
                        source
                    ]);
                    return !sourceTech || ((str1 = sourceTech.tech, str2 = this.techName_, toTitleCase$1(str1) !== toTitleCase$1(str2)) ? (this.changingSrc_ = !0, this.loadTech_(sourceTech.tech, sourceTech.source), this.tech_.ready(function() {
                        _this15.changingSrc_ = !1;
                    }), !1) : (this.ready(function() {
                        this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", source) : this.techCall_("src", source.src), this.changingSrc_ = !1;
                    }, !0), !1));
                }, _proto.load = function() {
                    this.techCall_("load");
                }, _proto.reset = function() {
                    var _this16 = this, PromiseClass = this.options_.Promise || global_window__WEBPACK_IMPORTED_MODULE_0___default().Promise;
                    this.paused() || !PromiseClass ? this.doReset_() : silencePromise(this.play().then(function() {
                        return _this16.doReset_();
                    }));
                }, _proto.doReset_ = function() {
                    this.tech_ && this.tech_.clearTracks("text"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), isEvented(this) && this.trigger("playerreset");
                }, _proto.resetControlBarUI_ = function() {
                    this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_();
                }, _proto.resetProgressBar_ = function() {
                    this.currentTime(0);
                    var _this$controlBar = this.controlBar, durationDisplay = _this$controlBar.durationDisplay, remainingTimeDisplay = _this$controlBar.remainingTimeDisplay;
                    durationDisplay && durationDisplay.updateContent(), remainingTimeDisplay && remainingTimeDisplay.updateContent();
                }, _proto.resetPlaybackRate_ = function() {
                    this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_();
                }, _proto.resetVolumeBar_ = function() {
                    this.volume(1.0), this.trigger("volumechange");
                }, _proto.currentSources = function() {
                    var source = this.currentSource(), sources = [];
                    return 0 !== Object.keys(source).length && sources.push(source), this.cache_.sources || sources;
                }, _proto.currentSource = function() {
                    return this.cache_.source || {};
                }, _proto.currentSrc = function() {
                    return this.currentSource() && this.currentSource().src || "";
                }, _proto.currentType = function() {
                    return this.currentSource() && this.currentSource().type || "";
                }, _proto.preload = function(value) {
                    if (void 0 !== value) {
                        this.techCall_("setPreload", value), this.options_.preload = value;
                        return;
                    }
                    return this.techGet_("preload");
                }, _proto.autoplay = function(value) {
                    var techAutoplay;
                    if (void 0 === value) return this.options_.autoplay || !1;
                    "string" == typeof value && /(any|play|muted)/.test(value) || !0 === value && this.options_.normalizeAutoplay ? (this.options_.autoplay = value, this.manualAutoplay_("string" == typeof value ? value : "play"), techAutoplay = !1) : value ? this.options_.autoplay = !0 : this.options_.autoplay = !1, techAutoplay = void 0 === techAutoplay ? this.options_.autoplay : techAutoplay, this.tech_ && this.techCall_("setAutoplay", techAutoplay);
                }, _proto.playsinline = function(value) {
                    return void 0 !== value ? (this.techCall_("setPlaysinline", value), this.options_.playsinline = value, this) : this.techGet_("playsinline");
                }, _proto.loop = function(value) {
                    if (void 0 !== value) {
                        this.techCall_("setLoop", value), this.options_.loop = value;
                        return;
                    }
                    return this.techGet_("loop");
                }, _proto.poster = function(src) {
                    if (void 0 === src) return this.poster_;
                    src || (src = ""), src !== this.poster_ && (this.poster_ = src, this.techCall_("setPoster", src), this.isPosterFromTech_ = !1, this.trigger("posterchange"));
                }, _proto.handleTechPosterChange_ = function() {
                    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
                        var newPoster = this.tech_.poster() || "";
                        newPoster !== this.poster_ && (this.poster_ = newPoster, this.isPosterFromTech_ = !0, this.trigger("posterchange"));
                    }
                }, _proto.controls = function(bool) {
                    if (void 0 === bool) return !!this.controls_;
                    bool = !!bool, this.controls_ !== bool && (this.controls_ = bool, this.usingNativeControls() && this.techCall_("setControls", bool), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_()));
                }, _proto.usingNativeControls = function(bool) {
                    if (void 0 === bool) return !!this.usingNativeControls_;
                    bool = !!bool, this.usingNativeControls_ !== bool && (this.usingNativeControls_ = bool, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols")));
                }, _proto.error = function(err) {
                    var _this17 = this;
                    if (void 0 === err) return this.error_ || null;
                    if (hooks("beforeerror").forEach(function(hookFunction) {
                        var newErr = hookFunction(_this17, err);
                        if (!(isObject(newErr) && !Array.isArray(newErr) || "string" == typeof newErr || "number" == typeof newErr || null === newErr)) {
                            _this17.log.error("please return a value that MediaError expects in beforeerror hooks");
                            return;
                        }
                        err = newErr;
                    }), this.options_.suppressNotSupportedError && err && 4 === err.code) {
                        var triggerSuppressedError = function() {
                            this.error(err);
                        };
                        this.options_.suppressNotSupportedError = !1, this.any([
                            "click",
                            "touchstart"
                        ], triggerSuppressedError), this.one("loadstart", function() {
                            this.off([
                                "click",
                                "touchstart"
                            ], triggerSuppressedError);
                        });
                        return;
                    }
                    if (null === err) {
                        this.error_ = err, this.removeClass("vjs-error"), this.errorDisplay && this.errorDisplay.close();
                        return;
                    }
                    this.error_ = new MediaError(err), this.addClass("vjs-error"), log$1.error("(CODE:" + this.error_.code + " " + MediaError.errorTypes[this.error_.code] + ")", this.error_.message, this.error_), this.trigger("error"), hooks("error").forEach(function(hookFunction) {
                        return hookFunction(_this17, _this17.error_);
                    });
                }, _proto.reportUserActivity = function(event) {
                    this.userActivity_ = !0;
                }, _proto.userActive = function(bool) {
                    if (void 0 === bool) return this.userActive_;
                    if ((bool = !!bool) !== this.userActive_) {
                        if (this.userActive_ = bool, this.userActive_) {
                            this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), this.trigger("useractive");
                            return;
                        }
                        this.tech_ && this.tech_.one("mousemove", function(e) {
                            e.stopPropagation(), e.preventDefault();
                        }), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive");
                    }
                }, _proto.listenForUserActivity_ = function() {
                    var mouseInProgress, lastMoveX, lastMoveY, inactivityTimeout, handleActivity = bind(this, this.reportUserActivity), handleMouseUpAndMouseLeave = function(event) {
                        handleActivity(), this.clearInterval(mouseInProgress);
                    };
                    this.on("mousedown", function() {
                        handleActivity(), this.clearInterval(mouseInProgress), mouseInProgress = this.setInterval(handleActivity, 250);
                    }), this.on("mousemove", function(e) {
                        (e.screenX !== lastMoveX || e.screenY !== lastMoveY) && (lastMoveX = e.screenX, lastMoveY = e.screenY, handleActivity());
                    }), this.on("mouseup", handleMouseUpAndMouseLeave), this.on("mouseleave", handleMouseUpAndMouseLeave);
                    var controlBar = this.getChild("controlBar");
                    !controlBar || IS_IOS || IS_ANDROID || (controlBar.on("mouseenter", function(event) {
                        0 !== this.player().options_.inactivityTimeout && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0;
                    }), controlBar.on("mouseleave", function(event) {
                        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
                    })), this.on("keydown", handleActivity), this.on("keyup", handleActivity), this.setInterval(function() {
                        if (this.userActivity_) {
                            this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(inactivityTimeout);
                            var timeout = this.options_.inactivityTimeout;
                            timeout <= 0 || (inactivityTimeout = this.setTimeout(function() {
                                this.userActivity_ || this.userActive(!1);
                            }, timeout));
                        }
                    }, 250);
                }, _proto.playbackRate = function(rate) {
                    if (void 0 !== rate) {
                        this.techCall_("setPlaybackRate", rate);
                        return;
                    }
                    return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1.0;
                }, _proto.defaultPlaybackRate = function(rate) {
                    return void 0 !== rate ? this.techCall_("setDefaultPlaybackRate", rate) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1.0;
                }, _proto.isAudio = function(bool) {
                    if (void 0 !== bool) {
                        this.isAudio_ = !!bool;
                        return;
                    }
                    return !!this.isAudio_;
                }, _proto.addTextTrack = function(kind, label, language) {
                    if (this.tech_) return this.tech_.addTextTrack(kind, label, language);
                }, _proto.addRemoteTextTrack = function(options, manualCleanup) {
                    if (this.tech_) return this.tech_.addRemoteTextTrack(options, manualCleanup);
                }, _proto.removeRemoteTextTrack = function(obj) {
                    void 0 === obj && (obj = {});
                    var track = obj.track;
                    if (track || (track = obj), this.tech_) return this.tech_.removeRemoteTextTrack(track);
                }, _proto.getVideoPlaybackQuality = function() {
                    return this.techGet_("getVideoPlaybackQuality");
                }, _proto.videoWidth = function() {
                    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
                }, _proto.videoHeight = function() {
                    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
                }, _proto.language = function(code) {
                    if (void 0 === code) return this.language_;
                    this.language_ !== String(code).toLowerCase() && (this.language_ = String(code).toLowerCase(), isEvented(this) && this.trigger("languagechange"));
                }, _proto.languages = function() {
                    return mergeOptions$3(Player.prototype.options_.languages, this.languages_);
                }, _proto.toJSON = function() {
                    var options = mergeOptions$3(this.options_), tracks = options.tracks;
                    options.tracks = [];
                    for(var i = 0; i < tracks.length; i++){
                        var track = tracks[i];
                        (track = mergeOptions$3(track)).player = void 0, options.tracks[i] = track;
                    }
                    return options;
                }, _proto.createModal = function(content, options) {
                    var _this18 = this;
                    (options = options || {}).content = content || "";
                    var modal = new ModalDialog(this, options);
                    return this.addChild(modal), modal.on("dispose", function() {
                        _this18.removeChild(modal);
                    }), modal.open(), modal;
                }, _proto.updateCurrentBreakpoint_ = function() {
                    if (this.responsive()) for(var currentBreakpoint = this.currentBreakpoint(), currentWidth = this.currentWidth(), i = 0; i < BREAKPOINT_ORDER.length; i++){
                        var candidateBreakpoint = BREAKPOINT_ORDER[i];
                        if (currentWidth <= this.breakpoints_[candidateBreakpoint]) {
                            if (currentBreakpoint === candidateBreakpoint) return;
                            currentBreakpoint && this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]), this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]), this.breakpoint_ = candidateBreakpoint;
                            break;
                        }
                    }
                }, _proto.removeCurrentBreakpoint_ = function() {
                    var className = this.currentBreakpointClass();
                    this.breakpoint_ = "", className && this.removeClass(className);
                }, _proto.breakpoints = function(_breakpoints) {
                    return void 0 === _breakpoints || (this.breakpoint_ = "", this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints), this.updateCurrentBreakpoint_()), assign(this.breakpoints_);
                }, _proto.responsive = function(value) {
                    return void 0 === value ? this.responsive_ : (value = Boolean(value)) !== this.responsive_ ? (this.responsive_ = value, value ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), value) : void 0;
                }, _proto.currentBreakpoint = function() {
                    return this.breakpoint_;
                }, _proto.currentBreakpointClass = function() {
                    return BREAKPOINT_CLASSES[this.breakpoint_] || "";
                }, _proto.loadMedia = function(media, ready) {
                    var _this19 = this;
                    if (media && "object" == typeof media) {
                        this.reset(), this.cache_.media = mergeOptions$3(media);
                        var _this$cache_$media = this.cache_.media, artwork = _this$cache_$media.artwork, poster = _this$cache_$media.poster, src = _this$cache_$media.src, textTracks = _this$cache_$media.textTracks;
                        !artwork && poster && (this.cache_.media.artwork = [
                            {
                                src: poster,
                                type: getMimetype(poster)
                            }
                        ]), src && this.src(src), poster && this.poster(poster), Array.isArray(textTracks) && textTracks.forEach(function(tt) {
                            return _this19.addRemoteTextTrack(tt, !1);
                        }), this.ready(ready);
                    }
                }, _proto.getMedia = function() {
                    if (!this.cache_.media) {
                        var poster = this.poster(), media = {
                            src: this.currentSources(),
                            textTracks: Array.prototype.map.call(this.remoteTextTracks(), function(tt) {
                                return {
                                    kind: tt.kind,
                                    label: tt.label,
                                    language: tt.language,
                                    src: tt.src
                                };
                            })
                        };
                        return poster && (media.poster = poster, media.artwork = [
                            {
                                src: media.poster,
                                type: getMimetype(media.poster)
                            }
                        ]), media;
                    }
                    return mergeOptions$3(this.cache_.media);
                }, Player.getTagSettings = function(tag) {
                    var baseOptions = {
                        sources: [],
                        tracks: []
                    }, tagOptions = getAttributes(tag), dataSetup = tagOptions["data-setup"];
                    if (hasClass(tag, "vjs-fill") && (tagOptions.fill = !0), hasClass(tag, "vjs-fluid") && (tagOptions.fluid = !0), null !== dataSetup) {
                        var _safeParseTuple = safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_2___default()(dataSetup || "{}"), err = _safeParseTuple[0], data = _safeParseTuple[1];
                        err && log$1.error(err), assign(tagOptions, data);
                    }
                    if (assign(baseOptions, tagOptions), tag.hasChildNodes()) for(var children = tag.childNodes, i = 0, j = children.length; i < j; i++){
                        var child = children[i], childName = child.nodeName.toLowerCase();
                        "source" === childName ? baseOptions.sources.push(getAttributes(child)) : "track" === childName && baseOptions.tracks.push(getAttributes(child));
                    }
                    return baseOptions;
                }, _proto.flexNotSupported_ = function() {
                    var elem = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("i");
                    return !("flexBasis" in elem.style || "webkitFlexBasis" in elem.style || "mozFlexBasis" in elem.style || "msFlexBasis" in elem.style || "msFlexOrder" in elem.style);
                }, _proto.debug = function(enabled) {
                    if (void 0 === enabled) return this.debugEnabled_;
                    enabled ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1);
                }, _proto.playbackRates = function(newRates) {
                    if (void 0 === newRates) return this.cache_.playbackRates;
                    Array.isArray(newRates) && newRates.every(function(rate) {
                        return "number" == typeof rate;
                    }) && (this.cache_.playbackRates = newRates, this.trigger("playbackrateschange"));
                }, Player;
            }(Component$1);
            ALL.names.forEach(function(name) {
                var props = ALL[name];
                Player.prototype[props.getterName] = function() {
                    return this.tech_ ? this.tech_[props.getterName]() : (this[props.privateName] = this[props.privateName] || new props.ListClass(), this[props.privateName]);
                };
            }), Player.prototype.crossorigin = Player.prototype.crossOrigin, Player.players = {};
            var navigator = global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator;
            Player.prototype.options_ = {
                techOrder: Tech.defaultTechOrder_,
                html5: {},
                inactivityTimeout: 2000,
                playbackRates: [],
                liveui: !1,
                children: [
                    "mediaLoader",
                    "posterImage",
                    "textTrackDisplay",
                    "loadingSpinner",
                    "bigPlayButton",
                    "liveTracker",
                    "controlBar",
                    "errorDisplay",
                    "textTrackSettings",
                    "resizeManager"
                ],
                language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || "en",
                languages: {},
                notSupportedMessage: "No compatible source was found for this media.",
                normalizeAutoplay: !1,
                fullscreen: {
                    options: {
                        navigationUI: "hide"
                    }
                },
                breakpoints: {},
                responsive: !1
            }, [
                "ended",
                "seeking",
                "seekable",
                "networkState",
                "readyState"
            ].forEach(function(fn) {
                Player.prototype[fn] = function() {
                    return this.techGet_(fn);
                };
            }), TECH_EVENTS_RETRIGGER.forEach(function(event) {
                Player.prototype["handleTech" + toTitleCase$1(event) + "_"] = function() {
                    return this.trigger(event);
                };
            }), Component$1.registerComponent("Player", Player);
            var BASE_PLUGIN_NAME = "plugin", PLUGIN_CACHE_KEY = "activePlugins_", pluginStorage = {}, pluginExists = function(name) {
                return pluginStorage.hasOwnProperty(name);
            }, getPlugin = function(name) {
                return pluginExists(name) ? pluginStorage[name] : void 0;
            }, markPluginAsActive = function(player, name) {
                player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {}, player[PLUGIN_CACHE_KEY][name] = !0;
            }, triggerSetupEvent = function(player, hash, before) {
                var eventName = (before ? "before" : "") + "pluginsetup";
                player.trigger(eventName, hash), player.trigger(eventName + ":" + hash.name, hash);
            }, createBasicPlugin = function(name, plugin) {
                var basicPluginWrapper = function() {
                    triggerSetupEvent(this, {
                        name: name,
                        plugin: plugin,
                        instance: null
                    }, !0);
                    var instance = plugin.apply(this, arguments);
                    return markPluginAsActive(this, name), triggerSetupEvent(this, {
                        name: name,
                        plugin: plugin,
                        instance: instance
                    }), instance;
                };
                return Object.keys(plugin).forEach(function(prop) {
                    basicPluginWrapper[prop] = plugin[prop];
                }), basicPluginWrapper;
            }, createPluginFactory = function(name, PluginSubClass) {
                return PluginSubClass.prototype.name = name, function() {
                    triggerSetupEvent(this, {
                        name: name,
                        plugin: PluginSubClass,
                        instance: null
                    }, !0);
                    for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    var instance = (0, _babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_18__.Z)(PluginSubClass, [
                        this
                    ].concat(args));
                    return this[name] = function() {
                        return instance;
                    }, triggerSetupEvent(this, instance.getEventHash()), instance;
                };
            }, Plugin = function() {
                function Plugin(player) {
                    if (this.constructor === Plugin) throw Error("Plugin must be sub-classed; not directly instantiated.");
                    this.player = player, this.log || (this.log = this.player.log.createLogger(this.name)), evented(this), delete this.trigger, stateful(this, this.constructor.defaultState), markPluginAsActive(player, this.name), this.dispose = this.dispose.bind(this), player.on("dispose", this.dispose);
                }
                var _proto = Plugin.prototype;
                return _proto.version = function() {
                    return this.constructor.VERSION;
                }, _proto.getEventHash = function(hash) {
                    return void 0 === hash && (hash = {}), hash.name = this.name, hash.plugin = this.constructor, hash.instance = this, hash;
                }, _proto.trigger = function(event, hash) {
                    return void 0 === hash && (hash = {}), trigger(this.eventBusEl_, event, this.getEventHash(hash));
                }, _proto.handleStateChanged = function(e) {}, _proto.dispose = function() {
                    var name = this.name, player = this.player;
                    this.trigger("dispose"), this.off(), player.off("dispose", this.dispose), player[PLUGIN_CACHE_KEY][name] = !1, this.player = this.state = null, player[name] = createPluginFactory(name, pluginStorage[name]);
                }, Plugin.isBasic = function(plugin) {
                    var p = "string" == typeof plugin ? getPlugin(plugin) : plugin;
                    return "function" == typeof p && !Plugin.prototype.isPrototypeOf(p.prototype);
                }, Plugin.registerPlugin = function(name, plugin) {
                    if ("string" != typeof name) throw Error('Illegal plugin name, "' + name + '", must be a string, was ' + typeof name + ".");
                    if (pluginExists(name)) log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
                    else if (Player.prototype.hasOwnProperty(name)) throw Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
                    if ("function" != typeof plugin) throw Error('Illegal plugin for "' + name + '", must be a function, was ' + typeof plugin + ".");
                    return pluginStorage[name] = plugin, name !== BASE_PLUGIN_NAME && (Plugin.isBasic(plugin) ? Player.prototype[name] = createBasicPlugin(name, plugin) : Player.prototype[name] = createPluginFactory(name, plugin)), plugin;
                }, Plugin.deregisterPlugin = function(name) {
                    if (name === BASE_PLUGIN_NAME) throw Error("Cannot de-register base plugin.");
                    pluginExists(name) && (delete pluginStorage[name], delete Player.prototype[name]);
                }, Plugin.getPlugins = function(names) {
                    var result;
                    return void 0 === names && (names = Object.keys(pluginStorage)), names.forEach(function(name) {
                        var plugin = getPlugin(name);
                        plugin && ((result = result || {})[name] = plugin);
                    }), result;
                }, Plugin.getPluginVersion = function(name) {
                    var plugin = getPlugin(name);
                    return plugin && plugin.VERSION || "";
                }, Plugin;
            }();
            Plugin.getPlugin = getPlugin, Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME, Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin), Player.prototype.usingPlugin = function(name) {
                return !!this[PLUGIN_CACHE_KEY] && !0 === this[PLUGIN_CACHE_KEY][name];
            }, Player.prototype.hasPlugin = function(name) {
                return !!pluginExists(name);
            };
            var normalizeId = function(id) {
                return 0 === id.indexOf("#") ? id.slice(1) : id;
            };
            function videojs(id, options, ready) {
                var player = videojs.getPlayer(id);
                if (player) return options && log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.'), ready && player.ready(ready), player;
                var el = "string" == typeof id ? $("#" + normalizeId(id)) : id;
                if (!isEl(el)) throw TypeError("The element or ID supplied is not valid. (videojs)");
                return el.ownerDocument.defaultView && el.ownerDocument.body.contains(el) || log$1.warn("The element supplied is not included in the DOM"), options = options || {}, hooks("beforesetup").forEach(function(hookFunction) {
                    var opts = hookFunction(el, mergeOptions$3(options));
                    if (!isObject(opts) || Array.isArray(opts)) {
                        log$1.error("please return an object in beforesetup hooks");
                        return;
                    }
                    options = mergeOptions$3(options, opts);
                }), player = new (Component$1.getComponent("Player"))(el, options, ready), hooks("setup").forEach(function(hookFunction) {
                    return hookFunction(player);
                }), player;
            }
            if (videojs.hooks_ = hooks_, videojs.hooks = hooks, videojs.hook = function(type, fn) {
                hooks(type, fn);
            }, videojs.hookOnce = function(type, fn) {
                hooks(type, [].concat(fn).map(function(original) {
                    return function wrapper() {
                        return removeHook(type, wrapper), original.apply(void 0, arguments);
                    };
                }));
            }, videojs.removeHook = removeHook, !0 !== global_window__WEBPACK_IMPORTED_MODULE_0___default().VIDEOJS_NO_DYNAMIC_STYLE && isReal()) {
                var style = $(".vjs-styles-defaults");
                if (!style) {
                    style = createStyleElement("vjs-styles-defaults");
                    var head = $("head");
                    head && head.insertBefore(style, head.firstChild), setTextContent(style, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ");
                }
            }
            autoSetupTimeout(1, videojs), videojs.VERSION = version$5, videojs.options = Player.prototype.options_, videojs.getPlayers = function() {
                return Player.players;
            }, videojs.getPlayer = function(id) {
                var tag, players = Player.players;
                if ("string" == typeof id) {
                    var nId = normalizeId(id), player = players[nId];
                    if (player) return player;
                    tag = $("#" + nId);
                } else tag = id;
                if (isEl(tag)) {
                    var _tag = tag, _player = _tag.player, playerId = _tag.playerId;
                    if (_player || players[playerId]) return _player || players[playerId];
                }
            }, videojs.getAllPlayers = function() {
                return Object.keys(Player.players).map(function(k) {
                    return Player.players[k];
                }).filter(Boolean);
            }, videojs.players = Player.players, videojs.getComponent = Component$1.getComponent, videojs.registerComponent = function(name, comp) {
                Tech.isTech(comp) && log$1.warn("The " + name + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)"), Component$1.registerComponent.call(Component$1, name, comp);
            }, videojs.getTech = Tech.getTech, videojs.registerTech = Tech.registerTech, videojs.use = function(type, middleware) {
                middlewares[type] = middlewares[type] || [], middlewares[type].push(middleware);
            }, Object.defineProperty(videojs, "middleware", {
                value: {},
                writeable: !1,
                enumerable: !0
            }), Object.defineProperty(videojs.middleware, "TERMINATOR", {
                value: TERMINATOR,
                writeable: !1,
                enumerable: !0
            }), videojs.browser = browser, videojs.TOUCH_ENABLED = TOUCH_ENABLED, videojs.extend = function(superClass, subClassMethods) {
                void 0 === subClassMethods && (subClassMethods = {});
                var subClass = function() {
                    superClass.apply(this, arguments);
                }, methods = {};
                for(var name in "object" == typeof subClassMethods ? (subClassMethods.constructor !== Object.prototype.constructor && (subClass = subClassMethods.constructor), methods = subClassMethods) : "function" == typeof subClassMethods && (subClass = subClassMethods), (0, _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_19__.Z)(subClass, superClass), superClass && (subClass.super_ = superClass), methods)methods.hasOwnProperty(name) && (subClass.prototype[name] = methods[name]);
                return subClass;
            }, videojs.mergeOptions = mergeOptions$3, videojs.bind = bind, videojs.registerPlugin = Plugin.registerPlugin, videojs.deregisterPlugin = Plugin.deregisterPlugin, videojs.plugin = function(name, plugin) {
                return log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead"), Plugin.registerPlugin(name, plugin);
            }, videojs.getPlugins = Plugin.getPlugins, videojs.getPlugin = Plugin.getPlugin, videojs.getPluginVersion = Plugin.getPluginVersion, videojs.addLanguage = function(code, data) {
                var _mergeOptions;
                return code = ("" + code).toLowerCase(), videojs.options.languages = mergeOptions$3(videojs.options.languages, ((_mergeOptions = {})[code] = data, _mergeOptions)), videojs.options.languages[code];
            }, videojs.log = log$1, videojs.createLogger = createLogger, videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges, videojs.formatTime = formatTime, videojs.setFormatTime = function(customImplementation) {
                implementation = customImplementation;
            }, videojs.resetFormatTime = function() {
                implementation = defaultImplementation;
            }, videojs.parseUrl = parseUrl, videojs.isCrossOrigin = isCrossOrigin, videojs.EventTarget = EventTarget$2, videojs.on = on, videojs.one = one, videojs.off = off, videojs.trigger = trigger, videojs.xhr = _videojs_xhr__WEBPACK_IMPORTED_MODULE_4___default(), videojs.TextTrack = TextTrack, videojs.AudioTrack = AudioTrack, videojs.VideoTrack = VideoTrack, [
                "isEl",
                "isTextNode",
                "createEl",
                "hasClass",
                "addClass",
                "removeClass",
                "toggleClass",
                "setAttributes",
                "getAttributes",
                "emptyEl",
                "appendContent",
                "insertContent"
            ].forEach(function(k) {
                videojs[k] = function() {
                    return log$1.warn("videojs." + k + "() is deprecated; use videojs.dom." + k + "() instead"), Dom[k].apply(null, arguments);
                };
            }), videojs.computedStyle = computedStyle, videojs.dom = Dom, videojs.url = Url, videojs.defineLazyProperty = defineLazyProperty, videojs.addLanguage("en", {
                "Non-Fullscreen": "Exit Fullscreen"
            });
            var resolveUrl = _videojs_vhs_utils_es_resolve_url_js__WEBPACK_IMPORTED_MODULE_6__.Z, resolveManifestRedirect = function(handleManifestRedirect, url, req) {
                return handleManifestRedirect && req && req.responseURL && url !== req.responseURL ? req.responseURL : url;
            }, logger = function(source) {
                return videojs.log.debug ? videojs.log.debug.bind(videojs, "VHS:", source + " >") : function() {};
            }, TIME_FUDGE_FACTOR = 1 / 30, SAFE_TIME_DELTA = 3 * (1 / 30), filterRanges = function(timeRanges, predicate) {
                var i, results = [];
                if (timeRanges && timeRanges.length) for(i = 0; i < timeRanges.length; i++)predicate(timeRanges.start(i), timeRanges.end(i)) && results.push([
                    timeRanges.start(i),
                    timeRanges.end(i)
                ]);
                return videojs.createTimeRanges(results);
            }, findRange = function(buffered, time) {
                return filterRanges(buffered, function(start, end) {
                    return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;
                });
            }, findNextRange = function(timeRanges, time) {
                return filterRanges(timeRanges, function(start) {
                    return start - TIME_FUDGE_FACTOR >= time;
                });
            }, findGaps = function(buffered) {
                if (buffered.length < 2) return videojs.createTimeRanges();
                for(var ranges = [], i = 1; i < buffered.length; i++){
                    var start = buffered.end(i - 1), end = buffered.start(i);
                    ranges.push([
                        start,
                        end
                    ]);
                }
                return videojs.createTimeRanges(ranges);
            }, bufferIntersection = function(bufferA, bufferB) {
                var start = null, end = null, arity = 0, extents = [], ranges = [];
                if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) return videojs.createTimeRange();
                for(var count = bufferA.length; count--;)extents.push({
                    time: bufferA.start(count),
                    type: "start"
                }), extents.push({
                    time: bufferA.end(count),
                    type: "end"
                });
                for(count = bufferB.length; count--;)extents.push({
                    time: bufferB.start(count),
                    type: "start"
                }), extents.push({
                    time: bufferB.end(count),
                    type: "end"
                });
                for(extents.sort(function(a, b) {
                    return a.time - b.time;
                }), count = 0; count < extents.length; count++)"start" === extents[count].type ? 2 == ++arity && (start = extents[count].time) : "end" === extents[count].type && 1 == --arity && (end = extents[count].time), null !== start && null !== end && (ranges.push([
                    start,
                    end
                ]), start = null, end = null);
                return videojs.createTimeRanges(ranges);
            }, printableRange = function(range) {
                var strArr = [];
                if (!range || !range.length) return "";
                for(var i = 0; i < range.length; i++)strArr.push(range.start(i) + " => " + range.end(i));
                return strArr.join(", ");
            }, timeRangesToArray = function(timeRanges) {
                for(var timeRangesList = [], i = 0; i < timeRanges.length; i++)timeRangesList.push({
                    start: timeRanges.start(i),
                    end: timeRanges.end(i)
                });
                return timeRangesList;
            }, isRangeDifferent = function(a, b) {
                if (a === b) return !1;
                if (!a && b || !b && a || a.length !== b.length) return !0;
                for(var i = 0; i < a.length; i++)if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) return !0;
                return !1;
            }, lastBufferedEnd = function(a) {
                if (a && a.length && a.end) return a.end(a.length - 1);
            }, timeAheadOf = function(range, startTime) {
                var time = 0;
                if (!range || !range.length) return time;
                for(var i = 0; i < range.length; i++){
                    var start = range.start(i), end = range.end(i);
                    if (!(startTime > end)) {
                        if (startTime > start && startTime <= end) {
                            time += end - startTime;
                            continue;
                        }
                        time += end - start;
                    }
                }
                return time;
            }, createTimeRange = videojs.createTimeRange, segmentDurationWithParts = function(playlist, segment) {
                if (!segment.preload) return segment.duration;
                var result = 0;
                return (segment.parts || []).forEach(function(p) {
                    result += p.duration;
                }), (segment.preloadHints || []).forEach(function(p) {
                    "PART" === p.type && (result += playlist.partTargetDuration);
                }), result;
            }, getPartsAndSegments = function(playlist) {
                return (playlist.segments || []).reduce(function(acc, segment, si) {
                    return segment.parts ? segment.parts.forEach(function(part, pi) {
                        acc.push({
                            duration: part.duration,
                            segmentIndex: si,
                            partIndex: pi,
                            part: part,
                            segment: segment
                        });
                    }) : acc.push({
                        duration: segment.duration,
                        segmentIndex: si,
                        partIndex: null,
                        segment: segment,
                        part: null
                    }), acc;
                }, []);
            }, getLastParts = function(media) {
                var lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
                return lastSegment && lastSegment.parts || [];
            }, getKnownPartCount = function(_ref) {
                var preloadSegment = _ref.preloadSegment;
                if (preloadSegment) {
                    var parts = preloadSegment.parts;
                    return (preloadSegment.preloadHints || []).reduce(function(count, hint) {
                        return count + ("PART" === hint.type ? 1 : 0);
                    }, 0) + (parts && parts.length ? parts.length : 0);
                }
            }, liveEdgeDelay = function(master, media) {
                if (media.endList) return 0;
                if (master && master.suggestedPresentationDelay) return master.suggestedPresentationDelay;
                var hasParts = getLastParts(media).length > 0;
                return hasParts && media.serverControl && media.serverControl.partHoldBack ? media.serverControl.partHoldBack : hasParts && media.partTargetDuration ? 3 * media.partTargetDuration : media.serverControl && media.serverControl.holdBack ? media.serverControl.holdBack : media.targetDuration ? 3 * media.targetDuration : 0;
            }, backwardDuration = function(playlist, endSequence) {
                var result = 0, i = endSequence - playlist.mediaSequence, segment = playlist.segments[i];
                if (segment) {
                    if (void 0 !== segment.start) return {
                        result: segment.start,
                        precise: !0
                    };
                    if (void 0 !== segment.end) return {
                        result: segment.end - segment.duration,
                        precise: !0
                    };
                }
                for(; i--;){
                    if (void 0 !== (segment = playlist.segments[i]).end) return {
                        result: result + segment.end,
                        precise: !0
                    };
                    if (result += segmentDurationWithParts(playlist, segment), void 0 !== segment.start) return {
                        result: result + segment.start,
                        precise: !0
                    };
                }
                return {
                    result: result,
                    precise: !1
                };
            }, forwardDuration = function(playlist, endSequence) {
                for(var segment, result = 0, i = endSequence - playlist.mediaSequence; i < playlist.segments.length; i++){
                    if (void 0 !== (segment = playlist.segments[i]).start) return {
                        result: segment.start - result,
                        precise: !0
                    };
                    if (result += segmentDurationWithParts(playlist, segment), void 0 !== segment.end) return {
                        result: segment.end - result,
                        precise: !0
                    };
                }
                return {
                    result: -1,
                    precise: !1
                };
            }, intervalDuration = function(playlist, endSequence, expired) {
                if (void 0 === endSequence && (endSequence = playlist.mediaSequence + playlist.segments.length), endSequence < playlist.mediaSequence) return 0;
                var backward = backwardDuration(playlist, endSequence);
                if (backward.precise) return backward.result;
                var forward = forwardDuration(playlist, endSequence);
                return forward.precise ? forward.result : backward.result + expired;
            }, duration = function(playlist, endSequence, expired) {
                if (!playlist) return 0;
                if ("number" != typeof expired && (expired = 0), void 0 === endSequence) {
                    if (playlist.totalDuration) return playlist.totalDuration;
                    if (!playlist.endList) return global_window__WEBPACK_IMPORTED_MODULE_0___default()[1 / 0];
                }
                return intervalDuration(playlist, endSequence, expired);
            }, sumDurations = function(_ref2) {
                var defaultDuration = _ref2.defaultDuration, durationList = _ref2.durationList, startIndex = _ref2.startIndex, endIndex = _ref2.endIndex, durations = 0;
                if (startIndex > endIndex) {
                    var _ref3 = [
                        endIndex,
                        startIndex
                    ];
                    startIndex = _ref3[0], endIndex = _ref3[1];
                }
                if (startIndex < 0) {
                    for(var i = startIndex; i < Math.min(0, endIndex); i++)durations += defaultDuration;
                    startIndex = 0;
                }
                for(var _i = startIndex; _i < endIndex; _i++)durations += durationList[_i].duration;
                return durations;
            }, playlistEnd = function(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
                if (!playlist || !playlist.segments) return null;
                if (playlist.endList) return duration(playlist);
                if (null === expired) return null;
                expired = expired || 0;
                var lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
                return useSafeLiveEnd && (lastSegmentEndTime -= liveEdgePadding = "number" == typeof liveEdgePadding ? liveEdgePadding : liveEdgeDelay(null, playlist)), Math.max(0, lastSegmentEndTime);
            }, isBlacklisted = function(playlist) {
                return playlist.excludeUntil && playlist.excludeUntil > Date.now();
            }, isIncompatible = function(playlist) {
                return playlist.excludeUntil && playlist.excludeUntil === 1 / 0;
            }, isEnabled = function(playlist) {
                var blacklisted = isBlacklisted(playlist);
                return !playlist.disabled && !blacklisted;
            }, hasAttribute = function(attr, playlist) {
                return playlist.attributes && playlist.attributes[attr];
            }, isLowestEnabledRendition = function(master, media) {
                if (1 === master.playlists.length) return !0;
                var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
                return 0 === master.playlists.filter(function(playlist) {
                    return !!isEnabled(playlist) && (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
                }).length;
            }, playlistMatch = function(a, b) {
                return (!!a || !!b) && (!!a || !b) && (!a || !!b) && (a === b || !!a.id && !!b.id && a.id === b.id || !!a.resolvedUri && !!b.resolvedUri && a.resolvedUri === b.resolvedUri || !!a.uri && !!b.uri && a.uri === b.uri);
            }, someAudioVariant = function(master, callback) {
                var AUDIO = master && master.mediaGroups && master.mediaGroups.AUDIO || {}, found = !1;
                for(var groupName in AUDIO){
                    for(var label in AUDIO[groupName])if (found = callback(AUDIO[groupName][label])) break;
                    if (found) break;
                }
                return !!found;
            }, isAudioOnly = function(master) {
                if (!master || !master.playlists || !master.playlists.length) return someAudioVariant(master, function(variant) {
                    return variant.playlists && variant.playlists.length || variant.uri;
                });
                for(var i = 0; i < master.playlists.length; i++){
                    var _ret = function(i) {
                        var playlist = master.playlists[i], CODECS = playlist.attributes && playlist.attributes.CODECS;
                        return CODECS && CODECS.split(",").every(function(c) {
                            return (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.KL)(c);
                        }) || someAudioVariant(master, function(variant) {
                            return playlistMatch(playlist, variant);
                        }) ? "continue" : {
                            v: !1
                        };
                    }(i);
                    if ("continue" !== _ret && "object" == typeof _ret) return _ret.v;
                }
                return !0;
            }, Playlist = {
                liveEdgeDelay: liveEdgeDelay,
                duration: duration,
                seekable: function(playlist, expired, liveEdgePadding) {
                    var seekableEnd = playlistEnd(playlist, expired, !0, liveEdgePadding);
                    return null === seekableEnd ? createTimeRange() : createTimeRange(expired || 0, seekableEnd);
                },
                getMediaInfoForTime: function(_ref4) {
                    for(var playlist = _ref4.playlist, currentTime = _ref4.currentTime, startingSegmentIndex = _ref4.startingSegmentIndex, startingPartIndex = _ref4.startingPartIndex, startTime = _ref4.startTime, experimentalExactManifestTimings = _ref4.experimentalExactManifestTimings, time = currentTime - startTime, partsAndSegments = getPartsAndSegments(playlist), startIndex = 0, i = 0; i < partsAndSegments.length; i++){
                        var partAndSegment = partsAndSegments[i];
                        if (startingSegmentIndex === partAndSegment.segmentIndex && ("number" != typeof startingPartIndex || "number" != typeof partAndSegment.partIndex || startingPartIndex === partAndSegment.partIndex)) {
                            startIndex = i;
                            break;
                        }
                    }
                    if (time < 0) {
                        if (startIndex > 0) for(var _i2 = startIndex - 1; _i2 >= 0; _i2--){
                            var _partAndSegment = partsAndSegments[_i2];
                            if (time += _partAndSegment.duration, experimentalExactManifestTimings) {
                                if (time < 0) continue;
                            } else if (time + TIME_FUDGE_FACTOR <= 0) continue;
                            return {
                                partIndex: _partAndSegment.partIndex,
                                segmentIndex: _partAndSegment.segmentIndex,
                                startTime: startTime - sumDurations({
                                    defaultDuration: playlist.targetDuration,
                                    durationList: partsAndSegments,
                                    startIndex: startIndex,
                                    endIndex: _i2
                                })
                            };
                        }
                        return {
                            partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
                            segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
                            startTime: currentTime
                        };
                    }
                    if (startIndex < 0) {
                        for(var _i3 = startIndex; _i3 < 0; _i3++)if ((time -= playlist.targetDuration) < 0) return {
                            partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
                            segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
                            startTime: currentTime
                        };
                        startIndex = 0;
                    }
                    for(var _i4 = startIndex; _i4 < partsAndSegments.length; _i4++){
                        var _partAndSegment2 = partsAndSegments[_i4];
                        if (time -= _partAndSegment2.duration, experimentalExactManifestTimings) {
                            if (time > 0) continue;
                        } else if (time - TIME_FUDGE_FACTOR >= 0) continue;
                        return {
                            partIndex: _partAndSegment2.partIndex,
                            segmentIndex: _partAndSegment2.segmentIndex,
                            startTime: startTime + sumDurations({
                                defaultDuration: playlist.targetDuration,
                                durationList: partsAndSegments,
                                startIndex: startIndex,
                                endIndex: _i4
                            })
                        };
                    }
                    return {
                        segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
                        partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
                        startTime: currentTime
                    };
                },
                isEnabled: isEnabled,
                isDisabled: function(playlist) {
                    return playlist.disabled;
                },
                isBlacklisted: isBlacklisted,
                isIncompatible: isIncompatible,
                playlistEnd: playlistEnd,
                isAes: function(media) {
                    for(var i = 0; i < media.segments.length; i++)if (media.segments[i].key) return !0;
                    return !1;
                },
                hasAttribute: hasAttribute,
                estimateSegmentRequestTime: function(segmentDuration, bandwidth, playlist, bytesReceived) {
                    return (void 0 === bytesReceived && (bytesReceived = 0), hasAttribute("BANDWIDTH", playlist)) ? (segmentDuration * playlist.attributes.BANDWIDTH - 8 * bytesReceived) / bandwidth : NaN;
                },
                isLowestEnabledRendition: isLowestEnabledRendition,
                isAudioOnly: isAudioOnly,
                playlistMatch: playlistMatch,
                segmentDurationWithParts: segmentDurationWithParts
            }, log = videojs.log, createPlaylistID = function(index, uri) {
                return index + "-" + uri;
            }, parseManifest = function(_ref) {
                var onwarn = _ref.onwarn, oninfo = _ref.oninfo, manifestString = _ref.manifestString, _ref$customTagParsers = _ref.customTagParsers, _ref$customTagMappers = _ref.customTagMappers, experimentalLLHLS = _ref.experimentalLLHLS, parser = new m3u8_parser__WEBPACK_IMPORTED_MODULE_7__._b();
                onwarn && parser.on("warn", onwarn), oninfo && parser.on("info", oninfo), (void 0 === _ref$customTagParsers ? [] : _ref$customTagParsers).forEach(function(customParser) {
                    return parser.addParser(customParser);
                }), (void 0 === _ref$customTagMappers ? [] : _ref$customTagMappers).forEach(function(mapper) {
                    return parser.addTagMapper(mapper);
                }), parser.push(manifestString), parser.end();
                var manifest = parser.manifest;
                if (!experimentalLLHLS && ([
                    "preloadSegment",
                    "skip",
                    "serverControl",
                    "renditionReports",
                    "partInf",
                    "partTargetDuration"
                ].forEach(function(k) {
                    manifest.hasOwnProperty(k) && delete manifest[k];
                }), manifest.segments && manifest.segments.forEach(function(segment) {
                    [
                        "parts",
                        "preloadHints"
                    ].forEach(function(k) {
                        segment.hasOwnProperty(k) && delete segment[k];
                    });
                })), !manifest.targetDuration) {
                    var targetDuration = 10;
                    manifest.segments && manifest.segments.length && (targetDuration = manifest.segments.reduce(function(acc, s) {
                        return Math.max(acc, s.duration);
                    }, 0)), onwarn && onwarn("manifest has no targetDuration defaulting to " + targetDuration), manifest.targetDuration = targetDuration;
                }
                var parts = getLastParts(manifest);
                if (parts.length && !manifest.partTargetDuration) {
                    var partTargetDuration = parts.reduce(function(acc, p) {
                        return Math.max(acc, p.duration);
                    }, 0);
                    onwarn && (onwarn("manifest has no partTargetDuration defaulting to " + partTargetDuration), log.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), manifest.partTargetDuration = partTargetDuration;
                }
                return manifest;
            }, forEachMediaGroup = function(master, callback) {
                master.mediaGroups && [
                    "AUDIO",
                    "SUBTITLES"
                ].forEach(function(mediaType) {
                    if (master.mediaGroups[mediaType]) for(var groupKey in master.mediaGroups[mediaType])for(var labelKey in master.mediaGroups[mediaType][groupKey])callback(master.mediaGroups[mediaType][groupKey][labelKey], mediaType, groupKey, labelKey);
                });
            }, setupMediaPlaylist = function(_ref2) {
                var playlist = _ref2.playlist, uri = _ref2.uri, id = _ref2.id;
                playlist.id = id, playlist.playlistErrors_ = 0, uri && (playlist.uri = uri), playlist.attributes = playlist.attributes || {};
            }, setupMediaPlaylists = function(master) {
                for(var i = master.playlists.length; i--;){
                    var playlist = master.playlists[i];
                    setupMediaPlaylist({
                        playlist: playlist,
                        id: createPlaylistID(i, playlist.uri)
                    }), playlist.resolvedUri = resolveUrl(master.uri, playlist.uri), master.playlists[playlist.id] = playlist, master.playlists[playlist.uri] = playlist, playlist.attributes.BANDWIDTH || log.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
                }
            }, resolveMediaGroupUris = function(master) {
                forEachMediaGroup(master, function(properties) {
                    properties.uri && (properties.resolvedUri = resolveUrl(master.uri, properties.uri));
                });
            }, masterForMedia = function(media, uri) {
                var id = createPlaylistID(0, uri), master = {
                    mediaGroups: {
                        AUDIO: {},
                        VIDEO: {},
                        "CLOSED-CAPTIONS": {},
                        SUBTITLES: {}
                    },
                    uri: global_window__WEBPACK_IMPORTED_MODULE_0___default().location.href,
                    resolvedUri: global_window__WEBPACK_IMPORTED_MODULE_0___default().location.href,
                    playlists: [
                        {
                            uri: uri,
                            id: id,
                            resolvedUri: uri,
                            attributes: {}
                        }
                    ]
                };
                return master.playlists[id] = master.playlists[0], master.playlists[uri] = master.playlists[0], master;
            }, addPropertiesToMaster = function(master, uri) {
                master.uri = uri;
                for(var i = 0; i < master.playlists.length; i++)if (!master.playlists[i].uri) {
                    var phonyUri = "placeholder-uri-" + i;
                    master.playlists[i].uri = phonyUri;
                }
                var audioOnlyMaster = isAudioOnly(master);
                forEachMediaGroup(master, function(properties, mediaType, groupKey, labelKey) {
                    var groupId = "placeholder-uri-" + mediaType + "-" + groupKey + "-" + labelKey;
                    if (!properties.playlists || !properties.playlists.length) {
                        if (audioOnlyMaster && "AUDIO" === mediaType && !properties.uri) for(var _i = 0; _i < master.playlists.length; _i++){
                            var p = master.playlists[_i];
                            if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) return;
                        }
                        properties.playlists = [
                            (0, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__.Z)({}, properties)
                        ];
                    }
                    properties.playlists.forEach(function(p, i) {
                        var id = createPlaylistID(i, groupId);
                        p.uri ? p.resolvedUri = p.resolvedUri || resolveUrl(master.uri, p.uri) : (p.uri = 0 === i ? groupId : id, p.resolvedUri = p.uri), p.id = p.id || id, p.attributes = p.attributes || {}, master.playlists[p.id] = p, master.playlists[p.uri] = p;
                    });
                }), setupMediaPlaylists(master), resolveMediaGroupUris(master);
            }, mergeOptions$2 = videojs.mergeOptions, EventTarget$1 = videojs.EventTarget, addLLHLSQueryDirectives = function(uri, media) {
                if (media.endList || !media.serverControl) return uri;
                var parameters = {};
                if (media.serverControl.canBlockReload) {
                    var preloadSegment = media.preloadSegment, nextMSN = media.mediaSequence + media.segments.length;
                    if (preloadSegment) {
                        var parts = preloadSegment.parts || [], nextPart = getKnownPartCount(media) - 1;
                        nextPart > -1 && nextPart !== parts.length - 1 && (parameters._HLS_part = nextPart), (nextPart > -1 || parts.length) && nextMSN--;
                    }
                    parameters._HLS_msn = nextMSN;
                }
                if (media.serverControl && media.serverControl.canSkipUntil && (parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(parameters).length) {
                    var parsedUri = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).URL(uri);
                    [
                        "_HLS_skip",
                        "_HLS_msn",
                        "_HLS_part"
                    ].forEach(function(name) {
                        parameters.hasOwnProperty(name) && parsedUri.searchParams.set(name, parameters[name]);
                    }), uri = parsedUri.toString();
                }
                return uri;
            }, updateSegment = function(a, b) {
                if (!a) return b;
                var result = mergeOptions$2(a, b);
                if (a.preloadHints && !b.preloadHints && delete result.preloadHints, a.parts && !b.parts) delete result.parts;
                else if (a.parts && b.parts) for(var i = 0; i < b.parts.length; i++)a.parts && a.parts[i] && (result.parts[i] = mergeOptions$2(a.parts[i], b.parts[i]));
                return !a.skipped && b.skipped && (result.skipped = !1), a.preload && !b.preload && (result.preload = !1), result;
            }, updateSegments = function(original, update, offset) {
                var currentMap, oldSegments = original.slice(), newSegments = update.slice();
                offset = offset || 0;
                for(var result = [], newIndex = 0; newIndex < newSegments.length; newIndex++){
                    var oldSegment = oldSegments[newIndex + offset], newSegment = newSegments[newIndex];
                    oldSegment ? (currentMap = oldSegment.map || currentMap, result.push(updateSegment(oldSegment, newSegment))) : (currentMap && !newSegment.map && (newSegment.map = currentMap), result.push(newSegment));
                }
                return result;
            }, resolveSegmentUris = function(segment, baseUri) {
                !segment.resolvedUri && segment.uri && (segment.resolvedUri = resolveUrl(baseUri, segment.uri)), segment.key && !segment.key.resolvedUri && (segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri)), segment.map && !segment.map.resolvedUri && (segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri)), segment.map && segment.map.key && !segment.map.key.resolvedUri && (segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri)), segment.parts && segment.parts.length && segment.parts.forEach(function(p) {
                    p.resolvedUri || (p.resolvedUri = resolveUrl(baseUri, p.uri));
                }), segment.preloadHints && segment.preloadHints.length && segment.preloadHints.forEach(function(p) {
                    p.resolvedUri || (p.resolvedUri = resolveUrl(baseUri, p.uri));
                });
            }, getAllSegments = function(media) {
                var segments = media.segments || [], preloadSegment = media.preloadSegment;
                if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
                    if (preloadSegment.preloadHints) {
                        for(var i = 0; i < preloadSegment.preloadHints.length; i++)if ("MAP" === preloadSegment.preloadHints[i].type) return segments;
                    }
                    preloadSegment.duration = media.targetDuration, preloadSegment.preload = !0, segments.push(preloadSegment);
                }
                return segments;
            }, isPlaylistUnchanged = function(a, b) {
                return a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
            }, updateMaster$1 = function(master, newMedia, unchangedCheck) {
                void 0 === unchangedCheck && (unchangedCheck = isPlaylistUnchanged);
                var result = mergeOptions$2(master, {}), oldMedia = result.playlists[newMedia.id];
                if (!oldMedia || unchangedCheck(oldMedia, newMedia)) return null;
                newMedia.segments = getAllSegments(newMedia);
                var mergedPlaylist = mergeOptions$2(oldMedia, newMedia);
                if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment && delete mergedPlaylist.preloadSegment, oldMedia.segments) {
                    if (newMedia.skip) {
                        newMedia.segments = newMedia.segments || [];
                        for(var i = 0; i < newMedia.skip.skippedSegments; i++)newMedia.segments.unshift({
                            skipped: !0
                        });
                    }
                    mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
                }
                mergedPlaylist.segments.forEach(function(segment) {
                    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
                });
                for(var _i = 0; _i < result.playlists.length; _i++)result.playlists[_i].id === newMedia.id && (result.playlists[_i] = mergedPlaylist);
                return result.playlists[newMedia.id] = mergedPlaylist, result.playlists[newMedia.uri] = mergedPlaylist, forEachMediaGroup(master, function(properties, mediaType, groupKey, labelKey) {
                    if (properties.playlists) for(var _i2 = 0; _i2 < properties.playlists.length; _i2++)newMedia.id === properties.playlists[_i2].id && (properties.playlists[_i2] = newMedia);
                }), result;
            }, refreshDelay = function(media, update) {
                var segments = media.segments || [], lastSegment = segments[segments.length - 1], lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1], lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
                return update && lastDuration ? 1000 * lastDuration : 500 * (media.partTargetDuration || media.targetDuration || 10);
            }, PlaylistLoader = function(_EventTarget) {
                function PlaylistLoader(src, vhs, options) {
                    if (void 0 === options && (options = {}), _this = _EventTarget.call(this) || this, !src) throw Error("A non-empty playlist URL or object is required");
                    _this.logger_ = logger("PlaylistLoader");
                    var _this, _options = options, _options$withCredenti = _options.withCredentials, _options$handleManife = _options.handleManifestRedirects;
                    _this.src = src, _this.vhs_ = vhs, _this.withCredentials = void 0 !== _options$withCredenti && _options$withCredenti, _this.handleManifestRedirects = void 0 !== _options$handleManife && _options$handleManife;
                    var vhsOptions = vhs.options_;
                    return _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [], _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [], _this.experimentalLLHLS = vhsOptions && vhsOptions.experimentalLLHLS || !1, videojs.browser.IE_VERSION && (_this.experimentalLLHLS = !1), _this.state = "HAVE_NOTHING", _this.handleMediaupdatetimeout_ = _this.handleMediaupdatetimeout_.bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), _this.on("mediaupdatetimeout", _this.handleMediaupdatetimeout_), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(PlaylistLoader, _EventTarget);
                var _proto = PlaylistLoader.prototype;
                return _proto.handleMediaupdatetimeout_ = function() {
                    var _this2 = this;
                    if ("HAVE_METADATA" === this.state) {
                        var media = this.media(), uri = resolveUrl(this.master.uri, media.uri);
                        this.experimentalLLHLS && (uri = addLLHLSQueryDirectives(uri, media)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({
                            uri: uri,
                            withCredentials: this.withCredentials
                        }, function(error, req) {
                            if (_this2.request) {
                                if (error) return _this2.playlistRequestError(_this2.request, _this2.media(), "HAVE_METADATA");
                                _this2.haveMetadata({
                                    playlistString: _this2.request.responseText,
                                    url: _this2.media().uri,
                                    id: _this2.media().id
                                });
                            }
                        });
                    }
                }, _proto.playlistRequestError = function(xhr, playlist, startingState) {
                    var uri = playlist.uri, id = playlist.id;
                    this.request = null, startingState && (this.state = startingState), this.error = {
                        playlist: this.master.playlists[id],
                        status: xhr.status,
                        message: "HLS playlist request error at URL: " + uri + ".",
                        responseText: xhr.responseText,
                        code: xhr.status >= 500 ? 4 : 2
                    }, this.trigger("error");
                }, _proto.parseManifest_ = function(_ref) {
                    var _this3 = this, url = _ref.url;
                    return parseManifest({
                        onwarn: function(_ref2) {
                            var message = _ref2.message;
                            return _this3.logger_("m3u8-parser warn for " + url + ": " + message);
                        },
                        oninfo: function(_ref3) {
                            var message = _ref3.message;
                            return _this3.logger_("m3u8-parser info for " + url + ": " + message);
                        },
                        manifestString: _ref.manifestString,
                        customTagParsers: this.customTagParsers,
                        customTagMappers: this.customTagMappers,
                        experimentalLLHLS: this.experimentalLLHLS
                    });
                }, _proto.haveMetadata = function(_ref4) {
                    var playlistString = _ref4.playlistString, playlistObject = _ref4.playlistObject, url = _ref4.url, id = _ref4.id;
                    this.request = null, this.state = "HAVE_METADATA";
                    var playlist = playlistObject || this.parseManifest_({
                        url: url,
                        manifestString: playlistString
                    });
                    playlist.lastRequest = Date.now(), setupMediaPlaylist({
                        playlist: playlist,
                        uri: url,
                        id: id
                    });
                    var update = updateMaster$1(this.master, playlist);
                    this.targetDuration = playlist.partTargetDuration || playlist.targetDuration, this.pendingMedia_ = null, update ? (this.master = update, this.media_ = this.master.playlists[id]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update)), this.trigger("loadedplaylist");
                }, _proto.dispose = function() {
                    this.trigger("dispose"), this.stopRequest(), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaUpdateTimeout), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.finalRenditionTimeout), this.off();
                }, _proto.stopRequest = function() {
                    if (this.request) {
                        var oldRequest = this.request;
                        this.request = null, oldRequest.onreadystatechange = null, oldRequest.abort();
                    }
                }, _proto.media = function(playlist, shouldDelay) {
                    var _this4 = this;
                    if (!playlist) return this.media_;
                    if ("HAVE_NOTHING" === this.state) throw Error("Cannot switch media playlist from " + this.state);
                    if ("string" == typeof playlist) {
                        if (!this.master.playlists[playlist]) throw Error("Unknown playlist URI: " + playlist);
                        playlist = this.master.playlists[playlist];
                    }
                    if (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.finalRenditionTimeout), shouldDelay) {
                        var delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1000 || 5000;
                        this.finalRenditionTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(this.media.bind(this, playlist, !1), delay);
                        return;
                    }
                    var startingState = this.state, mediaChange = !this.media_ || playlist.id !== this.media_.id, masterPlaylistRef = this.master.playlists[playlist.id];
                    if (masterPlaylistRef && masterPlaylistRef.endList || playlist.endList && playlist.segments.length) {
                        this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = playlist, mediaChange && (this.trigger("mediachanging"), "HAVE_MASTER" === startingState ? this.trigger("loadedmetadata") : this.trigger("mediachange"));
                        return;
                    }
                    if (this.updateMediaUpdateTimeout_(refreshDelay(playlist, !0)), mediaChange) {
                        if (this.state = "SWITCHING_MEDIA", this.request) {
                            if (playlist.resolvedUri === this.request.url) return;
                            this.request.onreadystatechange = null, this.request.abort(), this.request = null;
                        }
                        this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = playlist, this.request = this.vhs_.xhr({
                            uri: playlist.resolvedUri,
                            withCredentials: this.withCredentials
                        }, function(error, req) {
                            if (_this4.request) {
                                if (playlist.lastRequest = Date.now(), playlist.resolvedUri = resolveManifestRedirect(_this4.handleManifestRedirects, playlist.resolvedUri, req), error) return _this4.playlistRequestError(_this4.request, playlist, startingState);
                                _this4.haveMetadata({
                                    playlistString: req.responseText,
                                    url: playlist.uri,
                                    id: playlist.id
                                }), "HAVE_MASTER" === startingState ? _this4.trigger("loadedmetadata") : _this4.trigger("mediachange");
                            }
                        });
                    }
                }, _proto.pause = function() {
                    this.mediaUpdateTimeout && (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), "HAVE_NOTHING" === this.state && (this.started = !1), "SWITCHING_MEDIA" === this.state ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MASTER" : "HAVE_CURRENT_METADATA" === this.state && (this.state = "HAVE_METADATA");
                }, _proto.load = function(shouldDelay) {
                    var _this5 = this;
                    this.mediaUpdateTimeout && (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null);
                    var media = this.media();
                    if (shouldDelay) {
                        var delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1000 : 5000;
                        this.mediaUpdateTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                            _this5.mediaUpdateTimeout = null, _this5.load();
                        }, delay);
                        return;
                    }
                    if (!this.started) {
                        this.start();
                        return;
                    }
                    media && !media.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist");
                }, _proto.updateMediaUpdateTimeout_ = function(delay) {
                    var _this6 = this;
                    this.mediaUpdateTimeout && (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.media() && !this.media().endList && (this.mediaUpdateTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                        _this6.mediaUpdateTimeout = null, _this6.trigger("mediaupdatetimeout"), _this6.updateMediaUpdateTimeout_(delay);
                    }, delay));
                }, _proto.start = function() {
                    var _this7 = this;
                    if (this.started = !0, "object" == typeof this.src) {
                        this.src.uri || (this.src.uri = global_window__WEBPACK_IMPORTED_MODULE_0___default().location.href), this.src.resolvedUri = this.src.uri, setTimeout(function() {
                            _this7.setupInitialPlaylist(_this7.src);
                        }, 0);
                        return;
                    }
                    this.request = this.vhs_.xhr({
                        uri: this.src,
                        withCredentials: this.withCredentials
                    }, function(error, req) {
                        if (_this7.request) {
                            if (_this7.request = null, error) return _this7.error = {
                                status: req.status,
                                message: "HLS playlist request error at URL: " + _this7.src + ".",
                                responseText: req.responseText,
                                code: 2
                            }, "HAVE_NOTHING" === _this7.state && (_this7.started = !1), _this7.trigger("error");
                            _this7.src = resolveManifestRedirect(_this7.handleManifestRedirects, _this7.src, req);
                            var manifest = _this7.parseManifest_({
                                manifestString: req.responseText,
                                url: _this7.src
                            });
                            _this7.setupInitialPlaylist(manifest);
                        }
                    });
                }, _proto.srcUri = function() {
                    return "string" == typeof this.src ? this.src : this.src.uri;
                }, _proto.setupInitialPlaylist = function(manifest) {
                    if (this.state = "HAVE_MASTER", manifest.playlists) {
                        this.master = manifest, addPropertiesToMaster(this.master, this.srcUri()), manifest.playlists.forEach(function(playlist) {
                            playlist.segments = getAllSegments(playlist), playlist.segments.forEach(function(segment) {
                                resolveSegmentUris(segment, playlist.resolvedUri);
                            });
                        }), this.trigger("loadedplaylist"), this.request || this.media(this.master.playlists[0]);
                        return;
                    }
                    var uri = this.srcUri() || global_window__WEBPACK_IMPORTED_MODULE_0___default().location.href;
                    this.master = masterForMedia(manifest, uri), this.haveMetadata({
                        playlistObject: manifest,
                        url: uri,
                        id: this.master.playlists[0].id
                    }), this.trigger("loadedmetadata");
                }, PlaylistLoader;
            }(EventTarget$1), videojsXHR = videojs.xhr, mergeOptions$1 = videojs.mergeOptions, callbackWrapper = function(request, error, response, callback) {
                var reqResponse = "arraybuffer" === request.responseType ? request.response : request.responseText;
                error || !reqResponse || (request.responseTime = Date.now(), request.roundTripTime = request.responseTime - request.requestTime, request.bytesReceived = reqResponse.byteLength || reqResponse.length, request.bandwidth || (request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8000))), response.headers && (request.responseHeaders = response.headers), error && "ETIMEDOUT" === error.code && (request.timedout = !0), error || request.aborted || 200 === response.statusCode || 206 === response.statusCode || 0 === response.statusCode || (error = Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)))), callback(error, request);
            }, xhrFactory = function() {
                var xhr = function XhrFunction(options, callback) {
                    options = mergeOptions$1({
                        timeout: 45e3
                    }, options);
                    var beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;
                    if (beforeRequest && "function" == typeof beforeRequest) {
                        var newOptions = beforeRequest(options);
                        newOptions && (options = newOptions);
                    }
                    var request = (!0 === videojs.Vhs.xhr.original ? videojsXHR : videojs.Vhs.xhr)(options, function(error, response) {
                        return callbackWrapper(request, error, response, callback);
                    }), originalAbort = request.abort;
                    return request.abort = function() {
                        return request.aborted = !0, originalAbort.apply(request, arguments);
                    }, request.uri = options.uri, request.requestTime = Date.now(), request;
                };
                return xhr.original = !0, xhr;
            }, byterangeStr = function(byterange) {
                var byterangeEnd = byterange.offset + byterange.length - 1;
                return "bytes=" + byterange.offset + "-" + byterangeEnd;
            }, segmentXhrHeaders = function(segment) {
                var headers = {};
                return segment.byterange && (headers.Range = byterangeStr(segment.byterange)), headers;
            }, formatHexString = function(e, i) {
                var value = e.toString(16);
                return "00".substring(0, 2 - value.length) + value + (i % 2 ? " " : "");
            }, formatAsciiString = function(e) {
                return e >= 0x20 && e < 0x7e ? String.fromCharCode(e) : ".";
            }, createTransferableMessage = function(message) {
                var transferable = {};
                return Object.keys(message).forEach(function(key) {
                    var value = message[key];
                    ArrayBuffer.isView(value) ? transferable[key] = {
                        bytes: value.buffer,
                        byteOffset: value.byteOffset,
                        byteLength: value.byteLength
                    } : transferable[key] = value;
                }), transferable;
            }, initSegmentId = function(initSegment) {
                var byterange = initSegment.byterange || {
                    length: 1 / 0,
                    offset: 0
                };
                return [
                    byterange.length,
                    byterange.offset,
                    initSegment.resolvedUri
                ].join(",");
            }, segmentKeyId = function(key) {
                return key.resolvedUri;
            }, hexDump = function(data) {
                for(var bytes = Array.prototype.slice.call(data), result = "", j = 0; j < bytes.length / 16; j++)result += bytes.slice(16 * j, 16 * j + 16).map(formatHexString).join("") + " " + bytes.slice(16 * j, 16 * j + 16).map(formatAsciiString).join("") + "\n";
                return result;
            }, utils = Object.freeze({
                __proto__: null,
                createTransferableMessage: createTransferableMessage,
                initSegmentId: initSegmentId,
                segmentKeyId: segmentKeyId,
                hexDump: hexDump,
                tagDump: function(_ref) {
                    return hexDump(_ref.bytes);
                },
                textRanges: function(ranges) {
                    var i, i1, result = "";
                    for(i1 = 0; i1 < ranges.length; i1++)result += (i = i1, ranges.start(i) + "-" + ranges.end(i) + " ");
                    return result;
                }
            }), playerTimeToProgramTime = function(playerTime, segment) {
                if (!segment.dateTimeObject) return null;
                var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds, transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
                return new Date(segment.dateTimeObject.getTime() + 1000 * (playerTime - (transmuxedStart + transmuxerPrependedSeconds)));
            }, findSegmentForProgramTime = function(programTime, playlist) {
                try {
                    dateTimeObject = new Date(programTime);
                } catch (e) {
                    return null;
                }
                if (!playlist || !playlist.segments || 0 === playlist.segments.length) return null;
                var videoTimingInfo, dateTimeObject, segment = playlist.segments[0];
                if (dateTimeObject < segment.dateTimeObject) return null;
                for(var i = 0; i < playlist.segments.length - 1 && (segment = playlist.segments[i], !(dateTimeObject < playlist.segments[i + 1].dateTimeObject)); i++);
                var lastSegment = playlist.segments[playlist.segments.length - 1], lastSegmentStart = lastSegment.dateTimeObject, lastSegmentDuration = lastSegment.videoTimingInfo ? (videoTimingInfo = lastSegment.videoTimingInfo).transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds : lastSegment.duration + 0.25 * lastSegment.duration;
                return dateTimeObject > new Date(lastSegmentStart.getTime() + 1000 * lastSegmentDuration) ? null : (dateTimeObject > lastSegmentStart && (segment = lastSegment), {
                    segment: segment,
                    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
                    type: segment.videoTimingInfo ? "accurate" : "estimate"
                });
            }, findSegmentForPlayerTime = function(time, playlist) {
                if (!playlist || !playlist.segments || 0 === playlist.segments.length) return null;
                for(var segment, segmentEnd = 0, i = 0; i < playlist.segments.length && !(time <= (segmentEnd = (segment = playlist.segments[i]).videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration)); i++);
                var lastSegment = playlist.segments[playlist.segments.length - 1];
                if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) return null;
                if (time > segmentEnd) {
                    if (time > segmentEnd + 0.25 * lastSegment.duration) return null;
                    segment = lastSegment;
                }
                return {
                    segment: segment,
                    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
                    type: segment.videoTimingInfo ? "accurate" : "estimate"
                };
            }, getOffsetFromTimestamp = function(comparisonTimeStamp, programTime) {
                try {
                    segmentDateTime = new Date(comparisonTimeStamp), programDateTime = new Date(programTime);
                } catch (e) {}
                var segmentDateTime, programDateTime, segmentTimeEpoch = segmentDateTime.getTime();
                return (programDateTime.getTime() - segmentTimeEpoch) / 1000;
            }, verifyProgramDateTimeTags = function(playlist) {
                if (!playlist.segments || 0 === playlist.segments.length) return !1;
                for(var i = 0; i < playlist.segments.length; i++)if (!playlist.segments[i].dateTimeObject) return !1;
                return !0;
            }, getProgramTime = function(_ref) {
                var playlist = _ref.playlist, _ref$time = _ref.time, time = void 0 === _ref$time ? void 0 : _ref$time, callback = _ref.callback;
                if (!callback) throw Error("getProgramTime: callback must be provided");
                if (!playlist || void 0 === time) return callback({
                    message: "getProgramTime: playlist and time must be provided"
                });
                var matchedSegment = findSegmentForPlayerTime(time, playlist);
                if (!matchedSegment) return callback({
                    message: "valid programTime was not found"
                });
                if ("estimate" === matchedSegment.type) return callback({
                    message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
                    seekTime: matchedSegment.estimatedStart
                });
                var programTimeObject = {
                    mediaSeconds: time
                }, programTime = playerTimeToProgramTime(time, matchedSegment.segment);
                return programTime && (programTimeObject.programDateTime = programTime.toISOString()), callback(null, programTimeObject);
            }, seekToProgramTime = function seekToProgramTime(_ref2) {
                var programTime = _ref2.programTime, playlist = _ref2.playlist, _ref2$retryCount = _ref2.retryCount, retryCount = void 0 === _ref2$retryCount ? 2 : _ref2$retryCount, seekTo = _ref2.seekTo, _ref2$pauseAfterSeek = _ref2.pauseAfterSeek, pauseAfterSeek = void 0 === _ref2$pauseAfterSeek || _ref2$pauseAfterSeek, tech = _ref2.tech, callback = _ref2.callback;
                if (!callback) throw Error("seekToProgramTime: callback must be provided");
                if (void 0 === programTime || !playlist || !seekTo) return callback({
                    message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
                });
                if (!playlist.endList && !tech.hasStarted_) return callback({
                    message: "player must be playing a live stream to start buffering"
                });
                if (!verifyProgramDateTimeTags(playlist)) return callback({
                    message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
                });
                var matchedSegment = findSegmentForProgramTime(programTime, playlist);
                if (!matchedSegment) return callback({
                    message: programTime + " was not found in the stream"
                });
                var segment = matchedSegment.segment, mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
                if ("estimate" === matchedSegment.type) return 0 === retryCount ? callback({
                    message: programTime + " is not buffered yet. Try again"
                }) : (seekTo(matchedSegment.estimatedStart + mediaOffset), void tech.one("seeked", function() {
                    seekToProgramTime({
                        programTime: programTime,
                        playlist: playlist,
                        retryCount: retryCount - 1,
                        seekTo: seekTo,
                        pauseAfterSeek: pauseAfterSeek,
                        tech: tech,
                        callback: callback
                    });
                }));
                var seekToTime = segment.start + mediaOffset;
                tech.one("seeked", function() {
                    return callback(null, tech.currentTime());
                }), pauseAfterSeek && tech.pause(), seekTo(seekToTime);
            }, callbackOnCompleted = function(request, cb) {
                if (4 === request.readyState) return cb();
            }, containerRequest = function(uri, xhr, cb) {
                var id3Offset, bytes = [], finished = !1, endRequestAndCallback = function(err, req, type, _bytes) {
                    return req.abort(), finished = !0, cb(err, req, type, _bytes);
                }, progressListener = function(error, request) {
                    if (!finished) {
                        if (error) return endRequestAndCallback(error, request, "", bytes);
                        var newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length);
                        if (bytes = (0, _videojs_vhs_utils_es_byte_helpers__WEBPACK_IMPORTED_MODULE_13__.lx)(bytes, (0, _videojs_vhs_utils_es_byte_helpers__WEBPACK_IMPORTED_MODULE_13__.qX)(newPart, !0)), id3Offset = id3Offset || (0, _videojs_vhs_utils_es_id3_helpers__WEBPACK_IMPORTED_MODULE_11__.c)(bytes), bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) return callbackOnCompleted(request, function() {
                            return endRequestAndCallback(error, request, "", bytes);
                        });
                        var type = (0, _videojs_vhs_utils_es_containers__WEBPACK_IMPORTED_MODULE_12__.Xm)(bytes);
                        return "ts" === type && bytes.length < 188 || !type && bytes.length < 376 ? callbackOnCompleted(request, function() {
                            return endRequestAndCallback(error, request, "", bytes);
                        }) : endRequestAndCallback(null, request, type, bytes);
                    }
                }, request = xhr({
                    uri: uri,
                    beforeSend: function(request) {
                        request.overrideMimeType("text/plain; charset=x-user-defined"), request.addEventListener("progress", function(_ref) {
                            return _ref.total, _ref.loaded, callbackWrapper(request, null, {
                                statusCode: request.status
                            }, progressListener);
                        });
                    }
                }, function(error, response) {
                    return callbackWrapper(request, error, response, progressListener);
                });
                return request;
            }, EventTarget = videojs.EventTarget, mergeOptions = videojs.mergeOptions, dashPlaylistUnchanged = function(a, b) {
                if (!isPlaylistUnchanged(a, b) || a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length) || !a.sidx && b.sidx || a.sidx && !b.sidx || a.segments && !b.segments || !a.segments && b.segments) return !1;
                if (!a.segments && !b.segments) return !0;
                for(var i = 0; i < a.segments.length; i++){
                    var aSegment = a.segments[i], bSegment = b.segments[i];
                    if (aSegment.uri !== bSegment.uri) return !1;
                    if (aSegment.byterange || bSegment.byterange) {
                        var aByterange = aSegment.byterange, bByterange = bSegment.byterange;
                        if (aByterange && !bByterange || !aByterange && bByterange || aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) return !1;
                    }
                }
                return !0;
            }, parseMasterXml = function(_ref) {
                var masterXml = _ref.masterXml, srcUrl = _ref.srcUrl, clientOffset = _ref.clientOffset, sidxMapping = _ref.sidxMapping, master = (0, mpd_parser__WEBPACK_IMPORTED_MODULE_9__.Qc)(masterXml, {
                    manifestUri: srcUrl,
                    clientOffset: clientOffset,
                    sidxMapping: sidxMapping
                });
                return addPropertiesToMaster(master, srcUrl), master;
            }, updateMaster = function(oldMaster, newMaster, sidxMapping) {
                for(var noChanges = !0, update = mergeOptions(oldMaster, {
                    duration: newMaster.duration,
                    minimumUpdatePeriod: newMaster.minimumUpdatePeriod
                }), i = 0; i < newMaster.playlists.length; i++){
                    var playlist = newMaster.playlists[i];
                    if (playlist.sidx) {
                        var sidxKey = (0, mpd_parser__WEBPACK_IMPORTED_MODULE_9__.mm)(playlist.sidx);
                        sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx && (0, mpd_parser__WEBPACK_IMPORTED_MODULE_9__.jp)(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
                    }
                    var playlistUpdate = updateMaster$1(update, playlist, dashPlaylistUnchanged);
                    playlistUpdate && (update = playlistUpdate, noChanges = !1);
                }
                return (forEachMediaGroup(newMaster, function(properties, type, group, label) {
                    if (properties.playlists && properties.playlists.length) {
                        var id = properties.playlists[0].id, _playlistUpdate = updateMaster$1(update, properties.playlists[0], dashPlaylistUnchanged);
                        _playlistUpdate && ((update = _playlistUpdate).mediaGroups[type][group][label].playlists[0] = update.playlists[id], noChanges = !1);
                    }
                }), newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod && (noChanges = !1), noChanges) ? null : update;
            }, compareSidxEntry = function(playlists, oldSidxMapping) {
                var newSidxMapping = {};
                for(var id in playlists){
                    var currentSidxInfo = playlists[id].sidx;
                    if (currentSidxInfo) {
                        var a, key = (0, mpd_parser__WEBPACK_IMPORTED_MODULE_9__.mm)(currentSidxInfo);
                        if (!oldSidxMapping[key]) break;
                        (Boolean(!(a = oldSidxMapping[key].sidxInfo).map && !currentSidxInfo.map) || Boolean(a.map && currentSidxInfo.map && a.map.byterange.offset === currentSidxInfo.map.byterange.offset && a.map.byterange.length === currentSidxInfo.map.byterange.length)) && a.uri === currentSidxInfo.uri && a.byterange.offset === currentSidxInfo.byterange.offset && a.byterange.length === currentSidxInfo.byterange.length && (newSidxMapping[key] = oldSidxMapping[key]);
                    }
                }
                return newSidxMapping;
            }, filterChangedSidxMappings = function(master, oldSidxMapping) {
                var mediaGroupSidx = compareSidxEntry(master.playlists, oldSidxMapping);
                return forEachMediaGroup(master, function(properties, mediaType, groupKey, labelKey) {
                    properties.playlists && properties.playlists.length && (mediaGroupSidx = mergeOptions(mediaGroupSidx, compareSidxEntry(properties.playlists, oldSidxMapping)));
                }), mediaGroupSidx;
            }, DashPlaylistLoader = function(_EventTarget) {
                function DashPlaylistLoader(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {
                    void 0 === options && (options = {}), (_this = _EventTarget.call(this) || this).masterPlaylistLoader_ = masterPlaylistLoader || (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), masterPlaylistLoader || (_this.isMaster_ = !0);
                    var _this, _options = options, _options$withCredenti = _options.withCredentials, _options$handleManife = _options.handleManifestRedirects;
                    if (_this.vhs_ = vhs, _this.withCredentials = void 0 !== _options$withCredenti && _options$withCredenti, _this.handleManifestRedirects = void 0 !== _options$handleManife && _options$handleManife, !srcUrlOrPlaylist) throw Error("A non-empty playlist URL or object is required");
                    return _this.on("minimumUpdatePeriod", function() {
                        _this.refreshXml_();
                    }), _this.on("mediaupdatetimeout", function() {
                        _this.refreshMedia_(_this.media().id);
                    }), _this.state = "HAVE_NOTHING", _this.loadedPlaylists_ = {}, _this.logger_ = logger("DashPlaylistLoader"), _this.isMaster_ ? (_this.masterPlaylistLoader_.srcUrl = srcUrlOrPlaylist, _this.masterPlaylistLoader_.sidxMapping_ = {}) : _this.childPlaylist_ = srcUrlOrPlaylist, _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(DashPlaylistLoader, _EventTarget);
                var _proto = DashPlaylistLoader.prototype;
                return _proto.requestErrored_ = function(err, request, startingState) {
                    return !this.request || ((this.request = null, err) ? (this.error = "object" != typeof err || err instanceof Error ? {
                        status: request.status,
                        message: "DASH request error at URL: " + request.uri,
                        response: request.response,
                        code: 2
                    } : err, startingState && (this.state = startingState), this.trigger("error"), !0) : void 0);
                }, _proto.addSidxSegments_ = function(playlist, startingState, cb) {
                    var _this2 = this, sidxKey = playlist.sidx && (0, mpd_parser__WEBPACK_IMPORTED_MODULE_9__.mm)(playlist.sidx);
                    if (!playlist.sidx || !sidxKey || this.masterPlaylistLoader_.sidxMapping_[sidxKey]) {
                        this.mediaRequest_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                            return cb(!1);
                        }, 0);
                        return;
                    }
                    var uri = resolveManifestRedirect(this.handleManifestRedirects, playlist.sidx.resolvedUri), fin = function(err, request) {
                        if (!_this2.requestErrored_(err, request, startingState)) {
                            var sidx, sidxMapping = _this2.masterPlaylistLoader_.sidxMapping_;
                            try {
                                sidx = mux_js_lib_tools_parse_sidx__WEBPACK_IMPORTED_MODULE_10___default()((0, _videojs_vhs_utils_es_byte_helpers__WEBPACK_IMPORTED_MODULE_13__.Ki)(request.response).subarray(8));
                            } catch (e) {
                                _this2.requestErrored_(e, request, startingState);
                                return;
                            }
                            return sidxMapping[sidxKey] = {
                                sidxInfo: playlist.sidx,
                                sidx: sidx
                            }, (0, mpd_parser__WEBPACK_IMPORTED_MODULE_9__.jp)(playlist, sidx, playlist.sidx.resolvedUri), cb(!0);
                        }
                    };
                    this.request = containerRequest(uri, this.vhs_.xhr, function(err, request, container, bytes) {
                        if (err) return fin(err, request);
                        if (!container || "mp4" !== container) return fin({
                            status: request.status,
                            message: "Unsupported " + (container || "unknown") + " container type for sidx segment at URL: " + uri,
                            response: "",
                            playlist: playlist,
                            internal: !0,
                            blacklistDuration: 1 / 0,
                            code: 2
                        }, request);
                        var _playlist$sidx$bytera = playlist.sidx.byterange, offset = _playlist$sidx$bytera.offset, length = _playlist$sidx$bytera.length;
                        if (bytes.length >= length + offset) return fin(err, {
                            response: bytes.subarray(offset, offset + length),
                            status: request.status,
                            uri: request.uri
                        });
                        _this2.request = _this2.vhs_.xhr({
                            uri: uri,
                            responseType: "arraybuffer",
                            headers: segmentXhrHeaders({
                                byterange: playlist.sidx.byterange
                            })
                        }, fin);
                    });
                }, _proto.dispose = function() {
                    this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.minimumUpdatePeriodTimeout_), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaRequest_), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.masterPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_), this.masterPlaylistLoader_.createMupOnMedia_ = null), this.off();
                }, _proto.hasPendingRequest = function() {
                    return this.request || this.mediaRequest_;
                }, _proto.stopRequest = function() {
                    if (this.request) {
                        var oldRequest = this.request;
                        this.request = null, oldRequest.onreadystatechange = null, oldRequest.abort();
                    }
                }, _proto.media = function(playlist) {
                    var _this3 = this;
                    if (!playlist) return this.media_;
                    if ("HAVE_NOTHING" === this.state) throw Error("Cannot switch media playlist from " + this.state);
                    var startingState = this.state;
                    if ("string" == typeof playlist) {
                        if (!this.masterPlaylistLoader_.master.playlists[playlist]) throw Error("Unknown playlist URI: " + playlist);
                        playlist = this.masterPlaylistLoader_.master.playlists[playlist];
                    }
                    var mediaChange = !this.media_ || playlist.id !== this.media_.id;
                    if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
                        this.state = "HAVE_METADATA", this.media_ = playlist, mediaChange && (this.trigger("mediachanging"), this.trigger("mediachange"));
                        return;
                    }
                    mediaChange && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(playlist, startingState, function(sidxChanged) {
                        _this3.haveMetadata({
                            startingState: startingState,
                            playlist: playlist
                        });
                    }));
                }, _proto.haveMetadata = function(_ref2) {
                    var startingState = _ref2.startingState, playlist = _ref2.playlist;
                    this.state = "HAVE_METADATA", this.loadedPlaylists_[playlist.id] = playlist, this.mediaRequest_ = null, this.refreshMedia_(playlist.id), "HAVE_MASTER" === startingState ? this.trigger("loadedmetadata") : this.trigger("mediachange");
                }, _proto.pause = function() {
                    this.masterPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_), this.masterPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMaster_ && (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_), this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), "HAVE_NOTHING" === this.state && (this.started = !1);
                }, _proto.load = function(isFinalRendition) {
                    var _this4 = this;
                    global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null;
                    var media = this.media();
                    if (isFinalRendition) {
                        var delay = media ? media.targetDuration / 2 * 1000 : 5000;
                        this.mediaUpdateTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                            return _this4.load();
                        }, delay);
                        return;
                    }
                    if (!this.started) {
                        this.start();
                        return;
                    }
                    media && !media.endList ? (this.isMaster_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist");
                }, _proto.start = function() {
                    var _this5 = this;
                    if (this.started = !0, !this.isMaster_) {
                        this.mediaRequest_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                            return _this5.haveMaster_();
                        }, 0);
                        return;
                    }
                    this.requestMaster_(function(req, masterChanged) {
                        _this5.haveMaster_(), _this5.hasPendingRequest() || _this5.media_ || _this5.media(_this5.masterPlaylistLoader_.master.playlists[0]);
                    });
                }, _proto.requestMaster_ = function(cb) {
                    var _this6 = this;
                    this.request = this.vhs_.xhr({
                        uri: this.masterPlaylistLoader_.srcUrl,
                        withCredentials: this.withCredentials
                    }, function(error, req) {
                        if (_this6.requestErrored_(error, req)) {
                            "HAVE_NOTHING" === _this6.state && (_this6.started = !1);
                            return;
                        }
                        var masterChanged = req.responseText !== _this6.masterPlaylistLoader_.masterXml_;
                        if (_this6.masterPlaylistLoader_.masterXml_ = req.responseText, req.responseHeaders && req.responseHeaders.date ? _this6.masterLoaded_ = Date.parse(req.responseHeaders.date) : _this6.masterLoaded_ = Date.now(), _this6.masterPlaylistLoader_.srcUrl = resolveManifestRedirect(_this6.handleManifestRedirects, _this6.masterPlaylistLoader_.srcUrl, req), masterChanged) {
                            _this6.handleMaster_(), _this6.syncClientServerClock_(function() {
                                return cb(req, masterChanged);
                            });
                            return;
                        }
                        return cb(req, masterChanged);
                    });
                }, _proto.syncClientServerClock_ = function(done) {
                    var _this7 = this, utcTiming = (0, mpd_parser__WEBPACK_IMPORTED_MODULE_9__.LG)(this.masterPlaylistLoader_.masterXml_);
                    return null === utcTiming ? (this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now(), done()) : "DIRECT" === utcTiming.method ? (this.masterPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now(), done()) : void (this.request = this.vhs_.xhr({
                        uri: resolveUrl(this.masterPlaylistLoader_.srcUrl, utcTiming.value),
                        method: utcTiming.method,
                        withCredentials: this.withCredentials
                    }, function(error, req) {
                        var serverTime;
                        if (_this7.request) {
                            if (error) return _this7.masterPlaylistLoader_.clientOffset_ = _this7.masterLoaded_ - Date.now(), done();
                            serverTime = "HEAD" === utcTiming.method ? req.responseHeaders && req.responseHeaders.date ? Date.parse(req.responseHeaders.date) : _this7.masterLoaded_ : Date.parse(req.responseText), _this7.masterPlaylistLoader_.clientOffset_ = serverTime - Date.now(), done();
                        }
                    }));
                }, _proto.haveMaster_ = function() {
                    this.state = "HAVE_MASTER", this.isMaster_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_);
                }, _proto.handleMaster_ = function() {
                    this.mediaRequest_ = null;
                    var newMaster = parseMasterXml({
                        masterXml: this.masterPlaylistLoader_.masterXml_,
                        srcUrl: this.masterPlaylistLoader_.srcUrl,
                        clientOffset: this.masterPlaylistLoader_.clientOffset_,
                        sidxMapping: this.masterPlaylistLoader_.sidxMapping_
                    }), oldMaster = this.masterPlaylistLoader_.master;
                    oldMaster && (newMaster = updateMaster(oldMaster, newMaster, this.masterPlaylistLoader_.sidxMapping_)), this.masterPlaylistLoader_.master = newMaster || oldMaster;
                    var location = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
                    return location && location !== this.masterPlaylistLoader_.srcUrl && (this.masterPlaylistLoader_.srcUrl = location), (!oldMaster || newMaster && newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), Boolean(newMaster);
                }, _proto.updateMinimumUpdatePeriodTimeout_ = function() {
                    var mpl = this.masterPlaylistLoader_;
                    mpl.createMupOnMedia_ && (mpl.off("loadedmetadata", mpl.createMupOnMedia_), mpl.createMupOnMedia_ = null), mpl.minimumUpdatePeriodTimeout_ && (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(mpl.minimumUpdatePeriodTimeout_), mpl.minimumUpdatePeriodTimeout_ = null);
                    var mup = mpl.master && mpl.master.minimumUpdatePeriod;
                    if (0 === mup && (mpl.media() ? mup = 1000 * mpl.media().targetDuration : (mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_, mpl.one("loadedmetadata", mpl.createMupOnMedia_))), "number" != typeof mup || mup <= 0) {
                        mup < 0 && this.logger_("found invalid minimumUpdatePeriod of " + mup + ", not setting a timeout");
                        return;
                    }
                    this.createMUPTimeout_(mup);
                }, _proto.createMUPTimeout_ = function(mup) {
                    var mpl = this.masterPlaylistLoader_;
                    mpl.minimumUpdatePeriodTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                        mpl.minimumUpdatePeriodTimeout_ = null, mpl.trigger("minimumUpdatePeriod"), mpl.createMUPTimeout_(mup);
                    }, mup);
                }, _proto.refreshXml_ = function() {
                    var _this8 = this;
                    this.requestMaster_(function(req, masterChanged) {
                        masterChanged && (_this8.media_ && (_this8.media_ = _this8.masterPlaylistLoader_.master.playlists[_this8.media_.id]), _this8.masterPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(_this8.masterPlaylistLoader_.master, _this8.masterPlaylistLoader_.sidxMapping_), _this8.addSidxSegments_(_this8.media(), _this8.state, function(sidxChanged) {
                            _this8.refreshMedia_(_this8.media().id);
                        }));
                    });
                }, _proto.refreshMedia_ = function(mediaID) {
                    var _this9 = this;
                    if (!mediaID) throw Error("refreshMedia_ must take a media id");
                    this.media_ && this.isMaster_ && this.handleMaster_();
                    var playlists = this.masterPlaylistLoader_.master.playlists, mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
                    mediaChanged ? this.media_ = playlists[mediaID] : this.trigger("playlistunchanged"), this.mediaUpdateTimeout || function createMediaUpdateTimeout() {
                        _this9.media().endList || (_this9.mediaUpdateTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                            _this9.trigger("mediaupdatetimeout"), createMediaUpdateTimeout();
                        }, refreshDelay(_this9.media(), Boolean(mediaChanged))));
                    }(), this.trigger("loadedplaylist");
                }, DashPlaylistLoader;
            }(EventTarget), Config = {
                GOAL_BUFFER_LENGTH: 30,
                MAX_GOAL_BUFFER_LENGTH: 60,
                BACK_BUFFER_LENGTH: 30,
                GOAL_BUFFER_LENGTH_RATE: 1,
                INITIAL_BANDWIDTH: 4194304,
                BANDWIDTH_VARIANCE: 1.2,
                BUFFER_LOW_WATER_LINE: 0,
                MAX_BUFFER_LOW_WATER_LINE: 30,
                EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
                BUFFER_LOW_WATER_LINE_RATE: 1,
                BUFFER_HIGH_WATER_LINE: 30
            }, stringToArrayBuffer = function(string) {
                for(var view = new Uint8Array(new ArrayBuffer(string.length)), i = 0; i < string.length; i++)view[i] = string.charCodeAt(i);
                return view.buffer;
            }, browserWorkerPolyFill = function(workerObj) {
                return workerObj.on = workerObj.addEventListener, workerObj.off = workerObj.removeEventListener, workerObj;
            }, createObjectURL = function(str) {
                try {
                    return URL.createObjectURL(new Blob([
                        str
                    ], {
                        type: "application/javascript"
                    }));
                } catch (e) {
                    var blob = new BlobBuilder();
                    return blob.append(str), URL.createObjectURL(blob.getBlob());
                }
            }, factory = function(code) {
                return function() {
                    var objectUrl = createObjectURL(code), worker = browserWorkerPolyFill(new Worker(objectUrl));
                    worker.objURL = objectUrl;
                    var terminate = worker.terminate;
                    return worker.on = worker.addEventListener, worker.off = worker.removeEventListener, worker.terminate = function() {
                        return URL.revokeObjectURL(objectUrl), terminate.call(this);
                    }, worker;
                };
            }, transform = function(code) {
                return "var browserWorkerPolyFill = " + browserWorkerPolyFill.toString() + ";\nbrowserWorkerPolyFill(self);\n" + code;
            }, getWorkerString = function(fn) {
                return fn.toString().replace(/^function.+?{/, "").slice(0, -1);
            }, TransmuxWorker = factory(transform(getWorkerString(function() {
                var _TransportPacketStream, _TransportParseStream, _ElementaryStream, _AdtsStream, _H264Stream, _NalByteStream, PROFILES_WITH_OPTIONAL_SPS_DATA, _AacStream, _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream, getTimescaleFromMediaHeader, Stream = function() {
                    this.init = function() {
                        var listeners = {};
                        this.on = function(type, listener) {
                            listeners[type] || (listeners[type] = []), listeners[type] = listeners[type].concat(listener);
                        }, this.off = function(type, listener) {
                            var index;
                            return !!listeners[type] && (index = listeners[type].indexOf(listener), listeners[type] = listeners[type].slice(), listeners[type].splice(index, 1), index > -1);
                        }, this.trigger = function(type) {
                            var callbacks, i, length, args;
                            if (callbacks = listeners[type]) {
                                if (2 == arguments.length) for(i = 0, length = callbacks.length; i < length; ++i)callbacks[i].call(this, arguments[1]);
                                else {
                                    for(args = [], i = arguments.length, i = 1; i < arguments.length; ++i)args.push(arguments[i]);
                                    for(i = 0, length = callbacks.length; i < length; ++i)callbacks[i].apply(this, args);
                                }
                            }
                        }, this.dispose = function() {
                            listeners = {};
                        };
                    };
                };
                Stream.prototype.pipe = function(destination) {
                    return this.on("data", function(data) {
                        destination.push(data);
                    }), this.on("done", function(flushSource) {
                        destination.flush(flushSource);
                    }), this.on("partialdone", function(flushSource) {
                        destination.partialFlush(flushSource);
                    }), this.on("endedtimeline", function(flushSource) {
                        destination.endTimeline(flushSource);
                    }), this.on("reset", function(flushSource) {
                        destination.reset(flushSource);
                    }), destination;
                }, Stream.prototype.push = function(data) {
                    this.trigger("data", data);
                }, Stream.prototype.flush = function(flushSource) {
                    this.trigger("done", flushSource);
                }, Stream.prototype.partialFlush = function(flushSource) {
                    this.trigger("partialdone", flushSource);
                }, Stream.prototype.endTimeline = function(flushSource) {
                    this.trigger("endedtimeline", flushSource);
                }, Stream.prototype.reset = function(flushSource) {
                    this.trigger("reset", flushSource);
                }, function() {
                    var i;
                    if (types = {
                        avc1: [],
                        avcC: [],
                        btrt: [],
                        dinf: [],
                        dref: [],
                        esds: [],
                        ftyp: [],
                        hdlr: [],
                        mdat: [],
                        mdhd: [],
                        mdia: [],
                        mfhd: [],
                        minf: [],
                        moof: [],
                        moov: [],
                        mp4a: [],
                        mvex: [],
                        mvhd: [],
                        pasp: [],
                        sdtp: [],
                        smhd: [],
                        stbl: [],
                        stco: [],
                        stsc: [],
                        stsd: [],
                        stsz: [],
                        stts: [],
                        styp: [],
                        tfdt: [],
                        tfhd: [],
                        traf: [],
                        trak: [],
                        trun: [],
                        trex: [],
                        tkhd: [],
                        vmhd: []
                    }, "undefined" != typeof Uint8Array) {
                        for(i in types)types.hasOwnProperty(i) && (types[i] = [
                            i.charCodeAt(0),
                            i.charCodeAt(1),
                            i.charCodeAt(2),
                            i.charCodeAt(3)
                        ]);
                        MAJOR_BRAND = new Uint8Array([
                            105,
                            115,
                            111,
                            109
                        ]), AVC1_BRAND = new Uint8Array([
                            97,
                            118,
                            99,
                            49
                        ]), MINOR_VERSION = new Uint8Array([
                            0,
                            0,
                            0,
                            1
                        ]), HDLR_TYPES = {
                            video: new Uint8Array([
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x76,
                                0x69,
                                0x64,
                                0x65,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x56,
                                0x69,
                                0x64,
                                0x65,
                                0x6f,
                                0x48,
                                0x61,
                                0x6e,
                                0x64,
                                0x6c,
                                0x65,
                                0x72,
                                0x00
                            ]),
                            audio: new Uint8Array([
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x73,
                                0x6f,
                                0x75,
                                0x6e,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                0x53,
                                0x6f,
                                0x75,
                                0x6e,
                                0x64,
                                0x48,
                                0x61,
                                0x6e,
                                0x64,
                                0x6c,
                                0x65,
                                0x72,
                                0x00
                            ])
                        }, DREF = new Uint8Array([
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x01,
                            0x00,
                            0x00,
                            0x00,
                            0x0c,
                            0x75,
                            0x72,
                            0x6c,
                            0x20,
                            0x00,
                            0x00,
                            0x00,
                            0x01
                        ]), SMHD = new Uint8Array([
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00
                        ]), STSC = STCO = new Uint8Array([
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00
                        ]), STSZ = new Uint8Array([
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00
                        ]), STTS = STCO, VMHD = new Uint8Array([
                            0x00,
                            0x00,
                            0x00,
                            0x01,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00
                        ]);
                    }
                }(), box = function(type) {
                    var i, result, payload = [], size = 0;
                    for(i = 1; i < arguments.length; i++)payload.push(arguments[i]);
                    for(i = payload.length; i--;)size += payload[i].byteLength;
                    for(result = new Uint8Array(size + 8), new DataView(result.buffer, result.byteOffset, result.byteLength).setUint32(0, result.byteLength), result.set(type, 4), i = 0, size = 8; i < payload.length; i++)result.set(payload[i], size), size += payload[i].byteLength;
                    return result;
                }, ftyp = function() {
                    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
                }, mdhd = function(track) {
                    var result = new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x02,
                        0x00,
                        0x00,
                        0x00,
                        0x03,
                        0x00,
                        0x01,
                        0x5f,
                        0x90,
                        track.duration >>> 24 & 0xff,
                        track.duration >>> 16 & 0xff,
                        track.duration >>> 8 & 0xff,
                        0xff & track.duration,
                        0x55,
                        0xc4,
                        0x00,
                        0x00
                    ]);
                    return track.samplerate && (result[12] = track.samplerate >>> 24 & 0xff, result[13] = track.samplerate >>> 16 & 0xff, result[14] = track.samplerate >>> 8 & 0xff, result[15] = 0xff & track.samplerate), box(types.mdhd, result);
                }, mdia = function(track) {
                    var type;
                    return box(types.mdia, mdhd(track), (type = track.type, box(types.hdlr, HDLR_TYPES[type])), minf(track));
                }, minf = function(track) {
                    return box(types.minf, "video" === track.type ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), box(types.dinf, box(types.dref, DREF)), stbl(track));
                }, moov = function(tracks) {
                    for(var i = tracks.length, boxes = []; i--;)boxes[i] = trak(tracks[i]);
                    return box.apply(null, [
                        types.moov,
                        mvhd(0xffffffff)
                    ].concat(boxes).concat(mvex(tracks)));
                }, mvex = function(tracks) {
                    for(var i = tracks.length, boxes = []; i--;)boxes[i] = trex(tracks[i]);
                    return box.apply(null, [
                        types.mvex
                    ].concat(boxes));
                }, mvhd = function(duration) {
                    var bytes = new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x02,
                        0x00,
                        0x01,
                        0x5f,
                        0x90,
                        (0xff000000 & duration) >> 24,
                        (0xff0000 & duration) >> 16,
                        (0xff00 & duration) >> 8,
                        0xff & duration,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x40,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0xff,
                        0xff,
                        0xff,
                        0xff
                    ]);
                    return box(types.mvhd, bytes);
                }, sdtp = function(track) {
                    var flags, i, samples = track.samples || [], bytes = new Uint8Array(4 + samples.length);
                    for(i = 0; i < samples.length; i++)flags = samples[i].flags, bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
                    return box(types.sdtp, bytes);
                }, stbl = function(track) {
                    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
                }, stsd = function(track) {
                    return box(types.stsd, new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01
                    ]), "video" === track.type ? videoSample(track) : audioSample(track));
                }, videoSample = function(track) {
                    var i, avc1Box, sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [];
                    for(i = 0; i < sps.length; i++)sequenceParameterSets.push((0xff00 & sps[i].byteLength) >>> 8), sequenceParameterSets.push(0xff & sps[i].byteLength), sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
                    for(i = 0; i < pps.length; i++)pictureParameterSets.push((0xff00 & pps[i].byteLength) >>> 8), pictureParameterSets.push(0xff & pps[i].byteLength), pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
                    if (avc1Box = [
                        types.avc1,
                        new Uint8Array([
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x01,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            (0xff00 & track.width) >> 8,
                            0xff & track.width,
                            (0xff00 & track.height) >> 8,
                            0xff & track.height,
                            0x00,
                            0x48,
                            0x00,
                            0x00,
                            0x00,
                            0x48,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x01,
                            0x13,
                            0x76,
                            0x69,
                            0x64,
                            0x65,
                            0x6f,
                            0x6a,
                            0x73,
                            0x2d,
                            0x63,
                            0x6f,
                            0x6e,
                            0x74,
                            0x72,
                            0x69,
                            0x62,
                            0x2d,
                            0x68,
                            0x6c,
                            0x73,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x18,
                            0x11,
                            0x11
                        ]),
                        box(types.avcC, new Uint8Array([
                            0x01,
                            track.profileIdc,
                            track.profileCompatibility,
                            track.levelIdc,
                            0xff
                        ].concat([
                            sps.length
                        ], sequenceParameterSets, [
                            pps.length
                        ], pictureParameterSets))),
                        box(types.btrt, new Uint8Array([
                            0x00,
                            0x1c,
                            0x9c,
                            0x80,
                            0x00,
                            0x2d,
                            0xc6,
                            0xc0,
                            0x00,
                            0x2d,
                            0xc6,
                            0xc0
                        ]))
                    ], track.sarRatio) {
                        var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
                        avc1Box.push(box(types.pasp, new Uint8Array([
                            (0xff000000 & hSpacing) >> 24,
                            (0xff0000 & hSpacing) >> 16,
                            (0xff00 & hSpacing) >> 8,
                            0xff & hSpacing,
                            (0xff000000 & vSpacing) >> 24,
                            (0xff0000 & vSpacing) >> 16,
                            (0xff00 & vSpacing) >> 8,
                            0xff & vSpacing
                        ])));
                    }
                    return box.apply(null, avc1Box);
                }, audioSample = function(track) {
                    return box(types.mp4a, new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        (0xff00 & track.channelcount) >> 8,
                        0xff & track.channelcount,
                        (0xff00 & track.samplesize) >> 8,
                        0xff & track.samplesize,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        (0xff00 & track.samplerate) >> 8,
                        0xff & track.samplerate,
                        0x00,
                        0x00
                    ]), box(types.esds, new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x03,
                        0x19,
                        0x00,
                        0x00,
                        0x00,
                        0x04,
                        0x11,
                        0x40,
                        0x15,
                        0x00,
                        0x06,
                        0x00,
                        0x00,
                        0x00,
                        0xda,
                        0xc0,
                        0x00,
                        0x00,
                        0xda,
                        0xc0,
                        0x05,
                        0x02,
                        track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1,
                        track.samplingfrequencyindex << 7 | track.channelcount << 3,
                        0x06,
                        0x01,
                        0x02
                    ])));
                }, tkhd = function(track) {
                    var result = new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x07,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        (0xff000000 & track.id) >> 24,
                        (0xff0000 & track.id) >> 16,
                        (0xff00 & track.id) >> 8,
                        0xff & track.id,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        (0xff000000 & track.duration) >> 24,
                        (0xff0000 & track.duration) >> 16,
                        (0xff00 & track.duration) >> 8,
                        0xff & track.duration,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x40,
                        0x00,
                        0x00,
                        0x00,
                        (0xff00 & track.width) >> 8,
                        0xff & track.width,
                        0x00,
                        0x00,
                        (0xff00 & track.height) >> 8,
                        0xff & track.height,
                        0x00,
                        0x00
                    ]);
                    return box(types.tkhd, result);
                }, traf = function(track) {
                    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
                    return (trackFragmentHeader = box(types.tfhd, new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x3a,
                        (0xff000000 & track.id) >> 24,
                        (0xff0000 & track.id) >> 16,
                        (0xff00 & track.id) >> 8,
                        0xff & track.id,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00
                    ])), upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / 4294967296), lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % 4294967296), trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        upperWordBaseMediaDecodeTime >>> 24 & 0xff,
                        upperWordBaseMediaDecodeTime >>> 16 & 0xff,
                        upperWordBaseMediaDecodeTime >>> 8 & 0xff,
                        0xff & upperWordBaseMediaDecodeTime,
                        lowerWordBaseMediaDecodeTime >>> 24 & 0xff,
                        lowerWordBaseMediaDecodeTime >>> 16 & 0xff,
                        lowerWordBaseMediaDecodeTime >>> 8 & 0xff,
                        0xff & lowerWordBaseMediaDecodeTime
                    ])), "audio" === track.type) ? (trackFragmentRun = trun$1(track, 92), box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun)) : (sampleDependencyTable = sdtp(track), trackFragmentRun = trun$1(track, sampleDependencyTable.length + 92), box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable));
                }, trak = function(track) {
                    return track.duration = track.duration || 0xffffffff, box(types.trak, tkhd(track), mdia(track));
                }, trex = function(track) {
                    var result = new Uint8Array([
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        (0xff000000 & track.id) >> 24,
                        (0xff0000 & track.id) >> 16,
                        (0xff00 & track.id) >> 8,
                        0xff & track.id,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x01
                    ]);
                    return "video" !== track.type && (result[result.length - 1] = 0x00), box(types.trex, result);
                }, trunHeader = function(samples, offset) {
                    var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
                    return samples.length && (void 0 !== samples[0].duration && (durationPresent = 0x1), void 0 !== samples[0].size && (sizePresent = 0x2), void 0 !== samples[0].flags && (flagsPresent = 0x4), void 0 !== samples[0].compositionTimeOffset && (compositionTimeOffset = 0x8)), [
                        0x00,
                        0x00,
                        durationPresent | sizePresent | flagsPresent | compositionTimeOffset,
                        0x01,
                        (0xff000000 & samples.length) >>> 24,
                        (0xff0000 & samples.length) >>> 16,
                        (0xff00 & samples.length) >>> 8,
                        0xff & samples.length,
                        (0xff000000 & offset) >>> 24,
                        (0xff0000 & offset) >>> 16,
                        (0xff00 & offset) >>> 8,
                        0xff & offset
                    ];
                }, videoTrun = function(track, offset) {
                    var bytesOffest, bytes, header, samples, sample, i;
                    for(offset += 20 + 16 * (samples = track.samples || []).length, header = trunHeader(samples, offset), (bytes = new Uint8Array(header.length + 16 * samples.length)).set(header), bytesOffest = header.length, i = 0; i < samples.length; i++)sample = samples[i], bytes[bytesOffest++] = (0xff000000 & sample.duration) >>> 24, bytes[bytesOffest++] = (0xff0000 & sample.duration) >>> 16, bytes[bytesOffest++] = (0xff00 & sample.duration) >>> 8, bytes[bytesOffest++] = 0xff & sample.duration, bytes[bytesOffest++] = (0xff000000 & sample.size) >>> 24, bytes[bytesOffest++] = (0xff0000 & sample.size) >>> 16, bytes[bytesOffest++] = (0xff00 & sample.size) >>> 8, bytes[bytesOffest++] = 0xff & sample.size, bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn, bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample, bytes[bytesOffest++] = 61440 & sample.flags.degradationPriority, bytes[bytesOffest++] = 0x0f & sample.flags.degradationPriority, bytes[bytesOffest++] = (0xff000000 & sample.compositionTimeOffset) >>> 24, bytes[bytesOffest++] = (0xff0000 & sample.compositionTimeOffset) >>> 16, bytes[bytesOffest++] = (0xff00 & sample.compositionTimeOffset) >>> 8, bytes[bytesOffest++] = 0xff & sample.compositionTimeOffset;
                    return box(types.trun, bytes);
                }, audioTrun = function(track, offset) {
                    var bytes, bytesOffest, header, samples, sample, i;
                    for(offset += 20 + 8 * (samples = track.samples || []).length, header = trunHeader(samples, offset), (bytes = new Uint8Array(header.length + 8 * samples.length)).set(header), bytesOffest = header.length, i = 0; i < samples.length; i++)sample = samples[i], bytes[bytesOffest++] = (0xff000000 & sample.duration) >>> 24, bytes[bytesOffest++] = (0xff0000 & sample.duration) >>> 16, bytes[bytesOffest++] = (0xff00 & sample.duration) >>> 8, bytes[bytesOffest++] = 0xff & sample.duration, bytes[bytesOffest++] = (0xff000000 & sample.size) >>> 24, bytes[bytesOffest++] = (0xff0000 & sample.size) >>> 16, bytes[bytesOffest++] = (0xff00 & sample.size) >>> 8, bytes[bytesOffest++] = 0xff & sample.size;
                    return box(types.trun, bytes);
                }, trun$1 = function(track, offset) {
                    return "audio" === track.type ? audioTrun(track, offset) : videoTrun(track, offset);
                };
                var mp4Generator = {
                    ftyp: ftyp,
                    mdat: function(data) {
                        return box(types.mdat, data);
                    },
                    moof: function(sequenceNumber, tracks) {
                        for(var trackFragments = [], i = tracks.length; i--;)trackFragments[i] = traf(tracks[i]);
                        return box.apply(null, [
                            types.moof,
                            box(types.mfhd, new Uint8Array([
                                0x00,
                                0x00,
                                0x00,
                                0x00,
                                (0xff000000 & sequenceNumber) >> 24,
                                (0xff0000 & sequenceNumber) >> 16,
                                (0xff00 & sequenceNumber) >> 8,
                                0xff & sequenceNumber
                            ]))
                        ].concat(trackFragments));
                    },
                    moov: moov,
                    initSegment: function(tracks) {
                        var result, fileType = ftyp(), movie = moov(tracks);
                        return (result = new Uint8Array(fileType.byteLength + movie.byteLength)).set(fileType), result.set(movie, fileType.byteLength), result;
                    }
                }, sampleForFrame = function(frame, dataOffset) {
                    var sample = {
                        size: 0,
                        flags: {
                            isLeading: 0,
                            dependsOn: 1,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradationPriority: 0,
                            isNonSyncSample: 1
                        }
                    };
                    return sample.dataOffset = dataOffset, sample.compositionTimeOffset = frame.pts - frame.dts, sample.duration = frame.duration, sample.size = 4 * frame.length, sample.size += frame.byteLength, frame.keyFrame && (sample.flags.dependsOn = 2, sample.flags.isNonSyncSample = 0), sample;
                }, frameUtils = {
                    groupNalsIntoFrames: function(nalUnits) {
                        var i, currentNal, currentFrame = [], frames = [];
                        for(i = 0, frames.byteLength = 0, frames.nalCount = 0, frames.duration = 0, currentFrame.byteLength = 0; i < nalUnits.length; i++)"access_unit_delimiter_rbsp" === (currentNal = nalUnits[i]).nalUnitType ? (currentFrame.length && (currentFrame.duration = currentNal.dts - currentFrame.dts, frames.byteLength += currentFrame.byteLength, frames.nalCount += currentFrame.length, frames.duration += currentFrame.duration, frames.push(currentFrame)), (currentFrame = [
                            currentNal
                        ]).byteLength = currentNal.data.byteLength, currentFrame.pts = currentNal.pts, currentFrame.dts = currentNal.dts) : ("slice_layer_without_partitioning_rbsp_idr" === currentNal.nalUnitType && (currentFrame.keyFrame = !0), currentFrame.duration = currentNal.dts - currentFrame.dts, currentFrame.byteLength += currentNal.data.byteLength, currentFrame.push(currentNal));
                        return frames.length && (!currentFrame.duration || currentFrame.duration <= 0) && (currentFrame.duration = frames[frames.length - 1].duration), frames.byteLength += currentFrame.byteLength, frames.nalCount += currentFrame.length, frames.duration += currentFrame.duration, frames.push(currentFrame), frames;
                    },
                    groupFramesIntoGops: function(frames) {
                        var i, currentFrame, currentGop = [], gops = [];
                        for(i = 0, currentGop.byteLength = 0, currentGop.nalCount = 0, currentGop.duration = 0, currentGop.pts = frames[0].pts, currentGop.dts = frames[0].dts, gops.byteLength = 0, gops.nalCount = 0, gops.duration = 0, gops.pts = frames[0].pts, gops.dts = frames[0].dts; i < frames.length; i++)(currentFrame = frames[i]).keyFrame ? (currentGop.length && (gops.push(currentGop), gops.byteLength += currentGop.byteLength, gops.nalCount += currentGop.nalCount, gops.duration += currentGop.duration), (currentGop = [
                            currentFrame
                        ]).nalCount = currentFrame.length, currentGop.byteLength = currentFrame.byteLength, currentGop.pts = currentFrame.pts, currentGop.dts = currentFrame.dts, currentGop.duration = currentFrame.duration) : (currentGop.duration += currentFrame.duration, currentGop.nalCount += currentFrame.length, currentGop.byteLength += currentFrame.byteLength, currentGop.push(currentFrame));
                        return gops.length && currentGop.duration <= 0 && (currentGop.duration = gops[gops.length - 1].duration), gops.byteLength += currentGop.byteLength, gops.nalCount += currentGop.nalCount, gops.duration += currentGop.duration, gops.push(currentGop), gops;
                    },
                    extendFirstKeyFrame: function(gops) {
                        var currentGop;
                        return !gops[0][0].keyFrame && gops.length > 1 && (currentGop = gops.shift(), gops.byteLength -= currentGop.byteLength, gops.nalCount -= currentGop.nalCount, gops[0][0].dts = currentGop.dts, gops[0][0].pts = currentGop.pts, gops[0][0].duration += currentGop.duration), gops;
                    },
                    generateSampleTable: function(gops, baseDataOffset) {
                        var h, i, sample, currentGop, dataOffset = baseDataOffset || 0, samples = [];
                        for(h = 0; h < gops.length; h++)for(i = 0, currentGop = gops[h]; i < currentGop.length; i++)sample = sampleForFrame(currentGop[i], dataOffset), dataOffset += sample.size, samples.push(sample);
                        return samples;
                    },
                    concatenateNalData: function(gops) {
                        var h, i, j, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, data = new Uint8Array(nalsByteLength + 4 * numberOfNals), view = new DataView(data.buffer);
                        for(h = 0; h < gops.length; h++)for(i = 0, currentGop = gops[h]; i < currentGop.length; i++)for(j = 0, currentFrame = currentGop[i]; j < currentFrame.length; j++)currentNal = currentFrame[j], view.setUint32(dataOffset, currentNal.data.byteLength), dataOffset += 4, data.set(currentNal.data, dataOffset), dataOffset += currentNal.data.byteLength;
                        return data;
                    },
                    generateSampleTableForFrame: function(frame, baseDataOffset) {
                        var samples = [];
                        return samples.push(sampleForFrame(frame, baseDataOffset || 0)), samples;
                    },
                    concatenateNalDataForFrame: function(frame) {
                        var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, data = new Uint8Array(nalsByteLength + 4 * numberOfNals), view = new DataView(data.buffer);
                        for(i = 0; i < frame.length; i++)currentNal = frame[i], view.setUint32(dataOffset, currentNal.data.byteLength), dataOffset += 4, data.set(currentNal.data, dataOffset), dataOffset += currentNal.data.byteLength;
                        return data;
                    }
                }, highPrefix = [
                    33,
                    16,
                    5,
                    32,
                    164,
                    27
                ], lowPrefix = [
                    33,
                    65,
                    108,
                    84,
                    1,
                    2,
                    4,
                    8,
                    168,
                    2,
                    4,
                    8,
                    17,
                    191,
                    252
                ], zeroFill = function(count) {
                    for(var a = []; count--;)a.push(0);
                    return a;
                }, silence_1 = function() {
                    if (!silence) {
                        var metaTable;
                        silence = Object.keys(metaTable = {
                            96000: [
                                highPrefix,
                                [
                                    227,
                                    64
                                ],
                                zeroFill(154),
                                [
                                    56
                                ]
                            ],
                            88200: [
                                highPrefix,
                                [
                                    231
                                ],
                                zeroFill(170),
                                [
                                    56
                                ]
                            ],
                            64000: [
                                highPrefix,
                                [
                                    248,
                                    192
                                ],
                                zeroFill(240),
                                [
                                    56
                                ]
                            ],
                            48000: [
                                highPrefix,
                                [
                                    255,
                                    192
                                ],
                                zeroFill(268),
                                [
                                    55,
                                    148,
                                    128
                                ],
                                zeroFill(54),
                                [
                                    112
                                ]
                            ],
                            44100: [
                                highPrefix,
                                [
                                    255,
                                    192
                                ],
                                zeroFill(268),
                                [
                                    55,
                                    163,
                                    128
                                ],
                                zeroFill(84),
                                [
                                    112
                                ]
                            ],
                            32000: [
                                highPrefix,
                                [
                                    255,
                                    192
                                ],
                                zeroFill(268),
                                [
                                    55,
                                    234
                                ],
                                zeroFill(226),
                                [
                                    112
                                ]
                            ],
                            24000: [
                                highPrefix,
                                [
                                    255,
                                    192
                                ],
                                zeroFill(268),
                                [
                                    55,
                                    255,
                                    128
                                ],
                                zeroFill(268),
                                [
                                    111,
                                    112
                                ],
                                zeroFill(126),
                                [
                                    224
                                ]
                            ],
                            16000: [
                                highPrefix,
                                [
                                    255,
                                    192
                                ],
                                zeroFill(268),
                                [
                                    55,
                                    255,
                                    128
                                ],
                                zeroFill(268),
                                [
                                    111,
                                    255
                                ],
                                zeroFill(269),
                                [
                                    223,
                                    108
                                ],
                                zeroFill(195),
                                [
                                    1,
                                    192
                                ]
                            ],
                            12000: [
                                lowPrefix,
                                zeroFill(268),
                                [
                                    3,
                                    127,
                                    248
                                ],
                                zeroFill(268),
                                [
                                    6,
                                    255,
                                    240
                                ],
                                zeroFill(268),
                                [
                                    13,
                                    255,
                                    224
                                ],
                                zeroFill(268),
                                [
                                    27,
                                    253,
                                    128
                                ],
                                zeroFill(259),
                                [
                                    56
                                ]
                            ],
                            11025: [
                                lowPrefix,
                                zeroFill(268),
                                [
                                    3,
                                    127,
                                    248
                                ],
                                zeroFill(268),
                                [
                                    6,
                                    255,
                                    240
                                ],
                                zeroFill(268),
                                [
                                    13,
                                    255,
                                    224
                                ],
                                zeroFill(268),
                                [
                                    27,
                                    255,
                                    192
                                ],
                                zeroFill(268),
                                [
                                    55,
                                    175,
                                    128
                                ],
                                zeroFill(108),
                                [
                                    112
                                ]
                            ],
                            8000: [
                                lowPrefix,
                                zeroFill(268),
                                [
                                    3,
                                    121,
                                    16
                                ],
                                zeroFill(47),
                                [
                                    7
                                ]
                            ]
                        }).reduce(function(obj, key) {
                            return obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {
                                return arr.concat(part);
                            }, [])), obj;
                        }, {});
                    }
                    return silence;
                }, clock = {
                    ONE_SECOND_IN_TS: 90000,
                    secondsToVideoTs: secondsToVideoTs = function(seconds) {
                        return 90000 * seconds;
                    },
                    secondsToAudioTs: secondsToAudioTs = function(seconds, sampleRate) {
                        return seconds * sampleRate;
                    },
                    videoTsToSeconds: videoTsToSeconds = function(timestamp) {
                        return timestamp / 90000;
                    },
                    audioTsToSeconds: audioTsToSeconds = function(timestamp, sampleRate) {
                        return timestamp / sampleRate;
                    },
                    audioTsToVideoTs: function(timestamp, sampleRate) {
                        return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
                    },
                    videoTsToAudioTs: function(timestamp, sampleRate) {
                        return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
                    },
                    metadataTsToSeconds: function(timestamp, timelineStartPts, keepOriginalTimestamps) {
                        return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
                    }
                }, sumFrameByteLengths = function(array) {
                    var i, sum = 0;
                    for(i = 0; i < array.length; i++)sum += array[i].data.byteLength;
                    return sum;
                }, audioFrameUtils = {
                    prefixWithSilence: function(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
                        var baseMediaDecodeTimeTs, silentFrame, i, firstFrame, frameDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0;
                        if (frames.length && (baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024)), audioAppendStartTs && videoBaseMediaDecodeTime && (audioFillDuration = (audioFillFrameCount = Math.floor((baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime)) / frameDuration)) * frameDuration), !(audioFillFrameCount < 1) && !(audioFillDuration > clock.ONE_SECOND_IN_TS / 2))) {
                            for((silentFrame = silence_1()[track.samplerate]) || (silentFrame = frames[0].data), i = 0; i < audioFillFrameCount; i++)firstFrame = frames[0], frames.splice(0, 0, {
                                data: silentFrame,
                                dts: firstFrame.dts - frameDuration,
                                pts: firstFrame.pts - frameDuration
                            });
                            return track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate)), audioFillDuration;
                        }
                    },
                    trimAdtsFramesByEarliestDts: function(adtsFrames, track, earliestAllowedDts) {
                        return track.minSegmentDts >= earliestAllowedDts ? adtsFrames : (track.minSegmentDts = 1 / 0, adtsFrames.filter(function(currentFrame) {
                            return currentFrame.dts >= earliestAllowedDts && (track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts), track.minSegmentPts = track.minSegmentDts, !0);
                        }));
                    },
                    generateSampleTable: function(frames) {
                        var i, samples = [];
                        for(i = 0; i < frames.length; i++)samples.push({
                            size: frames[i].data.byteLength,
                            duration: 1024
                        });
                        return samples;
                    },
                    concatenateFrameData: function(frames) {
                        var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
                        for(i = 0; i < frames.length; i++)currentFrame = frames[i], data.set(currentFrame.data, dataOffset), dataOffset += currentFrame.data.byteLength;
                        return data;
                    }
                }, ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS, trackDecodeInfo = {
                    clearDtsInfo: function(track) {
                        delete track.minSegmentDts, delete track.maxSegmentDts, delete track.minSegmentPts, delete track.maxSegmentPts;
                    },
                    calculateTrackBaseMediaDecodeTime: function(track, keepOriginalTimestamps) {
                        var baseMediaDecodeTime, minSegmentDts = track.minSegmentDts;
                        return keepOriginalTimestamps || (minSegmentDts -= track.timelineStartInfo.dts), baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime + minSegmentDts), "audio" === track.type && (baseMediaDecodeTime *= track.samplerate / ONE_SECOND_IN_TS$3, baseMediaDecodeTime = Math.floor(baseMediaDecodeTime)), baseMediaDecodeTime;
                    },
                    collectDtsInfo: function(track, data) {
                        "number" == typeof data.pts && (void 0 === track.timelineStartInfo.pts && (track.timelineStartInfo.pts = data.pts), void 0 === track.minSegmentPts ? track.minSegmentPts = data.pts : track.minSegmentPts = Math.min(track.minSegmentPts, data.pts), void 0 === track.maxSegmentPts ? track.maxSegmentPts = data.pts : track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts)), "number" == typeof data.dts && (void 0 === track.timelineStartInfo.dts && (track.timelineStartInfo.dts = data.dts), void 0 === track.minSegmentDts ? track.minSegmentDts = data.dts : track.minSegmentDts = Math.min(track.minSegmentDts, data.dts), void 0 === track.maxSegmentDts ? track.maxSegmentDts = data.dts : track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts));
                    }
                }, captionPacketParser = {
                    parseSei: function(bytes) {
                        for(var i = 0, result = {
                            payloadType: -1,
                            payloadSize: 0
                        }, payloadType = 0, payloadSize = 0; i < bytes.byteLength && 128 !== bytes[i];){
                            for(; 0xff === bytes[i];)payloadType += 255, i++;
                            for(payloadType += bytes[i++]; 0xff === bytes[i];)payloadSize += 255, i++;
                            if (payloadSize += bytes[i++], !result.payload && 4 === payloadType) {
                                if ("GA94" === String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6])) {
                                    result.payloadType = payloadType, result.payloadSize = payloadSize, result.payload = bytes.subarray(i, i + payloadSize);
                                    break;
                                }
                                result.payload = void 0;
                            }
                            i += payloadSize, payloadType = 0, payloadSize = 0;
                        }
                        return result;
                    },
                    parseUserData: function(sei) {
                        return 181 !== sei.payload[0] || (sei.payload[1] << 8 | sei.payload[2]) != 49 || "GA94" !== String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) || 0x03 !== sei.payload[7] ? null : sei.payload.subarray(8, sei.payload.length - 1);
                    },
                    parseCaptionPackets: function(pts, userData) {
                        var i, count, offset, data, results = [];
                        if (!(0x40 & userData[0])) return results;
                        for(i = 0, count = 0x1f & userData[0]; i < count; i++)data = {
                            type: 0x03 & userData[(offset = 3 * i) + 2],
                            pts: pts
                        }, 0x04 & userData[offset + 2] && (data.ccData = userData[offset + 3] << 8 | userData[offset + 4], results.push(data));
                        return results;
                    },
                    discardEmulationPreventionBytes: function(data) {
                        for(var newLength, newData, length = data.byteLength, emulationPreventionBytesPositions = [], i = 1; i < length - 2;)0 === data[i] && 0 === data[i + 1] && 0x03 === data[i + 2] ? (emulationPreventionBytesPositions.push(i + 2), i += 2) : i++;
                        if (0 === emulationPreventionBytesPositions.length) return data;
                        newLength = length - emulationPreventionBytesPositions.length, newData = new Uint8Array(newLength);
                        var sourceIndex = 0;
                        for(i = 0; i < newLength; sourceIndex++, i++)sourceIndex === emulationPreventionBytesPositions[0] && (sourceIndex++, emulationPreventionBytesPositions.shift()), newData[i] = data[sourceIndex];
                        return newData;
                    },
                    USER_DATA_REGISTERED_ITU_T_T35: 4
                }, CaptionStream$1 = function CaptionStream(options) {
                    options = options || {}, CaptionStream.prototype.init.call(this), this.parse708captions_ = "boolean" != typeof options.parse708captions || options.parse708captions, this.captionPackets_ = [], this.ccStreams_ = [
                        new Cea608Stream(0, 0),
                        new Cea608Stream(0, 1),
                        new Cea608Stream(1, 0),
                        new Cea608Stream(1, 1)
                    ], this.parse708captions_ && (this.cc708Stream_ = new Cea708Stream({
                        captionServices: options.captionServices
                    })), this.reset(), this.ccStreams_.forEach(function(cc) {
                        cc.on("data", this.trigger.bind(this, "data")), cc.on("partialdone", this.trigger.bind(this, "partialdone")), cc.on("done", this.trigger.bind(this, "done"));
                    }, this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done")));
                };
                CaptionStream$1.prototype = new Stream(), CaptionStream$1.prototype.push = function(event) {
                    var sei, userData, newCaptionPackets;
                    if ("sei_rbsp" === event.nalUnitType && (sei = captionPacketParser.parseSei(event.escapedRBSP)).payload && sei.payloadType === captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35 && (userData = captionPacketParser.parseUserData(sei))) {
                        if (event.dts < this.latestDts_) {
                            this.ignoreNextEqualDts_ = !0;
                            return;
                        }
                        if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
                            this.numSameDts_--, this.numSameDts_ || (this.ignoreNextEqualDts_ = !1);
                            return;
                        }
                        newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData), this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets), this.latestDts_ !== event.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = event.dts;
                    }
                }, CaptionStream$1.prototype.flushCCStreams = function(flushType) {
                    this.ccStreams_.forEach(function(cc) {
                        return "flush" === flushType ? cc.flush() : cc.partialFlush();
                    }, this);
                }, CaptionStream$1.prototype.flushStream = function(flushType) {
                    if (!this.captionPackets_.length) {
                        this.flushCCStreams(flushType);
                        return;
                    }
                    this.captionPackets_.forEach(function(elem, idx) {
                        elem.presortIndex = idx;
                    }), this.captionPackets_.sort(function(a, b) {
                        return a.pts === b.pts ? a.presortIndex - b.presortIndex : a.pts - b.pts;
                    }), this.captionPackets_.forEach(function(packet) {
                        packet.type < 2 ? this.dispatchCea608Packet(packet) : this.dispatchCea708Packet(packet);
                    }, this), this.captionPackets_.length = 0, this.flushCCStreams(flushType);
                }, CaptionStream$1.prototype.flush = function() {
                    return this.flushStream("flush");
                }, CaptionStream$1.prototype.partialFlush = function() {
                    return this.flushStream("partialFlush");
                }, CaptionStream$1.prototype.reset = function() {
                    this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [
                        null,
                        null
                    ], this.ccStreams_.forEach(function(ccStream) {
                        ccStream.reset();
                    });
                }, CaptionStream$1.prototype.dispatchCea608Packet = function(packet) {
                    this.setsTextOrXDSActive(packet) ? this.activeCea608Channel_[packet.type] = null : this.setsChannel1Active(packet) ? this.activeCea608Channel_[packet.type] = 0 : this.setsChannel2Active(packet) && (this.activeCea608Channel_[packet.type] = 1), null !== this.activeCea608Channel_[packet.type] && this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
                }, CaptionStream$1.prototype.setsChannel1Active = function(packet) {
                    return (0x7800 & packet.ccData) == 0x1000;
                }, CaptionStream$1.prototype.setsChannel2Active = function(packet) {
                    return (0x7800 & packet.ccData) == 0x1800;
                }, CaptionStream$1.prototype.setsTextOrXDSActive = function(packet) {
                    return (0x7100 & packet.ccData) == 0x0100 || (0x78fe & packet.ccData) == 0x102a || (0x78fe & packet.ccData) == 0x182a;
                }, CaptionStream$1.prototype.dispatchCea708Packet = function(packet) {
                    this.parse708captions_ && this.cc708Stream_.push(packet);
                };
                var CHARACTER_TRANSLATION_708 = {
                    0x7f: 0x266a,
                    0x1020: 0x20,
                    0x1021: 0xa0,
                    0x1025: 0x2026,
                    0x102a: 0x0160,
                    0x102c: 0x0152,
                    0x1030: 0x2588,
                    0x1031: 0x2018,
                    0x1032: 0x2019,
                    0x1033: 0x201c,
                    0x1034: 0x201d,
                    0x1035: 0x2022,
                    0x1039: 0x2122,
                    0x103a: 0x0161,
                    0x103c: 0x0153,
                    0x103d: 0x2120,
                    0x103f: 0x0178,
                    0x1076: 0x215b,
                    0x1077: 0x215c,
                    0x1078: 0x215d,
                    0x1079: 0x215e,
                    0x107a: 0x23d0,
                    0x107b: 0x23a4,
                    0x107c: 0x23a3,
                    0x107d: 0x23af,
                    0x107e: 0x23a6,
                    0x107f: 0x23a1,
                    0x10a0: 0x3138
                }, get708CharFromCode = function(code) {
                    var newCode = CHARACTER_TRANSLATION_708[code] || code;
                    return 0x1000 & code && code === newCode ? "" : String.fromCharCode(newCode);
                }, within708TextBlock = function(b) {
                    return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;
                }, Cea708Window = function(windowNum) {
                    this.windowNum = windowNum, this.reset();
                };
                Cea708Window.prototype.reset = function() {
                    this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0;
                }, Cea708Window.prototype.getText = function() {
                    return this.rows.join("\n");
                }, Cea708Window.prototype.clearText = function() {
                    this.rows = [
                        ""
                    ], this.rowIdx = 0;
                }, Cea708Window.prototype.newLine = function(pts) {
                    for(this.rows.length >= this.virtualRowCount && "function" == typeof this.beforeRowOverflow && this.beforeRowOverflow(pts), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount;)this.rows.shift(), this.rowIdx--;
                }, Cea708Window.prototype.isEmpty = function() {
                    return 0 === this.rows.length || 1 === this.rows.length && "" === this.rows[0];
                }, Cea708Window.prototype.addText = function(text) {
                    this.rows[this.rowIdx] += text;
                }, Cea708Window.prototype.backspace = function() {
                    if (!this.isEmpty()) {
                        var row = this.rows[this.rowIdx];
                        this.rows[this.rowIdx] = row.substr(0, row.length - 1);
                    }
                };
                var Cea708Service = function(serviceNum, encoding, stream) {
                    this.serviceNum = serviceNum, this.text = "", this.currentWindow = new Cea708Window(-1), this.windows = [], this.stream = stream, "string" == typeof encoding && this.createTextDecoder(encoding);
                };
                Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
                    this.startPts = pts;
                    for(var win = 0; win < 8; win++)this.windows[win] = new Cea708Window(win), "function" == typeof beforeRowOverflow && (this.windows[win].beforeRowOverflow = beforeRowOverflow);
                }, Cea708Service.prototype.setCurrentWindow = function(windowNum) {
                    this.currentWindow = this.windows[windowNum];
                }, Cea708Service.prototype.createTextDecoder = function(encoding) {
                    if ("undefined" == typeof TextDecoder) this.stream.trigger("log", {
                        level: "warn",
                        message: "The `encoding` option is unsupported without TextDecoder support"
                    });
                    else try {
                        this.textDecoder_ = new TextDecoder(encoding);
                    } catch (error) {
                        this.stream.trigger("log", {
                            level: "warn",
                            message: "TextDecoder could not be created with " + encoding + " encoding. " + error
                        });
                    }
                };
                var Cea708Stream = function Cea708Stream(options) {
                    options = options || {}, Cea708Stream.prototype.init.call(this);
                    var serviceProps, self1 = this, captionServices = options.captionServices || {}, captionServiceEncodings = {};
                    Object.keys(captionServices).forEach(function(serviceName) {
                        serviceProps = captionServices[serviceName], /^SERVICE/.test(serviceName) && (captionServiceEncodings[serviceName] = serviceProps.encoding);
                    }), this.serviceEncodings = captionServiceEncodings, this.current708Packet = null, this.services = {}, this.push = function(packet) {
                        3 === packet.type ? (self1.new708Packet(), self1.add708Bytes(packet)) : (null === self1.current708Packet && self1.new708Packet(), self1.add708Bytes(packet));
                    };
                };
                Cea708Stream.prototype = new Stream(), Cea708Stream.prototype.new708Packet = function() {
                    null !== this.current708Packet && this.push708Packet(), this.current708Packet = {
                        data: [],
                        ptsVals: []
                    };
                }, Cea708Stream.prototype.add708Bytes = function(packet) {
                    var data = packet.ccData;
                    this.current708Packet.ptsVals.push(packet.pts), this.current708Packet.data.push(data >>> 8), this.current708Packet.data.push(0xff & data);
                }, Cea708Stream.prototype.push708Packet = function() {
                    var packet708 = this.current708Packet, packetData = packet708.data, serviceNum = null, blockSize = null, i = 0, b = packetData[i++];
                    for(packet708.seq = b >> 6, packet708.sizeCode = 0x3f & b; i < packetData.length; i++)serviceNum = (b = packetData[i++]) >> 5, blockSize = 0x1f & b, 7 === serviceNum && blockSize > 0 && (serviceNum = b = packetData[i++]), this.pushServiceBlock(serviceNum, i, blockSize), blockSize > 0 && (i += blockSize - 1);
                }, Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start, size) {
                    var b, i = start, packetData = this.current708Packet.data, service = this.services[serviceNum];
                    for(service || (service = this.initService(serviceNum, i)); i < start + size && i < packetData.length; i++)within708TextBlock(b = packetData[i]) ? i = this.handleText(i, service) : 0x18 === b ? i = this.multiByteCharacter(i, service) : 0x10 === b ? i = this.extendedCommands(i, service) : 0x80 <= b && b <= 0x87 ? i = this.setCurrentWindow(i, service) : 0x98 <= b && b <= 0x9f ? i = this.defineWindow(i, service) : 0x88 === b ? i = this.clearWindows(i, service) : 0x8c === b ? i = this.deleteWindows(i, service) : 0x89 === b ? i = this.displayWindows(i, service) : 0x8a === b ? i = this.hideWindows(i, service) : 0x8b === b ? i = this.toggleWindows(i, service) : 0x97 === b ? i = this.setWindowAttributes(i, service) : 0x90 === b ? i = this.setPenAttributes(i, service) : 0x91 === b ? i = this.setPenColor(i, service) : 0x92 === b ? i = this.setPenLocation(i, service) : 0x8f === b ? service = this.reset(i, service) : 0x08 === b ? service.currentWindow.backspace() : 0x0c === b ? service.currentWindow.clearText() : 0x0d === b ? service.currentWindow.pendingNewLine = !0 : 0x0e === b ? service.currentWindow.clearText() : 0x8d === b && i++;
                }, Cea708Stream.prototype.extendedCommands = function(i, service) {
                    return within708TextBlock(this.current708Packet.data[++i]) && (i = this.handleText(i, service, {
                        isExtended: !0
                    })), i;
                }, Cea708Stream.prototype.getPts = function(byteIndex) {
                    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
                }, Cea708Stream.prototype.initService = function(serviceNum, i) {
                    var encoding, serviceName = "SERVICE" + serviceNum, self1 = this;
                    return serviceName in this.serviceEncodings && (encoding = this.serviceEncodings[serviceName]), this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self1), this.services[serviceNum].init(this.getPts(i), function(pts) {
                        self1.flushDisplayed(pts, self1.services[serviceNum]);
                    }), this.services[serviceNum];
                }, Cea708Stream.prototype.handleText = function(i, service, options) {
                    var _char, charCodeArray, isExtended = options && options.isExtended, isMultiByte = options && options.isMultiByte, packetData = this.current708Packet.data, currentByte = packetData[i], nextByte = packetData[i + 1], win = service.currentWindow;
                    return service.textDecoder_ && !isExtended ? (isMultiByte ? (charCodeArray = [
                        currentByte,
                        nextByte
                    ], i++) : charCodeArray = [
                        currentByte
                    ], _char = service.textDecoder_.decode(new Uint8Array(charCodeArray))) : _char = get708CharFromCode((isExtended ? 0x1000 : 0x0000) | currentByte), win.pendingNewLine && !win.isEmpty() && win.newLine(this.getPts(i)), win.pendingNewLine = !1, win.addText(_char), i;
                }, Cea708Stream.prototype.multiByteCharacter = function(i, service) {
                    var packetData = this.current708Packet.data, firstByte = packetData[i + 1], secondByte = packetData[i + 2];
                    return within708TextBlock(firstByte) && within708TextBlock(secondByte) && (i = this.handleText(++i, service, {
                        isMultiByte: !0
                    })), i;
                }, Cea708Stream.prototype.setCurrentWindow = function(i, service) {
                    var b = this.current708Packet.data[i];
                    return service.setCurrentWindow(0x07 & b), i;
                }, Cea708Stream.prototype.defineWindow = function(i, service) {
                    var packetData = this.current708Packet.data, b = packetData[i], windowNum = 0x07 & b;
                    service.setCurrentWindow(windowNum);
                    var win = service.currentWindow;
                    return b = packetData[++i], win.visible = (0x20 & b) >> 5, win.rowLock = (0x10 & b) >> 4, win.columnLock = (0x08 & b) >> 3, win.priority = 0x07 & b, b = packetData[++i], win.relativePositioning = (0x80 & b) >> 7, win.anchorVertical = 0x7f & b, b = packetData[++i], win.anchorHorizontal = b, b = packetData[++i], win.anchorPoint = (0xf0 & b) >> 4, win.rowCount = 0x0f & b, b = packetData[++i], win.columnCount = 0x3f & b, b = packetData[++i], win.windowStyle = (0x38 & b) >> 3, win.penStyle = 0x07 & b, win.virtualRowCount = win.rowCount + 1, i;
                }, Cea708Stream.prototype.setWindowAttributes = function(i, service) {
                    var packetData = this.current708Packet.data, b = packetData[i], winAttr = service.currentWindow.winAttr;
                    return b = packetData[++i], winAttr.fillOpacity = (0xc0 & b) >> 6, winAttr.fillRed = (0x30 & b) >> 4, winAttr.fillGreen = (0x0c & b) >> 2, winAttr.fillBlue = 0x03 & b, b = packetData[++i], winAttr.borderType = (0xc0 & b) >> 6, winAttr.borderRed = (0x30 & b) >> 4, winAttr.borderGreen = (0x0c & b) >> 2, winAttr.borderBlue = 0x03 & b, b = packetData[++i], winAttr.borderType += (0x80 & b) >> 5, winAttr.wordWrap = (0x40 & b) >> 6, winAttr.printDirection = (0x30 & b) >> 4, winAttr.scrollDirection = (0x0c & b) >> 2, winAttr.justify = 0x03 & b, b = packetData[++i], winAttr.effectSpeed = (0xf0 & b) >> 4, winAttr.effectDirection = (0x0c & b) >> 2, winAttr.displayEffect = 0x03 & b, i;
                }, Cea708Stream.prototype.flushDisplayed = function(pts, service) {
                    for(var displayedText = [], winId = 0; winId < 8; winId++)service.windows[winId].visible && !service.windows[winId].isEmpty() && displayedText.push(service.windows[winId].getText());
                    service.endPts = pts, service.text = displayedText.join("\n\n"), this.pushCaption(service), service.startPts = pts;
                }, Cea708Stream.prototype.pushCaption = function(service) {
                    "" !== service.text && (this.trigger("data", {
                        startPts: service.startPts,
                        endPts: service.endPts,
                        text: service.text,
                        stream: "cc708_" + service.serviceNum
                    }), service.text = "", service.startPts = service.endPts);
                }, Cea708Stream.prototype.displayWindows = function(i, service) {
                    var b = this.current708Packet.data[++i], pts = this.getPts(i);
                    this.flushDisplayed(pts, service);
                    for(var winId = 0; winId < 8; winId++)b & 0x01 << winId && (service.windows[winId].visible = 1);
                    return i;
                }, Cea708Stream.prototype.hideWindows = function(i, service) {
                    var b = this.current708Packet.data[++i], pts = this.getPts(i);
                    this.flushDisplayed(pts, service);
                    for(var winId = 0; winId < 8; winId++)b & 0x01 << winId && (service.windows[winId].visible = 0);
                    return i;
                }, Cea708Stream.prototype.toggleWindows = function(i, service) {
                    var b = this.current708Packet.data[++i], pts = this.getPts(i);
                    this.flushDisplayed(pts, service);
                    for(var winId = 0; winId < 8; winId++)b & 0x01 << winId && (service.windows[winId].visible ^= 1);
                    return i;
                }, Cea708Stream.prototype.clearWindows = function(i, service) {
                    var b = this.current708Packet.data[++i], pts = this.getPts(i);
                    this.flushDisplayed(pts, service);
                    for(var winId = 0; winId < 8; winId++)b & 0x01 << winId && service.windows[winId].clearText();
                    return i;
                }, Cea708Stream.prototype.deleteWindows = function(i, service) {
                    var b = this.current708Packet.data[++i], pts = this.getPts(i);
                    this.flushDisplayed(pts, service);
                    for(var winId = 0; winId < 8; winId++)b & 0x01 << winId && service.windows[winId].reset();
                    return i;
                }, Cea708Stream.prototype.setPenAttributes = function(i, service) {
                    var packetData = this.current708Packet.data, b = packetData[i], penAttr = service.currentWindow.penAttr;
                    return b = packetData[++i], penAttr.textTag = (0xf0 & b) >> 4, penAttr.offset = (0x0c & b) >> 2, penAttr.penSize = 0x03 & b, b = packetData[++i], penAttr.italics = (0x80 & b) >> 7, penAttr.underline = (0x40 & b) >> 6, penAttr.edgeType = (0x38 & b) >> 3, penAttr.fontStyle = 0x07 & b, i;
                }, Cea708Stream.prototype.setPenColor = function(i, service) {
                    var packetData = this.current708Packet.data, b = packetData[i], penColor = service.currentWindow.penColor;
                    return b = packetData[++i], penColor.fgOpacity = (0xc0 & b) >> 6, penColor.fgRed = (0x30 & b) >> 4, penColor.fgGreen = (0x0c & b) >> 2, penColor.fgBlue = 0x03 & b, b = packetData[++i], penColor.bgOpacity = (0xc0 & b) >> 6, penColor.bgRed = (0x30 & b) >> 4, penColor.bgGreen = (0x0c & b) >> 2, penColor.bgBlue = 0x03 & b, b = packetData[++i], penColor.edgeRed = (0x30 & b) >> 4, penColor.edgeGreen = (0x0c & b) >> 2, penColor.edgeBlue = 0x03 & b, i;
                }, Cea708Stream.prototype.setPenLocation = function(i, service) {
                    var packetData = this.current708Packet.data, b = packetData[i], penLoc = service.currentWindow.penLoc;
                    return service.currentWindow.pendingNewLine = !0, b = packetData[++i], penLoc.row = 0x0f & b, b = packetData[++i], penLoc.column = 0x3f & b, i;
                }, Cea708Stream.prototype.reset = function(i, service) {
                    var pts = this.getPts(i);
                    return this.flushDisplayed(pts, service), this.initService(service.serviceNum, i);
                };
                var CHARACTER_TRANSLATION = {
                    0x2a: 0xe1,
                    0x5c: 0xe9,
                    0x5e: 0xed,
                    0x5f: 0xf3,
                    0x60: 0xfa,
                    0x7b: 0xe7,
                    0x7c: 0xf7,
                    0x7d: 0xd1,
                    0x7e: 0xf1,
                    0x7f: 0x2588,
                    0x0130: 0xae,
                    0x0131: 0xb0,
                    0x0132: 0xbd,
                    0x0133: 0xbf,
                    0x0134: 0x2122,
                    0x0135: 0xa2,
                    0x0136: 0xa3,
                    0x0137: 0x266a,
                    0x0138: 0xe0,
                    0x0139: 0xa0,
                    0x013a: 0xe8,
                    0x013b: 0xe2,
                    0x013c: 0xea,
                    0x013d: 0xee,
                    0x013e: 0xf4,
                    0x013f: 0xfb,
                    0x0220: 0xc1,
                    0x0221: 0xc9,
                    0x0222: 0xd3,
                    0x0223: 0xda,
                    0x0224: 0xdc,
                    0x0225: 0xfc,
                    0x0226: 0x2018,
                    0x0227: 0xa1,
                    0x0228: 0x2a,
                    0x0229: 0x27,
                    0x022a: 0x2014,
                    0x022b: 0xa9,
                    0x022c: 0x2120,
                    0x022d: 0x2022,
                    0x022e: 0x201c,
                    0x022f: 0x201d,
                    0x0230: 0xc0,
                    0x0231: 0xc2,
                    0x0232: 0xc7,
                    0x0233: 0xc8,
                    0x0234: 0xca,
                    0x0235: 0xcb,
                    0x0236: 0xeb,
                    0x0237: 0xce,
                    0x0238: 0xcf,
                    0x0239: 0xef,
                    0x023a: 0xd4,
                    0x023b: 0xd9,
                    0x023c: 0xf9,
                    0x023d: 0xdb,
                    0x023e: 0xab,
                    0x023f: 0xbb,
                    0x0320: 0xc3,
                    0x0321: 0xe3,
                    0x0322: 0xcd,
                    0x0323: 0xcc,
                    0x0324: 0xec,
                    0x0325: 0xd2,
                    0x0326: 0xf2,
                    0x0327: 0xd5,
                    0x0328: 0xf5,
                    0x0329: 0x7b,
                    0x032a: 0x7d,
                    0x032b: 0x5c,
                    0x032c: 0x5e,
                    0x032d: 0x5f,
                    0x032e: 0x7c,
                    0x032f: 0x7e,
                    0x0330: 0xc4,
                    0x0331: 0xe4,
                    0x0332: 0xd6,
                    0x0333: 0xf6,
                    0x0334: 0xdf,
                    0x0335: 0xa5,
                    0x0336: 0xa4,
                    0x0337: 0x2502,
                    0x0338: 0xc5,
                    0x0339: 0xe5,
                    0x033a: 0xd8,
                    0x033b: 0xf8,
                    0x033c: 0x250c,
                    0x033d: 0x2510,
                    0x033e: 0x2514,
                    0x033f: 0x2518
                }, getCharFromCode = function(code) {
                    return null === code ? "" : String.fromCharCode(code = CHARACTER_TRANSLATION[code] || code);
                }, ROWS = [
                    0x1100,
                    0x1120,
                    0x1200,
                    0x1220,
                    0x1500,
                    0x1520,
                    0x1600,
                    0x1620,
                    0x1700,
                    0x1720,
                    0x1000,
                    0x1300,
                    0x1320,
                    0x1400,
                    0x1420
                ], createDisplayBuffer = function() {
                    for(var result = [], i = 15; i--;)result.push("");
                    return result;
                }, Cea608Stream = function Cea608Stream(field, dataChannel) {
                    Cea608Stream.prototype.init.call(this), this.field_ = field || 0, this.dataChannel_ = dataChannel || 0, this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1), this.setConstants(), this.reset(), this.push = function(packet) {
                        var data, swap, char0, char1, text;
                        if ((data = 0x7f7f & packet.ccData) === this.lastControlCode_) {
                            this.lastControlCode_ = null;
                            return;
                        }
                        if ((0xf000 & data) == 0x1000 ? this.lastControlCode_ = data : data !== this.PADDING_ && (this.lastControlCode_ = null), char0 = data >>> 8, char1 = 0xff & data, data !== this.PADDING_) {
                            if (data === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn";
                            else if (data === this.END_OF_CAPTION_) this.mode_ = "popOn", this.clearFormatting(packet.pts), this.flushDisplayed(packet.pts), swap = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = swap, this.startPts_ = packet.pts;
                            else if (data === this.ROLL_UP_2_ROWS_) this.rollUpRows_ = 2, this.setRollUp(packet.pts);
                            else if (data === this.ROLL_UP_3_ROWS_) this.rollUpRows_ = 3, this.setRollUp(packet.pts);
                            else if (data === this.ROLL_UP_4_ROWS_) this.rollUpRows_ = 4, this.setRollUp(packet.pts);
                            else if (data === this.CARRIAGE_RETURN_) this.clearFormatting(packet.pts), this.flushDisplayed(packet.pts), this.shiftRowsUp_(), this.startPts_ = packet.pts;
                            else if (data === this.BACKSPACE_) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
                            else if (data === this.ERASE_DISPLAYED_MEMORY_) this.flushDisplayed(packet.pts), this.displayed_ = createDisplayBuffer();
                            else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = createDisplayBuffer();
                            else if (data === this.RESUME_DIRECT_CAPTIONING_) "paintOn" !== this.mode_ && (this.flushDisplayed(packet.pts), this.displayed_ = createDisplayBuffer()), this.mode_ = "paintOn", this.startPts_ = packet.pts;
                            else if (this.isSpecialCharacter(char0, char1)) text = getCharFromCode((char0 = (0x03 & char0) << 8) | char1), this[this.mode_](packet.pts, text), this.column_++;
                            else if (this.isExtCharacter(char0, char1)) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), text = getCharFromCode((char0 = (0x03 & char0) << 8) | char1), this[this.mode_](packet.pts, text), this.column_++;
                            else if (this.isMidRowCode(char0, char1)) this.clearFormatting(packet.pts), this[this.mode_](packet.pts, " "), this.column_++, (0xe & char1) == 0xe && this.addFormatting(packet.pts, [
                                "i"
                            ]), (0x1 & char1) == 0x1 && this.addFormatting(packet.pts, [
                                "u"
                            ]);
                            else if (this.isOffsetControlCode(char0, char1)) this.column_ += 0x03 & char1;
                            else if (this.isPAC(char0, char1)) {
                                var row = ROWS.indexOf(0x1f20 & data);
                                "rollUp" === this.mode_ && (row - this.rollUpRows_ + 1 < 0 && (row = this.rollUpRows_ - 1), this.setRollUp(packet.pts, row)), row !== this.row_ && (this.clearFormatting(packet.pts), this.row_ = row), 0x1 & char1 && -1 === this.formatting_.indexOf("u") && this.addFormatting(packet.pts, [
                                    "u"
                                ]), (0x10 & data) == 0x10 && (this.column_ = ((0xe & data) >> 1) * 4), this.isColorPAC(char1) && (0xe & char1) == 0xe && this.addFormatting(packet.pts, [
                                    "i"
                                ]);
                            } else this.isNormalChar(char0) && (0x00 === char1 && (char1 = null), text = getCharFromCode(char0) + getCharFromCode(char1), this[this.mode_](packet.pts, text), this.column_ += text.length);
                        }
                    };
                };
                Cea608Stream.prototype = new Stream(), Cea608Stream.prototype.flushDisplayed = function(pts) {
                    var content = this.displayed_.map(function(row, index) {
                        try {
                            return row.trim();
                        } catch (e) {
                            return this.trigger("log", {
                                level: "warn",
                                message: "Skipping a malformed 608 caption at index " + index + "."
                            }), "";
                        }
                    }, this).join("\n").replace(/^\n+|\n+$/g, "");
                    content.length && this.trigger("data", {
                        startPts: this.startPts_,
                        endPts: pts,
                        text: content,
                        stream: this.name_
                    });
                }, Cea608Stream.prototype.reset = function() {
                    this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = createDisplayBuffer(), this.nonDisplayed_ = createDisplayBuffer(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = 14, this.rollUpRows_ = 2, this.formatting_ = [];
                }, Cea608Stream.prototype.setConstants = function() {
                    0 === this.dataChannel_ ? (this.BASE_ = 0x10, this.EXT_ = 0x11, this.CONTROL_ = (0x14 | this.field_) << 8, this.OFFSET_ = 0x17) : 1 === this.dataChannel_ && (this.BASE_ = 0x18, this.EXT_ = 0x19, this.CONTROL_ = (0x1c | this.field_) << 8, this.OFFSET_ = 0x1f), this.PADDING_ = 0x0000, this.RESUME_CAPTION_LOADING_ = 0x20 | this.CONTROL_, this.END_OF_CAPTION_ = 0x2f | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 0x25 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 0x26 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 0x27 | this.CONTROL_, this.CARRIAGE_RETURN_ = 0x2d | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 0x29 | this.CONTROL_, this.BACKSPACE_ = 0x21 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 0x2c | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 0x2e | this.CONTROL_;
                }, Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
                    return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;
                }, Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
                    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;
                }, Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
                    return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;
                }, Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
                    return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;
                }, Cea608Stream.prototype.isPAC = function(char0, char1) {
                    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;
                }, Cea608Stream.prototype.isColorPAC = function(char1) {
                    return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;
                }, Cea608Stream.prototype.isNormalChar = function(_char2) {
                    return _char2 >= 0x20 && _char2 <= 0x7f;
                }, Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
                    if ("rollUp" !== this.mode_ && (this.row_ = 14, this.mode_ = "rollUp", this.flushDisplayed(pts), this.nonDisplayed_ = createDisplayBuffer(), this.displayed_ = createDisplayBuffer()), void 0 !== newBaseRow && newBaseRow !== this.row_) for(var i = 0; i < this.rollUpRows_; i++)this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i], this.displayed_[this.row_ - i] = "";
                    void 0 === newBaseRow && (newBaseRow = this.row_), this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
                }, Cea608Stream.prototype.addFormatting = function(pts, format) {
                    this.formatting_ = this.formatting_.concat(format);
                    var text = format.reduce(function(text, format) {
                        return text + "<" + format + ">";
                    }, "");
                    this[this.mode_](pts, text);
                }, Cea608Stream.prototype.clearFormatting = function(pts) {
                    if (this.formatting_.length) {
                        var text = this.formatting_.reverse().reduce(function(text, format) {
                            return text + "</" + format + ">";
                        }, "");
                        this.formatting_ = [], this[this.mode_](pts, text);
                    }
                }, Cea608Stream.prototype.popOn = function(pts, text) {
                    var baseRow = this.nonDisplayed_[this.row_];
                    baseRow += text, this.nonDisplayed_[this.row_] = baseRow;
                }, Cea608Stream.prototype.rollUp = function(pts, text) {
                    var baseRow = this.displayed_[this.row_];
                    baseRow += text, this.displayed_[this.row_] = baseRow;
                }, Cea608Stream.prototype.shiftRowsUp_ = function() {
                    var i;
                    for(i = 0; i < this.topRow_; i++)this.displayed_[i] = "";
                    for(i = this.row_ + 1; i < 15; i++)this.displayed_[i] = "";
                    for(i = this.topRow_; i < this.row_; i++)this.displayed_[i] = this.displayed_[i + 1];
                    this.displayed_[this.row_] = "";
                }, Cea608Stream.prototype.paintOn = function(pts, text) {
                    var baseRow = this.displayed_[this.row_];
                    baseRow += text, this.displayed_[this.row_] = baseRow;
                };
                var captionStream = {
                    CaptionStream: CaptionStream$1,
                    Cea608Stream: Cea608Stream,
                    Cea708Stream: Cea708Stream
                }, streamTypes = {
                    H264_STREAM_TYPE: 0x1b,
                    ADTS_STREAM_TYPE: 0x0f,
                    METADATA_STREAM_TYPE: 0x15
                }, TYPE_SHARED = "shared", handleRollover$1 = function(value, reference) {
                    var direction = 1;
                    for(value > reference && (direction = -1); Math.abs(reference - value) > 4294967296;)value += 8589934592 * direction;
                    return value;
                }, TimestampRolloverStream$1 = function TimestampRolloverStream(type) {
                    var lastDTS, referenceDTS;
                    TimestampRolloverStream.prototype.init.call(this), this.type_ = type || TYPE_SHARED, this.push = function(data) {
                        (this.type_ === TYPE_SHARED || data.type === this.type_) && (void 0 === referenceDTS && (referenceDTS = data.dts), data.dts = handleRollover$1(data.dts, referenceDTS), data.pts = handleRollover$1(data.pts, referenceDTS), lastDTS = data.dts, this.trigger("data", data));
                    }, this.flush = function() {
                        referenceDTS = lastDTS, this.trigger("done");
                    }, this.endTimeline = function() {
                        this.flush(), this.trigger("endedtimeline");
                    }, this.discontinuity = function() {
                        referenceDTS = void 0, lastDTS = void 0;
                    }, this.reset = function() {
                        this.discontinuity(), this.trigger("reset");
                    };
                };
                TimestampRolloverStream$1.prototype = new Stream();
                var videoSample, audioSample, audioTrun, videoTrun, trunHeader, box, ftyp, minf, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS, silence, secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, _MetadataStream, timestampRolloverStream = {
                    TimestampRolloverStream: TimestampRolloverStream$1,
                    handleRollover: handleRollover$1
                }, percentEncode$1 = function(bytes, start, end) {
                    var i, result = "";
                    for(i = start; i < end; i++)result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
                    return result;
                }, parseUtf8 = function(bytes, start, end) {
                    return decodeURIComponent(percentEncode$1(bytes, start, end));
                }, parseSyncSafeInteger$1 = function(data) {
                    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
                }, tagParsers = {
                    TXXX: function(tag) {
                        var i;
                        if (3 === tag.data[0]) {
                            for(i = 1; i < tag.data.length; i++)if (0 === tag.data[i]) {
                                tag.description = parseUtf8(tag.data, 1, i), tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\0*$/, "");
                                break;
                            }
                            tag.data = tag.value;
                        }
                    },
                    WXXX: function(tag) {
                        var i;
                        if (3 === tag.data[0]) {
                            for(i = 1; i < tag.data.length; i++)if (0 === tag.data[i]) {
                                tag.description = parseUtf8(tag.data, 1, i), tag.url = parseUtf8(tag.data, i + 1, tag.data.length);
                                break;
                            }
                        }
                    },
                    PRIV: function(tag) {
                        var i;
                        for(i = 0; i < tag.data.length; i++)if (0 === tag.data[i]) {
                            tag.owner = unescape(percentEncode$1(tag.data, 0, i));
                            break;
                        }
                        tag.privateData = tag.data.subarray(i + 1), tag.data = tag.privateData;
                    }
                };
                (_MetadataStream = function(options) {
                    var i, settings = {
                        descriptor: options && options.descriptor
                    }, tagSize = 0, buffer = [], bufferSize = 0;
                    if (_MetadataStream.prototype.init.call(this), this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16), settings.descriptor) for(i = 0; i < settings.descriptor.length; i++)this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
                    this.push = function(chunk) {
                        var tag, frameStart, frameSize, frame, i;
                        if ("timed-metadata" === chunk.type) {
                            if (chunk.dataAlignmentIndicator && (bufferSize = 0, buffer.length = 0), 0 === buffer.length && (chunk.data.length < 10 || 73 !== chunk.data[0] || 68 !== chunk.data[1] || 51 !== chunk.data[2])) {
                                this.trigger("log", {
                                    level: "warn",
                                    message: "Skipping unrecognized metadata packet"
                                });
                                return;
                            }
                            if (buffer.push(chunk), bufferSize += chunk.data.byteLength, 1 === buffer.length && (tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10)) + 10), !(bufferSize < tagSize)) {
                                for(i = 0, tag = {
                                    data: new Uint8Array(tagSize),
                                    frames: [],
                                    pts: buffer[0].pts,
                                    dts: buffer[0].dts
                                }; i < tagSize;)tag.data.set(buffer[0].data.subarray(0, tagSize - i), i), i += buffer[0].data.byteLength, bufferSize -= buffer[0].data.byteLength, buffer.shift();
                                frameStart = 10, 0x40 & tag.data[5] && (frameStart += 4 + parseSyncSafeInteger$1(tag.data.subarray(10, 14)), tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20)));
                                do {
                                    if ((frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8))) < 1) {
                                        this.trigger("log", {
                                            level: "warn",
                                            message: "Malformed ID3 frame encountered. Skipping metadata parsing."
                                        });
                                        return;
                                    }
                                    if ((frame = {
                                        id: String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]),
                                        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
                                    }).key = frame.id, tagParsers[frame.id] && (tagParsers[frame.id](frame), "com.apple.streaming.transportStreamTimestamp" === frame.owner)) {
                                        var d = frame.data, size = (0x01 & d[3]) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                                        size *= 4, size += 0x03 & d[7], frame.timeStamp = size, void 0 === tag.pts && void 0 === tag.dts && (tag.pts = frame.timeStamp, tag.dts = frame.timeStamp), this.trigger("timestamp", frame);
                                    }
                                    tag.frames.push(frame), frameStart += 10 + frameSize;
                                }while (frameStart < tagSize)
                                this.trigger("data", tag);
                            }
                        }
                    };
                }).prototype = new Stream();
                var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
                (_TransportPacketStream = function() {
                    var buffer = new Uint8Array(188), bytesInBuffer = 0;
                    _TransportPacketStream.prototype.init.call(this), this.push = function(bytes) {
                        var everything, startIndex = 0, endIndex = 188;
                        for(bytesInBuffer ? ((everything = new Uint8Array(bytes.byteLength + bytesInBuffer)).set(buffer.subarray(0, bytesInBuffer)), everything.set(bytes, bytesInBuffer), bytesInBuffer = 0) : everything = bytes; endIndex < everything.byteLength;){
                            if (0x47 === everything[startIndex] && 0x47 === everything[endIndex]) {
                                this.trigger("data", everything.subarray(startIndex, endIndex)), startIndex += 188, endIndex += 188;
                                continue;
                            }
                            startIndex++, endIndex++;
                        }
                        startIndex < everything.byteLength && (buffer.set(everything.subarray(startIndex), 0), bytesInBuffer = everything.byteLength - startIndex);
                    }, this.flush = function() {
                        188 === bytesInBuffer && 0x47 === buffer[0] && (this.trigger("data", buffer), bytesInBuffer = 0), this.trigger("done");
                    }, this.endTimeline = function() {
                        this.flush(), this.trigger("endedtimeline");
                    }, this.reset = function() {
                        bytesInBuffer = 0, this.trigger("reset");
                    };
                }).prototype = new Stream(), (_TransportParseStream = function() {
                    var parsePsi, parsePat, parsePmt, self1;
                    _TransportParseStream.prototype.init.call(this), self1 = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, parsePsi = function(payload, psi) {
                        var offset = 0;
                        psi.payloadUnitStartIndicator && (offset += payload[offset] + 1), "pat" === psi.type ? parsePat(payload.subarray(offset), psi) : parsePmt(payload.subarray(offset), psi);
                    }, parsePat = function(payload, pat) {
                        pat.section_number = payload[7], pat.last_section_number = payload[8], self1.pmtPid = (0x1f & payload[10]) << 8 | payload[11], pat.pmtPid = self1.pmtPid;
                    }, parsePmt = function(payload, pmt) {
                        var tableEnd, offset;
                        if (0x01 & payload[5]) {
                            for(self1.programMapTable = {
                                video: null,
                                audio: null,
                                "timed-metadata": {}
                            }, tableEnd = 3 + ((0x0f & payload[1]) << 8 | payload[2]) - 4, offset = 12 + ((0x0f & payload[10]) << 8 | payload[11]); offset < tableEnd;){
                                var streamType = payload[offset], pid = (0x1f & payload[offset + 1]) << 8 | payload[offset + 2];
                                streamType === streamTypes.H264_STREAM_TYPE && null === self1.programMapTable.video ? self1.programMapTable.video = pid : streamType === streamTypes.ADTS_STREAM_TYPE && null === self1.programMapTable.audio ? self1.programMapTable.audio = pid : streamType === streamTypes.METADATA_STREAM_TYPE && (self1.programMapTable["timed-metadata"][pid] = streamType), offset += ((0x0f & payload[offset + 3]) << 8 | payload[offset + 4]) + 5;
                            }
                            pmt.programMapTable = self1.programMapTable;
                        }
                    }, this.push = function(packet) {
                        var result = {}, offset = 4;
                        if (result.payloadUnitStartIndicator = !!(0x40 & packet[1]), result.pid = 0x1f & packet[1], result.pid <<= 8, result.pid |= packet[2], (0x30 & packet[3]) >>> 4 > 0x01 && (offset += packet[offset] + 1), 0 === result.pid) result.type = "pat", parsePsi(packet.subarray(offset), result), this.trigger("data", result);
                        else if (result.pid === this.pmtPid) for(result.type = "pmt", parsePsi(packet.subarray(offset), result), this.trigger("data", result); this.packetsWaitingForPmt.length;)this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
                        else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([
                            packet,
                            offset,
                            result
                        ]) : this.processPes_(packet, offset, result);
                    }, this.processPes_ = function(packet, offset, result) {
                        result.pid === this.programMapTable.video ? result.streamType = streamTypes.H264_STREAM_TYPE : result.pid === this.programMapTable.audio ? result.streamType = streamTypes.ADTS_STREAM_TYPE : result.streamType = this.programMapTable["timed-metadata"][result.pid], result.type = "pes", result.data = packet.subarray(offset), this.trigger("data", result);
                    };
                }).prototype = new Stream(), _TransportParseStream.STREAM_TYPES = {
                    h264: 0x1b,
                    adts: 0x0f
                }, (_ElementaryStream = function() {
                    var programMapTable, self1 = this, segmentHadPmt = !1, video = {
                        data: [],
                        size: 0
                    }, audio = {
                        data: [],
                        size: 0
                    }, timedMetadata = {
                        data: [],
                        size: 0
                    }, parsePes = function(payload, pes) {
                        var ptsDtsFlags, startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
                        pes.data = new Uint8Array(), 1 === startPrefix && (pes.packetLength = 6 + (payload[4] << 8 | payload[5]), pes.dataAlignmentIndicator = (0x04 & payload[6]) != 0, 0xc0 & (ptsDtsFlags = payload[7]) && (pes.pts = (0x0e & payload[9]) << 27 | (0xff & payload[10]) << 20 | (0xfe & payload[11]) << 12 | (0xff & payload[12]) << 5 | (0xfe & payload[13]) >>> 3, pes.pts *= 4, pes.pts += (0x06 & payload[13]) >>> 1, pes.dts = pes.pts, 0x40 & ptsDtsFlags && (pes.dts = (0x0e & payload[14]) << 27 | (0xff & payload[15]) << 20 | (0xfe & payload[16]) << 12 | (0xff & payload[17]) << 5 | (0xfe & payload[18]) >>> 3, pes.dts *= 4, pes.dts += (0x06 & payload[18]) >>> 1)), pes.data = payload.subarray(9 + payload[8]));
                    }, flushStream = function(stream, type, forceFlush) {
                        var fragment, packetData = new Uint8Array(stream.size), event = {
                            type: type
                        }, i = 0, offset = 0, packetFlushable = !1;
                        if (stream.data.length && !(stream.size < 9)) {
                            for(i = 0, event.trackId = stream.data[0].pid; i < stream.data.length; i++)fragment = stream.data[i], packetData.set(fragment.data, offset), offset += fragment.data.byteLength;
                            parsePes(packetData, event), packetFlushable = "video" === type || event.packetLength <= stream.size, (forceFlush || packetFlushable) && (stream.size = 0, stream.data.length = 0), packetFlushable && self1.trigger("data", event);
                        }
                    };
                    _ElementaryStream.prototype.init.call(this), this.push = function(data) {
                        ({
                            pat: function() {},
                            pes: function() {
                                var stream, streamType;
                                switch(data.streamType){
                                    case streamTypes.H264_STREAM_TYPE:
                                        stream = video, streamType = "video";
                                        break;
                                    case streamTypes.ADTS_STREAM_TYPE:
                                        stream = audio, streamType = "audio";
                                        break;
                                    case streamTypes.METADATA_STREAM_TYPE:
                                        stream = timedMetadata, streamType = "timed-metadata";
                                        break;
                                    default:
                                        return;
                                }
                                data.payloadUnitStartIndicator && flushStream(stream, streamType, !0), stream.data.push(data), stream.size += data.data.byteLength;
                            },
                            pmt: function() {
                                var event = {
                                    type: "metadata",
                                    tracks: []
                                };
                                null !== (programMapTable = data.programMapTable).video && event.tracks.push({
                                    timelineStartInfo: {
                                        baseMediaDecodeTime: 0
                                    },
                                    id: +programMapTable.video,
                                    codec: "avc",
                                    type: "video"
                                }), null !== programMapTable.audio && event.tracks.push({
                                    timelineStartInfo: {
                                        baseMediaDecodeTime: 0
                                    },
                                    id: +programMapTable.audio,
                                    codec: "adts",
                                    type: "audio"
                                }), segmentHadPmt = !0, self1.trigger("data", event);
                            }
                        })[data.type]();
                    }, this.reset = function() {
                        video.size = 0, video.data.length = 0, audio.size = 0, audio.data.length = 0, this.trigger("reset");
                    }, this.flushStreams_ = function() {
                        flushStream(video, "video"), flushStream(audio, "audio"), flushStream(timedMetadata, "timed-metadata");
                    }, this.flush = function() {
                        if (!segmentHadPmt && programMapTable) {
                            var pmt = {
                                type: "metadata",
                                tracks: []
                            };
                            null !== programMapTable.video && pmt.tracks.push({
                                timelineStartInfo: {
                                    baseMediaDecodeTime: 0
                                },
                                id: +programMapTable.video,
                                codec: "avc",
                                type: "video"
                            }), null !== programMapTable.audio && pmt.tracks.push({
                                timelineStartInfo: {
                                    baseMediaDecodeTime: 0
                                },
                                id: +programMapTable.audio,
                                codec: "adts",
                                type: "audio"
                            }), self1.trigger("data", pmt);
                        }
                        segmentHadPmt = !1, this.flushStreams_(), this.trigger("done");
                    };
                }).prototype = new Stream();
                var m2ts = {
                    PAT_PID: 0x0000,
                    MP2T_PACKET_LENGTH: 188,
                    TransportPacketStream: _TransportPacketStream,
                    TransportParseStream: _TransportParseStream,
                    ElementaryStream: _ElementaryStream,
                    TimestampRolloverStream: TimestampRolloverStream,
                    CaptionStream: captionStream.CaptionStream,
                    Cea608Stream: captionStream.Cea608Stream,
                    Cea708Stream: captionStream.Cea708Stream,
                    MetadataStream: _MetadataStream
                };
                for(var type in streamTypes)streamTypes.hasOwnProperty(type) && (m2ts[type] = streamTypes[type]);
                var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS, ADTS_SAMPLING_FREQUENCIES$1 = [
                    96000,
                    88200,
                    64000,
                    48000,
                    44100,
                    32000,
                    24000,
                    22050,
                    16000,
                    12000,
                    11025,
                    8000,
                    7350
                ];
                (_AdtsStream = function(handlePartialSegments) {
                    var buffer, frameNum = 0;
                    _AdtsStream.prototype.init.call(this), this.skipWarn_ = function(start, end) {
                        this.trigger("log", {
                            level: "warn",
                            message: "adts skiping bytes " + start + " to " + end + " in frame " + frameNum + " outside syncword"
                        });
                    }, this.push = function(packet) {
                        var skip, frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration, i = 0;
                        if (handlePartialSegments || (frameNum = 0), "audio" === packet.type) {
                            for(buffer && buffer.length ? (oldBuffer = buffer, (buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength)).set(oldBuffer), buffer.set(packet.data, oldBuffer.byteLength)) : buffer = packet.data; i + 7 < buffer.length;){
                                if (0xff !== buffer[i] || (0xf6 & buffer[i + 1]) != 0xf0) {
                                    "number" != typeof skip && (skip = i), i++;
                                    continue;
                                }
                                if ("number" == typeof skip && (this.skipWarn_(skip, i), skip = null), protectionSkipBytes = (0x01 & ~buffer[i + 1]) * 2, frameLength = (0x03 & buffer[i + 3]) << 11 | buffer[i + 4] << 3 | (0xe0 & buffer[i + 5]) >> 5, adtsFrameDuration = (sampleCount = ((0x03 & buffer[i + 6]) + 1) * 1024) * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(0x3c & buffer[i + 2]) >>> 2], buffer.byteLength - i < frameLength) break;
                                this.trigger("data", {
                                    pts: packet.pts + frameNum * adtsFrameDuration,
                                    dts: packet.dts + frameNum * adtsFrameDuration,
                                    sampleCount: sampleCount,
                                    audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,
                                    channelcount: (1 & buffer[i + 2]) << 2 | (0xc0 & buffer[i + 3]) >>> 6,
                                    samplerate: ADTS_SAMPLING_FREQUENCIES$1[(0x3c & buffer[i + 2]) >>> 2],
                                    samplingfrequencyindex: (0x3c & buffer[i + 2]) >>> 2,
                                    samplesize: 16,
                                    data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
                                }), frameNum++, i += frameLength;
                            }
                            "number" == typeof skip && (this.skipWarn_(skip, i), skip = null), buffer = buffer.subarray(i);
                        }
                    }, this.flush = function() {
                        frameNum = 0, this.trigger("done");
                    }, this.reset = function() {
                        buffer = void 0, this.trigger("reset");
                    }, this.endTimeline = function() {
                        buffer = void 0, this.trigger("endedtimeline");
                    };
                }).prototype = new Stream();
                var expGolomb = function(workingData) {
                    var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
                    this.length = function() {
                        return 8 * workingBytesAvailable;
                    }, this.bitsAvailable = function() {
                        return 8 * workingBytesAvailable + workingBitsAvailable;
                    }, this.loadWord = function() {
                        var position = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
                        if (0 === availableBytes) throw Error("no bytes available");
                        workingBytes.set(workingData.subarray(position, position + availableBytes)), workingWord = new DataView(workingBytes.buffer).getUint32(0), workingBitsAvailable = 8 * availableBytes, workingBytesAvailable -= availableBytes;
                    }, this.skipBits = function(count) {
                        var skipBytes;
                        workingBitsAvailable > count ? (workingWord <<= count, workingBitsAvailable -= count) : (count -= workingBitsAvailable, skipBytes = Math.floor(count / 8), count -= 8 * skipBytes, workingBytesAvailable -= skipBytes, this.loadWord(), workingWord <<= count, workingBitsAvailable -= count);
                    }, this.readBits = function(size) {
                        var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
                        return ((workingBitsAvailable -= bits) > 0 ? workingWord <<= bits : workingBytesAvailable > 0 && this.loadWord(), (bits = size - bits) > 0) ? valu << bits | this.readBits(bits) : valu;
                    }, this.skipLeadingZeros = function() {
                        var leadingZeroCount;
                        for(leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount)if ((workingWord & 0x80000000 >>> leadingZeroCount) != 0) return workingWord <<= leadingZeroCount, workingBitsAvailable -= leadingZeroCount, leadingZeroCount;
                        return this.loadWord(), leadingZeroCount + this.skipLeadingZeros();
                    }, this.skipUnsignedExpGolomb = function() {
                        this.skipBits(1 + this.skipLeadingZeros());
                    }, this.skipExpGolomb = function() {
                        this.skipBits(1 + this.skipLeadingZeros());
                    }, this.readUnsignedExpGolomb = function() {
                        var clz = this.skipLeadingZeros();
                        return this.readBits(clz + 1) - 1;
                    }, this.readExpGolomb = function() {
                        var valu = this.readUnsignedExpGolomb();
                        return 0x01 & valu ? 1 + valu >>> 1 : -1 * (valu >>> 1);
                    }, this.readBoolean = function() {
                        return 1 === this.readBits(1);
                    }, this.readUnsignedByte = function() {
                        return this.readBits(8);
                    }, this.loadWord();
                };
                (_NalByteStream = function() {
                    var i, buffer, syncPoint = 0;
                    _NalByteStream.prototype.init.call(this), this.push = function(data) {
                        buffer ? ((swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength)).set(buffer), swapBuffer.set(data.data, buffer.byteLength), buffer = swapBuffer) : buffer = data.data;
                        for(var swapBuffer, len = buffer.byteLength; syncPoint < len - 3; syncPoint++)if (1 === buffer[syncPoint + 2]) {
                            i = syncPoint + 5;
                            break;
                        }
                        for(; i < len;)switch(buffer[i]){
                            case 0:
                                if (0 !== buffer[i - 1]) {
                                    i += 2;
                                    break;
                                }
                                if (0 !== buffer[i - 2]) {
                                    i++;
                                    break;
                                }
                                syncPoint + 3 !== i - 2 && this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
                                do i++;
                                while (1 !== buffer[i] && i < len)
                                syncPoint = i - 2, i += 3;
                                break;
                            case 1:
                                if (0 !== buffer[i - 1] || 0 !== buffer[i - 2]) {
                                    i += 3;
                                    break;
                                }
                                this.trigger("data", buffer.subarray(syncPoint + 3, i - 2)), syncPoint = i - 2, i += 3;
                                break;
                            default:
                                i += 3;
                        }
                        buffer = buffer.subarray(syncPoint), i -= syncPoint, syncPoint = 0;
                    }, this.reset = function() {
                        buffer = null, syncPoint = 0, this.trigger("reset");
                    }, this.flush = function() {
                        buffer && buffer.byteLength > 3 && this.trigger("data", buffer.subarray(syncPoint + 3)), buffer = null, syncPoint = 0, this.trigger("done");
                    }, this.endTimeline = function() {
                        this.flush(), this.trigger("endedtimeline");
                    };
                }).prototype = new Stream(), PROFILES_WITH_OPTIONAL_SPS_DATA = {
                    100: !0,
                    110: !0,
                    122: !0,
                    244: !0,
                    44: !0,
                    83: !0,
                    86: !0,
                    118: !0,
                    128: !0,
                    138: !0,
                    139: !0,
                    134: !0
                }, (_H264Stream = function() {
                    var self1, trackId, currentPts, currentDts, discardEmulationPreventionBytes, readSequenceParameterSet, skipScalingList, nalByteStream = new _NalByteStream();
                    _H264Stream.prototype.init.call(this), self1 = this, this.push = function(packet) {
                        "video" === packet.type && (trackId = packet.trackId, currentPts = packet.pts, currentDts = packet.dts, nalByteStream.push(packet));
                    }, nalByteStream.on("data", function(data) {
                        var event = {
                            trackId: trackId,
                            pts: currentPts,
                            dts: currentDts,
                            data: data,
                            nalUnitTypeCode: 0x1f & data[0]
                        };
                        switch(event.nalUnitTypeCode){
                            case 0x05:
                                event.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
                                break;
                            case 0x06:
                                event.nalUnitType = "sei_rbsp", event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));
                                break;
                            case 0x07:
                                event.nalUnitType = "seq_parameter_set_rbsp", event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1)), event.config = readSequenceParameterSet(event.escapedRBSP);
                                break;
                            case 0x08:
                                event.nalUnitType = "pic_parameter_set_rbsp";
                                break;
                            case 0x09:
                                event.nalUnitType = "access_unit_delimiter_rbsp";
                        }
                        self1.trigger("data", event);
                    }), nalByteStream.on("done", function() {
                        self1.trigger("done");
                    }), nalByteStream.on("partialdone", function() {
                        self1.trigger("partialdone");
                    }), nalByteStream.on("reset", function() {
                        self1.trigger("reset");
                    }), nalByteStream.on("endedtimeline", function() {
                        self1.trigger("endedtimeline");
                    }), this.flush = function() {
                        nalByteStream.flush();
                    }, this.partialFlush = function() {
                        nalByteStream.partialFlush();
                    }, this.reset = function() {
                        nalByteStream.reset();
                    }, this.endTimeline = function() {
                        nalByteStream.endTimeline();
                    }, skipScalingList = function(count, expGolombDecoder) {
                        var j, lastScale = 8, nextScale = 8;
                        for(j = 0; j < count; j++)0 !== nextScale && (nextScale = (lastScale + expGolombDecoder.readExpGolomb() + 256) % 256), lastScale = 0 === nextScale ? lastScale : nextScale;
                    }, discardEmulationPreventionBytes = function(data) {
                        for(var newLength, newData, length = data.byteLength, emulationPreventionBytesPositions = [], i = 1; i < length - 2;)0 === data[i] && 0 === data[i + 1] && 0x03 === data[i + 2] ? (emulationPreventionBytesPositions.push(i + 2), i += 2) : i++;
                        if (0 === emulationPreventionBytesPositions.length) return data;
                        newLength = length - emulationPreventionBytesPositions.length, newData = new Uint8Array(newLength);
                        var sourceIndex = 0;
                        for(i = 0; i < newLength; sourceIndex++, i++)sourceIndex === emulationPreventionBytesPositions[0] && (sourceIndex++, emulationPreventionBytesPositions.shift()), newData[i] = data[sourceIndex];
                        return newData;
                    }, readSequenceParameterSet = function(data) {
                        var expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, i, frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, sarRatio = [
                            1,
                            1
                        ];
                        if (profileIdc = (expGolombDecoder = new expGolomb(data)).readUnsignedByte(), profileCompatibility = expGolombDecoder.readUnsignedByte(), levelIdc = expGolombDecoder.readUnsignedByte(), expGolombDecoder.skipUnsignedExpGolomb(), PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc] && (3 === (chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb()) && expGolombDecoder.skipBits(1), expGolombDecoder.skipUnsignedExpGolomb(), expGolombDecoder.skipUnsignedExpGolomb(), expGolombDecoder.skipBits(1), expGolombDecoder.readBoolean())) for(i = 0, scalingListCount = 3 !== chromaFormatIdc ? 8 : 12; i < scalingListCount; i++)expGolombDecoder.readBoolean() && (i < 6 ? skipScalingList(16, expGolombDecoder) : skipScalingList(64, expGolombDecoder));
                        if (expGolombDecoder.skipUnsignedExpGolomb(), 0 === (picOrderCntType = expGolombDecoder.readUnsignedExpGolomb())) expGolombDecoder.readUnsignedExpGolomb();
                        else if (1 === picOrderCntType) for(expGolombDecoder.skipBits(1), expGolombDecoder.skipExpGolomb(), expGolombDecoder.skipExpGolomb(), numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb(), i = 0; i < numRefFramesInPicOrderCntCycle; i++)expGolombDecoder.skipExpGolomb();
                        if (expGolombDecoder.skipUnsignedExpGolomb(), expGolombDecoder.skipBits(1), picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb(), picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb(), 0 === (frameMbsOnlyFlag = expGolombDecoder.readBits(1)) && expGolombDecoder.skipBits(1), expGolombDecoder.skipBits(1), expGolombDecoder.readBoolean() && (frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb(), frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb(), frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb(), frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb()), expGolombDecoder.readBoolean() && expGolombDecoder.readBoolean()) {
                            switch(expGolombDecoder.readUnsignedByte()){
                                case 1:
                                    sarRatio = [
                                        1,
                                        1
                                    ];
                                    break;
                                case 2:
                                    sarRatio = [
                                        12,
                                        11
                                    ];
                                    break;
                                case 3:
                                    sarRatio = [
                                        10,
                                        11
                                    ];
                                    break;
                                case 4:
                                    sarRatio = [
                                        16,
                                        11
                                    ];
                                    break;
                                case 5:
                                    sarRatio = [
                                        40,
                                        33
                                    ];
                                    break;
                                case 6:
                                    sarRatio = [
                                        24,
                                        11
                                    ];
                                    break;
                                case 7:
                                    sarRatio = [
                                        20,
                                        11
                                    ];
                                    break;
                                case 8:
                                    sarRatio = [
                                        32,
                                        11
                                    ];
                                    break;
                                case 9:
                                    sarRatio = [
                                        80,
                                        33
                                    ];
                                    break;
                                case 10:
                                    sarRatio = [
                                        18,
                                        11
                                    ];
                                    break;
                                case 11:
                                    sarRatio = [
                                        15,
                                        11
                                    ];
                                    break;
                                case 12:
                                    sarRatio = [
                                        64,
                                        33
                                    ];
                                    break;
                                case 13:
                                    sarRatio = [
                                        160,
                                        99
                                    ];
                                    break;
                                case 14:
                                    sarRatio = [
                                        4,
                                        3
                                    ];
                                    break;
                                case 15:
                                    sarRatio = [
                                        3,
                                        2
                                    ];
                                    break;
                                case 16:
                                    sarRatio = [
                                        2,
                                        1
                                    ];
                                    break;
                                case 255:
                                    sarRatio = [
                                        expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(),
                                        expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()
                                    ];
                            }
                            sarRatio && (sarRatio[0], sarRatio[1]);
                        }
                        return {
                            profileIdc: profileIdc,
                            levelIdc: levelIdc,
                            profileCompatibility: profileCompatibility,
                            width: (picWidthInMbsMinus1 + 1) * 16 - 2 * frameCropLeftOffset - 2 * frameCropRightOffset,
                            height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - 2 * frameCropTopOffset - 2 * frameCropBottomOffset,
                            sarRatio: sarRatio
                        };
                    };
                }).prototype = new Stream();
                var ADTS_SAMPLING_FREQUENCIES = [
                    96000,
                    88200,
                    64000,
                    48000,
                    44100,
                    32000,
                    24000,
                    22050,
                    16000,
                    12000,
                    11025,
                    8000,
                    7350
                ], parseId3TagSize = function(header, byteIndex) {
                    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9];
                    return (returnSize = returnSize >= 0 ? returnSize : 0, (16 & header[byteIndex + 5]) >> 4) ? returnSize + 20 : returnSize + 10;
                }, parseSyncSafeInteger = function(data) {
                    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
                }, percentEncode = function(bytes, start, end) {
                    var i, result = "";
                    for(i = start; i < end; i++)result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
                    return result;
                }, utils = {
                    isLikelyAacData: function(data) {
                        var offset = function getId3Offset(data, offset) {
                            return data.length - offset < 10 || 73 !== data[offset] || 68 !== data[offset + 1] || 51 !== data[offset + 2] ? offset : (offset += parseId3TagSize(data, offset), getId3Offset(data, offset));
                        }(data, 0);
                        return data.length >= offset + 2 && (0xff & data[offset]) == 0xff && (0xf0 & data[offset + 1]) == 0xf0 && (0x16 & data[offset + 1]) == 0x10;
                    },
                    parseId3TagSize: parseId3TagSize,
                    parseAdtsSize: function(header, byteIndex) {
                        var lowThree = (0xe0 & header[byteIndex + 5]) >> 5, middle = header[byteIndex + 4] << 3;
                        return 6144 & header[byteIndex + 3] | middle | lowThree;
                    },
                    parseType: function(header, byteIndex) {
                        return 73 === header[byteIndex] && 68 === header[byteIndex + 1] && 51 === header[byteIndex + 2] ? "timed-metadata" : !0 & header[byteIndex] && (0xf0 & header[byteIndex + 1]) == 0xf0 ? "audio" : null;
                    },
                    parseSampleRate: function(packet) {
                        for(var i = 0; i + 5 < packet.length;){
                            if (0xff !== packet[i] || (0xf6 & packet[i + 1]) != 0xf0) {
                                i++;
                                continue;
                            }
                            return ADTS_SAMPLING_FREQUENCIES[(0x3c & packet[i + 2]) >>> 2];
                        }
                        return null;
                    },
                    parseAacTimestamp: function(packet) {
                        var frameStart, frameSize, frame;
                        frameStart = 10, 0x40 & packet[5] && (frameStart += 4 + parseSyncSafeInteger(packet.subarray(10, 14)));
                        do {
                            if ((frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8))) < 1) break;
                            if ("PRIV" === String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3])) {
                                frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
                                for(var i = 0; i < frame.byteLength; i++)if (0 === frame[i]) {
                                    if ("com.apple.streaming.transportStreamTimestamp" === unescape(percentEncode(frame, 0, i))) {
                                        var d = frame.subarray(i + 1), size = (0x01 & d[3]) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                                        return size *= 4, size += 0x03 & d[7];
                                    }
                                    break;
                                }
                            }
                            frameStart += 10 + frameSize;
                        }while (frameStart < packet.byteLength)
                        return null;
                    }
                };
                (_AacStream = function() {
                    var everything = new Uint8Array(), timeStamp = 0;
                    _AacStream.prototype.init.call(this), this.setTimestamp = function(timestamp) {
                        timeStamp = timestamp;
                    }, this.push = function(bytes) {
                        var chunk, packet, tempLength, frameSize = 0, byteIndex = 0;
                        for(everything.length ? (tempLength = everything.length, (everything = new Uint8Array(bytes.byteLength + tempLength)).set(everything.subarray(0, tempLength)), everything.set(bytes, tempLength)) : everything = bytes; everything.length - byteIndex >= 3;){
                            if (73 === everything[byteIndex] && 68 === everything[byteIndex + 1] && 51 === everything[byteIndex + 2]) {
                                if (everything.length - byteIndex < 10 || (frameSize = utils.parseId3TagSize(everything, byteIndex), byteIndex + frameSize > everything.length)) break;
                                chunk = {
                                    type: "timed-metadata",
                                    data: everything.subarray(byteIndex, byteIndex + frameSize)
                                }, this.trigger("data", chunk), byteIndex += frameSize;
                                continue;
                            }
                            if ((0xff & everything[byteIndex]) == 0xff && (0xf0 & everything[byteIndex + 1]) == 0xf0) {
                                if (everything.length - byteIndex < 7 || (frameSize = utils.parseAdtsSize(everything, byteIndex), byteIndex + frameSize > everything.length)) break;
                                packet = {
                                    type: "audio",
                                    data: everything.subarray(byteIndex, byteIndex + frameSize),
                                    pts: timeStamp,
                                    dts: timeStamp
                                }, this.trigger("data", packet), byteIndex += frameSize;
                                continue;
                            }
                            byteIndex++;
                        }
                        everything = everything.length - byteIndex > 0 ? everything.subarray(byteIndex) : new Uint8Array();
                    }, this.reset = function() {
                        everything = new Uint8Array(), this.trigger("reset");
                    }, this.endTimeline = function() {
                        everything = new Uint8Array(), this.trigger("endedtimeline");
                    };
                }).prototype = new Stream();
                var audioProperties = [
                    "audioobjecttype",
                    "channelcount",
                    "samplerate",
                    "samplingfrequencyindex",
                    "samplesize"
                ], videoProperties = [
                    "width",
                    "height",
                    "profileIdc",
                    "levelIdc",
                    "profileCompatibility",
                    "sarRatio"
                ], isLikelyAacData = utils.isLikelyAacData, ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS, retriggerForStream = function(key, event) {
                    event.stream = key, this.trigger("log", event);
                }, addPipelineLogRetriggers = function(transmuxer, pipeline) {
                    for(var keys = Object.keys(pipeline), i = 0; i < keys.length; i++){
                        var key = keys[i];
                        "headOfPipeline" !== key && pipeline[key].on && pipeline[key].on("log", retriggerForStream.bind(transmuxer, key));
                    }
                }, arrayEquals = function(a, b) {
                    var i;
                    if (a.length !== b.length) return !1;
                    for(i = 0; i < a.length; i++)if (a[i] !== b[i]) return !1;
                    return !0;
                }, generateSegmentTimingInfo = function(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
                    return {
                        start: {
                            dts: baseMediaDecodeTime,
                            pts: baseMediaDecodeTime + (startPts - startDts)
                        },
                        end: {
                            dts: baseMediaDecodeTime + (endDts - startDts),
                            pts: baseMediaDecodeTime + (endPts - startPts)
                        },
                        prependedContentDuration: prependedContentDuration,
                        baseMediaDecodeTime: baseMediaDecodeTime
                    };
                };
                (_AudioSegmentStream = function(track, options) {
                    var sequenceNumber, adtsFrames = [], earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = 1 / 0;
                    sequenceNumber = (options = options || {}).firstSequenceNumber || 0, _AudioSegmentStream.prototype.init.call(this), this.push = function(data) {
                        trackDecodeInfo.collectDtsInfo(track, data), track && audioProperties.forEach(function(prop) {
                            track[prop] = data[prop];
                        }), adtsFrames.push(data);
                    }, this.setEarliestDts = function(earliestDts) {
                        earliestAllowedDts = earliestDts;
                    }, this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
                        videoBaseMediaDecodeTime = baseMediaDecodeTime;
                    }, this.setAudioAppendStart = function(timestamp) {
                        audioAppendStartTs = timestamp;
                    }, this.flush = function() {
                        var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
                        if (0 === adtsFrames.length) {
                            this.trigger("done", "AudioSegmentStream");
                            return;
                        }
                        frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts), track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps), videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime), track.samples = audioFrameUtils.generateSampleTable(frames), mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames)), adtsFrames = [], moof = mp4Generator.moof(sequenceNumber, [
                            track
                        ]), boxes = new Uint8Array(moof.byteLength + mdat.byteLength), sequenceNumber++, boxes.set(moof), boxes.set(mdat, moof.byteLength), trackDecodeInfo.clearDtsInfo(track), frameDuration = Math.ceil(1024 * ONE_SECOND_IN_TS$1 / track.samplerate), frames.length && (segmentDuration = frames.length * frameDuration, this.trigger("segmentTimingInfo", generateSegmentTimingInfo(clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0)), this.trigger("timingInfo", {
                            start: frames[0].pts,
                            end: frames[0].pts + segmentDuration
                        })), this.trigger("data", {
                            track: track,
                            boxes: boxes
                        }), this.trigger("done", "AudioSegmentStream");
                    }, this.reset = function() {
                        trackDecodeInfo.clearDtsInfo(track), adtsFrames = [], this.trigger("reset");
                    };
                }).prototype = new Stream(), (_VideoSegmentStream = function(track, options) {
                    var sequenceNumber, config, pps, nalUnits = [], gopsToAlignWith = [];
                    sequenceNumber = (options = options || {}).firstSequenceNumber || 0, _VideoSegmentStream.prototype.init.call(this), delete track.minPTS, this.gopCache_ = [], this.push = function(nalUnit) {
                        trackDecodeInfo.collectDtsInfo(track, nalUnit), "seq_parameter_set_rbsp" !== nalUnit.nalUnitType || config || (config = nalUnit.config, track.sps = [
                            nalUnit.data
                        ], videoProperties.forEach(function(prop) {
                            track[prop] = config[prop];
                        }, this)), "pic_parameter_set_rbsp" !== nalUnit.nalUnitType || pps || (pps = nalUnit.data, track.pps = [
                            nalUnit.data
                        ]), nalUnits.push(nalUnit);
                    }, this.flush = function() {
                        for(var alignedGops, frames, gopForFusion, gops, moof, mdat, boxes, firstGop, lastGop, prependedContentDuration = 0; nalUnits.length && "access_unit_delimiter_rbsp" !== nalUnits[0].nalUnitType;)nalUnits.shift();
                        if (0 === nalUnits.length) {
                            this.resetStream_(), this.trigger("done", "VideoSegmentStream");
                            return;
                        }
                        if (frames = frameUtils.groupNalsIntoFrames(nalUnits), (gops = frameUtils.groupFramesIntoGops(frames))[0][0].keyFrame || ((gopForFusion = this.getGopForFusion_(nalUnits[0], track)) ? (prependedContentDuration = gopForFusion.duration, gops.unshift(gopForFusion), gops.byteLength += gopForFusion.byteLength, gops.nalCount += gopForFusion.nalCount, gops.pts = gopForFusion.pts, gops.dts = gopForFusion.dts, gops.duration += gopForFusion.duration) : gops = frameUtils.extendFirstKeyFrame(gops)), gopsToAlignWith.length) {
                            if (!(alignedGops = options.alignGopsAtEnd ? this.alignGopsAtEnd_(gops) : this.alignGopsAtStart_(gops))) {
                                this.gopCache_.unshift({
                                    gop: gops.pop(),
                                    pps: track.pps,
                                    sps: track.sps
                                }), this.gopCache_.length = Math.min(6, this.gopCache_.length), nalUnits = [], this.resetStream_(), this.trigger("done", "VideoSegmentStream");
                                return;
                            }
                            trackDecodeInfo.clearDtsInfo(track), gops = alignedGops;
                        }
                        trackDecodeInfo.collectDtsInfo(track, gops), track.samples = frameUtils.generateSampleTable(gops), mdat = mp4Generator.mdat(frameUtils.concatenateNalData(gops)), track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps), this.trigger("processedGopsInfo", gops.map(function(gop) {
                            return {
                                pts: gop.pts,
                                dts: gop.dts,
                                byteLength: gop.byteLength
                            };
                        })), firstGop = gops[0], lastGop = gops[gops.length - 1], this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration)), this.trigger("timingInfo", {
                            start: gops[0].pts,
                            end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
                        }), this.gopCache_.unshift({
                            gop: gops.pop(),
                            pps: track.pps,
                            sps: track.sps
                        }), this.gopCache_.length = Math.min(6, this.gopCache_.length), nalUnits = [], this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime), this.trigger("timelineStartInfo", track.timelineStartInfo), moof = mp4Generator.moof(sequenceNumber, [
                            track
                        ]), boxes = new Uint8Array(moof.byteLength + mdat.byteLength), sequenceNumber++, boxes.set(moof), boxes.set(mdat, moof.byteLength), this.trigger("data", {
                            track: track,
                            boxes: boxes
                        }), this.resetStream_(), this.trigger("done", "VideoSegmentStream");
                    }, this.reset = function() {
                        this.resetStream_(), nalUnits = [], this.gopCache_.length = 0, gopsToAlignWith.length = 0, this.trigger("reset");
                    }, this.resetStream_ = function() {
                        trackDecodeInfo.clearDtsInfo(track), config = void 0, pps = void 0;
                    }, this.getGopForFusion_ = function(nalUnit) {
                        var dtsDistance, nearestGopObj, currentGop, currentGopObj, i, nearestDistance = 1 / 0;
                        for(i = 0; i < this.gopCache_.length; i++)currentGop = (currentGopObj = this.gopCache_[i]).gop, track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0]) && track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]) && !(currentGop.dts < track.timelineStartInfo.dts) && (dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration) >= -10000 && dtsDistance <= 45000 && (!nearestGopObj || nearestDistance > dtsDistance) && (nearestGopObj = currentGopObj, nearestDistance = dtsDistance);
                        return nearestGopObj ? nearestGopObj.gop : null;
                    }, this.alignGopsAtStart_ = function(gops) {
                        var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;
                        for(byteLength = gops.byteLength, nalCount = gops.nalCount, duration = gops.duration, alignIndex = gopIndex = 0; alignIndex < gopsToAlignWith.length && gopIndex < gops.length && (align = gopsToAlignWith[alignIndex], gop = gops[gopIndex], align.pts !== gop.pts);){
                            if (gop.pts > align.pts) {
                                alignIndex++;
                                continue;
                            }
                            gopIndex++, byteLength -= gop.byteLength, nalCount -= gop.nalCount, duration -= gop.duration;
                        }
                        return 0 === gopIndex ? gops : gopIndex === gops.length ? null : ((alignedGops = gops.slice(gopIndex)).byteLength = byteLength, alignedGops.duration = duration, alignedGops.nalCount = nalCount, alignedGops.pts = alignedGops[0].pts, alignedGops.dts = alignedGops[0].dts, alignedGops);
                    }, this.alignGopsAtEnd_ = function(gops) {
                        for(alignIndex = gopsToAlignWith.length - 1, gopIndex = gops.length - 1, alignEndIndex = null, matchFound = !1; alignIndex >= 0 && gopIndex >= 0;){
                            if (align = gopsToAlignWith[alignIndex], gop = gops[gopIndex], align.pts === gop.pts) {
                                matchFound = !0;
                                break;
                            }
                            if (align.pts > gop.pts) {
                                alignIndex--;
                                continue;
                            }
                            alignIndex === gopsToAlignWith.length - 1 && (alignEndIndex = gopIndex), gopIndex--;
                        }
                        if (!matchFound && null === alignEndIndex) return null;
                        if (0 === (trimIndex = matchFound ? gopIndex : alignEndIndex)) return gops;
                        var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound, trimIndex, alignedGops = gops.slice(trimIndex), metadata = alignedGops.reduce(function(total, gop) {
                            return total.byteLength += gop.byteLength, total.duration += gop.duration, total.nalCount += gop.nalCount, total;
                        }, {
                            byteLength: 0,
                            duration: 0,
                            nalCount: 0
                        });
                        return alignedGops.byteLength = metadata.byteLength, alignedGops.duration = metadata.duration, alignedGops.nalCount = metadata.nalCount, alignedGops.pts = alignedGops[0].pts, alignedGops.dts = alignedGops[0].dts, alignedGops;
                    }, this.alignGopsWith = function(newGopsToAlignWith) {
                        gopsToAlignWith = newGopsToAlignWith;
                    };
                }).prototype = new Stream(), (_CoalesceStream = function(options, metadataStream) {
                    this.numberOfTracks = 0, this.metadataStream = metadataStream, void 0 !== (options = options || {}).remux ? this.remuxTracks = !!options.remux : this.remuxTracks = !0, "boolean" == typeof options.keepOriginalTimestamps ? this.keepOriginalTimestamps = options.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, _CoalesceStream.prototype.init.call(this), this.push = function(output) {
                        return output.text ? this.pendingCaptions.push(output) : output.frames ? this.pendingMetadata.push(output) : void (this.pendingTracks.push(output.track), this.pendingBytes += output.boxes.byteLength, "video" === output.track.type && (this.videoTrack = output.track, this.pendingBoxes.push(output.boxes)), "audio" === output.track.type && (this.audioTrack = output.track, this.pendingBoxes.unshift(output.boxes)));
                    };
                }).prototype = new Stream(), _CoalesceStream.prototype.flush = function(flushSource) {
                    var caption, id3, initSegment, i, offset = 0, event = {
                        captions: [],
                        captionStreams: {},
                        metadata: [],
                        info: {}
                    }, timelineStartPts = 0;
                    if (this.pendingTracks.length < this.numberOfTracks) {
                        if ("VideoSegmentStream" !== flushSource && "AudioSegmentStream" !== flushSource || this.remuxTracks) return;
                        if (0 === this.pendingTracks.length) {
                            this.emittedTracks++, this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
                            return;
                        }
                    }
                    if (this.videoTrack ? (timelineStartPts = this.videoTrack.timelineStartInfo.pts, videoProperties.forEach(function(prop) {
                        event.info[prop] = this.videoTrack[prop];
                    }, this)) : this.audioTrack && (timelineStartPts = this.audioTrack.timelineStartInfo.pts, audioProperties.forEach(function(prop) {
                        event.info[prop] = this.audioTrack[prop];
                    }, this)), this.videoTrack || this.audioTrack) {
                        for(1 === this.pendingTracks.length ? event.type = this.pendingTracks[0].type : event.type = "combined", this.emittedTracks += this.pendingTracks.length, initSegment = mp4Generator.initSegment(this.pendingTracks), event.initSegment = new Uint8Array(initSegment.byteLength), event.initSegment.set(initSegment), event.data = new Uint8Array(this.pendingBytes), i = 0; i < this.pendingBoxes.length; i++)event.data.set(this.pendingBoxes[i], offset), offset += this.pendingBoxes[i].byteLength;
                        for(i = 0; i < this.pendingCaptions.length; i++)(caption = this.pendingCaptions[i]).startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps), caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps), event.captionStreams[caption.stream] = !0, event.captions.push(caption);
                        for(i = 0; i < this.pendingMetadata.length; i++)(id3 = this.pendingMetadata[i]).cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps), event.metadata.push(id3);
                        for(event.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", event), i = 0; i < event.captions.length; i++)caption = event.captions[i], this.trigger("caption", caption);
                        for(i = 0; i < event.metadata.length; i++)id3 = event.metadata[i], this.trigger("id3Frame", id3);
                    }
                    this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
                }, _CoalesceStream.prototype.setRemux = function(val) {
                    this.remuxTracks = val;
                }, (_Transmuxer = function(options) {
                    var videoTrack, audioTrack, self1 = this, hasFlushed = !0;
                    _Transmuxer.prototype.init.call(this), options = options || {}, this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() {
                        var pipeline = {};
                        this.transmuxPipeline_ = pipeline, pipeline.type = "aac", pipeline.metadataStream = new m2ts.MetadataStream(), pipeline.aacStream = new _AacStream(), pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream("audio"), pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream("timed-metadata"), pipeline.adtsStream = new _AdtsStream(), pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream), pipeline.headOfPipeline = pipeline.aacStream, pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream), pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream), pipeline.metadataStream.on("timestamp", function(frame) {
                            pipeline.aacStream.setTimestamp(frame.timeStamp);
                        }), pipeline.aacStream.on("data", function(data) {
                            "timed-metadata" !== data.type && "audio" !== data.type || pipeline.audioSegmentStream || (audioTrack = audioTrack || {
                                timelineStartInfo: {
                                    baseMediaDecodeTime: self1.baseMediaDecodeTime
                                },
                                codec: "adts",
                                type: "audio"
                            }, pipeline.coalesceStream.numberOfTracks++, pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options), pipeline.audioSegmentStream.on("log", self1.getLogTrigger_("audioSegmentStream")), pipeline.audioSegmentStream.on("timingInfo", self1.trigger.bind(self1, "audioTimingInfo")), pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream), self1.trigger("trackinfo", {
                                hasAudio: !!audioTrack,
                                hasVideo: !!videoTrack
                            }));
                        }), pipeline.coalesceStream.on("data", this.trigger.bind(this, "data")), pipeline.coalesceStream.on("done", this.trigger.bind(this, "done")), addPipelineLogRetriggers(this, pipeline);
                    }, this.setupTsPipeline = function() {
                        var pipeline = {};
                        this.transmuxPipeline_ = pipeline, pipeline.type = "ts", pipeline.metadataStream = new m2ts.MetadataStream(), pipeline.packetStream = new m2ts.TransportPacketStream(), pipeline.parseStream = new m2ts.TransportParseStream(), pipeline.elementaryStream = new m2ts.ElementaryStream(), pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream(), pipeline.adtsStream = new _AdtsStream(), pipeline.h264Stream = new _H264Stream(), pipeline.captionStream = new m2ts.CaptionStream(options), pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream), pipeline.headOfPipeline = pipeline.packetStream, pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream), pipeline.timestampRolloverStream.pipe(pipeline.h264Stream), pipeline.timestampRolloverStream.pipe(pipeline.adtsStream), pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream), pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream), pipeline.elementaryStream.on("data", function(data) {
                            var i;
                            if ("metadata" === data.type) {
                                for(i = data.tracks.length; i--;)videoTrack || "video" !== data.tracks[i].type ? audioTrack || "audio" !== data.tracks[i].type || ((audioTrack = data.tracks[i]).timelineStartInfo.baseMediaDecodeTime = self1.baseMediaDecodeTime) : (videoTrack = data.tracks[i]).timelineStartInfo.baseMediaDecodeTime = self1.baseMediaDecodeTime;
                                videoTrack && !pipeline.videoSegmentStream && (pipeline.coalesceStream.numberOfTracks++, pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options), pipeline.videoSegmentStream.on("log", self1.getLogTrigger_("videoSegmentStream")), pipeline.videoSegmentStream.on("timelineStartInfo", function(timelineStartInfo) {
                                    audioTrack && !options.keepOriginalTimestamps && (audioTrack.timelineStartInfo = timelineStartInfo, pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self1.baseMediaDecodeTime));
                                }), pipeline.videoSegmentStream.on("processedGopsInfo", self1.trigger.bind(self1, "gopInfo")), pipeline.videoSegmentStream.on("segmentTimingInfo", self1.trigger.bind(self1, "videoSegmentTimingInfo")), pipeline.videoSegmentStream.on("baseMediaDecodeTime", function(baseMediaDecodeTime) {
                                    audioTrack && pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
                                }), pipeline.videoSegmentStream.on("timingInfo", self1.trigger.bind(self1, "videoTimingInfo")), pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream)), audioTrack && !pipeline.audioSegmentStream && (pipeline.coalesceStream.numberOfTracks++, pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options), pipeline.audioSegmentStream.on("log", self1.getLogTrigger_("audioSegmentStream")), pipeline.audioSegmentStream.on("timingInfo", self1.trigger.bind(self1, "audioTimingInfo")), pipeline.audioSegmentStream.on("segmentTimingInfo", self1.trigger.bind(self1, "audioSegmentTimingInfo")), pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream)), self1.trigger("trackinfo", {
                                    hasAudio: !!audioTrack,
                                    hasVideo: !!videoTrack
                                });
                            }
                        }), pipeline.coalesceStream.on("data", this.trigger.bind(this, "data")), pipeline.coalesceStream.on("id3Frame", function(id3Frame) {
                            id3Frame.dispatchType = pipeline.metadataStream.dispatchType, self1.trigger("id3Frame", id3Frame);
                        }), pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption")), pipeline.coalesceStream.on("done", this.trigger.bind(this, "done")), addPipelineLogRetriggers(this, pipeline);
                    }, this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
                        var pipeline = this.transmuxPipeline_;
                        options.keepOriginalTimestamps || (this.baseMediaDecodeTime = baseMediaDecodeTime), audioTrack && (audioTrack.timelineStartInfo.dts = void 0, audioTrack.timelineStartInfo.pts = void 0, trackDecodeInfo.clearDtsInfo(audioTrack), pipeline.audioTimestampRolloverStream && pipeline.audioTimestampRolloverStream.discontinuity()), videoTrack && (pipeline.videoSegmentStream && (pipeline.videoSegmentStream.gopCache_ = []), videoTrack.timelineStartInfo.dts = void 0, videoTrack.timelineStartInfo.pts = void 0, trackDecodeInfo.clearDtsInfo(videoTrack), pipeline.captionStream.reset()), pipeline.timestampRolloverStream && pipeline.timestampRolloverStream.discontinuity();
                    }, this.setAudioAppendStart = function(timestamp) {
                        audioTrack && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
                    }, this.setRemux = function(val) {
                        var pipeline = this.transmuxPipeline_;
                        options.remux = val, pipeline && pipeline.coalesceStream && pipeline.coalesceStream.setRemux(val);
                    }, this.alignGopsWith = function(gopsToAlignWith) {
                        videoTrack && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
                    }, this.getLogTrigger_ = function(key) {
                        var self1 = this;
                        return function(event) {
                            event.stream = key, self1.trigger("log", event);
                        };
                    }, this.push = function(data) {
                        if (hasFlushed) {
                            var isAac = isLikelyAacData(data);
                            isAac && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : isAac || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), hasFlushed = !1;
                        }
                        this.transmuxPipeline_.headOfPipeline.push(data);
                    }, this.flush = function() {
                        hasFlushed = !0, this.transmuxPipeline_.headOfPipeline.flush();
                    }, this.endTimeline = function() {
                        this.transmuxPipeline_.headOfPipeline.endTimeline();
                    }, this.reset = function() {
                        this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset();
                    }, this.resetCaptions = function() {
                        this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset();
                    };
                }).prototype = new Stream();
                var transmuxer = {
                    Transmuxer: _Transmuxer,
                    VideoSegmentStream: _VideoSegmentStream,
                    AudioSegmentStream: _AudioSegmentStream,
                    AUDIO_PROPERTIES: audioProperties,
                    VIDEO_PROPERTIES: videoProperties,
                    generateSegmentTimingInfo: generateSegmentTimingInfo
                }, bin = {
                    toUnsigned: function(value) {
                        return value >>> 0;
                    },
                    toHexString: function(value) {
                        return ("00" + value.toString(16)).slice(-2);
                    }
                }, parseType_1 = function(buffer) {
                    return "" + (String.fromCharCode(buffer[0]) + String.fromCharCode(buffer[1]) + String.fromCharCode(buffer[2]) + String.fromCharCode(buffer[3]));
                }, toUnsigned$2 = bin.toUnsigned, findBox_1 = function findBox(data, path) {
                    var i, size, type, end, subresults, results = [];
                    if (!path.length) return null;
                    for(i = 0; i < data.byteLength;)size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]), type = parseType_1(data.subarray(i + 4, i + 8)), end = size > 1 ? i + size : data.byteLength, type === path[0] && (1 === path.length ? results.push(data.subarray(i + 8, end)) : (subresults = findBox(data.subarray(i + 8, end), path.slice(1))).length && (results = results.concat(subresults))), i = end;
                    return results;
                }, toUnsigned$1 = bin.toUnsigned, parseTfdt = function(data) {
                    var result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        baseMediaDecodeTime: toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7])
                    };
                    return 1 === result.version && (result.baseMediaDecodeTime *= 4294967296, result.baseMediaDecodeTime += toUnsigned$1(data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11])), result;
                }, parseSampleFlags_1 = function(flags) {
                    return {
                        isLeading: (0x0c & flags[0]) >>> 2,
                        dependsOn: 0x03 & flags[0],
                        isDependedOn: (0xc0 & flags[1]) >>> 6,
                        hasRedundancy: (0x30 & flags[1]) >>> 4,
                        paddingValue: (0x0e & flags[1]) >>> 1,
                        isNonSyncSample: 0x01 & flags[1],
                        degradationPriority: flags[2] << 8 | flags[3]
                    };
                }, parseTrun = function(data) {
                    var sample, result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        samples: []
                    }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = 0x01 & result.flags[2], firstSampleFlagsPresent = 0x04 & result.flags[2], sampleDurationPresent = 0x01 & result.flags[1], sampleSizePresent = 0x02 & result.flags[1], sampleFlagsPresent = 0x04 & result.flags[1], sampleCompositionTimeOffsetPresent = 0x08 & result.flags[1], sampleCount = view.getUint32(4), offset = 8;
                    for(dataOffsetPresent && (result.dataOffset = view.getInt32(offset), offset += 4), firstSampleFlagsPresent && sampleCount && (sample = {
                        flags: parseSampleFlags_1(data.subarray(offset, offset + 4))
                    }, offset += 4, sampleDurationPresent && (sample.duration = view.getUint32(offset), offset += 4), sampleSizePresent && (sample.size = view.getUint32(offset), offset += 4), sampleCompositionTimeOffsetPresent && (1 === result.version ? sample.compositionTimeOffset = view.getInt32(offset) : sample.compositionTimeOffset = view.getUint32(offset), offset += 4), result.samples.push(sample), sampleCount--); sampleCount--;)sample = {}, sampleDurationPresent && (sample.duration = view.getUint32(offset), offset += 4), sampleSizePresent && (sample.size = view.getUint32(offset), offset += 4), sampleFlagsPresent && (sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4)), offset += 4), sampleCompositionTimeOffsetPresent && (1 === result.version ? sample.compositionTimeOffset = view.getInt32(offset) : sample.compositionTimeOffset = view.getUint32(offset), offset += 4), result.samples.push(sample);
                    return result;
                }, parseTfhd = function(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        trackId: view.getUint32(4)
                    }, baseDataOffsetPresent = 0x01 & result.flags[2], sampleDescriptionIndexPresent = 0x02 & result.flags[2], defaultSampleDurationPresent = 0x08 & result.flags[2], defaultSampleSizePresent = 0x10 & result.flags[2], defaultSampleFlagsPresent = 0x20 & result.flags[2], durationIsEmpty = 0x010000 & result.flags[0], defaultBaseIsMoof = 0x020000 & result.flags[0];
                    return i = 8, baseDataOffsetPresent && (i += 4, result.baseDataOffset = view.getUint32(12), i += 4), sampleDescriptionIndexPresent && (result.sampleDescriptionIndex = view.getUint32(i), i += 4), defaultSampleDurationPresent && (result.defaultSampleDuration = view.getUint32(i), i += 4), defaultSampleSizePresent && (result.defaultSampleSize = view.getUint32(i), i += 4), defaultSampleFlagsPresent && (result.defaultSampleFlags = view.getUint32(i)), durationIsEmpty && (result.durationIsEmpty = !0), !baseDataOffsetPresent && defaultBaseIsMoof && (result.baseDataOffsetIsMoof = !0), result;
                }, discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes, CaptionStream = captionStream.CaptionStream, mapToSample = function(offset, samples) {
                    for(var approximateOffset = offset, i = 0; i < samples.length; i++){
                        var sample = samples[i];
                        if (approximateOffset < sample.size) return sample;
                        approximateOffset -= sample.size;
                    }
                    return null;
                }, findSeiNals = function(avcStream, samples, trackId) {
                    var seiNal, i, length, lastMatchedSample, avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
                        logs: [],
                        seiNals: []
                    };
                    for(i = 0; i + 4 < avcStream.length; i += length)if (length = avcView.getUint32(i), i += 4, !(length <= 0)) switch(0x1f & avcStream[i]){
                        case 0x06:
                            var data = avcStream.subarray(i + 1, i + 1 + length), matchingSample = mapToSample(i, samples);
                            if (seiNal = {
                                nalUnitType: "sei_rbsp",
                                size: length,
                                data: data,
                                escapedRBSP: discardEmulationPreventionBytes(data),
                                trackId: trackId
                            }, matchingSample) seiNal.pts = matchingSample.pts, seiNal.dts = matchingSample.dts, lastMatchedSample = matchingSample;
                            else if (lastMatchedSample) seiNal.pts = lastMatchedSample.pts, seiNal.dts = lastMatchedSample.dts;
                            else {
                                result.logs.push({
                                    level: "warn",
                                    message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
                                });
                                break;
                            }
                            result.seiNals.push(seiNal);
                    }
                    return result;
                }, parseSamples = function(truns, baseMediaDecodeTime, tfhd) {
                    var currentDts = baseMediaDecodeTime, defaultSampleDuration = tfhd.defaultSampleDuration || 0, defaultSampleSize = tfhd.defaultSampleSize || 0, trackId = tfhd.trackId, allSamples = [];
                    return truns.forEach(function(trun) {
                        var samples = parseTrun(trun).samples;
                        samples.forEach(function(sample) {
                            void 0 === sample.duration && (sample.duration = defaultSampleDuration), void 0 === sample.size && (sample.size = defaultSampleSize), sample.trackId = trackId, sample.dts = currentDts, void 0 === sample.compositionTimeOffset && (sample.compositionTimeOffset = 0), sample.pts = currentDts + sample.compositionTimeOffset, currentDts += sample.duration;
                        }), allSamples = allSamples.concat(samples);
                    }), allSamples;
                }, parseCaptionNals = function(segment, videoTrackId) {
                    var trafs = findBox_1(segment, [
                        "moof",
                        "traf"
                    ]), mdats = findBox_1(segment, [
                        "mdat"
                    ]), captionNals = {}, mdatTrafPairs = [];
                    return mdats.forEach(function(mdat, index) {
                        var matchingTraf = trafs[index];
                        mdatTrafPairs.push({
                            mdat: mdat,
                            traf: matchingTraf
                        });
                    }), mdatTrafPairs.forEach(function(pair) {
                        var result, mdat = pair.mdat, traf = pair.traf, headerInfo = parseTfhd(findBox_1(traf, [
                            "tfhd"
                        ])[0]), trackId = headerInfo.trackId, tfdt = findBox_1(traf, [
                            "tfdt"
                        ]), baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0, truns = findBox_1(traf, [
                            "trun"
                        ]);
                        videoTrackId === trackId && truns.length > 0 && (result = findSeiNals(mdat, parseSamples(truns, baseMediaDecodeTime, headerInfo), trackId), captionNals[trackId] || (captionNals[trackId] = {
                            seiNals: [],
                            logs: []
                        }), captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals), captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs));
                    }), captionNals;
                }, parseEmbeddedCaptions = function(segment, trackId, timescale) {
                    if (null === trackId) return null;
                    var trackNals = parseCaptionNals(segment, trackId)[trackId] || {};
                    return {
                        seiNals: trackNals.seiNals,
                        logs: trackNals.logs,
                        timescale: timescale
                    };
                }, captionParser = function() {
                    var captionStream, segmentCache, trackId, timescale, parsedCaptions, parsingPartial, isInitialized = !1;
                    this.isInitialized = function() {
                        return isInitialized;
                    }, this.init = function(options) {
                        captionStream = new CaptionStream(), isInitialized = !0, parsingPartial = !!options && options.isPartial, captionStream.on("data", function(event) {
                            event.startTime = event.startPts / timescale, event.endTime = event.endPts / timescale, parsedCaptions.captions.push(event), parsedCaptions.captionStreams[event.stream] = !0;
                        }), captionStream.on("log", function(log) {
                            parsedCaptions.logs.push(log);
                        });
                    }, this.isNewInit = function(videoTrackIds, timescales) {
                        return (!videoTrackIds || 0 !== videoTrackIds.length) && (!timescales || "object" != typeof timescales || 0 !== Object.keys(timescales).length) && (trackId !== videoTrackIds[0] || timescale !== timescales[trackId]);
                    }, this.parse = function(segment, videoTrackIds, timescales) {
                        var parsedData;
                        if (!this.isInitialized() || !videoTrackIds || !timescales) return null;
                        if (this.isNewInit(videoTrackIds, timescales)) timescale = timescales[trackId = videoTrackIds[0]];
                        else if (null === trackId || !timescale) return segmentCache.push(segment), null;
                        for(; segmentCache.length > 0;){
                            var cachedSegment = segmentCache.shift();
                            this.parse(cachedSegment, videoTrackIds, timescales);
                        }
                        return ((parsedData = parseEmbeddedCaptions(segment, trackId, timescale)) && parsedData.logs && (parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs)), null !== parsedData && parsedData.seiNals) ? (this.pushNals(parsedData.seiNals), this.flushStream(), parsedCaptions) : parsedCaptions.logs.length ? {
                            logs: parsedCaptions.logs,
                            captions: [],
                            captionStreams: []
                        } : null;
                    }, this.pushNals = function(nals) {
                        if (!this.isInitialized() || !nals || 0 === nals.length) return null;
                        nals.forEach(function(nal) {
                            captionStream.push(nal);
                        });
                    }, this.flushStream = function() {
                        if (!this.isInitialized()) return null;
                        parsingPartial ? captionStream.partialFlush() : captionStream.flush();
                    }, this.clearParsedCaptions = function() {
                        parsedCaptions.captions = [], parsedCaptions.captionStreams = {}, parsedCaptions.logs = [];
                    }, this.resetCaptionStream = function() {
                        if (!this.isInitialized()) return null;
                        captionStream.reset();
                    }, this.clearAllCaptions = function() {
                        this.clearParsedCaptions(), this.resetCaptionStream();
                    }, this.reset = function() {
                        segmentCache = [], trackId = null, timescale = null, parsedCaptions ? this.clearParsedCaptions() : parsedCaptions = {
                            captions: [],
                            captionStreams: {},
                            logs: []
                        }, this.resetCaptionStream();
                    }, this.reset();
                }, toUnsigned = bin.toUnsigned, toHexString = bin.toHexString, probe$2 = {
                    findBox: findBox_1,
                    parseType: parseType_1,
                    timescale: function(init) {
                        return findBox_1(init, [
                            "moov",
                            "trak"
                        ]).reduce(function(result, trak) {
                            var tkhd, index, id, mdhd;
                            return (tkhd = findBox_1(trak, [
                                "tkhd"
                            ])[0]) && (id = toUnsigned(tkhd[index = 0 === tkhd[0] ? 12 : 20] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]), mdhd = findBox_1(trak, [
                                "mdia",
                                "mdhd"
                            ])[0]) ? (index = 0 === mdhd[0] ? 12 : 20, result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]), result) : null;
                        }, {});
                    },
                    startTime: function(timescale, fragment) {
                        var trafs, baseTimes, result;
                        return trafs = findBox_1(fragment, [
                            "moof",
                            "traf"
                        ]), baseTimes = [].concat.apply([], trafs.map(function(traf) {
                            return findBox_1(traf, [
                                "tfhd"
                            ]).map(function(tfhd) {
                                var scale, baseTime;
                                return scale = timescale[toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7])] || 90e3, (baseTime = "number" != typeof (baseTime = findBox_1(traf, [
                                    "tfdt"
                                ]).map(function(tfdt) {
                                    var version, result;
                                    return version = tfdt[0], result = toUnsigned(tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7]), 1 === version && (result *= 4294967296, result += toUnsigned(tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11])), result;
                                })[0]) || isNaN(baseTime) ? 1 / 0 : baseTime) / scale;
                            });
                        })), isFinite(result = Math.min.apply(null, baseTimes)) ? result : 0;
                    },
                    compositionStartTime: function(timescales, fragment) {
                        var trackId, trafBoxes = findBox_1(fragment, [
                            "moof",
                            "traf"
                        ]), baseMediaDecodeTime = 0, compositionTimeOffset = 0;
                        if (trafBoxes && trafBoxes.length) {
                            var tfhd = findBox_1(trafBoxes[0], [
                                "tfhd"
                            ])[0], trun = findBox_1(trafBoxes[0], [
                                "trun"
                            ])[0], tfdt = findBox_1(trafBoxes[0], [
                                "tfdt"
                            ])[0];
                            if (tfhd && (trackId = parseTfhd(tfhd).trackId), tfdt && (baseMediaDecodeTime = parseTfdt(tfdt).baseMediaDecodeTime), trun) {
                                var parsedTrun = parseTrun(trun);
                                parsedTrun.samples && parsedTrun.samples.length && (compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0);
                            }
                        }
                        return (baseMediaDecodeTime + compositionTimeOffset) / (timescales[trackId] || 90e3);
                    },
                    videoTrackIds: function(init) {
                        var traks = findBox_1(init, [
                            "moov",
                            "trak"
                        ]), videoTrackIds = [];
                        return traks.forEach(function(trak) {
                            var hdlrs = findBox_1(trak, [
                                "mdia",
                                "hdlr"
                            ]), tkhds = findBox_1(trak, [
                                "tkhd"
                            ]);
                            hdlrs.forEach(function(hdlr, index) {
                                var view, trackId, handlerType = parseType_1(hdlr.subarray(8, 12)), tkhd = tkhds[index];
                                "vide" === handlerType && (trackId = 0 === (view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength)).getUint8(0) ? view.getUint32(12) : view.getUint32(20), videoTrackIds.push(trackId));
                            });
                        }), videoTrackIds;
                    },
                    tracks: function(init) {
                        var traks = findBox_1(init, [
                            "moov",
                            "trak"
                        ]), tracks = [];
                        return traks.forEach(function(trak) {
                            var track = {}, tkhd = findBox_1(trak, [
                                "tkhd"
                            ])[0];
                            tkhd && (tkhdVersion = (view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength)).getUint8(0), track.id = 0 === tkhdVersion ? view.getUint32(12) : view.getUint32(20));
                            var hdlr = findBox_1(trak, [
                                "mdia",
                                "hdlr"
                            ])[0];
                            if (hdlr) {
                                var type = parseType_1(hdlr.subarray(8, 12));
                                "vide" === type ? track.type = "video" : "soun" === type ? track.type = "audio" : track.type = type;
                            }
                            var stsd = findBox_1(trak, [
                                "mdia",
                                "minf",
                                "stbl",
                                "stsd"
                            ])[0];
                            if (stsd) {
                                var view, tkhdVersion, codecConfig, sampleDescriptions = stsd.subarray(8);
                                track.codec = parseType_1(sampleDescriptions.subarray(4, 8));
                                var codecBox = findBox_1(sampleDescriptions, [
                                    track.codec
                                ])[0];
                                codecBox && (/^[asm]vc[1-9]$/i.test(track.codec) ? "avcC" === parseType_1((codecConfig = codecBox.subarray(78)).subarray(4, 8)) && codecConfig.length > 11 ? (track.codec += ".", track.codec += toHexString(codecConfig[9]), track.codec += toHexString(codecConfig[10]), track.codec += toHexString(codecConfig[11])) : track.codec = "avc1.4d400d" : /^mp4[a,v]$/i.test(track.codec) ? "esds" === parseType_1((codecConfig = codecBox.subarray(28)).subarray(4, 8)) && codecConfig.length > 20 && 0 !== codecConfig[19] ? (track.codec += "." + toHexString(codecConfig[19]), track.codec += "." + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, "")) : track.codec = "mp4a.40.2" : track.codec = track.codec.toLowerCase());
                            }
                            var mdhd = findBox_1(trak, [
                                "mdia",
                                "mdhd"
                            ])[0];
                            mdhd && (track.timescale = getTimescaleFromMediaHeader(mdhd)), tracks.push(track);
                        }), tracks;
                    },
                    getTimescaleFromMediaHeader: getTimescaleFromMediaHeader = function(mdhd) {
                        var index = 0 === mdhd[0] ? 12 : 20;
                        return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);
                    }
                }, parsePid = function(packet) {
                    var pid = 0x1f & packet[1];
                    return pid <<= 8, pid |= packet[2];
                }, parsePayloadUnitStartIndicator = function(packet) {
                    return !!(0x40 & packet[1]);
                }, parseAdaptionField = function(packet) {
                    var offset = 0;
                    return (0x30 & packet[3]) >>> 4 > 0x01 && (offset += packet[4] + 1), offset;
                }, parseNalUnitType = function(type) {
                    switch(type){
                        case 0x05:
                            return "slice_layer_without_partitioning_rbsp_idr";
                        case 0x06:
                            return "sei_rbsp";
                        case 0x07:
                            return "seq_parameter_set_rbsp";
                        case 0x08:
                            return "pic_parameter_set_rbsp";
                        case 0x09:
                            return "access_unit_delimiter_rbsp";
                        default:
                            return null;
                    }
                }, handleRollover = timestampRolloverStream.handleRollover, probe = {};
                probe.ts = {
                    parseType: function(packet, pmtPid) {
                        var pid = parsePid(packet);
                        return 0 === pid ? "pat" : pid === pmtPid ? "pmt" : pmtPid ? "pes" : null;
                    },
                    parsePat: function(packet) {
                        var pusi = parsePayloadUnitStartIndicator(packet), offset = 4 + parseAdaptionField(packet);
                        return pusi && (offset += packet[offset] + 1), (0x1f & packet[offset + 10]) << 8 | packet[offset + 11];
                    },
                    parsePmt: function(packet) {
                        var tableEnd, programMapTable = {}, pusi = parsePayloadUnitStartIndicator(packet), payloadOffset = 4 + parseAdaptionField(packet);
                        if (pusi && (payloadOffset += packet[payloadOffset] + 1), 0x01 & packet[payloadOffset + 5]) {
                            tableEnd = 3 + ((0x0f & packet[payloadOffset + 1]) << 8 | packet[payloadOffset + 2]) - 4;
                            for(var offset = 12 + ((0x0f & packet[payloadOffset + 10]) << 8 | packet[payloadOffset + 11]); offset < tableEnd;){
                                var i = payloadOffset + offset;
                                programMapTable[(0x1f & packet[i + 1]) << 8 | packet[i + 2]] = packet[i], offset += ((0x0f & packet[i + 3]) << 8 | packet[i + 4]) + 5;
                            }
                            return programMapTable;
                        }
                    },
                    parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,
                    parsePesType: function(packet, programMapTable) {
                        switch(programMapTable[parsePid(packet)]){
                            case streamTypes.H264_STREAM_TYPE:
                                return "video";
                            case streamTypes.ADTS_STREAM_TYPE:
                                return "audio";
                            case streamTypes.METADATA_STREAM_TYPE:
                                return "timed-metadata";
                            default:
                                return null;
                        }
                    },
                    parsePesTime: function(packet) {
                        if (!parsePayloadUnitStartIndicator(packet)) return null;
                        var ptsDtsFlags, offset = 4 + parseAdaptionField(packet);
                        if (offset >= packet.byteLength) return null;
                        var pes = null;
                        return 0xc0 & (ptsDtsFlags = packet[offset + 7]) && ((pes = {}).pts = (0x0e & packet[offset + 9]) << 27 | (0xff & packet[offset + 10]) << 20 | (0xfe & packet[offset + 11]) << 12 | (0xff & packet[offset + 12]) << 5 | (0xfe & packet[offset + 13]) >>> 3, pes.pts *= 4, pes.pts += (0x06 & packet[offset + 13]) >>> 1, pes.dts = pes.pts, 0x40 & ptsDtsFlags && (pes.dts = (0x0e & packet[offset + 14]) << 27 | (0xff & packet[offset + 15]) << 20 | (0xfe & packet[offset + 16]) << 12 | (0xff & packet[offset + 17]) << 5 | (0xfe & packet[offset + 18]) >>> 3, pes.dts *= 4, pes.dts += (0x06 & packet[offset + 18]) >>> 1)), pes;
                    },
                    videoPacketContainsKeyFrame: function(packet) {
                        for(var offset = 4 + parseAdaptionField(packet), frameBuffer = packet.subarray(offset), frameI = 0, frameSyncPoint = 0, foundKeyFrame = !1; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++)if (1 === frameBuffer[frameSyncPoint + 2]) {
                            frameI = frameSyncPoint + 5;
                            break;
                        }
                        for(; frameI < frameBuffer.byteLength;)switch(frameBuffer[frameI]){
                            case 0:
                                if (0 !== frameBuffer[frameI - 1]) {
                                    frameI += 2;
                                    break;
                                }
                                if (0 !== frameBuffer[frameI - 2]) {
                                    frameI++;
                                    break;
                                }
                                frameSyncPoint + 3 !== frameI - 2 && "slice_layer_without_partitioning_rbsp_idr" === parseNalUnitType(0x1f & frameBuffer[frameSyncPoint + 3]) && (foundKeyFrame = !0);
                                do frameI++;
                                while (1 !== frameBuffer[frameI] && frameI < frameBuffer.length)
                                frameSyncPoint = frameI - 2, frameI += 3;
                                break;
                            case 1:
                                if (0 !== frameBuffer[frameI - 1] || 0 !== frameBuffer[frameI - 2]) {
                                    frameI += 3;
                                    break;
                                }
                                "slice_layer_without_partitioning_rbsp_idr" === parseNalUnitType(0x1f & frameBuffer[frameSyncPoint + 3]) && (foundKeyFrame = !0), frameSyncPoint = frameI - 2, frameI += 3;
                                break;
                            default:
                                frameI += 3;
                        }
                        return frameBuffer = frameBuffer.subarray(frameSyncPoint), frameI -= frameSyncPoint, frameSyncPoint = 0, frameBuffer && frameBuffer.byteLength > 3 && "slice_layer_without_partitioning_rbsp_idr" === parseNalUnitType(0x1f & frameBuffer[frameSyncPoint + 3]) && (foundKeyFrame = !0), foundKeyFrame;
                    }
                }, probe.aac = utils;
                var ONE_SECOND_IN_TS = clock.ONE_SECOND_IN_TS, parsePsi_ = function(bytes, pmt) {
                    for(var packet, startIndex = 0, endIndex = 188; endIndex < bytes.byteLength;){
                        if (0x47 === bytes[startIndex] && 0x47 === bytes[endIndex]) {
                            switch(packet = bytes.subarray(startIndex, endIndex), probe.ts.parseType(packet, pmt.pid)){
                                case "pat":
                                    pmt.pid = probe.ts.parsePat(packet);
                                    break;
                                case "pmt":
                                    var table = probe.ts.parsePmt(packet);
                                    pmt.table = pmt.table || {}, Object.keys(table).forEach(function(key) {
                                        pmt.table[key] = table[key];
                                    });
                            }
                            startIndex += 188, endIndex += 188;
                            continue;
                        }
                        startIndex++, endIndex++;
                    }
                }, parseAudioPes_ = function(bytes, pmt, result) {
                    for(var packet, pesType, pusi, parsed, startIndex = 0, endIndex = 188, endLoop = !1; endIndex <= bytes.byteLength;){
                        if (0x47 === bytes[startIndex] && (0x47 === bytes[endIndex] || endIndex === bytes.byteLength)) {
                            if (packet = bytes.subarray(startIndex, endIndex), "pes" === probe.ts.parseType(packet, pmt.pid) && (pesType = probe.ts.parsePesType(packet, pmt.table), pusi = probe.ts.parsePayloadUnitStartIndicator(packet), "audio" === pesType && pusi && (parsed = probe.ts.parsePesTime(packet)) && (parsed.type = "audio", result.audio.push(parsed), endLoop = !0)), endLoop) break;
                            startIndex += 188, endIndex += 188;
                            continue;
                        }
                        startIndex++, endIndex++;
                    }
                    for(startIndex = (endIndex = bytes.byteLength) - 188, endLoop = !1; startIndex >= 0;){
                        if (0x47 === bytes[startIndex] && (0x47 === bytes[endIndex] || endIndex === bytes.byteLength)) {
                            if (packet = bytes.subarray(startIndex, endIndex), "pes" === probe.ts.parseType(packet, pmt.pid) && (pesType = probe.ts.parsePesType(packet, pmt.table), pusi = probe.ts.parsePayloadUnitStartIndicator(packet), "audio" === pesType && pusi && (parsed = probe.ts.parsePesTime(packet)) && (parsed.type = "audio", result.audio.push(parsed), endLoop = !0)), endLoop) break;
                            startIndex -= 188, endIndex -= 188;
                            continue;
                        }
                        startIndex--, endIndex--;
                    }
                }, parseVideoPes_ = function(bytes, pmt, result) {
                    for(var packet, pesType, pusi, parsed, frame, i, pes, startIndex = 0, endIndex = 188, endLoop = !1, currentFrame = {
                        data: [],
                        size: 0
                    }; endIndex < bytes.byteLength;){
                        if (0x47 === bytes[startIndex] && 0x47 === bytes[endIndex]) {
                            if (packet = bytes.subarray(startIndex, endIndex), "pes" === probe.ts.parseType(packet, pmt.pid) && (pesType = probe.ts.parsePesType(packet, pmt.table), pusi = probe.ts.parsePayloadUnitStartIndicator(packet), "video" === pesType && (pusi && !endLoop && (parsed = probe.ts.parsePesTime(packet)) && (parsed.type = "video", result.video.push(parsed), endLoop = !0), !result.firstKeyFrame))) {
                                if (pusi && 0 !== currentFrame.size) {
                                    for(frame = new Uint8Array(currentFrame.size), i = 0; currentFrame.data.length;)pes = currentFrame.data.shift(), frame.set(pes, i), i += pes.byteLength;
                                    if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                                        var firstKeyFrame = probe.ts.parsePesTime(frame);
                                        firstKeyFrame ? (result.firstKeyFrame = firstKeyFrame, result.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                                    }
                                    currentFrame.size = 0;
                                }
                                currentFrame.data.push(packet), currentFrame.size += packet.byteLength;
                            }
                            if (endLoop && result.firstKeyFrame) break;
                            startIndex += 188, endIndex += 188;
                            continue;
                        }
                        startIndex++, endIndex++;
                    }
                    for(startIndex = (endIndex = bytes.byteLength) - 188, endLoop = !1; startIndex >= 0;){
                        if (0x47 === bytes[startIndex] && 0x47 === bytes[endIndex]) {
                            if (packet = bytes.subarray(startIndex, endIndex), "pes" === probe.ts.parseType(packet, pmt.pid) && (pesType = probe.ts.parsePesType(packet, pmt.table), pusi = probe.ts.parsePayloadUnitStartIndicator(packet), "video" === pesType && pusi && (parsed = probe.ts.parsePesTime(packet)) && (parsed.type = "video", result.video.push(parsed), endLoop = !0)), endLoop) break;
                            startIndex -= 188, endIndex -= 188;
                            continue;
                        }
                        startIndex--, endIndex--;
                    }
                }, adjustTimestamp_ = function(segmentInfo, baseTimestamp) {
                    if (segmentInfo.audio && segmentInfo.audio.length) {
                        var audioBaseTimestamp = baseTimestamp;
                        (void 0 === audioBaseTimestamp || isNaN(audioBaseTimestamp)) && (audioBaseTimestamp = segmentInfo.audio[0].dts), segmentInfo.audio.forEach(function(info) {
                            info.dts = handleRollover(info.dts, audioBaseTimestamp), info.pts = handleRollover(info.pts, audioBaseTimestamp), info.dtsTime = info.dts / ONE_SECOND_IN_TS, info.ptsTime = info.pts / ONE_SECOND_IN_TS;
                        });
                    }
                    if (segmentInfo.video && segmentInfo.video.length) {
                        var videoBaseTimestamp = baseTimestamp;
                        if ((void 0 === videoBaseTimestamp || isNaN(videoBaseTimestamp)) && (videoBaseTimestamp = segmentInfo.video[0].dts), segmentInfo.video.forEach(function(info) {
                            info.dts = handleRollover(info.dts, videoBaseTimestamp), info.pts = handleRollover(info.pts, videoBaseTimestamp), info.dtsTime = info.dts / ONE_SECOND_IN_TS, info.ptsTime = info.pts / ONE_SECOND_IN_TS;
                        }), segmentInfo.firstKeyFrame) {
                            var frame = segmentInfo.firstKeyFrame;
                            frame.dts = handleRollover(frame.dts, videoBaseTimestamp), frame.pts = handleRollover(frame.pts, videoBaseTimestamp), frame.dtsTime = frame.dts / ONE_SECOND_IN_TS, frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;
                        }
                    }
                }, inspectAac_ = function(bytes) {
                    for(var packet, endLoop = !1, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0; bytes.length - byteIndex >= 3;){
                        switch(probe.aac.parseType(bytes, byteIndex)){
                            case "timed-metadata":
                                if (bytes.length - byteIndex < 10 || (frameSize = probe.aac.parseId3TagSize(bytes, byteIndex)) > bytes.length) {
                                    endLoop = !0;
                                    break;
                                }
                                null === timestamp && (packet = bytes.subarray(byteIndex, byteIndex + frameSize), timestamp = probe.aac.parseAacTimestamp(packet)), byteIndex += frameSize;
                                break;
                            case "audio":
                                if (bytes.length - byteIndex < 7 || (frameSize = probe.aac.parseAdtsSize(bytes, byteIndex)) > bytes.length) {
                                    endLoop = !0;
                                    break;
                                }
                                null === sampleRate && (packet = bytes.subarray(byteIndex, byteIndex + frameSize), sampleRate = probe.aac.parseSampleRate(packet)), audioCount++, byteIndex += frameSize;
                                break;
                            default:
                                byteIndex++;
                        }
                        if (endLoop) return null;
                    }
                    if (null === sampleRate || null === timestamp) return null;
                    var audioTimescale = ONE_SECOND_IN_TS / sampleRate;
                    return {
                        audio: [
                            {
                                type: "audio",
                                dts: timestamp,
                                pts: timestamp
                            },
                            {
                                type: "audio",
                                dts: timestamp + 1024 * audioCount * audioTimescale,
                                pts: timestamp + 1024 * audioCount * audioTimescale
                            }
                        ]
                    };
                }, inspectTs_ = function(bytes) {
                    var pmt = {
                        pid: null,
                        table: null
                    }, result = {};
                    for(var pid in parsePsi_(bytes, pmt), pmt.table)if (pmt.table.hasOwnProperty(pid)) switch(pmt.table[pid]){
                        case streamTypes.H264_STREAM_TYPE:
                            result.video = [], parseVideoPes_(bytes, pmt, result), 0 === result.video.length && delete result.video;
                            break;
                        case streamTypes.ADTS_STREAM_TYPE:
                            result.audio = [], parseAudioPes_(bytes, pmt, result), 0 === result.audio.length && delete result.audio;
                    }
                    return result;
                }, tsInspector = {
                    inspect: function(bytes, baseTimestamp) {
                        var result;
                        return (result = probe.aac.isLikelyAacData(bytes) ? inspectAac_(bytes) : inspectTs_(bytes)) && (result.audio || result.video) ? (adjustTimestamp_(result, baseTimestamp), result) : null;
                    },
                    parseAudioPes_: parseAudioPes_
                }, wireTransmuxerEvents = function(self1, transmuxer) {
                    transmuxer.on("data", function(segment) {
                        var initArray = segment.initSegment;
                        segment.initSegment = {
                            data: initArray.buffer,
                            byteOffset: initArray.byteOffset,
                            byteLength: initArray.byteLength
                        };
                        var typedArray = segment.data;
                        segment.data = typedArray.buffer, self1.postMessage({
                            action: "data",
                            segment: segment,
                            byteOffset: typedArray.byteOffset,
                            byteLength: typedArray.byteLength
                        }, [
                            segment.data
                        ]);
                    }), transmuxer.on("done", function(data) {
                        self1.postMessage({
                            action: "done"
                        });
                    }), transmuxer.on("gopInfo", function(gopInfo) {
                        self1.postMessage({
                            action: "gopInfo",
                            gopInfo: gopInfo
                        });
                    }), transmuxer.on("videoSegmentTimingInfo", function(timingInfo) {
                        var videoSegmentTimingInfo = {
                            start: {
                                decode: clock.videoTsToSeconds(timingInfo.start.dts),
                                presentation: clock.videoTsToSeconds(timingInfo.start.pts)
                            },
                            end: {
                                decode: clock.videoTsToSeconds(timingInfo.end.dts),
                                presentation: clock.videoTsToSeconds(timingInfo.end.pts)
                            },
                            baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
                        };
                        timingInfo.prependedContentDuration && (videoSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration)), self1.postMessage({
                            action: "videoSegmentTimingInfo",
                            videoSegmentTimingInfo: videoSegmentTimingInfo
                        });
                    }), transmuxer.on("audioSegmentTimingInfo", function(timingInfo) {
                        var audioSegmentTimingInfo = {
                            start: {
                                decode: clock.videoTsToSeconds(timingInfo.start.dts),
                                presentation: clock.videoTsToSeconds(timingInfo.start.pts)
                            },
                            end: {
                                decode: clock.videoTsToSeconds(timingInfo.end.dts),
                                presentation: clock.videoTsToSeconds(timingInfo.end.pts)
                            },
                            baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
                        };
                        timingInfo.prependedContentDuration && (audioSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration)), self1.postMessage({
                            action: "audioSegmentTimingInfo",
                            audioSegmentTimingInfo: audioSegmentTimingInfo
                        });
                    }), transmuxer.on("id3Frame", function(id3Frame) {
                        self1.postMessage({
                            action: "id3Frame",
                            id3Frame: id3Frame
                        });
                    }), transmuxer.on("caption", function(caption) {
                        self1.postMessage({
                            action: "caption",
                            caption: caption
                        });
                    }), transmuxer.on("trackinfo", function(trackInfo) {
                        self1.postMessage({
                            action: "trackinfo",
                            trackInfo: trackInfo
                        });
                    }), transmuxer.on("audioTimingInfo", function(audioTimingInfo) {
                        self1.postMessage({
                            action: "audioTimingInfo",
                            audioTimingInfo: {
                                start: clock.videoTsToSeconds(audioTimingInfo.start),
                                end: clock.videoTsToSeconds(audioTimingInfo.end)
                            }
                        });
                    }), transmuxer.on("videoTimingInfo", function(videoTimingInfo) {
                        self1.postMessage({
                            action: "videoTimingInfo",
                            videoTimingInfo: {
                                start: clock.videoTsToSeconds(videoTimingInfo.start),
                                end: clock.videoTsToSeconds(videoTimingInfo.end)
                            }
                        });
                    }), transmuxer.on("log", function(log) {
                        self1.postMessage({
                            action: "log",
                            log: log
                        });
                    });
                }, MessageHandlers = function() {
                    function MessageHandlers(self1, options) {
                        this.options = options || {}, this.self = self1, this.init();
                    }
                    var _proto = MessageHandlers.prototype;
                    return _proto.init = function() {
                        this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new transmuxer.Transmuxer(this.options), wireTransmuxerEvents(this.self, this.transmuxer);
                    }, _proto.pushMp4Captions = function(data) {
                        this.captionParser || (this.captionParser = new captionParser(), this.captionParser.init());
                        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength), parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
                        this.self.postMessage({
                            action: "mp4Captions",
                            captions: parsed && parsed.captions || [],
                            logs: parsed && parsed.logs || [],
                            data: segment.buffer
                        }, [
                            segment.buffer
                        ]);
                    }, _proto.probeMp4StartTime = function(_ref) {
                        var timescales = _ref.timescales, data = _ref.data, startTime = probe$2.startTime(timescales, data);
                        this.self.postMessage({
                            action: "probeMp4StartTime",
                            startTime: startTime,
                            data: data
                        }, [
                            data.buffer
                        ]);
                    }, _proto.probeMp4Tracks = function(_ref2) {
                        var data = _ref2.data, tracks = probe$2.tracks(data);
                        this.self.postMessage({
                            action: "probeMp4Tracks",
                            tracks: tracks,
                            data: data
                        }, [
                            data.buffer
                        ]);
                    }, _proto.probeTs = function(_ref3) {
                        var data = _ref3.data, baseStartTime = _ref3.baseStartTime, tsStartTime = "number" != typeof baseStartTime || isNaN(baseStartTime) ? void 0 : baseStartTime * clock.ONE_SECOND_IN_TS, timeInfo = tsInspector.inspect(data, tsStartTime), result = null;
                        timeInfo && ((result = {
                            hasVideo: timeInfo.video && 2 === timeInfo.video.length || !1,
                            hasAudio: timeInfo.audio && 2 === timeInfo.audio.length || !1
                        }).hasVideo && (result.videoStart = timeInfo.video[0].ptsTime), result.hasAudio && (result.audioStart = timeInfo.audio[0].ptsTime)), this.self.postMessage({
                            action: "probeTs",
                            result: result,
                            data: data
                        }, [
                            data.buffer
                        ]);
                    }, _proto.clearAllMp4Captions = function() {
                        this.captionParser && this.captionParser.clearAllCaptions();
                    }, _proto.clearParsedMp4Captions = function() {
                        this.captionParser && this.captionParser.clearParsedCaptions();
                    }, _proto.push = function(data) {
                        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
                        this.transmuxer.push(segment);
                    }, _proto.reset = function() {
                        this.transmuxer.reset();
                    }, _proto.setTimestampOffset = function(data) {
                        var timestampOffset = data.timestampOffset || 0;
                        this.transmuxer.setBaseMediaDecodeTime(Math.round(clock.secondsToVideoTs(timestampOffset)));
                    }, _proto.setAudioAppendStart = function(data) {
                        this.transmuxer.setAudioAppendStart(Math.ceil(clock.secondsToVideoTs(data.appendStart)));
                    }, _proto.setRemux = function(data) {
                        this.transmuxer.setRemux(data.remux);
                    }, _proto.flush = function(data) {
                        this.transmuxer.flush(), self.postMessage({
                            action: "done",
                            type: "transmuxed"
                        });
                    }, _proto.endTimeline = function() {
                        this.transmuxer.endTimeline(), self.postMessage({
                            action: "endedtimeline",
                            type: "transmuxed"
                        });
                    }, _proto.alignGopsWith = function(data) {
                        this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
                    }, MessageHandlers;
                }();
                self.onmessage = function(event) {
                    if ("init" === event.data.action && event.data.options) {
                        this.messageHandlers = new MessageHandlers(self, event.data.options);
                        return;
                    }
                    this.messageHandlers || (this.messageHandlers = new MessageHandlers(self)), event.data && event.data.action && "init" !== event.data.action && this.messageHandlers[event.data.action] && this.messageHandlers[event.data.action](event.data);
                };
            }))), handleData_ = function(event, transmuxedData, callback) {
                var _event$data$segment = event.data.segment, type = _event$data$segment.type, initSegment = _event$data$segment.initSegment, captions = _event$data$segment.captions, captionStreams = _event$data$segment.captionStreams, metadata = _event$data$segment.metadata, videoFrameDtsTime = _event$data$segment.videoFrameDtsTime, videoFramePtsTime = _event$data$segment.videoFramePtsTime;
                transmuxedData.buffer.push({
                    captions: captions,
                    captionStreams: captionStreams,
                    metadata: metadata
                });
                var boxes = event.data.segment.boxes || {
                    data: event.data.segment.data
                }, result = {
                    type: type,
                    data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
                    initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
                };
                void 0 !== videoFrameDtsTime && (result.videoFrameDtsTime = videoFrameDtsTime), void 0 !== videoFramePtsTime && (result.videoFramePtsTime = videoFramePtsTime), callback(result);
            }, handleDone_ = function(_ref) {
                var transmuxedData = _ref.transmuxedData, callback = _ref.callback;
                transmuxedData.buffer = [], callback(transmuxedData);
            }, handleGopInfo_ = function(event, transmuxedData) {
                transmuxedData.gopInfo = event.data.gopInfo;
            }, processTransmux = function(options) {
                var transmuxer = options.transmuxer, bytes = options.bytes, audioAppendStart = options.audioAppendStart, gopsToAlignWith = options.gopsToAlignWith, remux = options.remux, onData = options.onData, onTrackInfo = options.onTrackInfo, onAudioTimingInfo = options.onAudioTimingInfo, onVideoTimingInfo = options.onVideoTimingInfo, onVideoSegmentTimingInfo = options.onVideoSegmentTimingInfo, onAudioSegmentTimingInfo = options.onAudioSegmentTimingInfo, onId3 = options.onId3, onCaptions = options.onCaptions, onDone = options.onDone, onEndedTimeline = options.onEndedTimeline, onTransmuxerLog = options.onTransmuxerLog, isEndOfTimeline = options.isEndOfTimeline, transmuxedData = {
                    buffer: []
                }, waitForEndedTimelineEvent = isEndOfTimeline;
                if (transmuxer.onmessage = function(event) {
                    transmuxer.currentTransmux === options && ("data" === event.data.action && handleData_(event, transmuxedData, onData), "trackinfo" === event.data.action && onTrackInfo(event.data.trackInfo), "gopInfo" === event.data.action && handleGopInfo_(event, transmuxedData), "audioTimingInfo" === event.data.action && onAudioTimingInfo(event.data.audioTimingInfo), "videoTimingInfo" === event.data.action && onVideoTimingInfo(event.data.videoTimingInfo), "videoSegmentTimingInfo" === event.data.action && onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo), "audioSegmentTimingInfo" === event.data.action && onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo), "id3Frame" === event.data.action && onId3([
                        event.data.id3Frame
                    ], event.data.id3Frame.dispatchType), "caption" === event.data.action && onCaptions(event.data.caption), "endedtimeline" === event.data.action && (waitForEndedTimelineEvent = !1, onEndedTimeline()), "log" === event.data.action && onTransmuxerLog(event.data.log), "transmuxed" !== event.data.type || waitForEndedTimelineEvent || (transmuxer.onmessage = null, handleDone_({
                        transmuxedData: transmuxedData,
                        callback: onDone
                    }), dequeue(transmuxer)));
                }, audioAppendStart && transmuxer.postMessage({
                    action: "setAudioAppendStart",
                    appendStart: audioAppendStart
                }), Array.isArray(gopsToAlignWith) && transmuxer.postMessage({
                    action: "alignGopsWith",
                    gopsToAlignWith: gopsToAlignWith
                }), void 0 !== remux && transmuxer.postMessage({
                    action: "setRemux",
                    remux: remux
                }), bytes.byteLength) {
                    var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer, byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
                    transmuxer.postMessage({
                        action: "push",
                        data: buffer,
                        byteOffset: byteOffset,
                        byteLength: bytes.byteLength
                    }, [
                        buffer
                    ]);
                }
                isEndOfTimeline && transmuxer.postMessage({
                    action: "endTimeline"
                }), transmuxer.postMessage({
                    action: "flush"
                });
            }, dequeue = function(transmuxer) {
                transmuxer.currentTransmux = null, transmuxer.transmuxQueue.length && (transmuxer.currentTransmux = transmuxer.transmuxQueue.shift(), "function" == typeof transmuxer.currentTransmux ? transmuxer.currentTransmux() : processTransmux(transmuxer.currentTransmux));
            }, processAction = function(transmuxer, action) {
                transmuxer.postMessage({
                    action: action
                }), dequeue(transmuxer);
            }, enqueueAction = function(action, transmuxer) {
                if (!transmuxer.currentTransmux) {
                    transmuxer.currentTransmux = action, processAction(transmuxer, action);
                    return;
                }
                transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
            }, transmux = function(options) {
                if (!options.transmuxer.currentTransmux) {
                    options.transmuxer.currentTransmux = options, processTransmux(options);
                    return;
                }
                options.transmuxer.transmuxQueue.push(options);
            }, segmentTransmuxer = {
                reset: function(transmuxer) {
                    enqueueAction("reset", transmuxer);
                },
                endTimeline: function(transmuxer) {
                    enqueueAction("endTimeline", transmuxer);
                },
                transmux: transmux,
                createTransmuxer: function(options) {
                    var transmuxer = new TransmuxWorker();
                    transmuxer.currentTransmux = null, transmuxer.transmuxQueue = [];
                    var term = transmuxer.terminate;
                    return transmuxer.terminate = function() {
                        return transmuxer.currentTransmux = null, transmuxer.transmuxQueue.length = 0, term.call(transmuxer);
                    }, transmuxer.postMessage({
                        action: "init",
                        options: options
                    }), transmuxer;
                }
            }, workerCallback = function(options) {
                var transmuxer = options.transmuxer, endAction = options.endAction || options.action, callback = options.callback, message = (0, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__.Z)({}, options, {
                    endAction: null,
                    transmuxer: null,
                    callback: null
                });
                if (transmuxer.addEventListener("message", function listenForEndEvent(event) {
                    event.data.action === endAction && (transmuxer.removeEventListener("message", listenForEndEvent), event.data.data && (event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength), options.data && (options.data = event.data.data)), callback(event.data));
                }), options.data) {
                    var isArrayBuffer = options.data instanceof ArrayBuffer;
                    message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset, message.byteLength = options.data.byteLength;
                    var transfers = [
                        isArrayBuffer ? options.data : options.data.buffer
                    ];
                    transmuxer.postMessage(message, transfers);
                } else transmuxer.postMessage(message);
            }, REQUEST_ERRORS = {
                FAILURE: 2,
                TIMEOUT: -101,
                ABORTED: -102
            }, abortAll = function(activeXhrs) {
                activeXhrs.forEach(function(xhr) {
                    xhr.abort();
                });
            }, getProgressStats = function(progressEvent) {
                var request = progressEvent.target, stats = {
                    bandwidth: 1 / 0,
                    bytesReceived: 0,
                    roundTripTime: Date.now() - request.requestTime || 0
                };
                return stats.bytesReceived = progressEvent.loaded, stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8000), stats;
            }, handleErrors = function(error, request) {
                return request.timedout ? {
                    status: request.status,
                    message: "HLS request timed-out at URL: " + request.uri,
                    code: REQUEST_ERRORS.TIMEOUT,
                    xhr: request
                } : request.aborted ? {
                    status: request.status,
                    message: "HLS request aborted at URL: " + request.uri,
                    code: REQUEST_ERRORS.ABORTED,
                    xhr: request
                } : error ? {
                    status: request.status,
                    message: "HLS request errored at URL: " + request.uri,
                    code: REQUEST_ERRORS.FAILURE,
                    xhr: request
                } : "arraybuffer" === request.responseType && 0 === request.response.byteLength ? {
                    status: request.status,
                    message: "Empty HLS response at URL: " + request.uri,
                    code: REQUEST_ERRORS.FAILURE,
                    xhr: request
                } : null;
            }, handleKeyResponse = function(segment, objects, finishProcessingFn) {
                return function(error, request) {
                    var response = request.response, errorObj = handleErrors(error, request);
                    if (errorObj) return finishProcessingFn(errorObj, segment);
                    if (16 !== response.byteLength) return finishProcessingFn({
                        status: request.status,
                        message: "Invalid HLS key at URL: " + request.uri,
                        code: REQUEST_ERRORS.FAILURE,
                        xhr: request
                    }, segment);
                    for(var view = new DataView(response), bytes = new Uint32Array([
                        view.getUint32(0),
                        view.getUint32(4),
                        view.getUint32(8),
                        view.getUint32(12)
                    ]), i = 0; i < objects.length; i++)objects[i].bytes = bytes;
                    return finishProcessingFn(null, segment);
                };
            }, parseInitSegment = function(segment, _callback) {
                var type = (0, _videojs_vhs_utils_es_containers__WEBPACK_IMPORTED_MODULE_12__.Xm)(segment.map.bytes);
                if ("mp4" !== type) return _callback({
                    internal: !0,
                    message: "Found unsupported " + (type || "unknown") + " container for initialization segment at URL: " + (segment.map.resolvedUri || segment.map.uri),
                    code: REQUEST_ERRORS.FAILURE
                });
                workerCallback({
                    action: "probeMp4Tracks",
                    data: segment.map.bytes,
                    transmuxer: segment.transmuxer,
                    callback: function(_ref) {
                        var tracks = _ref.tracks, data = _ref.data;
                        return segment.map.bytes = data, tracks.forEach(function(track) {
                            segment.map.tracks = segment.map.tracks || {}, !segment.map.tracks[track.type] && (segment.map.tracks[track.type] = track, "number" == typeof track.id && track.timescale && (segment.map.timescales = segment.map.timescales || {}, segment.map.timescales[track.id] = track.timescale));
                        }), _callback(null);
                    }
                });
            }, handleInitSegmentResponse = function(_ref2) {
                var segment = _ref2.segment, finishProcessingFn = _ref2.finishProcessingFn;
                return function(error, request) {
                    var errorObj = handleErrors(error, request);
                    if (errorObj) return finishProcessingFn(errorObj, segment);
                    var bytes = new Uint8Array(request.response);
                    if (segment.map.key) return segment.map.encryptedBytes = bytes, finishProcessingFn(null, segment);
                    segment.map.bytes = bytes, parseInitSegment(segment, function(parseError) {
                        if (parseError) return parseError.xhr = request, parseError.status = request.status, finishProcessingFn(parseError, segment);
                        finishProcessingFn(null, segment);
                    });
                };
            }, handleSegmentResponse = function(_ref3) {
                var segment = _ref3.segment, finishProcessingFn = _ref3.finishProcessingFn, responseType = _ref3.responseType;
                return function(error, request) {
                    var errorObj = handleErrors(error, request);
                    if (errorObj) return finishProcessingFn(errorObj, segment);
                    var newBytes = "arraybuffer" !== responseType && request.responseText ? stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0)) : request.response;
                    return segment.stats = {
                        bandwidth: request.bandwidth,
                        bytesReceived: request.bytesReceived || 0,
                        roundTripTime: request.roundTripTime || 0
                    }, segment.key ? segment.encryptedBytes = new Uint8Array(newBytes) : segment.bytes = new Uint8Array(newBytes), finishProcessingFn(null, segment);
                };
            }, transmuxAndNotify = function(_ref4) {
                var segment = _ref4.segment, bytes = _ref4.bytes, trackInfoFn = _ref4.trackInfoFn, timingInfoFn = _ref4.timingInfoFn, videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref4.audioSegmentTimingInfoFn, id3Fn = _ref4.id3Fn, captionsFn = _ref4.captionsFn, isEndOfTimeline = _ref4.isEndOfTimeline, endedTimelineFn = _ref4.endedTimelineFn, dataFn = _ref4.dataFn, doneFn = _ref4.doneFn, onTransmuxerLog = _ref4.onTransmuxerLog, fmp4Tracks = segment.map && segment.map.tracks || {}, isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video), audioStartFn = timingInfoFn.bind(null, segment, "audio", "start"), audioEndFn = timingInfoFn.bind(null, segment, "audio", "end"), videoStartFn = timingInfoFn.bind(null, segment, "video", "start"), videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
                workerCallback({
                    action: "probeTs",
                    transmuxer: segment.transmuxer,
                    data: bytes,
                    baseStartTime: segment.baseStartTime,
                    callback: function(data) {
                        segment.bytes = bytes = data.data;
                        var probeResult = data.result;
                        probeResult && (trackInfoFn(segment, {
                            hasAudio: probeResult.hasAudio,
                            hasVideo: probeResult.hasVideo,
                            isMuxed: isMuxed
                        }), trackInfoFn = null, probeResult.hasAudio && !isMuxed && audioStartFn(probeResult.audioStart), probeResult.hasVideo && videoStartFn(probeResult.videoStart), audioStartFn = null, videoStartFn = null), transmux({
                            bytes: bytes,
                            transmuxer: segment.transmuxer,
                            audioAppendStart: segment.audioAppendStart,
                            gopsToAlignWith: segment.gopsToAlignWith,
                            remux: isMuxed,
                            onData: function(result) {
                                result.type = "combined" === result.type ? "video" : result.type, dataFn(segment, result);
                            },
                            onTrackInfo: function(trackInfo) {
                                trackInfoFn && (isMuxed && (trackInfo.isMuxed = !0), trackInfoFn(segment, trackInfo));
                            },
                            onAudioTimingInfo: function(audioTimingInfo) {
                                audioStartFn && void 0 !== audioTimingInfo.start && (audioStartFn(audioTimingInfo.start), audioStartFn = null), audioEndFn && void 0 !== audioTimingInfo.end && audioEndFn(audioTimingInfo.end);
                            },
                            onVideoTimingInfo: function(videoTimingInfo) {
                                videoStartFn && void 0 !== videoTimingInfo.start && (videoStartFn(videoTimingInfo.start), videoStartFn = null), videoEndFn && void 0 !== videoTimingInfo.end && videoEndFn(videoTimingInfo.end);
                            },
                            onVideoSegmentTimingInfo: function(videoSegmentTimingInfo) {
                                videoSegmentTimingInfoFn(videoSegmentTimingInfo);
                            },
                            onAudioSegmentTimingInfo: function(audioSegmentTimingInfo) {
                                audioSegmentTimingInfoFn(audioSegmentTimingInfo);
                            },
                            onId3: function(id3Frames, dispatchType) {
                                id3Fn(segment, id3Frames, dispatchType);
                            },
                            onCaptions: function(captions) {
                                captionsFn(segment, [
                                    captions
                                ]);
                            },
                            isEndOfTimeline: isEndOfTimeline,
                            onEndedTimeline: function() {
                                endedTimelineFn();
                            },
                            onTransmuxerLog: onTransmuxerLog,
                            onDone: function(result) {
                                doneFn && (result.type = "combined" === result.type ? "video" : result.type, doneFn(null, segment, result));
                            }
                        });
                    }
                });
            }, handleSegmentBytes = function(_ref5) {
                var segment = _ref5.segment, bytes = _ref5.bytes, trackInfoFn = _ref5.trackInfoFn, timingInfoFn = _ref5.timingInfoFn, videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref5.audioSegmentTimingInfoFn, id3Fn = _ref5.id3Fn, captionsFn = _ref5.captionsFn, isEndOfTimeline = _ref5.isEndOfTimeline, endedTimelineFn = _ref5.endedTimelineFn, dataFn = _ref5.dataFn, doneFn = _ref5.doneFn, onTransmuxerLog = _ref5.onTransmuxerLog, bytesAsUint8Array = new Uint8Array(bytes);
                if ((0, _videojs_vhs_utils_es_containers__WEBPACK_IMPORTED_MODULE_12__.cz)(bytesAsUint8Array)) {
                    segment.isFmp4 = !0;
                    var tracks = segment.map.tracks, trackInfo = {
                        isFmp4: !0,
                        hasVideo: !!tracks.video,
                        hasAudio: !!tracks.audio
                    };
                    tracks.audio && tracks.audio.codec && "enca" !== tracks.audio.codec && (trackInfo.audioCodec = tracks.audio.codec), tracks.video && tracks.video.codec && "encv" !== tracks.video.codec && (trackInfo.videoCodec = tracks.video.codec), tracks.video && tracks.audio && (trackInfo.isMuxed = !0), trackInfoFn(segment, trackInfo);
                    var finishLoading = function(captions) {
                        dataFn(segment, {
                            data: bytesAsUint8Array,
                            type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
                        }), captions && captions.length && captionsFn(segment, captions), doneFn(null, segment, {});
                    };
                    workerCallback({
                        action: "probeMp4StartTime",
                        timescales: segment.map.timescales,
                        data: bytesAsUint8Array,
                        transmuxer: segment.transmuxer,
                        callback: function(_ref6) {
                            var data = _ref6.data, startTime = _ref6.startTime;
                            if (bytes = data.buffer, segment.bytes = bytesAsUint8Array = data, trackInfo.hasAudio && !trackInfo.isMuxed && timingInfoFn(segment, "audio", "start", startTime), trackInfo.hasVideo && timingInfoFn(segment, "video", "start", startTime), !tracks.video || !data.byteLength || !segment.transmuxer) {
                                finishLoading();
                                return;
                            }
                            workerCallback({
                                action: "pushMp4Captions",
                                endAction: "mp4Captions",
                                transmuxer: segment.transmuxer,
                                data: bytesAsUint8Array,
                                timescales: segment.map.timescales,
                                trackIds: [
                                    tracks.video.id
                                ],
                                callback: function(message) {
                                    bytes = message.data.buffer, segment.bytes = bytesAsUint8Array = message.data, message.logs.forEach(function(log) {
                                        onTransmuxerLog(videojs.mergeOptions(log, {
                                            stream: "mp4CaptionParser"
                                        }));
                                    }), finishLoading(message.captions);
                                }
                            });
                        }
                    });
                    return;
                }
                if (!segment.transmuxer) {
                    doneFn(null, segment, {});
                    return;
                }
                if (void 0 === segment.container && (segment.container = (0, _videojs_vhs_utils_es_containers__WEBPACK_IMPORTED_MODULE_12__.Xm)(bytesAsUint8Array)), "ts" !== segment.container && "aac" !== segment.container) {
                    trackInfoFn(segment, {
                        hasAudio: !1,
                        hasVideo: !1
                    }), doneFn(null, segment, {});
                    return;
                }
                transmuxAndNotify({
                    segment: segment,
                    bytes: bytes,
                    trackInfoFn: trackInfoFn,
                    timingInfoFn: timingInfoFn,
                    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
                    audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
                    id3Fn: id3Fn,
                    captionsFn: captionsFn,
                    isEndOfTimeline: isEndOfTimeline,
                    endedTimelineFn: endedTimelineFn,
                    dataFn: dataFn,
                    doneFn: doneFn,
                    onTransmuxerLog: onTransmuxerLog
                });
            }, decrypt = function(_ref7, callback) {
                var keyBytes, id = _ref7.id, key = _ref7.key, encryptedBytes = _ref7.encryptedBytes, decryptionWorker = _ref7.decryptionWorker;
                decryptionWorker.addEventListener("message", function decryptionHandler(event) {
                    if (event.data.source === id) {
                        decryptionWorker.removeEventListener("message", decryptionHandler);
                        var decrypted = event.data.decrypted;
                        callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
                    }
                }), keyBytes = key.bytes.slice ? key.bytes.slice() : new Uint32Array(Array.prototype.slice.call(key.bytes)), decryptionWorker.postMessage(createTransferableMessage({
                    source: id,
                    encrypted: encryptedBytes,
                    key: keyBytes,
                    iv: key.iv
                }), [
                    encryptedBytes.buffer,
                    keyBytes.buffer
                ]);
            }, decryptSegment = function(_ref8) {
                var decryptionWorker = _ref8.decryptionWorker, segment = _ref8.segment, trackInfoFn = _ref8.trackInfoFn, timingInfoFn = _ref8.timingInfoFn, videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref8.audioSegmentTimingInfoFn, id3Fn = _ref8.id3Fn, captionsFn = _ref8.captionsFn, isEndOfTimeline = _ref8.isEndOfTimeline, endedTimelineFn = _ref8.endedTimelineFn, dataFn = _ref8.dataFn, doneFn = _ref8.doneFn, onTransmuxerLog = _ref8.onTransmuxerLog;
                decrypt({
                    id: segment.requestId,
                    key: segment.key,
                    encryptedBytes: segment.encryptedBytes,
                    decryptionWorker: decryptionWorker
                }, function(decryptedBytes) {
                    segment.bytes = decryptedBytes, handleSegmentBytes({
                        segment: segment,
                        bytes: segment.bytes,
                        trackInfoFn: trackInfoFn,
                        timingInfoFn: timingInfoFn,
                        videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
                        audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
                        id3Fn: id3Fn,
                        captionsFn: captionsFn,
                        isEndOfTimeline: isEndOfTimeline,
                        endedTimelineFn: endedTimelineFn,
                        dataFn: dataFn,
                        doneFn: doneFn,
                        onTransmuxerLog: onTransmuxerLog
                    });
                });
            }, waitForCompletion = function(_ref9) {
                var activeXhrs = _ref9.activeXhrs, decryptionWorker = _ref9.decryptionWorker, trackInfoFn = _ref9.trackInfoFn, timingInfoFn = _ref9.timingInfoFn, videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref9.audioSegmentTimingInfoFn, id3Fn = _ref9.id3Fn, captionsFn = _ref9.captionsFn, isEndOfTimeline = _ref9.isEndOfTimeline, endedTimelineFn = _ref9.endedTimelineFn, dataFn = _ref9.dataFn, doneFn = _ref9.doneFn, onTransmuxerLog = _ref9.onTransmuxerLog, count = 0, didError = !1;
                return function(error, segment) {
                    if (!didError) {
                        if (error) return didError = !0, abortAll(activeXhrs), doneFn(error, segment);
                        if ((count += 1) === activeXhrs.length) {
                            var segmentFinish = function() {
                                if (segment.encryptedBytes) return decryptSegment({
                                    decryptionWorker: decryptionWorker,
                                    segment: segment,
                                    trackInfoFn: trackInfoFn,
                                    timingInfoFn: timingInfoFn,
                                    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
                                    audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
                                    id3Fn: id3Fn,
                                    captionsFn: captionsFn,
                                    isEndOfTimeline: isEndOfTimeline,
                                    endedTimelineFn: endedTimelineFn,
                                    dataFn: dataFn,
                                    doneFn: doneFn,
                                    onTransmuxerLog: onTransmuxerLog
                                });
                                handleSegmentBytes({
                                    segment: segment,
                                    bytes: segment.bytes,
                                    trackInfoFn: trackInfoFn,
                                    timingInfoFn: timingInfoFn,
                                    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
                                    audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
                                    id3Fn: id3Fn,
                                    captionsFn: captionsFn,
                                    isEndOfTimeline: isEndOfTimeline,
                                    endedTimelineFn: endedTimelineFn,
                                    dataFn: dataFn,
                                    doneFn: doneFn,
                                    onTransmuxerLog: onTransmuxerLog
                                });
                            };
                            if (segment.endOfAllRequests = Date.now(), segment.map && segment.map.encryptedBytes && !segment.map.bytes) return decrypt({
                                decryptionWorker: decryptionWorker,
                                id: segment.requestId + "-init",
                                encryptedBytes: segment.map.encryptedBytes,
                                key: segment.map.key
                            }, function(decryptedBytes) {
                                segment.map.bytes = decryptedBytes, parseInitSegment(segment, function(parseError) {
                                    if (parseError) return abortAll(activeXhrs), doneFn(parseError, segment);
                                    segmentFinish();
                                });
                            });
                            segmentFinish();
                        }
                    }
                };
            }, handleLoadEnd = function(_ref10) {
                var loadendState = _ref10.loadendState, abortFn = _ref10.abortFn;
                return function(event) {
                    event.target.aborted && abortFn && !loadendState.calledAbortFn && (abortFn(), loadendState.calledAbortFn = !0);
                };
            }, handleProgress = function(_ref11) {
                var segment = _ref11.segment, progressFn = _ref11.progressFn;
                return _ref11.trackInfoFn, _ref11.timingInfoFn, _ref11.videoSegmentTimingInfoFn, _ref11.audioSegmentTimingInfoFn, _ref11.id3Fn, _ref11.captionsFn, _ref11.isEndOfTimeline, _ref11.endedTimelineFn, _ref11.dataFn, function(event) {
                    if (!event.target.aborted) return segment.stats = videojs.mergeOptions(segment.stats, getProgressStats(event)), !segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived && (segment.stats.firstBytesReceivedAt = Date.now()), progressFn(event, segment);
                };
            }, mediaSegmentRequest = function(_ref12) {
                var xhr = _ref12.xhr, xhrOptions = _ref12.xhrOptions, decryptionWorker = _ref12.decryptionWorker, segment = _ref12.segment, abortFn = _ref12.abortFn, progressFn = _ref12.progressFn, trackInfoFn = _ref12.trackInfoFn, timingInfoFn = _ref12.timingInfoFn, videoSegmentTimingInfoFn = _ref12.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref12.audioSegmentTimingInfoFn, id3Fn = _ref12.id3Fn, captionsFn = _ref12.captionsFn, isEndOfTimeline = _ref12.isEndOfTimeline, endedTimelineFn = _ref12.endedTimelineFn, dataFn = _ref12.dataFn, doneFn = _ref12.doneFn, onTransmuxerLog = _ref12.onTransmuxerLog, activeXhrs = [], finishProcessingFn = waitForCompletion({
                    activeXhrs: activeXhrs,
                    decryptionWorker: decryptionWorker,
                    trackInfoFn: trackInfoFn,
                    timingInfoFn: timingInfoFn,
                    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
                    audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
                    id3Fn: id3Fn,
                    captionsFn: captionsFn,
                    isEndOfTimeline: isEndOfTimeline,
                    endedTimelineFn: endedTimelineFn,
                    dataFn: dataFn,
                    doneFn: doneFn,
                    onTransmuxerLog: onTransmuxerLog
                });
                if (segment.key && !segment.key.bytes) {
                    var objects = [
                        segment.key
                    ];
                    segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri && objects.push(segment.map.key);
                    var keyRequestOptions = videojs.mergeOptions(xhrOptions, {
                        uri: segment.key.resolvedUri,
                        responseType: "arraybuffer"
                    }), keyXhr = xhr(keyRequestOptions, handleKeyResponse(segment, objects, finishProcessingFn));
                    activeXhrs.push(keyXhr);
                }
                if (segment.map && !segment.map.bytes) {
                    if (segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri)) {
                        var mapKeyRequestOptions = videojs.mergeOptions(xhrOptions, {
                            uri: segment.map.key.resolvedUri,
                            responseType: "arraybuffer"
                        }), mapKeyXhr = xhr(mapKeyRequestOptions, handleKeyResponse(segment, [
                            segment.map.key
                        ], finishProcessingFn));
                        activeXhrs.push(mapKeyXhr);
                    }
                    var initSegmentOptions = videojs.mergeOptions(xhrOptions, {
                        uri: segment.map.resolvedUri,
                        responseType: "arraybuffer",
                        headers: segmentXhrHeaders(segment.map)
                    }), initSegmentXhr = xhr(initSegmentOptions, handleInitSegmentResponse({
                        segment: segment,
                        finishProcessingFn: finishProcessingFn
                    }));
                    activeXhrs.push(initSegmentXhr);
                }
                var segmentRequestOptions = videojs.mergeOptions(xhrOptions, {
                    uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
                    responseType: "arraybuffer",
                    headers: segmentXhrHeaders(segment)
                }), segmentRequestCallback = handleSegmentResponse({
                    segment: segment,
                    finishProcessingFn: finishProcessingFn,
                    responseType: segmentRequestOptions.responseType
                }), segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
                segmentXhr.addEventListener("progress", handleProgress({
                    segment: segment,
                    progressFn: progressFn,
                    trackInfoFn: trackInfoFn,
                    timingInfoFn: timingInfoFn,
                    videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
                    audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
                    id3Fn: id3Fn,
                    captionsFn: captionsFn,
                    isEndOfTimeline: isEndOfTimeline,
                    endedTimelineFn: endedTimelineFn,
                    dataFn: dataFn
                })), activeXhrs.push(segmentXhr);
                var loadendState = {};
                return activeXhrs.forEach(function(activeXhr) {
                    activeXhr.addEventListener("loadend", handleLoadEnd({
                        loadendState: loadendState,
                        abortFn: abortFn
                    }));
                }), function() {
                    return abortAll(activeXhrs);
                };
            }, logFn$1 = logger("CodecUtils"), getCodecs = function(media) {
                var mediaAttributes = media.attributes || {};
                if (mediaAttributes.CODECS) return (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(mediaAttributes.CODECS);
            }, isMaat = function(master, media) {
                var mediaAttributes = media.attributes || {};
                return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
            }, isMuxed = function(master, media) {
                if (!isMaat(master, media)) return !0;
                var mediaAttributes = media.attributes || {}, audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
                for(var groupId in audioGroup)if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) return !0;
                return !1;
            }, unwrapCodecList = function(codecList) {
                var codecs = {};
                return codecList.forEach(function(_ref) {
                    var mediaType = _ref.mediaType, type = _ref.type, details = _ref.details;
                    codecs[mediaType] = codecs[mediaType] || [], codecs[mediaType].push((0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.ws)("" + type + details));
                }), Object.keys(codecs).forEach(function(mediaType) {
                    if (codecs[mediaType].length > 1) {
                        logFn$1("multiple " + mediaType + " codecs found as attributes: " + codecs[mediaType].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs."), codecs[mediaType] = null;
                        return;
                    }
                    codecs[mediaType] = codecs[mediaType][0];
                }), codecs;
            }, codecCount = function(codecObj) {
                var count = 0;
                return codecObj.audio && count++, codecObj.video && count++, count;
            }, codecsForPlaylist = function(master, media) {
                var mediaAttributes = media.attributes || {}, codecInfo = unwrapCodecList(getCodecs(media) || []);
                if (isMaat(master, media) && !codecInfo.audio && !isMuxed(master, media)) {
                    var defaultCodecs = unwrapCodecList((0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.Jg)(master, mediaAttributes.AUDIO) || []);
                    defaultCodecs.audio && (codecInfo.audio = defaultCodecs.audio);
                }
                return codecInfo;
            }, logFn = logger("PlaylistSelector"), representationToString = function(representation) {
                if (representation && representation.playlist) {
                    var playlist = representation.playlist;
                    return JSON.stringify({
                        id: playlist.id,
                        bandwidth: representation.bandwidth,
                        width: representation.width,
                        height: representation.height,
                        codecs: playlist.attributes && playlist.attributes.CODECS || ""
                    });
                }
            }, safeGetComputedStyle = function(el, property) {
                if (!el) return "";
                var result = global_window__WEBPACK_IMPORTED_MODULE_0___default().getComputedStyle(el);
                return result ? result[property] : "";
            }, stableSort = function(array, sortFn) {
                var newArray = array.slice();
                array.sort(function(left, right) {
                    var cmp = sortFn(left, right);
                    return 0 === cmp ? newArray.indexOf(left) - newArray.indexOf(right) : cmp;
                });
            }, comparePlaylistBandwidth = function(left, right) {
                var leftBandwidth, rightBandwidth;
                return left.attributes.BANDWIDTH && (leftBandwidth = left.attributes.BANDWIDTH), leftBandwidth = leftBandwidth || global_window__WEBPACK_IMPORTED_MODULE_0___default().Number.MAX_VALUE, right.attributes.BANDWIDTH && (rightBandwidth = right.attributes.BANDWIDTH), leftBandwidth - (rightBandwidth = rightBandwidth || global_window__WEBPACK_IMPORTED_MODULE_0___default().Number.MAX_VALUE);
            }, simpleSelector = function(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, masterPlaylistController) {
                if (master) {
                    var resolutionPlusOneList, resolutionPlusOneSmallest, resolutionPlusOneRep, leastPixelDiffRep, options = {
                        bandwidth: playerBandwidth,
                        width: playerWidth,
                        height: playerHeight,
                        limitRenditionByPlayerDimensions: limitRenditionByPlayerDimensions
                    }, playlists = master.playlists;
                    Playlist.isAudioOnly(master) && (playlists = masterPlaylistController.getAudioTrackPlaylists_(), options.audioOnly = !0);
                    var sortedPlaylistReps = playlists.map(function(playlist) {
                        var width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width, height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
                        return {
                            bandwidth: playlist.attributes && playlist.attributes.BANDWIDTH || global_window__WEBPACK_IMPORTED_MODULE_0___default().Number.MAX_VALUE,
                            width: width,
                            height: height,
                            playlist: playlist
                        };
                    });
                    stableSort(sortedPlaylistReps, function(left, right) {
                        return left.bandwidth - right.bandwidth;
                    });
                    var enabledPlaylistReps = (sortedPlaylistReps = sortedPlaylistReps.filter(function(rep) {
                        return !Playlist.isIncompatible(rep.playlist);
                    })).filter(function(rep) {
                        return Playlist.isEnabled(rep.playlist);
                    });
                    enabledPlaylistReps.length || (enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
                        return !Playlist.isDisabled(rep.playlist);
                    }));
                    var bandwidthPlaylistReps = enabledPlaylistReps.filter(function(rep) {
                        return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;
                    }), highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1], bandwidthBestRep = bandwidthPlaylistReps.filter(function(rep) {
                        return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
                    })[0];
                    if (!1 === limitRenditionByPlayerDimensions) {
                        var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
                        if (_chosenRep && _chosenRep.playlist) {
                            var type = "sortedPlaylistReps";
                            return bandwidthBestRep && (type = "bandwidthBestRep"), enabledPlaylistReps[0] && (type = "enabledPlaylistReps"), logFn("choosing " + representationToString(_chosenRep) + " using " + type + " with options", options), _chosenRep.playlist;
                        }
                        return logFn("could not choose a playlist with options", options), null;
                    }
                    var haveResolution = bandwidthPlaylistReps.filter(function(rep) {
                        return rep.width && rep.height;
                    });
                    stableSort(haveResolution, function(left, right) {
                        return left.width - right.width;
                    });
                    var resolutionBestRepList = haveResolution.filter(function(rep) {
                        return rep.width === playerWidth && rep.height === playerHeight;
                    });
                    highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
                    var resolutionBestRep = resolutionBestRepList.filter(function(rep) {
                        return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
                    })[0];
                    if (resolutionBestRep || (highestRemainingBandwidthRep = (resolutionPlusOneSmallest = (resolutionPlusOneList = haveResolution.filter(function(rep) {
                        return rep.width > playerWidth || rep.height > playerHeight;
                    })).filter(function(rep) {
                        return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;
                    }))[resolutionPlusOneSmallest.length - 1], resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function(rep) {
                        return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
                    })[0]), masterPlaylistController.experimentalLeastPixelDiffSelector) {
                        var leastPixelDiffList = haveResolution.map(function(rep) {
                            return rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight), rep;
                        });
                        stableSort(leastPixelDiffList, function(left, right) {
                            return left.pixelDiff === right.pixelDiff ? right.bandwidth - left.bandwidth : left.pixelDiff - right.pixelDiff;
                        }), leastPixelDiffRep = leastPixelDiffList[0];
                    }
                    var chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
                    if (chosenRep && chosenRep.playlist) {
                        var _type = "sortedPlaylistReps";
                        return leastPixelDiffRep ? _type = "leastPixelDiffRep" : resolutionPlusOneRep ? _type = "resolutionPlusOneRep" : resolutionBestRep ? _type = "resolutionBestRep" : bandwidthBestRep ? _type = "bandwidthBestRep" : enabledPlaylistReps[0] && (_type = "enabledPlaylistReps"), logFn("choosing " + representationToString(chosenRep) + " using " + _type + " with options", options), chosenRep.playlist;
                    }
                    return logFn("could not choose a playlist with options", options), null;
                }
            }, lastBandwidthSelector = function() {
                var pixelRatio = this.useDevicePixelRatio && global_window__WEBPACK_IMPORTED_MODULE_0___default().devicePixelRatio || 1;
                return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
            }, minRebufferMaxBandwidthSelector = function(settings) {
                var master = settings.master, currentTime = settings.currentTime, bandwidth = settings.bandwidth, duration = settings.duration, segmentDuration = settings.segmentDuration, timeUntilRebuffer = settings.timeUntilRebuffer, currentTimeline = settings.currentTimeline, syncController = settings.syncController, compatiblePlaylists = master.playlists.filter(function(playlist) {
                    return !Playlist.isIncompatible(playlist);
                }), enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
                enabledPlaylists.length || (enabledPlaylists = compatiblePlaylists.filter(function(playlist) {
                    return !Playlist.isDisabled(playlist);
                }));
                var rebufferingEstimates = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, "BANDWIDTH")).map(function(playlist) {
                    var syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime), requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);
                    return {
                        playlist: playlist,
                        rebufferingImpact: requestTimeEstimate * (syncPoint ? 1 : 2) - timeUntilRebuffer
                    };
                }), noRebufferingPlaylists = rebufferingEstimates.filter(function(estimate) {
                    return estimate.rebufferingImpact <= 0;
                });
                return (stableSort(noRebufferingPlaylists, function(a, b) {
                    return comparePlaylistBandwidth(b.playlist, a.playlist);
                }), noRebufferingPlaylists.length) ? noRebufferingPlaylists[0] : (stableSort(rebufferingEstimates, function(a, b) {
                    return a.rebufferingImpact - b.rebufferingImpact;
                }), rebufferingEstimates[0] || null);
            }, concatSegments = function(segmentObj) {
                var tempBuffer, offset = 0;
                return segmentObj.bytes && (tempBuffer = new Uint8Array(segmentObj.bytes), segmentObj.segments.forEach(function(segment) {
                    tempBuffer.set(segment, offset), offset += segment.byteLength;
                })), tempBuffer;
            }, createCaptionsTrackIfNotExists = function(inbandTextTracks, tech, captionStream) {
                if (!inbandTextTracks[captionStream]) {
                    tech.trigger({
                        type: "usage",
                        name: "vhs-608"
                    }), tech.trigger({
                        type: "usage",
                        name: "hls-608"
                    });
                    var instreamId = captionStream;
                    /^cc708_/.test(captionStream) && (instreamId = "SERVICE" + captionStream.split("_")[1]);
                    var track = tech.textTracks().getTrackById(instreamId);
                    if (track) inbandTextTracks[captionStream] = track;
                    else {
                        var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {}, label = captionStream, language = captionStream, def = !1, captionService = captionServices[instreamId];
                        captionService && (label = captionService.label, language = captionService.language, def = captionService.default), inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
                            kind: "captions",
                            id: instreamId,
                            default: def,
                            label: label,
                            language: language
                        }, !1).track;
                    }
                }
            }, addCaptionData = function(_ref) {
                var inbandTextTracks = _ref.inbandTextTracks, captionArray = _ref.captionArray, timestampOffset = _ref.timestampOffset;
                if (captionArray) {
                    var Cue = global_window__WEBPACK_IMPORTED_MODULE_0___default().WebKitDataCue || global_window__WEBPACK_IMPORTED_MODULE_0___default().VTTCue;
                    captionArray.forEach(function(caption) {
                        inbandTextTracks[caption.stream].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));
                    });
                }
            }, deprecateOldCue = function(cue) {
                Object.defineProperties(cue.frame, {
                    id: {
                        get: function() {
                            return videojs.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), cue.value.key;
                        }
                    },
                    value: {
                        get: function() {
                            return videojs.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), cue.value.data;
                        }
                    },
                    privateData: {
                        get: function() {
                            return videojs.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), cue.value.data;
                        }
                    }
                });
            }, addMetadata = function(_ref2) {
                var inbandTextTracks = _ref2.inbandTextTracks, metadataArray = _ref2.metadataArray, timestampOffset = _ref2.timestampOffset, videoDuration = _ref2.videoDuration;
                if (metadataArray) {
                    var Cue = global_window__WEBPACK_IMPORTED_MODULE_0___default().WebKitDataCue || global_window__WEBPACK_IMPORTED_MODULE_0___default().VTTCue, metadataTrack = inbandTextTracks.metadataTrack_;
                    if (metadataTrack && (metadataArray.forEach(function(metadata) {
                        var time = metadata.cueTime + timestampOffset;
                        "number" != typeof time || global_window__WEBPACK_IMPORTED_MODULE_0___default().isNaN(time) || time < 0 || !(time < 1 / 0) || metadata.frames.forEach(function(frame) {
                            var cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
                            cue.frame = frame, cue.value = frame, deprecateOldCue(cue), metadataTrack.addCue(cue);
                        });
                    }), metadataTrack.cues && metadataTrack.cues.length)) {
                        for(var cues = metadataTrack.cues, cuesArray = [], i = 0; i < cues.length; i++)cues[i] && cuesArray.push(cues[i]);
                        var cuesGroupedByStartTime = cuesArray.reduce(function(obj, cue) {
                            var timeSlot = obj[cue.startTime] || [];
                            return timeSlot.push(cue), obj[cue.startTime] = timeSlot, obj;
                        }, {}), sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function(a, b) {
                            return Number(a) - Number(b);
                        });
                        sortedStartTimes.forEach(function(startTime, idx) {
                            var cueGroup = cuesGroupedByStartTime[startTime], nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;
                            cueGroup.forEach(function(cue) {
                                cue.endTime = nextTime;
                            });
                        });
                    }
                }
            }, createMetadataTrackIfNotExists = function(inbandTextTracks, dispatchType, tech) {
                inbandTextTracks.metadataTrack_ || (inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
                    kind: "metadata",
                    label: "Timed Metadata"
                }, !1).track, inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType);
            }, removeCuesFromTrack = function(start, end, track) {
                var i, cue;
                if (track && track.cues) for(i = track.cues.length; i--;)(cue = track.cues[i]).startTime >= start && cue.endTime <= end && track.removeCue(cue);
            }, removeDuplicateCuesFromTrack = function(track) {
                var cues = track.cues;
                if (cues) for(var i = 0; i < cues.length; i++){
                    for(var duplicates = [], occurrences = 0, j = 0; j < cues.length; j++)cues[i].startTime === cues[j].startTime && cues[i].endTime === cues[j].endTime && cues[i].text === cues[j].text && ++occurrences > 1 && duplicates.push(cues[j]);
                    duplicates.length && duplicates.forEach(function(dupe) {
                        return track.removeCue(dupe);
                    });
                }
            }, gopsSafeToAlignWith = function(buffer, currentTime, mapping) {
                if (null == currentTime || !buffer.length) return [];
                var i, currentTimePts = Math.ceil((currentTime - mapping + 3) * mux_js_lib_utils_clock__WEBPACK_IMPORTED_MODULE_14__.ONE_SECOND_IN_TS);
                for(i = 0; i < buffer.length && !(buffer[i].pts > currentTimePts); i++);
                return buffer.slice(i);
            }, updateGopBuffer = function(buffer, gops, replace) {
                if (!gops.length) return buffer;
                if (replace) return gops.slice();
                for(var start = gops[0].pts, i = 0; i < buffer.length && !(buffer[i].pts >= start); i++);
                return buffer.slice(0, i).concat(gops);
            }, removeGopBuffer = function(buffer, start, end, mapping) {
                for(var startPts = Math.ceil((start - mapping) * mux_js_lib_utils_clock__WEBPACK_IMPORTED_MODULE_14__.ONE_SECOND_IN_TS), endPts = Math.ceil((end - mapping) * mux_js_lib_utils_clock__WEBPACK_IMPORTED_MODULE_14__.ONE_SECOND_IN_TS), updatedBuffer = buffer.slice(), i = buffer.length; i-- && !(buffer[i].pts <= endPts););
                if (-1 === i) return updatedBuffer;
                for(var j = i + 1; j-- && !(buffer[j].pts <= startPts););
                return j = Math.max(j, 0), updatedBuffer.splice(j, i - j + 1), updatedBuffer;
            }, shallowEqual = function(a, b) {
                if (!a && !b || !a && b || a && !b) return !1;
                if (a === b) return !0;
                var akeys = Object.keys(a).sort(), bkeys = Object.keys(b).sort();
                if (akeys.length !== bkeys.length) return !1;
                for(var i = 0; i < akeys.length; i++){
                    var key = akeys[i];
                    if (key !== bkeys[i] || a[key] !== b[key]) return !1;
                }
                return !0;
            }, getSyncSegmentCandidate = function(currentTimeline, segments, targetTime) {
                segments = segments || [];
                for(var timelineSegments = [], time = 0, i = 0; i < segments.length; i++){
                    var segment = segments[i];
                    if (currentTimeline === segment.timeline && (timelineSegments.push(i), (time += segment.duration) > targetTime)) return i;
                }
                return 0 === timelineSegments.length ? 0 : timelineSegments[timelineSegments.length - 1];
            }, finite = function(num) {
                return "number" == typeof num && isFinite(num);
            }, MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60, safeBackBufferTrimTime = function(seekable, currentTime, targetDuration) {
                var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
                return seekable.length && (trimTime = Math.max(trimTime, seekable.start(0))), Math.min(currentTime - targetDuration, trimTime);
            }, segmentInfoString = function(segmentInfo) {
                var startOfSegment = segmentInfo.startOfSegment, duration = segmentInfo.duration, segment = segmentInfo.segment, part = segmentInfo.part, _segmentInfo$playlist = segmentInfo.playlist, seq = _segmentInfo$playlist.mediaSequence, id = _segmentInfo$playlist.id, _segmentInfo$playlist2 = _segmentInfo$playlist.segments, index = segmentInfo.mediaIndex, partIndex = segmentInfo.partIndex, timeline = segmentInfo.timeline, segmentLen = (void 0 === _segmentInfo$playlist2 ? [] : _segmentInfo$playlist2).length - 1, selection = "mediaIndex/partIndex increment";
                segmentInfo.getMediaInfoForTime ? selection = "getMediaInfoForTime (" + segmentInfo.getMediaInfoForTime + ")" : segmentInfo.isSyncRequest && (selection = "getSyncSegmentCandidate (isSyncRequest)"), segmentInfo.independent && (selection += " with independent " + segmentInfo.independent);
                var hasPartIndex = "number" == typeof partIndex, name = segmentInfo.segment.uri ? "segment" : "pre-segment", zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
                    preloadSegment: segment
                }) - 1 : 0;
                return name + " [" + (seq + index) + "/" + (seq + segmentLen) + "]" + (hasPartIndex ? " part [" + partIndex + "/" + zeroBasedPartCount + "]" : "") + " segment start/end [" + segment.start + " => " + segment.end + "]" + (hasPartIndex ? " part start/end [" + part.start + " => " + part.end + "]" : "") + " startOfSegment [" + startOfSegment + "] duration [" + duration + "] timeline [" + timeline + "] selected by [" + selection + "] playlist [" + id + "]";
            }, timingInfoPropertyForMedia = function(mediaType) {
                return mediaType + "TimingInfo";
            }, timestampOffsetForSegment = function(_ref) {
                var segmentTimeline = _ref.segmentTimeline, currentTimeline = _ref.currentTimeline, startOfSegment = _ref.startOfSegment, buffered = _ref.buffered;
                return _ref.overrideCheck || segmentTimeline !== currentTimeline ? segmentTimeline < currentTimeline ? startOfSegment : buffered.length ? buffered.end(buffered.length - 1) : startOfSegment : null;
            }, shouldWaitForTimelineChange = function(_ref2) {
                var timelineChangeController = _ref2.timelineChangeController, currentTimeline = _ref2.currentTimeline, segmentTimeline = _ref2.segmentTimeline, loaderType = _ref2.loaderType, audioDisabled = _ref2.audioDisabled;
                if (currentTimeline === segmentTimeline) return !1;
                if ("audio" === loaderType) {
                    var lastMainTimelineChange = timelineChangeController.lastTimelineChange({
                        type: "main"
                    });
                    return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
                }
                if ("main" === loaderType && audioDisabled) {
                    var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
                        type: "audio"
                    });
                    return !pendingAudioTimelineChange || pendingAudioTimelineChange.to !== segmentTimeline;
                }
                return !1;
            }, segmentTooLong = function(_ref3) {
                var segmentDuration = _ref3.segmentDuration, maxDuration = _ref3.maxDuration;
                return !!segmentDuration && Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
            }, getTroublesomeSegmentDurationMessage = function(segmentInfo, sourceType) {
                if ("hls" !== sourceType) return null;
                var audioTimingInfo, videoTimingInfo, segmentDuration = (audioTimingInfo = segmentInfo.audioTimingInfo, videoTimingInfo = segmentInfo.videoTimingInfo, Math.max(audioTimingInfo && "number" == typeof audioTimingInfo.start && "number" == typeof audioTimingInfo.end ? audioTimingInfo.end - audioTimingInfo.start : 0, videoTimingInfo && "number" == typeof videoTimingInfo.start && "number" == typeof videoTimingInfo.end ? videoTimingInfo.end - videoTimingInfo.start : 0));
                if (!segmentDuration) return null;
                var targetDuration = segmentInfo.playlist.targetDuration, isSegmentWayTooLong = segmentTooLong({
                    segmentDuration: segmentDuration,
                    maxDuration: 2 * targetDuration
                }), isSegmentSlightlyTooLong = segmentTooLong({
                    segmentDuration: segmentDuration,
                    maxDuration: targetDuration
                }), segmentTooLongMessage = "Segment with index " + segmentInfo.mediaIndex + " from playlist " + segmentInfo.playlist.id + " has a duration of " + segmentDuration + " when the reported duration is " + segmentInfo.duration + " and the target duration is " + targetDuration + ". For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
                return isSegmentWayTooLong || isSegmentSlightlyTooLong ? {
                    severity: isSegmentWayTooLong ? "warn" : "info",
                    message: segmentTooLongMessage
                } : null;
            }, SegmentLoader = function(_videojs$EventTarget) {
                function SegmentLoader(settings, options) {
                    var _this;
                    if (_this = _videojs$EventTarget.call(this) || this, !settings) throw TypeError("Initialization settings are required");
                    if ("function" != typeof settings.currentTime) throw TypeError("No currentTime getter specified");
                    if (!settings.mediaSource) throw TypeError("No MediaSource specified");
                    return _this.bandwidth = settings.bandwidth, _this.throughput = {
                        rate: 0,
                        count: 0
                    }, _this.roundTrip = NaN, _this.resetStats_(), _this.mediaIndex = null, _this.partIndex = null, _this.hasPlayed_ = settings.hasPlayed, _this.currentTime_ = settings.currentTime, _this.seekable_ = settings.seekable, _this.seeking_ = settings.seeking, _this.duration_ = settings.duration, _this.mediaSource_ = settings.mediaSource, _this.vhs_ = settings.vhs, _this.loaderType_ = settings.loaderType, _this.currentMediaInfo_ = void 0, _this.startingMediaInfo_ = void 0, _this.segmentMetadataTrack_ = settings.segmentMetadataTrack, _this.goalBufferLength_ = settings.goalBufferLength, _this.sourceType_ = settings.sourceType, _this.sourceUpdater_ = settings.sourceUpdater, _this.inbandTextTracks_ = settings.inbandTextTracks, _this.state_ = "INIT", _this.timelineChangeController_ = settings.timelineChangeController, _this.shouldSaveSegmentTimingInfo_ = !0, _this.parse708captions_ = settings.parse708captions, _this.captionServices_ = settings.captionServices, _this.experimentalExactManifestTimings = settings.experimentalExactManifestTimings, _this.checkBufferTimeout_ = null, _this.error_ = void 0, _this.currentTimeline_ = -1, _this.pendingSegment_ = null, _this.xhrOptions_ = null, _this.pendingSegments_ = [], _this.audioDisabled_ = !1, _this.isPendingTimestampOffset_ = !1, _this.gopBuffer_ = [], _this.timeMapping_ = 0, _this.safeAppend_ = videojs.browser.IE_VERSION >= 11, _this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }, _this.playlistOfLastInitSegment_ = {
                        audio: null,
                        video: null
                    }, _this.callQueue_ = [], _this.loadQueue_ = [], _this.metadataQueue_ = {
                        id3: [],
                        caption: []
                    }, _this.waitingOnRemove_ = !1, _this.quotaExceededErrorRetryTimeout_ = null, _this.activeInitSegmentId_ = null, _this.initSegments_ = {}, _this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys, _this.keyCache_ = {}, _this.decrypter_ = settings.decrypter, _this.syncController_ = settings.syncController, _this.syncPoint_ = {
                        segmentIndex: 0,
                        time: 0
                    }, _this.transmuxer_ = _this.createTransmuxer_(), _this.triggerSyncInfoUpdate_ = function() {
                        return _this.trigger("syncinfoupdate");
                    }, _this.syncController_.on("syncinfoupdate", _this.triggerSyncInfoUpdate_), _this.mediaSource_.addEventListener("sourceopen", function() {
                        _this.isEndOfStream_() || (_this.ended_ = !1);
                    }), _this.fetchAtBuffer_ = !1, _this.logger_ = logger("SegmentLoader[" + _this.loaderType_ + "]"), Object.defineProperty((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), "state", {
                        get: function() {
                            return this.state_;
                        },
                        set: function(newState) {
                            newState !== this.state_ && (this.logger_(this.state_ + " -> " + newState), this.state_ = newState, this.trigger("statechange"));
                        }
                    }), _this.sourceUpdater_.on("ready", function() {
                        _this.hasEnoughInfoToAppend_() && _this.processCallQueue_();
                    }), "main" === _this.loaderType_ && _this.timelineChangeController_.on("pendingtimelinechange", function() {
                        _this.hasEnoughInfoToAppend_() && _this.processCallQueue_();
                    }), "audio" === _this.loaderType_ && _this.timelineChangeController_.on("timelinechange", function() {
                        _this.hasEnoughInfoToLoad_() && _this.processLoadQueue_(), _this.hasEnoughInfoToAppend_() && _this.processCallQueue_();
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SegmentLoader, _videojs$EventTarget);
                var _proto = SegmentLoader.prototype;
                return _proto.createTransmuxer_ = function() {
                    return segmentTransmuxer.createTransmuxer({
                        remux: !1,
                        alignGopsAtEnd: this.safeAppend_,
                        keepOriginalTimestamps: !0,
                        parse708captions: this.parse708captions_,
                        captionServices: this.captionServices_
                    });
                }, _proto.resetStats_ = function() {
                    this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0;
                }, _proto.dispose = function() {
                    this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off();
                }, _proto.setAudio = function(enable) {
                    this.audioDisabled_ = !enable, enable ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_());
                }, _proto.abort = function() {
                    if ("WAITING" !== this.state) {
                        this.pendingSegment_ && (this.pendingSegment_ = null);
                        return;
                    }
                    this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_();
                }, _proto.abort_ = function() {
                    this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null;
                }, _proto.checkForAbort_ = function(requestId) {
                    return "APPENDING" !== this.state || this.pendingSegment_ ? !this.pendingSegment_ || this.pendingSegment_.requestId !== requestId : (this.state = "READY", !0);
                }, _proto.error = function(_error) {
                    return void 0 !== _error && (this.logger_("error occurred:", _error), this.error_ = _error), this.pendingSegment_ = null, this.error_;
                }, _proto.endOfStream = function() {
                    this.ended_ = !0, this.transmuxer_ && segmentTransmuxer.reset(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended");
                }, _proto.buffered_ = function() {
                    var trackInfo = this.getMediaInfo_();
                    if (!this.sourceUpdater_ || !trackInfo) return videojs.createTimeRanges();
                    if ("main" === this.loaderType_) {
                        var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed = trackInfo.isMuxed;
                        if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) return this.sourceUpdater_.buffered();
                        if (hasVideo) return this.sourceUpdater_.videoBuffered();
                    }
                    return this.sourceUpdater_.audioBuffered();
                }, _proto.initSegmentForMap = function(map, set) {
                    if (void 0 === set && (set = !1), !map) return null;
                    var id = initSegmentId(map), storedMap = this.initSegments_[id];
                    return set && !storedMap && map.bytes && (this.initSegments_[id] = storedMap = {
                        resolvedUri: map.resolvedUri,
                        byterange: map.byterange,
                        bytes: map.bytes,
                        tracks: map.tracks,
                        timescales: map.timescales
                    }), storedMap || map;
                }, _proto.segmentKey = function(key, set) {
                    if (void 0 === set && (set = !1), !key) return null;
                    var id = segmentKeyId(key), storedKey = this.keyCache_[id];
                    this.cacheEncryptionKeys_ && set && !storedKey && key.bytes && (this.keyCache_[id] = storedKey = {
                        resolvedUri: key.resolvedUri,
                        bytes: key.bytes
                    });
                    var result = {
                        resolvedUri: (storedKey || key).resolvedUri
                    };
                    return storedKey && (result.bytes = storedKey.bytes), result;
                }, _proto.couldBeginLoading_ = function() {
                    return this.playlist_ && !this.paused();
                }, _proto.load = function() {
                    if (this.monitorBuffer_(), this.playlist_) {
                        if ("INIT" === this.state && this.couldBeginLoading_()) return this.init_();
                        this.couldBeginLoading_() && ("READY" === this.state || "INIT" === this.state) && (this.state = "READY");
                    }
                }, _proto.init_ = function() {
                    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
                }, _proto.playlist = function(newPlaylist, options) {
                    if (void 0 === options && (options = {}), newPlaylist) {
                        var oldPlaylist = this.playlist_, segmentInfo = this.pendingSegment_;
                        this.playlist_ = newPlaylist, this.xhrOptions_ = options, "INIT" === this.state && (newPlaylist.syncInfo = {
                            mediaSequence: newPlaylist.mediaSequence,
                            time: 0
                        }, "main" === this.loaderType_ && this.syncController_.setDateTimeMappingForStart(newPlaylist));
                        var oldId = null;
                        if (oldPlaylist && (oldPlaylist.id ? oldId = oldPlaylist.id : oldPlaylist.uri && (oldId = oldPlaylist.uri)), this.logger_("playlist update [" + oldId + " => " + (newPlaylist.id || newPlaylist.uri) + "]"), this.trigger("syncinfoupdate"), "INIT" === this.state && this.couldBeginLoading_()) return this.init_();
                        if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
                            null !== this.mediaIndex && (newPlaylist.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, this.trigger("playlistupdate");
                            return;
                        }
                        var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
                        if (this.logger_("live window shift [" + mediaSequenceDiff + "]"), null !== this.mediaIndex) {
                            if (this.mediaIndex -= mediaSequenceDiff, this.mediaIndex < 0) this.mediaIndex = null, this.partIndex = null;
                            else {
                                var segment = this.playlist_.segments[this.mediaIndex];
                                if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
                                    var mediaIndex = this.mediaIndex;
                                    this.logger_("currently processing part (index " + this.partIndex + ") no longer exists."), this.resetLoader(), this.mediaIndex = mediaIndex;
                                }
                            }
                        }
                        segmentInfo && (segmentInfo.mediaIndex -= mediaSequenceDiff, segmentInfo.mediaIndex < 0 ? (segmentInfo.mediaIndex = null, segmentInfo.partIndex = null) : (segmentInfo.mediaIndex >= 0 && (segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex]), segmentInfo.partIndex >= 0 && segmentInfo.segment.parts && (segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex]))), this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
                    }
                }, _proto.pause = function() {
                    this.checkBufferTimeout_ && (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null);
                }, _proto.paused = function() {
                    return null === this.checkBufferTimeout_;
                }, _proto.resetEverything = function(done) {
                    this.ended_ = !1, this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }, this.resetLoader(), this.remove(0, 1 / 0, done), this.transmuxer_ && (this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    }), this.transmuxer_.postMessage({
                        action: "reset"
                    }));
                }, _proto.resetLoader = function() {
                    this.fetchAtBuffer_ = !1, this.resyncLoader();
                }, _proto.resyncLoader = function() {
                    this.transmuxer_ && segmentTransmuxer.reset(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearParsedMp4Captions"
                    });
                }, _proto.remove = function(start, end, done, force) {
                    if (void 0 === done && (done = function() {}), void 0 === force && (force = !1), end === 1 / 0 && (end = this.duration_()), end <= start) {
                        this.logger_("skipping remove because end ${end} is <= start ${start}");
                        return;
                    }
                    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
                        this.logger_("skipping remove because no source updater or starting media info");
                        return;
                    }
                    var removesRemaining = 1, removeFinished = function() {
                        0 == --removesRemaining && done();
                    };
                    for(var track in (force || !this.audioDisabled_) && (removesRemaining++, this.sourceUpdater_.removeAudio(start, end, removeFinished)), (force || "main" === this.loaderType_) && (this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_), removesRemaining++, this.sourceUpdater_.removeVideo(start, end, removeFinished)), this.inbandTextTracks_)removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);
                    removeCuesFromTrack(start, end, this.segmentMetadataTrack_), removeFinished();
                }, _proto.monitorBuffer_ = function() {
                    this.checkBufferTimeout_ && global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(this.monitorBufferTick_.bind(this), 1);
                }, _proto.monitorBufferTick_ = function() {
                    "READY" === this.state && this.fillBuffer_(), this.checkBufferTimeout_ && global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(this.monitorBufferTick_.bind(this), 500);
                }, _proto.fillBuffer_ = function() {
                    if (!this.sourceUpdater_.updating()) {
                        var segmentInfo = this.chooseNextRequest_();
                        segmentInfo && ("number" == typeof segmentInfo.timestampOffset && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({
                            type: this.loaderType_,
                            from: this.currentTimeline_,
                            to: segmentInfo.timeline
                        })), this.loadSegment_(segmentInfo));
                    }
                }, _proto.isEndOfStream_ = function(mediaIndex, playlist, partIndex) {
                    if (void 0 === mediaIndex && (mediaIndex = this.mediaIndex), void 0 === playlist && (playlist = this.playlist_), void 0 === partIndex && (partIndex = this.partIndex), !playlist || !this.mediaSource_) return !1;
                    var segment = "number" == typeof mediaIndex && playlist.segments[mediaIndex], appendedLastSegment = mediaIndex + 1 === playlist.segments.length, appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
                    return playlist.endList && "open" === this.mediaSource_.readyState && appendedLastSegment && appendedLastPart;
                }, _proto.chooseNextRequest_ = function() {
                    var buffered = this.buffered_(), bufferedEnd = lastBufferedEnd(buffered) || 0, bufferedTime = timeAheadOf(buffered, this.currentTime_()), preloaded = !this.hasPlayed_() && bufferedTime >= 1, haveEnoughBuffer = bufferedTime >= this.goalBufferLength_(), segments = this.playlist_.segments;
                    if (!segments.length || preloaded || haveEnoughBuffer) return null;
                    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
                    var next = {
                        partIndex: null,
                        mediaIndex: null,
                        startOfSegment: null,
                        playlist: this.playlist_,
                        isSyncRequest: Boolean(!this.syncPoint_)
                    };
                    if (next.isSyncRequest) next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
                    else if (null !== this.mediaIndex) {
                        var segment = segments[this.mediaIndex], partIndex = "number" == typeof this.partIndex ? this.partIndex : -1;
                        next.startOfSegment = segment.end ? segment.end : bufferedEnd, segment.parts && segment.parts[partIndex + 1] ? (next.mediaIndex = this.mediaIndex, next.partIndex = partIndex + 1) : next.mediaIndex = this.mediaIndex + 1;
                    } else {
                        var _Playlist$getMediaInf = Playlist.getMediaInfoForTime({
                            experimentalExactManifestTimings: this.experimentalExactManifestTimings,
                            playlist: this.playlist_,
                            currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
                            startingPartIndex: this.syncPoint_.partIndex,
                            startingSegmentIndex: this.syncPoint_.segmentIndex,
                            startTime: this.syncPoint_.time
                        }), segmentIndex = _Playlist$getMediaInf.segmentIndex, startTime = _Playlist$getMediaInf.startTime, _partIndex = _Playlist$getMediaInf.partIndex;
                        next.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + bufferedEnd : "currentTime " + this.currentTime_(), next.mediaIndex = segmentIndex, next.startOfSegment = startTime, next.partIndex = _partIndex;
                    }
                    var nextSegment = segments[next.mediaIndex], nextPart = nextSegment && "number" == typeof next.partIndex && nextSegment.parts && nextSegment.parts[next.partIndex];
                    if (!nextSegment || "number" == typeof next.partIndex && !nextPart) return null;
                    if ("number" != typeof next.partIndex && nextSegment.parts && (next.partIndex = 0, nextPart = nextSegment.parts[0]), !bufferedTime && nextPart && !nextPart.independent) {
                        if (0 === next.partIndex) {
                            var lastSegment = segments[next.mediaIndex - 1], lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
                            lastSegmentLastPart && lastSegmentLastPart.independent && (next.mediaIndex -= 1, next.partIndex = lastSegment.parts.length - 1, next.independent = "previous segment");
                        } else nextSegment.parts[next.partIndex - 1].independent && (next.partIndex -= 1, next.independent = "previous part");
                    }
                    var ended = this.mediaSource_ && "ended" === this.mediaSource_.readyState;
                    return next.mediaIndex >= segments.length - 1 && ended && !this.seeking_() ? null : this.generateSegmentInfo_(next);
                }, _proto.generateSegmentInfo_ = function(options) {
                    var independent = options.independent, playlist = options.playlist, mediaIndex = options.mediaIndex, startOfSegment = options.startOfSegment, isSyncRequest = options.isSyncRequest, partIndex = options.partIndex, forceTimestampOffset = options.forceTimestampOffset, getMediaInfoForTime = options.getMediaInfoForTime, segment = playlist.segments[mediaIndex], part = "number" == typeof partIndex && segment.parts[partIndex], segmentInfo = {
                        requestId: "segment-loader-" + Math.random(),
                        uri: part && part.resolvedUri || segment.resolvedUri,
                        mediaIndex: mediaIndex,
                        partIndex: part ? partIndex : null,
                        isSyncRequest: isSyncRequest,
                        startOfSegment: startOfSegment,
                        playlist: playlist,
                        bytes: null,
                        encryptedBytes: null,
                        timestampOffset: null,
                        timeline: segment.timeline,
                        duration: part && part.duration || segment.duration,
                        segment: segment,
                        part: part,
                        byteLength: 0,
                        transmuxer: this.transmuxer_,
                        getMediaInfoForTime: getMediaInfoForTime,
                        independent: independent
                    }, overrideCheck = void 0 !== forceTimestampOffset ? forceTimestampOffset : this.isPendingTimestampOffset_;
                    segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
                        segmentTimeline: segment.timeline,
                        currentTimeline: this.currentTimeline_,
                        startOfSegment: startOfSegment,
                        buffered: this.buffered_(),
                        overrideCheck: overrideCheck
                    });
                    var audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
                    return "number" == typeof audioBufferedEnd && (segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_)), segmentInfo;
                }, _proto.timestampOffsetForSegment_ = function(options) {
                    return timestampOffsetForSegment(options);
                }, _proto.earlyAbortWhenNeeded_ = function(stats) {
                    if (!(this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH || Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000)) {
                        var buffered, playbackRate, currentTime = this.currentTime_(), measuredBandwidth = stats.bandwidth, segmentDuration = this.pendingSegment_.duration, requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived), timeUntilRebuffer$1 = (buffered = this.buffered_(), void 0 === (playbackRate = this.vhs_.tech_.playbackRate()) && (playbackRate = 1), ((buffered.length ? buffered.end(buffered.length - 1) : 0) - currentTime) / playbackRate - 1);
                        if (!(requestTimeRemaining <= timeUntilRebuffer$1)) {
                            var switchCandidate = minRebufferMaxBandwidthSelector({
                                master: this.vhs_.playlists.master,
                                currentTime: currentTime,
                                bandwidth: measuredBandwidth,
                                duration: this.duration_(),
                                segmentDuration: segmentDuration,
                                timeUntilRebuffer: timeUntilRebuffer$1,
                                currentTimeline: this.currentTimeline_,
                                syncController: this.syncController_
                            });
                            if (switchCandidate) {
                                var timeSavedBySwitching = requestTimeRemaining - timeUntilRebuffer$1 - switchCandidate.rebufferingImpact, minimumTimeSaving = 0.5;
                                timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR && (minimumTimeSaving = 1), switchCandidate.playlist && switchCandidate.playlist.uri !== this.playlist_.uri && !(timeSavedBySwitching < minimumTimeSaving) && (this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort"));
                            }
                        }
                    }
                }, _proto.handleAbort_ = function(segmentInfo) {
                    this.logger_("Aborting " + segmentInfoString(segmentInfo)), this.mediaRequestsAborted += 1;
                }, _proto.handleProgress_ = function(event, simpleSegment) {
                    this.earlyAbortWhenNeeded_(simpleSegment.stats), this.checkForAbort_(simpleSegment.requestId) || this.trigger("progress");
                }, _proto.handleTrackInfo_ = function(simpleSegment, trackInfo) {
                    this.earlyAbortWhenNeeded_(simpleSegment.stats), this.checkForAbort_(simpleSegment.requestId) || this.checkForIllegalMediaSwitch(trackInfo) || (trackInfo = trackInfo || {}, shallowEqual(this.currentMediaInfo_, trackInfo) || (this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }, this.startingMediaInfo_ = trackInfo, this.currentMediaInfo_ = trackInfo, this.logger_("trackinfo update", trackInfo), this.trigger("trackinfo")), !this.checkForAbort_(simpleSegment.requestId) && (this.pendingSegment_.trackInfo = trackInfo, this.hasEnoughInfoToAppend_() && this.processCallQueue_()));
                }, _proto.handleTimingInfo_ = function(simpleSegment, mediaType, timeType, time) {
                    if (this.earlyAbortWhenNeeded_(simpleSegment.stats), !this.checkForAbort_(simpleSegment.requestId)) {
                        var segmentInfo = this.pendingSegment_, timingInfoProperty = timingInfoPropertyForMedia(mediaType);
                        segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {}, segmentInfo[timingInfoProperty][timeType] = time, this.logger_("timinginfo: " + mediaType + " - " + timeType + " - " + time), this.hasEnoughInfoToAppend_() && this.processCallQueue_();
                    }
                }, _proto.handleCaptions_ = function(simpleSegment, captionData) {
                    var _this2 = this;
                    if (this.earlyAbortWhenNeeded_(simpleSegment.stats), !this.checkForAbort_(simpleSegment.requestId)) {
                        if (0 === captionData.length) {
                            this.logger_("SegmentLoader received no captions from a caption event");
                            return;
                        }
                        if (!this.pendingSegment_.hasAppendedData_) {
                            this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
                            return;
                        }
                        var timestampOffset = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), captionTracks = {};
                        captionData.forEach(function(caption) {
                            captionTracks[caption.stream] = captionTracks[caption.stream] || {
                                startTime: 1 / 0,
                                captions: [],
                                endTime: 0
                            };
                            var captionTrack = captionTracks[caption.stream];
                            captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset), captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset), captionTrack.captions.push(caption);
                        }), Object.keys(captionTracks).forEach(function(trackName) {
                            var _captionTracks$trackN = captionTracks[trackName], startTime = _captionTracks$trackN.startTime, endTime = _captionTracks$trackN.endTime, captions = _captionTracks$trackN.captions, inbandTextTracks = _this2.inbandTextTracks_;
                            _this2.logger_("adding cues from " + startTime + " -> " + endTime + " for " + trackName), createCaptionsTrackIfNotExists(inbandTextTracks, _this2.vhs_.tech_, trackName), removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]), addCaptionData({
                                captionArray: captions,
                                inbandTextTracks: inbandTextTracks,
                                timestampOffset: timestampOffset
                            });
                        }), this.transmuxer_ && this.transmuxer_.postMessage({
                            action: "clearParsedMp4Captions"
                        });
                    }
                }, _proto.handleId3_ = function(simpleSegment, id3Frames, dispatchType) {
                    if (this.earlyAbortWhenNeeded_(simpleSegment.stats), !this.checkForAbort_(simpleSegment.requestId)) {
                        if (!this.pendingSegment_.hasAppendedData_) {
                            this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
                            return;
                        }
                        var timestampOffset = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
                        createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_), addMetadata({
                            inbandTextTracks: this.inbandTextTracks_,
                            metadataArray: id3Frames,
                            timestampOffset: timestampOffset,
                            videoDuration: this.duration_()
                        });
                    }
                }, _proto.processMetadataQueue_ = function() {
                    this.metadataQueue_.id3.forEach(function(fn) {
                        return fn();
                    }), this.metadataQueue_.caption.forEach(function(fn) {
                        return fn();
                    }), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [];
                }, _proto.processCallQueue_ = function() {
                    var callQueue = this.callQueue_;
                    this.callQueue_ = [], callQueue.forEach(function(fun) {
                        return fun();
                    });
                }, _proto.processLoadQueue_ = function() {
                    var loadQueue = this.loadQueue_;
                    this.loadQueue_ = [], loadQueue.forEach(function(fun) {
                        return fun();
                    });
                }, _proto.hasEnoughInfoToLoad_ = function() {
                    if ("audio" !== this.loaderType_) return !0;
                    var segmentInfo = this.pendingSegment_;
                    return !!segmentInfo && (!this.getCurrentMediaInfo_() || !shouldWaitForTimelineChange({
                        timelineChangeController: this.timelineChangeController_,
                        currentTimeline: this.currentTimeline_,
                        segmentTimeline: segmentInfo.timeline,
                        loaderType: this.loaderType_,
                        audioDisabled: this.audioDisabled_
                    }));
                }, _proto.getCurrentMediaInfo_ = function(segmentInfo) {
                    return void 0 === segmentInfo && (segmentInfo = this.pendingSegment_), segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
                }, _proto.getMediaInfo_ = function(segmentInfo) {
                    return void 0 === segmentInfo && (segmentInfo = this.pendingSegment_), this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
                }, _proto.hasEnoughInfoToAppend_ = function() {
                    if (!this.sourceUpdater_.ready() || this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) return !1;
                    var segmentInfo = this.pendingSegment_, trackInfo = this.getCurrentMediaInfo_();
                    if (!segmentInfo || !trackInfo) return !1;
                    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed = trackInfo.isMuxed;
                    return !(hasVideo && !segmentInfo.videoTimingInfo || hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo || shouldWaitForTimelineChange({
                        timelineChangeController: this.timelineChangeController_,
                        currentTimeline: this.currentTimeline_,
                        segmentTimeline: segmentInfo.timeline,
                        loaderType: this.loaderType_,
                        audioDisabled: this.audioDisabled_
                    }));
                }, _proto.handleData_ = function(simpleSegment, result) {
                    if (this.earlyAbortWhenNeeded_(simpleSegment.stats), !this.checkForAbort_(simpleSegment.requestId)) {
                        if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
                            this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
                            return;
                        }
                        var segmentInfo = this.pendingSegment_;
                        if (this.setTimeMapping_(segmentInfo.timeline), this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment), "closed" !== this.mediaSource_.readyState) {
                            if (simpleSegment.map && (simpleSegment.map = this.initSegmentForMap(simpleSegment.map, !0), segmentInfo.segment.map = simpleSegment.map), simpleSegment.key && this.segmentKey(simpleSegment.key, !0), segmentInfo.isFmp4 = simpleSegment.isFmp4, segmentInfo.timingInfo = segmentInfo.timingInfo || {}, segmentInfo.isFmp4) this.trigger("fmp4"), segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
                            else {
                                var firstVideoFrameTimeForData, trackInfo = this.getCurrentMediaInfo_(), useVideoTimingInfo = "main" === this.loaderType_ && trackInfo && trackInfo.hasVideo;
                                useVideoTimingInfo && (firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start), segmentInfo.timingInfo.start = this.trueSegmentStart_({
                                    currentStart: segmentInfo.timingInfo.start,
                                    playlist: segmentInfo.playlist,
                                    mediaIndex: segmentInfo.mediaIndex,
                                    currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
                                    useVideoTimingInfo: useVideoTimingInfo,
                                    firstVideoFrameTimeForData: firstVideoFrameTimeForData,
                                    videoTimingInfo: segmentInfo.videoTimingInfo,
                                    audioTimingInfo: segmentInfo.audioTimingInfo
                                });
                            }
                            if (this.updateAppendInitSegmentStatus(segmentInfo, result.type), this.updateSourceBufferTimestampOffset_(segmentInfo), segmentInfo.isSyncRequest) {
                                this.updateTimingInfoEnd_(segmentInfo), this.syncController_.saveSegmentTimingInfo({
                                    segmentInfo: segmentInfo,
                                    shouldSaveTimelineMapping: "main" === this.loaderType_
                                });
                                var next = this.chooseNextRequest_();
                                if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
                                    this.logger_("sync segment was incorrect, not appending");
                                    return;
                                }
                                this.logger_("sync segment was correct, appending");
                            }
                            segmentInfo.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(segmentInfo, result);
                        }
                    }
                }, _proto.updateAppendInitSegmentStatus = function(segmentInfo, type) {
                    "main" !== this.loaderType_ || "number" != typeof segmentInfo.timestampOffset || segmentInfo.changedTimestampOffset || (this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }), this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist && (this.appendInitSegment_[type] = !0);
                }, _proto.getInitSegmentAndUpdateState_ = function(_ref4) {
                    var type = _ref4.type, initSegment = _ref4.initSegment, map = _ref4.map, playlist = _ref4.playlist;
                    if (map) {
                        var id = initSegmentId(map);
                        if (this.activeInitSegmentId_ === id) return null;
                        initSegment = this.initSegmentForMap(map, !0).bytes, this.activeInitSegmentId_ = id;
                    }
                    return initSegment && this.appendInitSegment_[type] ? (this.playlistOfLastInitSegment_[type] = playlist, this.appendInitSegment_[type] = !1, this.activeInitSegmentId_ = null, initSegment) : null;
                }, _proto.handleQuotaExceededError_ = function(_ref5, error) {
                    var _this3 = this, segmentInfo = _ref5.segmentInfo, type = _ref5.type, bytes = _ref5.bytes, audioBuffered = this.sourceUpdater_.audioBuffered(), videoBuffered = this.sourceUpdater_.videoBuffered();
                    audioBuffered.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", ")), videoBuffered.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
                    var audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0, audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0, videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0, videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
                    if (audioBufferEnd - audioBufferStart <= 1 && videoBufferEnd - videoBufferStart <= 1) {
                        this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: " + bytes.byteLength + ", audio buffer: " + timeRangesToArray(audioBuffered).join(", ") + ", video buffer: " + timeRangesToArray(videoBuffered).join(", ") + ", "), this.error({
                            message: "Quota exceeded error with append of a single segment of content",
                            excludeUntil: 1 / 0
                        }), this.trigger("error");
                        return;
                    }
                    this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
                        segmentInfo: segmentInfo,
                        type: type,
                        bytes: bytes
                    }));
                    var timeToRemoveUntil = this.currentTime_() - 1;
                    this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + timeToRemoveUntil), this.remove(0, timeToRemoveUntil, function() {
                        _this3.logger_("On QUOTA_EXCEEDED_ERR, retrying append in 1s"), _this3.waitingOnRemove_ = !1, _this3.quotaExceededErrorRetryTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(function() {
                            _this3.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), _this3.quotaExceededErrorRetryTimeout_ = null, _this3.processCallQueue_();
                        }, 1000);
                    }, !0);
                }, _proto.handleAppendError_ = function(_ref6, error) {
                    var segmentInfo = _ref6.segmentInfo, type = _ref6.type, bytes = _ref6.bytes;
                    if (error) {
                        if (22 === error.code) {
                            this.handleQuotaExceededError_({
                                segmentInfo: segmentInfo,
                                type: type,
                                bytes: bytes
                            });
                            return;
                        }
                        this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error), this.error(type + " append of " + bytes.length + "b failed for segment #" + segmentInfo.mediaIndex + " in playlist " + segmentInfo.playlist.id), this.trigger("appenderror");
                    }
                }, _proto.appendToSourceBuffer_ = function(_ref7) {
                    var segmentInfo = _ref7.segmentInfo, type = _ref7.type, initSegment = _ref7.initSegment, data = _ref7.data, bytes = _ref7.bytes;
                    if (!bytes) {
                        var segments = [
                            data
                        ], byteLength = data.byteLength;
                        initSegment && (segments.unshift(initSegment), byteLength += initSegment.byteLength), bytes = concatSegments({
                            bytes: byteLength,
                            segments: segments
                        });
                    }
                    this.sourceUpdater_.appendBuffer({
                        segmentInfo: segmentInfo,
                        type: type,
                        bytes: bytes
                    }, this.handleAppendError_.bind(this, {
                        segmentInfo: segmentInfo,
                        type: type,
                        bytes: bytes
                    }));
                }, _proto.handleSegmentTimingInfo_ = function(type, requestId, segmentTimingInfo) {
                    if (this.pendingSegment_ && requestId === this.pendingSegment_.requestId) {
                        var segment = this.pendingSegment_.segment, timingInfoProperty = type + "TimingInfo";
                        segment[timingInfoProperty] || (segment[timingInfoProperty] = {}), segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0, segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation, segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode, segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation, segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode, segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
                    }
                }, _proto.appendData_ = function(segmentInfo, result) {
                    var type = result.type, data = result.data;
                    if (data && data.byteLength && ("audio" !== type || !this.audioDisabled_)) {
                        var initSegment = this.getInitSegmentAndUpdateState_({
                            type: type,
                            initSegment: result.initSegment,
                            playlist: segmentInfo.playlist,
                            map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
                        });
                        this.appendToSourceBuffer_({
                            segmentInfo: segmentInfo,
                            type: type,
                            initSegment: initSegment,
                            data: data
                        });
                    }
                }, _proto.loadSegment_ = function(segmentInfo) {
                    var _this4 = this;
                    if (this.state = "WAITING", this.pendingSegment_ = segmentInfo, this.trimBackBuffer_(segmentInfo), "number" == typeof segmentInfo.timestampOffset && this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    }), !this.hasEnoughInfoToLoad_()) {
                        this.loadQueue_.push(function() {
                            var options = (0, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__.Z)({}, segmentInfo, {
                                forceTimestampOffset: !0
                            });
                            (0, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_15__.Z)(segmentInfo, _this4.generateSegmentInfo_(options)), _this4.isPendingTimestampOffset_ = !1, _this4.updateTransmuxerAndRequestSegment_(segmentInfo);
                        });
                        return;
                    }
                    this.updateTransmuxerAndRequestSegment_(segmentInfo);
                }, _proto.updateTransmuxerAndRequestSegment_ = function(segmentInfo) {
                    var _this5 = this;
                    this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset) && (this.gopBuffer_.length = 0, segmentInfo.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({
                        action: "reset"
                    }), this.transmuxer_.postMessage({
                        action: "setTimestampOffset",
                        timestampOffset: segmentInfo.timestampOffset
                    }));
                    var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo), isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex), isWalkingForward = null !== this.mediaIndex, isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && segmentInfo.timeline > 0;
                    this.logger_("Requesting " + segmentInfoString(segmentInfo)), simpleSegment.map && !simpleSegment.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = {
                        video: !0,
                        audio: !0
                    }), segmentInfo.abortRequests = mediaSegmentRequest({
                        xhr: this.vhs_.xhr,
                        xhrOptions: this.xhrOptions_,
                        decryptionWorker: this.decrypter_,
                        segment: simpleSegment,
                        abortFn: this.handleAbort_.bind(this, segmentInfo),
                        progressFn: this.handleProgress_.bind(this),
                        trackInfoFn: this.handleTrackInfo_.bind(this),
                        timingInfoFn: this.handleTimingInfo_.bind(this),
                        videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
                        audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
                        captionsFn: this.handleCaptions_.bind(this),
                        isEndOfTimeline: isEndOfStream || isWalkingForward && isDiscontinuity,
                        endedTimelineFn: function() {
                            _this5.logger_("received endedtimeline callback");
                        },
                        id3Fn: this.handleId3_.bind(this),
                        dataFn: this.handleData_.bind(this),
                        doneFn: this.segmentRequestFinished_.bind(this),
                        onTransmuxerLog: function(_ref8) {
                            var message = _ref8.message, level = _ref8.level, stream = _ref8.stream;
                            _this5.logger_(segmentInfoString(segmentInfo) + " logged from transmuxer stream " + stream + " as a " + level + ": " + message);
                        }
                    });
                }, _proto.trimBackBuffer_ = function(segmentInfo) {
                    var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
                    removeToTime > 0 && this.remove(0, removeToTime);
                }, _proto.createSimplifiedSegmentObj_ = function(segmentInfo) {
                    var segment = segmentInfo.segment, part = segmentInfo.part, simpleSegment = {
                        resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
                        byterange: part ? part.byterange : segment.byterange,
                        requestId: segmentInfo.requestId,
                        transmuxer: segmentInfo.transmuxer,
                        audioAppendStart: segmentInfo.audioAppendStart,
                        gopsToAlignWith: segmentInfo.gopsToAlignWith,
                        part: segmentInfo.part
                    }, previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
                    if (previousSegment && previousSegment.timeline === segment.timeline && (previousSegment.videoTimingInfo ? simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd : previousSegment.audioTimingInfo && (simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd)), segment.key) {
                        var iv = segment.key.iv || new Uint32Array([
                            0,
                            0,
                            0,
                            segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence
                        ]);
                        simpleSegment.key = this.segmentKey(segment.key), simpleSegment.key.iv = iv;
                    }
                    return segment.map && (simpleSegment.map = this.initSegmentForMap(segment.map)), simpleSegment;
                }, _proto.saveTransferStats_ = function(stats) {
                    this.mediaRequests += 1, stats && (this.mediaBytesTransferred += stats.bytesReceived, this.mediaTransferDuration += stats.roundTripTime);
                }, _proto.saveBandwidthRelatedStats_ = function(duration, stats) {
                    if (this.pendingSegment_.byteLength = stats.bytesReceived, duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
                        this.logger_("Ignoring segment's bandwidth because its duration of " + duration + " is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS);
                        return;
                    }
                    this.bandwidth = stats.bandwidth, this.roundTrip = stats.roundTripTime;
                }, _proto.handleTimeout_ = function() {
                    this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate");
                }, _proto.segmentRequestFinished_ = function(error, simpleSegment, result) {
                    if (this.callQueue_.length) {
                        this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
                        return;
                    }
                    if (this.saveTransferStats_(simpleSegment.stats), this.pendingSegment_ && simpleSegment.requestId === this.pendingSegment_.requestId) {
                        if (error) {
                            if (this.pendingSegment_ = null, this.state = "READY", error.code === REQUEST_ERRORS.ABORTED) return;
                            if (this.pause(), error.code === REQUEST_ERRORS.TIMEOUT) {
                                this.handleTimeout_();
                                return;
                            }
                            this.mediaRequestsErrored += 1, this.error(error), this.trigger("error");
                            return;
                        }
                        var segmentInfo = this.pendingSegment_;
                        this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats), segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests, result.gopInfo && (this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(segmentInfo);
                    }
                }, _proto.setTimeMapping_ = function(timeline) {
                    var timelineMapping = this.syncController_.mappingForTimeline(timeline);
                    null !== timelineMapping && (this.timeMapping_ = timelineMapping);
                }, _proto.updateMediaSecondsLoaded_ = function(segment) {
                    "number" == typeof segment.start && "number" == typeof segment.end ? this.mediaSecondsLoaded += segment.end - segment.start : this.mediaSecondsLoaded += segment.duration;
                }, _proto.shouldUpdateTransmuxerTimestampOffset_ = function(timestampOffset) {
                    return null !== timestampOffset && ("main" === this.loaderType_ && timestampOffset !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset());
                }, _proto.trueSegmentStart_ = function(_ref9) {
                    var currentStart = _ref9.currentStart, playlist = _ref9.playlist, mediaIndex = _ref9.mediaIndex, firstVideoFrameTimeForData = _ref9.firstVideoFrameTimeForData, currentVideoTimestampOffset = _ref9.currentVideoTimestampOffset, useVideoTimingInfo = _ref9.useVideoTimingInfo, videoTimingInfo = _ref9.videoTimingInfo, audioTimingInfo = _ref9.audioTimingInfo;
                    if (void 0 !== currentStart) return currentStart;
                    if (!useVideoTimingInfo) return audioTimingInfo.start;
                    var previousSegment = playlist.segments[mediaIndex - 1];
                    return 0 !== mediaIndex && previousSegment && void 0 !== previousSegment.start && previousSegment.end === firstVideoFrameTimeForData + currentVideoTimestampOffset ? videoTimingInfo.start : firstVideoFrameTimeForData;
                }, _proto.waitForAppendsToComplete_ = function(segmentInfo) {
                    var trackInfo = this.getCurrentMediaInfo_(segmentInfo);
                    if (!trackInfo) {
                        this.error({
                            message: "No starting media returned, likely due to an unsupported media format.",
                            blacklistDuration: 1 / 0
                        }), this.trigger("error");
                        return;
                    }
                    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed = trackInfo.isMuxed, waitForVideo = "main" === this.loaderType_ && hasVideo, waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;
                    if (segmentInfo.waitingOnAppends = 0, !segmentInfo.hasAppendedData_) {
                        segmentInfo.timingInfo || "number" != typeof segmentInfo.timestampOffset || (this.isPendingTimestampOffset_ = !0), segmentInfo.timingInfo = {
                            start: 0
                        }, segmentInfo.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(segmentInfo), this.processMetadataQueue_()), this.checkAppendsDone_(segmentInfo);
                        return;
                    }
                    waitForVideo && segmentInfo.waitingOnAppends++, waitForAudio && segmentInfo.waitingOnAppends++, waitForVideo && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo)), waitForAudio && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
                }, _proto.checkAppendsDone_ = function(segmentInfo) {
                    this.checkForAbort_(segmentInfo.requestId) || (segmentInfo.waitingOnAppends--, 0 === segmentInfo.waitingOnAppends && this.handleAppendsDone_());
                }, _proto.checkForIllegalMediaSwitch = function(trackInfo) {
                    var loaderType, startingMedia, illegalMediaSwitchError = (loaderType = this.loaderType_, startingMedia = this.getCurrentMediaInfo_(), "main" === loaderType && startingMedia && trackInfo ? trackInfo.hasAudio || trackInfo.hasVideo ? startingMedia.hasVideo && !trackInfo.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !startingMedia.hasVideo && trackInfo.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null : "Neither audio nor video found in segment." : null);
                    return !!illegalMediaSwitchError && (this.error({
                        message: illegalMediaSwitchError,
                        blacklistDuration: 1 / 0
                    }), this.trigger("error"), !0);
                }, _proto.updateSourceBufferTimestampOffset_ = function(segmentInfo) {
                    if (null !== segmentInfo.timestampOffset && "number" == typeof segmentInfo.timingInfo.start && !segmentInfo.changedTimestampOffset && "main" === this.loaderType_) {
                        var didChange = !1;
                        segmentInfo.timestampOffset -= segmentInfo.timingInfo.start, segmentInfo.changedTimestampOffset = !0, segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset), didChange = !0), segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset), didChange = !0), didChange && this.trigger("timestampoffset");
                    }
                }, _proto.updateTimingInfoEnd_ = function(segmentInfo) {
                    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
                    var trackInfo = this.getMediaInfo_(), prioritizedTimingInfo = "main" === this.loaderType_ && trackInfo && trackInfo.hasVideo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
                    prioritizedTimingInfo && (segmentInfo.timingInfo.end = "number" == typeof prioritizedTimingInfo.end ? prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration);
                }, _proto.handleAppendsDone_ = function() {
                    if (this.pendingSegment_ && this.trigger("appendsdone"), !this.pendingSegment_) {
                        this.state = "READY", this.paused() || this.monitorBuffer_();
                        return;
                    }
                    var segmentInfo = this.pendingSegment_;
                    this.updateTimingInfoEnd_(segmentInfo), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({
                        segmentInfo: segmentInfo,
                        shouldSaveTimelineMapping: "main" === this.loaderType_
                    });
                    var segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
                    if (segmentDurationMessage && ("warn" === segmentDurationMessage.severity ? videojs.log.warn(segmentDurationMessage.message) : this.logger_(segmentDurationMessage.message)), this.recordThroughput_(segmentInfo), this.pendingSegment_ = null, this.state = "READY", segmentInfo.isSyncRequest && (this.trigger("syncinfoupdate"), !segmentInfo.hasAppendedData_)) {
                        this.logger_("Throwing away un-appended sync request " + segmentInfoString(segmentInfo));
                        return;
                    }
                    this.logger_("Appended " + segmentInfoString(segmentInfo)), this.addSegmentMetadataCue_(segmentInfo), this.fetchAtBuffer_ = !0, this.currentTimeline_ === segmentInfo.timeline || (this.timelineChangeController_.lastTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    }), "main" !== this.loaderType_ || this.audioDisabled_ || this.timelineChangeController_.lastTimelineChange({
                        type: "audio",
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    })), this.currentTimeline_ = segmentInfo.timeline, this.trigger("syncinfoupdate");
                    var segment = segmentInfo.segment, part = segmentInfo.part, badSegmentGuess = segment.end && this.currentTime_() - segment.end > 3 * segmentInfo.playlist.targetDuration, badPartGuess = part && part.end && this.currentTime_() - part.end > 3 * segmentInfo.playlist.partTargetDuration;
                    if (badSegmentGuess || badPartGuess) {
                        this.logger_("bad " + (badSegmentGuess ? "segment" : "part") + " " + segmentInfoString(segmentInfo)), this.resetEverything();
                        return;
                    }
                    null !== this.mediaIndex && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = segmentInfo.mediaIndex, this.partIndex = segmentInfo.partIndex, this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex) && this.endOfStream(), this.trigger("appended"), segmentInfo.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_();
                }, _proto.recordThroughput_ = function(segmentInfo) {
                    if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
                        this.logger_("Ignoring segment's throughput because its duration of " + segmentInfo.duration + " is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS);
                        return;
                    }
                    var rate = this.throughput.rate, segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1, segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8000);
                    this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
                }, _proto.addSegmentMetadataCue_ = function(segmentInfo) {
                    if (this.segmentMetadataTrack_) {
                        var segment = segmentInfo.segment, start = segment.start, end = segment.end;
                        if (finite(start) && finite(end)) {
                            removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
                            var Cue = global_window__WEBPACK_IMPORTED_MODULE_0___default().WebKitDataCue || global_window__WEBPACK_IMPORTED_MODULE_0___default().VTTCue, value = {
                                custom: segment.custom,
                                dateTimeObject: segment.dateTimeObject,
                                dateTimeString: segment.dateTimeString,
                                bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
                                resolution: segmentInfo.playlist.attributes.RESOLUTION,
                                codecs: segmentInfo.playlist.attributes.CODECS,
                                byteLength: segmentInfo.byteLength,
                                uri: segmentInfo.uri,
                                timeline: segmentInfo.timeline,
                                playlist: segmentInfo.playlist.id,
                                start: start,
                                end: end
                            }, data = JSON.stringify(value), cue = new Cue(start, end, data);
                            cue.value = value, this.segmentMetadataTrack_.addCue(cue);
                        }
                    }
                }, SegmentLoader;
            }(videojs.EventTarget);
            function noop() {}
            var toTitleCase = function(string) {
                return "string" != typeof string ? string : string.replace(/./, function(w) {
                    return w.toUpperCase();
                });
            }, bufferTypes = [
                "video",
                "audio"
            ], _updating = function(type, sourceUpdater) {
                var sourceBuffer = sourceUpdater[type + "Buffer"];
                return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];
            }, nextQueueIndexOfType = function(type, queue) {
                for(var i = 0; i < queue.length; i++){
                    var queueEntry = queue[i];
                    if ("mediaSource" === queueEntry.type) break;
                    if (queueEntry.type === type) return i;
                }
                return null;
            }, shiftQueue = function shiftQueue(type, sourceUpdater) {
                if (0 !== sourceUpdater.queue.length) {
                    var queueIndex = 0, queueEntry = sourceUpdater.queue[queueIndex];
                    if ("mediaSource" === queueEntry.type) {
                        sourceUpdater.updating() || "closed" === sourceUpdater.mediaSource.readyState || (sourceUpdater.queue.shift(), queueEntry.action(sourceUpdater), queueEntry.doneFn && queueEntry.doneFn(), shiftQueue("audio", sourceUpdater), shiftQueue("video", sourceUpdater));
                        return;
                    }
                    if (!("mediaSource" === type || !sourceUpdater.ready() || "closed" === sourceUpdater.mediaSource.readyState || _updating(type, sourceUpdater))) {
                        if (queueEntry.type !== type) {
                            if (null === (queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue))) return;
                            queueEntry = sourceUpdater.queue[queueIndex];
                        }
                        if (sourceUpdater.queue.splice(queueIndex, 1), sourceUpdater.queuePending[type] = queueEntry, queueEntry.action(type, sourceUpdater), !queueEntry.doneFn) {
                            sourceUpdater.queuePending[type] = null, shiftQueue(type, sourceUpdater);
                            return;
                        }
                    }
                }
            }, cleanupBuffer = function(type, sourceUpdater) {
                var buffer = sourceUpdater[type + "Buffer"], titleType = toTitleCase(type);
                buffer && (buffer.removeEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]), buffer.removeEventListener("error", sourceUpdater["on" + titleType + "Error_"]), sourceUpdater.codecs[type] = null, sourceUpdater[type + "Buffer"] = null);
            }, inSourceBuffers = function(mediaSource, sourceBuffer) {
                return mediaSource && sourceBuffer && -1 !== Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer);
            }, actions = {
                appendBuffer: function(bytes, segmentInfo, onError) {
                    return function(type, sourceUpdater) {
                        var sourceBuffer = sourceUpdater[type + "Buffer"];
                        if (inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
                            sourceUpdater.logger_("Appending segment " + segmentInfo.mediaIndex + "'s " + bytes.length + " bytes to " + type + "Buffer");
                            try {
                                sourceBuffer.appendBuffer(bytes);
                            } catch (e) {
                                sourceUpdater.logger_("Error with code " + e.code + " " + (22 === e.code ? "(QUOTA_EXCEEDED_ERR) " : "") + "when appending segment " + segmentInfo.mediaIndex + " to " + type + "Buffer"), sourceUpdater.queuePending[type] = null, onError(e);
                            }
                        }
                    };
                },
                remove: function(start, end) {
                    return function(type, sourceUpdater) {
                        var sourceBuffer = sourceUpdater[type + "Buffer"];
                        if (inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
                            sourceUpdater.logger_("Removing " + start + " to " + end + " from " + type + "Buffer");
                            try {
                                sourceBuffer.remove(start, end);
                            } catch (e) {
                                sourceUpdater.logger_("Remove " + start + " to " + end + " from " + type + "Buffer failed");
                            }
                        }
                    };
                },
                timestampOffset: function(offset) {
                    return function(type, sourceUpdater) {
                        var sourceBuffer = sourceUpdater[type + "Buffer"];
                        inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer) && (sourceUpdater.logger_("Setting " + type + "timestampOffset to " + offset), sourceBuffer.timestampOffset = offset);
                    };
                },
                callback: function(_callback) {
                    return function(type, sourceUpdater) {
                        _callback();
                    };
                },
                endOfStream: function(error) {
                    return function(sourceUpdater) {
                        if ("open" === sourceUpdater.mediaSource.readyState) {
                            sourceUpdater.logger_("Calling mediaSource endOfStream(" + (error || "") + ")");
                            try {
                                sourceUpdater.mediaSource.endOfStream(error);
                            } catch (e) {
                                videojs.log.warn("Failed to call media source endOfStream", e);
                            }
                        }
                    };
                },
                duration: function(_duration) {
                    return function(sourceUpdater) {
                        sourceUpdater.logger_("Setting mediaSource duration to " + _duration);
                        try {
                            sourceUpdater.mediaSource.duration = _duration;
                        } catch (e) {
                            videojs.log.warn("Failed to set media source duration", e);
                        }
                    };
                },
                abort: function() {
                    return function(type, sourceUpdater) {
                        if ("open" === sourceUpdater.mediaSource.readyState) {
                            var sourceBuffer = sourceUpdater[type + "Buffer"];
                            if (inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
                                sourceUpdater.logger_("calling abort on " + type + "Buffer");
                                try {
                                    sourceBuffer.abort();
                                } catch (e) {
                                    videojs.log.warn("Failed to abort on " + type + "Buffer", e);
                                }
                            }
                        }
                    };
                },
                addSourceBuffer: function(type, codec) {
                    return function(sourceUpdater) {
                        var titleType = toTitleCase(type), mime = (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__._5)(codec);
                        sourceUpdater.logger_("Adding " + type + "Buffer with codec " + codec + " to mediaSource");
                        var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
                        sourceBuffer.addEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]), sourceBuffer.addEventListener("error", sourceUpdater["on" + titleType + "Error_"]), sourceUpdater.codecs[type] = codec, sourceUpdater[type + "Buffer"] = sourceBuffer;
                    };
                },
                removeSourceBuffer: function(type) {
                    return function(sourceUpdater) {
                        var sourceBuffer = sourceUpdater[type + "Buffer"];
                        if (cleanupBuffer(type, sourceUpdater), inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
                            sourceUpdater.logger_("Removing " + type + "Buffer with codec " + sourceUpdater.codecs[type] + " from mediaSource");
                            try {
                                sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
                            } catch (e) {
                                videojs.log.warn("Failed to removeSourceBuffer " + type + "Buffer", e);
                            }
                        }
                    };
                },
                changeType: function(codec) {
                    return function(type, sourceUpdater) {
                        var sourceBuffer = sourceUpdater[type + "Buffer"], mime = (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__._5)(codec);
                        inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer) && sourceUpdater.codecs[type] !== codec && (sourceUpdater.logger_("changing " + type + "Buffer codec from " + sourceUpdater.codecs[type] + " to " + codec), sourceBuffer.changeType(mime), sourceUpdater.codecs[type] = codec);
                    };
                }
            }, pushQueue = function(_ref) {
                var type = _ref.type, sourceUpdater = _ref.sourceUpdater, action = _ref.action, doneFn = _ref.doneFn, name = _ref.name;
                sourceUpdater.queue.push({
                    type: type,
                    action: action,
                    doneFn: doneFn,
                    name: name
                }), shiftQueue(type, sourceUpdater);
            }, onUpdateend = function(type, sourceUpdater) {
                return function(e) {
                    if (sourceUpdater.queuePending[type]) {
                        var doneFn = sourceUpdater.queuePending[type].doneFn;
                        sourceUpdater.queuePending[type] = null, doneFn && doneFn(sourceUpdater[type + "Error_"]);
                    }
                    shiftQueue(type, sourceUpdater);
                };
            }, SourceUpdater = function(_videojs$EventTarget) {
                function SourceUpdater(mediaSource) {
                    var _this;
                    return (_this = _videojs$EventTarget.call(this) || this).mediaSource = mediaSource, _this.sourceopenListener_ = function() {
                        return shiftQueue("mediaSource", (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this));
                    }, _this.mediaSource.addEventListener("sourceopen", _this.sourceopenListener_), _this.logger_ = logger("SourceUpdater"), _this.audioTimestampOffset_ = 0, _this.videoTimestampOffset_ = 0, _this.queue = [], _this.queuePending = {
                        audio: null,
                        video: null
                    }, _this.delayedAudioAppendQueue_ = [], _this.videoAppendQueued_ = !1, _this.codecs = {}, _this.onVideoUpdateEnd_ = onUpdateend("video", (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), _this.onAudioUpdateEnd_ = onUpdateend("audio", (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), _this.onVideoError_ = function(e) {
                        _this.videoError_ = e;
                    }, _this.onAudioError_ = function(e) {
                        _this.audioError_ = e;
                    }, _this.createdSourceBuffers_ = !1, _this.initializedEme_ = !1, _this.triggeredReady_ = !1, _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SourceUpdater, _videojs$EventTarget);
                var _proto = SourceUpdater.prototype;
                return _proto.initializedEme = function() {
                    this.initializedEme_ = !0, this.triggerReady();
                }, _proto.hasCreatedSourceBuffers = function() {
                    return this.createdSourceBuffers_;
                }, _proto.hasInitializedAnyEme = function() {
                    return this.initializedEme_;
                }, _proto.ready = function() {
                    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
                }, _proto.createSourceBuffers = function(codecs) {
                    this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(codecs), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady());
                }, _proto.triggerReady = function() {
                    this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready"));
                }, _proto.addSourceBuffer = function(type, codec) {
                    pushQueue({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: actions.addSourceBuffer(type, codec),
                        name: "addSourceBuffer"
                    });
                }, _proto.abort = function(type) {
                    pushQueue({
                        type: type,
                        sourceUpdater: this,
                        action: actions.abort(type),
                        name: "abort"
                    });
                }, _proto.removeSourceBuffer = function(type) {
                    if (!this.canRemoveSourceBuffer()) {
                        videojs.log.error("removeSourceBuffer is not supported!");
                        return;
                    }
                    pushQueue({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: actions.removeSourceBuffer(type),
                        name: "removeSourceBuffer"
                    });
                }, _proto.canRemoveSourceBuffer = function() {
                    return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && global_window__WEBPACK_IMPORTED_MODULE_0___default().MediaSource && global_window__WEBPACK_IMPORTED_MODULE_0___default().MediaSource.prototype && "function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().MediaSource.prototype.removeSourceBuffer;
                }, SourceUpdater.canChangeType = function() {
                    return global_window__WEBPACK_IMPORTED_MODULE_0___default().SourceBuffer && global_window__WEBPACK_IMPORTED_MODULE_0___default().SourceBuffer.prototype && "function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().SourceBuffer.prototype.changeType;
                }, _proto.canChangeType = function() {
                    return this.constructor.canChangeType();
                }, _proto.changeType = function(type, codec) {
                    if (!this.canChangeType()) {
                        videojs.log.error("changeType is not supported!");
                        return;
                    }
                    pushQueue({
                        type: type,
                        sourceUpdater: this,
                        action: actions.changeType(codec),
                        name: "changeType"
                    });
                }, _proto.addOrChangeSourceBuffers = function(codecs) {
                    var _this2 = this;
                    if (!codecs || "object" != typeof codecs || 0 === Object.keys(codecs).length) throw Error("Cannot addOrChangeSourceBuffers to undefined codecs");
                    Object.keys(codecs).forEach(function(type) {
                        var codec = codecs[type];
                        if (!_this2.hasCreatedSourceBuffers()) return _this2.addSourceBuffer(type, codec);
                        _this2.canChangeType() && _this2.changeType(type, codec);
                    });
                }, _proto.appendBuffer = function(options, doneFn) {
                    var _this3 = this, segmentInfo = options.segmentInfo, type = options.type, bytes = options.bytes;
                    if (this.processedAppend_ = !0, "audio" === type && this.videoBuffer && !this.videoAppendQueued_) {
                        this.delayedAudioAppendQueue_.push([
                            options,
                            doneFn
                        ]), this.logger_("delayed audio append of " + bytes.length + " until video append");
                        return;
                    }
                    if (pushQueue({
                        type: type,
                        sourceUpdater: this,
                        action: actions.appendBuffer(bytes, segmentInfo || {
                            mediaIndex: -1
                        }, doneFn),
                        doneFn: doneFn,
                        name: "appendBuffer"
                    }), "video" === type) {
                        if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length) return;
                        var queue = this.delayedAudioAppendQueue_.slice();
                        this.logger_("queuing delayed audio " + queue.length + " appendBuffers"), this.delayedAudioAppendQueue_.length = 0, queue.forEach(function(que) {
                            _this3.appendBuffer.apply(_this3, que);
                        });
                    }
                }, _proto.audioBuffered = function() {
                    return inSourceBuffers(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs.createTimeRange();
                }, _proto.videoBuffered = function() {
                    return inSourceBuffers(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs.createTimeRange();
                }, _proto.buffered = function() {
                    var video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
                    return audio && !video ? this.audioBuffered() : video && !audio ? this.videoBuffered() : bufferIntersection(this.audioBuffered(), this.videoBuffered());
                }, _proto.setDuration = function(duration, doneFn) {
                    void 0 === doneFn && (doneFn = noop), pushQueue({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: actions.duration(duration),
                        name: "duration",
                        doneFn: doneFn
                    });
                }, _proto.endOfStream = function(error, doneFn) {
                    void 0 === error && (error = null), void 0 === doneFn && (doneFn = noop), "string" != typeof error && (error = void 0), pushQueue({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: actions.endOfStream(error),
                        name: "endOfStream",
                        doneFn: doneFn
                    });
                }, _proto.removeAudio = function(start, end, done) {
                    if (void 0 === done && (done = noop), !this.audioBuffered().length || 0 === this.audioBuffered().end(0)) {
                        done();
                        return;
                    }
                    pushQueue({
                        type: "audio",
                        sourceUpdater: this,
                        action: actions.remove(start, end),
                        doneFn: done,
                        name: "remove"
                    });
                }, _proto.removeVideo = function(start, end, done) {
                    if (void 0 === done && (done = noop), !this.videoBuffered().length || 0 === this.videoBuffered().end(0)) {
                        done();
                        return;
                    }
                    pushQueue({
                        type: "video",
                        sourceUpdater: this,
                        action: actions.remove(start, end),
                        doneFn: done,
                        name: "remove"
                    });
                }, _proto.updating = function() {
                    return !!(_updating("audio", this) || _updating("video", this));
                }, _proto.audioTimestampOffset = function(offset) {
                    return void 0 !== offset && this.audioBuffer && this.audioTimestampOffset_ !== offset && (pushQueue({
                        type: "audio",
                        sourceUpdater: this,
                        action: actions.timestampOffset(offset),
                        name: "timestampOffset"
                    }), this.audioTimestampOffset_ = offset), this.audioTimestampOffset_;
                }, _proto.videoTimestampOffset = function(offset) {
                    return void 0 !== offset && this.videoBuffer && this.videoTimestampOffset !== offset && (pushQueue({
                        type: "video",
                        sourceUpdater: this,
                        action: actions.timestampOffset(offset),
                        name: "timestampOffset"
                    }), this.videoTimestampOffset_ = offset), this.videoTimestampOffset_;
                }, _proto.audioQueueCallback = function(callback) {
                    this.audioBuffer && pushQueue({
                        type: "audio",
                        sourceUpdater: this,
                        action: actions.callback(callback),
                        name: "callback"
                    });
                }, _proto.videoQueueCallback = function(callback) {
                    this.videoBuffer && pushQueue({
                        type: "video",
                        sourceUpdater: this,
                        action: actions.callback(callback),
                        name: "callback"
                    });
                }, _proto.dispose = function() {
                    var _this4 = this;
                    this.trigger("dispose"), bufferTypes.forEach(function(type) {
                        _this4.abort(type), _this4.canRemoveSourceBuffer() ? _this4.removeSourceBuffer(type) : _this4[type + "QueueCallback"](function() {
                            return cleanupBuffer(type, _this4);
                        });
                    }), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off();
                }, SourceUpdater;
            }(videojs.EventTarget), uint8ToUtf8 = function(uintArray) {
                return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
            }, VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map(function(_char3) {
                return _char3.charCodeAt(0);
            })), VTTSegmentLoader = function(_SegmentLoader) {
                function VTTSegmentLoader(settings, options) {
                    var _this;
                    return void 0 === options && (options = {}), (_this = _SegmentLoader.call(this, settings, options) || this).mediaSource_ = null, _this.subtitlesTrack_ = null, _this.loaderType_ = "subtitle", _this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks, _this.shouldSaveSegmentTimingInfo_ = !1, _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VTTSegmentLoader, _SegmentLoader);
                var _proto = VTTSegmentLoader.prototype;
                return _proto.createTransmuxer_ = function() {
                    return null;
                }, _proto.buffered_ = function() {
                    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) return videojs.createTimeRanges();
                    var cues = this.subtitlesTrack_.cues, start = cues[0].startTime, end = cues[cues.length - 1].startTime;
                    return videojs.createTimeRanges([
                        [
                            start,
                            end
                        ]
                    ]);
                }, _proto.initSegmentForMap = function(map, set) {
                    if (void 0 === set && (set = !1), !map) return null;
                    var id = initSegmentId(map), storedMap = this.initSegments_[id];
                    if (set && !storedMap && map.bytes) {
                        var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength, combinedSegment = new Uint8Array(combinedByteLength);
                        combinedSegment.set(map.bytes), combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength), this.initSegments_[id] = storedMap = {
                            resolvedUri: map.resolvedUri,
                            byterange: map.byterange,
                            bytes: combinedSegment
                        };
                    }
                    return storedMap || map;
                }, _proto.couldBeginLoading_ = function() {
                    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
                }, _proto.init_ = function() {
                    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
                }, _proto.track = function(_track) {
                    return void 0 === _track || (this.subtitlesTrack_ = _track, "INIT" === this.state && this.couldBeginLoading_() && this.init_()), this.subtitlesTrack_;
                }, _proto.remove = function(start, end) {
                    removeCuesFromTrack(start, end, this.subtitlesTrack_);
                }, _proto.fillBuffer_ = function() {
                    var _this2 = this, segmentInfo = this.chooseNextRequest_();
                    if (segmentInfo) {
                        if (null === this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline)) {
                            this.syncController_.one("timestampoffset", function() {
                                _this2.state = "READY", _this2.paused() || _this2.monitorBuffer_();
                            }), this.state = "WAITING_ON_TIMELINE";
                            return;
                        }
                        this.loadSegment_(segmentInfo);
                    }
                }, _proto.timestampOffsetForSegment_ = function() {
                    return null;
                }, _proto.chooseNextRequest_ = function() {
                    return this.skipEmptySegments_(_SegmentLoader.prototype.chooseNextRequest_.call(this));
                }, _proto.skipEmptySegments_ = function(segmentInfo) {
                    for(; segmentInfo && segmentInfo.segment.empty;){
                        if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
                            segmentInfo = null;
                            break;
                        }
                        segmentInfo = this.generateSegmentInfo_({
                            playlist: segmentInfo.playlist,
                            mediaIndex: segmentInfo.mediaIndex + 1,
                            startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
                            isSyncRequest: segmentInfo.isSyncRequest
                        });
                    }
                    return segmentInfo;
                }, _proto.stopForError = function(error) {
                    this.error(error), this.state = "READY", this.pause(), this.trigger("error");
                }, _proto.segmentRequestFinished_ = function(error, simpleSegment, result) {
                    var _this3 = this;
                    if (!this.subtitlesTrack_) {
                        this.state = "READY";
                        return;
                    }
                    if (this.saveTransferStats_(simpleSegment.stats), !this.pendingSegment_) {
                        this.state = "READY", this.mediaRequestsAborted += 1;
                        return;
                    }
                    if (error) {
                        error.code === REQUEST_ERRORS.TIMEOUT && this.handleTimeout_(), error.code === REQUEST_ERRORS.ABORTED ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, this.stopForError(error);
                        return;
                    }
                    var segmentInfo = this.pendingSegment_;
                    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats), this.state = "APPENDING", this.trigger("appending");
                    var segment = segmentInfo.segment;
                    if (segment.map && (segment.map.bytes = simpleSegment.map.bytes), segmentInfo.bytes = simpleSegment.bytes, "function" != typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {
                        var loadHandler, errorHandler = function() {
                            _this3.subtitlesTrack_.tech_.off("vttjsloaded", loadHandler), _this3.stopForError({
                                message: "Error loading vtt.js"
                            });
                        };
                        loadHandler = function() {
                            _this3.subtitlesTrack_.tech_.off("vttjserror", errorHandler), _this3.segmentRequestFinished_(error, simpleSegment, result);
                        }, this.state = "WAITING_ON_VTTJS", this.subtitlesTrack_.tech_.one("vttjsloaded", loadHandler), this.subtitlesTrack_.tech_.one("vttjserror", errorHandler);
                        return;
                    }
                    segment.requested = !0;
                    try {
                        this.parseVTTCues_(segmentInfo);
                    } catch (e) {
                        this.stopForError({
                            message: e.message
                        });
                        return;
                    }
                    if (this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_), segmentInfo.cues.length ? segmentInfo.timingInfo = {
                        start: segmentInfo.cues[0].startTime,
                        end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
                    } : segmentInfo.timingInfo = {
                        start: segmentInfo.startOfSegment,
                        end: segmentInfo.startOfSegment + segmentInfo.duration
                    }, segmentInfo.isSyncRequest) {
                        this.trigger("syncinfoupdate"), this.pendingSegment_ = null, this.state = "READY";
                        return;
                    }
                    segmentInfo.byteLength = segmentInfo.bytes.byteLength, this.mediaSecondsLoaded += segment.duration, segmentInfo.cues.forEach(function(cue) {
                        _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
                    }), removeDuplicateCuesFromTrack(this.subtitlesTrack_), this.handleAppendsDone_();
                }, _proto.handleData_ = function() {}, _proto.updateTimingInfoEnd_ = function() {}, _proto.parseVTTCues_ = function(segmentInfo) {
                    var decoder, decodeBytesToString = !1;
                    "function" == typeof global_window__WEBPACK_IMPORTED_MODULE_0___default().TextDecoder ? decoder = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).TextDecoder("utf8") : (decoder = global_window__WEBPACK_IMPORTED_MODULE_0___default().WebVTT.StringDecoder(), decodeBytesToString = !0);
                    var parser = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).WebVTT.Parser(global_window__WEBPACK_IMPORTED_MODULE_0___default(), global_window__WEBPACK_IMPORTED_MODULE_0___default().vttjs, decoder);
                    if (segmentInfo.cues = [], segmentInfo.timestampmap = {
                        MPEGTS: 0,
                        LOCAL: 0
                    }, parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues), parser.ontimestampmap = function(map) {
                        segmentInfo.timestampmap = map;
                    }, parser.onparsingerror = function(error) {
                        videojs.log.warn("Error encountered when parsing cues: " + error.message);
                    }, segmentInfo.segment.map) {
                        var mapData = segmentInfo.segment.map.bytes;
                        decodeBytesToString && (mapData = uint8ToUtf8(mapData)), parser.parse(mapData);
                    }
                    var segmentData = segmentInfo.bytes;
                    decodeBytesToString && (segmentData = uint8ToUtf8(segmentData)), parser.parse(segmentData), parser.flush();
                }, _proto.updateTimeMapping_ = function(segmentInfo, mappingObj, playlist) {
                    var segment = segmentInfo.segment;
                    if (mappingObj) {
                        if (!segmentInfo.cues.length) {
                            segment.empty = !0;
                            return;
                        }
                        var timestampmap = segmentInfo.timestampmap, diff = timestampmap.MPEGTS / mux_js_lib_utils_clock__WEBPACK_IMPORTED_MODULE_14__.ONE_SECOND_IN_TS - timestampmap.LOCAL + mappingObj.mapping;
                        if (segmentInfo.cues.forEach(function(cue) {
                            cue.startTime += diff, cue.endTime += diff;
                        }), !playlist.syncInfo) {
                            var firstStart = segmentInfo.cues[0].startTime, lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
                            playlist.syncInfo = {
                                mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
                                time: Math.min(firstStart, lastStart - segment.duration)
                            };
                        }
                    }
                }, VTTSegmentLoader;
            }(SegmentLoader), findAdCue = function(track, mediaTime) {
                for(var cues = track.cues, i = 0; i < cues.length; i++){
                    var cue = cues[i];
                    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) return cue;
                }
                return null;
            }, updateAdCues = function(media, track, offset) {
                if (void 0 === offset && (offset = 0), media.segments) for(var cue, mediaTime = offset, i = 0; i < media.segments.length; i++){
                    var segment = media.segments[i];
                    if (cue || (cue = findAdCue(track, mediaTime + segment.duration / 2)), cue) {
                        if ("cueIn" in segment) {
                            cue.endTime = mediaTime, cue.adEndTime = mediaTime, mediaTime += segment.duration, cue = null;
                            continue;
                        }
                        if (mediaTime < cue.endTime) {
                            mediaTime += segment.duration;
                            continue;
                        }
                        cue.endTime += segment.duration;
                    } else if ("cueOut" in segment && ((cue = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut)).adStartTime = mediaTime, cue.adEndTime = mediaTime + parseFloat(segment.cueOut), track.addCue(cue)), "cueOutCont" in segment) {
                        var _segment$cueOutCont$s = segment.cueOutCont.split("/").map(parseFloat), adOffset = _segment$cueOutCont$s[0], adTotal = _segment$cueOutCont$s[1];
                        (cue = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).VTTCue(mediaTime, mediaTime + segment.duration, "")).adStartTime = mediaTime - adOffset, cue.adEndTime = cue.adStartTime + adTotal, track.addCue(cue);
                    }
                    mediaTime += segment.duration;
                }
            }, syncPointStrategies = [
                {
                    name: "VOD",
                    run: function(syncController, playlist, duration, currentTimeline, currentTime) {
                        return duration !== 1 / 0 ? {
                            time: 0,
                            segmentIndex: 0,
                            partIndex: null
                        } : null;
                    }
                },
                {
                    name: "ProgramDateTime",
                    run: function(syncController, playlist, duration, currentTimeline, currentTime) {
                        if (!Object.keys(syncController.timelineToDatetimeMappings).length) return null;
                        var syncPoint = null, lastDistance = null, partsAndSegments = getPartsAndSegments(playlist);
                        currentTime = currentTime || 0;
                        for(var i = 0; i < partsAndSegments.length; i++){
                            var partAndSegment = partsAndSegments[playlist.endList || 0 === currentTime ? i : partsAndSegments.length - (i + 1)], segment = partAndSegment.segment, datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
                            if (datetimeMapping && segment.dateTimeObject) {
                                var start = segment.dateTimeObject.getTime() / 1000 + datetimeMapping;
                                if (segment.parts && "number" == typeof partAndSegment.partIndex) for(var z = 0; z < partAndSegment.partIndex; z++)start += segment.parts[z].duration;
                                var distance = Math.abs(currentTime - start);
                                if (null !== lastDistance && (0 === distance || lastDistance < distance)) break;
                                lastDistance = distance, syncPoint = {
                                    time: start,
                                    segmentIndex: partAndSegment.segmentIndex,
                                    partIndex: partAndSegment.partIndex
                                };
                            }
                        }
                        return syncPoint;
                    }
                },
                {
                    name: "Segment",
                    run: function(syncController, playlist, duration, currentTimeline, currentTime) {
                        var syncPoint = null, lastDistance = null;
                        currentTime = currentTime || 0;
                        for(var partsAndSegments = getPartsAndSegments(playlist), i = 0; i < partsAndSegments.length; i++){
                            var partAndSegment = partsAndSegments[playlist.endList || 0 === currentTime ? i : partsAndSegments.length - (i + 1)], segment = partAndSegment.segment, start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
                            if (segment.timeline === currentTimeline && void 0 !== start) {
                                var distance = Math.abs(currentTime - start);
                                if (null !== lastDistance && lastDistance < distance) break;
                                (!syncPoint || null === lastDistance || lastDistance >= distance) && (lastDistance = distance, syncPoint = {
                                    time: start,
                                    segmentIndex: partAndSegment.segmentIndex,
                                    partIndex: partAndSegment.partIndex
                                });
                            }
                        }
                        return syncPoint;
                    }
                },
                {
                    name: "Discontinuity",
                    run: function(syncController, playlist, duration, currentTimeline, currentTime) {
                        var syncPoint = null;
                        if (currentTime = currentTime || 0, playlist.discontinuityStarts && playlist.discontinuityStarts.length) for(var lastDistance = null, i = 0; i < playlist.discontinuityStarts.length; i++){
                            var segmentIndex = playlist.discontinuityStarts[i], discontinuity = playlist.discontinuitySequence + i + 1, discontinuitySync = syncController.discontinuities[discontinuity];
                            if (discontinuitySync) {
                                var distance = Math.abs(currentTime - discontinuitySync.time);
                                if (null !== lastDistance && lastDistance < distance) break;
                                (!syncPoint || null === lastDistance || lastDistance >= distance) && (lastDistance = distance, syncPoint = {
                                    time: discontinuitySync.time,
                                    segmentIndex: segmentIndex,
                                    partIndex: null
                                });
                            }
                        }
                        return syncPoint;
                    }
                },
                {
                    name: "Playlist",
                    run: function(syncController, playlist, duration, currentTimeline, currentTime) {
                        return playlist.syncInfo ? {
                            time: playlist.syncInfo.time,
                            segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
                            partIndex: null
                        } : null;
                    }
                }
            ], SyncController = function(_videojs$EventTarget) {
                function SyncController(options) {
                    var _this;
                    return (_this = _videojs$EventTarget.call(this) || this).timelines = [], _this.discontinuities = [], _this.timelineToDatetimeMappings = {}, _this.logger_ = logger("SyncController"), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(SyncController, _videojs$EventTarget);
                var _proto = SyncController.prototype;
                return _proto.getSyncPoint = function(playlist, duration, currentTimeline, currentTime) {
                    var syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);
                    return syncPoints.length ? this.selectSyncPoint_(syncPoints, {
                        key: "time",
                        value: currentTime
                    }) : null;
                }, _proto.getExpiredTime = function(playlist, duration) {
                    if (!playlist || !playlist.segments) return null;
                    var syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0);
                    if (!syncPoints.length) return null;
                    var syncPoint = this.selectSyncPoint_(syncPoints, {
                        key: "segmentIndex",
                        value: 0
                    });
                    return syncPoint.segmentIndex > 0 && (syncPoint.time *= -1), Math.abs(syncPoint.time + sumDurations({
                        defaultDuration: playlist.targetDuration,
                        durationList: playlist.segments,
                        startIndex: syncPoint.segmentIndex,
                        endIndex: 0
                    }));
                }, _proto.runStrategies_ = function(playlist, duration, currentTimeline, currentTime) {
                    for(var syncPoints = [], i = 0; i < syncPointStrategies.length; i++){
                        var strategy = syncPointStrategies[i], syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);
                        syncPoint && (syncPoint.strategy = strategy.name, syncPoints.push({
                            strategy: strategy.name,
                            syncPoint: syncPoint
                        }));
                    }
                    return syncPoints;
                }, _proto.selectSyncPoint_ = function(syncPoints, target) {
                    for(var bestSyncPoint = syncPoints[0].syncPoint, bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value), bestStrategy = syncPoints[0].strategy, i = 1; i < syncPoints.length; i++){
                        var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
                        newDistance < bestDistance && (bestDistance = newDistance, bestSyncPoint = syncPoints[i].syncPoint, bestStrategy = syncPoints[i].strategy);
                    }
                    return this.logger_("syncPoint for [" + target.key + ": " + target.value + "] chosen with strategy [" + bestStrategy + "]: [time:" + bestSyncPoint.time + ", segmentIndex:" + bestSyncPoint.segmentIndex + ("number" == typeof bestSyncPoint.partIndex ? ",partIndex:" + bestSyncPoint.partIndex : "") + "]"), bestSyncPoint;
                }, _proto.saveExpiredSegmentInfo = function(oldPlaylist, newPlaylist) {
                    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
                    if (mediaSequenceDiff > 86400) {
                        videojs.log.warn("Not saving expired segment info. Media sequence gap " + mediaSequenceDiff + " is too large.");
                        return;
                    }
                    for(var i = mediaSequenceDiff - 1; i >= 0; i--){
                        var lastRemovedSegment = oldPlaylist.segments[i];
                        if (lastRemovedSegment && void 0 !== lastRemovedSegment.start) {
                            newPlaylist.syncInfo = {
                                mediaSequence: oldPlaylist.mediaSequence + i,
                                time: lastRemovedSegment.start
                            }, this.logger_("playlist refresh sync: [time:" + newPlaylist.syncInfo.time + ", mediaSequence: " + newPlaylist.syncInfo.mediaSequence + "]"), this.trigger("syncinfoupdate");
                            break;
                        }
                    }
                }, _proto.setDateTimeMappingForStart = function(playlist) {
                    if (this.timelineToDatetimeMappings = {}, playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
                        var firstSegment = playlist.segments[0], playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1000;
                        this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
                    }
                }, _proto.saveSegmentTimingInfo = function(_ref) {
                    var segmentInfo = _ref.segmentInfo, shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping, didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping), segment = segmentInfo.segment;
                    didCalculateSegmentTimeMapping && (this.saveDiscontinuitySyncInfo_(segmentInfo), segmentInfo.playlist.syncInfo || (segmentInfo.playlist.syncInfo = {
                        mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
                        time: segment.start
                    }));
                    var dateTime = segment.dateTimeObject;
                    segment.discontinuity && shouldSaveTimelineMapping && dateTime && (this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1000));
                }, _proto.timestampOffsetForTimeline = function(timeline) {
                    return void 0 === this.timelines[timeline] ? null : this.timelines[timeline].time;
                }, _proto.mappingForTimeline = function(timeline) {
                    return void 0 === this.timelines[timeline] ? null : this.timelines[timeline].mapping;
                }, _proto.calculateSegmentTimeMapping_ = function(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
                    var start, end, segment = segmentInfo.segment, part = segmentInfo.part, mappingObj = this.timelines[segmentInfo.timeline];
                    if ("number" == typeof segmentInfo.timestampOffset) mappingObj = {
                        time: segmentInfo.startOfSegment,
                        mapping: segmentInfo.startOfSegment - timingInfo.start
                    }, shouldSaveTimelineMapping && (this.timelines[segmentInfo.timeline] = mappingObj, this.trigger("timestampoffset"), this.logger_("time mapping for timeline " + segmentInfo.timeline + ": [time: " + mappingObj.time + "] [mapping: " + mappingObj.mapping + "]")), start = segmentInfo.startOfSegment, end = timingInfo.end + mappingObj.mapping;
                    else {
                        if (!mappingObj) return !1;
                        start = timingInfo.start + mappingObj.mapping, end = timingInfo.end + mappingObj.mapping;
                    }
                    return part && (part.start = start, part.end = end), (!segment.start || start < segment.start) && (segment.start = start), segment.end = end, !0;
                }, _proto.saveDiscontinuitySyncInfo_ = function(segmentInfo) {
                    var playlist = segmentInfo.playlist, segment = segmentInfo.segment;
                    if (segment.discontinuity) this.discontinuities[segment.timeline] = {
                        time: segment.start,
                        accuracy: 0
                    };
                    else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) for(var i = 0; i < playlist.discontinuityStarts.length; i++){
                        var segmentIndex = playlist.discontinuityStarts[i], discontinuity = playlist.discontinuitySequence + i + 1, mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex, accuracy = Math.abs(mediaIndexDiff);
                        if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
                            var time = void 0;
                            time = mediaIndexDiff < 0 ? segment.start - sumDurations({
                                defaultDuration: playlist.targetDuration,
                                durationList: playlist.segments,
                                startIndex: segmentInfo.mediaIndex,
                                endIndex: segmentIndex
                            }) : segment.end + sumDurations({
                                defaultDuration: playlist.targetDuration,
                                durationList: playlist.segments,
                                startIndex: segmentInfo.mediaIndex + 1,
                                endIndex: segmentIndex
                            }), this.discontinuities[discontinuity] = {
                                time: time,
                                accuracy: accuracy
                            };
                        }
                    }
                }, _proto.dispose = function() {
                    this.trigger("dispose"), this.off();
                }, SyncController;
            }(videojs.EventTarget), TimelineChangeController = function(_videojs$EventTarget) {
                function TimelineChangeController() {
                    var _this;
                    return (_this = _videojs$EventTarget.call(this) || this).pendingTimelineChanges_ = {}, _this.lastTimelineChanges_ = {}, _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(TimelineChangeController, _videojs$EventTarget);
                var _proto = TimelineChangeController.prototype;
                return _proto.clearPendingTimelineChange = function(type) {
                    this.pendingTimelineChanges_[type] = null, this.trigger("pendingtimelinechange");
                }, _proto.pendingTimelineChange = function(_ref) {
                    var type = _ref.type, from = _ref.from, to = _ref.to;
                    return "number" == typeof from && "number" == typeof to && (this.pendingTimelineChanges_[type] = {
                        type: type,
                        from: from,
                        to: to
                    }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[type];
                }, _proto.lastTimelineChange = function(_ref2) {
                    var type = _ref2.type, from = _ref2.from, to = _ref2.to;
                    return "number" == typeof from && "number" == typeof to && (this.lastTimelineChanges_[type] = {
                        type: type,
                        from: from,
                        to: to
                    }, delete this.pendingTimelineChanges_[type], this.trigger("timelinechange")), this.lastTimelineChanges_[type];
                }, _proto.dispose = function() {
                    this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off();
                }, TimelineChangeController;
            }(videojs.EventTarget), Decrypter = factory(transform(getWorkerString(function() {
                function createCommonjsModule(fn, basedir, module) {
                    return fn(module = {
                        path: basedir,
                        exports: {},
                        require: function(path, base) {
                            return function() {
                                throw Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
                            }(path, null == base ? module.path : base);
                        }
                    }, module.exports), module.exports;
                }
                var createClass = createCommonjsModule(function(module) {
                    function _defineProperties(target, props) {
                        for(var i = 0; i < props.length; i++){
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    module.exports = function(Constructor, protoProps, staticProps) {
                        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
                    }, module.exports.default = module.exports, module.exports.__esModule = !0;
                }), setPrototypeOf = createCommonjsModule(function(module) {
                    function _setPrototypeOf(o, p) {
                        return module.exports = _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                            return o.__proto__ = p, o;
                        }, module.exports.default = module.exports, module.exports.__esModule = !0, _setPrototypeOf(o, p);
                    }
                    module.exports = _setPrototypeOf, module.exports.default = module.exports, module.exports.__esModule = !0;
                }), inheritsLoose = createCommonjsModule(function(module) {
                    module.exports = function(subClass, superClass) {
                        subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, setPrototypeOf(subClass, superClass);
                    }, module.exports.default = module.exports, module.exports.__esModule = !0;
                }), Stream = function() {
                    function Stream() {
                        this.listeners = {};
                    }
                    var _proto = Stream.prototype;
                    return _proto.on = function(type, listener) {
                        this.listeners[type] || (this.listeners[type] = []), this.listeners[type].push(listener);
                    }, _proto.off = function(type, listener) {
                        if (!this.listeners[type]) return !1;
                        var index = this.listeners[type].indexOf(listener);
                        return this.listeners[type] = this.listeners[type].slice(0), this.listeners[type].splice(index, 1), index > -1;
                    }, _proto.trigger = function(type) {
                        var callbacks = this.listeners[type];
                        if (callbacks) {
                            if (2 == arguments.length) for(var length = callbacks.length, i = 0; i < length; ++i)callbacks[i].call(this, arguments[1]);
                            else for(var args = Array.prototype.slice.call(arguments, 1), _length = callbacks.length, _i = 0; _i < _length; ++_i)callbacks[_i].apply(this, args);
                        }
                    }, _proto.dispose = function() {
                        this.listeners = {};
                    }, _proto.pipe = function(destination) {
                        this.on("data", function(data) {
                            destination.push(data);
                        });
                    }, Stream;
                }(), precompute = function() {
                    var i, x, xInv, x2, x4, s, tEnc, tDec, tables = [
                        [
                            [],
                            [],
                            [],
                            [],
                            []
                        ],
                        [
                            [],
                            [],
                            [],
                            [],
                            []
                        ]
                    ], encTable = tables[0], decTable = tables[1], sbox = encTable[4], sboxInv = decTable[4], d = [], th = [];
                    for(i = 0; i < 256; i++)th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
                    for(x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1)for(i = 0, s = (s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4) >> 8 ^ 255 & s ^ 99, sbox[x] = s, sboxInv[s] = x, tDec = 0x1010101 * d[x4 = d[x2 = d[x]]] ^ 0x10001 * x4 ^ 0x101 * x2 ^ 0x1010100 * x, tEnc = 0x101 * d[s] ^ 0x1010100 * s; i < 4; i++)encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8, decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
                    for(i = 0; i < 5; i++)encTable[i] = encTable[i].slice(0), decTable[i] = decTable[i].slice(0);
                    return tables;
                }, aesTables = null, AES = function() {
                    function AES(key) {
                        aesTables || (aesTables = precompute()), this._tables = [
                            [
                                aesTables[0][0].slice(),
                                aesTables[0][1].slice(),
                                aesTables[0][2].slice(),
                                aesTables[0][3].slice(),
                                aesTables[0][4].slice()
                            ],
                            [
                                aesTables[1][0].slice(),
                                aesTables[1][1].slice(),
                                aesTables[1][2].slice(),
                                aesTables[1][3].slice(),
                                aesTables[1][4].slice()
                            ]
                        ];
                        var i, j, tmp, sbox = this._tables[0][4], decTable = this._tables[1], keyLen = key.length, rcon = 1;
                        if (4 !== keyLen && 6 !== keyLen && 8 !== keyLen) throw Error("Invalid aes key size");
                        var encKey = key.slice(0), decKey = [];
                        for(this._key = [
                            encKey,
                            decKey
                        ], i = keyLen; i < 4 * keyLen + 28; i++)tmp = encKey[i - 1], (i % keyLen == 0 || 8 === keyLen && i % keyLen == 4) && (tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[255 & tmp], i % keyLen == 0 && (tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24, rcon = rcon << 1 ^ (rcon >> 7) * 283)), encKey[i] = encKey[i - keyLen] ^ tmp;
                        for(j = 0; i; j++, i--)tmp = encKey[3 & j ? i : i - 4], i <= 4 || j < 4 ? decKey[j] = tmp : decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[255 & tmp]];
                    }
                    return AES.prototype.decrypt = function(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
                        var a2, b2, c2, i, key = this._key[1], a = encrypted0 ^ key[0], b = encrypted3 ^ key[1], c = encrypted2 ^ key[2], d = encrypted1 ^ key[3], nInnerRounds = key.length / 4 - 2, kIndex = 4, table = this._tables[1], table0 = table[0], table1 = table[1], table2 = table[2], table3 = table[3], sbox = table[4];
                        for(i = 0; i < nInnerRounds; i++)a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[255 & d] ^ key[kIndex], b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[255 & a] ^ key[kIndex + 1], c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[255 & b] ^ key[kIndex + 2], d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[255 & c] ^ key[kIndex + 3], kIndex += 4, a = a2, b = b2, c = c2;
                        for(i = 0; i < 4; i++)out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[255 & d] ^ key[kIndex++], a2 = a, a = b, b = c, c = d, d = a2;
                    }, AES;
                }(), AsyncStream = function(_Stream) {
                    function AsyncStream() {
                        var _this;
                        return (_this = _Stream.call(this, Stream) || this).jobs = [], _this.delay = 1, _this.timeout_ = null, _this;
                    }
                    inheritsLoose(AsyncStream, _Stream);
                    var _proto = AsyncStream.prototype;
                    return _proto.processJob_ = function() {
                        this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null;
                    }, _proto.push = function(job) {
                        this.jobs.push(job), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay));
                    }, AsyncStream;
                }(Stream), ntoh = function(word) {
                    return word << 24 | (0xff00 & word) << 8 | (0xff0000 & word) >> 8 | word >>> 24;
                }, decrypt = function(encrypted, key, initVector) {
                    var init0, init1, init2, init3, encrypted0, encrypted1, encrypted2, encrypted3, wordIx, encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2), decipher = new AES(Array.prototype.slice.call(key)), decrypted = new Uint8Array(encrypted.byteLength), decrypted32 = new Int32Array(decrypted.buffer);
                    for(wordIx = 0, init0 = initVector[0], init1 = initVector[1], init2 = initVector[2], init3 = initVector[3]; wordIx < encrypted32.length; wordIx += 4)encrypted0 = ntoh(encrypted32[wordIx]), encrypted1 = ntoh(encrypted32[wordIx + 1]), encrypted2 = ntoh(encrypted32[wordIx + 2]), encrypted3 = ntoh(encrypted32[wordIx + 3]), decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx), decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0), decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1), decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2), decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3), init0 = encrypted0, init1 = encrypted1, init2 = encrypted2, init3 = encrypted3;
                    return decrypted;
                }, Decrypter = function() {
                    function Decrypter(encrypted, key, initVector, done) {
                        var step = Decrypter.STEP, encrypted32 = new Int32Array(encrypted.buffer), decrypted = new Uint8Array(encrypted.byteLength), i = 0;
                        for(this.asyncStream_ = new AsyncStream(), this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted)), i = step; i < encrypted32.length; i += step)initVector = new Uint32Array([
                            ntoh(encrypted32[i - 4]),
                            ntoh(encrypted32[i - 3]),
                            ntoh(encrypted32[i - 2]),
                            ntoh(encrypted32[i - 1])
                        ]), this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
                        this.asyncStream_.push(function() {
                            done(null, decrypted.subarray(0, decrypted.byteLength - decrypted[decrypted.byteLength - 1]));
                        });
                    }
                    return Decrypter.prototype.decryptChunk_ = function(encrypted, key, initVector, decrypted) {
                        return function() {
                            var bytes = decrypt(encrypted, key, initVector);
                            decrypted.set(bytes, encrypted.byteOffset);
                        };
                    }, createClass(Decrypter, null, [
                        {
                            key: "STEP",
                            get: function() {
                                return 32000;
                            }
                        }
                    ]), Decrypter;
                }(), createTransferableMessage = function(message) {
                    var transferable = {};
                    return Object.keys(message).forEach(function(key) {
                        var value = message[key];
                        ArrayBuffer.isView(value) ? transferable[key] = {
                            bytes: value.buffer,
                            byteOffset: value.byteOffset,
                            byteLength: value.byteLength
                        } : transferable[key] = value;
                    }), transferable;
                };
                self.onmessage = function(event) {
                    var data = event.data, encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength), key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4), iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
                    new Decrypter(encrypted, key, iv, function(err, bytes) {
                        self.postMessage(createTransferableMessage({
                            source: data.source,
                            decrypted: bytes
                        }), [
                            bytes.buffer
                        ]);
                    });
                };
            }))), audioTrackKind_ = function(properties) {
                var kind = properties.default ? "main" : "alternative";
                return properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (kind = "main-desc"), kind;
            }, stopLoaders = function(segmentLoader, mediaType) {
                segmentLoader.abort(), segmentLoader.pause(), mediaType && mediaType.activePlaylistLoader && (mediaType.activePlaylistLoader.pause(), mediaType.activePlaylistLoader = null);
            }, startLoaders = function(playlistLoader, mediaType) {
                mediaType.activePlaylistLoader = playlistLoader, playlistLoader.load();
            }, onError = {
                AUDIO: function(type, settings) {
                    return function() {
                        var segmentLoader = settings.segmentLoaders[type], mediaType = settings.mediaTypes[type], blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;
                        stopLoaders(segmentLoader, mediaType);
                        var activeTrack = mediaType.activeTrack(), activeGroup = mediaType.activeGroup(), id = (activeGroup.filter(function(group) {
                            return group.default;
                        })[0] || activeGroup[0]).id, defaultTrack = mediaType.tracks[id];
                        if (activeTrack === defaultTrack) {
                            blacklistCurrentPlaylist({
                                message: "Problem encountered loading the default audio track."
                            });
                            return;
                        }
                        for(var trackId in videojs.log.warn("Problem encountered loading the alternate audio track.Switching back to default."), mediaType.tracks)mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
                        mediaType.onTrackChanged();
                    };
                },
                SUBTITLES: function(type, settings) {
                    return function() {
                        var segmentLoader = settings.segmentLoaders[type], mediaType = settings.mediaTypes[type];
                        videojs.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track."), stopLoaders(segmentLoader, mediaType);
                        var track = mediaType.activeTrack();
                        track && (track.mode = "disabled"), mediaType.onTrackChanged();
                    };
                }
            }, setupListeners = {
                AUDIO: function(type, playlistLoader, settings) {
                    if (playlistLoader) {
                        var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type];
                        playlistLoader.on("loadedmetadata", function() {
                            var media = playlistLoader.media();
                            segmentLoader.playlist(media, requestOptions), (!tech.paused() || media.endList && "none" !== tech.preload()) && segmentLoader.load();
                        }), playlistLoader.on("loadedplaylist", function() {
                            segmentLoader.playlist(playlistLoader.media(), requestOptions), tech.paused() || segmentLoader.load();
                        }), playlistLoader.on("error", onError[type](type, settings));
                    }
                },
                SUBTITLES: function(type, playlistLoader, settings) {
                    var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type], mediaType = settings.mediaTypes[type];
                    playlistLoader.on("loadedmetadata", function() {
                        var media = playlistLoader.media();
                        segmentLoader.playlist(media, requestOptions), segmentLoader.track(mediaType.activeTrack()), (!tech.paused() || media.endList && "none" !== tech.preload()) && segmentLoader.load();
                    }), playlistLoader.on("loadedplaylist", function() {
                        segmentLoader.playlist(playlistLoader.media(), requestOptions), tech.paused() || segmentLoader.load();
                    }), playlistLoader.on("error", onError[type](type, settings));
                }
            }, initialize = {
                AUDIO: function(type, settings) {
                    var vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$ = settings.mediaTypes[type], groups = _settings$mediaTypes$.groups, tracks = _settings$mediaTypes$.tracks, logger_ = _settings$mediaTypes$.logger_, masterPlaylistLoader = settings.masterPlaylistLoader, audioOnlyMaster = isAudioOnly(masterPlaylistLoader.master);
                    for(var groupId in (!mediaGroups[type] || 0 === Object.keys(mediaGroups[type]).length) && (mediaGroups[type] = {
                        main: {
                            default: {
                                default: !0
                            }
                        }
                    }, audioOnlyMaster && (mediaGroups[type].main.default.playlists = masterPlaylistLoader.master.playlists)), mediaGroups[type])for(var variantLabel in groups[groupId] || (groups[groupId] = []), mediaGroups[type][groupId]){
                        var properties = mediaGroups[type][groupId][variantLabel], playlistLoader = void 0;
                        if (audioOnlyMaster ? (logger_("AUDIO group '" + groupId + "' label '" + variantLabel + "' is a master playlist"), properties.isMasterPlaylist = !0, playlistLoader = null) : playlistLoader = "vhs-json" === sourceType && properties.playlists ? new PlaylistLoader(properties.playlists[0], vhs, requestOptions) : properties.resolvedUri ? new PlaylistLoader(properties.resolvedUri, vhs, requestOptions) : properties.playlists && "dash" === sourceType ? new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader) : null, properties = videojs.mergeOptions({
                            id: variantLabel,
                            playlistLoader: playlistLoader
                        }, properties), setupListeners[type](type, properties.playlistLoader, settings), groups[groupId].push(properties), void 0 === tracks[variantLabel]) {
                            var track = new videojs.AudioTrack({
                                id: variantLabel,
                                kind: audioTrackKind_(properties),
                                enabled: !1,
                                language: properties.language,
                                default: properties.default,
                                label: variantLabel
                            });
                            tracks[variantLabel] = track;
                        }
                    }
                    segmentLoader.on("error", onError[type](type, settings));
                },
                SUBTITLES: function(type, settings) {
                    var tech = settings.tech, vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$2 = settings.mediaTypes[type], groups = _settings$mediaTypes$2.groups, tracks = _settings$mediaTypes$2.tracks, masterPlaylistLoader = settings.masterPlaylistLoader;
                    for(var groupId in mediaGroups[type])for(var variantLabel in groups[groupId] || (groups[groupId] = []), mediaGroups[type][groupId])if (!mediaGroups[type][groupId][variantLabel].forced) {
                        var properties = mediaGroups[type][groupId][variantLabel], playlistLoader = void 0;
                        if ("hls" === sourceType) playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
                        else if ("dash" === sourceType) {
                            if (!properties.playlists.filter(function(p) {
                                return p.excludeUntil !== 1 / 0;
                            }).length) return;
                            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
                        } else "vhs-json" === sourceType && (playlistLoader = new PlaylistLoader(properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions));
                        if (properties = videojs.mergeOptions({
                            id: variantLabel,
                            playlistLoader: playlistLoader
                        }, properties), setupListeners[type](type, properties.playlistLoader, settings), groups[groupId].push(properties), void 0 === tracks[variantLabel]) {
                            var track = tech.addRemoteTextTrack({
                                id: variantLabel,
                                kind: "subtitles",
                                default: properties.default && properties.autoselect,
                                language: properties.language,
                                label: variantLabel
                            }, !1).track;
                            tracks[variantLabel] = track;
                        }
                    }
                    segmentLoader.on("error", onError[type](type, settings));
                },
                "CLOSED-CAPTIONS": function(type, settings) {
                    var tech = settings.tech, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$3 = settings.mediaTypes[type], groups = _settings$mediaTypes$3.groups, tracks = _settings$mediaTypes$3.tracks;
                    for(var groupId in mediaGroups[type])for(var variantLabel in groups[groupId] || (groups[groupId] = []), mediaGroups[type][groupId]){
                        var properties = mediaGroups[type][groupId][variantLabel];
                        if (/^(?:CC|SERVICE)/.test(properties.instreamId)) {
                            var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {}, newProps = {
                                label: variantLabel,
                                language: properties.language,
                                instreamId: properties.instreamId,
                                default: properties.default && properties.autoselect
                            };
                            if (captionServices[newProps.instreamId] && (newProps = videojs.mergeOptions(newProps, captionServices[newProps.instreamId])), void 0 === newProps.default && delete newProps.default, groups[groupId].push(videojs.mergeOptions({
                                id: variantLabel
                            }, properties)), void 0 === tracks[variantLabel]) {
                                var track = tech.addRemoteTextTrack({
                                    id: newProps.instreamId,
                                    kind: "captions",
                                    default: newProps.default,
                                    language: newProps.language,
                                    label: newProps.label
                                }, !1).track;
                                tracks[variantLabel] = track;
                            }
                        }
                    }
                }
            }, groupMatch = function groupMatch(list, media) {
                for(var i = 0; i < list.length; i++)if (playlistMatch(media, list[i]) || list[i].playlists && groupMatch(list[i].playlists, media)) return !0;
                return !1;
            }, activeTrack = {
                AUDIO: function(type, settings) {
                    return function() {
                        var tracks = settings.mediaTypes[type].tracks;
                        for(var id in tracks)if (tracks[id].enabled) return tracks[id];
                        return null;
                    };
                },
                SUBTITLES: function(type, settings) {
                    return function() {
                        var tracks = settings.mediaTypes[type].tracks;
                        for(var id in tracks)if ("showing" === tracks[id].mode || "hidden" === tracks[id].mode) return tracks[id];
                        return null;
                    };
                }
            }, getActiveGroup = function(type, _ref) {
                var mediaTypes = _ref.mediaTypes;
                return function() {
                    var activeTrack_ = mediaTypes[type].activeTrack();
                    return activeTrack_ ? mediaTypes[type].activeGroup(activeTrack_) : null;
                };
            }, setupMediaGroups = function(settings) {
                [
                    "AUDIO",
                    "SUBTITLES",
                    "CLOSED-CAPTIONS"
                ].forEach(function(type) {
                    initialize[type](type, settings);
                });
                var mediaTypes = settings.mediaTypes, masterPlaylistLoader = settings.masterPlaylistLoader, tech = settings.tech, vhs = settings.vhs, _settings$segmentLoad3 = settings.segmentLoaders, audioSegmentLoader = _settings$segmentLoad3.AUDIO, mainSegmentLoader = _settings$segmentLoad3.main;
                [
                    "AUDIO",
                    "SUBTITLES"
                ].forEach(function(type) {
                    var settings1;
                    mediaTypes[type].activeGroup = function(track) {
                        var masterPlaylistLoader = settings.masterPlaylistLoader, groups = settings.mediaTypes[type].groups, media = masterPlaylistLoader.media();
                        if (!media) return null;
                        var variants = null;
                        media.attributes[type] && (variants = groups[media.attributes[type]]);
                        var groupKeys = Object.keys(groups);
                        if (!variants) {
                            if ("AUDIO" === type && groupKeys.length > 1 && isAudioOnly(settings.master)) for(var i = 0; i < groupKeys.length; i++){
                                var groupPropertyList = groups[groupKeys[i]];
                                if (groupMatch(groupPropertyList, media)) {
                                    variants = groupPropertyList;
                                    break;
                                }
                            }
                            else groups.main ? variants = groups.main : 1 === groupKeys.length && (variants = groups[groupKeys[0]]);
                        }
                        return void 0 === track ? variants : null !== track && variants && variants.filter(function(props) {
                            return props.id === track.id;
                        })[0] || null;
                    }, mediaTypes[type].activeTrack = activeTrack[type](type, settings), mediaTypes[type].onGroupChanged = function() {
                        var _settings$segmentLoad = settings.segmentLoaders, segmentLoader = _settings$segmentLoad[type], mainSegmentLoader = _settings$segmentLoad.main, mediaType = settings.mediaTypes[type], activeTrack = mediaType.activeTrack(), activeGroup = mediaType.getActiveGroup(), previousActiveLoader = mediaType.activePlaylistLoader, lastGroup = mediaType.lastGroup_;
                        if ((!activeGroup || !lastGroup || activeGroup.id !== lastGroup.id) && (mediaType.lastGroup_ = activeGroup, mediaType.lastTrack_ = activeTrack, stopLoaders(segmentLoader, mediaType), activeGroup && !activeGroup.isMasterPlaylist)) {
                            if (!activeGroup.playlistLoader) {
                                previousActiveLoader && mainSegmentLoader.resetEverything();
                                return;
                            }
                            segmentLoader.resyncLoader(), startLoaders(activeGroup.playlistLoader, mediaType);
                        }
                    }, mediaTypes[type].onGroupChanging = (settings1 = settings, function() {
                        var segmentLoader = settings1.segmentLoaders[type];
                        settings1.mediaTypes[type].lastGroup_ = null, segmentLoader.abort(), segmentLoader.pause();
                    }), mediaTypes[type].onTrackChanged = function() {
                        var masterPlaylistLoader = settings.masterPlaylistLoader, _settings$segmentLoad2 = settings.segmentLoaders, segmentLoader = _settings$segmentLoad2[type], mainSegmentLoader = _settings$segmentLoad2.main, mediaType = settings.mediaTypes[type], activeTrack = mediaType.activeTrack(), activeGroup = mediaType.getActiveGroup(), previousActiveLoader = mediaType.activePlaylistLoader, lastTrack = mediaType.lastTrack_;
                        if ((!lastTrack || !activeTrack || lastTrack.id !== activeTrack.id) && (mediaType.lastGroup_ = activeGroup, mediaType.lastTrack_ = activeTrack, stopLoaders(segmentLoader, mediaType), activeGroup)) {
                            if (activeGroup.isMasterPlaylist) {
                                if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) return;
                                var mpc = settings.vhs.masterPlaylistController_, newPlaylist = mpc.selectPlaylist();
                                if (mpc.media() === newPlaylist) return;
                                mediaType.logger_("track change. Switching master audio from " + lastTrack.id + " to " + activeTrack.id), masterPlaylistLoader.pause(), mainSegmentLoader.resetEverything(), mpc.fastQualityChange_(newPlaylist);
                                return;
                            }
                            if ("AUDIO" === type) {
                                if (!activeGroup.playlistLoader) {
                                    mainSegmentLoader.setAudio(!0), mainSegmentLoader.resetEverything();
                                    return;
                                }
                                segmentLoader.setAudio(!0), mainSegmentLoader.setAudio(!1);
                            }
                            if (previousActiveLoader === activeGroup.playlistLoader) {
                                startLoaders(activeGroup.playlistLoader, mediaType);
                                return;
                            }
                            segmentLoader.track && segmentLoader.track(activeTrack), segmentLoader.resetEverything(), startLoaders(activeGroup.playlistLoader, mediaType);
                        }
                    }, mediaTypes[type].getActiveGroup = getActiveGroup(type, settings);
                });
                var audioGroup = mediaTypes.AUDIO.activeGroup();
                if (audioGroup) {
                    var groupId = (audioGroup.filter(function(group) {
                        return group.default;
                    })[0] || audioGroup[0]).id;
                    mediaTypes.AUDIO.tracks[groupId].enabled = !0, mediaTypes.AUDIO.onGroupChanged(), mediaTypes.AUDIO.onTrackChanged(), mediaTypes.AUDIO.getActiveGroup().playlistLoader ? (mainSegmentLoader.setAudio(!1), audioSegmentLoader.setAudio(!0)) : mainSegmentLoader.setAudio(!0);
                }
                masterPlaylistLoader.on("mediachange", function() {
                    [
                        "AUDIO",
                        "SUBTITLES"
                    ].forEach(function(type) {
                        return mediaTypes[type].onGroupChanged();
                    });
                }), masterPlaylistLoader.on("mediachanging", function() {
                    [
                        "AUDIO",
                        "SUBTITLES"
                    ].forEach(function(type) {
                        return mediaTypes[type].onGroupChanging();
                    });
                });
                var onAudioTrackChanged = function() {
                    mediaTypes.AUDIO.onTrackChanged(), tech.trigger({
                        type: "usage",
                        name: "vhs-audio-change"
                    }), tech.trigger({
                        type: "usage",
                        name: "hls-audio-change"
                    });
                };
                for(var id in tech.audioTracks().addEventListener("change", onAudioTrackChanged), tech.remoteTextTracks().addEventListener("change", mediaTypes.SUBTITLES.onTrackChanged), vhs.on("dispose", function() {
                    tech.audioTracks().removeEventListener("change", onAudioTrackChanged), tech.remoteTextTracks().removeEventListener("change", mediaTypes.SUBTITLES.onTrackChanged);
                }), tech.clearTracks("audio"), mediaTypes.AUDIO.tracks)tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);
            }, createMediaTypes = function() {
                var mediaTypes = {};
                return [
                    "AUDIO",
                    "SUBTITLES",
                    "CLOSED-CAPTIONS"
                ].forEach(function(type) {
                    mediaTypes[type] = {
                        groups: {},
                        tracks: {},
                        activePlaylistLoader: null,
                        activeGroup: noop,
                        activeTrack: noop,
                        getActiveGroup: noop,
                        onGroupChanged: noop,
                        onTrackChanged: noop,
                        lastTrack_: null,
                        logger_: logger("MediaGroups[" + type + "]")
                    };
                }), mediaTypes;
            }, loaderStats = [
                "mediaRequests",
                "mediaRequestsAborted",
                "mediaRequestsTimedout",
                "mediaRequestsErrored",
                "mediaTransferDuration",
                "mediaBytesTransferred",
                "mediaAppends"
            ], sumLoaderStat = function(stat) {
                return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
            }, shouldSwitchToMedia = function(_ref) {
                var currentPlaylist = _ref.currentPlaylist, buffered = _ref.buffered, currentTime = _ref.currentTime, nextPlaylist = _ref.nextPlaylist, bufferLowWaterLine = _ref.bufferLowWaterLine, bufferHighWaterLine = _ref.bufferHighWaterLine, duration = _ref.duration, experimentalBufferBasedABR = _ref.experimentalBufferBasedABR, log = _ref.log;
                if (!nextPlaylist) return videojs.log.warn("We received no playlist to switch to. Please check your stream."), !1;
                var sharedLogLine = "allowing switch " + (currentPlaylist && currentPlaylist.id || "null") + " -> " + nextPlaylist.id;
                if (!currentPlaylist) return log(sharedLogLine + " as current playlist is not set"), !0;
                if (nextPlaylist.id === currentPlaylist.id) return !1;
                var isBuffered = Boolean(findRange(buffered, currentTime).length);
                if (!currentPlaylist.endList) return isBuffered || "number" != typeof currentPlaylist.partTargetDuration ? (log(sharedLogLine + " as current playlist is live"), !0) : (log("not " + sharedLogLine + " as current playlist is live llhls, but currentTime isn't in buffered."), !1);
                var forwardBuffer = timeAheadOf(buffered, currentTime), maxBufferLowWaterLine = experimentalBufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
                if (duration < maxBufferLowWaterLine) return log(sharedLogLine + " as duration < max low water line (" + duration + " < " + maxBufferLowWaterLine + ")"), !0;
                var nextBandwidth = nextPlaylist.attributes.BANDWIDTH, currBandwidth = currentPlaylist.attributes.BANDWIDTH;
                if (nextBandwidth < currBandwidth && (!experimentalBufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
                    var logLine = sharedLogLine + " as next bandwidth < current bandwidth (" + nextBandwidth + " < " + currBandwidth + ")";
                    return experimentalBufferBasedABR && (logLine += " and forwardBuffer < bufferHighWaterLine (" + forwardBuffer + " < " + bufferHighWaterLine + ")"), log(logLine), !0;
                }
                if ((!experimentalBufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
                    var _logLine = sharedLogLine + " as forwardBuffer >= bufferLowWaterLine (" + forwardBuffer + " >= " + bufferLowWaterLine + ")";
                    return experimentalBufferBasedABR && (_logLine += " and next bandwidth > current bandwidth (" + nextBandwidth + " > " + currBandwidth + ")"), log(_logLine), !0;
                }
                return log("not " + sharedLogLine + " as no switching criteria met"), !1;
            }, MasterPlaylistController = function(_videojs$EventTarget) {
                function MasterPlaylistController(options) {
                    _this = _videojs$EventTarget.call(this) || this;
                    var _this, src = options.src, handleManifestRedirects = options.handleManifestRedirects, withCredentials = options.withCredentials, tech = options.tech, bandwidth = options.bandwidth, externVhs = options.externVhs, useCueTags = options.useCueTags, blacklistDuration = options.blacklistDuration, enableLowInitialPlaylist = options.enableLowInitialPlaylist, sourceType = options.sourceType, cacheEncryptionKeys = options.cacheEncryptionKeys, experimentalBufferBasedABR = options.experimentalBufferBasedABR, experimentalLeastPixelDiffSelector = options.experimentalLeastPixelDiffSelector, captionServices = options.captionServices;
                    if (!src) throw Error("A non-empty playlist URL or JSON manifest string is required");
                    var maxPlaylistRetries = options.maxPlaylistRetries;
                    null == maxPlaylistRetries && (maxPlaylistRetries = 1 / 0), Vhs$1 = externVhs, _this.experimentalBufferBasedABR = Boolean(experimentalBufferBasedABR), _this.experimentalLeastPixelDiffSelector = Boolean(experimentalLeastPixelDiffSelector), _this.withCredentials = withCredentials, _this.tech_ = tech, _this.vhs_ = tech.vhs, _this.sourceType_ = sourceType, _this.useCueTags_ = useCueTags, _this.blacklistDuration = blacklistDuration, _this.maxPlaylistRetries = maxPlaylistRetries, _this.enableLowInitialPlaylist = enableLowInitialPlaylist, _this.useCueTags_ && (_this.cueTagsTrack_ = _this.tech_.addTextTrack("metadata", "ad-cues"), _this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), _this.requestOptions_ = {
                        withCredentials: withCredentials,
                        handleManifestRedirects: handleManifestRedirects,
                        maxPlaylistRetries: maxPlaylistRetries,
                        timeout: null
                    }, _this.on("error", _this.pauseLoading), _this.mediaTypes_ = createMediaTypes(), _this.mediaSource = new (global_window__WEBPACK_IMPORTED_MODULE_0___default()).MediaSource(), _this.handleDurationChange_ = _this.handleDurationChange_.bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), _this.handleSourceOpen_ = _this.handleSourceOpen_.bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), _this.handleSourceEnded_ = _this.handleSourceEnded_.bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this)), _this.mediaSource.addEventListener("durationchange", _this.handleDurationChange_), _this.mediaSource.addEventListener("sourceopen", _this.handleSourceOpen_), _this.mediaSource.addEventListener("sourceended", _this.handleSourceEnded_), _this.seekable_ = videojs.createTimeRanges(), _this.hasPlayed_ = !1, _this.syncController_ = new SyncController(options), _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
                        kind: "metadata",
                        label: "segment-metadata"
                    }, !1).track, _this.decrypter_ = new Decrypter(), _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource), _this.inbandTextTracks_ = {}, _this.timelineChangeController_ = new TimelineChangeController();
                    var segmentLoaderSettings = {
                        vhs: _this.vhs_,
                        parse708captions: options.parse708captions,
                        captionServices: captionServices,
                        mediaSource: _this.mediaSource,
                        currentTime: _this.tech_.currentTime.bind(_this.tech_),
                        seekable: function() {
                            return _this.seekable();
                        },
                        seeking: function() {
                            return _this.tech_.seeking();
                        },
                        duration: function() {
                            return _this.duration();
                        },
                        hasPlayed: function() {
                            return _this.hasPlayed_;
                        },
                        goalBufferLength: function() {
                            return _this.goalBufferLength();
                        },
                        bandwidth: bandwidth,
                        syncController: _this.syncController_,
                        decrypter: _this.decrypter_,
                        sourceType: _this.sourceType_,
                        inbandTextTracks: _this.inbandTextTracks_,
                        cacheEncryptionKeys: cacheEncryptionKeys,
                        sourceUpdater: _this.sourceUpdater_,
                        timelineChangeController: _this.timelineChangeController_,
                        experimentalExactManifestTimings: options.experimentalExactManifestTimings
                    };
                    _this.masterPlaylistLoader_ = "dash" === _this.sourceType_ ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader(src, _this.vhs_, _this.requestOptions_), _this.setupMasterPlaylistLoaderListeners_(), _this.mainSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
                        segmentMetadataTrack: _this.segmentMetadataTrack_,
                        loaderType: "main"
                    }), options), _this.audioSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
                        loaderType: "audio"
                    }), options), _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
                        loaderType: "vtt",
                        featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks
                    }), options), _this.setupSegmentLoaderListeners_(), _this.experimentalBufferBasedABR && (_this.masterPlaylistLoader_.one("loadedplaylist", function() {
                        return _this.startABRTimer_();
                    }), _this.tech_.on("pause", function() {
                        return _this.stopABRTimer_();
                    }), _this.tech_.on("play", function() {
                        return _this.startABRTimer_();
                    })), loaderStats.forEach(function(stat) {
                        _this[stat + "_"] = sumLoaderStat.bind((0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this), stat);
                    }), _this.logger_ = logger("MPC"), _this.triggeredFmp4Usage = !1, "none" === _this.tech_.preload() ? (_this.loadOnPlay_ = function() {
                        _this.loadOnPlay_ = null, _this.masterPlaylistLoader_.load();
                    }, _this.tech_.one("play", _this.loadOnPlay_)) : _this.masterPlaylistLoader_.load(), _this.timeToLoadedData__ = -1, _this.mainAppendsToLoadedData__ = -1, _this.audioAppendsToLoadedData__ = -1;
                    var event = "none" === _this.tech_.preload() ? "play" : "loadstart";
                    return _this.tech_.one(event, function() {
                        var timeToLoadedDataStart = Date.now();
                        _this.tech_.one("loadeddata", function() {
                            _this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart, _this.mainAppendsToLoadedData__ = _this.mainSegmentLoader_.mediaAppends, _this.audioAppendsToLoadedData__ = _this.audioSegmentLoader_.mediaAppends;
                        });
                    }), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(MasterPlaylistController, _videojs$EventTarget);
                var _proto = MasterPlaylistController.prototype;
                return _proto.mainAppendsToLoadedData_ = function() {
                    return this.mainAppendsToLoadedData__;
                }, _proto.audioAppendsToLoadedData_ = function() {
                    return this.audioAppendsToLoadedData__;
                }, _proto.appendsToLoadedData_ = function() {
                    var main = this.mainAppendsToLoadedData_(), audio = this.audioAppendsToLoadedData_();
                    return -1 === main || -1 === audio ? -1 : main + audio;
                }, _proto.timeToLoadedData_ = function() {
                    return this.timeToLoadedData__;
                }, _proto.checkABR_ = function() {
                    var nextPlaylist = this.selectPlaylist();
                    nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist) && this.switchMedia_(nextPlaylist, "abr");
                }, _proto.switchMedia_ = function(playlist, cause, delay) {
                    var oldMedia = this.media(), oldId = oldMedia && (oldMedia.id || oldMedia.uri), newId = playlist.id || playlist.uri;
                    oldId && oldId !== newId && (this.logger_("switch media " + oldId + " -> " + newId + " from " + cause), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-change-" + cause
                    })), this.masterPlaylistLoader_.media(playlist, delay);
                }, _proto.startABRTimer_ = function() {
                    var _this2 = this;
                    this.stopABRTimer_(), this.abrTimer_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setInterval(function() {
                        return _this2.checkABR_();
                    }, 250);
                }, _proto.stopABRTimer_ = function() {
                    this.tech_.scrubbing && this.tech_.scrubbing() || (global_window__WEBPACK_IMPORTED_MODULE_0___default().clearInterval(this.abrTimer_), this.abrTimer_ = null);
                }, _proto.getAudioTrackPlaylists_ = function() {
                    var track, master = this.master(), defaultPlaylists = master && master.playlists || [];
                    if (!master || !master.mediaGroups || !master.mediaGroups.AUDIO) return defaultPlaylists;
                    var AUDIO = master.mediaGroups.AUDIO, groupKeys = Object.keys(AUDIO);
                    if (Object.keys(this.mediaTypes_.AUDIO.groups).length) track = this.mediaTypes_.AUDIO.activeTrack();
                    else {
                        var defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];
                        for(var label in defaultGroup)if (defaultGroup[label].default) {
                            track = {
                                label: label
                            };
                            break;
                        }
                    }
                    if (!track) return defaultPlaylists;
                    var playlists = [];
                    for(var group in AUDIO)if (AUDIO[group][track.label]) {
                        var properties = AUDIO[group][track.label];
                        if (properties.playlists && properties.playlists.length) playlists.push.apply(playlists, properties.playlists);
                        else if (properties.uri) playlists.push(properties);
                        else if (master.playlists.length) for(var i = 0; i < master.playlists.length; i++){
                            var playlist = master.playlists[i];
                            playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group && playlists.push(playlist);
                        }
                    }
                    return playlists.length ? playlists : defaultPlaylists;
                }, _proto.setupMasterPlaylistLoaderListeners_ = function() {
                    var _this3 = this;
                    this.masterPlaylistLoader_.on("loadedmetadata", function() {
                        var media = _this3.masterPlaylistLoader_.media(), requestTimeout = 1500 * media.targetDuration;
                        isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media()) ? _this3.requestOptions_.timeout = 0 : _this3.requestOptions_.timeout = requestTimeout, media.endList && "none" !== _this3.tech_.preload() && (_this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_), _this3.mainSegmentLoader_.load()), setupMediaGroups({
                            sourceType: _this3.sourceType_,
                            segmentLoaders: {
                                AUDIO: _this3.audioSegmentLoader_,
                                SUBTITLES: _this3.subtitleSegmentLoader_,
                                main: _this3.mainSegmentLoader_
                            },
                            tech: _this3.tech_,
                            requestOptions: _this3.requestOptions_,
                            masterPlaylistLoader: _this3.masterPlaylistLoader_,
                            vhs: _this3.vhs_,
                            master: _this3.master(),
                            mediaTypes: _this3.mediaTypes_,
                            blacklistCurrentPlaylist: _this3.blacklistCurrentPlaylist.bind(_this3)
                        }), _this3.triggerPresenceUsage_(_this3.master(), media), _this3.setupFirstPlay(), !_this3.mediaTypes_.AUDIO.activePlaylistLoader || _this3.mediaTypes_.AUDIO.activePlaylistLoader.media() ? _this3.trigger("selectedinitialmedia") : _this3.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", function() {
                            _this3.trigger("selectedinitialmedia");
                        });
                    }), this.masterPlaylistLoader_.on("loadedplaylist", function() {
                        _this3.loadOnPlay_ && _this3.tech_.off("play", _this3.loadOnPlay_);
                        var selectedMedia, updatedPlaylist = _this3.masterPlaylistLoader_.media();
                        if (!updatedPlaylist) {
                            if (_this3.excludeUnsupportedVariants_(), _this3.enableLowInitialPlaylist && (selectedMedia = _this3.selectInitialPlaylist()), selectedMedia || (selectedMedia = _this3.selectPlaylist()), !selectedMedia || !_this3.shouldSwitchToMedia_(selectedMedia) || (_this3.initialMedia_ = selectedMedia, _this3.switchMedia_(_this3.initialMedia_, "initial"), !("vhs-json" === _this3.sourceType_ && _this3.initialMedia_.segments))) return;
                            updatedPlaylist = _this3.initialMedia_;
                        }
                        _this3.handleUpdatedMediaPlaylist(updatedPlaylist);
                    }), this.masterPlaylistLoader_.on("error", function() {
                        _this3.blacklistCurrentPlaylist(_this3.masterPlaylistLoader_.error);
                    }), this.masterPlaylistLoader_.on("mediachanging", function() {
                        _this3.mainSegmentLoader_.abort(), _this3.mainSegmentLoader_.pause();
                    }), this.masterPlaylistLoader_.on("mediachange", function() {
                        var media = _this3.masterPlaylistLoader_.media(), requestTimeout = 1500 * media.targetDuration;
                        isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media()) ? _this3.requestOptions_.timeout = 0 : _this3.requestOptions_.timeout = requestTimeout, _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_), _this3.mainSegmentLoader_.load(), _this3.tech_.trigger({
                            type: "mediachange",
                            bubbles: !0
                        });
                    }), this.masterPlaylistLoader_.on("playlistunchanged", function() {
                        var updatedPlaylist = _this3.masterPlaylistLoader_.media();
                        "playlist-unchanged" !== updatedPlaylist.lastExcludeReason_ && _this3.stuckAtPlaylistEnd_(updatedPlaylist) && (_this3.blacklistCurrentPlaylist({
                            message: "Playlist no longer updating.",
                            reason: "playlist-unchanged"
                        }), _this3.tech_.trigger("playliststuck"));
                    }), this.masterPlaylistLoader_.on("renditiondisabled", function() {
                        _this3.tech_.trigger({
                            type: "usage",
                            name: "vhs-rendition-disabled"
                        }), _this3.tech_.trigger({
                            type: "usage",
                            name: "hls-rendition-disabled"
                        });
                    }), this.masterPlaylistLoader_.on("renditionenabled", function() {
                        _this3.tech_.trigger({
                            type: "usage",
                            name: "vhs-rendition-enabled"
                        }), _this3.tech_.trigger({
                            type: "usage",
                            name: "hls-rendition-enabled"
                        });
                    });
                }, _proto.handleUpdatedMediaPlaylist = function(updatedPlaylist) {
                    this.useCueTags_ && this.updateAdCues_(updatedPlaylist), this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_), this.updateDuration(!updatedPlaylist.endList), !this.tech_.paused() && (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load());
                }, _proto.triggerPresenceUsage_ = function(master, media) {
                    var mediaGroups = master.mediaGroups || {}, defaultDemuxed = !0, audioGroupKeys = Object.keys(mediaGroups.AUDIO);
                    for(var mediaGroup in mediaGroups.AUDIO)for(var label in mediaGroups.AUDIO[mediaGroup])mediaGroups.AUDIO[mediaGroup][label].uri || (defaultDemuxed = !1);
                    defaultDemuxed && (this.tech_.trigger({
                        type: "usage",
                        name: "vhs-demuxed"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-demuxed"
                    })), Object.keys(mediaGroups.SUBTITLES).length && (this.tech_.trigger({
                        type: "usage",
                        name: "vhs-webvtt"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-webvtt"
                    })), Vhs$1.Playlist.isAes(media) && (this.tech_.trigger({
                        type: "usage",
                        name: "vhs-aes"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-aes"
                    })), audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1 && (this.tech_.trigger({
                        type: "usage",
                        name: "vhs-alternate-audio"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-alternate-audio"
                    })), this.useCueTags_ && (this.tech_.trigger({
                        type: "usage",
                        name: "vhs-playlist-cue-tags"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-playlist-cue-tags"
                    }));
                }, _proto.shouldSwitchToMedia_ = function(nextPlaylist) {
                    var currentPlaylist = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_, currentTime = this.tech_.currentTime(), bufferLowWaterLine = this.bufferLowWaterLine(), bufferHighWaterLine = this.bufferHighWaterLine();
                    return shouldSwitchToMedia({
                        buffered: this.tech_.buffered(),
                        currentTime: currentTime,
                        currentPlaylist: currentPlaylist,
                        nextPlaylist: nextPlaylist,
                        bufferLowWaterLine: bufferLowWaterLine,
                        bufferHighWaterLine: bufferHighWaterLine,
                        duration: this.duration(),
                        experimentalBufferBasedABR: this.experimentalBufferBasedABR,
                        log: this.logger_
                    });
                }, _proto.setupSegmentLoaderListeners_ = function() {
                    var _this4 = this;
                    this.experimentalBufferBasedABR || (this.mainSegmentLoader_.on("bandwidthupdate", function() {
                        var nextPlaylist = _this4.selectPlaylist();
                        _this4.shouldSwitchToMedia_(nextPlaylist) && _this4.switchMedia_(nextPlaylist, "bandwidthupdate"), _this4.tech_.trigger("bandwidthupdate");
                    }), this.mainSegmentLoader_.on("progress", function() {
                        _this4.trigger("progress");
                    })), this.mainSegmentLoader_.on("error", function() {
                        _this4.blacklistCurrentPlaylist(_this4.mainSegmentLoader_.error());
                    }), this.mainSegmentLoader_.on("appenderror", function() {
                        _this4.error = _this4.mainSegmentLoader_.error_, _this4.trigger("error");
                    }), this.mainSegmentLoader_.on("syncinfoupdate", function() {
                        _this4.onSyncInfoUpdate_();
                    }), this.mainSegmentLoader_.on("timestampoffset", function() {
                        _this4.tech_.trigger({
                            type: "usage",
                            name: "vhs-timestamp-offset"
                        }), _this4.tech_.trigger({
                            type: "usage",
                            name: "hls-timestamp-offset"
                        });
                    }), this.audioSegmentLoader_.on("syncinfoupdate", function() {
                        _this4.onSyncInfoUpdate_();
                    }), this.audioSegmentLoader_.on("appenderror", function() {
                        _this4.error = _this4.audioSegmentLoader_.error_, _this4.trigger("error");
                    }), this.mainSegmentLoader_.on("ended", function() {
                        _this4.logger_("main segment loader ended"), _this4.onEndOfStream();
                    }), this.mainSegmentLoader_.on("earlyabort", function(event) {
                        _this4.experimentalBufferBasedABR || (_this4.delegateLoaders_("all", [
                            "abort"
                        ]), _this4.blacklistCurrentPlaylist({
                            message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
                        }, 120));
                    });
                    var updateCodecs = function() {
                        if (!_this4.sourceUpdater_.hasCreatedSourceBuffers()) return _this4.tryToCreateSourceBuffers_();
                        var codecs = _this4.getCodecsOrExclude_();
                        codecs && _this4.sourceUpdater_.addOrChangeSourceBuffers(codecs);
                    };
                    this.mainSegmentLoader_.on("trackinfo", updateCodecs), this.audioSegmentLoader_.on("trackinfo", updateCodecs), this.mainSegmentLoader_.on("fmp4", function() {
                        _this4.triggeredFmp4Usage || (_this4.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        }), _this4.tech_.trigger({
                            type: "usage",
                            name: "hls-fmp4"
                        }), _this4.triggeredFmp4Usage = !0);
                    }), this.audioSegmentLoader_.on("fmp4", function() {
                        _this4.triggeredFmp4Usage || (_this4.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        }), _this4.tech_.trigger({
                            type: "usage",
                            name: "hls-fmp4"
                        }), _this4.triggeredFmp4Usage = !0);
                    }), this.audioSegmentLoader_.on("ended", function() {
                        _this4.logger_("audioSegmentLoader ended"), _this4.onEndOfStream();
                    });
                }, _proto.mediaSecondsLoaded_ = function() {
                    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
                }, _proto.load = function() {
                    this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load();
                }, _proto.smoothQualityChange_ = function(media) {
                    void 0 === media && (media = this.selectPlaylist()), this.fastQualityChange_(media);
                }, _proto.fastQualityChange_ = function(media) {
                    var _this5 = this;
                    if (void 0 === media && (media = this.selectPlaylist()), media === this.masterPlaylistLoader_.media()) {
                        this.logger_("skipping fastQualityChange because new media is same as old");
                        return;
                    }
                    this.switchMedia_(media, "fast-quality"), this.mainSegmentLoader_.resetEverything(function() {
                        videojs.browser.IE_VERSION || videojs.browser.IS_EDGE ? _this5.tech_.setCurrentTime(_this5.tech_.currentTime() + 0.04) : _this5.tech_.setCurrentTime(_this5.tech_.currentTime());
                    });
                }, _proto.play = function() {
                    if (!this.setupFirstPlay()) {
                        this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load();
                        var seekable = this.tech_.seekable();
                        if (this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < seekable.start(0)) return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));
                    }
                }, _proto.setupFirstPlay = function() {
                    var _this6 = this, media = this.masterPlaylistLoader_.media();
                    if (!media || this.tech_.paused() || this.hasPlayed_) return !1;
                    if (!media.endList) {
                        var seekable = this.seekable();
                        if (!seekable.length) return !1;
                        if (videojs.browser.IE_VERSION && 0 === this.tech_.readyState()) return this.tech_.one("loadedmetadata", function() {
                            _this6.trigger("firstplay"), _this6.tech_.setCurrentTime(seekable.end(0)), _this6.hasPlayed_ = !0;
                        }), !1;
                        this.trigger("firstplay"), this.tech_.setCurrentTime(seekable.end(0));
                    }
                    return this.hasPlayed_ = !0, this.load(), !0;
                }, _proto.handleSourceOpen_ = function() {
                    if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) {
                        var playPromise = this.tech_.play();
                        void 0 !== playPromise && "function" == typeof playPromise.then && playPromise.then(null, function(e) {});
                    }
                    this.trigger("sourceopen");
                }, _proto.handleSourceEnded_ = function() {
                    if (this.inbandTextTracks_.metadataTrack_) {
                        var cues = this.inbandTextTracks_.metadataTrack_.cues;
                        if (cues && cues.length) {
                            var duration = this.duration();
                            cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === 1 / 0 ? Number.MAX_VALUE : duration;
                        }
                    }
                }, _proto.handleDurationChange_ = function() {
                    this.tech_.trigger("durationchange");
                }, _proto.onEndOfStream = function() {
                    var isEndOfStream = this.mainSegmentLoader_.ended_;
                    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                        var mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
                        isEndOfStream = !mainMediaInfo || mainMediaInfo.hasVideo ? isEndOfStream && this.audioSegmentLoader_.ended_ : this.audioSegmentLoader_.ended_;
                    }
                    isEndOfStream && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream());
                }, _proto.stuckAtPlaylistEnd_ = function(playlist) {
                    if (!this.seekable().length) return !1;
                    var expired = this.syncController_.getExpiredTime(playlist, this.duration());
                    if (null === expired) return !1;
                    var absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired), currentTime = this.tech_.currentTime(), buffered = this.tech_.buffered();
                    if (!buffered.length) return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
                    var bufferedEnd = buffered.end(buffered.length - 1);
                    return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
                }, _proto.blacklistCurrentPlaylist = function(error, blacklistDuration) {
                    void 0 === error && (error = {});
                    var excludeUntil, currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();
                    if (blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration, !currentPlaylist) {
                        this.error = error, "open" !== this.mediaSource.readyState ? this.trigger("error") : this.sourceUpdater_.endOfStream("network");
                        return;
                    }
                    currentPlaylist.playlistErrors_++;
                    var playlists = this.masterPlaylistLoader_.master.playlists, enabledPlaylists = playlists.filter(isEnabled), isFinalRendition = 1 === enabledPlaylists.length && enabledPlaylists[0] === currentPlaylist;
                    if (1 === playlists.length && blacklistDuration !== 1 / 0) return videojs.log.warn("Problem encountered with playlist " + currentPlaylist.id + ". Trying again since it is the only playlist."), this.tech_.trigger("retryplaylist"), this.masterPlaylistLoader_.load(isFinalRendition);
                    if (isFinalRendition) {
                        var reincluded = !1;
                        playlists.forEach(function(playlist) {
                            if (playlist !== currentPlaylist) {
                                var excludeUntil = playlist.excludeUntil;
                                void 0 !== excludeUntil && excludeUntil !== 1 / 0 && (reincluded = !0, delete playlist.excludeUntil);
                            }
                        }), reincluded && (videojs.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist"));
                    }
                    excludeUntil = currentPlaylist.playlistErrors_ > this.maxPlaylistRetries ? 1 / 0 : Date.now() + 1000 * blacklistDuration, currentPlaylist.excludeUntil = excludeUntil, error.reason && (currentPlaylist.lastExcludeReason_ = error.reason), this.tech_.trigger("blacklistplaylist"), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-blacklisted"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-rendition-blacklisted"
                    });
                    var nextPlaylist = this.selectPlaylist();
                    if (!nextPlaylist) {
                        this.error = "Playback cannot continue. No available working or supported playlists.", this.trigger("error");
                        return;
                    }
                    var logFn = error.internal ? this.logger_ : videojs.log.warn, errorMessage = error.message ? " " + error.message : "";
                    logFn((error.internal ? "Internal problem" : "Problem") + " encountered with playlist " + currentPlaylist.id + "." + errorMessage + " Switching to playlist " + nextPlaylist.id + "."), nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO && this.delegateLoaders_("audio", [
                        "abort",
                        "pause"
                    ]), nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES && this.delegateLoaders_("subtitle", [
                        "abort",
                        "pause"
                    ]), this.delegateLoaders_("main", [
                        "abort",
                        "pause"
                    ]);
                    var delayDuration = nextPlaylist.targetDuration / 2 * 1000 || 5000, shouldDelay = "number" == typeof nextPlaylist.lastRequest && Date.now() - nextPlaylist.lastRequest <= delayDuration;
                    return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
                }, _proto.pauseLoading = function() {
                    this.delegateLoaders_("all", [
                        "abort",
                        "pause"
                    ]), this.stopABRTimer_();
                }, _proto.delegateLoaders_ = function(filter, fnNames) {
                    var _this7 = this, loaders = [], dontFilterPlaylist = "all" === filter;
                    (dontFilterPlaylist || "main" === filter) && loaders.push(this.masterPlaylistLoader_);
                    var mediaTypes = [];
                    (dontFilterPlaylist || "audio" === filter) && mediaTypes.push("AUDIO"), (dontFilterPlaylist || "subtitle" === filter) && (mediaTypes.push("CLOSED-CAPTIONS"), mediaTypes.push("SUBTITLES")), mediaTypes.forEach(function(mediaType) {
                        var loader = _this7.mediaTypes_[mediaType] && _this7.mediaTypes_[mediaType].activePlaylistLoader;
                        loader && loaders.push(loader);
                    }), [
                        "main",
                        "audio",
                        "subtitle"
                    ].forEach(function(name) {
                        var loader = _this7[name + "SegmentLoader_"];
                        loader && (filter === name || "all" === filter) && loaders.push(loader);
                    }), loaders.forEach(function(loader) {
                        return fnNames.forEach(function(fnName) {
                            "function" == typeof loader[fnName] && loader[fnName]();
                        });
                    });
                }, _proto.setCurrentTime = function(currentTime) {
                    var buffered = findRange(this.tech_.buffered(), currentTime);
                    return this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media() && this.masterPlaylistLoader_.media().segments ? buffered && buffered.length ? currentTime : void (this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), this.load()) : 0;
                }, _proto.duration = function() {
                    if (!this.masterPlaylistLoader_) return 0;
                    var media = this.masterPlaylistLoader_.media();
                    return media ? media.endList ? this.mediaSource ? this.mediaSource.duration : Vhs$1.Playlist.duration(media) : 1 / 0 : 0;
                }, _proto.seekable = function() {
                    return this.seekable_;
                }, _proto.onSyncInfoUpdate_ = function() {
                    if (!(!this.masterPlaylistLoader_ || this.sourceUpdater_.hasCreatedSourceBuffers())) {
                        var audioSeekable, oldEnd, oldStart, media = this.masterPlaylistLoader_.media();
                        if (media) {
                            var expired = this.syncController_.getExpiredTime(media, this.duration());
                            if (null !== expired) {
                                var master = this.masterPlaylistLoader_.master, mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
                                0 !== mainSeekable.length && (!this.mediaTypes_.AUDIO.activePlaylistLoader || (media = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), null !== (expired = this.syncController_.getExpiredTime(media, this.duration())) && 0 !== (audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media))).length)) && (this.seekable_ && this.seekable_.length && (oldEnd = this.seekable_.end(0), oldStart = this.seekable_.start(0)), audioSeekable ? audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0) ? this.seekable_ = mainSeekable : this.seekable_ = videojs.createTimeRanges([
                                    [
                                        audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0),
                                        audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)
                                    ]
                                ]) : this.seekable_ = mainSeekable, this.seekable_ && this.seekable_.length && this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart || (this.logger_("seekable updated [" + printableRange(this.seekable_) + "]"), this.tech_.trigger("seekablechanged")));
                            }
                        }
                    }
                }, _proto.updateDuration = function(isLive) {
                    if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), "open" !== this.mediaSource.readyState) {
                        this.updateDuration_ = this.updateDuration.bind(this, isLive), this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
                        return;
                    }
                    if (isLive) {
                        var seekable = this.seekable();
                        if (!seekable.length) return;
                        (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) && this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));
                        return;
                    }
                    var buffered = this.tech_.buffered(), duration = Vhs$1.Playlist.duration(this.masterPlaylistLoader_.media());
                    buffered.length > 0 && (duration = Math.max(duration, buffered.end(buffered.length - 1))), this.mediaSource.duration !== duration && this.sourceUpdater_.setDuration(duration);
                }, _proto.dispose = function() {
                    var _this8 = this;
                    this.trigger("dispose"), this.decrypter_.terminate(), this.masterPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), [
                        "AUDIO",
                        "SUBTITLES"
                    ].forEach(function(type) {
                        var groups = _this8.mediaTypes_[type].groups;
                        for(var id in groups)groups[id].forEach(function(group) {
                            group.playlistLoader && group.playlistLoader.dispose();
                        });
                    }), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off();
                }, _proto.master = function() {
                    return this.masterPlaylistLoader_.master;
                }, _proto.media = function() {
                    return this.masterPlaylistLoader_.media() || this.initialMedia_;
                }, _proto.areMediaTypesKnown_ = function() {
                    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader, hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), hasAudioMediaInfo = !usingAudioLoader || !!this.audioSegmentLoader_.getCurrentMediaInfo_();
                    return !!hasMainMediaInfo && !!hasAudioMediaInfo;
                }, _proto.getCodecsOrExclude_ = function() {
                    var unsupportedAudio, _this9 = this, media = {
                        main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
                        audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
                    };
                    media.video = media.main;
                    var playlistCodecs = codecsForPlaylist(this.master(), this.media()), codecs = {}, usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
                    if (media.main.hasVideo && (codecs.video = playlistCodecs.video || media.main.videoCodec || _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.xz), media.main.isMuxed && (codecs.video += "," + (playlistCodecs.audio || media.main.audioCodec || _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.lA)), (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) && (codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.lA, media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4), !codecs.audio && !codecs.video) {
                        this.blacklistCurrentPlaylist({
                            playlist: this.media(),
                            message: "Could not determine codecs for playlist.",
                            blacklistDuration: 1 / 0
                        });
                        return;
                    }
                    var unsupportedCodecs = {};
                    if ([
                        "video",
                        "audio"
                    ].forEach(function(type) {
                        var isFmp4, codec;
                        if (codecs.hasOwnProperty(type) && (isFmp4 = media[type].isFmp4, codec = codecs[type], isFmp4 ? !(0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.p7)(codec) : !(0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.Hi)(codec))) {
                            var supporter = media[type].isFmp4 ? "browser" : "muxer";
                            unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [], unsupportedCodecs[supporter].push(codecs[type]), "audio" === type && (unsupportedAudio = supporter);
                        }
                    }), usingAudioLoader && unsupportedAudio && this.media().attributes.AUDIO) {
                        var audioGroup = this.media().attributes.AUDIO;
                        this.master().playlists.forEach(function(variant) {
                            (variant.attributes && variant.attributes.AUDIO) === audioGroup && variant !== _this9.media() && (variant.excludeUntil = 1 / 0);
                        }), this.logger_("excluding audio group " + audioGroup + " as " + unsupportedAudio + ' does not support codec(s): "' + codecs.audio + '"');
                    }
                    if (Object.keys(unsupportedCodecs).length) {
                        var message = Object.keys(unsupportedCodecs).reduce(function(acc, supporter) {
                            return acc && (acc += ", "), acc += supporter + ' does not support codec(s): "' + unsupportedCodecs[supporter].join(",") + '"';
                        }, "") + ".";
                        this.blacklistCurrentPlaylist({
                            playlist: this.media(),
                            internal: !0,
                            message: message,
                            blacklistDuration: 1 / 0
                        });
                        return;
                    }
                    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
                        var switchMessages = [];
                        if ([
                            "video",
                            "audio"
                        ].forEach(function(type) {
                            var newCodec = ((0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(_this9.sourceUpdater_.codecs[type] || "")[0] || {}).type, oldCodec = ((0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(codecs[type] || "")[0] || {}).type;
                            newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase() && switchMessages.push('"' + _this9.sourceUpdater_.codecs[type] + '" -> "' + codecs[type] + '"');
                        }), switchMessages.length) {
                            this.blacklistCurrentPlaylist({
                                playlist: this.media(),
                                message: "Codec switching not supported: " + switchMessages.join(", ") + ".",
                                blacklistDuration: 1 / 0,
                                internal: !0
                            });
                            return;
                        }
                    }
                    return codecs;
                }, _proto.tryToCreateSourceBuffers_ = function() {
                    if (!("open" !== this.mediaSource.readyState || this.sourceUpdater_.hasCreatedSourceBuffers()) && this.areMediaTypesKnown_()) {
                        var codecs = this.getCodecsOrExclude_();
                        if (codecs) {
                            this.sourceUpdater_.createSourceBuffers(codecs);
                            var codecString = [
                                codecs.video,
                                codecs.audio
                            ].filter(Boolean).join(",");
                            this.excludeIncompatibleVariants_(codecString);
                        }
                    }
                }, _proto.excludeUnsupportedVariants_ = function() {
                    var _this10 = this, playlists = this.master().playlists, ids = [];
                    Object.keys(playlists).forEach(function(key) {
                        var variant = playlists[key];
                        if (-1 === ids.indexOf(variant.id)) {
                            ids.push(variant.id);
                            var codecs = codecsForPlaylist(_this10.master, variant), unsupported = [];
                            !codecs.audio || (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.Hi)(codecs.audio) || (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.p7)(codecs.audio) || unsupported.push("audio codec " + codecs.audio), !codecs.video || (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.Hi)(codecs.video) || (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.p7)(codecs.video) || unsupported.push("video codec " + codecs.video), codecs.text && "stpp.ttml.im1t" === codecs.text && unsupported.push("text codec " + codecs.text), unsupported.length && (variant.excludeUntil = 1 / 0, _this10.logger_("excluding " + variant.id + " for unsupported: " + unsupported.join(", ")));
                        }
                    });
                }, _proto.excludeIncompatibleVariants_ = function(codecString) {
                    var _this11 = this, ids = [], playlists = this.master().playlists, codecs = unwrapCodecList((0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(codecString)), codecCount_ = codecCount(codecs), videoDetails = codecs.video && (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(codecs.video)[0] || null, audioDetails = codecs.audio && (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(codecs.audio)[0] || null;
                    Object.keys(playlists).forEach(function(key) {
                        var variant = playlists[key];
                        if (-1 === ids.indexOf(variant.id) && variant.excludeUntil !== 1 / 0) {
                            ids.push(variant.id);
                            var blacklistReasons = [], variantCodecs = codecsForPlaylist(_this11.masterPlaylistLoader_.master, variant), variantCodecCount = codecCount(variantCodecs);
                            if (variantCodecs.audio || variantCodecs.video) {
                                if (variantCodecCount !== codecCount_ && blacklistReasons.push('codec count "' + variantCodecCount + '" !== "' + codecCount_ + '"'), !_this11.sourceUpdater_.canChangeType()) {
                                    var variantVideoDetails = variantCodecs.video && (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(variantCodecs.video)[0] || null, variantAudioDetails = variantCodecs.audio && (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(variantCodecs.audio)[0] || null;
                                    variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase() && blacklistReasons.push('video codec "' + variantVideoDetails.type + '" !== "' + videoDetails.type + '"'), variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase() && blacklistReasons.push('audio codec "' + variantAudioDetails.type + '" !== "' + audioDetails.type + '"');
                                }
                                blacklistReasons.length && (variant.excludeUntil = 1 / 0, _this11.logger_("blacklisting " + variant.id + ": " + blacklistReasons.join(" && ")));
                            }
                        }
                    });
                }, _proto.updateAdCues_ = function(media) {
                    var offset = 0, seekable = this.seekable();
                    seekable.length && (offset = seekable.start(0)), updateAdCues(media, this.cueTagsTrack_, offset);
                }, _proto.goalBufferLength = function() {
                    var currentTime = this.tech_.currentTime(), initial = Config.GOAL_BUFFER_LENGTH, rate = Config.GOAL_BUFFER_LENGTH_RATE, max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
                    return Math.min(initial + currentTime * rate, max);
                }, _proto.bufferLowWaterLine = function() {
                    var currentTime = this.tech_.currentTime(), initial = Config.BUFFER_LOW_WATER_LINE, rate = Config.BUFFER_LOW_WATER_LINE_RATE, max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE), newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
                    return Math.min(initial + currentTime * rate, this.experimentalBufferBasedABR ? newMax : max);
                }, _proto.bufferHighWaterLine = function() {
                    return Config.BUFFER_HIGH_WATER_LINE;
                }, MasterPlaylistController;
            }(videojs.EventTarget), Representation = function(vhsHandler, playlist, id) {
                var loader, playlistID, mpc = vhsHandler.masterPlaylistController_, qualityChangeFunction = mpc[(vhsHandler.options_.smoothQualityChange ? "smooth" : "fast") + "QualityChange_"].bind(mpc);
                if (playlist.attributes) {
                    var resolution = playlist.attributes.RESOLUTION;
                    this.width = resolution && resolution.width, this.height = resolution && resolution.height, this.bandwidth = playlist.attributes.BANDWIDTH;
                }
                this.codecs = codecsForPlaylist(mpc.master(), playlist), this.playlist = playlist, this.id = id, this.enabled = (loader = vhsHandler.playlists, playlistID = playlist.id, function(enable) {
                    var playlist = loader.master.playlists[playlistID], incompatible = isIncompatible(playlist), currentlyEnabled = isEnabled(playlist);
                    return void 0 === enable ? currentlyEnabled : (enable ? delete playlist.disabled : playlist.disabled = !0, enable === currentlyEnabled || incompatible || (qualityChangeFunction(), enable ? loader.trigger("renditionenabled") : loader.trigger("renditiondisabled")), enable);
                });
            }, renditionSelectionMixin = function(vhsHandler) {
                vhsHandler.representations = function() {
                    var master = vhsHandler.masterPlaylistController_.master(), playlists = isAudioOnly(master) ? vhsHandler.masterPlaylistController_.getAudioTrackPlaylists_() : master.playlists;
                    return playlists ? playlists.filter(function(media) {
                        return !isIncompatible(media);
                    }).map(function(e, i) {
                        return new Representation(vhsHandler, e, e.id);
                    }) : [];
                };
            }, timerCancelEvents = [
                "seeking",
                "seeked",
                "pause",
                "playing",
                "error"
            ], PlaybackWatcher = function() {
                function PlaybackWatcher(options) {
                    var _this = this;
                    this.masterPlaylistController_ = options.masterPlaylistController, this.tech_ = options.tech, this.seekable = options.seekable, this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta, this.media = options.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.timer_ = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = logger("PlaybackWatcher"), this.logger_("initialize");
                    var playHandler = function() {
                        return _this.monitorCurrentTime_();
                    }, canPlayHandler = function() {
                        return _this.monitorCurrentTime_();
                    }, waitingHandler = function() {
                        return _this.techWaiting_();
                    }, cancelTimerHandler = function() {
                        return _this.cancelTimer_();
                    }, mpc = this.masterPlaylistController_, loaderTypes = [
                        "main",
                        "subtitle",
                        "audio"
                    ], loaderChecks = {};
                    loaderTypes.forEach(function(type) {
                        loaderChecks[type] = {
                            reset: function() {
                                return _this.resetSegmentDownloads_(type);
                            },
                            updateend: function() {
                                return _this.checkSegmentDownloads_(type);
                            }
                        }, mpc[type + "SegmentLoader_"].on("appendsdone", loaderChecks[type].updateend), mpc[type + "SegmentLoader_"].on("playlistupdate", loaderChecks[type].reset), _this.tech_.on([
                            "seeked",
                            "seeking"
                        ], loaderChecks[type].reset);
                    });
                    var setSeekingHandlers = function(fn) {
                        [
                            "main",
                            "audio"
                        ].forEach(function(type) {
                            mpc[type + "SegmentLoader_"][fn]("appended", _this.seekingAppendCheck_);
                        });
                    };
                    this.seekingAppendCheck_ = function() {
                        _this.fixesBadSeeks_() && (_this.consecutiveUpdates = 0, _this.lastRecordedTime = _this.tech_.currentTime(), setSeekingHandlers("off"));
                    }, this.clearSeekingAppendCheck_ = function() {
                        return setSeekingHandlers("off");
                    }, this.watchForBadSeeking_ = function() {
                        _this.clearSeekingAppendCheck_(), setSeekingHandlers("on");
                    }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", waitingHandler), this.tech_.on(timerCancelEvents, cancelTimerHandler), this.tech_.on("canplay", canPlayHandler), this.tech_.one("play", playHandler), this.dispose = function() {
                        _this.clearSeekingAppendCheck_(), _this.logger_("dispose"), _this.tech_.off("waiting", waitingHandler), _this.tech_.off(timerCancelEvents, cancelTimerHandler), _this.tech_.off("canplay", canPlayHandler), _this.tech_.off("play", playHandler), _this.tech_.off("seeking", _this.watchForBadSeeking_), _this.tech_.off("seeked", _this.clearSeekingAppendCheck_), loaderTypes.forEach(function(type) {
                            mpc[type + "SegmentLoader_"].off("appendsdone", loaderChecks[type].updateend), mpc[type + "SegmentLoader_"].off("playlistupdate", loaderChecks[type].reset), _this.tech_.off([
                                "seeked",
                                "seeking"
                            ], loaderChecks[type].reset);
                        }), _this.checkCurrentTimeTimeout_ && global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(_this.checkCurrentTimeTimeout_), _this.cancelTimer_();
                    };
                }
                var _proto = PlaybackWatcher.prototype;
                return _proto.monitorCurrentTime_ = function() {
                    this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && global_window__WEBPACK_IMPORTED_MODULE_0___default().clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().setTimeout(this.monitorCurrentTime_.bind(this), 250);
                }, _proto.resetSegmentDownloads_ = function(type) {
                    var loader = this.masterPlaylistController_[type + "SegmentLoader_"];
                    this[type + "StalledDownloads_"] > 0 && this.logger_("resetting possible stalled download count for " + type + " loader"), this[type + "StalledDownloads_"] = 0, this[type + "Buffered_"] = loader.buffered_();
                }, _proto.checkSegmentDownloads_ = function(type) {
                    var mpc = this.masterPlaylistController_, loader = mpc[type + "SegmentLoader_"], buffered = loader.buffered_(), isBufferedDifferent = isRangeDifferent(this[type + "Buffered_"], buffered);
                    if (this[type + "Buffered_"] = buffered, isBufferedDifferent) {
                        this.resetSegmentDownloads_(type);
                        return;
                    }
                    this[type + "StalledDownloads_"]++, this.logger_("found #" + this[type + "StalledDownloads_"] + " " + type + " appends that did not increase buffer (possible stalled download)", {
                        playlistId: loader.playlist_ && loader.playlist_.id,
                        buffered: timeRangesToArray(buffered)
                    }), this[type + "StalledDownloads_"] < 10 || (this.logger_(type + " loader stalled download exclusion"), this.resetSegmentDownloads_(type), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-" + type + "-download-exclusion"
                    }), "subtitle" !== type && mpc.blacklistCurrentPlaylist({
                        message: "Excessive " + type + " segment downloading detected."
                    }, 1 / 0));
                }, _proto.checkCurrentTime_ = function() {
                    if (!(this.tech_.paused() || this.tech_.seeking())) {
                        var currentTime = this.tech_.currentTime(), buffered = this.tech_.buffered();
                        if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) return this.techWaiting_();
                        this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : currentTime === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = currentTime);
                    }
                }, _proto.cancelTimer_ = function() {
                    this.consecutiveUpdates = 0, this.timer_ && (this.logger_("cancelTimer_"), clearTimeout(this.timer_)), this.timer_ = null;
                }, _proto.fixesBadSeeks_ = function() {
                    if (!this.tech_.seeking()) return !1;
                    var seekTo, seekable = this.seekable(), currentTime = this.tech_.currentTime();
                    if (this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow) && (seekTo = seekable.end(seekable.length - 1)), this.beforeSeekableWindow_(seekable, currentTime)) {
                        var seekableStart = seekable.start(0);
                        seekTo = seekableStart + (seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);
                    }
                    if (void 0 !== seekTo) return this.logger_("Trying to seek outside of seekable at time " + currentTime + " with seekable range " + printableRange(seekable) + ". Seeking to " + seekTo + "."), this.tech_.setCurrentTime(seekTo), !0;
                    for(var sourceUpdater = this.masterPlaylistController_.sourceUpdater_, buffered = this.tech_.buffered(), audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null, videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null, media = this.media(), minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2, bufferedToCheck = [
                        audioBuffered,
                        videoBuffered
                    ], i = 0; i < bufferedToCheck.length; i++)if (bufferedToCheck[i] && timeAheadOf(bufferedToCheck[i], currentTime) < minAppendedDuration) return !1;
                    var nextRange = findNextRange(buffered, currentTime);
                    return 0 !== nextRange.length && (seekTo = nextRange.start(0) + SAFE_TIME_DELTA, this.logger_("Buffered region starts (" + nextRange.start(0) + ")  just beyond seek point (" + currentTime + "). Seeking to " + seekTo + "."), this.tech_.setCurrentTime(seekTo), !0);
                }, _proto.waiting_ = function() {
                    if (!this.techWaiting_()) {
                        var currentTime = this.tech_.currentTime(), currentRange = findRange(this.tech_.buffered(), currentTime);
                        if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
                            this.cancelTimer_(), this.tech_.setCurrentTime(currentTime), this.logger_("Stopped at " + currentTime + " while inside a buffered region [" + currentRange.start(0) + " -> " + currentRange.end(0) + "]. Attempting to resume playback by seeking to the current time."), this.tech_.trigger({
                                type: "usage",
                                name: "vhs-unknown-waiting"
                            }), this.tech_.trigger({
                                type: "usage",
                                name: "hls-unknown-waiting"
                            });
                            return;
                        }
                    }
                }, _proto.techWaiting_ = function() {
                    var seekable = this.seekable(), currentTime = this.tech_.currentTime();
                    if (this.tech_.seeking() || null !== this.timer_) return !0;
                    if (this.beforeSeekableWindow_(seekable, currentTime)) {
                        var livePoint = seekable.end(seekable.length - 1);
                        return this.logger_("Fell out of live window at time " + currentTime + ". Seeking to live point (seekable end) " + livePoint), this.cancelTimer_(), this.tech_.setCurrentTime(livePoint), this.tech_.trigger({
                            type: "usage",
                            name: "vhs-live-resync"
                        }), this.tech_.trigger({
                            type: "usage",
                            name: "hls-live-resync"
                        }), !0;
                    }
                    var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_, buffered = this.tech_.buffered();
                    if (this.videoUnderflow_({
                        audioBuffered: sourceUpdater.audioBuffered(),
                        videoBuffered: sourceUpdater.videoBuffered(),
                        currentTime: currentTime
                    })) return this.cancelTimer_(), this.tech_.setCurrentTime(currentTime), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-video-underflow"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-video-underflow"
                    }), !0;
                    var nextRange = findNextRange(buffered, currentTime);
                    if (nextRange.length > 0) {
                        var difference = nextRange.start(0) - currentTime;
                        return this.logger_("Stopped at " + currentTime + ", setting timer for " + difference + ", seeking to " + nextRange.start(0)), this.cancelTimer_(), this.timer_ = setTimeout(this.skipTheGap_.bind(this), 1000 * difference, currentTime), !0;
                    }
                    return !1;
                }, _proto.afterSeekableWindow_ = function(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {
                    if (void 0 === allowSeeksWithinUnsafeLiveWindow && (allowSeeksWithinUnsafeLiveWindow = !1), !seekable.length) return !1;
                    var allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;
                    return !playlist.endList && allowSeeksWithinUnsafeLiveWindow && (allowedEnd = seekable.end(seekable.length - 1) + 3 * playlist.targetDuration), currentTime > allowedEnd;
                }, _proto.beforeSeekableWindow_ = function(seekable, currentTime) {
                    return !!(seekable.length && seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta);
                }, _proto.videoUnderflow_ = function(_ref) {
                    var gap, videoBuffered = _ref.videoBuffered, audioBuffered = _ref.audioBuffered, currentTime = _ref.currentTime;
                    if (videoBuffered) {
                        if (videoBuffered.length && audioBuffered.length) {
                            var lastVideoRange = findRange(videoBuffered, currentTime - 3), videoRange = findRange(videoBuffered, currentTime), audioRange = findRange(audioBuffered, currentTime);
                            audioRange.length && !videoRange.length && lastVideoRange.length && (gap = {
                                start: lastVideoRange.end(0),
                                end: audioRange.end(0)
                            });
                        } else findNextRange(videoBuffered, currentTime).length || (gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime));
                        return !!gap && (this.logger_("Encountered a gap in video from " + gap.start + " to " + gap.end + ". Seeking to current time " + currentTime), !0);
                    }
                }, _proto.skipTheGap_ = function(scheduledCurrentTime) {
                    var buffered = this.tech_.buffered(), currentTime = this.tech_.currentTime(), nextRange = findNextRange(buffered, currentTime);
                    this.cancelTimer_(), 0 !== nextRange.length && currentTime === scheduledCurrentTime && (this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0)), this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-gap-skip"
                    }), this.tech_.trigger({
                        type: "usage",
                        name: "hls-gap-skip"
                    }));
                }, _proto.gapFromVideoUnderflow_ = function(buffered, currentTime) {
                    for(var gaps = findGaps(buffered), i = 0; i < gaps.length; i++){
                        var start = gaps.start(i), end = gaps.end(i);
                        if (currentTime - start < 4 && currentTime - start > 2) return {
                            start: start,
                            end: end
                        };
                    }
                    return null;
                }, PlaybackWatcher;
            }(), defaultOptions = {
                errorInterval: 30,
                getSource: function(next) {
                    return next(this.tech({
                        IWillNotUseThisInPlugins: !0
                    }).currentSource_ || this.currentSource());
                }
            }, initPlugin = function initPlugin(player, options) {
                var lastCalled = 0, seekTo = 0, localOptions = videojs.mergeOptions(defaultOptions, options);
                player.ready(function() {
                    player.trigger({
                        type: "usage",
                        name: "vhs-error-reload-initialized"
                    }), player.trigger({
                        type: "usage",
                        name: "hls-error-reload-initialized"
                    });
                });
                var loadedMetadataHandler = function() {
                    seekTo && player.currentTime(seekTo);
                }, setSource = function(sourceObj) {
                    null != sourceObj && (seekTo = player.duration() !== 1 / 0 && player.currentTime() || 0, player.one("loadedmetadata", loadedMetadataHandler), player.src(sourceObj), player.trigger({
                        type: "usage",
                        name: "vhs-error-reload"
                    }), player.trigger({
                        type: "usage",
                        name: "hls-error-reload"
                    }), player.play());
                }, errorHandler = function() {
                    if (Date.now() - lastCalled < 1000 * localOptions.errorInterval) {
                        player.trigger({
                            type: "usage",
                            name: "vhs-error-reload-canceled"
                        }), player.trigger({
                            type: "usage",
                            name: "hls-error-reload-canceled"
                        });
                        return;
                    }
                    if (!localOptions.getSource || "function" != typeof localOptions.getSource) {
                        videojs.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
                        return;
                    }
                    return lastCalled = Date.now(), localOptions.getSource.call(player, setSource);
                }, cleanupEvents = function cleanupEvents() {
                    player.off("loadedmetadata", loadedMetadataHandler), player.off("error", errorHandler), player.off("dispose", cleanupEvents);
                };
                player.on("error", errorHandler), player.on("dispose", cleanupEvents), player.reloadSourceOnError = function(newOptions) {
                    cleanupEvents(), initPlugin(player, newOptions);
                };
            }, version$4 = "2.12.0", Vhs = {
                PlaylistLoader: PlaylistLoader,
                Playlist: Playlist,
                utils: utils,
                STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
                INITIAL_PLAYLIST_SELECTOR: function() {
                    var _this = this, playlists = this.playlists.master.playlists.filter(Playlist.isEnabled);
                    return stableSort(playlists, function(a, b) {
                        return comparePlaylistBandwidth(a, b);
                    }), playlists.filter(function(playlist) {
                        return !!codecsForPlaylist(_this.playlists.master, playlist).video;
                    })[0] || null;
                },
                lastBandwidthSelector: lastBandwidthSelector,
                movingAverageBandwidthSelector: function(decay) {
                    var average = -1, lastSystemBandwidth = -1;
                    if (decay < 0 || decay > 1) throw Error("Moving average bandwidth decay must be between 0 and 1.");
                    return function() {
                        var pixelRatio = this.useDevicePixelRatio && global_window__WEBPACK_IMPORTED_MODULE_0___default().devicePixelRatio || 1;
                        return average < 0 && (average = this.systemBandwidth, lastSystemBandwidth = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth && (average = decay * this.systemBandwidth + (1 - decay) * average, lastSystemBandwidth = this.systemBandwidth), simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
                    };
                },
                comparePlaylistBandwidth: comparePlaylistBandwidth,
                comparePlaylistResolution: function(left, right) {
                    var leftWidth, rightWidth;
                    return (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width && (leftWidth = left.attributes.RESOLUTION.width), leftWidth = leftWidth || global_window__WEBPACK_IMPORTED_MODULE_0___default().Number.MAX_VALUE, right.attributes.RESOLUTION && right.attributes.RESOLUTION.width && (rightWidth = right.attributes.RESOLUTION.width), leftWidth === (rightWidth = rightWidth || global_window__WEBPACK_IMPORTED_MODULE_0___default().Number.MAX_VALUE) && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) ? left.attributes.BANDWIDTH - right.attributes.BANDWIDTH : leftWidth - rightWidth;
                },
                xhr: xhrFactory()
            };
            Object.keys(Config).forEach(function(prop) {
                Object.defineProperty(Vhs, prop, {
                    get: function() {
                        return videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing"), Config[prop];
                    },
                    set: function(value) {
                        if (videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing"), "number" != typeof value || value < 0) {
                            videojs.log.warn("value of Vhs." + prop + " must be greater than or equal to 0");
                            return;
                        }
                        Config[prop] = value;
                    }
                });
            });
            var LOCAL_STORAGE_KEY = "videojs-vhs", handleVhsMediaChange = function(qualityLevels, playlistLoader) {
                for(var newPlaylist = playlistLoader.media(), selectedIndex = -1, i = 0; i < qualityLevels.length; i++)if (qualityLevels[i].id === newPlaylist.id) {
                    selectedIndex = i;
                    break;
                }
                qualityLevels.selectedIndex_ = selectedIndex, qualityLevels.trigger({
                    selectedIndex: selectedIndex,
                    type: "change"
                });
            }, handleVhsLoadedMetadata = function(qualityLevels, vhs) {
                vhs.representations().forEach(function(rep) {
                    qualityLevels.addQualityLevel(rep);
                }), handleVhsMediaChange(qualityLevels, vhs.playlists);
            };
            Vhs.canPlaySource = function() {
                return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
            };
            var emeKeySystems = function(keySystemOptions, mainPlaylist, audioPlaylist) {
                if (!keySystemOptions) return keySystemOptions;
                var codecs = {};
                mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS && (codecs = unwrapCodecList((0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.kS)(mainPlaylist.attributes.CODECS))), audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS && (codecs.audio = audioPlaylist.attributes.CODECS);
                var videoContentType = (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__._5)(codecs.video), audioContentType = (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__._5)(codecs.audio), keySystemContentTypes = {};
                for(var keySystem in keySystemOptions)keySystemContentTypes[keySystem] = {}, audioContentType && (keySystemContentTypes[keySystem].audioContentType = audioContentType), videoContentType && (keySystemContentTypes[keySystem].videoContentType = videoContentType), mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh && (keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh), "string" == typeof keySystemOptions[keySystem] && (keySystemContentTypes[keySystem].url = keySystemOptions[keySystem]);
                return videojs.mergeOptions(keySystemOptions, keySystemContentTypes);
            }, waitForKeySessionCreation = function(_ref) {
                var playlists, keySystems, player = _ref.player, sourceKeySystems = _ref.sourceKeySystems, audioMedia = _ref.audioMedia, mainPlaylists = _ref.mainPlaylists;
                if (!player.eme.initializeMediaKeys) return Promise.resolve();
                var keySystemsOptionsArr = (playlists = audioMedia ? mainPlaylists.concat([
                    audioMedia
                ]) : mainPlaylists, keySystems = Object.keys(sourceKeySystems), playlists.reduce(function(keySystemsArr, playlist) {
                    if (!playlist.contentProtection) return keySystemsArr;
                    var keySystemsOptions = keySystems.reduce(function(keySystemsObj, keySystem) {
                        var keySystemOptions = playlist.contentProtection[keySystem];
                        return keySystemOptions && keySystemOptions.pssh && (keySystemsObj[keySystem] = {
                            pssh: keySystemOptions.pssh
                        }), keySystemsObj;
                    }, {});
                    return Object.keys(keySystemsOptions).length && keySystemsArr.push(keySystemsOptions), keySystemsArr;
                }, [])), initializationFinishedPromises = [], keySessionCreatedPromises = [];
                return keySystemsOptionsArr.forEach(function(keySystemsOptions) {
                    keySessionCreatedPromises.push(new Promise(function(resolve, reject) {
                        player.tech_.one("keysessioncreated", resolve);
                    })), initializationFinishedPromises.push(new Promise(function(resolve, reject) {
                        player.eme.initializeMediaKeys({
                            keySystems: keySystemsOptions
                        }, function(err) {
                            if (err) {
                                reject(err);
                                return;
                            }
                            resolve();
                        });
                    }));
                }), Promise.race([
                    Promise.all(initializationFinishedPromises),
                    Promise.race(keySessionCreatedPromises)
                ]);
            }, setupEmeOptions = function(_ref2) {
                var player = _ref2.player, sourceOptions = emeKeySystems(_ref2.sourceKeySystems, _ref2.media, _ref2.audioMedia);
                return !!sourceOptions && (player.currentSource().keySystems = sourceOptions, !sourceOptions || !!player.eme || (videojs.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), !1));
            }, getVhsLocalStorage = function() {
                if (!global_window__WEBPACK_IMPORTED_MODULE_0___default().localStorage) return null;
                var storedObject = global_window__WEBPACK_IMPORTED_MODULE_0___default().localStorage.getItem(LOCAL_STORAGE_KEY);
                if (!storedObject) return null;
                try {
                    return JSON.parse(storedObject);
                } catch (e) {
                    return null;
                }
            }, updateVhsLocalStorage = function(options) {
                if (!global_window__WEBPACK_IMPORTED_MODULE_0___default().localStorage) return !1;
                var objectToStore = getVhsLocalStorage();
                objectToStore = objectToStore ? videojs.mergeOptions(objectToStore, options) : options;
                try {
                    global_window__WEBPACK_IMPORTED_MODULE_0___default().localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
                } catch (e) {
                    return !1;
                }
                return objectToStore;
            };
            Vhs.supportsNativeHls = function() {
                if (!global_document__WEBPACK_IMPORTED_MODULE_1___default() || !global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement) return !1;
                var video = global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("video");
                return !!videojs.getTech("Html5").isSupported() && [
                    "application/vnd.apple.mpegurl",
                    "audio/mpegurl",
                    "audio/x-mpegurl",
                    "application/x-mpegurl",
                    "video/x-mpegurl",
                    "video/mpegurl",
                    "application/mpegurl"
                ].some(function(canItPlay) {
                    return /maybe|probably/i.test(video.canPlayType(canItPlay));
                });
            }(), Vhs.supportsNativeDash = !!(global_document__WEBPACK_IMPORTED_MODULE_1___default() && global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement && videojs.getTech("Html5").isSupported()) && /maybe|probably/i.test(global_document__WEBPACK_IMPORTED_MODULE_1___default().createElement("video").canPlayType("application/dash+xml")), Vhs.supportsTypeNatively = function(type) {
                return "hls" === type ? Vhs.supportsNativeHls : "dash" === type && Vhs.supportsNativeDash;
            }, Vhs.isSupported = function() {
                return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
            };
            var VhsHandler = function(_Component) {
                function VhsHandler(source, tech, options) {
                    var _this;
                    if (_this = _Component.call(this, tech, videojs.mergeOptions(options.hls, options.vhs)) || this, options.hls && Object.keys(options.hls).length && videojs.log.warn("Using hls options is deprecated. Use vhs instead."), "number" == typeof options.initialBandwidth && (_this.options_.bandwidth = options.initialBandwidth), _this.logger_ = logger("VhsHandler"), tech.options_ && tech.options_.playerId) {
                        var _player = videojs(tech.options_.playerId);
                        _player.hasOwnProperty("hls") || Object.defineProperty(_player, "hls", {
                            get: function() {
                                return videojs.log.warn("player.hls is deprecated. Use player.tech().vhs instead."), tech.trigger({
                                    type: "usage",
                                    name: "hls-player-access"
                                }), (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this);
                            },
                            configurable: !0
                        }), _player.hasOwnProperty("vhs") || Object.defineProperty(_player, "vhs", {
                            get: function() {
                                return videojs.log.warn("player.vhs is deprecated. Use player.tech().vhs instead."), tech.trigger({
                                    type: "usage",
                                    name: "vhs-player-access"
                                }), (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this);
                            },
                            configurable: !0
                        }), _player.hasOwnProperty("dash") || Object.defineProperty(_player, "dash", {
                            get: function() {
                                return videojs.log.warn("player.dash is deprecated. Use player.tech().vhs instead."), (0, _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_17__.Z)(_this);
                            },
                            configurable: !0
                        }), _this.player_ = _player;
                    }
                    if (_this.tech_ = tech, _this.source_ = source, _this.stats = {}, _this.ignoreNextSeekingEvent_ = !1, _this.setOptions_(), _this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) tech.overrideNativeAudioTracks(!0), tech.overrideNativeVideoTracks(!0);
                    else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) throw Error("Overriding native HLS requires emulated tracks. See https://git.io/vMpjB");
                    return _this.on(global_document__WEBPACK_IMPORTED_MODULE_1___default(), [
                        "fullscreenchange",
                        "webkitfullscreenchange",
                        "mozfullscreenchange",
                        "MSFullscreenChange"
                    ], function(event) {
                        var fullscreenElement = global_document__WEBPACK_IMPORTED_MODULE_1___default().fullscreenElement || global_document__WEBPACK_IMPORTED_MODULE_1___default().webkitFullscreenElement || global_document__WEBPACK_IMPORTED_MODULE_1___default().mozFullScreenElement || global_document__WEBPACK_IMPORTED_MODULE_1___default().msFullscreenElement;
                        fullscreenElement && fullscreenElement.contains(_this.tech_.el()) ? _this.masterPlaylistController_.fastQualityChange_() : _this.masterPlaylistController_.checkABR_();
                    }), _this.on(_this.tech_, "seeking", function() {
                        if (this.ignoreNextSeekingEvent_) {
                            this.ignoreNextSeekingEvent_ = !1;
                            return;
                        }
                        this.setCurrentTime(this.tech_.currentTime());
                    }), _this.on(_this.tech_, "error", function() {
                        this.tech_.error() && this.masterPlaylistController_ && this.masterPlaylistController_.pauseLoading();
                    }), _this.on(_this.tech_, "play", _this.play), _this;
                }
                (0, _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_16__.Z)(VhsHandler, _Component);
                var _proto = VhsHandler.prototype;
                return _proto.setOptions_ = function() {
                    var _this2 = this;
                    if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.handleManifestRedirects = !1 !== this.options_.handleManifestRedirects, this.options_.limitRenditionByPlayerDimensions = !1 !== this.options_.limitRenditionByPlayerDimensions, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.smoothQualityChange = this.options_.smoothQualityChange || !1, this.options_.useBandwidthFromLocalStorage = void 0 !== this.source_.useBandwidthFromLocalStorage ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, "number" != typeof this.options_.blacklistDuration && (this.options_.blacklistDuration = 300), "number" != typeof this.options_.bandwidth && this.options_.useBandwidthFromLocalStorage) {
                        var storedObject = getVhsLocalStorage();
                        storedObject && storedObject.bandwidth && (this.options_.bandwidth = storedObject.bandwidth, this.tech_.trigger({
                            type: "usage",
                            name: "vhs-bandwidth-from-local-storage"
                        }), this.tech_.trigger({
                            type: "usage",
                            name: "hls-bandwidth-from-local-storage"
                        })), storedObject && storedObject.throughput && (this.options_.throughput = storedObject.throughput, this.tech_.trigger({
                            type: "usage",
                            name: "vhs-throughput-from-local-storage"
                        }), this.tech_.trigger({
                            type: "usage",
                            name: "hls-throughput-from-local-storage"
                        }));
                    }
                    "number" != typeof this.options_.bandwidth && (this.options_.bandwidth = Config.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH, [
                        "withCredentials",
                        "useDevicePixelRatio",
                        "limitRenditionByPlayerDimensions",
                        "bandwidth",
                        "smoothQualityChange",
                        "customTagParsers",
                        "customTagMappers",
                        "handleManifestRedirects",
                        "cacheEncryptionKeys",
                        "playlistSelector",
                        "initialPlaylistSelector",
                        "experimentalBufferBasedABR",
                        "liveRangeSafeTimeDelta",
                        "experimentalLLHLS",
                        "useNetworkInformationApi",
                        "experimentalExactManifestTimings",
                        "experimentalLeastPixelDiffSelector"
                    ].forEach(function(option) {
                        void 0 !== _this2.source_[option] && (_this2.options_[option] = _this2.source_[option]);
                    }), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
                }, _proto.src = function(_src, type) {
                    var dataUri, _this3 = this;
                    if (_src) {
                        this.setOptions_(), this.options_.src = 0 === (dataUri = this.source_.src).toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") ? JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1)) : dataUri, this.options_.tech = this.tech_, this.options_.externVhs = Vhs, this.options_.sourceType = (0, _videojs_vhs_utils_es_media_types_js__WEBPACK_IMPORTED_MODULE_20__.t)(type), this.options_.seekTo = function(time) {
                            _this3.tech_.setCurrentTime(time);
                        }, this.options_.smoothQualityChange && videojs.log.warn("smoothQualityChange is deprecated and will be removed in the next major version"), this.masterPlaylistController_ = new MasterPlaylistController(this.options_);
                        var playbackWatcherOptions = videojs.mergeOptions({
                            liveRangeSafeTimeDelta: SAFE_TIME_DELTA
                        }, this.options_, {
                            seekable: function() {
                                return _this3.seekable();
                            },
                            media: function() {
                                return _this3.masterPlaylistController_.media();
                            },
                            masterPlaylistController: this.masterPlaylistController_
                        });
                        this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions), this.masterPlaylistController_.on("error", function() {
                            var player = videojs.players[_this3.tech_.options_.playerId], error = _this3.masterPlaylistController_.error;
                            "object" != typeof error || error.code ? "string" == typeof error && (error = {
                                message: error,
                                code: 3
                            }) : error.code = 3, player.error(error);
                        });
                        var defaultSelector = this.options_.experimentalBufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
                        this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this), this.masterPlaylistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.masterPlaylistController_.masterPlaylistLoader_, this.mediaSource = this.masterPlaylistController_.mediaSource, Object.defineProperties(this, {
                            selectPlaylist: {
                                get: function() {
                                    return this.masterPlaylistController_.selectPlaylist;
                                },
                                set: function(selectPlaylist) {
                                    this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);
                                }
                            },
                            throughput: {
                                get: function() {
                                    return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
                                },
                                set: function(throughput) {
                                    this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput, this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
                                }
                            },
                            bandwidth: {
                                get: function() {
                                    var playerBandwidthEst = this.masterPlaylistController_.mainSegmentLoader_.bandwidth, networkInformation = global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator.connection || global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator.mozConnection || global_window__WEBPACK_IMPORTED_MODULE_0___default().navigator.webkitConnection;
                                    if (this.options_.useNetworkInformationApi && networkInformation) {
                                        var networkInfoBandwidthEstBitsPerSec = 1000000 * networkInformation.downlink;
                                        playerBandwidthEst = networkInfoBandwidthEstBitsPerSec >= 10e6 && playerBandwidthEst >= 10e6 ? Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec) : networkInfoBandwidthEstBitsPerSec;
                                    }
                                    return playerBandwidthEst;
                                },
                                set: function(bandwidth) {
                                    this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth, this.masterPlaylistController_.mainSegmentLoader_.throughput = {
                                        rate: 0,
                                        count: 0
                                    };
                                }
                            },
                            systemBandwidth: {
                                get: function() {
                                    return Math.floor(1 / (1 / (this.bandwidth || 1) + (this.throughput > 0 ? 1 / this.throughput : 0)));
                                },
                                set: function() {
                                    videojs.log.error('The "systemBandwidth" property is read-only');
                                }
                            }
                        }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, {
                            bandwidth: {
                                get: function() {
                                    return _this3.bandwidth || 0;
                                },
                                enumerable: !0
                            },
                            mediaRequests: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaRequests_() || 0;
                                },
                                enumerable: !0
                            },
                            mediaRequestsAborted: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;
                                },
                                enumerable: !0
                            },
                            mediaRequestsTimedout: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;
                                },
                                enumerable: !0
                            },
                            mediaRequestsErrored: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;
                                },
                                enumerable: !0
                            },
                            mediaTransferDuration: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;
                                },
                                enumerable: !0
                            },
                            mediaBytesTransferred: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;
                                },
                                enumerable: !0
                            },
                            mediaSecondsLoaded: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;
                                },
                                enumerable: !0
                            },
                            mediaAppends: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mediaAppends_() || 0;
                                },
                                enumerable: !0
                            },
                            mainAppendsToLoadedData: {
                                get: function() {
                                    return _this3.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
                                },
                                enumerable: !0
                            },
                            audioAppendsToLoadedData: {
                                get: function() {
                                    return _this3.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
                                },
                                enumerable: !0
                            },
                            appendsToLoadedData: {
                                get: function() {
                                    return _this3.masterPlaylistController_.appendsToLoadedData_() || 0;
                                },
                                enumerable: !0
                            },
                            timeToLoadedData: {
                                get: function() {
                                    return _this3.masterPlaylistController_.timeToLoadedData_() || 0;
                                },
                                enumerable: !0
                            },
                            buffered: {
                                get: function() {
                                    return timeRangesToArray(_this3.tech_.buffered());
                                },
                                enumerable: !0
                            },
                            currentTime: {
                                get: function() {
                                    return _this3.tech_.currentTime();
                                },
                                enumerable: !0
                            },
                            currentSource: {
                                get: function() {
                                    return _this3.tech_.currentSource_;
                                },
                                enumerable: !0
                            },
                            currentTech: {
                                get: function() {
                                    return _this3.tech_.name_;
                                },
                                enumerable: !0
                            },
                            duration: {
                                get: function() {
                                    return _this3.tech_.duration();
                                },
                                enumerable: !0
                            },
                            master: {
                                get: function() {
                                    return _this3.playlists.master;
                                },
                                enumerable: !0
                            },
                            playerDimensions: {
                                get: function() {
                                    return _this3.tech_.currentDimensions();
                                },
                                enumerable: !0
                            },
                            seekable: {
                                get: function() {
                                    return timeRangesToArray(_this3.tech_.seekable());
                                },
                                enumerable: !0
                            },
                            timestamp: {
                                get: function() {
                                    return Date.now();
                                },
                                enumerable: !0
                            },
                            videoPlaybackQuality: {
                                get: function() {
                                    return _this3.tech_.getVideoPlaybackQuality();
                                },
                                enumerable: !0
                            }
                        }), this.tech_.one("canplay", this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_)), this.tech_.on("bandwidthupdate", function() {
                            _this3.options_.useBandwidthFromLocalStorage && updateVhsLocalStorage({
                                bandwidth: _this3.bandwidth,
                                throughput: Math.round(_this3.throughput)
                            });
                        }), this.masterPlaylistController_.on("selectedinitialmedia", function() {
                            renditionSelectionMixin(_this3);
                        }), this.masterPlaylistController_.sourceUpdater_.on("createdsourcebuffers", function() {
                            _this3.setupEme_();
                        }), this.on(this.masterPlaylistController_, "progress", function() {
                            this.tech_.trigger("progress");
                        }), this.on(this.masterPlaylistController_, "firstplay", function() {
                            this.ignoreNextSeekingEvent_ = !0;
                        }), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = global_window__WEBPACK_IMPORTED_MODULE_0___default().URL.createObjectURL(this.masterPlaylistController_.mediaSource), this.tech_.src(this.mediaSourceUrl_));
                    }
                }, _proto.setupEme_ = function() {
                    var _this4 = this, audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader, didSetupEmeOptions = setupEmeOptions({
                        player: this.player_,
                        sourceKeySystems: this.source_.keySystems,
                        media: this.playlists.media(),
                        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
                    });
                    if (this.player_.tech_.on("keystatuschange", function(e) {
                        "output-restricted" === e.status && _this4.masterPlaylistController_.blacklistCurrentPlaylist({
                            playlist: _this4.masterPlaylistController_.media(),
                            message: "DRM keystatus changed to " + e.status + ". Playlist will fail to play. Check for HDCP content.",
                            blacklistDuration: 1 / 0
                        });
                    }), 11 === videojs.browser.IE_VERSION || !didSetupEmeOptions) {
                        this.masterPlaylistController_.sourceUpdater_.initializedEme();
                        return;
                    }
                    this.logger_("waiting for EME key session creation"), waitForKeySessionCreation({
                        player: this.player_,
                        sourceKeySystems: this.source_.keySystems,
                        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
                        mainPlaylists: this.playlists.master.playlists
                    }).then(function() {
                        _this4.logger_("created EME key session"), _this4.masterPlaylistController_.sourceUpdater_.initializedEme();
                    }).catch(function(err) {
                        _this4.logger_("error while creating EME key session", err), _this4.player_.error({
                            message: "Failed to initialize media keys for EME",
                            code: 3
                        });
                    });
                }, _proto.setupQualityLevels_ = function() {
                    var _this5 = this, player = videojs.players[this.tech_.options_.playerId];
                    player && player.qualityLevels && !this.qualityLevels_ && (this.qualityLevels_ = player.qualityLevels(), this.masterPlaylistController_.on("selectedinitialmedia", function() {
                        handleVhsLoadedMetadata(_this5.qualityLevels_, _this5);
                    }), this.playlists.on("mediachange", function() {
                        handleVhsMediaChange(_this5.qualityLevels_, _this5.playlists);
                    }));
                }, VhsHandler.version = function() {
                    return {
                        "@videojs/http-streaming": version$4,
                        "mux.js": "5.14.1",
                        "mpd-parser": "0.19.2",
                        "m3u8-parser": "4.7.0",
                        "aes-decrypter": "3.1.2"
                    };
                }, _proto.version = function() {
                    return this.constructor.version();
                }, _proto.canChangeType = function() {
                    return SourceUpdater.canChangeType();
                }, _proto.play = function() {
                    this.masterPlaylistController_.play();
                }, _proto.setCurrentTime = function(currentTime) {
                    this.masterPlaylistController_.setCurrentTime(currentTime);
                }, _proto.duration = function() {
                    return this.masterPlaylistController_.duration();
                }, _proto.seekable = function() {
                    return this.masterPlaylistController_.seekable();
                }, _proto.dispose = function() {
                    this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.masterPlaylistController_ && this.masterPlaylistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.player_ && (delete this.player_.vhs, delete this.player_.dash, delete this.player_.hls), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.tech_ && delete this.tech_.hls, this.mediaSourceUrl_ && global_window__WEBPACK_IMPORTED_MODULE_0___default().URL.revokeObjectURL && (global_window__WEBPACK_IMPORTED_MODULE_0___default().URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), _Component.prototype.dispose.call(this);
                }, _proto.convertToProgramTime = function(time, callback) {
                    return getProgramTime({
                        playlist: this.masterPlaylistController_.media(),
                        time: time,
                        callback: callback
                    });
                }, _proto.seekToProgramTime = function(programTime, callback, pauseAfterSeek, retryCount) {
                    return void 0 === pauseAfterSeek && (pauseAfterSeek = !0), void 0 === retryCount && (retryCount = 2), seekToProgramTime({
                        programTime: programTime,
                        playlist: this.masterPlaylistController_.media(),
                        retryCount: retryCount,
                        pauseAfterSeek: pauseAfterSeek,
                        seekTo: this.options_.seekTo,
                        tech: this.options_.tech,
                        callback: callback
                    });
                }, VhsHandler;
            }(videojs.getComponent("Component")), VhsSourceHandler = {
                name: "videojs-http-streaming",
                VERSION: version$4,
                canHandleSource: function(srcObj, options) {
                    void 0 === options && (options = {});
                    var localOptions = videojs.mergeOptions(videojs.options, options);
                    return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
                },
                handleSource: function(source, tech, options) {
                    void 0 === options && (options = {});
                    var localOptions = videojs.mergeOptions(videojs.options, options);
                    return tech.vhs = new VhsHandler(source, tech, localOptions), videojs.hasOwnProperty("hls") || Object.defineProperty(tech, "hls", {
                        get: function() {
                            return videojs.log.warn("player.tech().hls is deprecated. Use player.tech().vhs instead."), tech.vhs;
                        },
                        configurable: !0
                    }), tech.vhs.xhr = xhrFactory(), tech.vhs.src(source.src, source.type), tech.vhs;
                },
                canPlayType: function(type, options) {
                    void 0 === options && (options = {});
                    var _videojs$mergeOptions2 = videojs.mergeOptions(videojs.options, options).vhs.overrideNative, overrideNative = void 0 === _videojs$mergeOptions2 ? !videojs.browser.IS_ANY_SAFARI : _videojs$mergeOptions2, supportedType = (0, _videojs_vhs_utils_es_media_types_js__WEBPACK_IMPORTED_MODULE_20__.t)(type);
                    return supportedType && (!Vhs.supportsTypeNatively(supportedType) || overrideNative) ? "maybe" : "";
                }
            };
            (0, _videojs_vhs_utils_es_codecs_js__WEBPACK_IMPORTED_MODULE_8__.p7)("avc1.4d400d,mp4a.40.2") && videojs.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0), videojs.VhsHandler = VhsHandler, Object.defineProperty(videojs, "HlsHandler", {
                get: function() {
                    return videojs.log.warn("videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead."), VhsHandler;
                },
                configurable: !0
            }), videojs.VhsSourceHandler = VhsSourceHandler, Object.defineProperty(videojs, "HlsSourceHandler", {
                get: function() {
                    return videojs.log.warn("videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead."), VhsSourceHandler;
                },
                configurable: !0
            }), videojs.Vhs = Vhs, Object.defineProperty(videojs, "Hls", {
                get: function() {
                    return videojs.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead."), Vhs;
                },
                configurable: !0
            }), videojs.use || (videojs.registerComponent("Hls", Vhs), videojs.registerComponent("Vhs", Vhs)), videojs.options.vhs = videojs.options.vhs || {}, videojs.options.hls = videojs.options.hls || {}, videojs.getPlugin && videojs.getPlugin("reloadSourceOnError") || (videojs.registerPlugin || videojs.plugin)("reloadSourceOnError", function(options) {
                initPlugin(this, options);
            }), __webpack_exports__.Z = videojs;
        }
    }
]);
