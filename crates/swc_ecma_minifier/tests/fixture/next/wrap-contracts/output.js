(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [
        514
    ],
    {
        8161: function(module, __unused_webpack_exports, __webpack_require__) {
            const elliptic = __webpack_require__(6266), BN = __webpack_require__(3783), { sha256  } = __webpack_require__(2023), { sha512  } = __webpack_require__(3434), EC = new elliptic.ec('secp256k1');
            function toBytesInt32(num) {
                return new Uint8Array([
                    (0xff000000 & num) >> 24,
                    (0x00ff0000 & num) >> 16,
                    (0x0000ff00 & num) >> 8,
                    0x000000ff & num, 
                ]);
            }
            const one = new BN(1);
            function Unmarshal(data) {
                const byteLen = EC.n.bitLength() + 7 >> 3;
                if (EC.g.mul(10), (-2 & data[0]) != 2 || data.length != 1 + byteLen) return [
                    null,
                    null
                ];
                const tx = new BN(data.slice(1, 1 + byteLen));
                try {
                    const p = EC.curve.pointFromX(tx);
                    return [
                        p.x,
                        p.y
                    ];
                } catch (e) {
                    return [
                        null,
                        null
                    ];
                }
            }
            function H1(m) {
                let x = null, y = null;
                const byteLen = EC.n.bitLength() + 7 >> 3;
                let i = 0;
                for(; null == x && i < 100;){
                    const res = sha512.array(new Uint8Array([
                        ...toBytesInt32(i),
                        ...m
                    ])), r = [
                        2,
                        ...res
                    ];
                    [x, y] = Unmarshal(r.slice(0, byteLen + 1)), i++;
                }
                return EC.curve.point(x, y);
            }
            function H2(m) {
                const byteLen = EC.n.bitLength() + 7 >> 3;
                let i = 0;
                for(;;){
                    const res = sha512.array(new Uint8Array([
                        ...toBytesInt32(i),
                        ...m
                    ])), k = new BN(res.slice(0, byteLen));
                    if (-1 == k.cmp(EC.curve.n.sub(one))) return k.add(one);
                    i++;
                }
            }
            function Evaluate(privateKey, m) {
                const currentKey = EC.keyFromPrivate(privateKey), r = EC.genKeyPair(), rBN = r.getPrivate(), pointH = H1(m), point = pointH.mul(privateKey), vrf = point.encode(), rgPoint = EC.curve.g.mul(rBN), rhPoint = pointH.mul(rBN), b = [
                    ...EC.curve.g.encode(),
                    ...pointH.encode(),
                    ...currentKey.getPublic().encode(),
                    ...vrf,
                    ...rgPoint.encode(),
                    ...rhPoint.encode(), 
                ], s = H2(b), t = rBN.sub(s.mul(currentKey.getPrivate())).umod(EC.curve.n), index = sha256.array(new Uint8Array(vrf)), buf = [
                    ...Array(32 - s.byteLength()).fill(0),
                    ...s.toArray(),
                    ...Array(32 - t.byteLength()).fill(0),
                    ...t.toArray(),
                    ...vrf, 
                ];
                return [
                    index,
                    buf
                ];
            }
            function ProofHoHash(publicKey, data, proof) {
                const currentKey = EC.keyFromPublic(publicKey);
                if (129 !== proof.length) throw Error('invalid vrf');
                const s = proof.slice(0, 32), t = proof.slice(32, 64), vrf = proof.slice(64, 129), uhPoint = decodePoint(vrf);
                if (!uhPoint) throw Error('invalid vrf');
                const tgPoint = EC.curve.g.mul(t), ksgPoint = currentKey.getPublic().mul(s), tksgPoint = tgPoint.add(ksgPoint), hPoint = H1(data), thPoint = hPoint.mul(t), shPoint = uhPoint.mul(s), tkshPoint = thPoint.add(shPoint), b = [
                    ...EC.curve.g.encode(),
                    ...hPoint.encode(),
                    ...currentKey.getPublic().encode(),
                    ...vrf,
                    ...tksgPoint.encode(),
                    ...tkshPoint.encode(), 
                ], h2 = H2(b), buf = [
                    ...Array(32 - h2.byteLength()).fill(0),
                    ...h2.toArray()
                ];
                let equal = !0;
                for(let i = 0; i < buf.length; i++)s[i] !== buf[i] && (equal = !1);
                if (!equal) throw Error('invalid vrf');
                return sha256.array(new Uint8Array(vrf));
            }
            function decodePoint(data) {
                try {
                    return EC.curve.decodePoint(data);
                } catch  {
                    return null;
                }
            }
            module.exports = {
                Evaluate,
                ProofHoHash
            };
        },
        3783: function(module, __unused_webpack_exports, __webpack_require__) {
            !function(module, exports) {
                'use strict';
                function assert(val, msg) {
                    if (!val) throw Error(msg || 'Assertion failed');
                }
                function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
                }
                function BN(number, base, endian) {
                    if (BN.isBN(number)) return number;
                    this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== number && (('le' === base || 'be' === base) && (endian = base, base = 10), this._init(number || 0, base || 10, endian || 'be'));
                }
                'object' == typeof module ? module.exports = BN : exports.BN = BN, BN.BN = BN, BN.wordSize = 26;
                try {
                    Buffer = 'undefined' != typeof window && void 0 !== window.Buffer ? window.Buffer : __webpack_require__(136).Buffer;
                } catch (e) {}
                function parseHex4Bits(string, index) {
                    var c = string.charCodeAt(index);
                    return c >= 48 && c <= 57 ? c - 48 : c >= 65 && c <= 70 ? c - 55 : c >= 97 && c <= 102 ? c - 87 : void assert(!1, 'Invalid character in ' + string);
                }
                function parseHexByte(string, lowerBound, index) {
                    var r = parseHex4Bits(string, index);
                    return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4), r;
                }
                function parseBase(str, start, end, mul) {
                    for(var r = 0, b = 0, len = Math.min(str.length, end), i = start; i < len; i++){
                        var c = str.charCodeAt(i) - 48;
                        r *= mul, b = c >= 49 ? c - 49 + 0xa : c >= 17 ? c - 17 + 0xa : c, assert(c >= 0 && b < mul, 'Invalid character'), r += b;
                    }
                    return r;
                }
                function move(dest, src) {
                    dest.words = src.words, dest.length = src.length, dest.negative = src.negative, dest.red = src.red;
                }
                if (BN.isBN = function(num) {
                    return num instanceof BN || null !== num && 'object' == typeof num && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
                }, BN.max = function(left, right) {
                    return left.cmp(right) > 0 ? left : right;
                }, BN.min = function(left, right) {
                    return 0 > left.cmp(right) ? left : right;
                }, BN.prototype._init = function(number, base, endian) {
                    if ('number' == typeof number) return this._initNumber(number, base, endian);
                    if ('object' == typeof number) return this._initArray(number, base, endian);
                    'hex' === base && (base = 16), assert(base === (0 | base) && base >= 2 && base <= 36);
                    var start = 0;
                    '-' === (number = number.toString().replace(/\s+/g, ''))[0] && (start++, this.negative = 1), start < number.length && (16 === base ? this._parseHex(number, start, endian) : (this._parseBase(number, base, start), 'le' === endian && this._initArray(this.toArray(), base, endian)));
                }, BN.prototype._initNumber = function(number, base, endian) {
                    number < 0 && (this.negative = 1, number = -number), number < 0x4000000 ? (this.words = [
                        0x3ffffff & number
                    ], this.length = 1) : number < 0x10000000000000 ? (this.words = [
                        0x3ffffff & number,
                        number / 0x4000000 & 0x3ffffff
                    ], this.length = 2) : (assert(number < 0x20000000000000), this.words = [
                        0x3ffffff & number,
                        number / 0x4000000 & 0x3ffffff,
                        1
                    ], this.length = 3), 'le' === endian && this._initArray(this.toArray(), base, endian);
                }, BN.prototype._initArray = function(number, base, endian) {
                    if (assert('number' == typeof number.length), number.length <= 0) return this.words = [
                        0
                    ], this.length = 1, this;
                    this.length = Math.ceil(number.length / 3), this.words = Array(this.length);
                    for(var j, w, i = 0; i < this.length; i++)this.words[i] = 0;
                    var off = 0;
                    if ('be' === endian) for(i = number.length - 1, j = 0; i >= 0; i -= 3)w = number[i] | number[i - 1] << 8 | number[i - 2] << 16, this.words[j] |= w << off & 0x3ffffff, this.words[j + 1] = w >>> 26 - off & 0x3ffffff, (off += 24) >= 26 && (off -= 26, j++);
                    else if ('le' === endian) for(i = 0, j = 0; i < number.length; i += 3)w = number[i] | number[i + 1] << 8 | number[i + 2] << 16, this.words[j] |= w << off & 0x3ffffff, this.words[j + 1] = w >>> 26 - off & 0x3ffffff, (off += 24) >= 26 && (off -= 26, j++);
                    return this._strip();
                }, BN.prototype._parseHex = function(number, start, endian) {
                    this.length = Math.ceil((number.length - start) / 6), this.words = Array(this.length);
                    for(var w, i = 0; i < this.length; i++)this.words[i] = 0;
                    var off = 0, j = 0;
                    if ('be' === endian) for(i = number.length - 1; i >= start; i -= 2)w = parseHexByte(number, start, i) << off, this.words[j] |= 0x3ffffff & w, off >= 18 ? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;
                    else {
                        var parseLength = number.length - start;
                        for(i = parseLength % 2 == 0 ? start + 1 : start; i < number.length; i += 2)w = parseHexByte(number, start, i) << off, this.words[j] |= 0x3ffffff & w, off >= 18 ? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;
                    }
                    this._strip();
                }, BN.prototype._parseBase = function(number, base, start) {
                    this.words = [
                        0
                    ], this.length = 1;
                    for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
                    limbLen--, limbPow = limbPow / base | 0;
                    for(var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start; i < end; i += limbLen)word = parseBase(number, i, i + limbLen, base), this.imuln(limbPow), this.words[0] + word < 0x4000000 ? this.words[0] += word : this._iaddn(word);
                    if (0 !== mod) {
                        var pow = 1;
                        for(word = parseBase(number, i, number.length, base), i = 0; i < mod; i++)pow *= base;
                        this.imuln(pow), this.words[0] + word < 0x4000000 ? this.words[0] += word : this._iaddn(word);
                    }
                    this._strip();
                }, BN.prototype.copy = function(dest) {
                    dest.words = Array(this.length);
                    for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
                    dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
                }, BN.prototype._move = function(dest) {
                    move(dest, this);
                }, BN.prototype.clone = function() {
                    var r = new BN(null);
                    return this.copy(r), r;
                }, BN.prototype._expand = function(size) {
                    for(; this.length < size;)this.words[this.length++] = 0;
                    return this;
                }, BN.prototype._strip = function() {
                    for(; this.length > 1 && 0 === this.words[this.length - 1];)this.length--;
                    return this._normSign();
                }, BN.prototype._normSign = function() {
                    return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
                }, 'undefined' != typeof Symbol && 'function' == typeof Symbol.for) try {
                    BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
                } catch (e1) {
                    BN.prototype.inspect = inspect;
                }
                else BN.prototype.inspect = inspect;
                function inspect() {
                    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
                }
                var Buffer, zeros = [
                    '',
                    '0',
                    '00',
                    '000',
                    '0000',
                    '00000',
                    '000000',
                    '0000000',
                    '00000000',
                    '000000000',
                    '0000000000',
                    '00000000000',
                    '000000000000',
                    '0000000000000',
                    '00000000000000',
                    '000000000000000',
                    '0000000000000000',
                    '00000000000000000',
                    '000000000000000000',
                    '0000000000000000000',
                    '00000000000000000000',
                    '000000000000000000000',
                    '0000000000000000000000',
                    '00000000000000000000000',
                    '000000000000000000000000',
                    '0000000000000000000000000'
                ], groupSizes = [
                    0,
                    0,
                    25,
                    16,
                    12,
                    11,
                    10,
                    9,
                    8,
                    8,
                    7,
                    7,
                    7,
                    7,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ], groupBases = [
                    0,
                    0,
                    33554432,
                    43046721,
                    16777216,
                    48828125,
                    60466176,
                    40353607,
                    16777216,
                    43046721,
                    10000000,
                    19487171,
                    35831808,
                    62748517,
                    7529536,
                    11390625,
                    16777216,
                    24137569,
                    34012224,
                    47045881,
                    64000000,
                    4084101,
                    5153632,
                    6436343,
                    7962624,
                    9765625,
                    11881376,
                    14348907,
                    17210368,
                    20511149,
                    24300000,
                    28629151,
                    33554432,
                    39135393,
                    45435424,
                    52521875,
                    60466176
                ];
                BN.prototype.toString = function(base, padding) {
                    if (padding = 0 | padding || 1, 16 === (base = base || 10) || 'hex' === base) {
                        out = '';
                        for(var out, off = 0, carry = 0, i = 0; i < this.length; i++){
                            var w = this.words[i], word = ((w << off | carry) & 0xffffff).toString(16);
                            carry = w >>> 24 - off & 0xffffff, (off += 2) >= 26 && (off -= 26, i--), out = 0 !== carry || i !== this.length - 1 ? zeros[6 - word.length] + word + out : word + out;
                        }
                        for(0 !== carry && (out = carry.toString(16) + out); out.length % padding != 0;)out = '0' + out;
                        return 0 !== this.negative && (out = '-' + out), out;
                    }
                    if (base === (0 | base) && base >= 2 && base <= 36) {
                        var groupSize = groupSizes[base], groupBase = groupBases[base];
                        out = '';
                        var c = this.clone();
                        for(c.negative = 0; !c.isZero();){
                            var r = c.modrn(groupBase).toString(base);
                            out = (c = c.idivn(groupBase)).isZero() ? r + out : zeros[groupSize - r.length] + r + out;
                        }
                        for(this.isZero() && (out = '0' + out); out.length % padding != 0;)out = '0' + out;
                        return 0 !== this.negative && (out = '-' + out), out;
                    }
                    assert(!1, 'Base should be between 2 and 36');
                }, BN.prototype.toNumber = function() {
                    var ret = this.words[0];
                    return 2 === this.length ? ret += 0x4000000 * this.words[1] : 3 === this.length && 0x01 === this.words[2] ? ret += 0x10000000000000 + 0x4000000 * this.words[1] : this.length > 2 && assert(!1, 'Number can only safely store up to 53 bits'), 0 !== this.negative ? -ret : ret;
                }, BN.prototype.toJSON = function() {
                    return this.toString(16, 2);
                }, Buffer && (BN.prototype.toBuffer = function(endian, length) {
                    return this.toArrayLike(Buffer, endian, length);
                }), BN.prototype.toArray = function(endian, length) {
                    return this.toArrayLike(Array, endian, length);
                };
                var allocate = function(ArrayType, size) {
                    return ArrayType.allocUnsafe ? ArrayType.allocUnsafe(size) : new ArrayType(size);
                };
                function toBitArray(num) {
                    for(var w = Array(num.bitLength()), bit = 0; bit < w.length; bit++){
                        var off = bit / 26 | 0, wbit = bit % 26;
                        w[bit] = num.words[off] >>> wbit & 0x01;
                    }
                    return w;
                }
                function smallMulTo(self1, num, out) {
                    out.negative = num.negative ^ self1.negative;
                    var len = self1.length + num.length | 0;
                    out.length = len, len = len - 1 | 0;
                    var a = 0 | self1.words[0], b = 0 | num.words[0], r = a * b, lo = 0x3ffffff & r, carry = r / 0x4000000 | 0;
                    out.words[0] = lo;
                    for(var k = 1; k < len; k++){
                        for(var ncarry = carry >>> 26, rword = 0x3ffffff & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
                            var i = k - j | 0;
                            ncarry += (r = (a = 0 | self1.words[i]) * (b = 0 | num.words[j]) + rword) / 0x4000000 | 0, rword = 0x3ffffff & r;
                        }
                        out.words[k] = 0 | rword, carry = 0 | ncarry;
                    }
                    return 0 !== carry ? out.words[k] = 0 | carry : out.length--, out._strip();
                }
                BN.prototype.toArrayLike = function(ArrayType, endian, length) {
                    this._strip();
                    var byteLength = this.byteLength(), reqLength = length || Math.max(1, byteLength);
                    assert(byteLength <= reqLength, 'byte array longer than desired length'), assert(reqLength > 0, 'Requested array length <= 0');
                    var res = allocate(ArrayType, reqLength);
                    return this['_toArrayLike' + ('le' === endian ? 'LE' : 'BE')](res, byteLength), res;
                }, BN.prototype._toArrayLikeLE = function(res, byteLength) {
                    for(var position = 0, carry = 0, i = 0, shift = 0; i < this.length; i++){
                        var word = this.words[i] << shift | carry;
                        res[position++] = 0xff & word, position < res.length && (res[position++] = word >> 8 & 0xff), position < res.length && (res[position++] = word >> 16 & 0xff), 6 === shift ? (position < res.length && (res[position++] = word >> 24 & 0xff), carry = 0, shift = 0) : (carry = word >>> 24, shift += 2);
                    }
                    if (position < res.length) for(res[position++] = carry; position < res.length;)res[position++] = 0;
                }, BN.prototype._toArrayLikeBE = function(res, byteLength) {
                    for(var position = res.length - 1, carry = 0, i = 0, shift = 0; i < this.length; i++){
                        var word = this.words[i] << shift | carry;
                        res[position--] = 0xff & word, position >= 0 && (res[position--] = word >> 8 & 0xff), position >= 0 && (res[position--] = word >> 16 & 0xff), 6 === shift ? (position >= 0 && (res[position--] = word >> 24 & 0xff), carry = 0, shift = 0) : (carry = word >>> 24, shift += 2);
                    }
                    if (position >= 0) for(res[position--] = carry; position >= 0;)res[position--] = 0;
                }, Math.clz32 ? BN.prototype._countBits = function(w) {
                    return 32 - Math.clz32(w);
                } : BN.prototype._countBits = function(w) {
                    var t = w, r = 0;
                    return t >= 0x1000 && (r += 13, t >>>= 13), t >= 0x40 && (r += 7, t >>>= 7), t >= 0x8 && (r += 4, t >>>= 4), t >= 0x02 && (r += 2, t >>>= 2), r + t;
                }, BN.prototype._zeroBits = function(w) {
                    if (0 === w) return 26;
                    var t = w, r = 0;
                    return (0x1fff & t) == 0 && (r += 13, t >>>= 13), (0x7f & t) == 0 && (r += 7, t >>>= 7), (0xf & t) == 0 && (r += 4, t >>>= 4), (0x3 & t) == 0 && (r += 2, t >>>= 2), (0x1 & t) == 0 && r++, r;
                }, BN.prototype.bitLength = function() {
                    var w = this.words[this.length - 1], hi = this._countBits(w);
                    return (this.length - 1) * 26 + hi;
                }, BN.prototype.zeroBits = function() {
                    if (this.isZero()) return 0;
                    for(var r = 0, i = 0; i < this.length; i++){
                        var b = this._zeroBits(this.words[i]);
                        if (r += b, 26 !== b) break;
                    }
                    return r;
                }, BN.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8);
                }, BN.prototype.toTwos = function(width) {
                    return 0 !== this.negative ? this.abs().inotn(width).iaddn(1) : this.clone();
                }, BN.prototype.fromTwos = function(width) {
                    return this.testn(width - 1) ? this.notn(width).iaddn(1).ineg() : this.clone();
                }, BN.prototype.isNeg = function() {
                    return 0 !== this.negative;
                }, BN.prototype.neg = function() {
                    return this.clone().ineg();
                }, BN.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1), this;
                }, BN.prototype.iuor = function(num) {
                    for(; this.length < num.length;)this.words[this.length++] = 0;
                    for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
                    return this._strip();
                }, BN.prototype.ior = function(num) {
                    return assert((this.negative | num.negative) == 0), this.iuor(num);
                }, BN.prototype.or = function(num) {
                    return this.length > num.length ? this.clone().ior(num) : num.clone().ior(this);
                }, BN.prototype.uor = function(num) {
                    return this.length > num.length ? this.clone().iuor(num) : num.clone().iuor(this);
                }, BN.prototype.iuand = function(num) {
                    var b;
                    b = this.length > num.length ? num : this;
                    for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
                    return this.length = b.length, this._strip();
                }, BN.prototype.iand = function(num) {
                    return assert((this.negative | num.negative) == 0), this.iuand(num);
                }, BN.prototype.and = function(num) {
                    return this.length > num.length ? this.clone().iand(num) : num.clone().iand(this);
                }, BN.prototype.uand = function(num) {
                    return this.length > num.length ? this.clone().iuand(num) : num.clone().iuand(this);
                }, BN.prototype.iuxor = function(num) {
                    this.length > num.length ? (a = this, b = num) : (a = num, b = this);
                    for(var a, b, i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
                    if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
                    return this.length = a.length, this._strip();
                }, BN.prototype.ixor = function(num) {
                    return assert((this.negative | num.negative) == 0), this.iuxor(num);
                }, BN.prototype.xor = function(num) {
                    return this.length > num.length ? this.clone().ixor(num) : num.clone().ixor(this);
                }, BN.prototype.uxor = function(num) {
                    return this.length > num.length ? this.clone().iuxor(num) : num.clone().iuxor(this);
                }, BN.prototype.inotn = function(width) {
                    assert('number' == typeof width && width >= 0);
                    var bytesNeeded = 0 | Math.ceil(width / 26), bitsLeft = width % 26;
                    this._expand(bytesNeeded), bitsLeft > 0 && bytesNeeded--;
                    for(var i = 0; i < bytesNeeded; i++)this.words[i] = 0x3ffffff & ~this.words[i];
                    return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft), this._strip();
                }, BN.prototype.notn = function(width) {
                    return this.clone().inotn(width);
                }, BN.prototype.setn = function(bit, val) {
                    assert('number' == typeof bit && bit >= 0);
                    var off = bit / 26 | 0, wbit = bit % 26;
                    return this._expand(off + 1), val ? this.words[off] = this.words[off] | 1 << wbit : this.words[off] = this.words[off] & ~(1 << wbit), this._strip();
                }, BN.prototype.iadd = function(num) {
                    if (0 !== this.negative && 0 === num.negative) return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
                    if (0 === this.negative && 0 !== num.negative) return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
                    this.length > num.length ? (a = this, b = num) : (a = num, b = this);
                    for(var r, a, b, carry = 0, i = 0; i < b.length; i++)r = (0 | a.words[i]) + (0 | b.words[i]) + carry, this.words[i] = 0x3ffffff & r, carry = r >>> 26;
                    for(; 0 !== carry && i < a.length; i++)r = (0 | a.words[i]) + carry, this.words[i] = 0x3ffffff & r, carry = r >>> 26;
                    if (this.length = a.length, 0 !== carry) this.words[this.length] = carry, this.length++;
                    else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
                    return this;
                }, BN.prototype.add = function(num) {
                    var res;
                    return 0 !== num.negative && 0 === this.negative ? (num.negative = 0, res = this.sub(num), num.negative ^= 1, res) : 0 === num.negative && 0 !== this.negative ? (this.negative = 0, res = num.sub(this), this.negative = 1, res) : this.length > num.length ? this.clone().iadd(num) : num.clone().iadd(this);
                }, BN.prototype.isub = function(num) {
                    if (0 !== num.negative) {
                        num.negative = 0;
                        var a, b, r = this.iadd(num);
                        return num.negative = 1, r._normSign();
                    }
                    if (0 !== this.negative) return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
                    var cmp = this.cmp(num);
                    if (0 === cmp) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                    cmp > 0 ? (a = this, b = num) : (a = num, b = this);
                    for(var carry = 0, i = 0; i < b.length; i++)carry = (r = (0 | a.words[i]) - (0 | b.words[i]) + carry) >> 26, this.words[i] = 0x3ffffff & r;
                    for(; 0 !== carry && i < a.length; i++)carry = (r = (0 | a.words[i]) + carry) >> 26, this.words[i] = 0x3ffffff & r;
                    if (0 === carry && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
                    return this.length = Math.max(this.length, i), a !== this && (this.negative = 1), this._strip();
                }, BN.prototype.sub = function(num) {
                    return this.clone().isub(num);
                };
                var comb10MulTo = function(self1, num, out) {
                    var lo, mid, hi, a = self1.words, b = num.words, o = out.words, c = 0, a0 = 0 | a[0], al0 = 0x1fff & a0, ah0 = a0 >>> 13, a1 = 0 | a[1], al1 = 0x1fff & a1, ah1 = a1 >>> 13, a2 = 0 | a[2], al2 = 0x1fff & a2, ah2 = a2 >>> 13, a3 = 0 | a[3], al3 = 0x1fff & a3, ah3 = a3 >>> 13, a4 = 0 | a[4], al4 = 0x1fff & a4, ah4 = a4 >>> 13, a5 = 0 | a[5], al5 = 0x1fff & a5, ah5 = a5 >>> 13, a6 = 0 | a[6], al6 = 0x1fff & a6, ah6 = a6 >>> 13, a7 = 0 | a[7], al7 = 0x1fff & a7, ah7 = a7 >>> 13, a8 = 0 | a[8], al8 = 0x1fff & a8, ah8 = a8 >>> 13, a9 = 0 | a[9], al9 = 0x1fff & a9, ah9 = a9 >>> 13, b0 = 0 | b[0], bl0 = 0x1fff & b0, bh0 = b0 >>> 13, b1 = 0 | b[1], bl1 = 0x1fff & b1, bh1 = b1 >>> 13, b2 = 0 | b[2], bl2 = 0x1fff & b2, bh2 = b2 >>> 13, b3 = 0 | b[3], bl3 = 0x1fff & b3, bh3 = b3 >>> 13, b4 = 0 | b[4], bl4 = 0x1fff & b4, bh4 = b4 >>> 13, b5 = 0 | b[5], bl5 = 0x1fff & b5, bh5 = b5 >>> 13, b6 = 0 | b[6], bl6 = 0x1fff & b6, bh6 = b6 >>> 13, b7 = 0 | b[7], bl7 = 0x1fff & b7, bh7 = b7 >>> 13, b8 = 0 | b[8], bl8 = 0x1fff & b8, bh8 = b8 >>> 13, b9 = 0 | b[9], bl9 = 0x1fff & b9, bh9 = b9 >>> 13;
                    out.negative = self1.negative ^ num.negative, out.length = 19;
                    var w0 = (c + (lo = Math.imul(al0, bl0)) | 0) + ((0x1fff & (mid = (mid = Math.imul(al0, bh0)) + Math.imul(ah0, bl0) | 0)) << 13) | 0;
                    c = ((hi = Math.imul(ah0, bh0)) + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 0x3ffffff, lo = Math.imul(al1, bl0), mid = (mid = Math.imul(al1, bh0)) + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0);
                    var w1 = (c + (lo = lo + Math.imul(al0, bl1) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh1) | 0) + Math.imul(ah0, bl1) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh1) | 0) + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 0x3ffffff, lo = Math.imul(al2, bl0), mid = (mid = Math.imul(al2, bh0)) + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = (mid = mid + Math.imul(al1, bh1) | 0) + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0;
                    var w2 = (c + (lo = lo + Math.imul(al0, bl2) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh2) | 0) + Math.imul(ah0, bl2) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh2) | 0) + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 0x3ffffff, lo = Math.imul(al3, bl0), mid = (mid = Math.imul(al3, bh0)) + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = (mid = mid + Math.imul(al2, bh1) | 0) + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = (mid = mid + Math.imul(al1, bh2) | 0) + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0;
                    var w3 = (c + (lo = lo + Math.imul(al0, bl3) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh3) | 0) + Math.imul(ah0, bl3) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh3) | 0) + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 0x3ffffff, lo = Math.imul(al4, bl0), mid = (mid = Math.imul(al4, bh0)) + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = (mid = mid + Math.imul(al3, bh1) | 0) + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = (mid = mid + Math.imul(al2, bh2) | 0) + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = (mid = mid + Math.imul(al1, bh3) | 0) + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0;
                    var w4 = (c + (lo = lo + Math.imul(al0, bl4) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh4) | 0) + Math.imul(ah0, bl4) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh4) | 0) + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 0x3ffffff, lo = Math.imul(al5, bl0), mid = (mid = Math.imul(al5, bh0)) + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = (mid = mid + Math.imul(al4, bh1) | 0) + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = (mid = mid + Math.imul(al3, bh2) | 0) + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = (mid = mid + Math.imul(al2, bh3) | 0) + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = (mid = mid + Math.imul(al1, bh4) | 0) + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0;
                    var w5 = (c + (lo = lo + Math.imul(al0, bl5) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh5) | 0) + Math.imul(ah0, bl5) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh5) | 0) + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 0x3ffffff, lo = Math.imul(al6, bl0), mid = (mid = Math.imul(al6, bh0)) + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = (mid = mid + Math.imul(al5, bh1) | 0) + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = (mid = mid + Math.imul(al4, bh2) | 0) + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = (mid = mid + Math.imul(al3, bh3) | 0) + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = (mid = mid + Math.imul(al2, bh4) | 0) + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = (mid = mid + Math.imul(al1, bh5) | 0) + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0;
                    var w6 = (c + (lo = lo + Math.imul(al0, bl6) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh6) | 0) + Math.imul(ah0, bl6) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh6) | 0) + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 0x3ffffff, lo = Math.imul(al7, bl0), mid = (mid = Math.imul(al7, bh0)) + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = (mid = mid + Math.imul(al6, bh1) | 0) + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = (mid = mid + Math.imul(al5, bh2) | 0) + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = (mid = mid + Math.imul(al4, bh3) | 0) + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = (mid = mid + Math.imul(al3, bh4) | 0) + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = (mid = mid + Math.imul(al2, bh5) | 0) + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = (mid = mid + Math.imul(al1, bh6) | 0) + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0;
                    var w7 = (c + (lo = lo + Math.imul(al0, bl7) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh7) | 0) + Math.imul(ah0, bl7) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh7) | 0) + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 0x3ffffff, lo = Math.imul(al8, bl0), mid = (mid = Math.imul(al8, bh0)) + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = (mid = mid + Math.imul(al7, bh1) | 0) + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = (mid = mid + Math.imul(al6, bh2) | 0) + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = (mid = mid + Math.imul(al5, bh3) | 0) + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = (mid = mid + Math.imul(al4, bh4) | 0) + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = (mid = mid + Math.imul(al3, bh5) | 0) + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = (mid = mid + Math.imul(al2, bh6) | 0) + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = (mid = mid + Math.imul(al1, bh7) | 0) + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0;
                    var w8 = (c + (lo = lo + Math.imul(al0, bl8) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh8) | 0) + Math.imul(ah0, bl8) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh8) | 0) + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 0x3ffffff, lo = Math.imul(al9, bl0), mid = (mid = Math.imul(al9, bh0)) + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = (mid = mid + Math.imul(al8, bh1) | 0) + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = (mid = mid + Math.imul(al7, bh2) | 0) + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = (mid = mid + Math.imul(al6, bh3) | 0) + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = (mid = mid + Math.imul(al5, bh4) | 0) + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = (mid = mid + Math.imul(al4, bh5) | 0) + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = (mid = mid + Math.imul(al3, bh6) | 0) + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = (mid = mid + Math.imul(al2, bh7) | 0) + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = (mid = mid + Math.imul(al1, bh8) | 0) + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0;
                    var w9 = (c + (lo = lo + Math.imul(al0, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh9) | 0) + Math.imul(ah0, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh9) | 0) + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 0x3ffffff, lo = Math.imul(al9, bl1), mid = (mid = Math.imul(al9, bh1)) + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = (mid = mid + Math.imul(al8, bh2) | 0) + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = (mid = mid + Math.imul(al7, bh3) | 0) + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = (mid = mid + Math.imul(al6, bh4) | 0) + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = (mid = mid + Math.imul(al5, bh5) | 0) + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = (mid = mid + Math.imul(al4, bh6) | 0) + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = (mid = mid + Math.imul(al3, bh7) | 0) + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = (mid = mid + Math.imul(al2, bh8) | 0) + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0;
                    var w10 = (c + (lo = lo + Math.imul(al1, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al1, bh9) | 0) + Math.imul(ah1, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah1, bh9) | 0) + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 0x3ffffff, lo = Math.imul(al9, bl2), mid = (mid = Math.imul(al9, bh2)) + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = (mid = mid + Math.imul(al8, bh3) | 0) + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = (mid = mid + Math.imul(al7, bh4) | 0) + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = (mid = mid + Math.imul(al6, bh5) | 0) + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = (mid = mid + Math.imul(al5, bh6) | 0) + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = (mid = mid + Math.imul(al4, bh7) | 0) + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = (mid = mid + Math.imul(al3, bh8) | 0) + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0;
                    var w11 = (c + (lo = lo + Math.imul(al2, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al2, bh9) | 0) + Math.imul(ah2, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah2, bh9) | 0) + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 0x3ffffff, lo = Math.imul(al9, bl3), mid = (mid = Math.imul(al9, bh3)) + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = (mid = mid + Math.imul(al8, bh4) | 0) + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = (mid = mid + Math.imul(al7, bh5) | 0) + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = (mid = mid + Math.imul(al6, bh6) | 0) + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = (mid = mid + Math.imul(al5, bh7) | 0) + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = (mid = mid + Math.imul(al4, bh8) | 0) + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0;
                    var w12 = (c + (lo = lo + Math.imul(al3, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al3, bh9) | 0) + Math.imul(ah3, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah3, bh9) | 0) + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 0x3ffffff, lo = Math.imul(al9, bl4), mid = (mid = Math.imul(al9, bh4)) + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = (mid = mid + Math.imul(al8, bh5) | 0) + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = (mid = mid + Math.imul(al7, bh6) | 0) + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = (mid = mid + Math.imul(al6, bh7) | 0) + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = (mid = mid + Math.imul(al5, bh8) | 0) + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0;
                    var w13 = (c + (lo = lo + Math.imul(al4, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al4, bh9) | 0) + Math.imul(ah4, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah4, bh9) | 0) + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 0x3ffffff, lo = Math.imul(al9, bl5), mid = (mid = Math.imul(al9, bh5)) + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = (mid = mid + Math.imul(al8, bh6) | 0) + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = (mid = mid + Math.imul(al7, bh7) | 0) + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = (mid = mid + Math.imul(al6, bh8) | 0) + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0;
                    var w14 = (c + (lo = lo + Math.imul(al5, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al5, bh9) | 0) + Math.imul(ah5, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah5, bh9) | 0) + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 0x3ffffff, lo = Math.imul(al9, bl6), mid = (mid = Math.imul(al9, bh6)) + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = (mid = mid + Math.imul(al8, bh7) | 0) + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = (mid = mid + Math.imul(al7, bh8) | 0) + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0;
                    var w15 = (c + (lo = lo + Math.imul(al6, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al6, bh9) | 0) + Math.imul(ah6, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah6, bh9) | 0) + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 0x3ffffff, lo = Math.imul(al9, bl7), mid = (mid = Math.imul(al9, bh7)) + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = (mid = mid + Math.imul(al8, bh8) | 0) + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0;
                    var w16 = (c + (lo = lo + Math.imul(al7, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al7, bh9) | 0) + Math.imul(ah7, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah7, bh9) | 0) + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 0x3ffffff, lo = Math.imul(al9, bl8), mid = (mid = Math.imul(al9, bh8)) + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8);
                    var w17 = (c + (lo = lo + Math.imul(al8, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al8, bh9) | 0) + Math.imul(ah8, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah8, bh9) | 0) + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 0x3ffffff;
                    var w18 = (c + (lo = Math.imul(al9, bl9)) | 0) + ((0x1fff & (mid = (mid = Math.imul(al9, bh9)) + Math.imul(ah9, bl9) | 0)) << 13) | 0;
                    return c = ((hi = Math.imul(ah9, bh9)) + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 0x3ffffff, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, 0 !== c && (o[19] = c, out.length++), out;
                };
                function bigMulTo(self1, num, out) {
                    out.negative = num.negative ^ self1.negative, out.length = self1.length + num.length;
                    for(var carry = 0, hncarry = 0, k = 0; k < out.length - 1; k++){
                        var ncarry = hncarry;
                        hncarry = 0;
                        for(var rword = 0x3ffffff & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
                            var i = k - j, r = (0 | self1.words[i]) * (0 | num.words[j]), lo = 0x3ffffff & r;
                            ncarry = ncarry + (r / 0x4000000 | 0) | 0, rword = 0x3ffffff & (lo = lo + rword | 0), hncarry += (ncarry = ncarry + (lo >>> 26) | 0) >>> 26, ncarry &= 0x3ffffff;
                        }
                        out.words[k] = rword, carry = ncarry, ncarry = hncarry;
                    }
                    return 0 !== carry ? out.words[k] = carry : out.length--, out._strip();
                }
                function jumboMulTo(self1, num, out) {
                    return bigMulTo(self1, num, out);
                }
                function FFTM(x, y) {
                    this.x = x, this.y = y;
                }
                Math.imul || (comb10MulTo = smallMulTo), BN.prototype.mulTo = function(num, out) {
                    var len = this.length + num.length;
                    return 10 === this.length && 10 === num.length ? comb10MulTo(this, num, out) : len < 63 ? smallMulTo(this, num, out) : len < 1024 ? bigMulTo(this, num, out) : jumboMulTo(this, num, out);
                }, FFTM.prototype.makeRBT = function(N) {
                    for(var t = Array(N), l = BN.prototype._countBits(N) - 1, i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
                    return t;
                }, FFTM.prototype.revBin = function(x, l, N) {
                    if (0 === x || x === N - 1) return x;
                    for(var rb = 0, i = 0; i < l; i++)rb |= (1 & x) << l - i - 1, x >>= 1;
                    return rb;
                }, FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {
                    for(var i = 0; i < N; i++)rtws[i] = rws[rbt[i]], itws[i] = iws[rbt[i]];
                }, FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {
                    this.permute(rbt, rws, iws, rtws, itws, N);
                    for(var s = 1; s < N; s <<= 1)for(var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l), p = 0; p < N; p += l)for(var rtwdf_ = rtwdf, itwdf_ = itwdf, j = 0; j < s; j++){
                        var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
                        io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l && (rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx);
                    }
                }, FFTM.prototype.guessLen13b = function(n, m) {
                    var N = 1 | Math.max(m, n), odd = 1 & N, i = 0;
                    for(N = N / 2 | 0; N; N >>>= 1)i++;
                    return 1 << i + 1 + odd;
                }, FFTM.prototype.conjugate = function(rws, iws, N) {
                    if (!(N <= 1)) for(var i = 0; i < N / 2; i++){
                        var t = rws[i];
                        rws[i] = rws[N - i - 1], rws[N - i - 1] = t, t = iws[i], iws[i] = -iws[N - i - 1], iws[N - i - 1] = -t;
                    }
                }, FFTM.prototype.normalize13b = function(ws, N) {
                    for(var carry = 0, i = 0; i < N / 2; i++){
                        var w = 0x2000 * Math.round(ws[2 * i + 1] / N) + Math.round(ws[2 * i] / N) + carry;
                        ws[i] = 0x3ffffff & w, carry = w < 0x4000000 ? 0 : w / 0x4000000 | 0;
                    }
                    return ws;
                }, FFTM.prototype.convert13b = function(ws, len, rws, N) {
                    for(var carry = 0, i = 0; i < len; i++)carry += 0 | ws[i], rws[2 * i] = 0x1fff & carry, carry >>>= 13, rws[2 * i + 1] = 0x1fff & carry, carry >>>= 13;
                    for(i = 2 * len; i < N; ++i)rws[i] = 0;
                    assert(0 === carry), assert((-8192 & carry) == 0);
                }, FFTM.prototype.stub = function(N) {
                    for(var ph = Array(N), i = 0; i < N; i++)ph[i] = 0;
                    return ph;
                }, FFTM.prototype.mulp = function(x, y, out) {
                    var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = Array(N), rwst = Array(N), iwst = Array(N), nrws = Array(N), nrwst = Array(N), niwst = Array(N), rmws = out.words;
                    rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
                    for(var i = 0; i < N; i++){
                        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i], rwst[i] = rx;
                    }
                    return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out._strip();
                }, BN.prototype.mul = function(num) {
                    var out = new BN(null);
                    return out.words = Array(this.length + num.length), this.mulTo(num, out);
                }, BN.prototype.mulf = function(num) {
                    var out = new BN(null);
                    return out.words = Array(this.length + num.length), jumboMulTo(this, num, out);
                }, BN.prototype.imul = function(num) {
                    return this.clone().mulTo(num, this);
                }, BN.prototype.imuln = function(num) {
                    var isNegNum = num < 0;
                    isNegNum && (num = -num), assert('number' == typeof num), assert(num < 0x4000000);
                    for(var carry = 0, i = 0; i < this.length; i++){
                        var w = (0 | this.words[i]) * num, lo = (0x3ffffff & w) + (0x3ffffff & carry);
                        carry >>= 26, carry += w / 0x4000000 | 0, carry += lo >>> 26, this.words[i] = 0x3ffffff & lo;
                    }
                    return 0 !== carry && (this.words[i] = carry, this.length++), isNegNum ? this.ineg() : this;
                }, BN.prototype.muln = function(num) {
                    return this.clone().imuln(num);
                }, BN.prototype.sqr = function() {
                    return this.mul(this);
                }, BN.prototype.isqr = function() {
                    return this.imul(this.clone());
                }, BN.prototype.pow = function(num) {
                    var w = toBitArray(num);
                    if (0 === w.length) return new BN(1);
                    for(var res = this, i = 0; i < w.length && 0 === w[i]; i++, res = res.sqr());
                    if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr())0 !== w[i] && (res = res.mul(q));
                    return res;
                }, BN.prototype.iushln = function(bits) {
                    assert('number' == typeof bits && bits >= 0);
                    var i, r = bits % 26, s = (bits - r) / 26, carryMask = 0x3ffffff >>> 26 - r << 26 - r;
                    if (0 !== r) {
                        var carry = 0;
                        for(i = 0; i < this.length; i++){
                            var newCarry = this.words[i] & carryMask, c = (0 | this.words[i]) - newCarry << r;
                            this.words[i] = c | carry, carry = newCarry >>> 26 - r;
                        }
                        carry && (this.words[i] = carry, this.length++);
                    }
                    if (0 !== s) {
                        for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
                        for(i = 0; i < s; i++)this.words[i] = 0;
                        this.length += s;
                    }
                    return this._strip();
                }, BN.prototype.ishln = function(bits) {
                    return assert(0 === this.negative), this.iushln(bits);
                }, BN.prototype.iushrn = function(bits, hint, extended) {
                    assert('number' == typeof bits && bits >= 0), h = hint ? (hint - hint % 26) / 26 : 0;
                    var h, r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 0x3ffffff ^ 0x3ffffff >>> r << r, maskedWords = extended;
                    if (h -= s, h = Math.max(0, h), maskedWords) {
                        for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
                        maskedWords.length = s;
                    }
                    if (0 === s) ;
                    else if (this.length > s) for(this.length -= s, i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
                    else this.words[0] = 0, this.length = 1;
                    var carry = 0;
                    for(i = this.length - 1; i >= 0 && (0 !== carry || i >= h); i--){
                        var word = 0 | this.words[i];
                        this.words[i] = carry << 26 - r | word >>> r, carry = word & mask;
                    }
                    return maskedWords && 0 !== carry && (maskedWords.words[maskedWords.length++] = carry), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip();
                }, BN.prototype.ishrn = function(bits, hint, extended) {
                    return assert(0 === this.negative), this.iushrn(bits, hint, extended);
                }, BN.prototype.shln = function(bits) {
                    return this.clone().ishln(bits);
                }, BN.prototype.ushln = function(bits) {
                    return this.clone().iushln(bits);
                }, BN.prototype.shrn = function(bits) {
                    return this.clone().ishrn(bits);
                }, BN.prototype.ushrn = function(bits) {
                    return this.clone().iushrn(bits);
                }, BN.prototype.testn = function(bit) {
                    assert('number' == typeof bit && bit >= 0);
                    var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
                    return !(this.length <= s) && !!(this.words[s] & q);
                }, BN.prototype.imaskn = function(bits) {
                    assert('number' == typeof bits && bits >= 0);
                    var r = bits % 26, s = (bits - r) / 26;
                    if (assert(0 === this.negative, 'imaskn works only with positive numbers'), this.length <= s) return this;
                    if (0 !== r && s++, this.length = Math.min(s, this.length), 0 !== r) {
                        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
                        this.words[this.length - 1] &= mask;
                    }
                    return this._strip();
                }, BN.prototype.maskn = function(bits) {
                    return this.clone().imaskn(bits);
                }, BN.prototype.iaddn = function(num) {
                    return (assert('number' == typeof num), assert(num < 0x4000000), num < 0) ? this.isubn(-num) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= num ? (this.words[0] = num - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(num), this.negative = 1, this) : this._iaddn(num);
                }, BN.prototype._iaddn = function(num) {
                    this.words[0] += num;
                    for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++)this.words[i] -= 0x4000000, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
                    return this.length = Math.max(this.length, i + 1), this;
                }, BN.prototype.isubn = function(num) {
                    if (assert('number' == typeof num), assert(num < 0x4000000), num < 0) return this.iaddn(-num);
                    if (0 !== this.negative) return this.negative = 0, this.iaddn(num), this.negative = 1, this;
                    if (this.words[0] -= num, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                    else for(var i = 0; i < this.length && this.words[i] < 0; i++)this.words[i] += 0x4000000, this.words[i + 1] -= 1;
                    return this._strip();
                }, BN.prototype.addn = function(num) {
                    return this.clone().iaddn(num);
                }, BN.prototype.subn = function(num) {
                    return this.clone().isubn(num);
                }, BN.prototype.iabs = function() {
                    return this.negative = 0, this;
                }, BN.prototype.abs = function() {
                    return this.clone().iabs();
                }, BN.prototype._ishlnsubmul = function(num, mul, shift) {
                    var i, w, len = num.length + shift;
                    this._expand(len);
                    var carry = 0;
                    for(i = 0; i < num.length; i++){
                        w = (0 | this.words[i + shift]) + carry;
                        var right = (0 | num.words[i]) * mul;
                        w -= 0x3ffffff & right, carry = (w >> 26) - (right / 0x4000000 | 0), this.words[i + shift] = 0x3ffffff & w;
                    }
                    for(; i < this.length - shift; i++)carry = (w = (0 | this.words[i + shift]) + carry) >> 26, this.words[i + shift] = 0x3ffffff & w;
                    if (0 === carry) return this._strip();
                    for(assert(-1 === carry), carry = 0, i = 0; i < this.length; i++)carry = (w = -(0 | this.words[i]) + carry) >> 26, this.words[i] = 0x3ffffff & w;
                    return this.negative = 1, this._strip();
                }, BN.prototype._wordDiv = function(num, mode) {
                    var q, shift = this.length - num.length, a = this.clone(), b = num, bhi = 0 | b.words[b.length - 1];
                    0 != (shift = 26 - this._countBits(bhi)) && (b = b.ushln(shift), a.iushln(shift), bhi = 0 | b.words[b.length - 1]);
                    var m = a.length - b.length;
                    if ('mod' !== mode) {
                        (q = new BN(null)).length = m + 1, q.words = Array(q.length);
                        for(var i = 0; i < q.length; i++)q.words[i] = 0;
                    }
                    var diff = a.clone()._ishlnsubmul(b, 1, m);
                    0 === diff.negative && (a = diff, q && (q.words[m] = 1));
                    for(var j = m - 1; j >= 0; j--){
                        var qj = (0 | a.words[b.length + j]) * 0x4000000 + (0 | a.words[b.length + j - 1]);
                        for(qj = Math.min(qj / bhi | 0, 0x3ffffff), a._ishlnsubmul(b, qj, j); 0 !== a.negative;)qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), a.isZero() || (a.negative ^= 1);
                        q && (q.words[j] = qj);
                    }
                    return q && q._strip(), a._strip(), 'div' !== mode && 0 !== shift && a.iushrn(shift), {
                        div: q || null,
                        mod: a
                    };
                }, BN.prototype.divmod = function(num, mode, positive) {
                    var div, mod, res;
                    return (assert(!num.isZero()), this.isZero()) ? {
                        div: new BN(0),
                        mod: new BN(0)
                    } : 0 !== this.negative && 0 === num.negative ? (res = this.neg().divmod(num, mode), 'mod' !== mode && (div = res.div.neg()), 'div' !== mode && (mod = res.mod.neg(), positive && 0 !== mod.negative && mod.iadd(num)), {
                        div: div,
                        mod: mod
                    }) : 0 === this.negative && 0 !== num.negative ? (res = this.divmod(num.neg(), mode), 'mod' !== mode && (div = res.div.neg()), {
                        div: div,
                        mod: res.mod
                    }) : (this.negative & num.negative) != 0 ? (res = this.neg().divmod(num.neg(), mode), 'div' !== mode && (mod = res.mod.neg(), positive && 0 !== mod.negative && mod.isub(num)), {
                        div: res.div,
                        mod: mod
                    }) : num.length > this.length || 0 > this.cmp(num) ? {
                        div: new BN(0),
                        mod: this
                    } : 1 === num.length ? 'div' === mode ? {
                        div: this.divn(num.words[0]),
                        mod: null
                    } : 'mod' === mode ? {
                        div: null,
                        mod: new BN(this.modrn(num.words[0]))
                    } : {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modrn(num.words[0]))
                    } : this._wordDiv(num, mode);
                }, BN.prototype.div = function(num) {
                    return this.divmod(num, 'div', !1).div;
                }, BN.prototype.mod = function(num) {
                    return this.divmod(num, 'mod', !1).mod;
                }, BN.prototype.umod = function(num) {
                    return this.divmod(num, 'mod', !0).mod;
                }, BN.prototype.divRound = function(num) {
                    var dm = this.divmod(num);
                    if (dm.mod.isZero()) return dm.div;
                    var mod = 0 !== dm.div.negative ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
                    return cmp < 0 || 1 === r2 && 0 === cmp ? dm.div : 0 !== dm.div.negative ? dm.div.isubn(1) : dm.div.iaddn(1);
                }, BN.prototype.modrn = function(num) {
                    var isNegNum = num < 0;
                    isNegNum && (num = -num), assert(num <= 0x3ffffff);
                    for(var p = 67108864 % num, acc = 0, i = this.length - 1; i >= 0; i--)acc = (p * acc + (0 | this.words[i])) % num;
                    return isNegNum ? -acc : acc;
                }, BN.prototype.modn = function(num) {
                    return this.modrn(num);
                }, BN.prototype.idivn = function(num) {
                    var isNegNum = num < 0;
                    isNegNum && (num = -num), assert(num <= 0x3ffffff);
                    for(var carry = 0, i = this.length - 1; i >= 0; i--){
                        var w = (0 | this.words[i]) + 0x4000000 * carry;
                        this.words[i] = w / num | 0, carry = w % num;
                    }
                    return this._strip(), isNegNum ? this.ineg() : this;
                }, BN.prototype.divn = function(num) {
                    return this.clone().idivn(num);
                }, BN.prototype.egcd = function(p) {
                    assert(0 === p.negative), assert(!p.isZero());
                    var x = this, y = p.clone();
                    x = 0 !== x.negative ? x.umod(p) : x.clone();
                    for(var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0; x.isEven() && y.isEven();)x.iushrn(1), y.iushrn(1), ++g;
                    for(var yp = y.clone(), xp = x.clone(); !x.isZero();){
                        for(var i = 0, im = 1; (x.words[0] & im) == 0 && i < 26; ++i, im <<= 1);
                        if (i > 0) for(x.iushrn(i); i-- > 0;)(A.isOdd() || B.isOdd()) && (A.iadd(yp), B.isub(xp)), A.iushrn(1), B.iushrn(1);
                        for(var j = 0, jm = 1; (y.words[0] & jm) == 0 && j < 26; ++j, jm <<= 1);
                        if (j > 0) for(y.iushrn(j); j-- > 0;)(C.isOdd() || D.isOdd()) && (C.iadd(yp), D.isub(xp)), C.iushrn(1), D.iushrn(1);
                        x.cmp(y) >= 0 ? (x.isub(y), A.isub(C), B.isub(D)) : (y.isub(x), C.isub(A), D.isub(B));
                    }
                    return {
                        a: C,
                        b: D,
                        gcd: y.iushln(g)
                    };
                }, BN.prototype._invmp = function(p) {
                    assert(0 === p.negative), assert(!p.isZero());
                    var res, a = this, b = p.clone();
                    a = 0 !== a.negative ? a.umod(p) : a.clone();
                    for(var x1 = new BN(1), x2 = new BN(0), delta = b.clone(); a.cmpn(1) > 0 && b.cmpn(1) > 0;){
                        for(var i = 0, im = 1; (a.words[0] & im) == 0 && i < 26; ++i, im <<= 1);
                        if (i > 0) for(a.iushrn(i); i-- > 0;)x1.isOdd() && x1.iadd(delta), x1.iushrn(1);
                        for(var j = 0, jm = 1; (b.words[0] & jm) == 0 && j < 26; ++j, jm <<= 1);
                        if (j > 0) for(b.iushrn(j); j-- > 0;)x2.isOdd() && x2.iadd(delta), x2.iushrn(1);
                        a.cmp(b) >= 0 ? (a.isub(b), x1.isub(x2)) : (b.isub(a), x2.isub(x1));
                    }
                    return 0 > (res = 0 === a.cmpn(1) ? x1 : x2).cmpn(0) && res.iadd(p), res;
                }, BN.prototype.gcd = function(num) {
                    if (this.isZero()) return num.abs();
                    if (num.isZero()) return this.abs();
                    var a = this.clone(), b = num.clone();
                    a.negative = 0, b.negative = 0;
                    for(var shift = 0; a.isEven() && b.isEven(); shift++)a.iushrn(1), b.iushrn(1);
                    for(;;){
                        for(; a.isEven();)a.iushrn(1);
                        for(; b.isEven();)b.iushrn(1);
                        var r = a.cmp(b);
                        if (r < 0) {
                            var t = a;
                            a = b, b = t;
                        } else if (0 === r || 0 === b.cmpn(1)) break;
                        a.isub(b);
                    }
                    return b.iushln(shift);
                }, BN.prototype.invm = function(num) {
                    return this.egcd(num).a.umod(num);
                }, BN.prototype.isEven = function() {
                    return (1 & this.words[0]) == 0;
                }, BN.prototype.isOdd = function() {
                    return (1 & this.words[0]) == 1;
                }, BN.prototype.andln = function(num) {
                    return this.words[0] & num;
                }, BN.prototype.bincn = function(bit) {
                    assert('number' == typeof bit);
                    var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
                    if (this.length <= s) return this._expand(s + 1), this.words[s] |= q, this;
                    for(var carry = q, i = s; 0 !== carry && i < this.length; i++){
                        var w = 0 | this.words[i];
                        w += carry, carry = w >>> 26, w &= 0x3ffffff, this.words[i] = w;
                    }
                    return 0 !== carry && (this.words[i] = carry, this.length++), this;
                }, BN.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0];
                }, BN.prototype.cmpn = function(num) {
                    var res, negative = num < 0;
                    if (0 !== this.negative && !negative) return -1;
                    if (0 === this.negative && negative) return 1;
                    if (this._strip(), this.length > 1) res = 1;
                    else {
                        negative && (num = -num), assert(num <= 0x3ffffff, 'Number is too big');
                        var w = 0 | this.words[0];
                        res = w === num ? 0 : w < num ? -1 : 1;
                    }
                    return 0 !== this.negative ? 0 | -res : res;
                }, BN.prototype.cmp = function(num) {
                    if (0 !== this.negative && 0 === num.negative) return -1;
                    if (0 === this.negative && 0 !== num.negative) return 1;
                    var res = this.ucmp(num);
                    return 0 !== this.negative ? 0 | -res : res;
                }, BN.prototype.ucmp = function(num) {
                    if (this.length > num.length) return 1;
                    if (this.length < num.length) return -1;
                    for(var res = 0, i = this.length - 1; i >= 0; i--){
                        var a = 0 | this.words[i], b = 0 | num.words[i];
                        if (a !== b) {
                            a < b ? res = -1 : a > b && (res = 1);
                            break;
                        }
                    }
                    return res;
                }, BN.prototype.gtn = function(num) {
                    return 1 === this.cmpn(num);
                }, BN.prototype.gt = function(num) {
                    return 1 === this.cmp(num);
                }, BN.prototype.gten = function(num) {
                    return this.cmpn(num) >= 0;
                }, BN.prototype.gte = function(num) {
                    return this.cmp(num) >= 0;
                }, BN.prototype.ltn = function(num) {
                    return -1 === this.cmpn(num);
                }, BN.prototype.lt = function(num) {
                    return -1 === this.cmp(num);
                }, BN.prototype.lten = function(num) {
                    return 0 >= this.cmpn(num);
                }, BN.prototype.lte = function(num) {
                    return 0 >= this.cmp(num);
                }, BN.prototype.eqn = function(num) {
                    return 0 === this.cmpn(num);
                }, BN.prototype.eq = function(num) {
                    return 0 === this.cmp(num);
                }, BN.red = function(num) {
                    return new Red(num);
                }, BN.prototype.toRed = function(ctx) {
                    return assert(!this.red, 'Already a number in reduction context'), assert(0 === this.negative, 'red works only with positives'), ctx.convertTo(this)._forceRed(ctx);
                }, BN.prototype.fromRed = function() {
                    return assert(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this);
                }, BN.prototype._forceRed = function(ctx) {
                    return this.red = ctx, this;
                }, BN.prototype.forceRed = function(ctx) {
                    return assert(!this.red, 'Already a number in reduction context'), this._forceRed(ctx);
                }, BN.prototype.redAdd = function(num) {
                    return assert(this.red, 'redAdd works only with red numbers'), this.red.add(this, num);
                }, BN.prototype.redIAdd = function(num) {
                    return assert(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, num);
                }, BN.prototype.redSub = function(num) {
                    return assert(this.red, 'redSub works only with red numbers'), this.red.sub(this, num);
                }, BN.prototype.redISub = function(num) {
                    return assert(this.red, 'redISub works only with red numbers'), this.red.isub(this, num);
                }, BN.prototype.redShl = function(num) {
                    return assert(this.red, 'redShl works only with red numbers'), this.red.shl(this, num);
                }, BN.prototype.redMul = function(num) {
                    return assert(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num), this.red.mul(this, num);
                }, BN.prototype.redIMul = function(num) {
                    return assert(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num), this.red.imul(this, num);
                }, BN.prototype.redSqr = function() {
                    return assert(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this);
                }, BN.prototype.redISqr = function() {
                    return assert(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this);
                }, BN.prototype.redSqrt = function() {
                    return assert(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this);
                }, BN.prototype.redInvm = function() {
                    return assert(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this);
                }, BN.prototype.redNeg = function() {
                    return assert(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this);
                }, BN.prototype.redPow = function(num) {
                    return assert(this.red && !num.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, num);
                };
                var primes = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                function MPrime(name, p) {
                    this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
                }
                function K256() {
                    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
                }
                function P224() {
                    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
                }
                function P192() {
                    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
                }
                function P25519() {
                    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
                }
                function Red(m) {
                    if ('string' == typeof m) {
                        var prime = BN._prime(m);
                        this.m = prime.p, this.prime = prime;
                    } else assert(m.gtn(1), 'modulus must be greater than 1'), this.m = m, this.prime = null;
                }
                function Mont(m) {
                    Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
                }
                MPrime.prototype._tmp = function() {
                    var tmp = new BN(null);
                    return tmp.words = Array(Math.ceil(this.n / 13)), tmp;
                }, MPrime.prototype.ireduce = function(num) {
                    var rlen, r = num;
                    do this.split(r, this.tmp), rlen = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength();
                    while (rlen > this.n)
                    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                    return 0 === cmp ? (r.words[0] = 0, r.length = 1) : cmp > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r;
                }, MPrime.prototype.split = function(input, out) {
                    input.iushrn(this.n, 0, out);
                }, MPrime.prototype.imulK = function(num) {
                    return num.imul(this.k);
                }, inherits(K256, MPrime), K256.prototype.split = function(input, output) {
                    for(var mask = 0x3fffff, outLen = Math.min(input.length, 9), i = 0; i < outLen; i++)output.words[i] = input.words[i];
                    if (output.length = outLen, input.length <= 9) {
                        input.words[0] = 0, input.length = 1;
                        return;
                    }
                    var prev = input.words[9];
                    for(i = 10, output.words[output.length++] = prev & mask; i < input.length; i++){
                        var next = 0 | input.words[i];
                        input.words[i - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
                    }
                    prev >>>= 22, input.words[i - 10] = prev, 0 === prev && input.length > 10 ? input.length -= 10 : input.length -= 9;
                }, K256.prototype.imulK = function(num) {
                    num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
                    for(var lo = 0, i = 0; i < num.length; i++){
                        var w = 0 | num.words[i];
                        lo += 0x3d1 * w, num.words[i] = 0x3ffffff & lo, lo = 0x40 * w + (lo / 0x4000000 | 0);
                    }
                    return 0 === num.words[num.length - 1] && (num.length--, 0 === num.words[num.length - 1] && num.length--), num;
                }, inherits(P224, MPrime), inherits(P192, MPrime), inherits(P25519, MPrime), P25519.prototype.imulK = function(num) {
                    for(var carry = 0, i = 0; i < num.length; i++){
                        var hi = (0 | num.words[i]) * 0x13 + carry, lo = 0x3ffffff & hi;
                        hi >>>= 26, num.words[i] = lo, carry = hi;
                    }
                    return 0 !== carry && (num.words[num.length++] = carry), num;
                }, BN._prime = function(name) {
                    var prime;
                    if (primes[name]) return primes[name];
                    if ('k256' === name) prime = new K256();
                    else if ('p224' === name) prime = new P224();
                    else if ('p192' === name) prime = new P192();
                    else if ('p25519' === name) prime = new P25519();
                    else throw Error('Unknown prime ' + name);
                    return primes[name] = prime, prime;
                }, Red.prototype._verify1 = function(a) {
                    assert(0 === a.negative, 'red works only with positives'), assert(a.red, 'red works only with red numbers');
                }, Red.prototype._verify2 = function(a, b) {
                    assert((a.negative | b.negative) == 0, 'red works only with positives'), assert(a.red && a.red === b.red, 'red works only with red numbers');
                }, Red.prototype.imod = function(a) {
                    return this.prime ? this.prime.ireduce(a)._forceRed(this) : (move(a, a.umod(this.m)._forceRed(this)), a);
                }, Red.prototype.neg = function(a) {
                    return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
                }, Red.prototype.add = function(a, b) {
                    this._verify2(a, b);
                    var res = a.add(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m), res._forceRed(this);
                }, Red.prototype.iadd = function(a, b) {
                    this._verify2(a, b);
                    var res = a.iadd(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m), res;
                }, Red.prototype.sub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.sub(b);
                    return 0 > res.cmpn(0) && res.iadd(this.m), res._forceRed(this);
                }, Red.prototype.isub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.isub(b);
                    return 0 > res.cmpn(0) && res.iadd(this.m), res;
                }, Red.prototype.shl = function(a, num) {
                    return this._verify1(a), this.imod(a.ushln(num));
                }, Red.prototype.imul = function(a, b) {
                    return this._verify2(a, b), this.imod(a.imul(b));
                }, Red.prototype.mul = function(a, b) {
                    return this._verify2(a, b), this.imod(a.mul(b));
                }, Red.prototype.isqr = function(a) {
                    return this.imul(a, a.clone());
                }, Red.prototype.sqr = function(a) {
                    return this.mul(a, a);
                }, Red.prototype.sqrt = function(a) {
                    if (a.isZero()) return a.clone();
                    var mod3 = this.m.andln(3);
                    if (assert(mod3 % 2 == 1), 3 === mod3) {
                        var pow = this.m.add(new BN(1)).iushrn(2);
                        return this.pow(a, pow);
                    }
                    for(var q = this.m.subn(1), s = 0; !q.isZero() && 0 === q.andln(1);)s++, q.iushrn(1);
                    assert(!q.isZero());
                    var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
                    for(z = new BN(2 * z * z).toRed(this); 0 !== this.pow(z, lpow).cmp(nOne);)z.redIAdd(nOne);
                    for(var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s; 0 !== t.cmp(one);){
                        for(var tmp = t, i = 0; 0 !== tmp.cmp(one); i++)tmp = tmp.redSqr();
                        assert(i < m);
                        var b = this.pow(c, new BN(1).iushln(m - i - 1));
                        r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i;
                    }
                    return r;
                }, Red.prototype.invm = function(a) {
                    var inv = a._invmp(this.m);
                    return 0 !== inv.negative ? (inv.negative = 0, this.imod(inv).redNeg()) : this.imod(inv);
                }, Red.prototype.pow = function(a, num) {
                    if (num.isZero()) return new BN(1).toRed(this);
                    if (0 === num.cmpn(1)) return a.clone();
                    var windowSize = 4, wnd = Array(1 << windowSize);
                    wnd[0] = new BN(1).toRed(this), wnd[1] = a;
                    for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
                    var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
                    for(0 === start && (start = 26), i = num.length - 1; i >= 0; i--){
                        for(var word = num.words[i], j = start - 1; j >= 0; j--){
                            var bit = word >> j & 1;
                            if (res !== wnd[0] && (res = this.sqr(res)), 0 === bit && 0 === current) {
                                currentLen = 0;
                                continue;
                            }
                            current <<= 1, current |= bit, (++currentLen === windowSize || 0 === i && 0 === j) && (res = this.mul(res, wnd[current]), currentLen = 0, current = 0);
                        }
                        start = 26;
                    }
                    return res;
                }, Red.prototype.convertTo = function(num) {
                    var r = num.umod(this.m);
                    return r === num ? r.clone() : r;
                }, Red.prototype.convertFrom = function(num) {
                    var res = num.clone();
                    return res.red = null, res;
                }, BN.mont = function(num) {
                    return new Mont(num);
                }, inherits(Mont, Red), Mont.prototype.convertTo = function(num) {
                    return this.imod(num.ushln(this.shift));
                }, Mont.prototype.convertFrom = function(num) {
                    var r = this.imod(num.mul(this.rinv));
                    return r.red = null, r;
                }, Mont.prototype.imul = function(a, b) {
                    if (a.isZero() || b.isZero()) return a.words[0] = 0, a.length = 1, a;
                    var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : 0 > u.cmpn(0) && (res = u.iadd(this.m)), res._forceRed(this);
                }, Mont.prototype.mul = function(a, b) {
                    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
                    var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : 0 > u.cmpn(0) && (res = u.iadd(this.m)), res._forceRed(this);
                }, Mont.prototype.invm = function(a) {
                    return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this);
                };
            }(module = __webpack_require__.nmd(module), this);
        },
        9464: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { fromCallback  } = __webpack_require__(6957), ModuleError = __webpack_require__(4473), { getCallback , getOptions  } = __webpack_require__(2520), kPromise = Symbol('promise'), kStatus = Symbol('status'), kOperations = Symbol('operations'), kFinishClose = Symbol('finishClose'), kCloseCallbacks = Symbol('closeCallbacks');
            class AbstractChainedBatch {
                constructor(db){
                    if ('object' != typeof db || null === db) {
                        const hint = null === db ? 'null' : typeof db;
                        throw TypeError(`The first argument must be an abstract-level database, received ${hint}`);
                    }
                    this[kOperations] = [], this[kCloseCallbacks] = [], this[kStatus] = 'open', this[kFinishClose] = this[kFinishClose].bind(this), this.db = db, this.db.attachResource(this), this.nextTick = db.nextTick;
                }
                get length() {
                    return this[kOperations].length;
                }
                put(key, value, options) {
                    if ('open' !== this[kStatus]) throw new ModuleError('Batch is not open: cannot call put() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    });
                    const err = this.db._checkKey(key) || this.db._checkValue(value);
                    if (err) throw err;
                    const db = options && null != options.sublevel ? options.sublevel : this.db, original = options, keyEncoding = db.keyEncoding(options && options.keyEncoding), valueEncoding = db.valueEncoding(options && options.valueEncoding), keyFormat = keyEncoding.format;
                    options = {
                        ...options,
                        keyEncoding: keyFormat,
                        valueEncoding: valueEncoding.format
                    }, db !== this.db && (options.sublevel = null);
                    const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat), mappedValue = valueEncoding.encode(value);
                    return this._put(mappedKey, mappedValue, options), this[kOperations].push({
                        ...original,
                        type: 'put',
                        key,
                        value
                    }), this;
                }
                _put(key, value, options) {}
                del(key, options) {
                    if ('open' !== this[kStatus]) throw new ModuleError('Batch is not open: cannot call del() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    });
                    const err = this.db._checkKey(key);
                    if (err) throw err;
                    const db = options && null != options.sublevel ? options.sublevel : this.db, original = options, keyEncoding = db.keyEncoding(options && options.keyEncoding), keyFormat = keyEncoding.format;
                    return options = {
                        ...options,
                        keyEncoding: keyFormat
                    }, db !== this.db && (options.sublevel = null), this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options), this[kOperations].push({
                        ...original,
                        type: 'del',
                        key
                    }), this;
                }
                _del(key, options) {}
                clear() {
                    if ('open' !== this[kStatus]) throw new ModuleError('Batch is not open: cannot call clear() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    });
                    return this._clear(), this[kOperations] = [], this;
                }
                _clear() {}
                write(options, callback) {
                    return callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options), 'open' !== this[kStatus] ? this.nextTick(callback, new ModuleError('Batch is not open: cannot call write() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    })) : 0 === this.length ? this.close(callback) : (this[kStatus] = 'writing', this._write(options, (err)=>{
                        this[kStatus] = 'closing', this[kCloseCallbacks].push(()=>callback(err)), err || this.db.emit('batch', this[kOperations]), this._close(this[kFinishClose]);
                    })), callback[kPromise];
                }
                _write(options, callback) {}
                close(callback) {
                    return callback = fromCallback(callback, kPromise), 'closing' === this[kStatus] ? this[kCloseCallbacks].push(callback) : 'closed' === this[kStatus] ? this.nextTick(callback) : (this[kCloseCallbacks].push(callback), 'writing' !== this[kStatus] && (this[kStatus] = 'closing', this._close(this[kFinishClose]))), callback[kPromise];
                }
                _close(callback) {
                    this.nextTick(callback);
                }
                [kFinishClose]() {
                    this[kStatus] = 'closed', this.db.detachResource(this);
                    const callbacks = this[kCloseCallbacks];
                    for (const cb of (this[kCloseCallbacks] = [], callbacks))cb();
                }
            }
            exports.AbstractChainedBatch = AbstractChainedBatch;
        },
        3961: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { fromCallback  } = __webpack_require__(6957), ModuleError = __webpack_require__(4473), { getOptions , getCallback  } = __webpack_require__(2520), kPromise = Symbol('promise'), kCallback = Symbol('callback'), kWorking = Symbol('working'), kHandleOne = Symbol('handleOne'), kHandleMany = Symbol('handleMany'), kAutoClose = Symbol('autoClose'), kFinishWork = Symbol('finishWork'), kReturnMany = Symbol('returnMany'), kClosing = Symbol('closing'), kHandleClose = Symbol('handleClose'), kClosed = Symbol('closed'), kCloseCallbacks = Symbol('closeCallbacks'), kKeyEncoding = Symbol('keyEncoding'), kValueEncoding = Symbol('valueEncoding'), kAbortOnClose = Symbol('abortOnClose'), kLegacy = Symbol('legacy'), kKeys = Symbol('keys'), kValues = Symbol('values'), kLimit = Symbol('limit'), kCount = Symbol('count'), emptyOptions = Object.freeze({}), noop = ()=>{};
            let warnedEnd = !1;
            class CommonIterator {
                constructor(db, options, legacy){
                    if ('object' != typeof db || null === db) {
                        const hint = null === db ? 'null' : typeof db;
                        throw TypeError(`The first argument must be an abstract-level database, received ${hint}`);
                    }
                    if ('object' != typeof options || null === options) throw TypeError('The second argument must be an options object');
                    this[kClosed] = !1, this[kCloseCallbacks] = [], this[kWorking] = !1, this[kClosing] = !1, this[kAutoClose] = !1, this[kCallback] = null, this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this), this[kHandleClose] = this[kHandleClose].bind(this), this[kKeyEncoding] = options[kKeyEncoding], this[kValueEncoding] = options[kValueEncoding], this[kLegacy] = legacy, this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : 1 / 0, this[kCount] = 0, this[kAbortOnClose] = !!options.abortOnClose, this.db = db, this.db.attachResource(this), this.nextTick = db.nextTick;
                }
                get count() {
                    return this[kCount];
                }
                get limit() {
                    return this[kLimit];
                }
                next(callback) {
                    let promise;
                    if (void 0 === callback) promise = new Promise((resolve, reject)=>{
                        callback = (err, key, value)=>{
                            err ? reject(err) : this[kLegacy] ? void 0 === key && void 0 === value ? resolve() : resolve([
                                key,
                                value
                            ]) : resolve(key);
                        };
                    });
                    else if ('function' != typeof callback) throw TypeError('Callback must be a function');
                    return this[kClosing] ? this.nextTick(callback, new ModuleError('Iterator is not open: cannot call next() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    })) : this[kWorking] ? this.nextTick(callback, new ModuleError('Iterator is busy: cannot call next() until previous call has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    })) : (this[kWorking] = !0, this[kCallback] = callback, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleOne], null) : this._next(this[kHandleOne])), promise;
                }
                _next(callback) {
                    this.nextTick(callback);
                }
                nextv(size, options, callback) {
                    return (callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options, emptyOptions), Number.isInteger(size)) ? (this[kClosing] ? this.nextTick(callback, new ModuleError('Iterator is not open: cannot call nextv() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    })) : this[kWorking] ? this.nextTick(callback, new ModuleError('Iterator is busy: cannot call nextv() until previous call has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    })) : (size < 1 && (size = 1), this[kLimit] < 1 / 0 && (size = Math.min(size, this[kLimit] - this[kCount])), this[kWorking] = !0, this[kCallback] = callback, size <= 0 ? this.nextTick(this[kHandleMany], null, []) : this._nextv(size, options, this[kHandleMany])), callback[kPromise]) : (this.nextTick(callback, TypeError("The first argument 'size' must be an integer")), callback[kPromise]);
                }
                _nextv(size, options, callback) {
                    const acc = [], onnext = (err, key, value)=>err ? callback(err) : (this[kLegacy] ? void 0 === key && void 0 === value : void 0 === key) ? callback(null, acc) : void (acc.push(this[kLegacy] ? [
                            key,
                            value
                        ] : key), acc.length === size ? callback(null, acc) : this._next(onnext));
                    this._next(onnext);
                }
                all(options, callback) {
                    return callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options, emptyOptions), this[kClosing] ? this.nextTick(callback, new ModuleError('Iterator is not open: cannot call all() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    })) : this[kWorking] ? this.nextTick(callback, new ModuleError('Iterator is busy: cannot call all() until previous call has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    })) : (this[kWorking] = !0, this[kCallback] = callback, this[kAutoClose] = !0, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleMany], null, []) : this._all(options, this[kHandleMany])), callback[kPromise];
                }
                _all(options, callback) {
                    let count = this[kCount];
                    const acc = [], nextv = ()=>{
                        const size = this[kLimit] < 1 / 0 ? Math.min(1e3, this[kLimit] - count) : 1e3;
                        size <= 0 ? this.nextTick(callback, null, acc) : this._nextv(size, emptyOptions, onnextv);
                    }, onnextv = (err, items)=>{
                        err ? callback(err) : 0 === items.length ? callback(null, acc) : (acc.push.apply(acc, items), count += items.length, nextv());
                    };
                    nextv();
                }
                [kFinishWork]() {
                    const cb = this[kCallback];
                    return this[kAbortOnClose] && null === cb ? noop : (this[kWorking] = !1, this[kCallback] = null, this[kClosing] && this._close(this[kHandleClose]), cb);
                }
                [kReturnMany](cb, err, items) {
                    this[kAutoClose] ? this.close(cb.bind(null, err, items)) : cb(err, items);
                }
                seek(target, options) {
                    if (options = getOptions(options, emptyOptions), this[kClosing]) ;
                    else if (this[kWorking]) throw new ModuleError('Iterator is busy: cannot call seek() until next() has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    });
                    else {
                        const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding]), keyFormat = keyEncoding.format;
                        options.keyEncoding !== keyFormat && (options = {
                            ...options,
                            keyEncoding: keyFormat
                        });
                        const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
                        this._seek(mapped, options);
                    }
                }
                _seek(target, options) {
                    throw new ModuleError('Iterator does not support seek()', {
                        code: 'LEVEL_NOT_SUPPORTED'
                    });
                }
                close(callback) {
                    if (callback = fromCallback(callback, kPromise), this[kClosed]) this.nextTick(callback);
                    else if (this[kClosing]) this[kCloseCallbacks].push(callback);
                    else if (this[kClosing] = !0, this[kCloseCallbacks].push(callback), this[kWorking]) {
                        if (this[kAbortOnClose]) {
                            const cb = this[kFinishWork]();
                            cb(new ModuleError('Aborted on iterator close()', {
                                code: 'LEVEL_ITERATOR_NOT_OPEN'
                            }));
                        }
                    } else this._close(this[kHandleClose]);
                    return callback[kPromise];
                }
                _close(callback) {
                    this.nextTick(callback);
                }
                [kHandleClose]() {
                    this[kClosed] = !0, this.db.detachResource(this);
                    const callbacks = this[kCloseCallbacks];
                    for (const cb of (this[kCloseCallbacks] = [], callbacks))cb();
                }
                async *[Symbol.asyncIterator]() {
                    try {
                        let item;
                        for(; void 0 !== (item = await this.next());)yield item;
                    } finally{
                        this[kClosed] || await this.close();
                    }
                }
            }
            class AbstractIterator extends CommonIterator {
                constructor(db, options){
                    super(db, options, !0), this[kKeys] = !1 !== options.keys, this[kValues] = !1 !== options.values;
                }
                [kHandleOne](err, key, value) {
                    const cb = this[kFinishWork]();
                    if (err) return cb(err);
                    try {
                        key = this[kKeys] && void 0 !== key ? this[kKeyEncoding].decode(key) : void 0, value = this[kValues] && void 0 !== value ? this[kValueEncoding].decode(value) : void 0;
                    } catch (err1) {
                        return cb(new IteratorDecodeError('entry', err1));
                    }
                    !(void 0 === key && void 0 === value) && this[kCount]++, cb(null, key, value);
                }
                [kHandleMany](err, entries) {
                    const cb = this[kFinishWork]();
                    if (err) return this[kReturnMany](cb, err);
                    try {
                        for (const entry of entries){
                            const key = entry[0], value = entry[1];
                            entry[0] = this[kKeys] && void 0 !== key ? this[kKeyEncoding].decode(key) : void 0, entry[1] = this[kValues] && void 0 !== value ? this[kValueEncoding].decode(value) : void 0;
                        }
                    } catch (err1) {
                        return this[kReturnMany](cb, new IteratorDecodeError('entries', err1));
                    }
                    this[kCount] += entries.length, this[kReturnMany](cb, null, entries);
                }
                end(callback) {
                    return warnedEnd || 'undefined' == typeof console || (warnedEnd = !0, console.warn(new ModuleError('The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version', {
                        code: 'LEVEL_LEGACY'
                    }))), this.close(callback);
                }
            }
            class AbstractKeyIterator extends CommonIterator {
                constructor(db, options){
                    super(db, options, !1);
                }
                [kHandleOne](err, key) {
                    const cb = this[kFinishWork]();
                    if (err) return cb(err);
                    try {
                        key = void 0 !== key ? this[kKeyEncoding].decode(key) : void 0;
                    } catch (err1) {
                        return cb(new IteratorDecodeError('key', err1));
                    }
                    void 0 !== key && this[kCount]++, cb(null, key);
                }
                [kHandleMany](err, keys) {
                    const cb = this[kFinishWork]();
                    if (err) return this[kReturnMany](cb, err);
                    try {
                        for(let i = 0; i < keys.length; i++){
                            const key = keys[i];
                            keys[i] = void 0 !== key ? this[kKeyEncoding].decode(key) : void 0;
                        }
                    } catch (err1) {
                        return this[kReturnMany](cb, new IteratorDecodeError('keys', err1));
                    }
                    this[kCount] += keys.length, this[kReturnMany](cb, null, keys);
                }
            }
            class AbstractValueIterator extends CommonIterator {
                constructor(db, options){
                    super(db, options, !1);
                }
                [kHandleOne](err, value) {
                    const cb = this[kFinishWork]();
                    if (err) return cb(err);
                    try {
                        value = void 0 !== value ? this[kValueEncoding].decode(value) : void 0;
                    } catch (err1) {
                        return cb(new IteratorDecodeError('value', err1));
                    }
                    void 0 !== value && this[kCount]++, cb(null, value);
                }
                [kHandleMany](err, values) {
                    const cb = this[kFinishWork]();
                    if (err) return this[kReturnMany](cb, err);
                    try {
                        for(let i = 0; i < values.length; i++){
                            const value = values[i];
                            values[i] = void 0 !== value ? this[kValueEncoding].decode(value) : void 0;
                        }
                    } catch (err1) {
                        return this[kReturnMany](cb, new IteratorDecodeError('values', err1));
                    }
                    this[kCount] += values.length, this[kReturnMany](cb, null, values);
                }
            }
            class IteratorDecodeError extends ModuleError {
                constructor(subject, cause){
                    super(`Iterator could not decode ${subject}`, {
                        code: 'LEVEL_DECODE_ERROR',
                        cause
                    });
                }
            }
            for (const k of [
                '_ended property',
                '_nexting property',
                '_end method'
            ])Object.defineProperty(AbstractIterator.prototype, k.split(' ')[0], {
                get () {
                    throw new ModuleError(`The ${k} has been removed`, {
                        code: 'LEVEL_LEGACY'
                    });
                },
                set () {
                    throw new ModuleError(`The ${k} has been removed`, {
                        code: 'LEVEL_LEGACY'
                    });
                }
            });
            AbstractIterator.keyEncoding = kKeyEncoding, AbstractIterator.valueEncoding = kValueEncoding, exports.AbstractIterator = AbstractIterator, exports.AbstractKeyIterator = AbstractKeyIterator, exports.AbstractValueIterator = AbstractValueIterator;
        },
        9071: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { supports  } = __webpack_require__(1675), { Transcoder  } = __webpack_require__(8499), { EventEmitter  } = __webpack_require__(7187), { fromCallback  } = __webpack_require__(6957), ModuleError = __webpack_require__(4473), { AbstractIterator  } = __webpack_require__(3961), { DefaultKeyIterator , DefaultValueIterator  } = __webpack_require__(5429), { DeferredIterator , DeferredKeyIterator , DeferredValueIterator  } = __webpack_require__(593), { DefaultChainedBatch  } = __webpack_require__(4765), { getCallback , getOptions  } = __webpack_require__(2520), rangeOptions = __webpack_require__(56), kPromise = Symbol('promise'), kLanded = Symbol('landed'), kResources = Symbol('resources'), kCloseResources = Symbol('closeResources'), kOperations = Symbol('operations'), kUndefer = Symbol('undefer'), kDeferOpen = Symbol('deferOpen'), kOptions = Symbol('options'), kStatus = Symbol('status'), kDefaultOptions = Symbol('defaultOptions'), kTranscoder = Symbol('transcoder'), kKeyEncoding = Symbol('keyEncoding'), kValueEncoding = Symbol('valueEncoding'), noop = ()=>{};
            class AbstractLevel extends EventEmitter {
                constructor(manifest, options){
                    if (super(), 'object' != typeof manifest || null === manifest) throw TypeError("The first argument 'manifest' must be an object");
                    options = getOptions(options);
                    const { keyEncoding , valueEncoding , passive , ...forward } = options;
                    for (const encoding of (this[kResources] = new Set(), this[kOperations] = [], this[kDeferOpen] = !0, this[kOptions] = forward, this[kStatus] = 'opening', this.supports = supports(manifest, {
                        status: !0,
                        promises: !0,
                        clear: !0,
                        getMany: !0,
                        deferredOpen: !0,
                        snapshots: !1 !== manifest.snapshots,
                        permanence: !1 !== manifest.permanence,
                        keyIterator: !0,
                        valueIterator: !0,
                        iteratorNextv: !0,
                        iteratorAll: !0,
                        encodings: manifest.encodings || {},
                        events: Object.assign({}, manifest.events, {
                            opening: !0,
                            open: !0,
                            closing: !0,
                            closed: !0,
                            put: !0,
                            del: !0,
                            batch: !0,
                            clear: !0
                        })
                    }), this[kTranscoder] = new Transcoder(formats(this)), this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8'), this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8'), this[kTranscoder].encodings()))this.supports.encodings[encoding.commonName] || (this.supports.encodings[encoding.commonName] = !0);
                    this[kDefaultOptions] = {
                        empty: Object.freeze({}),
                        entry: Object.freeze({
                            keyEncoding: this[kKeyEncoding].commonName,
                            valueEncoding: this[kValueEncoding].commonName
                        }),
                        key: Object.freeze({
                            keyEncoding: this[kKeyEncoding].commonName
                        })
                    }, this.nextTick(()=>{
                        this[kDeferOpen] && this.open({
                            passive: !1
                        }, noop);
                    });
                }
                get status() {
                    return this[kStatus];
                }
                keyEncoding(encoding) {
                    return this[kTranscoder].encoding(null != encoding ? encoding : this[kKeyEncoding]);
                }
                valueEncoding(encoding) {
                    return this[kTranscoder].encoding(null != encoding ? encoding : this[kValueEncoding]);
                }
                open(options, callback) {
                    callback = getCallback(options, callback), callback = fromCallback(callback, kPromise), (options = {
                        ...this[kOptions],
                        ...getOptions(options)
                    }).createIfMissing = !1 !== options.createIfMissing, options.errorIfExists = !!options.errorIfExists;
                    const maybeOpened = (err)=>{
                        'closing' === this[kStatus] || 'opening' === this[kStatus] ? this.once(kLanded, err ? ()=>maybeOpened(err) : maybeOpened) : 'open' !== this[kStatus] ? callback(new ModuleError('Database is not open', {
                            code: 'LEVEL_DATABASE_NOT_OPEN',
                            cause: err
                        })) : callback();
                    };
                    return options.passive ? 'opening' === this[kStatus] ? this.once(kLanded, maybeOpened) : this.nextTick(maybeOpened) : 'closed' === this[kStatus] || this[kDeferOpen] ? (this[kDeferOpen] = !1, this[kStatus] = 'opening', this.emit('opening'), this._open(options, (err)=>{
                        if (err) {
                            this[kStatus] = 'closed', this[kCloseResources](()=>{
                                this.emit(kLanded), maybeOpened(err);
                            }), this[kUndefer]();
                            return;
                        }
                        this[kStatus] = 'open', this[kUndefer](), this.emit(kLanded), 'open' === this[kStatus] && this.emit('open'), 'open' === this[kStatus] && this.emit('ready'), maybeOpened();
                    })) : 'open' === this[kStatus] ? this.nextTick(maybeOpened) : this.once(kLanded, ()=>this.open(options, callback)), callback[kPromise];
                }
                _open(options, callback) {
                    this.nextTick(callback);
                }
                close(callback) {
                    callback = fromCallback(callback, kPromise);
                    const maybeClosed = (err)=>{
                        'opening' === this[kStatus] || 'closing' === this[kStatus] ? this.once(kLanded, err ? maybeClosed(err) : maybeClosed) : 'closed' !== this[kStatus] ? callback(new ModuleError('Database is not closed', {
                            code: 'LEVEL_DATABASE_NOT_CLOSED',
                            cause: err
                        })) : callback();
                    };
                    if ('open' === this[kStatus]) {
                        this[kStatus] = 'closing', this.emit('closing');
                        const cancel = (err)=>{
                            this[kStatus] = 'open', this[kUndefer](), this.emit(kLanded), maybeClosed(err);
                        };
                        this[kCloseResources](()=>{
                            this._close((err)=>{
                                if (err) return cancel(err);
                                this[kStatus] = 'closed', this[kUndefer](), this.emit(kLanded), 'closed' === this[kStatus] && this.emit('closed'), maybeClosed();
                            });
                        });
                    } else 'closed' === this[kStatus] ? this.nextTick(maybeClosed) : this.once(kLanded, ()=>this.close(callback));
                    return callback[kPromise];
                }
                [kCloseResources](callback) {
                    if (0 === this[kResources].size) return this.nextTick(callback);
                    let pending = this[kResources].size, sync = !0;
                    const next = ()=>{
                        0 == --pending && (sync ? this.nextTick(callback) : callback());
                    };
                    for (const resource of this[kResources])resource.close(next);
                    sync = !1, this[kResources].clear();
                }
                _close(callback) {
                    this.nextTick(callback);
                }
                get(key, options, callback) {
                    if (callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options, this[kDefaultOptions].entry), 'opening' === this[kStatus]) return this.defer(()=>this.get(key, options, callback)), callback[kPromise];
                    if (maybeError(this, callback)) return callback[kPromise];
                    const err = this._checkKey(key);
                    if (err) return this.nextTick(callback, err), callback[kPromise];
                    const keyEncoding = this.keyEncoding(options.keyEncoding), valueEncoding = this.valueEncoding(options.valueEncoding), keyFormat = keyEncoding.format, valueFormat = valueEncoding.format;
                    return (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) && (options = Object.assign({}, options, {
                        keyEncoding: keyFormat,
                        valueEncoding: valueFormat
                    })), this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err, value)=>{
                        if (err) return ('LEVEL_NOT_FOUND' === err.code || err.notFound || /NotFound/i.test(err)) && (err.code || (err.code = 'LEVEL_NOT_FOUND'), err.notFound || (err.notFound = !0), err.status || (err.status = 404)), callback(err);
                        try {
                            value = valueEncoding.decode(value);
                        } catch (err1) {
                            return callback(new ModuleError('Could not decode value', {
                                code: 'LEVEL_DECODE_ERROR',
                                cause: err1
                            }));
                        }
                        callback(null, value);
                    }), callback[kPromise];
                }
                _get(key, options, callback) {
                    this.nextTick(callback, Error('NotFound'));
                }
                getMany(keys, options, callback) {
                    if (callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options, this[kDefaultOptions].entry), 'opening' === this[kStatus]) return this.defer(()=>this.getMany(keys, options, callback)), callback[kPromise];
                    if (maybeError(this, callback)) return callback[kPromise];
                    if (!Array.isArray(keys)) return this.nextTick(callback, TypeError("The first argument 'keys' must be an array")), callback[kPromise];
                    if (0 === keys.length) return this.nextTick(callback, null, []), callback[kPromise];
                    const keyEncoding = this.keyEncoding(options.keyEncoding), valueEncoding = this.valueEncoding(options.valueEncoding), keyFormat = keyEncoding.format, valueFormat = valueEncoding.format;
                    (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) && (options = Object.assign({}, options, {
                        keyEncoding: keyFormat,
                        valueEncoding: valueFormat
                    }));
                    const mappedKeys = Array(keys.length);
                    for(let i = 0; i < keys.length; i++){
                        const key = keys[i], err = this._checkKey(key);
                        if (err) return this.nextTick(callback, err), callback[kPromise];
                        mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat);
                    }
                    return this._getMany(mappedKeys, options, (err, values)=>{
                        if (err) return callback(err);
                        try {
                            for(let i = 0; i < values.length; i++)void 0 !== values[i] && (values[i] = valueEncoding.decode(values[i]));
                        } catch (err1) {
                            return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {
                                code: 'LEVEL_DECODE_ERROR',
                                cause: err1
                            }));
                        }
                        callback(null, values);
                    }), callback[kPromise];
                }
                _getMany(keys, options, callback) {
                    this.nextTick(callback, null, Array(keys.length).fill(void 0));
                }
                put(key, value, options, callback) {
                    if (callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options, this[kDefaultOptions].entry), 'opening' === this[kStatus]) return this.defer(()=>this.put(key, value, options, callback)), callback[kPromise];
                    if (maybeError(this, callback)) return callback[kPromise];
                    const err = this._checkKey(key) || this._checkValue(value);
                    if (err) return this.nextTick(callback, err), callback[kPromise];
                    const keyEncoding = this.keyEncoding(options.keyEncoding), valueEncoding = this.valueEncoding(options.valueEncoding), keyFormat = keyEncoding.format, valueFormat = valueEncoding.format;
                    (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) && (options = Object.assign({}, options, {
                        keyEncoding: keyFormat,
                        valueEncoding: valueFormat
                    }));
                    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat), mappedValue = valueEncoding.encode(value);
                    return this._put(mappedKey, mappedValue, options, (err)=>{
                        if (err) return callback(err);
                        this.emit('put', key, value), callback();
                    }), callback[kPromise];
                }
                _put(key, value, options, callback) {
                    this.nextTick(callback);
                }
                del(key, options, callback) {
                    if (callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options, this[kDefaultOptions].key), 'opening' === this[kStatus]) return this.defer(()=>this.del(key, options, callback)), callback[kPromise];
                    if (maybeError(this, callback)) return callback[kPromise];
                    const err = this._checkKey(key);
                    if (err) return this.nextTick(callback, err), callback[kPromise];
                    const keyEncoding = this.keyEncoding(options.keyEncoding), keyFormat = keyEncoding.format;
                    return options.keyEncoding !== keyFormat && (options = Object.assign({}, options, {
                        keyEncoding: keyFormat
                    })), this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err)=>{
                        if (err) return callback(err);
                        this.emit('del', key), callback();
                    }), callback[kPromise];
                }
                _del(key, options, callback) {
                    this.nextTick(callback);
                }
                batch(operations, options, callback) {
                    if (!arguments.length) {
                        if ('opening' === this[kStatus]) return new DefaultChainedBatch(this);
                        if ('open' !== this[kStatus]) throw new ModuleError('Database is not open', {
                            code: 'LEVEL_DATABASE_NOT_OPEN'
                        });
                        return this._chainedBatch();
                    }
                    if (callback = fromCallback(callback = 'function' == typeof operations ? operations : getCallback(options, callback), kPromise), options = getOptions(options, this[kDefaultOptions].empty), 'opening' === this[kStatus]) return this.defer(()=>this.batch(operations, options, callback)), callback[kPromise];
                    if (maybeError(this, callback)) return callback[kPromise];
                    if (!Array.isArray(operations)) return this.nextTick(callback, TypeError("The first argument 'operations' must be an array")), callback[kPromise];
                    if (0 === operations.length) return this.nextTick(callback), callback[kPromise];
                    const mapped = Array(operations.length), { keyEncoding: ke , valueEncoding: ve , ...forward } = options;
                    for(let i = 0; i < operations.length; i++){
                        if ('object' != typeof operations[i] || null === operations[i]) return this.nextTick(callback, TypeError('A batch operation must be an object')), callback[kPromise];
                        const op = Object.assign({}, operations[i]);
                        if ('put' !== op.type && 'del' !== op.type) return this.nextTick(callback, TypeError("A batch operation must have a type property that is 'put' or 'del'")), callback[kPromise];
                        const err = this._checkKey(op.key);
                        if (err) return this.nextTick(callback, err), callback[kPromise];
                        const db = null != op.sublevel ? op.sublevel : this, keyEncoding = db.keyEncoding(op.keyEncoding || ke), keyFormat = keyEncoding.format;
                        if (op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat), op.keyEncoding = keyFormat, 'put' === op.type) {
                            const valueErr = this._checkValue(op.value);
                            if (valueErr) return this.nextTick(callback, valueErr), callback[kPromise];
                            const valueEncoding = db.valueEncoding(op.valueEncoding || ve);
                            op.value = valueEncoding.encode(op.value), op.valueEncoding = valueEncoding.format;
                        }
                        db !== this && (op.sublevel = null), mapped[i] = op;
                    }
                    return this._batch(mapped, forward, (err)=>{
                        if (err) return callback(err);
                        this.emit('batch', operations), callback();
                    }), callback[kPromise];
                }
                _batch(operations, options, callback) {
                    this.nextTick(callback);
                }
                sublevel(name, options) {
                    return this._sublevel(name, AbstractSublevel.defaults(options));
                }
                _sublevel(name, options) {
                    return new AbstractSublevel(this, name, options);
                }
                prefixKey(key, keyFormat) {
                    return key;
                }
                clear(options, callback) {
                    if (callback = fromCallback(callback = getCallback(options, callback), kPromise), options = getOptions(options, this[kDefaultOptions].empty), 'opening' === this[kStatus]) return this.defer(()=>this.clear(options, callback)), callback[kPromise];
                    if (maybeError(this, callback)) return callback[kPromise];
                    const original = options, keyEncoding = this.keyEncoding(options.keyEncoding);
                    return (options = rangeOptions(options, keyEncoding)).keyEncoding = keyEncoding.format, 0 === options.limit ? this.nextTick(callback) : this._clear(options, (err)=>{
                        if (err) return callback(err);
                        this.emit('clear', original), callback();
                    }), callback[kPromise];
                }
                _clear(options, callback) {
                    this.nextTick(callback);
                }
                iterator(options) {
                    const keyEncoding = this.keyEncoding(options && options.keyEncoding), valueEncoding = this.valueEncoding(options && options.valueEncoding);
                    if ((options = rangeOptions(options, keyEncoding)).keys = !1 !== options.keys, options.values = !1 !== options.values, options[AbstractIterator.keyEncoding] = keyEncoding, options[AbstractIterator.valueEncoding] = valueEncoding, options.keyEncoding = keyEncoding.format, options.valueEncoding = valueEncoding.format, 'opening' === this[kStatus]) return new DeferredIterator(this, options);
                    if ('open' !== this[kStatus]) throw new ModuleError('Database is not open', {
                        code: 'LEVEL_DATABASE_NOT_OPEN'
                    });
                    return this._iterator(options);
                }
                _iterator(options) {
                    return new AbstractIterator(this, options);
                }
                keys(options) {
                    const keyEncoding = this.keyEncoding(options && options.keyEncoding), valueEncoding = this.valueEncoding(options && options.valueEncoding);
                    if ((options = rangeOptions(options, keyEncoding))[AbstractIterator.keyEncoding] = keyEncoding, options[AbstractIterator.valueEncoding] = valueEncoding, options.keyEncoding = keyEncoding.format, options.valueEncoding = valueEncoding.format, 'opening' === this[kStatus]) return new DeferredKeyIterator(this, options);
                    if ('open' !== this[kStatus]) throw new ModuleError('Database is not open', {
                        code: 'LEVEL_DATABASE_NOT_OPEN'
                    });
                    return this._keys(options);
                }
                _keys(options) {
                    return new DefaultKeyIterator(this, options);
                }
                values(options) {
                    const keyEncoding = this.keyEncoding(options && options.keyEncoding), valueEncoding = this.valueEncoding(options && options.valueEncoding);
                    if ((options = rangeOptions(options, keyEncoding))[AbstractIterator.keyEncoding] = keyEncoding, options[AbstractIterator.valueEncoding] = valueEncoding, options.keyEncoding = keyEncoding.format, options.valueEncoding = valueEncoding.format, 'opening' === this[kStatus]) return new DeferredValueIterator(this, options);
                    if ('open' !== this[kStatus]) throw new ModuleError('Database is not open', {
                        code: 'LEVEL_DATABASE_NOT_OPEN'
                    });
                    return this._values(options);
                }
                _values(options) {
                    return new DefaultValueIterator(this, options);
                }
                defer(fn) {
                    if ('function' != typeof fn) throw TypeError('The first argument must be a function');
                    this[kOperations].push(fn);
                }
                [kUndefer]() {
                    if (0 === this[kOperations].length) return;
                    const operations = this[kOperations];
                    for (const op of (this[kOperations] = [], operations))op();
                }
                attachResource(resource) {
                    if ('object' != typeof resource || null === resource || 'function' != typeof resource.close) throw TypeError('The first argument must be a resource object');
                    this[kResources].add(resource);
                }
                detachResource(resource) {
                    this[kResources].delete(resource);
                }
                _chainedBatch() {
                    return new DefaultChainedBatch(this);
                }
                _checkKey(key) {
                    if (null == key) return new ModuleError('Key cannot be null or undefined', {
                        code: 'LEVEL_INVALID_KEY'
                    });
                }
                _checkValue(value) {
                    if (null == value) return new ModuleError('Value cannot be null or undefined', {
                        code: 'LEVEL_INVALID_VALUE'
                    });
                }
            }
            AbstractLevel.prototype.nextTick = __webpack_require__(6909);
            const { AbstractSublevel  } = __webpack_require__(9650)({
                AbstractLevel
            });
            exports.AbstractLevel = AbstractLevel, exports.AbstractSublevel = AbstractSublevel;
            const maybeError = function(db, callback) {
                return 'open' !== db[kStatus] && (db.nextTick(callback, new ModuleError('Database is not open', {
                    code: 'LEVEL_DATABASE_NOT_OPEN'
                })), !0);
            }, formats = function(db) {
                return Object.keys(db.supports.encodings).filter((k)=>!!db.supports.encodings[k]);
            };
        },
        875: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            exports.AbstractLevel = __webpack_require__(9071).AbstractLevel, exports.AbstractSublevel = __webpack_require__(9071).AbstractSublevel, exports.AbstractIterator = __webpack_require__(3961).AbstractIterator, exports.AbstractKeyIterator = __webpack_require__(3961).AbstractKeyIterator, exports.AbstractValueIterator = __webpack_require__(3961).AbstractValueIterator, exports.AbstractChainedBatch = __webpack_require__(9464).AbstractChainedBatch;
        },
        2970: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { AbstractIterator , AbstractKeyIterator , AbstractValueIterator  } = __webpack_require__(3961), kUnfix = Symbol('unfix'), kIterator = Symbol('iterator'), kHandleOne = Symbol('handleOne'), kHandleMany = Symbol('handleMany'), kCallback = Symbol('callback');
            class AbstractSublevelIterator extends AbstractIterator {
                constructor(db, options, iterator, unfix){
                    super(db, options), this[kIterator] = iterator, this[kUnfix] = unfix, this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this), this[kCallback] = null;
                }
                [kHandleOne](err, key, value) {
                    const callback = this[kCallback];
                    if (err) return callback(err);
                    void 0 !== key && (key = this[kUnfix](key)), callback(err, key, value);
                }
                [kHandleMany](err, entries) {
                    const callback = this[kCallback];
                    if (err) return callback(err);
                    for (const entry of entries){
                        const key = entry[0];
                        void 0 !== key && (entry[0] = this[kUnfix](key));
                    }
                    callback(err, entries);
                }
            }
            class AbstractSublevelKeyIterator extends AbstractKeyIterator {
                constructor(db, options, iterator, unfix){
                    super(db, options), this[kIterator] = iterator, this[kUnfix] = unfix, this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this), this[kCallback] = null;
                }
                [kHandleOne](err, key) {
                    const callback = this[kCallback];
                    if (err) return callback(err);
                    void 0 !== key && (key = this[kUnfix](key)), callback(err, key);
                }
                [kHandleMany](err, keys) {
                    const callback = this[kCallback];
                    if (err) return callback(err);
                    for(let i = 0; i < keys.length; i++){
                        const key = keys[i];
                        void 0 !== key && (keys[i] = this[kUnfix](key));
                    }
                    callback(err, keys);
                }
            }
            class AbstractSublevelValueIterator extends AbstractValueIterator {
                constructor(db, options, iterator){
                    super(db, options), this[kIterator] = iterator;
                }
            }
            for (const Iterator of [
                AbstractSublevelIterator,
                AbstractSublevelKeyIterator
            ])Iterator.prototype._next = function(callback) {
                this[kCallback] = callback, this[kIterator].next(this[kHandleOne]);
            }, Iterator.prototype._nextv = function(size, options, callback) {
                this[kCallback] = callback, this[kIterator].nextv(size, options, this[kHandleMany]);
            }, Iterator.prototype._all = function(options, callback) {
                this[kCallback] = callback, this[kIterator].all(options, this[kHandleMany]);
            };
            for (const Iterator1 of [
                AbstractSublevelValueIterator
            ])Iterator1.prototype._next = function(callback) {
                this[kIterator].next(callback);
            }, Iterator1.prototype._nextv = function(size, options, callback) {
                this[kIterator].nextv(size, options, callback);
            }, Iterator1.prototype._all = function(options, callback) {
                this[kIterator].all(options, callback);
            };
            for (const Iterator2 of [
                AbstractSublevelIterator,
                AbstractSublevelKeyIterator,
                AbstractSublevelValueIterator
            ])Iterator2.prototype._seek = function(target, options) {
                this[kIterator].seek(target, options);
            }, Iterator2.prototype._close = function(callback) {
                this[kIterator].close(callback);
            };
            exports.AbstractSublevelIterator = AbstractSublevelIterator, exports.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator, exports.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
        },
        9650: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const ModuleError = __webpack_require__(4473), { Buffer  } = __webpack_require__(8764) || {}, { AbstractSublevelIterator , AbstractSublevelKeyIterator , AbstractSublevelValueIterator  } = __webpack_require__(2970), kPrefix = Symbol('prefix'), kUpperBound = Symbol('upperBound'), kPrefixRange = Symbol('prefixRange'), kParent = Symbol('parent'), kUnfix = Symbol('unfix'), textEncoder = new TextEncoder(), defaults = {
                separator: '!'
            };
            module.exports = function({ AbstractLevel  }) {
                class AbstractSublevel extends AbstractLevel {
                    static defaults(options) {
                        if ('string' == typeof options) throw new ModuleError('The subleveldown string shorthand for { separator } has been removed', {
                            code: 'LEVEL_LEGACY'
                        });
                        if (options && options.open) throw new ModuleError('The subleveldown open option has been removed', {
                            code: 'LEVEL_LEGACY'
                        });
                        return null == options ? defaults : options.separator ? options : {
                            ...options,
                            separator: '!'
                        };
                    }
                    constructor(db, name, options){
                        const { separator , manifest , ...forward } = AbstractSublevel.defaults(options);
                        name = trim(name, separator);
                        const reserved = separator.charCodeAt(0) + 1, parent = db[kParent] || db;
                        if (!textEncoder.encode(name).every((x)=>x > reserved && x < 127)) throw new ModuleError(`Prefix must use bytes > ${reserved} < 127`, {
                            code: 'LEVEL_INVALID_PREFIX'
                        });
                        super(mergeManifests(parent, manifest), forward);
                        const prefix = (db.prefix || '') + separator + name + separator, upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
                        this[kParent] = parent, this[kPrefix] = new MultiFormat(prefix), this[kUpperBound] = new MultiFormat(upperBound), this[kUnfix] = new Unfixer(), this.nextTick = parent.nextTick;
                    }
                    prefixKey(key, keyFormat) {
                        if ('utf8' === keyFormat) return this[kPrefix].utf8 + key;
                        if (0 === key.byteLength) return this[kPrefix][keyFormat];
                        if ('view' === keyFormat) {
                            const view = this[kPrefix].view, result = new Uint8Array(view.byteLength + key.byteLength);
                            return result.set(view, 0), result.set(key, view.byteLength), result;
                        }
                        {
                            const buffer = this[kPrefix].buffer;
                            return Buffer.concat([
                                buffer,
                                key
                            ], buffer.byteLength + key.byteLength);
                        }
                    }
                    [kPrefixRange](range, keyFormat) {
                        void 0 !== range.gte ? range.gte = this.prefixKey(range.gte, keyFormat) : void 0 !== range.gt ? range.gt = this.prefixKey(range.gt, keyFormat) : range.gte = this[kPrefix][keyFormat], void 0 !== range.lte ? range.lte = this.prefixKey(range.lte, keyFormat) : void 0 !== range.lt ? range.lt = this.prefixKey(range.lt, keyFormat) : range.lte = this[kUpperBound][keyFormat];
                    }
                    get prefix() {
                        return this[kPrefix].utf8;
                    }
                    get db() {
                        return this[kParent];
                    }
                    _open(options, callback) {
                        this[kParent].open({
                            passive: !0
                        }, callback);
                    }
                    _put(key, value, options, callback) {
                        this[kParent].put(key, value, options, callback);
                    }
                    _get(key, options, callback) {
                        this[kParent].get(key, options, callback);
                    }
                    _getMany(keys, options, callback) {
                        this[kParent].getMany(keys, options, callback);
                    }
                    _del(key, options, callback) {
                        this[kParent].del(key, options, callback);
                    }
                    _batch(operations, options, callback) {
                        this[kParent].batch(operations, options, callback);
                    }
                    _clear(options, callback) {
                        this[kPrefixRange](options, options.keyEncoding), this[kParent].clear(options, callback);
                    }
                    _iterator(options) {
                        this[kPrefixRange](options, options.keyEncoding);
                        const iterator = this[kParent].iterator(options), unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
                        return new AbstractSublevelIterator(this, options, iterator, unfix);
                    }
                    _keys(options) {
                        this[kPrefixRange](options, options.keyEncoding);
                        const iterator = this[kParent].keys(options), unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
                        return new AbstractSublevelKeyIterator(this, options, iterator, unfix);
                    }
                    _values(options) {
                        this[kPrefixRange](options, options.keyEncoding);
                        const iterator = this[kParent].values(options);
                        return new AbstractSublevelValueIterator(this, options, iterator);
                    }
                }
                return {
                    AbstractSublevel
                };
            };
            const mergeManifests = function(parent, manifest) {
                return {
                    ...parent.supports,
                    createIfMissing: !1,
                    errorIfExists: !1,
                    events: {},
                    additionalMethods: {},
                    ...manifest,
                    encodings: {
                        utf8: supportsEncoding(parent, 'utf8'),
                        buffer: supportsEncoding(parent, 'buffer'),
                        view: supportsEncoding(parent, 'view')
                    }
                };
            }, supportsEncoding = function(parent, encoding) {
                return !!parent.supports.encodings[encoding] && parent.keyEncoding(encoding).name === encoding;
            };
            class MultiFormat {
                constructor(key){
                    this.utf8 = key, this.view = textEncoder.encode(key), this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {};
                }
            }
            class Unfixer {
                constructor(){
                    this.cache = new Map();
                }
                get(prefixLength, keyFormat) {
                    let unfix = this.cache.get(keyFormat);
                    return void 0 === unfix && (unfix = 'view' === keyFormat ? (function(prefixLength, key) {
                        return key.subarray(prefixLength);
                    }).bind(null, prefixLength) : (function(prefixLength, key) {
                        return key.slice(prefixLength);
                    }).bind(null, prefixLength), this.cache.set(keyFormat, unfix)), unfix;
                }
            }
            const trim = function(str, char) {
                let start = 0, end = str.length;
                for(; start < end && str[start] === char;)start++;
                for(; end > start && str[end - 1] === char;)end--;
                return str.slice(start, end);
            };
        },
        2520: function(__unused_webpack_module, exports) {
            "use strict";
            exports.getCallback = function(options, callback) {
                return 'function' == typeof options ? options : callback;
            }, exports.getOptions = function(options, def) {
                return 'object' == typeof options && null !== options ? options : void 0 !== def ? def : {};
            };
        },
        4765: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { AbstractChainedBatch  } = __webpack_require__(9464), ModuleError = __webpack_require__(4473), kEncoded = Symbol('encoded');
            class DefaultChainedBatch extends AbstractChainedBatch {
                constructor(db){
                    super(db), this[kEncoded] = [];
                }
                _put(key, value, options) {
                    this[kEncoded].push({
                        ...options,
                        type: 'put',
                        key,
                        value
                    });
                }
                _del(key, options) {
                    this[kEncoded].push({
                        ...options,
                        type: 'del',
                        key
                    });
                }
                _clear() {
                    this[kEncoded] = [];
                }
                _write(options, callback) {
                    'opening' === this.db.status ? this.db.defer(()=>this._write(options, callback)) : 'open' === this.db.status ? 0 === this[kEncoded].length ? this.nextTick(callback) : this.db._batch(this[kEncoded], options, callback) : this.nextTick(callback, new ModuleError('Batch is not open: cannot call write() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    }));
                }
            }
            exports.DefaultChainedBatch = DefaultChainedBatch;
        },
        5429: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { AbstractKeyIterator , AbstractValueIterator  } = __webpack_require__(3961), kIterator = Symbol('iterator'), kCallback = Symbol('callback'), kHandleOne = Symbol('handleOne'), kHandleMany = Symbol('handleMany');
            class DefaultKeyIterator extends AbstractKeyIterator {
                constructor(db, options){
                    super(db, options), this[kIterator] = db.iterator({
                        ...options,
                        keys: !0,
                        values: !1
                    }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
                }
            }
            class DefaultValueIterator extends AbstractValueIterator {
                constructor(db, options){
                    super(db, options), this[kIterator] = db.iterator({
                        ...options,
                        keys: !1,
                        values: !0
                    }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
                }
            }
            for (const Iterator of [
                DefaultKeyIterator,
                DefaultValueIterator
            ]){
                const keys = Iterator === DefaultKeyIterator, mapEntry = keys ? (entry)=>entry[0] : (entry)=>entry[1];
                Iterator.prototype._next = function(callback) {
                    this[kCallback] = callback, this[kIterator].next(this[kHandleOne]);
                }, Iterator.prototype[kHandleOne] = function(err, key, value) {
                    const callback = this[kCallback];
                    err ? callback(err) : callback(null, keys ? key : value);
                }, Iterator.prototype._nextv = function(size, options, callback) {
                    this[kCallback] = callback, this[kIterator].nextv(size, options, this[kHandleMany]);
                }, Iterator.prototype._all = function(options, callback) {
                    this[kCallback] = callback, this[kIterator].all(options, this[kHandleMany]);
                }, Iterator.prototype[kHandleMany] = function(err, entries) {
                    const callback = this[kCallback];
                    err ? callback(err) : callback(null, entries.map(mapEntry));
                }, Iterator.prototype._seek = function(target, options) {
                    this[kIterator].seek(target, options);
                }, Iterator.prototype._close = function(callback) {
                    this[kIterator].close(callback);
                };
            }
            exports.DefaultKeyIterator = DefaultKeyIterator, exports.DefaultValueIterator = DefaultValueIterator;
        },
        593: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { AbstractIterator , AbstractKeyIterator , AbstractValueIterator  } = __webpack_require__(3961), ModuleError = __webpack_require__(4473), kNut = Symbol('nut'), kUndefer = Symbol('undefer'), kFactory = Symbol('factory');
            class DeferredIterator extends AbstractIterator {
                constructor(db, options){
                    super(db, options), this[kNut] = null, this[kFactory] = ()=>db.iterator(options), this.db.defer(()=>this[kUndefer]());
                }
            }
            class DeferredKeyIterator extends AbstractKeyIterator {
                constructor(db, options){
                    super(db, options), this[kNut] = null, this[kFactory] = ()=>db.keys(options), this.db.defer(()=>this[kUndefer]());
                }
            }
            class DeferredValueIterator extends AbstractValueIterator {
                constructor(db, options){
                    super(db, options), this[kNut] = null, this[kFactory] = ()=>db.values(options), this.db.defer(()=>this[kUndefer]());
                }
            }
            for (const Iterator of [
                DeferredIterator,
                DeferredKeyIterator,
                DeferredValueIterator
            ])Iterator.prototype[kUndefer] = function() {
                'open' === this.db.status && (this[kNut] = this[kFactory]());
            }, Iterator.prototype._next = function(callback) {
                null !== this[kNut] ? this[kNut].next(callback) : 'opening' === this.db.status ? this.db.defer(()=>this._next(callback)) : this.nextTick(callback, new ModuleError('Iterator is not open: cannot call next() after close()', {
                    code: 'LEVEL_ITERATOR_NOT_OPEN'
                }));
            }, Iterator.prototype._nextv = function(size, options, callback) {
                null !== this[kNut] ? this[kNut].nextv(size, options, callback) : 'opening' === this.db.status ? this.db.defer(()=>this._nextv(size, options, callback)) : this.nextTick(callback, new ModuleError('Iterator is not open: cannot call nextv() after close()', {
                    code: 'LEVEL_ITERATOR_NOT_OPEN'
                }));
            }, Iterator.prototype._all = function(options, callback) {
                null !== this[kNut] ? this[kNut].all(callback) : 'opening' === this.db.status ? this.db.defer(()=>this._all(options, callback)) : this.nextTick(callback, new ModuleError('Iterator is not open: cannot call all() after close()', {
                    code: 'LEVEL_ITERATOR_NOT_OPEN'
                }));
            }, Iterator.prototype._seek = function(target, options) {
                null !== this[kNut] ? this[kNut]._seek(target, options) : 'opening' === this.db.status && this.db.defer(()=>this._seek(target, options));
            }, Iterator.prototype._close = function(callback) {
                null !== this[kNut] ? this[kNut].close(callback) : 'opening' === this.db.status ? this.db.defer(()=>this._close(callback)) : this.nextTick(callback);
            };
            exports.DeferredIterator = DeferredIterator, exports.DeferredKeyIterator = DeferredKeyIterator, exports.DeferredValueIterator = DeferredValueIterator;
        },
        6909: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const queueMicrotask1 = __webpack_require__(4375);
            module.exports = function(fn, ...args) {
                0 === args.length ? queueMicrotask1(fn) : queueMicrotask1(()=>fn(...args));
            };
        },
        56: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const ModuleError = __webpack_require__(4473), hasOwnProperty = Object.prototype.hasOwnProperty, rangeOptions = new Set([
                'lt',
                'lte',
                'gt',
                'gte'
            ]);
            module.exports = function(options, keyEncoding) {
                const result = {};
                for(const k in options)if (hasOwnProperty.call(options, k) && 'keyEncoding' !== k && 'valueEncoding' !== k) {
                    if ('start' === k || 'end' === k) throw new ModuleError(`The legacy range option '${k}' has been removed`, {
                        code: 'LEVEL_LEGACY'
                    });
                    if ('encoding' === k) throw new ModuleError("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
                        code: 'LEVEL_LEGACY'
                    });
                    rangeOptions.has(k) ? result[k] = keyEncoding.encode(options[k]) : result[k] = options[k];
                }
                return result.reverse = !!result.reverse, result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1, result;
            };
        },
        1317: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__), __webpack_exports__.default = {};
        },
        3883: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const bignumber_js_1 = __webpack_require__(4431);
            class Ar {
                constructor(){
                    this.BigNum = (value, decimals)=>new (bignumber_js_1.BigNumber.clone({
                            DECIMAL_PLACES: decimals
                        }))(value);
                }
                winstonToAr(winstonString, { formatted =!1 , decimals =12 , trim =!0  } = {}) {
                    let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
                    return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
                }
                arToWinston(arString, { formatted =!1  } = {}) {
                    let number = this.stringToBigNum(arString).shiftedBy(12);
                    return formatted ? number.toFormat() : number.toFixed(0);
                }
                compare(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA), b = this.stringToBigNum(winstonStringB);
                    return a.comparedTo(b);
                }
                isEqual(winstonStringA, winstonStringB) {
                    return 0 === this.compare(winstonStringA, winstonStringB);
                }
                isLessThan(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA), b = this.stringToBigNum(winstonStringB);
                    return a.isLessThan(b);
                }
                isGreaterThan(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA), b = this.stringToBigNum(winstonStringB);
                    return a.isGreaterThan(b);
                }
                add(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA);
                    return this.stringToBigNum(winstonStringB), a.plus(winstonStringB).toFixed(0);
                }
                sub(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA);
                    return this.stringToBigNum(winstonStringB), a.minus(winstonStringB).toFixed(0);
                }
                stringToBigNum(stringValue, decimalPlaces = 12) {
                    return this.BigNum(stringValue, decimalPlaces);
                }
            }
            exports.default = Ar;
        },
        1286: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const error_1 = __importDefault(__webpack_require__(2990));
            __webpack_require__(1317);
            class Blocks {
                constructor(api, network){
                    this.api = api, this.network = network;
                }
                async get(indepHash) {
                    const response = await this.api.get(`${Blocks.ENDPOINT}${indepHash}`);
                    if (200 === response.status) return response.data;
                    if (404 === response.status) throw new error_1.default("BLOCK_NOT_FOUND");
                    throw Error(`Error while loading block data: ${response}`);
                }
                async getCurrent() {
                    const { current  } = await this.network.getInfo();
                    return await this.get(current);
                }
            }
            exports.default = Blocks, Blocks.ENDPOINT = "block/hash/";
        },
        1070: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const error_1 = __webpack_require__(2990), ArweaveUtils = __importStar(__webpack_require__(5160));
            class Chunks {
                constructor(api){
                    this.api = api;
                }
                async getTransactionOffset(id) {
                    const resp = await this.api.get(`tx/${id}/offset`);
                    if (200 === resp.status) return resp.data;
                    throw Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);
                }
                async getChunk(offset) {
                    const resp = await this.api.get(`chunk/${offset}`);
                    if (200 === resp.status) return resp.data;
                    throw Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);
                }
                async getChunkData(offset) {
                    const chunk = await this.getChunk(offset), buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
                    return buf;
                }
                firstChunkOffset(offsetResponse) {
                    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
                }
                async downloadChunkedData(id) {
                    const offsetResponse = await this.getTransactionOffset(id), size = parseInt(offsetResponse.size), endOffset = parseInt(offsetResponse.offset), startOffset = endOffset - size + 1, data = new Uint8Array(size);
                    let byte = 0;
                    for(; byte < size;){
                        this.api.config.logging && console.log(`[chunk] ${byte}/${size}`);
                        let chunkData;
                        try {
                            chunkData = await this.getChunkData(startOffset + byte);
                        } catch (error) {
                            console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
                        }
                        if (chunkData) data.set(chunkData, byte), byte += chunkData.length;
                        else throw Error(`Couldn't complete data download at ${byte}/${size}`);
                    }
                    return data;
                }
            }
            exports.default = Chunks;
        },
        9499: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            }, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const ar_1 = __importDefault(__webpack_require__(3883)), api_1 = __importDefault(__webpack_require__(7468)), node_driver_1 = __importDefault(__webpack_require__(602)), network_1 = __importDefault(__webpack_require__(5764)), transactions_1 = __importDefault(__webpack_require__(5385)), wallets_1 = __importDefault(__webpack_require__(8379)), transaction_1 = __importDefault(__webpack_require__(7241)), ArweaveUtils = __importStar(__webpack_require__(5160)), silo_1 = __importDefault(__webpack_require__(4486)), chunks_1 = __importDefault(__webpack_require__(1070)), blocks_1 = __importDefault(__webpack_require__(1286));
            class Arweave {
                constructor(apiConfig){
                    this.api = new api_1.default(apiConfig), this.wallets = new wallets_1.default(this.api, Arweave.crypto), this.chunks = new chunks_1.default(this.api), this.transactions = new transactions_1.default(this.api, Arweave.crypto, this.chunks), this.silo = new silo_1.default(this.api, this.crypto, this.transactions), this.network = new network_1.default(this.api), this.blocks = new blocks_1.default(this.api, this.network), this.ar = new ar_1.default();
                }
                get crypto() {
                    return Arweave.crypto;
                }
                get utils() {
                    return Arweave.utils;
                }
                getConfig() {
                    return {
                        api: this.api.getConfig(),
                        crypto: null
                    };
                }
                async createTransaction(attributes, jwk) {
                    const transaction = {};
                    if (Object.assign(transaction, attributes), !attributes.data && !(attributes.target && attributes.quantity)) throw Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
                    if (void 0 == attributes.owner && jwk && "use_wallet" !== jwk && (transaction.owner = jwk.n), void 0 == attributes.last_tx && (transaction.last_tx = await this.transactions.getTransactionAnchor()), "string" == typeof attributes.data && (attributes.data = ArweaveUtils.stringToBuffer(attributes.data)), attributes.data instanceof ArrayBuffer && (attributes.data = new Uint8Array(attributes.data)), attributes.data && !(attributes.data instanceof Uint8Array)) throw Error("Expected data to be a string, Uint8Array or ArrayBuffer");
                    if (void 0 == attributes.reward) {
                        const length = attributes.data ? attributes.data.byteLength : 0;
                        transaction.reward = await this.transactions.getPrice(length, transaction.target);
                    }
                    transaction.data_root = "", transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : "0", transaction.data = attributes.data || new Uint8Array(0);
                    const createdTransaction = new transaction_1.default(transaction);
                    return await createdTransaction.getSignatureData(), createdTransaction;
                }
                async createSiloTransaction(attributes, jwk, siloUri) {
                    const transaction = {};
                    if (Object.assign(transaction, attributes), !attributes.data) throw Error("Silo transactions must have a 'data' value");
                    if (!siloUri) throw Error("No Silo URI specified.");
                    if (attributes.target || attributes.quantity) throw Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
                    if (void 0 == attributes.owner) {
                        if (!jwk || !jwk.n) throw Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
                        transaction.owner = jwk.n;
                    }
                    void 0 == attributes.last_tx && (transaction.last_tx = await this.transactions.getTransactionAnchor());
                    const siloResource = await this.silo.parseUri(siloUri);
                    if ("string" == typeof attributes.data) {
                        const encrypted = await this.crypto.encrypt(ArweaveUtils.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
                        transaction.reward = await this.transactions.getPrice(encrypted.byteLength), transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
                    }
                    if (attributes.data instanceof Uint8Array) {
                        const encrypted1 = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
                        transaction.reward = await this.transactions.getPrice(encrypted1.byteLength), transaction.data = ArweaveUtils.bufferTob64Url(encrypted1);
                    }
                    const siloTransaction = new transaction_1.default(transaction);
                    return siloTransaction.addTag("Silo-Name", siloResource.getAccessKey()), siloTransaction.addTag("Silo-Version", "0.1.0"), siloTransaction;
                }
                arql(query) {
                    return this.api.post("/arql", query).then((response)=>response.data || []);
                }
            }
            exports.default = Arweave, Arweave.crypto = new node_driver_1.default(), Arweave.utils = ArweaveUtils;
        },
        7468: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const axios_1 = __importDefault(__webpack_require__(9669));
            class Api {
                constructor(config){
                    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(config);
                }
                applyConfig(config) {
                    this.config = this.mergeDefaults(config);
                }
                getConfig() {
                    return this.config;
                }
                mergeDefaults(config) {
                    const protocol = config.protocol || "http", port = config.port || ("https" === protocol ? 443 : 80);
                    return {
                        host: config.host || "127.0.0.1",
                        protocol,
                        port,
                        timeout: config.timeout || 20000,
                        logging: config.logging || !1,
                        logger: config.logger || console.log,
                        network: config.network
                    };
                }
                async get(endpoint, config) {
                    try {
                        return await this.request().get(endpoint, config);
                    } catch (error) {
                        if (error.response && error.response.status) return error.response;
                        throw error;
                    }
                }
                async post(endpoint, body, config) {
                    try {
                        return await this.request().post(endpoint, body, config);
                    } catch (error) {
                        if (error.response && error.response.status) return error.response;
                        throw error;
                    }
                }
                request() {
                    const headers = {};
                    this.config.network && (headers["x-network"] = this.config.network);
                    let instance = axios_1.default.create({
                        baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`,
                        timeout: this.config.timeout,
                        maxContentLength: 536870912,
                        headers
                    });
                    return this.config.logging && (instance.interceptors.request.use((request)=>(this.config.logger(`Requesting: ${request.baseURL}/${request.url}`), request)), instance.interceptors.response.use((response)=>(this.config.logger(`Response:   ${response.config.url} - ${response.status}`), response))), instance;
                }
            }
            exports.default = Api;
        },
        602: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(8764).Buffer, __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const pem_1 = __webpack_require__(3068), crypto1 = __importStar(__webpack_require__(2474)), constants = __importStar(__webpack_require__(2454));
            class NodeCryptoDriver {
                constructor(){
                    this.keyLength = 4096, this.publicExponent = 0x10001, this.hashAlgorithm = "sha256", this.encryptionAlgorithm = "aes-256-cbc";
                }
                generateJWK() {
                    if ("function" != typeof crypto1.generateKeyPair) throw Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
                    return new Promise((resolve, reject)=>{
                        crypto1.generateKeyPair("rsa", {
                            modulusLength: this.keyLength,
                            publicExponent: this.publicExponent,
                            privateKeyEncoding: {
                                type: "pkcs1",
                                format: "pem"
                            },
                            publicKeyEncoding: {
                                type: "pkcs1",
                                format: "pem"
                            }
                        }, (err, publicKey, privateKey)=>{
                            err && reject(err), resolve(this.pemToJWK(privateKey));
                        });
                    });
                }
                sign(jwk, data, { saltLength  } = {}) {
                    return new Promise((resolve, reject)=>{
                        resolve(crypto1.createSign(this.hashAlgorithm).update(data).sign({
                            key: this.jwkToPem(jwk),
                            padding: constants.RSA_PKCS1_PSS_PADDING,
                            saltLength
                        }));
                    });
                }
                verify(publicModulus, data, signature) {
                    return new Promise((resolve, reject)=>{
                        const publicKey = {
                            kty: "RSA",
                            e: "AQAB",
                            n: publicModulus
                        }, pem = this.jwkToPem(publicKey);
                        resolve(crypto1.createVerify(this.hashAlgorithm).update(data).verify({
                            key: pem,
                            padding: constants.RSA_PKCS1_PSS_PADDING
                        }, signature));
                    });
                }
                hash(data, algorithm = "SHA-256") {
                    return new Promise((resolve, reject)=>{
                        resolve(crypto1.createHash(this.parseHashAlgorithm(algorithm)).update(data).digest());
                    });
                }
                async encrypt(data, key, salt) {
                    const derivedKey = crypto1.pbkdf2Sync(key, salt = salt || "salt", 100000, 32, this.hashAlgorithm), iv = crypto1.randomBytes(16), cipher = crypto1.createCipheriv(this.encryptionAlgorithm, derivedKey, iv), encrypted = Buffer.concat([
                        iv,
                        cipher.update(data),
                        cipher.final()
                    ]);
                    return encrypted;
                }
                async decrypt(encrypted, key, salt) {
                    try {
                        const derivedKey = crypto1.pbkdf2Sync(key, salt = salt || "salt", 100000, 32, this.hashAlgorithm), iv = encrypted.slice(0, 16), data = encrypted.slice(16), decipher = crypto1.createDecipheriv(this.encryptionAlgorithm, derivedKey, iv), decrypted = Buffer.concat([
                            decipher.update(data),
                            decipher.final(), 
                        ]);
                        return decrypted;
                    } catch (error) {
                        throw Error("Failed to decrypt");
                    }
                }
                jwkToPem(jwk) {
                    return (0, pem_1.jwkTopem)(jwk);
                }
                pemToJWK(pem) {
                    return (0, pem_1.pemTojwk)(pem);
                }
                parseHashAlgorithm(algorithm) {
                    switch(algorithm){
                        case "SHA-256":
                            return "sha256";
                        case "SHA-384":
                            return "sha384";
                        default:
                            throw Error(`Algorithm not supported: ${algorithm}`);
                    }
                }
            }
            exports.default = NodeCryptoDriver;
        },
        3068: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(8764).Buffer, __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.jwkTopem = exports.pemTojwk = void 0;
            const asn = __importStar(__webpack_require__(9809));
            function urlize(base64) {
                return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
            }
            function hex2b64url(str) {
                return urlize(Buffer.from(str, "hex").toString("base64"));
            }
            var RSAPublicKey = asn.define("RSAPublicKey", function() {
                this.seq().obj(this.key("n").int(), this.key("e").int());
            }), AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
                this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
            }), PublicKeyInfo = asn.define("PublicKeyInfo", function() {
                this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("publicKey").bitstr());
            }), Version = asn.define("Version", function() {
                this.int({
                    0: "two-prime",
                    1: "multi"
                });
            }), OtherPrimeInfos = asn.define("OtherPrimeInfos", function() {
                this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
            }), RSAPrivateKey = asn.define("RSAPrivateKey", function() {
                this.seq().obj(this.key("version").use(Version), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos));
            }), PrivateKeyInfo = asn.define("PrivateKeyInfo", function() {
                this.seq().obj(this.key("version").use(Version), this.key("algorithm").use(AlgorithmIdentifier), this.key("privateKey").bitstr());
            });
            function addExtras(obj, extras) {
                return Object.keys(extras = extras || {}).forEach(function(key) {
                    obj[key] = extras[key];
                }), obj;
            }
            function pad(hex) {
                return hex.length % 2 == 1 ? "0" + hex : hex;
            }
            function decodeRsaPublic(buffer, extras) {
                var key = RSAPublicKey.decode(buffer, "der"), e = pad(key.e.toString(16));
                return addExtras({
                    kty: "RSA",
                    n: bn2base64url(key.n),
                    e: hex2b64url(e)
                }, extras);
            }
            function decodeRsaPrivate(buffer, extras) {
                var key = RSAPrivateKey.decode(buffer, "der"), e = pad(key.e.toString(16));
                return addExtras({
                    kty: "RSA",
                    n: bn2base64url(key.n),
                    e: hex2b64url(e),
                    d: bn2base64url(key.d),
                    p: bn2base64url(key.p),
                    q: bn2base64url(key.q),
                    dp: bn2base64url(key.dp),
                    dq: bn2base64url(key.dq),
                    qi: bn2base64url(key.qi)
                }, extras);
            }
            function decodePublic(buffer, extras) {
                return decodeRsaPublic(PublicKeyInfo.decode(buffer, "der").publicKey.data, extras);
            }
            function decodePrivate(buffer, extras) {
                return decodeRsaPrivate(PrivateKeyInfo.decode(buffer, "der").privateKey.data, extras);
            }
            function getDecoder(header) {
                var match = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(header);
                if (!match) return null;
                var isRSA = !!match[1];
                return "PRIVATE" === match[2] ? isRSA ? decodeRsaPrivate : decodePrivate : isRSA ? decodeRsaPublic : decodePublic;
            }
            function parse(jwk) {
                return {
                    n: string2bn(jwk.n),
                    e: string2bn(jwk.e),
                    d: jwk.d && string2bn(jwk.d),
                    p: jwk.p && string2bn(jwk.p),
                    q: jwk.q && string2bn(jwk.q),
                    dp: jwk.dp && string2bn(jwk.dp),
                    dq: jwk.dq && string2bn(jwk.dq),
                    qi: jwk.qi && string2bn(jwk.qi)
                };
            }
            function bn2base64url(bn) {
                return hex2b64url(pad(bn.toString(16)));
            }
            function base64url2bn(str) {
                return new asn.bignum(Buffer.from(str, "base64"));
            }
            function string2bn(str) {
                return /^[0-9]+$/.test(str) ? new asn.bignum(str, 10) : base64url2bn(str);
            }
            function pemTojwk(pem, extras) {
                var text = pem.toString().split(/(\r\n|\r|\n)+/g), decoder = getDecoder((text = text.filter(function(line) {
                    return 0 !== line.trim().length;
                }))[0]);
                return text = text.slice(1, -1).join(""), decoder(Buffer.from(text.replace(/[^\w\d\+\/=]+/g, ""), "base64"), extras);
            }
            function jwkTopem(json) {
                var jwk = parse(json), isPrivate = !!jwk.d, t = isPrivate ? "PRIVATE" : "PUBLIC", header = "-----BEGIN RSA " + t + " KEY-----\n", footer = "\n-----END RSA " + t + " KEY-----\n", data = Buffer.alloc(0);
                return isPrivate ? (jwk.version = "two-prime", data = RSAPrivateKey.encode(jwk, "der")) : data = RSAPublicKey.encode(jwk, "der"), header + data.toString("base64").match(/.{1,64}/g).join("\n") + footer;
            }
            exports.pemTojwk = pemTojwk, exports.jwkTopem = jwkTopem;
        },
        7439: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const common_1 = __importDefault(__webpack_require__(9499));
            async function deepHash(data) {
                if (Array.isArray(data)) {
                    const tag = common_1.default.utils.concatBuffers([
                        common_1.default.utils.stringToBuffer("list"),
                        common_1.default.utils.stringToBuffer(data.length.toString()), 
                    ]);
                    return await deepHashChunks(data, await common_1.default.crypto.hash(tag, "SHA-384"));
                }
                const tag1 = common_1.default.utils.concatBuffers([
                    common_1.default.utils.stringToBuffer("blob"),
                    common_1.default.utils.stringToBuffer(data.byteLength.toString()), 
                ]), taggedHash = common_1.default.utils.concatBuffers([
                    await common_1.default.crypto.hash(tag1, "SHA-384"),
                    await common_1.default.crypto.hash(data, "SHA-384"), 
                ]);
                return await common_1.default.crypto.hash(taggedHash, "SHA-384");
            }
            async function deepHashChunks(chunks, acc) {
                if (chunks.length < 1) return acc;
                const hashPair = common_1.default.utils.concatBuffers([
                    acc,
                    await deepHash(chunks[0]), 
                ]), newAcc = await common_1.default.crypto.hash(hashPair, "SHA-384");
                return await deepHashChunks(chunks.slice(1), newAcc);
            }
            exports.default = deepHash;
        },
        2990: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.getError = void 0;
            class ArweaveError extends Error {
                constructor(type, optional = {}){
                    optional.message ? super(optional.message) : super(), this.type = type, this.response = optional.response;
                }
                getType() {
                    return this.type;
                }
            }
            function getError(resp) {
                let data = resp.data;
                if ("string" == typeof resp.data) try {
                    data = JSON.parse(resp.data);
                } catch (e) {}
                if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) try {
                    data = JSON.parse(data.toString());
                } catch (e1) {}
                return data ? data.error || data : resp.statusText || "unknown";
            }
            exports.default = ArweaveError, exports.getError = getError;
        },
        1612: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(8764).Buffer, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;
            const common_1 = __importDefault(__webpack_require__(9499)), utils_1 = __webpack_require__(5160);
            exports.MAX_CHUNK_SIZE = 262144, exports.MIN_CHUNK_SIZE = 32768;
            const NOTE_SIZE = 32, HASH_SIZE = 32;
            async function chunkData(data) {
                let chunks = [], rest = data, cursor = 0;
                for(; rest.byteLength >= exports.MAX_CHUNK_SIZE;){
                    let chunkSize = exports.MAX_CHUNK_SIZE, nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;
                    nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE && (chunkSize = Math.ceil(rest.byteLength / 2));
                    const chunk = rest.slice(0, chunkSize), dataHash = await common_1.default.crypto.hash(chunk);
                    cursor += chunk.byteLength, chunks.push({
                        dataHash,
                        minByteRange: cursor - chunk.byteLength,
                        maxByteRange: cursor
                    }), rest = rest.slice(chunkSize);
                }
                return chunks.push({
                    dataHash: await common_1.default.crypto.hash(rest),
                    minByteRange: cursor,
                    maxByteRange: cursor + rest.byteLength
                }), chunks;
            }
            async function generateLeaves(chunks) {
                return Promise.all(chunks.map(async ({ dataHash , minByteRange , maxByteRange  })=>({
                        type: "leaf",
                        id: await hash(await Promise.all([
                            hash(dataHash),
                            hash(intToBuffer(maxByteRange))
                        ])),
                        dataHash: dataHash,
                        minByteRange,
                        maxByteRange
                    })));
            }
            async function computeRootHash(data) {
                const rootNode = await generateTree(data);
                return rootNode.id;
            }
            async function generateTree(data) {
                const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));
                return rootNode;
            }
            async function generateTransactionChunks(data) {
                const chunks = await chunkData(data), leaves = await generateLeaves(chunks), root = await buildLayers(leaves), proofs = await generateProofs(root), lastChunk = chunks.slice(-1)[0];
                return lastChunk.maxByteRange - lastChunk.minByteRange == 0 && (chunks.splice(chunks.length - 1, 1), proofs.splice(proofs.length - 1, 1)), {
                    data_root: root.id,
                    chunks,
                    proofs
                };
            }
            async function buildLayers(nodes, level = 0) {
                if (nodes.length < 2) {
                    const root = nodes[0];
                    return root;
                }
                const nextLayer = [];
                for(let i = 0; i < nodes.length; i += 2)nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));
                return buildLayers(nextLayer, level + 1);
            }
            function generateProofs(root) {
                const proofs = resolveBranchProofs(root);
                return Array.isArray(proofs) ? arrayFlatten(proofs) : [
                    proofs
                ];
            }
            function resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {
                if ("leaf" == node.type) return {
                    offset: node.maxByteRange - 1,
                    proof: (0, utils_1.concatBuffers)([
                        proof,
                        node.dataHash,
                        intToBuffer(node.maxByteRange), 
                    ])
                };
                if ("branch" == node.type) {
                    const partialProof = (0, utils_1.concatBuffers)([
                        proof,
                        node.leftChild.id,
                        node.rightChild.id,
                        intToBuffer(node.byteRange), 
                    ]);
                    return [
                        resolveBranchProofs(node.leftChild, partialProof, depth + 1),
                        resolveBranchProofs(node.rightChild, partialProof, depth + 1), 
                    ];
                }
                throw Error("Unexpected node type");
            }
            function arrayFlatten(input) {
                const flat = [];
                return input.forEach((item)=>{
                    Array.isArray(item) ? flat.push(...arrayFlatten(item)) : flat.push(item);
                }), flat;
            }
            async function hashBranch(left, right) {
                return right ? {
                    type: "branch",
                    id: await hash([
                        await hash(left.id),
                        await hash(right.id),
                        await hash(intToBuffer(left.maxByteRange)), 
                    ]),
                    byteRange: left.maxByteRange,
                    maxByteRange: right.maxByteRange,
                    leftChild: left,
                    rightChild: right
                } : left;
            }
            async function hash(data) {
                return Array.isArray(data) && (data = common_1.default.utils.concatBuffers(data)), new Uint8Array(await common_1.default.crypto.hash(data));
            }
            function intToBuffer(note) {
                const buffer = new Uint8Array(NOTE_SIZE);
                for(var i = buffer.length - 1; i >= 0; i--){
                    var byte = note % 256;
                    buffer[i] = byte, note = (note - byte) / 256;
                }
                return buffer;
            }
            function bufferToInt(buffer) {
                let value = 0;
                for(var i = 0; i < buffer.length; i++)value *= 256, value += buffer[i];
                return value;
            }
            exports.chunkData = chunkData, exports.generateLeaves = generateLeaves, exports.computeRootHash = computeRootHash, exports.generateTree = generateTree, exports.generateTransactionChunks = generateTransactionChunks, exports.buildLayers = buildLayers, exports.generateProofs = generateProofs, exports.arrayFlatten = arrayFlatten, exports.intToBuffer = intToBuffer, exports.bufferToInt = bufferToInt;
            const arrayCompare = (a, b)=>a.every((value, index)=>b[index] === value);
            async function validatePath(id, dest, leftBound, rightBound, path) {
                if (rightBound <= 0) return !1;
                if (dest >= rightBound) return validatePath(id, 0, rightBound - 1, rightBound, path);
                if (dest < 0) return validatePath(id, 0, 0, rightBound, path);
                if (path.length == HASH_SIZE + NOTE_SIZE) {
                    const pathData = path.slice(0, HASH_SIZE), endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE), pathDataHash = await hash([
                        await hash(pathData),
                        await hash(endOffsetBuffer), 
                    ]);
                    return !!(0, exports.arrayCompare)(id, pathDataHash) && {
                        offset: rightBound - 1,
                        leftBound: leftBound,
                        rightBound: rightBound,
                        chunkSize: rightBound - leftBound
                    };
                }
                const left = path.slice(0, HASH_SIZE), right = path.slice(left.length, left.length + HASH_SIZE), offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE), offset = bufferToInt(offsetBuffer), remainder = path.slice(left.length + right.length + offsetBuffer.length), pathHash = await hash([
                    await hash(left),
                    await hash(right),
                    await hash(offsetBuffer), 
                ]);
                return !!(0, exports.arrayCompare)(id, pathHash) && (dest < offset ? await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder) : await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder));
            }
            async function debug(proof, output = "") {
                if (proof.byteLength < 1) return output;
                const left = proof.slice(0, HASH_SIZE), right = proof.slice(left.length, left.length + HASH_SIZE), offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE), offset = bufferToInt(offsetBuffer), remainder = proof.slice(left.length + right.length + offsetBuffer.length), pathHash = await hash([
                    await hash(left),
                    await hash(right),
                    await hash(offsetBuffer), 
                ]), updatedOutput = `${output}\n${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
                return debug(remainder, updatedOutput);
            }
            exports.arrayCompare = arrayCompare, exports.validatePath = validatePath, exports.debug = debug;
        },
        4107: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            }, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.TransactionUploader = void 0;
            const transaction_1 = __importDefault(__webpack_require__(7241)), ArweaveUtils = __importStar(__webpack_require__(5160)), error_1 = __webpack_require__(2990), merkle_1 = __webpack_require__(1612), MAX_CHUNKS_IN_BODY = 1, FATAL_CHUNK_UPLOAD_ERRORS = [
                "invalid_json",
                "chunk_too_big",
                "data_path_too_big",
                "offset_too_big",
                "data_size_too_big",
                "chunk_proof_ratio_not_attractive",
                "invalid_proof", 
            ], ERROR_DELAY = 40000;
            class TransactionUploader {
                constructor(api, transaction){
                    if (this.api = api, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !transaction.id) throw Error("Transaction is not signed");
                    if (!transaction.chunks) throw Error("Transaction chunks not prepared");
                    this.data = transaction.data, this.transaction = new transaction_1.default(Object.assign({}, transaction, {
                        data: new Uint8Array(0)
                    }));
                }
                get isComplete() {
                    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
                }
                get totalChunks() {
                    return this.transaction.chunks.chunks.length;
                }
                get uploadedChunks() {
                    return this.chunkIndex;
                }
                get pctComplete() {
                    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
                }
                async uploadChunk(chunkIndex_) {
                    if (this.isComplete) throw Error("Upload is already complete");
                    if ("" !== this.lastResponseError ? this.totalErrors++ : this.totalErrors = 0, 100 === this.totalErrors) throw Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
                    let delay = "" === this.lastResponseError ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
                    if (delay > 0 && await new Promise((res)=>setTimeout(res, delay -= delay * Math.random() * 0.3)), this.lastResponseError = "", !this.txPosted) {
                        await this.postTransaction();
                        return;
                    }
                    chunkIndex_ && (this.chunkIndex = chunkIndex_);
                    const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data), chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));
                    if (!chunkOk) throw Error(`Unable to validate chunk ${this.chunkIndex}`);
                    const resp = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((e)=>(console.error(e.message), {
                            status: -1,
                            data: {
                                error: e.message
                            }
                        }));
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp.status, 200 == this.lastResponseStatus) this.chunkIndex++;
                    else if (this.lastResponseError = (0, error_1.getError)(resp), FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) throw Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
                }
                static async fromSerialized(api, serialized, data) {
                    if (!serialized || "number" != typeof serialized.chunkIndex || "object" != typeof serialized.transaction) throw Error("Serialized object does not match expected format.");
                    var transaction = new transaction_1.default(serialized.transaction);
                    transaction.chunks || await transaction.prepareChunks(data);
                    const upload = new TransactionUploader(api, transaction);
                    if (upload.chunkIndex = serialized.chunkIndex, upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd, upload.lastResponseError = serialized.lastResponseError, upload.lastResponseStatus = serialized.lastResponseStatus, upload.txPosted = serialized.txPosted, upload.data = data, upload.transaction.data_root !== serialized.transaction.data_root) throw Error("Data mismatch: Uploader doesn't match provided data.");
                    return upload;
                }
                static async fromTransactionId(api, id) {
                    const resp = await api.get(`tx/${id}`);
                    if (200 !== resp.status) throw Error(`Tx ${id} not found: ${resp.status}`);
                    const transaction = resp.data;
                    transaction.data = new Uint8Array(0);
                    const serialized = {
                        txPosted: !0,
                        chunkIndex: 0,
                        lastResponseError: "",
                        lastRequestTimeEnd: 0,
                        lastResponseStatus: 0,
                        transaction
                    };
                    return serialized;
                }
                toJSON() {
                    return {
                        chunkIndex: this.chunkIndex,
                        transaction: this.transaction,
                        lastRequestTimeEnd: this.lastRequestTimeEnd,
                        lastResponseStatus: this.lastResponseStatus,
                        lastResponseError: this.lastResponseError,
                        txPosted: this.txPosted
                    };
                }
                async postTransaction() {
                    const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
                    if (uploadInBody) {
                        this.transaction.data = this.data;
                        const resp = await this.api.post("tx", this.transaction).catch((e)=>(console.error(e), {
                                status: -1,
                                data: {
                                    error: e.message
                                }
                            }));
                        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp.status, this.transaction.data = new Uint8Array(0), resp.status >= 200 && resp.status < 300) {
                            this.txPosted = !0, this.chunkIndex = MAX_CHUNKS_IN_BODY;
                            return;
                        }
                        throw this.lastResponseError = (0, error_1.getError)(resp), Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
                    }
                    const resp1 = await this.api.post("tx", this.transaction);
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, !(resp1.status >= 200 && resp1.status < 300)) throw this.lastResponseError = (0, error_1.getError)(resp1), Error(`Unable to upload transaction: ${resp1.status}, ${this.lastResponseError}`);
                    this.txPosted = !0;
                }
            }
            exports.TransactionUploader = TransactionUploader;
        },
        7241: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            }, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Tag = void 0;
            const ArweaveUtils = __importStar(__webpack_require__(5160)), deepHash_1 = __importDefault(__webpack_require__(7439)), merkle_1 = __webpack_require__(1612);
            class BaseObject {
                get(field, options) {
                    if (!Object.getOwnPropertyNames(this).includes(field)) throw Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
                    return this[field] instanceof Uint8Array ? options && options.decode && options.string ? ArweaveUtils.bufferToString(this[field]) : options && options.decode && !options.string ? this[field] : ArweaveUtils.bufferTob64Url(this[field]) : options && !0 == options.decode ? options && options.string ? ArweaveUtils.b64UrlToString(this[field]) : ArweaveUtils.b64UrlToBuffer(this[field]) : this[field];
                }
            }
            class Tag extends BaseObject {
                constructor(name, value, decode = !1){
                    super(), this.name = name, this.value = value;
                }
            }
            exports.Tag = Tag;
            class Transaction extends BaseObject {
                constructor(attributes = {}){
                    super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, attributes), "string" == typeof this.data && (this.data = ArweaveUtils.b64UrlToBuffer(this.data)), attributes.tags && (this.tags = attributes.tags.map((tag)=>new Tag(tag.name, tag.value)));
                }
                addTag(name, value) {
                    this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));
                }
                toJSON() {
                    return {
                        format: this.format,
                        id: this.id,
                        last_tx: this.last_tx,
                        owner: this.owner,
                        tags: this.tags,
                        target: this.target,
                        quantity: this.quantity,
                        data: ArweaveUtils.bufferTob64Url(this.data),
                        data_size: this.data_size,
                        data_root: this.data_root,
                        data_tree: this.data_tree,
                        reward: this.reward,
                        signature: this.signature
                    };
                }
                setOwner(owner) {
                    this.owner = owner;
                }
                setSignature({ id , owner , reward , tags , signature ,  }) {
                    this.id = id, this.owner = owner, reward && (this.reward = reward), tags && (this.tags = tags), this.signature = signature;
                }
                async prepareChunks(data) {
                    !this.chunks && data.byteLength > 0 && (this.chunks = await (0, merkle_1.generateTransactionChunks)(data), this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root)), this.chunks || 0 !== data.byteLength || (this.chunks = {
                        chunks: [],
                        data_root: new Uint8Array(),
                        proofs: []
                    }, this.data_root = "");
                }
                getChunk(idx, data) {
                    if (!this.chunks) throw Error("Chunks have not been prepared");
                    const proof = this.chunks.proofs[idx], chunk = this.chunks.chunks[idx];
                    return {
                        data_root: this.data_root,
                        data_size: this.data_size,
                        data_path: ArweaveUtils.bufferTob64Url(proof.proof),
                        offset: proof.offset.toString(),
                        chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))
                    };
                }
                async getSignatureData() {
                    switch(this.format){
                        case 1:
                            let tags = this.tags.reduce((accumulator, tag)=>ArweaveUtils.concatBuffers([
                                    accumulator,
                                    tag.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag.get("value", {
                                        decode: !0,
                                        string: !1
                                    }), 
                                ]), new Uint8Array());
                            return ArweaveUtils.concatBuffers([
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("data", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils.stringToBuffer(this.quantity),
                                ArweaveUtils.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tags, 
                            ]);
                        case 2:
                            this.data_root || await this.prepareChunks(this.data);
                            const tagList = this.tags.map((tag)=>[
                                    tag.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag.get("value", {
                                        decode: !0,
                                        string: !1
                                    }), 
                                ]);
                            return await (0, deepHash_1.default)([
                                ArweaveUtils.stringToBuffer(this.format.toString()),
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils.stringToBuffer(this.quantity),
                                ArweaveUtils.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tagList,
                                ArweaveUtils.stringToBuffer(this.data_size),
                                this.get("data_root", {
                                    decode: !0,
                                    string: !1
                                }), 
                            ]);
                        default:
                            throw Error(`Unexpected transaction format: ${this.format}`);
                    }
                }
            }
            exports.default = Transaction;
        },
        5160: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.b64UrlDecode = exports.b64UrlEncode = exports.bufferTob64Url = exports.bufferTob64 = exports.b64UrlToBuffer = exports.stringToB64Url = exports.stringToBuffer = exports.bufferToString = exports.b64UrlToString = exports.concatBuffers = void 0;
            const B64js = __importStar(__webpack_require__(9742));
            function concatBuffers(buffers) {
                let total_length = 0;
                for(let i = 0; i < buffers.length; i++)total_length += buffers[i].byteLength;
                let temp = new Uint8Array(total_length), offset = 0;
                temp.set(new Uint8Array(buffers[0]), offset), offset += buffers[0].byteLength;
                for(let i1 = 1; i1 < buffers.length; i1++)temp.set(new Uint8Array(buffers[i1]), offset), offset += buffers[i1].byteLength;
                return temp;
            }
            function b64UrlToString(b64UrlString) {
                let buffer = b64UrlToBuffer(b64UrlString);
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer);
            }
            function bufferToString(buffer) {
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer);
            }
            function stringToBuffer(string) {
                if ("undefined" == typeof TextEncoder) {
                    const TextEncoder1 = __webpack_require__(9539).TextEncoder;
                    return new TextEncoder1().encode(string);
                }
                return new TextEncoder().encode(string);
            }
            function stringToB64Url(string) {
                return bufferTob64Url(stringToBuffer(string));
            }
            function b64UrlToBuffer(b64UrlString) {
                return new Uint8Array(B64js.toByteArray(b64UrlDecode(b64UrlString)));
            }
            function bufferTob64(buffer) {
                return B64js.fromByteArray(new Uint8Array(buffer));
            }
            function bufferTob64Url(buffer) {
                return b64UrlEncode(bufferTob64(buffer));
            }
            function b64UrlEncode(b64UrlString) {
                return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
            }
            function b64UrlDecode(b64UrlString) {
                let padding;
                return padding = (b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - b64UrlString.length % 4, b64UrlString.concat("=".repeat(padding));
            }
            exports.concatBuffers = concatBuffers, exports.b64UrlToString = b64UrlToString, exports.bufferToString = bufferToString, exports.stringToBuffer = stringToBuffer, exports.stringToB64Url = stringToB64Url, exports.b64UrlToBuffer = b64UrlToBuffer, exports.bufferTob64 = bufferTob64, exports.bufferTob64Url = bufferTob64Url, exports.b64UrlEncode = b64UrlEncode, exports.b64UrlDecode = b64UrlDecode;
        },
        5764: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            class Network {
                constructor(api){
                    this.api = api;
                }
                getInfo() {
                    return this.api.get("info").then((response)=>response.data);
                }
                getPeers() {
                    return this.api.get("peers").then((response)=>response.data);
                }
            }
            exports.default = Network;
        },
        4486: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SiloResource = void 0;
            const ArweaveUtils = __importStar(__webpack_require__(5160));
            class Silo {
                constructor(api, crypto1, transactions){
                    this.api = api, this.crypto = crypto1, this.transactions = transactions;
                }
                async get(siloURI) {
                    if (!siloURI) throw Error("No Silo URI specified");
                    const resource = await this.parseUri(siloURI), ids = await this.transactions.search("Silo-Name", resource.getAccessKey());
                    if (0 == ids.length) throw Error(`No data could be found for the Silo URI: ${siloURI}`);
                    const transaction = await this.transactions.get(ids[0]);
                    if (!transaction) throw Error(`No data could be found for the Silo URI: ${siloURI}`);
                    const encrypted = transaction.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
                }
                async readTransactionData(transaction, siloURI) {
                    if (!siloURI) throw Error("No Silo URI specified");
                    const resource = await this.parseUri(siloURI), encrypted = transaction.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
                }
                async parseUri(siloURI) {
                    const parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
                    if (!parsed) throw Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
                    const siloName = parsed[1], hashIterations = Math.pow(2, parseInt(parsed[2])), digest = await this.hash(ArweaveUtils.stringToBuffer(siloName), hashIterations), accessKey = ArweaveUtils.bufferTob64(digest.slice(0, 15)), encryptionkey = await this.hash(digest.slice(16, 31), 1);
                    return new SiloResource(siloURI, accessKey, encryptionkey);
                }
                async hash(input, iterations) {
                    let digest = await this.crypto.hash(input);
                    for(let count = 0; count < iterations - 1; count++)digest = await this.crypto.hash(digest);
                    return digest;
                }
            }
            exports.default = Silo;
            class SiloResource {
                constructor(uri, accessKey, encryptionKey){
                    this.uri = uri, this.accessKey = accessKey, this.encryptionKey = encryptionKey;
                }
                getUri() {
                    return this.uri;
                }
                getAccessKey() {
                    return this.accessKey;
                }
                getEncryptionKey() {
                    return this.encryptionKey;
                }
            }
            exports.SiloResource = SiloResource;
        },
        5385: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            }, __await = this && this.__await || function(v) {
                return this instanceof __await ? (this.v = v, this) : new __await(v);
            }, __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var i, g = generator.apply(thisArg, _arguments || []), q = [];
                return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                    return this;
                }, i;
                function verb(n) {
                    g[n] && (i[n] = function(v) {
                        return new Promise(function(a, b) {
                            q.push([
                                n,
                                v,
                                a,
                                b
                            ]) > 1 || resume(n, v);
                        });
                    });
                }
                function resume(n, v) {
                    try {
                        step(g[n](v));
                    } catch (e) {
                        settle(q[0][3], e);
                    }
                }
                function step(r) {
                    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                }
                function fulfill(value) {
                    resume("next", value);
                }
                function reject(value) {
                    resume("throw", value);
                }
                function settle(f, v) {
                    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
                }
            }, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const error_1 = __importDefault(__webpack_require__(2990)), transaction_1 = __importDefault(__webpack_require__(7241)), ArweaveUtils = __importStar(__webpack_require__(5160)), transaction_uploader_1 = __webpack_require__(4107);
            __webpack_require__(1317);
            class Transactions {
                constructor(api, crypto1, chunks){
                    this.api = api, this.crypto = crypto1, this.chunks = chunks;
                }
                getTransactionAnchor() {
                    return this.api.get("tx_anchor", {
                        transformResponse: []
                    }).then((response)=>response.data);
                }
                getPrice(byteSize, targetAddress) {
                    let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
                    return this.api.get(endpoint, {
                        transformResponse: [
                            function(data) {
                                return data;
                            }, 
                        ]
                    }).then((response)=>response.data);
                }
                async get(id) {
                    const response = await this.api.get(`tx/${id}`);
                    if (200 == response.status) {
                        const data_size = parseInt(response.data.data_size);
                        if (response.data.format >= 2 && data_size > 0 && data_size <= 12582912) {
                            const data = await this.getData(id);
                            return new transaction_1.default(Object.assign(Object.assign({}, response.data), {
                                data
                            }));
                        }
                        return new transaction_1.default(Object.assign(Object.assign({}, response.data), {
                            format: response.data.format || 1
                        }));
                    }
                    if (404 == response.status) throw new error_1.default("TX_NOT_FOUND");
                    if (410 == response.status) throw new error_1.default("TX_FAILED");
                    throw new error_1.default("TX_INVALID");
                }
                fromRaw(attributes) {
                    return new transaction_1.default(attributes);
                }
                async search(tagName, tagValue) {
                    return this.api.post("arql", {
                        op: "equals",
                        expr1: tagName,
                        expr2: tagValue
                    }).then((response)=>response.data ? response.data : []);
                }
                getStatus(id) {
                    return this.api.get(`tx/${id}/status`).then((response)=>200 == response.status ? {
                            status: 200,
                            confirmed: response.data
                        } : {
                            status: response.status,
                            confirmed: null
                        });
                }
                async getData(id, options) {
                    let data;
                    try {
                        data = await this.chunks.downloadChunkedData(id);
                    } catch (error) {
                        console.error(`Error while trying to download chunked data for ${id}`), console.error(error);
                    }
                    if (!data) {
                        console.warn(`Falling back to gateway cache for ${id}`);
                        try {
                            data = (await this.api.get(`/${id}`)).data;
                        } catch (error1) {
                            console.error(`Error while trying to download contiguous data from gateway cache for ${id}`), console.error(error1);
                        }
                    }
                    if (!data) throw Error(`${id} was not found!`);
                    return options && options.decode && !options.string ? data : options && options.decode && options.string ? ArweaveUtils.bufferToString(data) : ArweaveUtils.bufferTob64Url(data);
                }
                async sign(transaction, jwk, options) {
                    if (jwk || "undefined" != typeof window && window.arweaveWallet) {
                        if (jwk && "use_wallet" !== jwk) {
                            transaction.setOwner(jwk.n);
                            let rawSignature = await this.crypto.sign(jwk, await transaction.getSignatureData(), options), id = await this.crypto.hash(rawSignature);
                            transaction.setSignature({
                                id: ArweaveUtils.bufferTob64Url(id),
                                owner: jwk.n,
                                signature: ArweaveUtils.bufferTob64Url(rawSignature)
                            });
                        } else {
                            try {
                                const existingPermissions = await window.arweaveWallet.getPermissions();
                                existingPermissions.includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect([
                                    "SIGN_TRANSACTION"
                                ]);
                            } catch (_a) {}
                            const signedTransaction = await window.arweaveWallet.sign(transaction, options);
                            transaction.setSignature({
                                id: signedTransaction.id,
                                owner: signedTransaction.owner,
                                reward: signedTransaction.reward,
                                tags: signedTransaction.tags,
                                signature: signedTransaction.signature
                            });
                        }
                    } else throw Error("A new Arweave transaction must provide the jwk parameter.");
                }
                async verify(transaction) {
                    const signaturePayload = await transaction.getSignatureData(), rawSignature = transaction.get("signature", {
                        decode: !0,
                        string: !1
                    }), expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));
                    if (transaction.id !== expectedId) throw Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
                    return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);
                }
                async post(transaction) {
                    if ("string" == typeof transaction ? transaction = new transaction_1.default(JSON.parse(transaction)) : "function" == typeof transaction.readInt32BE ? transaction = new transaction_1.default(JSON.parse(transaction.toString())) : "object" != typeof transaction || transaction instanceof transaction_1.default || (transaction = new transaction_1.default(transaction)), !(transaction instanceof transaction_1.default)) throw Error("Must be Transaction object");
                    transaction.chunks || await transaction.prepareChunks(transaction.data);
                    const uploader = await this.getUploader(transaction, transaction.data);
                    try {
                        for(; !uploader.isComplete;)await uploader.uploadChunk();
                    } catch (e) {
                        if (uploader.lastResponseStatus > 0) return {
                            status: uploader.lastResponseStatus,
                            statusText: uploader.lastResponseError,
                            data: {
                                error: uploader.lastResponseError
                            }
                        };
                        throw e;
                    }
                    return {
                        status: 200,
                        statusText: "OK",
                        data: {}
                    };
                }
                async getUploader(upload, data) {
                    let uploader;
                    if (data instanceof ArrayBuffer && (data = new Uint8Array(data)), upload instanceof transaction_1.default) {
                        if (data || (data = upload.data), !(data instanceof Uint8Array)) throw Error("Data format is invalid");
                        upload.chunks || await upload.prepareChunks(data), (uploader = new transaction_uploader_1.TransactionUploader(this.api, upload)).data && 0 !== uploader.data.length || (uploader.data = data);
                    } else {
                        if ("string" == typeof upload && (upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload)), !data || !(data instanceof Uint8Array)) throw Error("Must provide data when resuming upload");
                        uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);
                    }
                    return uploader;
                }
                upload(upload, data) {
                    return __asyncGenerator(this, arguments, function*() {
                        const uploader = yield __await(this.getUploader(upload, data));
                        for(; !uploader.isComplete;)yield __await(uploader.uploadChunk()), yield yield __await(uploader);
                        return yield __await(uploader);
                    });
                }
            }
            exports.default = Transactions;
        },
        8379: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const ArweaveUtils = __importStar(__webpack_require__(5160));
            __webpack_require__(1317);
            class Wallets {
                constructor(api, crypto1){
                    this.api = api, this.crypto = crypto1;
                }
                getBalance(address) {
                    return this.api.get(`wallet/${address}/balance`, {
                        transformResponse: [
                            function(data) {
                                return data;
                            }, 
                        ]
                    }).then((response)=>response.data);
                }
                getLastTransactionID(address) {
                    return this.api.get(`wallet/${address}/last_tx`).then((response)=>response.data);
                }
                generate() {
                    return this.crypto.generateJWK();
                }
                async jwkToAddress(jwk) {
                    return jwk && "use_wallet" !== jwk ? this.getAddress(jwk) : this.getAddress();
                }
                async getAddress(jwk) {
                    if (jwk && "use_wallet" !== jwk) return this.ownerToAddress(jwk.n);
                    try {
                        await window.arweaveWallet.connect([
                            "ACCESS_ADDRESS"
                        ]);
                    } catch (_a) {}
                    return window.arweaveWallet.getActiveAddress();
                }
                async ownerToAddress(owner) {
                    return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));
                }
            }
            exports.default = Wallets;
        },
        4586: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const bignumber_js_1 = __webpack_require__(4431);
            class Ar {
                constructor(){
                    this.BigNum = (value, decimals)=>new (bignumber_js_1.BigNumber.clone({
                            DECIMAL_PLACES: decimals
                        }))(value);
                }
                winstonToAr(winstonString, { formatted =!1 , decimals =12 , trim =!0  } = {}) {
                    let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
                    return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
                }
                arToWinston(arString, { formatted =!1  } = {}) {
                    let number = this.stringToBigNum(arString).shiftedBy(12);
                    return formatted ? number.toFormat() : number.toFixed(0);
                }
                compare(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA), b = this.stringToBigNum(winstonStringB);
                    return a.comparedTo(b);
                }
                isEqual(winstonStringA, winstonStringB) {
                    return 0 === this.compare(winstonStringA, winstonStringB);
                }
                isLessThan(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA), b = this.stringToBigNum(winstonStringB);
                    return a.isLessThan(b);
                }
                isGreaterThan(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA), b = this.stringToBigNum(winstonStringB);
                    return a.isGreaterThan(b);
                }
                add(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA);
                    return this.stringToBigNum(winstonStringB), a.plus(winstonStringB).toFixed(0);
                }
                sub(winstonStringA, winstonStringB) {
                    let a = this.stringToBigNum(winstonStringA);
                    return this.stringToBigNum(winstonStringB), a.minus(winstonStringB).toFixed(0);
                }
                stringToBigNum(stringValue, decimalPlaces = 12) {
                    return this.BigNum(stringValue, decimalPlaces);
                }
            }
            exports.default = Ar;
        },
        3759: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const error_1 = __webpack_require__(5498);
            __webpack_require__(1317);
            class Blocks {
                constructor(api, network){
                    this.api = api, this.network = network;
                }
                async get(indepHash) {
                    const response = await this.api.get(`${Blocks.ENDPOINT}${indepHash}`);
                    if (200 === response.status) return response.data;
                    if (404 === response.status) throw new error_1.default("BLOCK_NOT_FOUND");
                    throw Error(`Error while loading block data: ${response}`);
                }
                async getCurrent() {
                    const { current  } = await this.network.getInfo();
                    return await this.get(current);
                }
            }
            exports.default = Blocks, Blocks.ENDPOINT = "block/hash/";
        },
        6879: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const error_1 = __webpack_require__(5498), ArweaveUtils = __webpack_require__(8244);
            class Chunks {
                constructor(api){
                    this.api = api;
                }
                async getTransactionOffset(id) {
                    const resp = await this.api.get(`tx/${id}/offset`);
                    if (200 === resp.status) return resp.data;
                    throw Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);
                }
                async getChunk(offset) {
                    const resp = await this.api.get(`chunk/${offset}`);
                    if (200 === resp.status) return resp.data;
                    throw Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);
                }
                async getChunkData(offset) {
                    const chunk = await this.getChunk(offset), buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
                    return buf;
                }
                firstChunkOffset(offsetResponse) {
                    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
                }
                async downloadChunkedData(id) {
                    const offsetResponse = await this.getTransactionOffset(id), size = parseInt(offsetResponse.size), endOffset = parseInt(offsetResponse.offset), startOffset = endOffset - size + 1, data = new Uint8Array(size);
                    let byte = 0;
                    for(; byte < size;){
                        this.api.config.logging && console.log(`[chunk] ${byte}/${size}`);
                        let chunkData;
                        try {
                            chunkData = await this.getChunkData(startOffset + byte);
                        } catch (error) {
                            console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
                        }
                        if (chunkData) data.set(chunkData, byte), byte += chunkData.length;
                        else throw Error(`Couldn't complete data download at ${byte}/${size}`);
                    }
                    return data;
                }
            }
            exports.default = Chunks;
        },
        536: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const ar_1 = __webpack_require__(4586), api_1 = __webpack_require__(6874), node_driver_1 = __webpack_require__(9363), network_1 = __webpack_require__(2248), transactions_1 = __webpack_require__(6935), wallets_1 = __webpack_require__(7927), transaction_1 = __webpack_require__(7825), ArweaveUtils = __webpack_require__(8244), silo_1 = __webpack_require__(1243), chunks_1 = __webpack_require__(6879), blocks_1 = __webpack_require__(3759);
            class Arweave {
                constructor(apiConfig){
                    this.api = new api_1.default(apiConfig), this.wallets = new wallets_1.default(this.api, Arweave.crypto), this.chunks = new chunks_1.default(this.api), this.transactions = new transactions_1.default(this.api, Arweave.crypto, this.chunks), this.silo = new silo_1.default(this.api, this.crypto, this.transactions), this.network = new network_1.default(this.api), this.blocks = new blocks_1.default(this.api, this.network), this.ar = new ar_1.default();
                }
                get crypto() {
                    return Arweave.crypto;
                }
                get utils() {
                    return Arweave.utils;
                }
                getConfig() {
                    return {
                        api: this.api.getConfig(),
                        crypto: null
                    };
                }
                async createTransaction(attributes, jwk) {
                    const transaction = {};
                    if (Object.assign(transaction, attributes), !attributes.data && !(attributes.target && attributes.quantity)) throw Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
                    if (void 0 == attributes.owner && jwk && "use_wallet" !== jwk && (transaction.owner = jwk.n), void 0 == attributes.last_tx && (transaction.last_tx = await this.transactions.getTransactionAnchor()), "string" == typeof attributes.data && (attributes.data = ArweaveUtils.stringToBuffer(attributes.data)), attributes.data instanceof ArrayBuffer && (attributes.data = new Uint8Array(attributes.data)), attributes.data && !(attributes.data instanceof Uint8Array)) throw Error("Expected data to be a string, Uint8Array or ArrayBuffer");
                    if (void 0 == attributes.reward) {
                        const length = attributes.data ? attributes.data.byteLength : 0;
                        transaction.reward = await this.transactions.getPrice(length, transaction.target);
                    }
                    transaction.data_root = "", transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : "0", transaction.data = attributes.data || new Uint8Array(0);
                    const createdTransaction = new transaction_1.default(transaction);
                    return await createdTransaction.getSignatureData(), createdTransaction;
                }
                async createSiloTransaction(attributes, jwk, siloUri) {
                    const transaction = {};
                    if (Object.assign(transaction, attributes), !attributes.data) throw Error("Silo transactions must have a 'data' value");
                    if (!siloUri) throw Error("No Silo URI specified.");
                    if (attributes.target || attributes.quantity) throw Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
                    if (void 0 == attributes.owner) {
                        if (!jwk || !jwk.n) throw Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
                        transaction.owner = jwk.n;
                    }
                    void 0 == attributes.last_tx && (transaction.last_tx = await this.transactions.getTransactionAnchor());
                    const siloResource = await this.silo.parseUri(siloUri);
                    if ("string" == typeof attributes.data) {
                        const encrypted = await this.crypto.encrypt(ArweaveUtils.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
                        transaction.reward = await this.transactions.getPrice(encrypted.byteLength), transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
                    }
                    if (attributes.data instanceof Uint8Array) {
                        const encrypted1 = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
                        transaction.reward = await this.transactions.getPrice(encrypted1.byteLength), transaction.data = ArweaveUtils.bufferTob64Url(encrypted1);
                    }
                    const siloTransaction = new transaction_1.default(transaction);
                    return siloTransaction.addTag("Silo-Name", siloResource.getAccessKey()), siloTransaction.addTag("Silo-Version", "0.1.0"), siloTransaction;
                }
                arql(query) {
                    return this.api.post("/arql", query).then((response)=>response.data || []);
                }
            }
            exports.default = Arweave, Arweave.crypto = new node_driver_1.default(), Arweave.utils = ArweaveUtils;
        },
        7386: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __exportStar = this && this.__exportStar || function(m, exports) {
                for(var p in m)"default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const common_1 = __webpack_require__(536);
            common_1.default.init = function(apiConfig = {}) {
                function getDefaultConfig() {
                    const defaults = {
                        host: "arweave.net",
                        port: 443,
                        protocol: "https"
                    };
                    if (!window || !window.location || !window.location.protocol || !window.location.hostname) return defaults;
                    const currentProtocol = window.location.protocol.replace(":", ""), currentHost = window.location.hostname, currentPort = window.location.port ? parseInt(window.location.port) : "https" == currentProtocol ? 443 : 80, isLocal = [
                        "localhost",
                        "127.0.0.1"
                    ].includes(currentHost) || "file" == currentProtocol;
                    return isLocal ? defaults : {
                        host: currentHost,
                        port: currentPort,
                        protocol: currentProtocol
                    };
                }
                const defaultConfig = getDefaultConfig(), protocol = apiConfig.protocol || defaultConfig.protocol, host = apiConfig.host || defaultConfig.host, port = apiConfig.port || defaultConfig.port;
                return new common_1.default(Object.assign(Object.assign({}, apiConfig), {
                    host,
                    protocol,
                    port
                }));
            }, window.Arweave = common_1.default, __exportStar(__webpack_require__(536), exports), exports.default = common_1.default;
        },
        6874: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const axios_1 = __webpack_require__(9669);
            class Api {
                constructor(config){
                    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(config);
                }
                applyConfig(config) {
                    this.config = this.mergeDefaults(config);
                }
                getConfig() {
                    return this.config;
                }
                mergeDefaults(config) {
                    const protocol = config.protocol || "http", port = config.port || ("https" === protocol ? 443 : 80);
                    return {
                        host: config.host || "127.0.0.1",
                        protocol,
                        port,
                        timeout: config.timeout || 20000,
                        logging: config.logging || !1,
                        logger: config.logger || console.log,
                        network: config.network
                    };
                }
                async get(endpoint, config) {
                    try {
                        return await this.request().get(endpoint, config);
                    } catch (error) {
                        if (error.response && error.response.status) return error.response;
                        throw error;
                    }
                }
                async post(endpoint, body, config) {
                    try {
                        return await this.request().post(endpoint, body, config);
                    } catch (error) {
                        if (error.response && error.response.status) return error.response;
                        throw error;
                    }
                }
                request() {
                    const headers = {};
                    this.config.network && (headers["x-network"] = this.config.network);
                    let instance = axios_1.default.create({
                        baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`,
                        timeout: this.config.timeout,
                        maxContentLength: 536870912,
                        headers
                    });
                    return this.config.logging && (instance.interceptors.request.use((request)=>(this.config.logger(`Requesting: ${request.baseURL}/${request.url}`), request)), instance.interceptors.response.use((response)=>(this.config.logger(`Response:   ${response.config.url} - ${response.status}`), response))), instance;
                }
            }
            exports.default = Api;
        },
        9363: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const ArweaveUtils = __webpack_require__(8244);
            class WebCryptoDriver {
                constructor(){
                    if (this.keyLength = 4096, this.publicExponent = 0x10001, this.hashAlgorithm = "sha256", !this.detectWebCrypto()) throw Error("SubtleCrypto not available!");
                    this.driver = crypto.subtle;
                }
                async generateJWK() {
                    let jwk = await this.driver.exportKey("jwk", (await this.driver.generateKey({
                        name: "RSA-PSS",
                        modulusLength: 4096,
                        publicExponent: new Uint8Array([
                            0x01,
                            0x00,
                            0x01
                        ]),
                        hash: {
                            name: "SHA-256"
                        }
                    }, !0, [
                        "sign"
                    ])).privateKey);
                    return {
                        kty: jwk.kty,
                        e: jwk.e,
                        n: jwk.n,
                        d: jwk.d,
                        p: jwk.p,
                        q: jwk.q,
                        dp: jwk.dp,
                        dq: jwk.dq,
                        qi: jwk.qi
                    };
                }
                async sign(jwk, data, { saltLength  } = {}) {
                    let signature = await this.driver.sign({
                        name: "RSA-PSS",
                        saltLength: 32
                    }, await this.jwkToCryptoKey(jwk), data);
                    return new Uint8Array(signature);
                }
                async hash(data, algorithm = "SHA-256") {
                    let digest = await this.driver.digest(algorithm, data);
                    return new Uint8Array(digest);
                }
                async verify(publicModulus, data, signature) {
                    const publicKey = {
                        kty: "RSA",
                        e: "AQAB",
                        n: publicModulus
                    }, key = await this.jwkToPublicCryptoKey(publicKey), verifyWith32 = this.driver.verify({
                        name: "RSA-PSS",
                        saltLength: 32
                    }, key, signature, data), verifyWith0 = this.driver.verify({
                        name: "RSA-PSS",
                        saltLength: 0
                    }, key, signature, data);
                    return verifyWith32 || verifyWith0;
                }
                async jwkToCryptoKey(jwk) {
                    return this.driver.importKey("jwk", jwk, {
                        name: "RSA-PSS",
                        hash: {
                            name: "SHA-256"
                        }
                    }, !1, [
                        "sign"
                    ]);
                }
                async jwkToPublicCryptoKey(publicJwk) {
                    return this.driver.importKey("jwk", publicJwk, {
                        name: "RSA-PSS",
                        hash: {
                            name: "SHA-256"
                        }
                    }, !1, [
                        "verify"
                    ]);
                }
                detectWebCrypto() {
                    if ("undefined" == typeof crypto) return !1;
                    const subtle = null == crypto ? void 0 : crypto.subtle;
                    if (void 0 === subtle) return !1;
                    const names = [
                        "generateKey",
                        "importKey",
                        "exportKey",
                        "digest",
                        "sign", 
                    ];
                    return names.every((name)=>"function" == typeof subtle[name]);
                }
                async encrypt(data, key, salt) {
                    const initialKey = await this.driver.importKey("raw", "string" == typeof key ? ArweaveUtils.stringToBuffer(key) : key, {
                        name: "PBKDF2",
                        length: 32
                    }, !1, [
                        "deriveKey"
                    ]), derivedkey = await this.driver.deriveKey({
                        name: "PBKDF2",
                        salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
                        iterations: 100000,
                        hash: "SHA-256"
                    }, initialKey, {
                        name: "AES-CBC",
                        length: 256
                    }, !1, [
                        "encrypt",
                        "decrypt"
                    ]), iv = new Uint8Array(16);
                    crypto.getRandomValues(iv);
                    const encryptedData = await this.driver.encrypt({
                        name: "AES-CBC",
                        iv: iv
                    }, derivedkey, data);
                    return ArweaveUtils.concatBuffers([
                        iv,
                        encryptedData
                    ]);
                }
                async decrypt(encrypted, key, salt) {
                    const initialKey = await this.driver.importKey("raw", "string" == typeof key ? ArweaveUtils.stringToBuffer(key) : key, {
                        name: "PBKDF2",
                        length: 32
                    }, !1, [
                        "deriveKey"
                    ]), derivedkey = await this.driver.deriveKey({
                        name: "PBKDF2",
                        salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
                        iterations: 100000,
                        hash: "SHA-256"
                    }, initialKey, {
                        name: "AES-CBC",
                        length: 256
                    }, !1, [
                        "encrypt",
                        "decrypt"
                    ]), iv = encrypted.slice(0, 16), data = await this.driver.decrypt({
                        name: "AES-CBC",
                        iv: iv
                    }, derivedkey, encrypted.slice(16));
                    return ArweaveUtils.concatBuffers([
                        data
                    ]);
                }
            }
            exports.default = WebCryptoDriver;
        },
        921: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const common_1 = __webpack_require__(536);
            async function deepHash(data) {
                if (Array.isArray(data)) {
                    const tag = common_1.default.utils.concatBuffers([
                        common_1.default.utils.stringToBuffer("list"),
                        common_1.default.utils.stringToBuffer(data.length.toString()), 
                    ]);
                    return await deepHashChunks(data, await common_1.default.crypto.hash(tag, "SHA-384"));
                }
                const tag1 = common_1.default.utils.concatBuffers([
                    common_1.default.utils.stringToBuffer("blob"),
                    common_1.default.utils.stringToBuffer(data.byteLength.toString()), 
                ]), taggedHash = common_1.default.utils.concatBuffers([
                    await common_1.default.crypto.hash(tag1, "SHA-384"),
                    await common_1.default.crypto.hash(data, "SHA-384"), 
                ]);
                return await common_1.default.crypto.hash(taggedHash, "SHA-384");
            }
            async function deepHashChunks(chunks, acc) {
                if (chunks.length < 1) return acc;
                const hashPair = common_1.default.utils.concatBuffers([
                    acc,
                    await deepHash(chunks[0]), 
                ]), newAcc = await common_1.default.crypto.hash(hashPair, "SHA-384");
                return await deepHashChunks(chunks.slice(1), newAcc);
            }
            exports.default = deepHash;
        },
        5498: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.getError = void 0;
            class ArweaveError extends Error {
                constructor(type, optional = {}){
                    optional.message ? super(optional.message) : super(), this.type = type, this.response = optional.response;
                }
                getType() {
                    return this.type;
                }
            }
            function getError(resp) {
                let data = resp.data;
                if ("string" == typeof resp.data) try {
                    data = JSON.parse(resp.data);
                } catch (e) {}
                if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) try {
                    data = JSON.parse(data.toString());
                } catch (e1) {}
                return data ? data.error || data : resp.statusText || "unknown";
            }
            exports.default = ArweaveError, exports.getError = getError;
        },
        8224: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(8764).Buffer;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;
            const common_1 = __webpack_require__(536), utils_1 = __webpack_require__(8244);
            exports.MAX_CHUNK_SIZE = 262144, exports.MIN_CHUNK_SIZE = 32768;
            const NOTE_SIZE = 32, HASH_SIZE = 32;
            async function chunkData(data) {
                let chunks = [], rest = data, cursor = 0;
                for(; rest.byteLength >= exports.MAX_CHUNK_SIZE;){
                    let chunkSize = exports.MAX_CHUNK_SIZE, nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;
                    nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE && (chunkSize = Math.ceil(rest.byteLength / 2));
                    const chunk = rest.slice(0, chunkSize), dataHash = await common_1.default.crypto.hash(chunk);
                    cursor += chunk.byteLength, chunks.push({
                        dataHash,
                        minByteRange: cursor - chunk.byteLength,
                        maxByteRange: cursor
                    }), rest = rest.slice(chunkSize);
                }
                return chunks.push({
                    dataHash: await common_1.default.crypto.hash(rest),
                    minByteRange: cursor,
                    maxByteRange: cursor + rest.byteLength
                }), chunks;
            }
            async function generateLeaves(chunks) {
                return Promise.all(chunks.map(async ({ dataHash , minByteRange , maxByteRange  })=>({
                        type: "leaf",
                        id: await hash(await Promise.all([
                            hash(dataHash),
                            hash(intToBuffer(maxByteRange))
                        ])),
                        dataHash: dataHash,
                        minByteRange,
                        maxByteRange
                    })));
            }
            async function computeRootHash(data) {
                const rootNode = await generateTree(data);
                return rootNode.id;
            }
            async function generateTree(data) {
                const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));
                return rootNode;
            }
            async function generateTransactionChunks(data) {
                const chunks = await chunkData(data), leaves = await generateLeaves(chunks), root = await buildLayers(leaves), proofs = await generateProofs(root), lastChunk = chunks.slice(-1)[0];
                return lastChunk.maxByteRange - lastChunk.minByteRange == 0 && (chunks.splice(chunks.length - 1, 1), proofs.splice(proofs.length - 1, 1)), {
                    data_root: root.id,
                    chunks,
                    proofs
                };
            }
            async function buildLayers(nodes, level = 0) {
                if (nodes.length < 2) {
                    const root = nodes[0];
                    return root;
                }
                const nextLayer = [];
                for(let i = 0; i < nodes.length; i += 2)nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));
                return buildLayers(nextLayer, level + 1);
            }
            function generateProofs(root) {
                const proofs = resolveBranchProofs(root);
                return Array.isArray(proofs) ? arrayFlatten(proofs) : [
                    proofs
                ];
            }
            function resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {
                if ("leaf" == node.type) return {
                    offset: node.maxByteRange - 1,
                    proof: (0, utils_1.concatBuffers)([
                        proof,
                        node.dataHash,
                        intToBuffer(node.maxByteRange), 
                    ])
                };
                if ("branch" == node.type) {
                    const partialProof = (0, utils_1.concatBuffers)([
                        proof,
                        node.leftChild.id,
                        node.rightChild.id,
                        intToBuffer(node.byteRange), 
                    ]);
                    return [
                        resolveBranchProofs(node.leftChild, partialProof, depth + 1),
                        resolveBranchProofs(node.rightChild, partialProof, depth + 1), 
                    ];
                }
                throw Error("Unexpected node type");
            }
            function arrayFlatten(input) {
                const flat = [];
                return input.forEach((item)=>{
                    Array.isArray(item) ? flat.push(...arrayFlatten(item)) : flat.push(item);
                }), flat;
            }
            async function hashBranch(left, right) {
                return right ? {
                    type: "branch",
                    id: await hash([
                        await hash(left.id),
                        await hash(right.id),
                        await hash(intToBuffer(left.maxByteRange)), 
                    ]),
                    byteRange: left.maxByteRange,
                    maxByteRange: right.maxByteRange,
                    leftChild: left,
                    rightChild: right
                } : left;
            }
            async function hash(data) {
                return Array.isArray(data) && (data = common_1.default.utils.concatBuffers(data)), new Uint8Array(await common_1.default.crypto.hash(data));
            }
            function intToBuffer(note) {
                const buffer = new Uint8Array(NOTE_SIZE);
                for(var i = buffer.length - 1; i >= 0; i--){
                    var byte = note % 256;
                    buffer[i] = byte, note = (note - byte) / 256;
                }
                return buffer;
            }
            function bufferToInt(buffer) {
                let value = 0;
                for(var i = 0; i < buffer.length; i++)value *= 256, value += buffer[i];
                return value;
            }
            exports.chunkData = chunkData, exports.generateLeaves = generateLeaves, exports.computeRootHash = computeRootHash, exports.generateTree = generateTree, exports.generateTransactionChunks = generateTransactionChunks, exports.buildLayers = buildLayers, exports.generateProofs = generateProofs, exports.arrayFlatten = arrayFlatten, exports.intToBuffer = intToBuffer, exports.bufferToInt = bufferToInt;
            const arrayCompare = (a, b)=>a.every((value, index)=>b[index] === value);
            async function validatePath(id, dest, leftBound, rightBound, path) {
                if (rightBound <= 0) return !1;
                if (dest >= rightBound) return validatePath(id, 0, rightBound - 1, rightBound, path);
                if (dest < 0) return validatePath(id, 0, 0, rightBound, path);
                if (path.length == HASH_SIZE + NOTE_SIZE) {
                    const pathData = path.slice(0, HASH_SIZE), endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE), pathDataHash = await hash([
                        await hash(pathData),
                        await hash(endOffsetBuffer), 
                    ]);
                    return !!(0, exports.arrayCompare)(id, pathDataHash) && {
                        offset: rightBound - 1,
                        leftBound: leftBound,
                        rightBound: rightBound,
                        chunkSize: rightBound - leftBound
                    };
                }
                const left = path.slice(0, HASH_SIZE), right = path.slice(left.length, left.length + HASH_SIZE), offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE), offset = bufferToInt(offsetBuffer), remainder = path.slice(left.length + right.length + offsetBuffer.length), pathHash = await hash([
                    await hash(left),
                    await hash(right),
                    await hash(offsetBuffer), 
                ]);
                return !!(0, exports.arrayCompare)(id, pathHash) && (dest < offset ? await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder) : await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder));
            }
            async function debug(proof, output = "") {
                if (proof.byteLength < 1) return output;
                const left = proof.slice(0, HASH_SIZE), right = proof.slice(left.length, left.length + HASH_SIZE), offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE), offset = bufferToInt(offsetBuffer), remainder = proof.slice(left.length + right.length + offsetBuffer.length), pathHash = await hash([
                    await hash(left),
                    await hash(right),
                    await hash(offsetBuffer), 
                ]), updatedOutput = `${output}\n${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
                return debug(remainder, updatedOutput);
            }
            exports.arrayCompare = arrayCompare, exports.validatePath = validatePath, exports.debug = debug;
        },
        1246: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.TransactionUploader = void 0;
            const transaction_1 = __webpack_require__(7825), ArweaveUtils = __webpack_require__(8244), error_1 = __webpack_require__(5498), merkle_1 = __webpack_require__(8224), MAX_CHUNKS_IN_BODY = 1, FATAL_CHUNK_UPLOAD_ERRORS = [
                "invalid_json",
                "chunk_too_big",
                "data_path_too_big",
                "offset_too_big",
                "data_size_too_big",
                "chunk_proof_ratio_not_attractive",
                "invalid_proof", 
            ], ERROR_DELAY = 40000;
            class TransactionUploader {
                constructor(api, transaction){
                    if (this.api = api, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !transaction.id) throw Error("Transaction is not signed");
                    if (!transaction.chunks) throw Error("Transaction chunks not prepared");
                    this.data = transaction.data, this.transaction = new transaction_1.default(Object.assign({}, transaction, {
                        data: new Uint8Array(0)
                    }));
                }
                get isComplete() {
                    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
                }
                get totalChunks() {
                    return this.transaction.chunks.chunks.length;
                }
                get uploadedChunks() {
                    return this.chunkIndex;
                }
                get pctComplete() {
                    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
                }
                async uploadChunk(chunkIndex_) {
                    if (this.isComplete) throw Error("Upload is already complete");
                    if ("" !== this.lastResponseError ? this.totalErrors++ : this.totalErrors = 0, 100 === this.totalErrors) throw Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
                    let delay = "" === this.lastResponseError ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
                    if (delay > 0 && await new Promise((res)=>setTimeout(res, delay -= delay * Math.random() * 0.3)), this.lastResponseError = "", !this.txPosted) {
                        await this.postTransaction();
                        return;
                    }
                    chunkIndex_ && (this.chunkIndex = chunkIndex_);
                    const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data), chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));
                    if (!chunkOk) throw Error(`Unable to validate chunk ${this.chunkIndex}`);
                    const resp = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((e)=>(console.error(e.message), {
                            status: -1,
                            data: {
                                error: e.message
                            }
                        }));
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp.status, 200 == this.lastResponseStatus) this.chunkIndex++;
                    else if (this.lastResponseError = (0, error_1.getError)(resp), FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) throw Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
                }
                static async fromSerialized(api, serialized, data) {
                    if (!serialized || "number" != typeof serialized.chunkIndex || "object" != typeof serialized.transaction) throw Error("Serialized object does not match expected format.");
                    var transaction = new transaction_1.default(serialized.transaction);
                    transaction.chunks || await transaction.prepareChunks(data);
                    const upload = new TransactionUploader(api, transaction);
                    if (upload.chunkIndex = serialized.chunkIndex, upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd, upload.lastResponseError = serialized.lastResponseError, upload.lastResponseStatus = serialized.lastResponseStatus, upload.txPosted = serialized.txPosted, upload.data = data, upload.transaction.data_root !== serialized.transaction.data_root) throw Error("Data mismatch: Uploader doesn't match provided data.");
                    return upload;
                }
                static async fromTransactionId(api, id) {
                    const resp = await api.get(`tx/${id}`);
                    if (200 !== resp.status) throw Error(`Tx ${id} not found: ${resp.status}`);
                    const transaction = resp.data;
                    transaction.data = new Uint8Array(0);
                    const serialized = {
                        txPosted: !0,
                        chunkIndex: 0,
                        lastResponseError: "",
                        lastRequestTimeEnd: 0,
                        lastResponseStatus: 0,
                        transaction
                    };
                    return serialized;
                }
                toJSON() {
                    return {
                        chunkIndex: this.chunkIndex,
                        transaction: this.transaction,
                        lastRequestTimeEnd: this.lastRequestTimeEnd,
                        lastResponseStatus: this.lastResponseStatus,
                        lastResponseError: this.lastResponseError,
                        txPosted: this.txPosted
                    };
                }
                async postTransaction() {
                    const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
                    if (uploadInBody) {
                        this.transaction.data = this.data;
                        const resp = await this.api.post("tx", this.transaction).catch((e)=>(console.error(e), {
                                status: -1,
                                data: {
                                    error: e.message
                                }
                            }));
                        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp.status, this.transaction.data = new Uint8Array(0), resp.status >= 200 && resp.status < 300) {
                            this.txPosted = !0, this.chunkIndex = MAX_CHUNKS_IN_BODY;
                            return;
                        }
                        throw this.lastResponseError = (0, error_1.getError)(resp), Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
                    }
                    const resp1 = await this.api.post("tx", this.transaction);
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, !(resp1.status >= 200 && resp1.status < 300)) throw this.lastResponseError = (0, error_1.getError)(resp1), Error(`Unable to upload transaction: ${resp1.status}, ${this.lastResponseError}`);
                    this.txPosted = !0;
                }
            }
            exports.TransactionUploader = TransactionUploader;
        },
        7825: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Tag = void 0;
            const ArweaveUtils = __webpack_require__(8244), deepHash_1 = __webpack_require__(921), merkle_1 = __webpack_require__(8224);
            class BaseObject {
                get(field, options) {
                    if (!Object.getOwnPropertyNames(this).includes(field)) throw Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
                    return this[field] instanceof Uint8Array ? options && options.decode && options.string ? ArweaveUtils.bufferToString(this[field]) : options && options.decode && !options.string ? this[field] : ArweaveUtils.bufferTob64Url(this[field]) : options && !0 == options.decode ? options && options.string ? ArweaveUtils.b64UrlToString(this[field]) : ArweaveUtils.b64UrlToBuffer(this[field]) : this[field];
                }
            }
            class Tag extends BaseObject {
                constructor(name, value, decode = !1){
                    super(), this.name = name, this.value = value;
                }
            }
            exports.Tag = Tag;
            class Transaction extends BaseObject {
                constructor(attributes = {}){
                    super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, attributes), "string" == typeof this.data && (this.data = ArweaveUtils.b64UrlToBuffer(this.data)), attributes.tags && (this.tags = attributes.tags.map((tag)=>new Tag(tag.name, tag.value)));
                }
                addTag(name, value) {
                    this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));
                }
                toJSON() {
                    return {
                        format: this.format,
                        id: this.id,
                        last_tx: this.last_tx,
                        owner: this.owner,
                        tags: this.tags,
                        target: this.target,
                        quantity: this.quantity,
                        data: ArweaveUtils.bufferTob64Url(this.data),
                        data_size: this.data_size,
                        data_root: this.data_root,
                        data_tree: this.data_tree,
                        reward: this.reward,
                        signature: this.signature
                    };
                }
                setOwner(owner) {
                    this.owner = owner;
                }
                setSignature({ id , owner , reward , tags , signature ,  }) {
                    this.id = id, this.owner = owner, reward && (this.reward = reward), tags && (this.tags = tags), this.signature = signature;
                }
                async prepareChunks(data) {
                    !this.chunks && data.byteLength > 0 && (this.chunks = await (0, merkle_1.generateTransactionChunks)(data), this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root)), this.chunks || 0 !== data.byteLength || (this.chunks = {
                        chunks: [],
                        data_root: new Uint8Array(),
                        proofs: []
                    }, this.data_root = "");
                }
                getChunk(idx, data) {
                    if (!this.chunks) throw Error("Chunks have not been prepared");
                    const proof = this.chunks.proofs[idx], chunk = this.chunks.chunks[idx];
                    return {
                        data_root: this.data_root,
                        data_size: this.data_size,
                        data_path: ArweaveUtils.bufferTob64Url(proof.proof),
                        offset: proof.offset.toString(),
                        chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))
                    };
                }
                async getSignatureData() {
                    switch(this.format){
                        case 1:
                            let tags = this.tags.reduce((accumulator, tag)=>ArweaveUtils.concatBuffers([
                                    accumulator,
                                    tag.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag.get("value", {
                                        decode: !0,
                                        string: !1
                                    }), 
                                ]), new Uint8Array());
                            return ArweaveUtils.concatBuffers([
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("data", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils.stringToBuffer(this.quantity),
                                ArweaveUtils.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tags, 
                            ]);
                        case 2:
                            this.data_root || await this.prepareChunks(this.data);
                            const tagList = this.tags.map((tag)=>[
                                    tag.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag.get("value", {
                                        decode: !0,
                                        string: !1
                                    }), 
                                ]);
                            return await (0, deepHash_1.default)([
                                ArweaveUtils.stringToBuffer(this.format.toString()),
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils.stringToBuffer(this.quantity),
                                ArweaveUtils.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tagList,
                                ArweaveUtils.stringToBuffer(this.data_size),
                                this.get("data_root", {
                                    decode: !0,
                                    string: !1
                                }), 
                            ]);
                        default:
                            throw Error(`Unexpected transaction format: ${this.format}`);
                    }
                }
            }
            exports.default = Transaction;
        },
        8244: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.b64UrlDecode = exports.b64UrlEncode = exports.bufferTob64Url = exports.bufferTob64 = exports.b64UrlToBuffer = exports.stringToB64Url = exports.stringToBuffer = exports.bufferToString = exports.b64UrlToString = exports.concatBuffers = void 0;
            const B64js = __webpack_require__(9742);
            function concatBuffers(buffers) {
                let total_length = 0;
                for(let i = 0; i < buffers.length; i++)total_length += buffers[i].byteLength;
                let temp = new Uint8Array(total_length), offset = 0;
                temp.set(new Uint8Array(buffers[0]), offset), offset += buffers[0].byteLength;
                for(let i1 = 1; i1 < buffers.length; i1++)temp.set(new Uint8Array(buffers[i1]), offset), offset += buffers[i1].byteLength;
                return temp;
            }
            function b64UrlToString(b64UrlString) {
                let buffer = b64UrlToBuffer(b64UrlString);
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer);
            }
            function bufferToString(buffer) {
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer);
            }
            function stringToBuffer(string) {
                if ("undefined" == typeof TextEncoder) {
                    const TextEncoder1 = __webpack_require__(9539).TextEncoder;
                    return new TextEncoder1().encode(string);
                }
                return new TextEncoder().encode(string);
            }
            function stringToB64Url(string) {
                return bufferTob64Url(stringToBuffer(string));
            }
            function b64UrlToBuffer(b64UrlString) {
                return new Uint8Array(B64js.toByteArray(b64UrlDecode(b64UrlString)));
            }
            function bufferTob64(buffer) {
                return B64js.fromByteArray(new Uint8Array(buffer));
            }
            function bufferTob64Url(buffer) {
                return b64UrlEncode(bufferTob64(buffer));
            }
            function b64UrlEncode(b64UrlString) {
                return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
            }
            function b64UrlDecode(b64UrlString) {
                let padding;
                return padding = (b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - b64UrlString.length % 4, b64UrlString.concat("=".repeat(padding));
            }
            exports.concatBuffers = concatBuffers, exports.b64UrlToString = b64UrlToString, exports.bufferToString = bufferToString, exports.stringToBuffer = stringToBuffer, exports.stringToB64Url = stringToB64Url, exports.b64UrlToBuffer = b64UrlToBuffer, exports.bufferTob64 = bufferTob64, exports.bufferTob64Url = bufferTob64Url, exports.b64UrlEncode = b64UrlEncode, exports.b64UrlDecode = b64UrlDecode;
        },
        2248: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            class Network {
                constructor(api){
                    this.api = api;
                }
                getInfo() {
                    return this.api.get("info").then((response)=>response.data);
                }
                getPeers() {
                    return this.api.get("peers").then((response)=>response.data);
                }
            }
            exports.default = Network;
        },
        1243: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SiloResource = void 0;
            const ArweaveUtils = __webpack_require__(8244);
            class Silo {
                constructor(api, crypto1, transactions){
                    this.api = api, this.crypto = crypto1, this.transactions = transactions;
                }
                async get(siloURI) {
                    if (!siloURI) throw Error("No Silo URI specified");
                    const resource = await this.parseUri(siloURI), ids = await this.transactions.search("Silo-Name", resource.getAccessKey());
                    if (0 == ids.length) throw Error(`No data could be found for the Silo URI: ${siloURI}`);
                    const transaction = await this.transactions.get(ids[0]);
                    if (!transaction) throw Error(`No data could be found for the Silo URI: ${siloURI}`);
                    const encrypted = transaction.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
                }
                async readTransactionData(transaction, siloURI) {
                    if (!siloURI) throw Error("No Silo URI specified");
                    const resource = await this.parseUri(siloURI), encrypted = transaction.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
                }
                async parseUri(siloURI) {
                    const parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
                    if (!parsed) throw Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
                    const siloName = parsed[1], hashIterations = Math.pow(2, parseInt(parsed[2])), digest = await this.hash(ArweaveUtils.stringToBuffer(siloName), hashIterations), accessKey = ArweaveUtils.bufferTob64(digest.slice(0, 15)), encryptionkey = await this.hash(digest.slice(16, 31), 1);
                    return new SiloResource(siloURI, accessKey, encryptionkey);
                }
                async hash(input, iterations) {
                    let digest = await this.crypto.hash(input);
                    for(let count = 0; count < iterations - 1; count++)digest = await this.crypto.hash(digest);
                    return digest;
                }
            }
            exports.default = Silo;
            class SiloResource {
                constructor(uri, accessKey, encryptionKey){
                    this.uri = uri, this.accessKey = accessKey, this.encryptionKey = encryptionKey;
                }
                getUri() {
                    return this.uri;
                }
                getAccessKey() {
                    return this.accessKey;
                }
                getEncryptionKey() {
                    return this.encryptionKey;
                }
            }
            exports.SiloResource = SiloResource;
        },
        6935: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __await = this && this.__await || function(v) {
                return this instanceof __await ? (this.v = v, this) : new __await(v);
            }, __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var i, g = generator.apply(thisArg, _arguments || []), q = [];
                return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                    return this;
                }, i;
                function verb(n) {
                    g[n] && (i[n] = function(v) {
                        return new Promise(function(a, b) {
                            q.push([
                                n,
                                v,
                                a,
                                b
                            ]) > 1 || resume(n, v);
                        });
                    });
                }
                function resume(n, v) {
                    try {
                        step(g[n](v));
                    } catch (e) {
                        settle(q[0][3], e);
                    }
                }
                function step(r) {
                    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                }
                function fulfill(value) {
                    resume("next", value);
                }
                function reject(value) {
                    resume("throw", value);
                }
                function settle(f, v) {
                    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
                }
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const error_1 = __webpack_require__(5498), transaction_1 = __webpack_require__(7825), ArweaveUtils = __webpack_require__(8244), transaction_uploader_1 = __webpack_require__(1246);
            __webpack_require__(1317);
            class Transactions {
                constructor(api, crypto1, chunks){
                    this.api = api, this.crypto = crypto1, this.chunks = chunks;
                }
                getTransactionAnchor() {
                    return this.api.get("tx_anchor", {
                        transformResponse: []
                    }).then((response)=>response.data);
                }
                getPrice(byteSize, targetAddress) {
                    let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
                    return this.api.get(endpoint, {
                        transformResponse: [
                            function(data) {
                                return data;
                            }, 
                        ]
                    }).then((response)=>response.data);
                }
                async get(id) {
                    const response = await this.api.get(`tx/${id}`);
                    if (200 == response.status) {
                        const data_size = parseInt(response.data.data_size);
                        if (response.data.format >= 2 && data_size > 0 && data_size <= 12582912) {
                            const data = await this.getData(id);
                            return new transaction_1.default(Object.assign(Object.assign({}, response.data), {
                                data
                            }));
                        }
                        return new transaction_1.default(Object.assign(Object.assign({}, response.data), {
                            format: response.data.format || 1
                        }));
                    }
                    if (404 == response.status) throw new error_1.default("TX_NOT_FOUND");
                    if (410 == response.status) throw new error_1.default("TX_FAILED");
                    throw new error_1.default("TX_INVALID");
                }
                fromRaw(attributes) {
                    return new transaction_1.default(attributes);
                }
                async search(tagName, tagValue) {
                    return this.api.post("arql", {
                        op: "equals",
                        expr1: tagName,
                        expr2: tagValue
                    }).then((response)=>response.data ? response.data : []);
                }
                getStatus(id) {
                    return this.api.get(`tx/${id}/status`).then((response)=>200 == response.status ? {
                            status: 200,
                            confirmed: response.data
                        } : {
                            status: response.status,
                            confirmed: null
                        });
                }
                async getData(id, options) {
                    let data;
                    try {
                        data = await this.chunks.downloadChunkedData(id);
                    } catch (error) {
                        console.error(`Error while trying to download chunked data for ${id}`), console.error(error);
                    }
                    if (!data) {
                        console.warn(`Falling back to gateway cache for ${id}`);
                        try {
                            data = (await this.api.get(`/${id}`)).data;
                        } catch (error1) {
                            console.error(`Error while trying to download contiguous data from gateway cache for ${id}`), console.error(error1);
                        }
                    }
                    if (!data) throw Error(`${id} was not found!`);
                    return options && options.decode && !options.string ? data : options && options.decode && options.string ? ArweaveUtils.bufferToString(data) : ArweaveUtils.bufferTob64Url(data);
                }
                async sign(transaction, jwk, options) {
                    if (jwk || "undefined" != typeof window && window.arweaveWallet) {
                        if (jwk && "use_wallet" !== jwk) {
                            transaction.setOwner(jwk.n);
                            let rawSignature = await this.crypto.sign(jwk, await transaction.getSignatureData(), options), id = await this.crypto.hash(rawSignature);
                            transaction.setSignature({
                                id: ArweaveUtils.bufferTob64Url(id),
                                owner: jwk.n,
                                signature: ArweaveUtils.bufferTob64Url(rawSignature)
                            });
                        } else {
                            try {
                                const existingPermissions = await window.arweaveWallet.getPermissions();
                                existingPermissions.includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect([
                                    "SIGN_TRANSACTION"
                                ]);
                            } catch (_a) {}
                            const signedTransaction = await window.arweaveWallet.sign(transaction, options);
                            transaction.setSignature({
                                id: signedTransaction.id,
                                owner: signedTransaction.owner,
                                reward: signedTransaction.reward,
                                tags: signedTransaction.tags,
                                signature: signedTransaction.signature
                            });
                        }
                    } else throw Error("A new Arweave transaction must provide the jwk parameter.");
                }
                async verify(transaction) {
                    const signaturePayload = await transaction.getSignatureData(), rawSignature = transaction.get("signature", {
                        decode: !0,
                        string: !1
                    }), expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));
                    if (transaction.id !== expectedId) throw Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
                    return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);
                }
                async post(transaction) {
                    if ("string" == typeof transaction ? transaction = new transaction_1.default(JSON.parse(transaction)) : "function" == typeof transaction.readInt32BE ? transaction = new transaction_1.default(JSON.parse(transaction.toString())) : "object" != typeof transaction || transaction instanceof transaction_1.default || (transaction = new transaction_1.default(transaction)), !(transaction instanceof transaction_1.default)) throw Error("Must be Transaction object");
                    transaction.chunks || await transaction.prepareChunks(transaction.data);
                    const uploader = await this.getUploader(transaction, transaction.data);
                    try {
                        for(; !uploader.isComplete;)await uploader.uploadChunk();
                    } catch (e) {
                        if (uploader.lastResponseStatus > 0) return {
                            status: uploader.lastResponseStatus,
                            statusText: uploader.lastResponseError,
                            data: {
                                error: uploader.lastResponseError
                            }
                        };
                        throw e;
                    }
                    return {
                        status: 200,
                        statusText: "OK",
                        data: {}
                    };
                }
                async getUploader(upload, data) {
                    let uploader;
                    if (data instanceof ArrayBuffer && (data = new Uint8Array(data)), upload instanceof transaction_1.default) {
                        if (data || (data = upload.data), !(data instanceof Uint8Array)) throw Error("Data format is invalid");
                        upload.chunks || await upload.prepareChunks(data), (uploader = new transaction_uploader_1.TransactionUploader(this.api, upload)).data && 0 !== uploader.data.length || (uploader.data = data);
                    } else {
                        if ("string" == typeof upload && (upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload)), !data || !(data instanceof Uint8Array)) throw Error("Must provide data when resuming upload");
                        uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);
                    }
                    return uploader;
                }
                upload(upload, data) {
                    return __asyncGenerator(this, arguments, function*() {
                        const uploader = yield __await(this.getUploader(upload, data));
                        for(; !uploader.isComplete;)yield __await(uploader.uploadChunk()), yield yield __await(uploader);
                        return yield __await(uploader);
                    });
                }
            }
            exports.default = Transactions;
        },
        7927: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            const ArweaveUtils = __webpack_require__(8244);
            __webpack_require__(1317);
            class Wallets {
                constructor(api, crypto1){
                    this.api = api, this.crypto = crypto1;
                }
                getBalance(address) {
                    return this.api.get(`wallet/${address}/balance`, {
                        transformResponse: [
                            function(data) {
                                return data;
                            }, 
                        ]
                    }).then((response)=>response.data);
                }
                getLastTransactionID(address) {
                    return this.api.get(`wallet/${address}/last_tx`).then((response)=>response.data);
                }
                generate() {
                    return this.crypto.generateJWK();
                }
                async jwkToAddress(jwk) {
                    return jwk && "use_wallet" !== jwk ? this.getAddress(jwk) : this.getAddress();
                }
                async getAddress(jwk) {
                    if (jwk && "use_wallet" !== jwk) return this.ownerToAddress(jwk.n);
                    try {
                        await window.arweaveWallet.connect([
                            "ACCESS_ADDRESS"
                        ]);
                    } catch (_a) {}
                    return window.arweaveWallet.getActiveAddress();
                }
                async ownerToAddress(owner) {
                    return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));
                }
            }
            exports.default = Wallets;
        },
        9809: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const asn1 = exports;
            asn1.bignum = __webpack_require__(3550), asn1.define = __webpack_require__(2500).define, asn1.base = __webpack_require__(1979), asn1.constants = __webpack_require__(6826), asn1.decoders = __webpack_require__(8307), asn1.encoders = __webpack_require__(6579);
        },
        2500: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const encoders = __webpack_require__(6579), decoders = __webpack_require__(8307), inherits = __webpack_require__(5717), api = exports;
            function Entity(name, body) {
                this.name = name, this.body = body, this.decoders = {}, this.encoders = {};
            }
            api.define = function(name, body) {
                return new Entity(name, body);
            }, Entity.prototype._createNamed = function(Base) {
                const name = this.name;
                function Generated(entity) {
                    this._initNamed(entity, name);
                }
                return inherits(Generated, Base), Generated.prototype._initNamed = function(entity, name) {
                    Base.call(this, entity, name);
                }, new Generated(this);
            }, Entity.prototype._getDecoder = function(enc) {
                return enc = enc || 'der', this.decoders.hasOwnProperty(enc) || (this.decoders[enc] = this._createNamed(decoders[enc])), this.decoders[enc];
            }, Entity.prototype.decode = function(data, enc, options) {
                return this._getDecoder(enc).decode(data, options);
            }, Entity.prototype._getEncoder = function(enc) {
                return enc = enc || 'der', this.encoders.hasOwnProperty(enc) || (this.encoders[enc] = this._createNamed(encoders[enc])), this.encoders[enc];
            }, Entity.prototype.encode = function(data, enc, reporter) {
                return this._getEncoder(enc).encode(data, reporter);
            };
        },
        6625: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const inherits = __webpack_require__(5717), Reporter = __webpack_require__(8465).b, Buffer = __webpack_require__(2399).Buffer;
            function DecoderBuffer(base, options) {
                if (Reporter.call(this, options), !Buffer.isBuffer(base)) {
                    this.error('Input not Buffer');
                    return;
                }
                this.base = base, this.offset = 0, this.length = base.length;
            }
            function EncoderBuffer(value, reporter) {
                if (Array.isArray(value)) this.length = 0, this.value = value.map(function(item) {
                    return EncoderBuffer.isEncoderBuffer(item) || (item = new EncoderBuffer(item, reporter)), this.length += item.length, item;
                }, this);
                else if ('number' == typeof value) {
                    if (!(0 <= value && value <= 0xff)) return reporter.error('non-byte EncoderBuffer value');
                    this.value = value, this.length = 1;
                } else if ('string' == typeof value) this.value = value, this.length = Buffer.byteLength(value);
                else {
                    if (!Buffer.isBuffer(value)) return reporter.error('Unsupported type: ' + typeof value);
                    this.value = value, this.length = value.length;
                }
            }
            inherits(DecoderBuffer, Reporter), exports.C = DecoderBuffer, DecoderBuffer.isDecoderBuffer = function(data) {
                if (data instanceof DecoderBuffer) return !0;
                const isCompatible = 'object' == typeof data && Buffer.isBuffer(data.base) && 'DecoderBuffer' === data.constructor.name && 'number' == typeof data.offset && 'number' == typeof data.length && 'function' == typeof data.save && 'function' == typeof data.restore && 'function' == typeof data.isEmpty && 'function' == typeof data.readUInt8 && 'function' == typeof data.skip && 'function' == typeof data.raw;
                return isCompatible;
            }, DecoderBuffer.prototype.save = function() {
                return {
                    offset: this.offset,
                    reporter: Reporter.prototype.save.call(this)
                };
            }, DecoderBuffer.prototype.restore = function(save) {
                const res = new DecoderBuffer(this.base);
                return res.offset = save.offset, res.length = this.offset, this.offset = save.offset, Reporter.prototype.restore.call(this, save.reporter), res;
            }, DecoderBuffer.prototype.isEmpty = function() {
                return this.offset === this.length;
            }, DecoderBuffer.prototype.readUInt8 = function(fail) {
                return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(fail || 'DecoderBuffer overrun');
            }, DecoderBuffer.prototype.skip = function(bytes, fail) {
                if (!(this.offset + bytes <= this.length)) return this.error(fail || 'DecoderBuffer overrun');
                const res = new DecoderBuffer(this.base);
                return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;
            }, DecoderBuffer.prototype.raw = function(save) {
                return this.base.slice(save ? save.offset : this.offset, this.length);
            }, exports.R = EncoderBuffer, EncoderBuffer.isEncoderBuffer = function(data) {
                if (data instanceof EncoderBuffer) return !0;
                const isCompatible = 'object' == typeof data && 'EncoderBuffer' === data.constructor.name && 'number' == typeof data.length && 'function' == typeof data.join;
                return isCompatible;
            }, EncoderBuffer.prototype.join = function(out, offset) {
                return out || (out = Buffer.alloc(this.length)), offset || (offset = 0), 0 === this.length || (Array.isArray(this.value) ? this.value.forEach(function(item) {
                    item.join(out, offset), offset += item.length;
                }) : ('number' == typeof this.value ? out[offset] = this.value : 'string' == typeof this.value ? out.write(this.value, offset) : Buffer.isBuffer(this.value) && this.value.copy(out, offset), offset += this.length)), out;
            };
        },
        1979: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const base = exports;
            base.Reporter = __webpack_require__(8465).b, base.DecoderBuffer = __webpack_require__(6625).C, base.EncoderBuffer = __webpack_require__(6625).R, base.Node = __webpack_require__(1949);
        },
        1949: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const Reporter = __webpack_require__(8465).b, EncoderBuffer = __webpack_require__(6625).R, DecoderBuffer = __webpack_require__(6625).C, assert = __webpack_require__(9746), tags = [
                'seq',
                'seqof',
                'set',
                'setof',
                'objid',
                'bool',
                'gentime',
                'utctime',
                'null_',
                'enum',
                'int',
                'objDesc',
                'bitstr',
                'bmpstr',
                'charstr',
                'genstr',
                'graphstr',
                'ia5str',
                'iso646str',
                'numstr',
                'octstr',
                'printstr',
                't61str',
                'unistr',
                'utf8str',
                'videostr'
            ], methods = [
                'key',
                'obj',
                'use',
                'optional',
                'explicit',
                'implicit',
                'def',
                'choice',
                'any',
                'contains'
            ].concat(tags), overrided = [
                '_peekTag',
                '_decodeTag',
                '_use',
                '_decodeStr',
                '_decodeObjid',
                '_decodeTime',
                '_decodeNull',
                '_decodeInt',
                '_decodeBool',
                '_decodeList',
                '_encodeComposite',
                '_encodeStr',
                '_encodeObjid',
                '_encodeTime',
                '_encodeNull',
                '_encodeInt',
                '_encodeBool'
            ];
            function Node(enc, parent, name) {
                const state = {};
                this._baseState = state, state.name = name, state.enc = enc, state.parent = parent || null, state.children = null, state.tag = null, state.args = null, state.reverseArgs = null, state.choice = null, state.optional = !1, state.any = !1, state.obj = !1, state.use = null, state.useDecoder = null, state.key = null, state.default = null, state.explicit = null, state.implicit = null, state.contains = null, state.parent || (state.children = [], this._wrap());
            }
            module.exports = Node;
            const stateProps = [
                'enc',
                'parent',
                'children',
                'tag',
                'args',
                'reverseArgs',
                'choice',
                'optional',
                'any',
                'obj',
                'use',
                'alteredUse',
                'key',
                'default',
                'explicit',
                'implicit',
                'contains'
            ];
            Node.prototype.clone = function() {
                const state = this._baseState, cstate = {};
                stateProps.forEach(function(prop) {
                    cstate[prop] = state[prop];
                });
                const res = new this.constructor(cstate.parent);
                return res._baseState = cstate, res;
            }, Node.prototype._wrap = function() {
                const state = this._baseState;
                methods.forEach(function(method) {
                    this[method] = function() {
                        const clone = new this.constructor(this);
                        return state.children.push(clone), clone[method].apply(clone, arguments);
                    };
                }, this);
            }, Node.prototype._init = function(body) {
                const state = this._baseState;
                assert(null === state.parent), body.call(this), state.children = state.children.filter(function(child) {
                    return child._baseState.parent === this;
                }, this), assert.equal(state.children.length, 1, 'Root node can have only one child');
            }, Node.prototype._useArgs = function(args) {
                const state = this._baseState, children = args.filter(function(arg) {
                    return arg instanceof this.constructor;
                }, this);
                args = args.filter(function(arg) {
                    return !(arg instanceof this.constructor);
                }, this), 0 !== children.length && (assert(null === state.children), state.children = children, children.forEach(function(child) {
                    child._baseState.parent = this;
                }, this)), 0 !== args.length && (assert(null === state.args), state.args = args, state.reverseArgs = args.map(function(arg) {
                    if ('object' != typeof arg || arg.constructor !== Object) return arg;
                    const res = {};
                    return Object.keys(arg).forEach(function(key) {
                        key == (0 | key) && (key |= 0);
                        const value = arg[key];
                        res[value] = key;
                    }), res;
                }));
            }, overrided.forEach(function(method) {
                Node.prototype[method] = function() {
                    const state = this._baseState;
                    throw Error(method + ' not implemented for encoding: ' + state.enc);
                };
            }), tags.forEach(function(tag) {
                Node.prototype[tag] = function() {
                    const state = this._baseState, args = Array.prototype.slice.call(arguments);
                    return assert(null === state.tag), state.tag = tag, this._useArgs(args), this;
                };
            }), Node.prototype.use = function(item) {
                assert(item);
                const state = this._baseState;
                return assert(null === state.use), state.use = item, this;
            }, Node.prototype.optional = function() {
                const state = this._baseState;
                return state.optional = !0, this;
            }, Node.prototype.def = function(val) {
                const state = this._baseState;
                return assert(null === state.default), state.default = val, state.optional = !0, this;
            }, Node.prototype.explicit = function(num) {
                const state = this._baseState;
                return assert(null === state.explicit && null === state.implicit), state.explicit = num, this;
            }, Node.prototype.implicit = function(num) {
                const state = this._baseState;
                return assert(null === state.explicit && null === state.implicit), state.implicit = num, this;
            }, Node.prototype.obj = function() {
                const state = this._baseState, args = Array.prototype.slice.call(arguments);
                return state.obj = !0, 0 !== args.length && this._useArgs(args), this;
            }, Node.prototype.key = function(newKey) {
                const state = this._baseState;
                return assert(null === state.key), state.key = newKey, this;
            }, Node.prototype.any = function() {
                const state = this._baseState;
                return state.any = !0, this;
            }, Node.prototype.choice = function(obj) {
                const state = this._baseState;
                return assert(null === state.choice), state.choice = obj, this._useArgs(Object.keys(obj).map(function(key) {
                    return obj[key];
                })), this;
            }, Node.prototype.contains = function(item) {
                const state = this._baseState;
                return assert(null === state.use), state.contains = item, this;
            }, Node.prototype._decode = function(input, options) {
                const state = this._baseState;
                if (null === state.parent) return input.wrapResult(state.children[0]._decode(input, options));
                let result = state.default, present = !0, prevKey = null;
                if (null !== state.key && (prevKey = input.enterKey(state.key)), state.optional) {
                    let tag = null;
                    if (null !== state.explicit ? tag = state.explicit : null !== state.implicit ? tag = state.implicit : null !== state.tag && (tag = state.tag), null !== tag || state.any) {
                        if (present = this._peekTag(input, tag, state.any), input.isError(present)) return present;
                    } else {
                        const save = input.save();
                        try {
                            null === state.choice ? this._decodeGeneric(state.tag, input, options) : this._decodeChoice(input, options), present = !0;
                        } catch (e) {
                            present = !1;
                        }
                        input.restore(save);
                    }
                }
                let prevObj;
                if (state.obj && present && (prevObj = input.enterObject()), present) {
                    if (null !== state.explicit) {
                        const explicit = this._decodeTag(input, state.explicit);
                        if (input.isError(explicit)) return explicit;
                        input = explicit;
                    }
                    const start = input.offset;
                    if (null === state.use && null === state.choice) {
                        let save1;
                        state.any && (save1 = input.save());
                        const body = this._decodeTag(input, null !== state.implicit ? state.implicit : state.tag, state.any);
                        if (input.isError(body)) return body;
                        state.any ? result = input.raw(save1) : input = body;
                    }
                    if (options && options.track && null !== state.tag && options.track(input.path(), start, input.length, 'tagged'), options && options.track && null !== state.tag && options.track(input.path(), input.offset, input.length, 'content'), state.any || (result = null === state.choice ? this._decodeGeneric(state.tag, input, options) : this._decodeChoice(input, options)), input.isError(result)) return result;
                    if (state.any || null !== state.choice || null === state.children || state.children.forEach(function(child) {
                        child._decode(input, options);
                    }), state.contains && ('octstr' === state.tag || 'bitstr' === state.tag)) {
                        const data = new DecoderBuffer(result);
                        result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
                    }
                }
                return state.obj && present && (result = input.leaveObject(prevObj)), null !== state.key && (null !== result || !0 === present) ? input.leaveKey(prevKey, state.key, result) : null !== prevKey && input.exitKey(prevKey), result;
            }, Node.prototype._decodeGeneric = function(tag, input, options) {
                const state = this._baseState;
                return 'seq' === tag || 'set' === tag ? null : 'seqof' === tag || 'setof' === tag ? this._decodeList(input, tag, state.args[0], options) : /str$/.test(tag) ? this._decodeStr(input, tag, options) : 'objid' === tag && state.args ? this._decodeObjid(input, state.args[0], state.args[1], options) : 'objid' === tag ? this._decodeObjid(input, null, null, options) : 'gentime' === tag || 'utctime' === tag ? this._decodeTime(input, tag, options) : 'null_' === tag ? this._decodeNull(input, options) : 'bool' === tag ? this._decodeBool(input, options) : 'objDesc' === tag ? this._decodeStr(input, tag, options) : 'int' === tag || 'enum' === tag ? this._decodeInt(input, state.args && state.args[0], options) : null !== state.use ? this._getUse(state.use, input._reporterState.obj)._decode(input, options) : input.error('unknown tag: ' + tag);
            }, Node.prototype._getUse = function(entity, obj) {
                const state = this._baseState;
                return state.useDecoder = this._use(entity, obj), assert(null === state.useDecoder._baseState.parent), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit && (state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit), state.useDecoder;
            }, Node.prototype._decodeChoice = function(input, options) {
                const state = this._baseState;
                let result = null, match = !1;
                return (Object.keys(state.choice).some(function(key) {
                    const save = input.save(), node = state.choice[key];
                    try {
                        const value = node._decode(input, options);
                        if (input.isError(value)) return !1;
                        result = {
                            type: key,
                            value: value
                        }, match = !0;
                    } catch (e) {
                        return input.restore(save), !1;
                    }
                    return !0;
                }, this), match) ? result : input.error('Choice not matched');
            }, Node.prototype._createEncoderBuffer = function(data) {
                return new EncoderBuffer(data, this.reporter);
            }, Node.prototype._encode = function(data, reporter, parent) {
                const state = this._baseState;
                if (null !== state.default && state.default === data) return;
                const result = this._encodeValue(data, reporter, parent);
                if (void 0 !== result && !this._skipDefault(result, reporter, parent)) return result;
            }, Node.prototype._encodeValue = function(data, reporter, parent) {
                const state = this._baseState;
                if (null === state.parent) return state.children[0]._encode(data, reporter || new Reporter());
                let result = null;
                if (this.reporter = reporter, state.optional && void 0 === data) {
                    if (null === state.default) return;
                    data = state.default;
                }
                let content = null, primitive = !1;
                if (state.any) result = this._createEncoderBuffer(data);
                else if (state.choice) result = this._encodeChoice(data, reporter);
                else if (state.contains) content = this._getUse(state.contains, parent)._encode(data, reporter), primitive = !0;
                else if (state.children) content = state.children.map(function(child) {
                    if ('null_' === child._baseState.tag) return child._encode(null, reporter, data);
                    if (null === child._baseState.key) return reporter.error('Child should have a key');
                    const prevKey = reporter.enterKey(child._baseState.key);
                    if ('object' != typeof data) return reporter.error('Child expected, but input is not object');
                    const res = child._encode(data[child._baseState.key], reporter, data);
                    return reporter.leaveKey(prevKey), res;
                }, this).filter(function(child) {
                    return child;
                }), content = this._createEncoderBuffer(content);
                else if ('seqof' === state.tag || 'setof' === state.tag) {
                    if (!(state.args && 1 === state.args.length)) return reporter.error('Too many args for : ' + state.tag);
                    if (!Array.isArray(data)) return reporter.error('seqof/setof, but data is not Array');
                    const child = this.clone();
                    child._baseState.implicit = null, content = this._createEncoderBuffer(data.map(function(item) {
                        const state = this._baseState;
                        return this._getUse(state.args[0], data)._encode(item, reporter);
                    }, child));
                } else null !== state.use ? result = this._getUse(state.use, parent)._encode(data, reporter) : (content = this._encodePrimitive(state.tag, data), primitive = !0);
                if (!state.any && null === state.choice) {
                    const tag = null !== state.implicit ? state.implicit : state.tag, cls = null === state.implicit ? 'universal' : 'context';
                    null === tag ? null === state.use && reporter.error('Tag could be omitted only for .use()') : null === state.use && (result = this._encodeComposite(tag, primitive, cls, content));
                }
                return null !== state.explicit && (result = this._encodeComposite(state.explicit, !1, 'context', result)), result;
            }, Node.prototype._encodeChoice = function(data, reporter) {
                const state = this._baseState, node = state.choice[data.type];
                return node || assert(!1, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice))), node._encode(data.value, reporter);
            }, Node.prototype._encodePrimitive = function(tag, data) {
                const state = this._baseState;
                if (/str$/.test(tag)) return this._encodeStr(data, tag);
                if ('objid' === tag && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
                if ('objid' === tag) return this._encodeObjid(data, null, null);
                if ('gentime' === tag || 'utctime' === tag) return this._encodeTime(data, tag);
                if ('null_' === tag) return this._encodeNull();
                if ('int' === tag || 'enum' === tag) return this._encodeInt(data, state.args && state.reverseArgs[0]);
                if ('bool' === tag) return this._encodeBool(data);
                if ('objDesc' === tag) return this._encodeStr(data, tag);
                throw Error('Unsupported tag: ' + tag);
            }, Node.prototype._isNumstr = function(str) {
                return /^[0-9 ]*$/.test(str);
            }, Node.prototype._isPrintstr = function(str) {
                return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
            };
        },
        8465: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const inherits = __webpack_require__(5717);
            function Reporter(options) {
                this._reporterState = {
                    obj: null,
                    path: [],
                    options: options || {},
                    errors: []
                };
            }
            function ReporterError(path, msg) {
                this.path = path, this.rethrow(msg);
            }
            exports.b = Reporter, Reporter.prototype.isError = function(obj) {
                return obj instanceof ReporterError;
            }, Reporter.prototype.save = function() {
                const state = this._reporterState;
                return {
                    obj: state.obj,
                    pathLen: state.path.length
                };
            }, Reporter.prototype.restore = function(data) {
                const state = this._reporterState;
                state.obj = data.obj, state.path = state.path.slice(0, data.pathLen);
            }, Reporter.prototype.enterKey = function(key) {
                return this._reporterState.path.push(key);
            }, Reporter.prototype.exitKey = function(index) {
                const state = this._reporterState;
                state.path = state.path.slice(0, index - 1);
            }, Reporter.prototype.leaveKey = function(index, key, value) {
                const state = this._reporterState;
                this.exitKey(index), null !== state.obj && (state.obj[key] = value);
            }, Reporter.prototype.path = function() {
                return this._reporterState.path.join('/');
            }, Reporter.prototype.enterObject = function() {
                const state = this._reporterState, prev = state.obj;
                return state.obj = {}, prev;
            }, Reporter.prototype.leaveObject = function(prev) {
                const state = this._reporterState, now = state.obj;
                return state.obj = prev, now;
            }, Reporter.prototype.error = function(msg) {
                let err;
                const state = this._reporterState, inherited = msg instanceof ReporterError;
                if (err = inherited ? msg : new ReporterError(state.path.map(function(elem) {
                    return '[' + JSON.stringify(elem) + ']';
                }).join(''), msg.message || msg, msg.stack), !state.options.partial) throw err;
                return inherited || state.errors.push(err), err;
            }, Reporter.prototype.wrapResult = function(result) {
                const state = this._reporterState;
                return state.options.partial ? {
                    result: this.isError(result) ? null : result,
                    errors: state.errors
                } : result;
            }, inherits(ReporterError, Error), ReporterError.prototype.rethrow = function(msg) {
                if (this.message = msg + ' at: ' + (this.path || '(shallow)'), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack) try {
                    throw Error(this.message);
                } catch (e) {
                    this.stack = e.stack;
                }
                return this;
            };
        },
        160: function(__unused_webpack_module, exports) {
            "use strict";
            function reverse(map) {
                const res = {};
                return Object.keys(map).forEach(function(key) {
                    (0 | key) == key && (key |= 0);
                    const value = map[key];
                    res[value] = key;
                }), res;
            }
            exports.tagClass = {
                0: 'universal',
                1: 'application',
                2: 'context',
                3: 'private'
            }, exports.tagClassByName = reverse(exports.tagClass), exports.tag = {
                0x00: 'end',
                0x01: 'bool',
                0x02: 'int',
                0x03: 'bitstr',
                0x04: 'octstr',
                0x05: 'null_',
                0x06: 'objid',
                0x07: 'objDesc',
                0x08: 'external',
                0x09: 'real',
                0x0a: 'enum',
                0x0b: 'embed',
                0x0c: 'utf8str',
                0x0d: 'relativeOid',
                0x10: 'seq',
                0x11: 'set',
                0x12: 'numstr',
                0x13: 'printstr',
                0x14: 't61str',
                0x15: 'videostr',
                0x16: 'ia5str',
                0x17: 'utctime',
                0x18: 'gentime',
                0x19: 'graphstr',
                0x1a: 'iso646str',
                0x1b: 'genstr',
                0x1c: 'unistr',
                0x1d: 'charstr',
                0x1e: 'bmpstr'
            }, exports.tagByName = reverse(exports.tag);
        },
        6826: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const constants = exports;
            constants._reverse = function(map) {
                const res = {};
                return Object.keys(map).forEach(function(key) {
                    (0 | key) == key && (key |= 0);
                    const value = map[key];
                    res[value] = key;
                }), res;
            }, constants.der = __webpack_require__(160);
        },
        1671: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const inherits = __webpack_require__(5717), bignum = __webpack_require__(3550), DecoderBuffer = __webpack_require__(6625).C, Node = __webpack_require__(1949), der = __webpack_require__(160);
            function DERDecoder(entity) {
                this.enc = 'der', this.name = entity.name, this.entity = entity, this.tree = new DERNode(), this.tree._init(entity.body);
            }
            function DERNode(parent) {
                Node.call(this, 'der', parent);
            }
            function derDecodeTag(buf, fail) {
                let tag = buf.readUInt8(fail);
                if (buf.isError(tag)) return tag;
                const cls = der.tagClass[tag >> 6], primitive = (0x20 & tag) == 0;
                if ((0x1f & tag) == 0x1f) {
                    let oct = tag;
                    for(tag = 0; (0x80 & oct) == 0x80;){
                        if (oct = buf.readUInt8(fail), buf.isError(oct)) return oct;
                        tag <<= 7, tag |= 0x7f & oct;
                    }
                } else tag &= 0x1f;
                const tagStr = der.tag[tag];
                return {
                    cls: cls,
                    primitive: primitive,
                    tag: tag,
                    tagStr: tagStr
                };
            }
            function derDecodeLen(buf, primitive, fail) {
                let len = buf.readUInt8(fail);
                if (buf.isError(len)) return len;
                if (!primitive && 0x80 === len) return null;
                if ((0x80 & len) == 0) return len;
                const num = 0x7f & len;
                if (num > 4) return buf.error('length octect is too long');
                len = 0;
                for(let i = 0; i < num; i++){
                    len <<= 8;
                    const j = buf.readUInt8(fail);
                    if (buf.isError(j)) return j;
                    len |= j;
                }
                return len;
            }
            module.exports = DERDecoder, DERDecoder.prototype.decode = function(data, options) {
                return DecoderBuffer.isDecoderBuffer(data) || (data = new DecoderBuffer(data, options)), this.tree._decode(data, options);
            }, inherits(DERNode, Node), DERNode.prototype._peekTag = function(buffer, tag, any) {
                if (buffer.isEmpty()) return !1;
                const state = buffer.save(), decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
                return buffer.isError(decodedTag) ? decodedTag : (buffer.restore(state), decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + 'of' === tag || any);
            }, DERNode.prototype._decodeTag = function(buffer, tag, any) {
                const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
                if (buffer.isError(decodedTag)) return decodedTag;
                let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
                if (buffer.isError(len)) return len;
                if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) return buffer.error('Failed to match tag: "' + tag + '"');
                if (decodedTag.primitive || null !== len) return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
                const state = buffer.save(), res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
                return buffer.isError(res) ? res : (len = buffer.offset - state.offset, buffer.restore(state), buffer.skip(len, 'Failed to match body of: "' + tag + '"'));
            }, DERNode.prototype._skipUntilEnd = function(buffer, fail) {
                for(;;){
                    const tag = derDecodeTag(buffer, fail);
                    if (buffer.isError(tag)) return tag;
                    const len = derDecodeLen(buffer, tag.primitive, fail);
                    if (buffer.isError(len)) return len;
                    let res;
                    if (res = tag.primitive || null !== len ? buffer.skip(len) : this._skipUntilEnd(buffer, fail), buffer.isError(res)) return res;
                    if ('end' === tag.tagStr) break;
                }
            }, DERNode.prototype._decodeList = function(buffer, tag, decoder, options) {
                const result = [];
                for(; !buffer.isEmpty();){
                    const possibleEnd = this._peekTag(buffer, 'end');
                    if (buffer.isError(possibleEnd)) return possibleEnd;
                    const res = decoder.decode(buffer, 'der', options);
                    if (buffer.isError(res) && possibleEnd) break;
                    result.push(res);
                }
                return result;
            }, DERNode.prototype._decodeStr = function(buffer, tag) {
                if ('bitstr' === tag) {
                    const unused = buffer.readUInt8();
                    return buffer.isError(unused) ? unused : {
                        unused: unused,
                        data: buffer.raw()
                    };
                }
                if ('bmpstr' === tag) {
                    const raw = buffer.raw();
                    if (raw.length % 2 == 1) return buffer.error('Decoding of string type: bmpstr length mismatch');
                    let str = '';
                    for(let i = 0; i < raw.length / 2; i++)str += String.fromCharCode(raw.readUInt16BE(2 * i));
                    return str;
                }
                if ('numstr' === tag) {
                    const numstr = buffer.raw().toString('ascii');
                    return this._isNumstr(numstr) ? numstr : buffer.error("Decoding of string type: numstr unsupported characters");
                }
                if ('octstr' === tag || 'objDesc' === tag) return buffer.raw();
                if ('printstr' === tag) {
                    const printstr = buffer.raw().toString('ascii');
                    return this._isPrintstr(printstr) ? printstr : buffer.error("Decoding of string type: printstr unsupported characters");
                }
                return /str$/.test(tag) ? buffer.raw().toString() : buffer.error('Decoding of string type: ' + tag + ' unsupported');
            }, DERNode.prototype._decodeObjid = function(buffer, values, relative) {
                let result;
                const identifiers = [];
                let ident = 0, subident = 0;
                for(; !buffer.isEmpty();)subident = buffer.readUInt8(), ident <<= 7, ident |= 0x7f & subident, (0x80 & subident) == 0 && (identifiers.push(ident), ident = 0);
                0x80 & subident && identifiers.push(ident);
                const first = identifiers[0] / 40 | 0, second = identifiers[0] % 40;
                if (result = relative ? identifiers : [
                    first,
                    second
                ].concat(identifiers.slice(1)), values) {
                    let tmp = values[result.join(' ')];
                    void 0 === tmp && (tmp = values[result.join('.')]), void 0 !== tmp && (result = tmp);
                }
                return result;
            }, DERNode.prototype._decodeTime = function(buffer, tag) {
                const str = buffer.raw().toString();
                let year, mon, day, hour, min, sec;
                if ('gentime' === tag) year = 0 | str.slice(0, 4), mon = 0 | str.slice(4, 6), day = 0 | str.slice(6, 8), hour = 0 | str.slice(8, 10), min = 0 | str.slice(10, 12), sec = 0 | str.slice(12, 14);
                else {
                    if ('utctime' !== tag) return buffer.error('Decoding ' + tag + ' time is not supported yet');
                    year = 0 | str.slice(0, 2), mon = 0 | str.slice(2, 4), day = 0 | str.slice(4, 6), hour = 0 | str.slice(6, 8), min = 0 | str.slice(8, 10), sec = 0 | str.slice(10, 12), year = year < 70 ? 2000 + year : 1900 + year;
                }
                return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
            }, DERNode.prototype._decodeNull = function() {
                return null;
            }, DERNode.prototype._decodeBool = function(buffer) {
                const res = buffer.readUInt8();
                return buffer.isError(res) ? res : 0 !== res;
            }, DERNode.prototype._decodeInt = function(buffer, values) {
                const raw = buffer.raw();
                let res = new bignum(raw);
                return values && (res = values[res.toString(10)] || res), res;
            }, DERNode.prototype._use = function(entity, obj) {
                return 'function' == typeof entity && (entity = entity(obj)), entity._getDecoder('der').tree;
            };
        },
        8307: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const decoders = exports;
            decoders.der = __webpack_require__(1671), decoders.pem = __webpack_require__(9631);
        },
        9631: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const inherits = __webpack_require__(5717), Buffer = __webpack_require__(2399).Buffer, DERDecoder = __webpack_require__(1671);
            function PEMDecoder(entity) {
                DERDecoder.call(this, entity), this.enc = 'pem';
            }
            inherits(PEMDecoder, DERDecoder), module.exports = PEMDecoder, PEMDecoder.prototype.decode = function(data, options) {
                const lines = data.toString().split(/[\r\n]+/g), label = options.label.toUpperCase(), re = /^-----(BEGIN|END) ([^-]+)-----$/;
                let start = -1, end = -1;
                for(let i = 0; i < lines.length; i++){
                    const match = lines[i].match(re);
                    if (null !== match && match[2] === label) {
                        if (-1 === start) {
                            if ('BEGIN' !== match[1]) break;
                            start = i;
                        } else {
                            if ('END' !== match[1]) break;
                            end = i;
                            break;
                        }
                    }
                }
                if (-1 === start || -1 === end) throw Error('PEM section not found for: ' + label);
                const base64 = lines.slice(start + 1, end).join('');
                base64.replace(/[^a-z0-9+/=]+/gi, '');
                const input = Buffer.from(base64, 'base64');
                return DERDecoder.prototype.decode.call(this, input, options);
            };
        },
        6984: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const inherits = __webpack_require__(5717), Buffer = __webpack_require__(2399).Buffer, Node = __webpack_require__(1949), der = __webpack_require__(160);
            function DEREncoder(entity) {
                this.enc = 'der', this.name = entity.name, this.entity = entity, this.tree = new DERNode(), this.tree._init(entity.body);
            }
            function DERNode(parent) {
                Node.call(this, 'der', parent);
            }
            function two(num) {
                return num < 10 ? '0' + num : num;
            }
            function encodeTag(tag, primitive, cls, reporter) {
                let res;
                if ('seqof' === tag ? tag = 'seq' : 'setof' === tag && (tag = 'set'), der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];
                else {
                    if ('number' != typeof tag || (0 | tag) !== tag) return reporter.error('Unknown tag: ' + tag);
                    res = tag;
                }
                return res >= 0x1f ? reporter.error('Multi-octet tag encoding unsupported') : (primitive || (res |= 0x20), res |= der.tagClassByName[cls || 'universal'] << 6);
            }
            module.exports = DEREncoder, DEREncoder.prototype.encode = function(data, reporter) {
                return this.tree._encode(data, reporter).join();
            }, inherits(DERNode, Node), DERNode.prototype._encodeComposite = function(tag, primitive, cls, content) {
                const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
                if (content.length < 0x80) {
                    const header = Buffer.alloc(2);
                    return header[0] = encodedTag, header[1] = content.length, this._createEncoderBuffer([
                        header,
                        content
                    ]);
                }
                let lenOctets = 1;
                for(let i = content.length; i >= 0x100; i >>= 8)lenOctets++;
                const header1 = Buffer.alloc(2 + lenOctets);
                header1[0] = encodedTag, header1[1] = 0x80 | lenOctets;
                for(let i1 = 1 + lenOctets, j = content.length; j > 0; i1--, j >>= 8)header1[i1] = 0xff & j;
                return this._createEncoderBuffer([
                    header1,
                    content
                ]);
            }, DERNode.prototype._encodeStr = function(str, tag) {
                if ('bitstr' === tag) return this._createEncoderBuffer([
                    0 | str.unused,
                    str.data
                ]);
                if ('bmpstr' === tag) {
                    const buf = Buffer.alloc(2 * str.length);
                    for(let i = 0; i < str.length; i++)buf.writeUInt16BE(str.charCodeAt(i), 2 * i);
                    return this._createEncoderBuffer(buf);
                }
                return 'numstr' === tag ? this._isNumstr(str) ? this._createEncoderBuffer(str) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : 'printstr' === tag ? this._isPrintstr(str) ? this._createEncoderBuffer(str) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(tag) ? this._createEncoderBuffer(str) : 'objDesc' === tag ? this._createEncoderBuffer(str) : this.reporter.error('Encoding of string type: ' + tag + ' unsupported');
            }, DERNode.prototype._encodeObjid = function(id, values, relative) {
                if ('string' == typeof id) {
                    if (!values) return this.reporter.error('string objid given, but no values map found');
                    if (!values.hasOwnProperty(id)) return this.reporter.error('objid not found in values map');
                    id = values[id].split(/[\s.]+/g);
                    for(let i = 0; i < id.length; i++)id[i] |= 0;
                } else if (Array.isArray(id)) {
                    id = id.slice();
                    for(let i1 = 0; i1 < id.length; i1++)id[i1] |= 0;
                }
                if (!Array.isArray(id)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
                if (!relative) {
                    if (id[1] >= 40) return this.reporter.error('Second objid identifier OOB');
                    id.splice(0, 2, 40 * id[0] + id[1]);
                }
                let size = 0;
                for(let i2 = 0; i2 < id.length; i2++){
                    let ident = id[i2];
                    for(size++; ident >= 0x80; ident >>= 7)size++;
                }
                const objid = Buffer.alloc(size);
                let offset = objid.length - 1;
                for(let i3 = id.length - 1; i3 >= 0; i3--){
                    let ident1 = id[i3];
                    for(objid[offset--] = 0x7f & ident1; (ident1 >>= 7) > 0;)objid[offset--] = 0x80 | 0x7f & ident1;
                }
                return this._createEncoderBuffer(objid);
            }, DERNode.prototype._encodeTime = function(time, tag) {
                let str;
                const date = new Date(time);
                return 'gentime' === tag ? str = [
                    two(date.getUTCFullYear()),
                    two(date.getUTCMonth() + 1),
                    two(date.getUTCDate()),
                    two(date.getUTCHours()),
                    two(date.getUTCMinutes()),
                    two(date.getUTCSeconds()),
                    'Z'
                ].join('') : 'utctime' === tag ? str = [
                    two(date.getUTCFullYear() % 100),
                    two(date.getUTCMonth() + 1),
                    two(date.getUTCDate()),
                    two(date.getUTCHours()),
                    two(date.getUTCMinutes()),
                    two(date.getUTCSeconds()),
                    'Z'
                ].join('') : this.reporter.error('Encoding ' + tag + ' time is not supported yet'), this._encodeStr(str, 'octstr');
            }, DERNode.prototype._encodeNull = function() {
                return this._createEncoderBuffer('');
            }, DERNode.prototype._encodeInt = function(num, values) {
                if ('string' == typeof num) {
                    if (!values) return this.reporter.error('String int or enum given, but no values map');
                    if (!values.hasOwnProperty(num)) return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num));
                    num = values[num];
                }
                if ('number' != typeof num && !Buffer.isBuffer(num)) {
                    const numArray = num.toArray();
                    !num.sign && 0x80 & numArray[0] && numArray.unshift(0), num = Buffer.from(numArray);
                }
                if (Buffer.isBuffer(num)) {
                    let size = num.length;
                    0 === num.length && size++;
                    const out = Buffer.alloc(size);
                    return num.copy(out), 0 === num.length && (out[0] = 0), this._createEncoderBuffer(out);
                }
                if (num < 0x80) return this._createEncoderBuffer(num);
                if (num < 0x100) return this._createEncoderBuffer([
                    0,
                    num
                ]);
                let size1 = 1;
                for(let i = num; i >= 0x100; i >>= 8)size1++;
                const out1 = Array(size1);
                for(let i1 = out1.length - 1; i1 >= 0; i1--)out1[i1] = 0xff & num, num >>= 8;
                return 0x80 & out1[0] && out1.unshift(0), this._createEncoderBuffer(Buffer.from(out1));
            }, DERNode.prototype._encodeBool = function(value) {
                return this._createEncoderBuffer(value ? 0xff : 0);
            }, DERNode.prototype._use = function(entity, obj) {
                return 'function' == typeof entity && (entity = entity(obj)), entity._getEncoder('der').tree;
            }, DERNode.prototype._skipDefault = function(dataBuffer, reporter, parent) {
                const state = this._baseState;
                let i;
                if (null === state.default) return !1;
                const data = dataBuffer.join();
                if (void 0 === state.defaultBuffer && (state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join()), data.length !== state.defaultBuffer.length) return !1;
                for(i = 0; i < data.length; i++)if (data[i] !== state.defaultBuffer[i]) return !1;
                return !0;
            };
        },
        6579: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const encoders = exports;
            encoders.der = __webpack_require__(6984), encoders.pem = __webpack_require__(2883);
        },
        2883: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            const inherits = __webpack_require__(5717), DEREncoder = __webpack_require__(6984);
            function PEMEncoder(entity) {
                DEREncoder.call(this, entity), this.enc = 'pem';
            }
            inherits(PEMEncoder, DEREncoder), module.exports = PEMEncoder, PEMEncoder.prototype.encode = function(data, options) {
                const buf = DEREncoder.prototype.encode.call(this, data), p = buf.toString('base64'), out = [
                    '-----BEGIN ' + options.label + '-----'
                ];
                for(let i = 0; i < p.length; i += 64)out.push(p.slice(i, i + 64));
                return out.push('-----END ' + options.label + '-----'), out.join('\n');
            };
        },
        9669: function(module, __unused_webpack_exports, __webpack_require__) {
            module.exports = __webpack_require__(1609);
        },
        5448: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867), settle = __webpack_require__(6026), cookies = __webpack_require__(4372), buildURL = __webpack_require__(5327), buildFullPath = __webpack_require__(4097), parseHeaders = __webpack_require__(4109), isURLSameOrigin = __webpack_require__(7985), transitionalDefaults = __webpack_require__(7874), AxiosError = __webpack_require__(723), CanceledError = __webpack_require__(644), parseProtocol = __webpack_require__(205);
            module.exports = function(config) {
                return new Promise(function(resolve, reject) {
                    var onCanceled, requestData = config.data, requestHeaders = config.headers, responseType = config.responseType;
                    function done() {
                        config.cancelToken && config.cancelToken.unsubscribe(onCanceled), config.signal && config.signal.removeEventListener('abort', onCanceled);
                    }
                    utils.isFormData(requestData) && utils.isStandardBrowserEnv() && delete requestHeaders['Content-Type'];
                    var request = new XMLHttpRequest();
                    if (config.auth) {
                        var username = config.auth.username || '', password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
                        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
                    }
                    var fullPath = buildFullPath(config.baseURL, config.url);
                    function onloadend() {
                        if (request) {
                            var responseData, responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null, response = {
                                data: responseType && 'text' !== responseType && 'json' !== responseType ? request.response : request.responseText,
                                status: request.status,
                                statusText: request.statusText,
                                headers: responseHeaders,
                                config: config,
                                request: request
                            };
                            settle(function(value) {
                                resolve(value), done();
                            }, function(err) {
                                reject(err), done();
                            }, response), request = null;
                        }
                    }
                    if (request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), !0), request.timeout = config.timeout, 'onloadend' in request ? request.onloadend = onloadend : request.onreadystatechange = function() {
                        request && 4 === request.readyState && (0 !== request.status || request.responseURL && 0 === request.responseURL.indexOf('file:')) && setTimeout(onloadend);
                    }, request.onabort = function() {
                        request && (reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request)), request = null);
                    }, request.onerror = function() {
                        reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request)), request = null;
                    }, request.ontimeout = function() {
                        var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded', transitional = config.transitional || transitionalDefaults;
                        config.timeoutErrorMessage && (timeoutErrorMessage = config.timeoutErrorMessage), reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request)), request = null;
                    }, utils.isStandardBrowserEnv()) {
                        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
                        xsrfValue && (requestHeaders[config.xsrfHeaderName] = xsrfValue);
                    }
                    'setRequestHeader' in request && utils.forEach(requestHeaders, function(val, key) {
                        void 0 === requestData && 'content-type' === key.toLowerCase() ? delete requestHeaders[key] : request.setRequestHeader(key, val);
                    }), utils.isUndefined(config.withCredentials) || (request.withCredentials = !!config.withCredentials), responseType && 'json' !== responseType && (request.responseType = config.responseType), 'function' == typeof config.onDownloadProgress && request.addEventListener('progress', config.onDownloadProgress), 'function' == typeof config.onUploadProgress && request.upload && request.upload.addEventListener('progress', config.onUploadProgress), (config.cancelToken || config.signal) && (onCanceled = function(cancel) {
                        request && (reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel), request.abort(), request = null);
                    }, config.cancelToken && config.cancelToken.subscribe(onCanceled), config.signal && (config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled))), requestData || (requestData = null);
                    var protocol = parseProtocol(fullPath);
                    if (protocol && -1 === [
                        'http',
                        'https',
                        'file'
                    ].indexOf(protocol)) {
                        reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
                        return;
                    }
                    request.send(requestData);
                });
            };
        },
        1609: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867), bind = __webpack_require__(1849), Axios = __webpack_require__(321), mergeConfig = __webpack_require__(7185), defaults = __webpack_require__(5546);
            function createInstance(defaultConfig) {
                var context = new Axios(defaultConfig), instance = bind(Axios.prototype.request, context);
                return utils.extend(instance, Axios.prototype, context), utils.extend(instance, context), instance.create = function(instanceConfig) {
                    return createInstance(mergeConfig(defaultConfig, instanceConfig));
                }, instance;
            }
            var axios = createInstance(defaults);
            axios.Axios = Axios, axios.CanceledError = __webpack_require__(644), axios.CancelToken = __webpack_require__(4972), axios.isCancel = __webpack_require__(6502), axios.VERSION = __webpack_require__(7288).version, axios.toFormData = __webpack_require__(7675), axios.AxiosError = __webpack_require__(723), axios.Cancel = axios.CanceledError, axios.all = function(promises) {
                return Promise.all(promises);
            }, axios.spread = __webpack_require__(8713), axios.isAxiosError = __webpack_require__(6268), module.exports = axios, module.exports.default = axios;
        },
        4972: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var CanceledError = __webpack_require__(644);
            function CancelToken(executor) {
                if ('function' != typeof executor) throw TypeError('executor must be a function.');
                this.promise = new Promise(function(resolve) {
                    resolvePromise = resolve;
                });
                var resolvePromise, token = this;
                this.promise.then(function(cancel) {
                    if (token._listeners) {
                        var i, l = token._listeners.length;
                        for(i = 0; i < l; i++)token._listeners[i](cancel);
                        token._listeners = null;
                    }
                }), this.promise.then = function(onfulfilled) {
                    var _resolve, promise = new Promise(function(resolve) {
                        token.subscribe(resolve), _resolve = resolve;
                    }).then(onfulfilled);
                    return promise.cancel = function() {
                        token.unsubscribe(_resolve);
                    }, promise;
                }, executor(function(message) {
                    token.reason || (token.reason = new CanceledError(message), resolvePromise(token.reason));
                });
            }
            CancelToken.prototype.throwIfRequested = function() {
                if (this.reason) throw this.reason;
            }, CancelToken.prototype.subscribe = function(listener) {
                if (this.reason) {
                    listener(this.reason);
                    return;
                }
                this._listeners ? this._listeners.push(listener) : this._listeners = [
                    listener
                ];
            }, CancelToken.prototype.unsubscribe = function(listener) {
                if (this._listeners) {
                    var index = this._listeners.indexOf(listener);
                    -1 !== index && this._listeners.splice(index, 1);
                }
            }, CancelToken.source = function() {
                var cancel;
                return {
                    token: new CancelToken(function(c) {
                        cancel = c;
                    }),
                    cancel: cancel
                };
            }, module.exports = CancelToken;
        },
        644: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var AxiosError = __webpack_require__(723), utils = __webpack_require__(4867);
            function CanceledError(message) {
                AxiosError.call(this, null == message ? 'canceled' : message, AxiosError.ERR_CANCELED), this.name = 'CanceledError';
            }
            utils.inherits(CanceledError, AxiosError, {
                __CANCEL__: !0
            }), module.exports = CanceledError;
        },
        6502: function(module) {
            "use strict";
            module.exports = function(value) {
                return !!(value && value.__CANCEL__);
            };
        },
        321: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867), buildURL = __webpack_require__(5327), InterceptorManager = __webpack_require__(782), dispatchRequest = __webpack_require__(3572), mergeConfig = __webpack_require__(7185), buildFullPath = __webpack_require__(4097), validator = __webpack_require__(4875), validators = validator.validators;
            function Axios(instanceConfig) {
                this.defaults = instanceConfig, this.interceptors = {
                    request: new InterceptorManager(),
                    response: new InterceptorManager()
                };
            }
            Axios.prototype.request = function(configOrUrl, config) {
                'string' == typeof configOrUrl ? (config = config || {}).url = configOrUrl : config = configOrUrl || {}, (config = mergeConfig(this.defaults, config)).method ? config.method = config.method.toLowerCase() : this.defaults.method ? config.method = this.defaults.method.toLowerCase() : config.method = 'get';
                var promise, transitional = config.transitional;
                void 0 !== transitional && validator.assertOptions(transitional, {
                    silentJSONParsing: validators.transitional(validators.boolean),
                    forcedJSONParsing: validators.transitional(validators.boolean),
                    clarifyTimeoutError: validators.transitional(validators.boolean)
                }, !1);
                var requestInterceptorChain = [], synchronousRequestInterceptors = !0;
                this.interceptors.request.forEach(function(interceptor) {
                    ('function' != typeof interceptor.runWhen || !1 !== interceptor.runWhen(config)) && (synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous, requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected));
                });
                var responseInterceptorChain = [];
                if (this.interceptors.response.forEach(function(interceptor) {
                    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
                }), !synchronousRequestInterceptors) {
                    var chain = [
                        dispatchRequest,
                        void 0
                    ];
                    for(Array.prototype.unshift.apply(chain, requestInterceptorChain), chain = chain.concat(responseInterceptorChain), promise = Promise.resolve(config); chain.length;)promise = promise.then(chain.shift(), chain.shift());
                    return promise;
                }
                for(var newConfig = config; requestInterceptorChain.length;){
                    var onFulfilled = requestInterceptorChain.shift(), onRejected = requestInterceptorChain.shift();
                    try {
                        newConfig = onFulfilled(newConfig);
                    } catch (error) {
                        onRejected(error);
                        break;
                    }
                }
                try {
                    promise = dispatchRequest(newConfig);
                } catch (error1) {
                    return Promise.reject(error1);
                }
                for(; responseInterceptorChain.length;)promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
                return promise;
            }, Axios.prototype.getUri = function(config) {
                config = mergeConfig(this.defaults, config);
                var fullPath = buildFullPath(config.baseURL, config.url);
                return buildURL(fullPath, config.params, config.paramsSerializer);
            }, utils.forEach([
                'delete',
                'get',
                'head',
                'options'
            ], function(method) {
                Axios.prototype[method] = function(url, config) {
                    return this.request(mergeConfig(config || {}, {
                        method: method,
                        url: url,
                        data: (config || {}).data
                    }));
                };
            }), utils.forEach([
                'post',
                'put',
                'patch'
            ], function(method) {
                function generateHTTPMethod(isForm) {
                    return function(url, data, config) {
                        return this.request(mergeConfig(config || {}, {
                            method: method,
                            headers: isForm ? {
                                'Content-Type': 'multipart/form-data'
                            } : {},
                            url: url,
                            data: data
                        }));
                    };
                }
                Axios.prototype[method] = generateHTTPMethod(), Axios.prototype[method + 'Form'] = generateHTTPMethod(!0);
            }), module.exports = Axios;
        },
        723: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            function AxiosError(message, code, config, request, response) {
                Error.call(this), this.message = message, this.name = 'AxiosError', code && (this.code = code), config && (this.config = config), request && (this.request = request), response && (this.response = response);
            }
            utils.inherits(AxiosError, Error, {
                toJSON: function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: this.config,
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    };
                }
            });
            var prototype = AxiosError.prototype, descriptors = {};
            [
                'ERR_BAD_OPTION_VALUE',
                'ERR_BAD_OPTION',
                'ECONNABORTED',
                'ETIMEDOUT',
                'ERR_NETWORK',
                'ERR_FR_TOO_MANY_REDIRECTS',
                'ERR_DEPRECATED',
                'ERR_BAD_RESPONSE',
                'ERR_BAD_REQUEST',
                'ERR_CANCELED'
            ].forEach(function(code) {
                descriptors[code] = {
                    value: code
                };
            }), Object.defineProperties(AxiosError, descriptors), Object.defineProperty(prototype, 'isAxiosError', {
                value: !0
            }), AxiosError.from = function(error, code, config, request, response, customProps) {
                var axiosError = Object.create(prototype);
                return utils.toFlatObject(error, axiosError, function(obj) {
                    return obj !== Error.prototype;
                }), AxiosError.call(axiosError, error.message, code, config, request, response), axiosError.name = error.name, customProps && Object.assign(axiosError, customProps), axiosError;
            }, module.exports = AxiosError;
        },
        782: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            function InterceptorManager() {
                this.handlers = [];
            }
            InterceptorManager.prototype.use = function(fulfilled, rejected, options) {
                return this.handlers.push({
                    fulfilled: fulfilled,
                    rejected: rejected,
                    synchronous: !!options && options.synchronous,
                    runWhen: options ? options.runWhen : null
                }), this.handlers.length - 1;
            }, InterceptorManager.prototype.eject = function(id) {
                this.handlers[id] && (this.handlers[id] = null);
            }, InterceptorManager.prototype.forEach = function(fn) {
                utils.forEach(this.handlers, function(h) {
                    null !== h && fn(h);
                });
            }, module.exports = InterceptorManager;
        },
        4097: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var isAbsoluteURL = __webpack_require__(1793), combineURLs = __webpack_require__(7303);
            module.exports = function(baseURL, requestedURL) {
                return baseURL && !isAbsoluteURL(requestedURL) ? combineURLs(baseURL, requestedURL) : requestedURL;
            };
        },
        3572: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867), transformData = __webpack_require__(8527), isCancel = __webpack_require__(6502), defaults = __webpack_require__(5546), CanceledError = __webpack_require__(644);
            function throwIfCancellationRequested(config) {
                if (config.cancelToken && config.cancelToken.throwIfRequested(), config.signal && config.signal.aborted) throw new CanceledError();
            }
            module.exports = function(config) {
                return throwIfCancellationRequested(config), config.headers = config.headers || {}, config.data = transformData.call(config, config.data, config.headers, config.transformRequest), config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers), utils.forEach([
                    'delete',
                    'get',
                    'head',
                    'post',
                    'put',
                    'patch',
                    'common'
                ], function(method) {
                    delete config.headers[method];
                }), (config.adapter || defaults.adapter)(config).then(function(response) {
                    return throwIfCancellationRequested(config), response.data = transformData.call(config, response.data, response.headers, config.transformResponse), response;
                }, function(reason) {
                    return !isCancel(reason) && (throwIfCancellationRequested(config), reason && reason.response && (reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse))), Promise.reject(reason);
                });
            };
        },
        7185: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            module.exports = function(config1, config2) {
                config2 = config2 || {};
                var config = {};
                function getMergedValue(target, source) {
                    return utils.isPlainObject(target) && utils.isPlainObject(source) ? utils.merge(target, source) : utils.isPlainObject(source) ? utils.merge({}, source) : utils.isArray(source) ? source.slice() : source;
                }
                function mergeDeepProperties(prop) {
                    return utils.isUndefined(config2[prop]) ? utils.isUndefined(config1[prop]) ? void 0 : getMergedValue(void 0, config1[prop]) : getMergedValue(config1[prop], config2[prop]);
                }
                function valueFromConfig2(prop) {
                    if (!utils.isUndefined(config2[prop])) return getMergedValue(void 0, config2[prop]);
                }
                function defaultToConfig2(prop) {
                    return utils.isUndefined(config2[prop]) ? utils.isUndefined(config1[prop]) ? void 0 : getMergedValue(void 0, config1[prop]) : getMergedValue(void 0, config2[prop]);
                }
                function mergeDirectKeys(prop) {
                    return prop in config2 ? getMergedValue(config1[prop], config2[prop]) : prop in config1 ? getMergedValue(void 0, config1[prop]) : void 0;
                }
                var mergeMap = {
                    url: valueFromConfig2,
                    method: valueFromConfig2,
                    data: valueFromConfig2,
                    baseURL: defaultToConfig2,
                    transformRequest: defaultToConfig2,
                    transformResponse: defaultToConfig2,
                    paramsSerializer: defaultToConfig2,
                    timeout: defaultToConfig2,
                    timeoutMessage: defaultToConfig2,
                    withCredentials: defaultToConfig2,
                    adapter: defaultToConfig2,
                    responseType: defaultToConfig2,
                    xsrfCookieName: defaultToConfig2,
                    xsrfHeaderName: defaultToConfig2,
                    onUploadProgress: defaultToConfig2,
                    onDownloadProgress: defaultToConfig2,
                    decompress: defaultToConfig2,
                    maxContentLength: defaultToConfig2,
                    maxBodyLength: defaultToConfig2,
                    beforeRedirect: defaultToConfig2,
                    transport: defaultToConfig2,
                    httpAgent: defaultToConfig2,
                    httpsAgent: defaultToConfig2,
                    cancelToken: defaultToConfig2,
                    socketPath: defaultToConfig2,
                    responseEncoding: defaultToConfig2,
                    validateStatus: mergeDirectKeys
                };
                return utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function(prop) {
                    var merge = mergeMap[prop] || mergeDeepProperties, configValue = merge(prop);
                    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
                }), config;
            };
        },
        6026: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var AxiosError = __webpack_require__(723);
            module.exports = function(resolve, reject, response) {
                var validateStatus = response.config.validateStatus;
                !response.status || !validateStatus || validateStatus(response.status) ? resolve(response) : reject(new AxiosError('Request failed with status code ' + response.status, [
                    AxiosError.ERR_BAD_REQUEST,
                    AxiosError.ERR_BAD_RESPONSE
                ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
            };
        },
        8527: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867), defaults = __webpack_require__(5546);
            module.exports = function(data, headers, fns) {
                var context = this || defaults;
                return utils.forEach(fns, function(fn) {
                    data = fn.call(context, data, headers);
                }), data;
            };
        },
        5546: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var process = __webpack_require__(3454), utils = __webpack_require__(4867), normalizeHeaderName = __webpack_require__(6016), AxiosError = __webpack_require__(723), transitionalDefaults = __webpack_require__(7874), toFormData = __webpack_require__(7675), DEFAULT_CONTENT_TYPE = {
                'Content-Type': 'application/x-www-form-urlencoded'
            };
            function setContentTypeIfUnset(headers, value) {
                !utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type']) && (headers['Content-Type'] = value);
            }
            function getDefaultAdapter() {
                var adapter;
                return 'undefined' != typeof XMLHttpRequest ? adapter = __webpack_require__(5448) : void 0 !== process && '[object process]' === Object.prototype.toString.call(process) && (adapter = __webpack_require__(5448)), adapter;
            }
            function stringifySafely(rawValue, parser, encoder) {
                if (utils.isString(rawValue)) try {
                    return (parser || JSON.parse)(rawValue), utils.trim(rawValue);
                } catch (e) {
                    if ('SyntaxError' !== e.name) throw e;
                }
                return (encoder || JSON.stringify)(rawValue);
            }
            var defaults = {
                transitional: transitionalDefaults,
                adapter: getDefaultAdapter(),
                transformRequest: [
                    function(data, headers) {
                        if (normalizeHeaderName(headers, 'Accept'), normalizeHeaderName(headers, 'Content-Type'), utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) return data;
                        if (utils.isArrayBufferView(data)) return data.buffer;
                        if (utils.isURLSearchParams(data)) return setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'), data.toString();
                        var isFileList, isObjectPayload = utils.isObject(data), contentType = headers && headers['Content-Type'];
                        if ((isFileList = utils.isFileList(data)) || isObjectPayload && 'multipart/form-data' === contentType) {
                            var _FormData = this.env && this.env.FormData;
                            return toFormData(isFileList ? {
                                'files[]': data
                            } : data, _FormData && new _FormData());
                        }
                        return isObjectPayload || 'application/json' === contentType ? (setContentTypeIfUnset(headers, 'application/json'), stringifySafely(data)) : data;
                    }
                ],
                transformResponse: [
                    function(data) {
                        var transitional = this.transitional || defaults.transitional, silentJSONParsing = transitional && transitional.silentJSONParsing, forcedJSONParsing = transitional && transitional.forcedJSONParsing, strictJSONParsing = !silentJSONParsing && 'json' === this.responseType;
                        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) try {
                            return JSON.parse(data);
                        } catch (e) {
                            if (strictJSONParsing) {
                                if ('SyntaxError' === e.name) throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                                throw e;
                            }
                        }
                        return data;
                    }
                ],
                timeout: 0,
                xsrfCookieName: 'XSRF-TOKEN',
                xsrfHeaderName: 'X-XSRF-TOKEN',
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: __webpack_require__(1623)
                },
                validateStatus: function(status) {
                    return status >= 200 && status < 300;
                },
                headers: {
                    common: {
                        Accept: 'application/json, text/plain, */*'
                    }
                }
            };
            utils.forEach([
                'delete',
                'get',
                'head'
            ], function(method) {
                defaults.headers[method] = {};
            }), utils.forEach([
                'post',
                'put',
                'patch'
            ], function(method) {
                defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
            }), module.exports = defaults;
        },
        7874: function(module) {
            "use strict";
            module.exports = {
                silentJSONParsing: !0,
                forcedJSONParsing: !0,
                clarifyTimeoutError: !1
            };
        },
        7288: function(module) {
            module.exports = {
                version: "0.27.2"
            };
        },
        1849: function(module) {
            "use strict";
            module.exports = function(fn, thisArg) {
                return function() {
                    for(var args = Array(arguments.length), i = 0; i < args.length; i++)args[i] = arguments[i];
                    return fn.apply(thisArg, args);
                };
            };
        },
        5327: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            function encode(val) {
                return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
            }
            module.exports = function(url, params, paramsSerializer) {
                if (!params) return url;
                if (paramsSerializer) serializedParams = paramsSerializer(params);
                else if (utils.isURLSearchParams(params)) serializedParams = params.toString();
                else {
                    var serializedParams, parts = [];
                    utils.forEach(params, function(val, key) {
                        null != val && (utils.isArray(val) ? key += '[]' : val = [
                            val
                        ], utils.forEach(val, function(v) {
                            utils.isDate(v) ? v = v.toISOString() : utils.isObject(v) && (v = JSON.stringify(v)), parts.push(encode(key) + '=' + encode(v));
                        }));
                    }), serializedParams = parts.join('&');
                }
                if (serializedParams) {
                    var hashmarkIndex = url.indexOf('#');
                    -1 !== hashmarkIndex && (url = url.slice(0, hashmarkIndex)), url += (-1 === url.indexOf('?') ? '?' : '&') + serializedParams;
                }
                return url;
            };
        },
        7303: function(module) {
            "use strict";
            module.exports = function(baseURL, relativeURL) {
                return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
            };
        },
        4372: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            module.exports = utils.isStandardBrowserEnv() ? {
                write: function(name, value, expires, path, domain, secure) {
                    var cookie = [];
                    cookie.push(name + '=' + encodeURIComponent(value)), utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString()), utils.isString(path) && cookie.push('path=' + path), utils.isString(domain) && cookie.push('domain=' + domain), !0 === secure && cookie.push('secure'), document.cookie = cookie.join('; ');
                },
                read: function(name) {
                    var match = document.cookie.match(RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
                    return match ? decodeURIComponent(match[3]) : null;
                },
                remove: function(name) {
                    this.write(name, '', Date.now() - 86400000);
                }
            } : {
                write: function() {},
                read: function() {
                    return null;
                },
                remove: function() {}
            };
        },
        1793: function(module) {
            "use strict";
            module.exports = function(url) {
                return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
            };
        },
        6268: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            module.exports = function(payload) {
                return utils.isObject(payload) && !0 === payload.isAxiosError;
            };
        },
        7985: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            module.exports = utils.isStandardBrowserEnv() ? function() {
                var originURL, msie = /(msie|trident)/i.test(navigator.userAgent), urlParsingNode = document.createElement('a');
                function resolveURL(url) {
                    var href = url;
                    return msie && (urlParsingNode.setAttribute('href', href), href = urlParsingNode.href), urlParsingNode.setAttribute('href', href), {
                        href: urlParsingNode.href,
                        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                        host: urlParsingNode.host,
                        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                        hostname: urlParsingNode.hostname,
                        port: urlParsingNode.port,
                        pathname: '/' === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
                    };
                }
                return originURL = resolveURL(window.location.href), function(requestURL) {
                    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
                    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
                };
            }() : function() {
                return !0;
            };
        },
        6016: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867);
            module.exports = function(headers, normalizedName) {
                utils.forEach(headers, function(value, name) {
                    name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase() && (headers[normalizedName] = value, delete headers[name]);
                });
            };
        },
        1623: function(module) {
            module.exports = null;
        },
        4109: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(4867), ignoreDuplicateOf = [
                'age',
                'authorization',
                'content-length',
                'content-type',
                'etag',
                'expires',
                'from',
                'host',
                'if-modified-since',
                'if-unmodified-since',
                'last-modified',
                'location',
                'max-forwards',
                'proxy-authorization',
                'referer',
                'retry-after',
                'user-agent'
            ];
            module.exports = function(headers) {
                var key, val, i, parsed = {};
                return headers && utils.forEach(headers.split('\n'), function(line) {
                    i = line.indexOf(':'), key = utils.trim(line.substr(0, i)).toLowerCase(), val = utils.trim(line.substr(i + 1)), key && !(parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) && ('set-cookie' === key ? parsed[key] = (parsed[key] ? parsed[key] : []).concat([
                        val
                    ]) : parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val);
                }), parsed;
            };
        },
        205: function(module) {
            "use strict";
            module.exports = function(url) {
                var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
                return match && match[1] || '';
            };
        },
        8713: function(module) {
            "use strict";
            module.exports = function(callback) {
                return function(arr) {
                    return callback.apply(null, arr);
                };
            };
        },
        7675: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(8764).Buffer, utils = __webpack_require__(4867);
            function toFormData(obj, formData) {
                formData = formData || new FormData();
                var stack = [];
                function convertValue(value) {
                    return null === value ? '' : utils.isDate(value) ? value.toISOString() : utils.isArrayBuffer(value) || utils.isTypedArray(value) ? 'function' == typeof Blob ? new Blob([
                        value
                    ]) : Buffer.from(value) : value;
                }
                function build(data, parentKey) {
                    if (utils.isPlainObject(data) || utils.isArray(data)) {
                        if (-1 !== stack.indexOf(data)) throw Error('Circular reference detected in ' + parentKey);
                        stack.push(data), utils.forEach(data, function(value, key) {
                            if (!utils.isUndefined(value)) {
                                var arr, fullKey = parentKey ? parentKey + '.' + key : key;
                                if (value && !parentKey && 'object' == typeof value) {
                                    if (utils.endsWith(key, '{}')) value = JSON.stringify(value);
                                    else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
                                        arr.forEach(function(el) {
                                            utils.isUndefined(el) || formData.append(fullKey, convertValue(el));
                                        });
                                        return;
                                    }
                                }
                                build(value, fullKey);
                            }
                        }), stack.pop();
                    } else formData.append(parentKey, convertValue(data));
                }
                return build(obj), formData;
            }
            module.exports = toFormData;
        },
        4875: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var VERSION = __webpack_require__(7288).version, AxiosError = __webpack_require__(723), validators = {};
            [
                'object',
                'boolean',
                'number',
                'function',
                'string',
                'symbol'
            ].forEach(function(type, i) {
                validators[type] = function(thing) {
                    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
                };
            });
            var deprecatedWarnings = {};
            function assertOptions(options, schema, allowUnknown) {
                if ('object' != typeof options) throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
                for(var keys = Object.keys(options), i = keys.length; i-- > 0;){
                    var opt = keys[i], validator = schema[opt];
                    if (validator) {
                        var value = options[opt], result = void 0 === value || validator(value, opt, options);
                        if (!0 !== result) throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
                        continue;
                    }
                    if (!0 !== allowUnknown) throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
                }
            }
            validators.transitional = function(validator, version, message) {
                function formatMessage(opt, desc) {
                    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
                }
                return function(value, opt, opts) {
                    if (!1 === validator) throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
                    return version && !deprecatedWarnings[opt] && (deprecatedWarnings[opt] = !0, console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'))), !validator || validator(value, opt, opts);
                };
            }, module.exports = {
                assertOptions: assertOptions,
                validators: validators
            };
        },
        4867: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var cache, bind = __webpack_require__(1849), toString1 = Object.prototype.toString, kindOf = (cache = Object.create(null), function(thing) {
                var str = toString1.call(thing);
                return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
            });
            function kindOfTest(type) {
                return type = type.toLowerCase(), function(thing) {
                    return kindOf(thing) === type;
                };
            }
            function isArray(val) {
                return Array.isArray(val);
            }
            function isUndefined(val) {
                return void 0 === val;
            }
            function isBuffer(val) {
                return null !== val && !isUndefined(val) && null !== val.constructor && !isUndefined(val.constructor) && 'function' == typeof val.constructor.isBuffer && val.constructor.isBuffer(val);
            }
            var isArrayBuffer = kindOfTest('ArrayBuffer');
            function isArrayBufferView(val) {
                return 'undefined' != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(val) : val && val.buffer && isArrayBuffer(val.buffer);
            }
            function isString(val) {
                return 'string' == typeof val;
            }
            function isNumber(val) {
                return 'number' == typeof val;
            }
            function isObject(val) {
                return null !== val && 'object' == typeof val;
            }
            function isPlainObject(val) {
                if ('object' !== kindOf(val)) return !1;
                var prototype = Object.getPrototypeOf(val);
                return null === prototype || prototype === Object.prototype;
            }
            var isDate = kindOfTest('Date'), isFile = kindOfTest('File'), isBlob = kindOfTest('Blob'), isFileList = kindOfTest('FileList');
            function isFunction(val) {
                return '[object Function]' === toString1.call(val);
            }
            function isStream(val) {
                return isObject(val) && isFunction(val.pipe);
            }
            function isFormData(thing) {
                var pattern = '[object FormData]';
                return thing && ('function' == typeof FormData && thing instanceof FormData || toString1.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
            }
            var isURLSearchParams = kindOfTest('URLSearchParams');
            function trim(str) {
                return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
            }
            function isStandardBrowserEnv() {
                return ('undefined' == typeof navigator || 'ReactNative' !== navigator.product && 'NativeScript' !== navigator.product && 'NS' !== navigator.product) && 'undefined' != typeof window && 'undefined' != typeof document;
            }
            function forEach(obj, fn) {
                if (null != obj) {
                    if ('object' != typeof obj && (obj = [
                        obj
                    ]), isArray(obj)) for(var i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
                    else for(var key in obj)Object.prototype.hasOwnProperty.call(obj, key) && fn.call(null, obj[key], key, obj);
                }
            }
            function merge() {
                var result = {};
                function assignValue(val, key) {
                    isPlainObject(result[key]) && isPlainObject(val) ? result[key] = merge(result[key], val) : isPlainObject(val) ? result[key] = merge({}, val) : isArray(val) ? result[key] = val.slice() : result[key] = val;
                }
                for(var i = 0, l = arguments.length; i < l; i++)forEach(arguments[i], assignValue);
                return result;
            }
            function extend(a, b, thisArg) {
                return forEach(b, function(val, key) {
                    thisArg && 'function' == typeof val ? a[key] = bind(val, thisArg) : a[key] = val;
                }), a;
            }
            function stripBOM(content) {
                return 0xFEFF === content.charCodeAt(0) && (content = content.slice(1)), content;
            }
            function inherits(constructor, superConstructor, props, descriptors) {
                constructor.prototype = Object.create(superConstructor.prototype, descriptors), constructor.prototype.constructor = constructor, props && Object.assign(constructor.prototype, props);
            }
            function toFlatObject(sourceObj, destObj, filter) {
                var props, i, prop, merged = {};
                destObj = destObj || {};
                do {
                    for(i = (props = Object.getOwnPropertyNames(sourceObj)).length; i-- > 0;)merged[prop = props[i]] || (destObj[prop] = sourceObj[prop], merged[prop] = !0);
                    sourceObj = Object.getPrototypeOf(sourceObj);
                }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype)
                return destObj;
            }
            function endsWith(str, searchString, position) {
                str = String(str), (void 0 === position || position > str.length) && (position = str.length), position -= searchString.length;
                var lastIndex = str.indexOf(searchString, position);
                return -1 !== lastIndex && lastIndex === position;
            }
            function toArray(thing) {
                if (!thing) return null;
                var i = thing.length;
                if (isUndefined(i)) return null;
                for(var arr = Array(i); i-- > 0;)arr[i] = thing[i];
                return arr;
            }
            var TypedArray, isTypedArray = (TypedArray = 'undefined' != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function(thing) {
                return TypedArray && thing instanceof TypedArray;
            });
            module.exports = {
                isArray: isArray,
                isArrayBuffer: isArrayBuffer,
                isBuffer: isBuffer,
                isFormData: isFormData,
                isArrayBufferView: isArrayBufferView,
                isString: isString,
                isNumber: isNumber,
                isObject: isObject,
                isPlainObject: isPlainObject,
                isUndefined: isUndefined,
                isDate: isDate,
                isFile: isFile,
                isBlob: isBlob,
                isFunction: isFunction,
                isStream: isStream,
                isURLSearchParams: isURLSearchParams,
                isStandardBrowserEnv: isStandardBrowserEnv,
                forEach: forEach,
                merge: merge,
                extend: extend,
                trim: trim,
                stripBOM: stripBOM,
                inherits: inherits,
                toFlatObject: toFlatObject,
                kindOf: kindOf,
                kindOfTest: kindOfTest,
                endsWith: endsWith,
                toArray: toArray,
                isTypedArray: isTypedArray,
                isFileList: isFileList
            };
        },
        9742: function(__unused_webpack_module, exports) {
            "use strict";
            exports.byteLength = byteLength, exports.toByteArray = toByteArray, exports.fromByteArray = fromByteArray;
            for(var lookup = [], revLookup = [], Arr = 'undefined' != typeof Uint8Array ? Uint8Array : Array, code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', i = 0, len = code.length; i < len; ++i)lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
            function getLens(b64) {
                var len = b64.length;
                if (len % 4 > 0) throw Error('Invalid string. Length must be a multiple of 4');
                var validLen = b64.indexOf('=');
                -1 === validLen && (validLen = len);
                var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
                return [
                    validLen,
                    placeHoldersLen
                ];
            }
            function byteLength(b64) {
                var lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1];
                return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
            }
            function _byteLength(b64, validLen, placeHoldersLen) {
                return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
            }
            function toByteArray(b64) {
                var tmp, i, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Arr(_byteLength(b64, validLen, placeHoldersLen)), curByte = 0, len = placeHoldersLen > 0 ? validLen - 4 : validLen;
                for(i = 0; i < len; i += 4)tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], arr[curByte++] = tmp >> 16 & 0xFF, arr[curByte++] = tmp >> 8 & 0xFF, arr[curByte++] = 0xFF & tmp;
                return 2 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, arr[curByte++] = 0xFF & tmp), 1 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, arr[curByte++] = tmp >> 8 & 0xFF, arr[curByte++] = 0xFF & tmp), arr;
            }
            function tripletToBase64(num) {
                return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[0x3F & num];
            }
            function encodeChunk(uint8, start, end) {
                for(var tmp, output = [], i = start; i < end; i += 3)output.push(tripletToBase64(tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (0xFF & uint8[i + 2])));
                return output.join('');
            }
            function fromByteArray(uint8) {
                for(var tmp, len = uint8.length, extraBytes = len % 3, parts = [], maxChunkLength = 16383, i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
                return 1 === extraBytes ? parts.push(lookup[(tmp = uint8[len - 1]) >> 2] + lookup[tmp << 4 & 0x3F] + '==') : 2 === extraBytes && parts.push(lookup[(tmp = (uint8[len - 2] << 8) + uint8[len - 1]) >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '='), parts.join('');
            }
            revLookup['-'.charCodeAt(0)] = 62, revLookup['_'.charCodeAt(0)] = 63;
        },
        4431: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !function(globalObject) {
                'use strict';
                var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = '[BigNumber Error] ', tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ', BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, POWS_TEN = [
                    1,
                    10,
                    100,
                    1e3,
                    1e4,
                    1e5,
                    1e6,
                    1e7,
                    1e8,
                    1e9,
                    1e10,
                    1e11,
                    1e12,
                    1e13
                ], SQRT_BASE = 1e7, MAX = 1E9;
                function clone(configObject) {
                    var pow2_53, random53bitInt, basePrefix, dotAfter, dotBefore, isInfinityOrNaN, whitespaceOrPlus, div, convertBase, parseNumeric, P = BigNumber.prototype = {
                        constructor: BigNumber,
                        toString: null,
                        valueOf: null
                    }, ONE = new BigNumber(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -10000000, MAX_EXP = 1e7, CRYPTO = !1, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
                        prefix: '',
                        groupSize: 3,
                        secondaryGroupSize: 0,
                        groupSeparator: ',',
                        decimalSeparator: '.',
                        fractionGroupSize: 0,
                        fractionGroupSeparator: '\xA0',
                        suffix: ''
                    }, ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz', alphabetHasNormalDecimalDigits = !0;
                    function BigNumber(v, b) {
                        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
                        if (!(x instanceof BigNumber)) return new BigNumber(v, b);
                        if (null == b) {
                            if (v && !0 === v._isBigNumber) {
                                x.s = v.s, !v.c || v.e > MAX_EXP ? x.c = x.e = null : v.e < MIN_EXP ? x.c = [
                                    x.e = 0
                                ] : (x.e = v.e, x.c = v.c.slice());
                                return;
                            }
                            if ((isNum = 'number' == typeof v) && 0 * v == 0) {
                                if (x.s = 1 / v < 0 ? (v = -v, -1) : 1, v === ~~v) {
                                    for(e = 0, i = v; i >= 10; i /= 10, e++);
                                    e > MAX_EXP ? x.c = x.e = null : (x.e = e, x.c = [
                                        v
                                    ]);
                                    return;
                                }
                                str = String(v);
                            } else {
                                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
                                x.s = 45 == str.charCodeAt(0) ? (str = str.slice(1), -1) : 1;
                            }
                            (e = str.indexOf('.')) > -1 && (str = str.replace('.', '')), (i = str.search(/e/i)) > 0 ? (e < 0 && (e = i), e += +str.slice(i + 1), str = str.substring(0, i)) : e < 0 && (e = str.length);
                        } else {
                            if (intCheck(b, 2, ALPHABET.length, 'Base'), 10 == b && alphabetHasNormalDecimalDigits) return x = new BigNumber(v), round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                            if (str = String(v), isNum = 'number' == typeof v) {
                                if (0 * v != 0) return parseNumeric(x, str, isNum, b);
                                if (x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1, BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) throw Error(tooManyDigits + v);
                            } else x.s = 45 === str.charCodeAt(0) ? (str = str.slice(1), -1) : 1;
                            for(alphabet = ALPHABET.slice(0, b), e = i = 0, len = str.length; i < len; i++)if (0 > alphabet.indexOf(c = str.charAt(i))) {
                                if ('.' == c) {
                                    if (i > e) {
                                        e = len;
                                        continue;
                                    }
                                } else if (!caseChanged && (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase()))) {
                                    caseChanged = !0, i = -1, e = 0;
                                    continue;
                                }
                                return parseNumeric(x, String(v), isNum, b);
                            }
                            isNum = !1, (e = (str = convertBase(str, b, 10, x.s)).indexOf('.')) > -1 ? str = str.replace('.', '') : e = str.length;
                        }
                        for(i = 0; 48 === str.charCodeAt(i); i++);
                        for(len = str.length; 48 === str.charCodeAt(--len););
                        if (str = str.slice(i, ++len)) {
                            if (len -= i, isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) throw Error(tooManyDigits + x.s * v);
                            if ((e = e - i - 1) > MAX_EXP) x.c = x.e = null;
                            else if (e < MIN_EXP) x.c = [
                                x.e = 0
                            ];
                            else {
                                if (x.e = e, x.c = [], i = (e + 1) % LOG_BASE, e < 0 && (i += LOG_BASE), i < len) {
                                    for(i && x.c.push(+str.slice(0, i)), len -= LOG_BASE; i < len;)x.c.push(+str.slice(i, i += LOG_BASE));
                                    i = LOG_BASE - (str = str.slice(i)).length;
                                } else i -= len;
                                for(; i--; str += '0');
                                x.c.push(+str);
                            }
                        } else x.c = [
                            x.e = 0
                        ];
                    }
                    function format(n, i, rm, id) {
                        var c0, e, ne, len, str;
                        if (null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8), !n.c) return n.toString();
                        if (c0 = n.c[0], ne = n.e, null == i) str = coeffToString(n.c), str = 1 == id || 2 == id && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
                        else if (e = (n = round(new BigNumber(n), i, rm)).e, len = (str = coeffToString(n.c)).length, 1 == id || 2 == id && (i <= e || e <= TO_EXP_NEG)) {
                            for(; len < i; str += '0', len++);
                            str = toExponential(str, e);
                        } else if (i -= ne, str = toFixedPoint(str, e, '0'), e + 1 > len) {
                            if (--i > 0) for(str += '.'; i--; str += '0');
                        } else if ((i += e - len) > 0) for(e + 1 == len && (str += '.'); i--; str += '0');
                        return n.s < 0 && c0 ? '-' + str : str;
                    }
                    function maxOrMin(args, method) {
                        for(var n, i = 1, m = new BigNumber(args[0]); i < args.length; i++)if ((n = new BigNumber(args[i])).s) method.call(m, n) && (m = n);
                        else {
                            m = n;
                            break;
                        }
                        return m;
                    }
                    function normalise(n, c, e) {
                        for(var i = 1, j = c.length; !c[--j]; c.pop());
                        for(j = c[0]; j >= 10; j /= 10, i++);
                        return (e = i + e * LOG_BASE - 1) > MAX_EXP ? n.c = n.e = null : e < MIN_EXP ? n.c = [
                            n.e = 0
                        ] : (n.e = e, n.c = c), n;
                    }
                    function round(x, sd, rm, r) {
                        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
                        if (xc) {
                            out: {
                                for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                                if ((i = sd - d) < 0) i += LOG_BASE, j = sd, rd = (n = xc[ni = 0]) / pows10[d - j - 1] % 10 | 0;
                                else if ((ni = mathceil((i + 1) / LOG_BASE)) >= xc.length) {
                                    if (r) {
                                        for(; xc.length <= ni; xc.push(0));
                                        n = rd = 0, d = 1, i %= LOG_BASE, j = i - LOG_BASE + 1;
                                    } else break out;
                                } else {
                                    for(d = 1, n = k = xc[ni]; k >= 10; k /= 10, d++);
                                    i %= LOG_BASE, rd = (j = i - LOG_BASE + d) < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                                }
                                if (r = r || sd < 0 || null != xc[ni + 1] || (j < 0 ? n : n % pows10[d - j - 1]), r = rm < 4 ? (rd || r) && (0 == rm || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || 5 == rd && (4 == rm || r || 6 == rm && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7)), sd < 1 || !xc[0]) return xc.length = 0, r ? (sd -= x.e + 1, xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE], x.e = -sd || 0) : xc[0] = x.e = 0, x;
                                if (0 == i ? (xc.length = ni, k = 1, ni--) : (xc.length = ni + 1, k = pows10[LOG_BASE - i], xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0), r) for(;;){
                                    if (0 == ni) {
                                        for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                                        for(j = xc[0] += k, k = 1; j >= 10; j /= 10, k++);
                                        i != k && (x.e++, xc[0] == BASE && (xc[0] = 1));
                                        break;
                                    }
                                    if (xc[ni] += k, xc[ni] != BASE) break;
                                    xc[ni--] = 0, k = 1;
                                }
                                for(i = xc.length; 0 === xc[--i]; xc.pop());
                            }
                            x.e > MAX_EXP ? x.c = x.e = null : x.e < MIN_EXP && (x.c = [
                                x.e = 0
                            ]);
                        }
                        return x;
                    }
                    function valueOf(n) {
                        var str, e = n.e;
                        return null === e ? n.toString() : (str = coeffToString(n.c), str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0'), n.s < 0 ? '-' + str : str);
                    }
                    return BigNumber.clone = clone, BigNumber.ROUND_UP = 0, BigNumber.ROUND_DOWN = 1, BigNumber.ROUND_CEIL = 2, BigNumber.ROUND_FLOOR = 3, BigNumber.ROUND_HALF_UP = 4, BigNumber.ROUND_HALF_DOWN = 5, BigNumber.ROUND_HALF_EVEN = 6, BigNumber.ROUND_HALF_CEIL = 7, BigNumber.ROUND_HALF_FLOOR = 8, BigNumber.EUCLID = 9, BigNumber.config = BigNumber.set = function(obj) {
                        var p, v;
                        if (null != obj) {
                            if ('object' == typeof obj) {
                                if (obj.hasOwnProperty(p = 'DECIMAL_PLACES') && (intCheck(v = obj[p], 0, MAX, p), DECIMAL_PLACES = v), obj.hasOwnProperty(p = 'ROUNDING_MODE') && (intCheck(v = obj[p], 0, 8, p), ROUNDING_MODE = v), obj.hasOwnProperty(p = 'EXPONENTIAL_AT') && ((v = obj[p]) && v.pop ? (intCheck(v[0], -MAX, 0, p), intCheck(v[1], 0, MAX, p), TO_EXP_NEG = v[0], TO_EXP_POS = v[1]) : (intCheck(v, -MAX, MAX, p), TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v))), obj.hasOwnProperty(p = 'RANGE')) {
                                    if ((v = obj[p]) && v.pop) intCheck(v[0], -MAX, -1, p), intCheck(v[1], 1, MAX, p), MIN_EXP = v[0], MAX_EXP = v[1];
                                    else if (intCheck(v, -MAX, MAX, p), v) MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                                    else throw Error(bignumberError + p + ' cannot be zero: ' + v);
                                }
                                if (obj.hasOwnProperty(p = 'CRYPTO')) {
                                    if (!!(v = obj[p]) === v) {
                                        if (v) {
                                            if ('undefined' != typeof crypto && crypto && (crypto.getRandomValues || crypto.randomBytes)) CRYPTO = v;
                                            else throw CRYPTO = !v, Error(bignumberError + 'crypto unavailable');
                                        } else CRYPTO = v;
                                    } else throw Error(bignumberError + p + ' not true or false: ' + v);
                                }
                                if (obj.hasOwnProperty(p = 'MODULO_MODE') && (intCheck(v = obj[p], 0, 9, p), MODULO_MODE = v), obj.hasOwnProperty(p = 'POW_PRECISION') && (intCheck(v = obj[p], 0, MAX, p), POW_PRECISION = v), obj.hasOwnProperty(p = 'FORMAT')) {
                                    if ('object' == typeof (v = obj[p])) FORMAT = v;
                                    else throw Error(bignumberError + p + ' not an object: ' + v);
                                }
                                if (obj.hasOwnProperty(p = 'ALPHABET')) {
                                    if ('string' != typeof (v = obj[p]) || /^.?$|[+\-.\s]|(.).*\1/.test(v)) throw Error(bignumberError + p + ' invalid: ' + v);
                                    alphabetHasNormalDecimalDigits = '0123456789' == v.slice(0, 10), ALPHABET = v;
                                }
                            } else throw Error(bignumberError + 'Object expected: ' + obj);
                        }
                        return {
                            DECIMAL_PLACES: DECIMAL_PLACES,
                            ROUNDING_MODE: ROUNDING_MODE,
                            EXPONENTIAL_AT: [
                                TO_EXP_NEG,
                                TO_EXP_POS
                            ],
                            RANGE: [
                                MIN_EXP,
                                MAX_EXP
                            ],
                            CRYPTO: CRYPTO,
                            MODULO_MODE: MODULO_MODE,
                            POW_PRECISION: POW_PRECISION,
                            FORMAT: FORMAT,
                            ALPHABET: ALPHABET
                        };
                    }, BigNumber.isBigNumber = function(v) {
                        if (!v || !0 !== v._isBigNumber) return !1;
                        if (!BigNumber.DEBUG) return !0;
                        var i, n, c = v.c, e = v.e, s = v.s;
                        out: if ('[object Array]' == ({}).toString.call(c)) {
                            if ((1 === s || -1 === s) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                                if (0 === c[0]) {
                                    if (0 === e && 1 === c.length) return !0;
                                    break out;
                                }
                                if ((i = (e + 1) % LOG_BASE) < 1 && (i += LOG_BASE), String(c[0]).length == i) {
                                    for(i = 0; i < c.length; i++)if ((n = c[i]) < 0 || n >= BASE || n !== mathfloor(n)) break out;
                                    if (0 !== n) return !0;
                                }
                            }
                        } else if (null === c && null === e && (null === s || 1 === s || -1 === s)) return !0;
                        throw Error(bignumberError + 'Invalid BigNumber: ' + v);
                    }, BigNumber.maximum = BigNumber.max = function() {
                        return maxOrMin(arguments, P.lt);
                    }, BigNumber.minimum = BigNumber.min = function() {
                        return maxOrMin(arguments, P.gt);
                    }, BigNumber.random = (random53bitInt = Math.random() * (pow2_53 = 0x20000000000000) & 0x1fffff ? function() {
                        return mathfloor(Math.random() * pow2_53);
                    } : function() {
                        return (0x40000000 * Math.random() | 0) * 0x800000 + (0x800000 * Math.random() | 0);
                    }, function(dp) {
                        var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
                        if (null == dp ? dp = DECIMAL_PLACES : intCheck(dp, 0, MAX), k = mathceil(dp / LOG_BASE), CRYPTO) {
                            if (crypto.getRandomValues) {
                                for(a = crypto.getRandomValues(new Uint32Array(k *= 2)); i < k;)(v = 0x20000 * a[i] + (a[i + 1] >>> 11)) >= 9e15 ? (b = crypto.getRandomValues(new Uint32Array(2)), a[i] = b[0], a[i + 1] = b[1]) : (c.push(v % 1e14), i += 2);
                                i = k / 2;
                            } else if (crypto.randomBytes) {
                                for(a = crypto.randomBytes(k *= 7); i < k;)(v = (31 & a[i]) * 0x1000000000000 + 0x10000000000 * a[i + 1] + 0x100000000 * a[i + 2] + 0x1000000 * a[i + 3] + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6]) >= 9e15 ? crypto.randomBytes(7).copy(a, i) : (c.push(v % 1e14), i += 7);
                                i = k / 7;
                            } else throw CRYPTO = !1, Error(bignumberError + 'crypto unavailable');
                        }
                        if (!CRYPTO) for(; i < k;)(v = random53bitInt()) < 9e15 && (c[i++] = v % 1e14);
                        for(k = c[--i], dp %= LOG_BASE, k && dp && (v = POWS_TEN[LOG_BASE - dp], c[i] = mathfloor(k / v) * v); 0 === c[i]; c.pop(), i--);
                        if (i < 0) c = [
                            e = 0
                        ];
                        else {
                            for(e = -1; 0 === c[0]; c.splice(0, 1), e -= LOG_BASE);
                            for(i = 1, v = c[0]; v >= 10; v /= 10, i++);
                            i < LOG_BASE && (e -= LOG_BASE - i);
                        }
                        return rand.e = e, rand.c = c, rand;
                    }), BigNumber.sum = function() {
                        for(var i = 1, args = arguments, sum = new BigNumber(args[0]); i < args.length;)sum = sum.plus(args[i++]);
                        return sum;
                    }, convertBase = function() {
                        var decimal = '0123456789';
                        function toBaseOut(str, baseIn, baseOut, alphabet) {
                            for(var j, arrL, arr = [
                                0
                            ], i = 0, len = str.length; i < len;){
                                for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);
                                for(arr[0] += alphabet.indexOf(str.charAt(i++)), j = 0; j < arr.length; j++)arr[j] > baseOut - 1 && (null == arr[j + 1] && (arr[j + 1] = 0), arr[j + 1] += arr[j] / baseOut | 0, arr[j] %= baseOut);
                            }
                            return arr.reverse();
                        }
                        return function(str, baseIn, baseOut, sign, callerIsToString) {
                            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf('.'), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                            for(i >= 0 && (k = POW_PRECISION, POW_PRECISION = 0, str = str.replace('.', ''), x = (y = new BigNumber(baseIn)).pow(str.length - i), POW_PRECISION = k, y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal), y.e = y.c.length), e = k = (xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET))).length; 0 == xc[--k]; xc.pop());
                            if (!xc[0]) return alphabet.charAt(0);
                            if (i < 0 ? --e : (x.c = xc, x.e = e, x.s = sign, xc = (x = div(x, y, dp, rm, baseOut)).c, r = x.r, e = x.e), i = xc[d = e + dp + 1], k = baseOut / 2, r = r || d < 0 || null != xc[d + 1], r = rm < 4 ? (null != i || r) && (0 == rm || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (4 == rm || r || 6 == rm && 1 & xc[d - 1] || rm == (x.s < 0 ? 8 : 7)), d < 1 || !xc[0]) str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                            else {
                                if (xc.length = d, r) for(--baseOut; ++xc[--d] > baseOut;)xc[d] = 0, d || (++e, xc = [
                                    1
                                ].concat(xc));
                                for(k = xc.length; !xc[--k];);
                                for(i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));
                                str = toFixedPoint(str, e, alphabet.charAt(0));
                            }
                            return str;
                        };
                    }(), div = function() {
                        function multiply(x, k, base) {
                            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
                            for(x = x.slice(); i--;)m = khi * (xlo = x[i] % SQRT_BASE) + (xhi = x[i] / SQRT_BASE | 0) * klo, carry = ((temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry) / base | 0) + (m / SQRT_BASE | 0) + khi * xhi, x[i] = temp % base;
                            return carry && (x = [
                                carry
                            ].concat(x)), x;
                        }
                        function compare(a, b, aL, bL) {
                            var i, cmp;
                            if (aL != bL) cmp = aL > bL ? 1 : -1;
                            else for(i = cmp = 0; i < aL; i++)if (a[i] != b[i]) {
                                cmp = a[i] > b[i] ? 1 : -1;
                                break;
                            }
                            return cmp;
                        }
                        function subtract(a, b, aL, base) {
                            for(var i = 0; aL--;)a[aL] -= i, i = a[aL] < b[aL] ? 1 : 0, a[aL] = i * base + a[aL] - b[aL];
                            for(; !a[0] && a.length > 1; a.splice(0, 1));
                        }
                        return function(x, y, dp, rm, base) {
                            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                            if (!xc || !xc[0] || !yc || !yc[0]) return new BigNumber(x.s && y.s && (xc ? !yc || xc[0] != yc[0] : yc) ? xc && 0 == xc[0] || !yc ? 0 * s : s / 0 : NaN);
                            for(qc = (q = new BigNumber(s)).c = [], s = dp + (e = x.e - y.e) + 1, base || (base = BASE, e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE), s = s / LOG_BASE | 0), i = 0; yc[i] == (xc[i] || 0); i++);
                            if (yc[i] > (xc[i] || 0) && e--, s < 0) qc.push(1), more = !0;
                            else {
                                for(xL = xc.length, yL = yc.length, i = 0, s += 2, (n = mathfloor(base / (yc[0] + 1))) > 1 && (yc = multiply(yc, n, base), xc = multiply(xc, n, base), yL = yc.length, xL = xc.length), xi = yL, remL = (rem = xc.slice(0, yL)).length; remL < yL; rem[remL++] = 0);
                                yz = [
                                    0
                                ].concat(yz = yc.slice()), yc0 = yc[0], yc[1] >= base / 2 && yc0++;
                                do {
                                    if (n = 0, (cmp = compare(yc, rem, yL, remL)) < 0) {
                                        if (rem0 = rem[0], yL != remL && (rem0 = rem0 * base + (rem[1] || 0)), (n = mathfloor(rem0 / yc0)) > 1) for(n >= base && (n = base - 1), prodL = (prod = multiply(yc, n, base)).length, remL = rem.length; 1 == compare(prod, rem, prodL, remL);)n--, subtract(prod, yL < prodL ? yz : yc, prodL, base), prodL = prod.length, cmp = 1;
                                        else 0 == n && (cmp = n = 1), prodL = (prod = yc.slice()).length;
                                        if (prodL < remL && (prod = [
                                            0
                                        ].concat(prod)), subtract(rem, prod, remL, base), remL = rem.length, -1 == cmp) for(; 1 > compare(yc, rem, yL, remL);)n++, subtract(rem, yL < remL ? yz : yc, remL, base), remL = rem.length;
                                    } else 0 === cmp && (n++, rem = [
                                        0
                                    ]);
                                    qc[i++] = n, rem[0] ? rem[remL++] = xc[xi] || 0 : (rem = [
                                        xc[xi]
                                    ], remL = 1);
                                }while ((xi++ < xL || null != rem[0]) && s--)
                                more = null != rem[0], qc[0] || qc.splice(0, 1);
                            }
                            if (base == BASE) {
                                for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);
                                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
                            } else q.e = e, q.r = +more;
                            return q;
                        };
                    }(), parseNumeric = (basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g, function(x, str, isNum, b) {
                        var base, s = isNum ? str : str.replace(whitespaceOrPlus, '');
                        if (isInfinityOrNaN.test(s)) x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                        else {
                            if (!isNum && (s = s.replace(basePrefix, function(m, p1, p2) {
                                return base = 'x' == (p2 = p2.toLowerCase()) ? 16 : 'b' == p2 ? 2 : 8, b && b != base ? m : p1;
                            }), b && (base = b, s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1')), str != s)) return new BigNumber(s, base);
                            if (BigNumber.DEBUG) throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                            x.s = null;
                        }
                        x.c = x.e = null;
                    }), P.absoluteValue = P.abs = function() {
                        var x = new BigNumber(this);
                        return x.s < 0 && (x.s = 1), x;
                    }, P.comparedTo = function(y, b) {
                        return compare(this, new BigNumber(y, b));
                    }, P.decimalPlaces = P.dp = function(dp, rm) {
                        var c, n, v, x = this;
                        if (null != dp) return intCheck(dp, 0, MAX), null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8), round(new BigNumber(x), dp + x.e + 1, rm);
                        if (!(c = x.c)) return null;
                        if (n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, v = c[v]) for(; v % 10 == 0; v /= 10, n--);
                        return n < 0 && (n = 0), n;
                    }, P.dividedBy = P.div = function(y, b) {
                        return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
                    }, P.dividedToIntegerBy = P.idiv = function(y, b) {
                        return div(this, new BigNumber(y, b), 0, 1);
                    }, P.exponentiatedBy = P.pow = function(n, m) {
                        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
                        if ((n = new BigNumber(n)).c && !n.isInteger()) throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
                        if (null != m && (m = new BigNumber(m)), nIsBig = n.e > 14, !x.c || !x.c[0] || 1 == x.c[0] && !x.e && 1 == x.c.length || !n.c || !n.c[0]) return y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n))), m ? y.mod(m) : y;
                        if (nIsNeg = n.s < 0, m) {
                            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
                            (isModExp = !nIsNeg && x.isInteger() && m.isInteger()) && (x = x.mod(m));
                        } else {
                            if (n.e > 9 && (x.e > 0 || x.e < -1 || (0 == x.e ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) return k = (x.s < 0 && isOdd(n), -0), x.e > -1 && (k = 1 / k), new BigNumber(nIsNeg ? 1 / k : k);
                            POW_PRECISION && (k = mathceil(POW_PRECISION / LOG_BASE + 2));
                        }
                        for(nIsBig ? (half = new BigNumber(0.5), nIsNeg && (n.s = 1), nIsOdd = isOdd(n)) : nIsOdd = (i = Math.abs(+valueOf(n))) % 2, y = new BigNumber(ONE);;){
                            if (nIsOdd) {
                                if (!(y = y.times(x)).c) break;
                                k ? y.c.length > k && (y.c.length = k) : isModExp && (y = y.mod(m));
                            }
                            if (i) {
                                if (0 === (i = mathfloor(i / 2))) break;
                                nIsOdd = i % 2;
                            } else if (round(n = n.times(half), n.e + 1, 1), n.e > 14) nIsOdd = isOdd(n);
                            else {
                                if (0 == (i = +valueOf(n))) break;
                                nIsOdd = i % 2;
                            }
                            x = x.times(x), k ? x.c && x.c.length > k && (x.c.length = k) : isModExp && (x = x.mod(m));
                        }
                        return isModExp ? y : (nIsNeg && (y = ONE.div(y)), m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y);
                    }, P.integerValue = function(rm) {
                        var n = new BigNumber(this);
                        return null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8), round(n, n.e + 1, rm);
                    }, P.isEqualTo = P.eq = function(y, b) {
                        return 0 === compare(this, new BigNumber(y, b));
                    }, P.isFinite = function() {
                        return !!this.c;
                    }, P.isGreaterThan = P.gt = function(y, b) {
                        return compare(this, new BigNumber(y, b)) > 0;
                    }, P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
                        return 1 === (b = compare(this, new BigNumber(y, b))) || 0 === b;
                    }, P.isInteger = function() {
                        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
                    }, P.isLessThan = P.lt = function(y, b) {
                        return 0 > compare(this, new BigNumber(y, b));
                    }, P.isLessThanOrEqualTo = P.lte = function(y, b) {
                        return -1 === (b = compare(this, new BigNumber(y, b))) || 0 === b;
                    }, P.isNaN = function() {
                        return !this.s;
                    }, P.isNegative = function() {
                        return this.s < 0;
                    }, P.isPositive = function() {
                        return this.s > 0;
                    }, P.isZero = function() {
                        return !!this.c && 0 == this.c[0];
                    }, P.minus = function(y, b) {
                        var i, j, t, xLTy, x = this, a = x.s;
                        if (b = (y = new BigNumber(y, b)).s, !a || !b) return new BigNumber(NaN);
                        if (a != b) return y.s = -b, x.plus(y);
                        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                        if (!xe || !ye) {
                            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
                            if (!xc[0] || !yc[0]) return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : -0);
                        }
                        if (xe = bitFloor(xe), ye = bitFloor(ye), xc = xc.slice(), a = xe - ye) {
                            for((xLTy = a < 0) ? (a = -a, t = xc) : (ye = xe, t = yc), t.reverse(), b = a; b--; t.push(0));
                            t.reverse();
                        } else for(j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b, a = b = 0; b < j; b++)if (xc[b] != yc[b]) {
                            xLTy = xc[b] < yc[b];
                            break;
                        }
                        if (xLTy && (t = xc, xc = yc, yc = t, y.s = -y.s), (b = (j = yc.length) - (i = xc.length)) > 0) for(; b--; xc[i++] = 0);
                        for(b = BASE - 1; j > a;){
                            if (xc[--j] < yc[j]) {
                                for(i = j; i && !xc[--i]; xc[i] = b);
                                --xc[i], xc[j] += BASE;
                            }
                            xc[j] -= yc[j];
                        }
                        for(; 0 == xc[0]; xc.splice(0, 1), --ye);
                        return xc[0] ? normalise(y, xc, ye) : (y.s = 3 == ROUNDING_MODE ? -1 : 1, y.c = [
                            y.e = 0
                        ], y);
                    }, P.modulo = P.mod = function(y, b) {
                        var q, s, x = this;
                        return (y = new BigNumber(y, b), x.c && y.s && (!y.c || y.c[0])) ? y.c && (!x.c || x.c[0]) ? (9 == MODULO_MODE ? (s = y.s, y.s = 1, q = div(x, y, 0, 3), y.s = s, q.s *= s) : q = div(x, y, 0, MODULO_MODE), (y = x.minus(q.times(y))).c[0] || 1 != MODULO_MODE || (y.s = x.s), y) : new BigNumber(x) : new BigNumber(NaN);
                    }, P.multipliedBy = P.times = function(y, b) {
                        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;
                        if (!xc || !yc || !xc[0] || !yc[0]) return x.s && y.s && (!xc || xc[0] || yc) && (!yc || yc[0] || xc) ? (y.s *= x.s, xc && yc ? (y.c = [
                            0
                        ], y.e = 0) : y.c = y.e = null) : y.c = y.e = y.s = null, y;
                        for(e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE), y.s *= x.s, (xcL = xc.length) < (ycL = yc.length) && (zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i), i = xcL + ycL, zc = []; i--; zc.push(0));
                        for(base = BASE, sqrtBase = SQRT_BASE, i = ycL; --i >= 0;){
                            for(c = 0, ylo = yc[i] % sqrtBase, yhi = yc[i] / sqrtBase | 0, j = i + (k = xcL); j > i;)m = yhi * (xlo = xc[--k] % sqrtBase) + (xhi = xc[k] / sqrtBase | 0) * ylo, c = ((xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c) / base | 0) + (m / sqrtBase | 0) + yhi * xhi, zc[j--] = xlo % base;
                            zc[j] = c;
                        }
                        return c ? ++e : zc.splice(0, 1), normalise(y, zc, e);
                    }, P.negated = function() {
                        var x = new BigNumber(this);
                        return x.s = -x.s || null, x;
                    }, P.plus = function(y, b) {
                        var t, x = this, a = x.s;
                        if (b = (y = new BigNumber(y, b)).s, !a || !b) return new BigNumber(NaN);
                        if (a != b) return y.s = -b, x.minus(y);
                        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                        if (!xe || !ye) {
                            if (!xc || !yc) return new BigNumber(a / 0);
                            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : 0 * a);
                        }
                        if (xe = bitFloor(xe), ye = bitFloor(ye), xc = xc.slice(), a = xe - ye) {
                            for(a > 0 ? (ye = xe, t = yc) : (a = -a, t = xc), t.reverse(); a--; t.push(0));
                            t.reverse();
                        }
                        for((a = xc.length) - (b = yc.length) < 0 && (t = yc, yc = xc, xc = t, b = a), a = 0; b;)a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0, xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
                        return a && (xc = [
                            a
                        ].concat(xc), ++ye), normalise(y, xc, ye);
                    }, P.precision = P.sd = function(sd, rm) {
                        var c, n, v, x = this;
                        if (null != sd && !!sd !== sd) return intCheck(sd, 1, MAX), null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8), round(new BigNumber(x), sd, rm);
                        if (!(c = x.c)) return null;
                        if (n = (v = c.length - 1) * LOG_BASE + 1, v = c[v]) {
                            for(; v % 10 == 0; v /= 10, n--);
                            for(v = c[0]; v >= 10; v /= 10, n++);
                        }
                        return sd && x.e + 1 > n && (n = x.e + 1), n;
                    }, P.shiftedBy = function(k) {
                        return intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER), this.times('1e' + k);
                    }, P.squareRoot = P.sqrt = function() {
                        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber('0.5');
                        if (1 !== s || !c || !c[0]) return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                        if (0 == (s = Math.sqrt(+valueOf(x))) || s == 1 / 0 ? (((n = coeffToString(c)).length + e) % 2 == 0 && (n += '0'), s = Math.sqrt(+n), e = bitFloor((e + 1) / 2) - (e < 0 || e % 2), n = s == 1 / 0 ? '5e' + e : (n = s.toExponential()).slice(0, n.indexOf('e') + 1) + e, r = new BigNumber(n)) : r = new BigNumber(s + ''), r.c[0]) {
                            for((s = (e = r.e) + dp) < 3 && (s = 0);;)if (t = r, r = half.times(t.plus(div(x, t, dp, 1))), coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                                if (r.e < e && --s, '9999' != (n = n.slice(s - 3, s + 1)) && (rep || '4999' != n)) {
                                    +n && (+n.slice(1) || '5' != n.charAt(0)) || (round(r, r.e + DECIMAL_PLACES + 2, 1), m = !r.times(r).eq(x));
                                    break;
                                }
                                if (!rep && (round(t, t.e + DECIMAL_PLACES + 2, 0), t.times(t).eq(x))) {
                                    r = t;
                                    break;
                                }
                                dp += 4, s += 4, rep = 1;
                            }
                        }
                        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
                    }, P.toExponential = function(dp, rm) {
                        return null != dp && (intCheck(dp, 0, MAX), dp++), format(this, dp, rm, 1);
                    }, P.toFixed = function(dp, rm) {
                        return null != dp && (intCheck(dp, 0, MAX), dp = dp + this.e + 1), format(this, dp, rm);
                    }, P.toFormat = function(dp, rm, format) {
                        var str, x = this;
                        if (null == format) null != dp && rm && 'object' == typeof rm ? (format = rm, rm = null) : dp && 'object' == typeof dp ? (format = dp, dp = rm = null) : format = FORMAT;
                        else if ('object' != typeof format) throw Error(bignumberError + 'Argument not an object: ' + format);
                        if (str = x.toFixed(dp, rm), x.c) {
                            var i, arr = str.split('.'), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || '', intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                            if (g2 && (i = g1, g1 = g2, g2 = i, len -= i), g1 > 0 && len > 0) {
                                for(i = len % g1 || g1, intPart = intDigits.substr(0, i); i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);
                                g2 > 0 && (intPart += groupSeparator + intDigits.slice(i)), isNeg && (intPart = '-' + intPart);
                            }
                            str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
                        }
                        return (format.prefix || '') + str + (format.suffix || '');
                    }, P.toFraction = function(md) {
                        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
                        if (null != md && (!(n = new BigNumber(md)).isInteger() && (n.c || 1 !== n.s) || n.lt(ONE))) throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
                        if (!xc) return new BigNumber(x);
                        for(d = new BigNumber(ONE), n1 = d0 = new BigNumber(ONE), d1 = n0 = new BigNumber(ONE), s = coeffToString(xc), e = d.e = s.length - x.e - 1, d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp], md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n, exp = MAX_EXP, MAX_EXP = 1 / 0, n = new BigNumber(s), n0.c[0] = 0; q = div(n, d, 0, 1), 1 != (d2 = d0.plus(q.times(d1))).comparedTo(md);)d0 = d1, d1 = d2, n1 = n0.plus(q.times(d2 = n1)), n0 = d2, d = n.minus(q.times(d2 = d)), n = d2;
                        return d2 = div(md.minus(d0), d1, 0, 1), n0 = n0.plus(d2.times(n1)), d0 = d0.plus(d2.times(d1)), n0.s = n1.s = x.s, e *= 2, r = 1 > div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) ? [
                            n1,
                            d1
                        ] : [
                            n0,
                            d0
                        ], MAX_EXP = exp, r;
                    }, P.toNumber = function() {
                        return +valueOf(this);
                    }, P.toPrecision = function(sd, rm) {
                        return null != sd && intCheck(sd, 1, MAX), format(this, sd, rm, 2);
                    }, P.toString = function(b) {
                        var str, n = this, s = n.s, e = n.e;
                        return null === e ? s ? (str = 'Infinity', s < 0 && (str = '-' + str)) : str = 'NaN' : (null == b ? str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0') : 10 === b && alphabetHasNormalDecimalDigits ? str = toFixedPoint(coeffToString((n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE)).c), n.e, '0') : (intCheck(b, 2, ALPHABET.length, 'Base'), str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, !0)), s < 0 && n.c[0] && (str = '-' + str)), str;
                    }, P.valueOf = P.toJSON = function() {
                        return valueOf(this);
                    }, P._isBigNumber = !0, null != configObject && BigNumber.set(configObject), BigNumber;
                }
                function bitFloor(n) {
                    var i = 0 | n;
                    return n > 0 || n === i ? i : i - 1;
                }
                function coeffToString(a) {
                    for(var s, z, i = 1, j = a.length, r = a[0] + ''; i < j;){
                        for(z = LOG_BASE - (s = a[i++] + '').length; z--; s = '0' + s);
                        r += s;
                    }
                    for(j = r.length; 48 === r.charCodeAt(--j););
                    return r.slice(0, j + 1 || 1);
                }
                function compare(x, y) {
                    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
                    if (!i || !j) return null;
                    if (a = xc && !xc[0], b = yc && !yc[0], a || b) return a ? b ? 0 : -j : i;
                    if (i != j) return i;
                    if (a = i < 0, b = k == l, !xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
                    if (!b) return k > l ^ a ? 1 : -1;
                    for(i = 0, j = (k = xc.length) < (l = yc.length) ? k : l; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
                    return k == l ? 0 : k > l ^ a ? 1 : -1;
                }
                function intCheck(n, min, max, name) {
                    if (n < min || n > max || n !== mathfloor(n)) throw Error(bignumberError + (name || 'Argument') + ('number' == typeof n ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
                }
                function isOdd(n) {
                    var k = n.c.length - 1;
                    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
                }
                function toExponential(str, e) {
                    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
                }
                function toFixedPoint(str, e, z) {
                    var len, zs;
                    if (e < 0) {
                        for(zs = z + '.'; ++e; zs += z);
                        str = zs + str;
                    } else if (len = str.length, ++e > len) {
                        for(zs = z, e -= len; --e; zs += z);
                        str += zs;
                    } else e < len && (str = str.slice(0, e) + '.' + str.slice(e));
                    return str;
                }
                (BigNumber = clone()).default = BigNumber.BigNumber = BigNumber, void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return BigNumber;
                }).call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            }(this);
        },
        3550: function(module, __unused_webpack_exports, __webpack_require__) {
            !function(module, exports) {
                'use strict';
                function assert(val, msg) {
                    if (!val) throw Error(msg || 'Assertion failed');
                }
                function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
                }
                function BN(number, base, endian) {
                    if (BN.isBN(number)) return number;
                    this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== number && (('le' === base || 'be' === base) && (endian = base, base = 10), this._init(number || 0, base || 10, endian || 'be'));
                }
                'object' == typeof module ? module.exports = BN : exports.BN = BN, BN.BN = BN, BN.wordSize = 26;
                try {
                    Buffer = 'undefined' != typeof window && void 0 !== window.Buffer ? window.Buffer : __webpack_require__(6601).Buffer;
                } catch (e) {}
                function parseHex4Bits(string, index) {
                    var c = string.charCodeAt(index);
                    return c >= 65 && c <= 70 ? c - 55 : c >= 97 && c <= 102 ? c - 87 : c - 48 & 0xf;
                }
                function parseHexByte(string, lowerBound, index) {
                    var r = parseHex4Bits(string, index);
                    return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4), r;
                }
                function parseBase(str, start, end, mul) {
                    for(var r = 0, len = Math.min(str.length, end), i = start; i < len; i++){
                        var c = str.charCodeAt(i) - 48;
                        r *= mul, c >= 49 ? r += c - 49 + 0xa : c >= 17 ? r += c - 17 + 0xa : r += c;
                    }
                    return r;
                }
                BN.isBN = function(num) {
                    return num instanceof BN || null !== num && 'object' == typeof num && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
                }, BN.max = function(left, right) {
                    return left.cmp(right) > 0 ? left : right;
                }, BN.min = function(left, right) {
                    return 0 > left.cmp(right) ? left : right;
                }, BN.prototype._init = function(number, base, endian) {
                    if ('number' == typeof number) return this._initNumber(number, base, endian);
                    if ('object' == typeof number) return this._initArray(number, base, endian);
                    'hex' === base && (base = 16), assert(base === (0 | base) && base >= 2 && base <= 36);
                    var start = 0;
                    '-' === (number = number.toString().replace(/\s+/g, ''))[0] && (start++, this.negative = 1), start < number.length && (16 === base ? this._parseHex(number, start, endian) : (this._parseBase(number, base, start), 'le' === endian && this._initArray(this.toArray(), base, endian)));
                }, BN.prototype._initNumber = function(number, base, endian) {
                    number < 0 && (this.negative = 1, number = -number), number < 0x4000000 ? (this.words = [
                        0x3ffffff & number
                    ], this.length = 1) : number < 0x10000000000000 ? (this.words = [
                        0x3ffffff & number,
                        number / 0x4000000 & 0x3ffffff
                    ], this.length = 2) : (assert(number < 0x20000000000000), this.words = [
                        0x3ffffff & number,
                        number / 0x4000000 & 0x3ffffff,
                        1
                    ], this.length = 3), 'le' === endian && this._initArray(this.toArray(), base, endian);
                }, BN.prototype._initArray = function(number, base, endian) {
                    if (assert('number' == typeof number.length), number.length <= 0) return this.words = [
                        0
                    ], this.length = 1, this;
                    this.length = Math.ceil(number.length / 3), this.words = Array(this.length);
                    for(var j, w, i = 0; i < this.length; i++)this.words[i] = 0;
                    var off = 0;
                    if ('be' === endian) for(i = number.length - 1, j = 0; i >= 0; i -= 3)w = number[i] | number[i - 1] << 8 | number[i - 2] << 16, this.words[j] |= w << off & 0x3ffffff, this.words[j + 1] = w >>> 26 - off & 0x3ffffff, (off += 24) >= 26 && (off -= 26, j++);
                    else if ('le' === endian) for(i = 0, j = 0; i < number.length; i += 3)w = number[i] | number[i + 1] << 8 | number[i + 2] << 16, this.words[j] |= w << off & 0x3ffffff, this.words[j + 1] = w >>> 26 - off & 0x3ffffff, (off += 24) >= 26 && (off -= 26, j++);
                    return this.strip();
                }, BN.prototype._parseHex = function(number, start, endian) {
                    this.length = Math.ceil((number.length - start) / 6), this.words = Array(this.length);
                    for(var w, i = 0; i < this.length; i++)this.words[i] = 0;
                    var off = 0, j = 0;
                    if ('be' === endian) for(i = number.length - 1; i >= start; i -= 2)w = parseHexByte(number, start, i) << off, this.words[j] |= 0x3ffffff & w, off >= 18 ? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;
                    else {
                        var parseLength = number.length - start;
                        for(i = parseLength % 2 == 0 ? start + 1 : start; i < number.length; i += 2)w = parseHexByte(number, start, i) << off, this.words[j] |= 0x3ffffff & w, off >= 18 ? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;
                    }
                    this.strip();
                }, BN.prototype._parseBase = function(number, base, start) {
                    this.words = [
                        0
                    ], this.length = 1;
                    for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
                    limbLen--, limbPow = limbPow / base | 0;
                    for(var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start; i < end; i += limbLen)word = parseBase(number, i, i + limbLen, base), this.imuln(limbPow), this.words[0] + word < 0x4000000 ? this.words[0] += word : this._iaddn(word);
                    if (0 !== mod) {
                        var pow = 1;
                        for(word = parseBase(number, i, number.length, base), i = 0; i < mod; i++)pow *= base;
                        this.imuln(pow), this.words[0] + word < 0x4000000 ? this.words[0] += word : this._iaddn(word);
                    }
                    this.strip();
                }, BN.prototype.copy = function(dest) {
                    dest.words = Array(this.length);
                    for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
                    dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
                }, BN.prototype.clone = function() {
                    var r = new BN(null);
                    return this.copy(r), r;
                }, BN.prototype._expand = function(size) {
                    for(; this.length < size;)this.words[this.length++] = 0;
                    return this;
                }, BN.prototype.strip = function() {
                    for(; this.length > 1 && 0 === this.words[this.length - 1];)this.length--;
                    return this._normSign();
                }, BN.prototype._normSign = function() {
                    return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
                }, BN.prototype.inspect = function() {
                    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
                };
                var Buffer, zeros = [
                    '',
                    '0',
                    '00',
                    '000',
                    '0000',
                    '00000',
                    '000000',
                    '0000000',
                    '00000000',
                    '000000000',
                    '0000000000',
                    '00000000000',
                    '000000000000',
                    '0000000000000',
                    '00000000000000',
                    '000000000000000',
                    '0000000000000000',
                    '00000000000000000',
                    '000000000000000000',
                    '0000000000000000000',
                    '00000000000000000000',
                    '000000000000000000000',
                    '0000000000000000000000',
                    '00000000000000000000000',
                    '000000000000000000000000',
                    '0000000000000000000000000'
                ], groupSizes = [
                    0,
                    0,
                    25,
                    16,
                    12,
                    11,
                    10,
                    9,
                    8,
                    8,
                    7,
                    7,
                    7,
                    7,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ], groupBases = [
                    0,
                    0,
                    33554432,
                    43046721,
                    16777216,
                    48828125,
                    60466176,
                    40353607,
                    16777216,
                    43046721,
                    10000000,
                    19487171,
                    35831808,
                    62748517,
                    7529536,
                    11390625,
                    16777216,
                    24137569,
                    34012224,
                    47045881,
                    64000000,
                    4084101,
                    5153632,
                    6436343,
                    7962624,
                    9765625,
                    11881376,
                    14348907,
                    17210368,
                    20511149,
                    24300000,
                    28629151,
                    33554432,
                    39135393,
                    45435424,
                    52521875,
                    60466176
                ];
                function toBitArray(num) {
                    for(var w = Array(num.bitLength()), bit = 0; bit < w.length; bit++){
                        var off = bit / 26 | 0, wbit = bit % 26;
                        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
                    }
                    return w;
                }
                function smallMulTo(self1, num, out) {
                    out.negative = num.negative ^ self1.negative;
                    var len = self1.length + num.length | 0;
                    out.length = len, len = len - 1 | 0;
                    var a = 0 | self1.words[0], b = 0 | num.words[0], r = a * b, lo = 0x3ffffff & r, carry = r / 0x4000000 | 0;
                    out.words[0] = lo;
                    for(var k = 1; k < len; k++){
                        for(var ncarry = carry >>> 26, rword = 0x3ffffff & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
                            var i = k - j | 0;
                            ncarry += (r = (a = 0 | self1.words[i]) * (b = 0 | num.words[j]) + rword) / 0x4000000 | 0, rword = 0x3ffffff & r;
                        }
                        out.words[k] = 0 | rword, carry = 0 | ncarry;
                    }
                    return 0 !== carry ? out.words[k] = 0 | carry : out.length--, out.strip();
                }
                BN.prototype.toString = function(base, padding) {
                    if (padding = 0 | padding || 1, 16 === (base = base || 10) || 'hex' === base) {
                        out = '';
                        for(var out, off = 0, carry = 0, i = 0; i < this.length; i++){
                            var w = this.words[i], word = ((w << off | carry) & 0xffffff).toString(16);
                            out = 0 != (carry = w >>> 24 - off & 0xffffff) || i !== this.length - 1 ? zeros[6 - word.length] + word + out : word + out, (off += 2) >= 26 && (off -= 26, i--);
                        }
                        for(0 !== carry && (out = carry.toString(16) + out); out.length % padding != 0;)out = '0' + out;
                        return 0 !== this.negative && (out = '-' + out), out;
                    }
                    if (base === (0 | base) && base >= 2 && base <= 36) {
                        var groupSize = groupSizes[base], groupBase = groupBases[base];
                        out = '';
                        var c = this.clone();
                        for(c.negative = 0; !c.isZero();){
                            var r = c.modn(groupBase).toString(base);
                            out = (c = c.idivn(groupBase)).isZero() ? r + out : zeros[groupSize - r.length] + r + out;
                        }
                        for(this.isZero() && (out = '0' + out); out.length % padding != 0;)out = '0' + out;
                        return 0 !== this.negative && (out = '-' + out), out;
                    }
                    assert(!1, 'Base should be between 2 and 36');
                }, BN.prototype.toNumber = function() {
                    var ret = this.words[0];
                    return 2 === this.length ? ret += 0x4000000 * this.words[1] : 3 === this.length && 0x01 === this.words[2] ? ret += 0x10000000000000 + 0x4000000 * this.words[1] : this.length > 2 && assert(!1, 'Number can only safely store up to 53 bits'), 0 !== this.negative ? -ret : ret;
                }, BN.prototype.toJSON = function() {
                    return this.toString(16);
                }, BN.prototype.toBuffer = function(endian, length) {
                    return assert(void 0 !== Buffer), this.toArrayLike(Buffer, endian, length);
                }, BN.prototype.toArray = function(endian, length) {
                    return this.toArrayLike(Array, endian, length);
                }, BN.prototype.toArrayLike = function(ArrayType, endian, length) {
                    var b, i, byteLength = this.byteLength(), reqLength = length || Math.max(1, byteLength);
                    assert(byteLength <= reqLength, 'byte array longer than desired length'), assert(reqLength > 0, 'Requested array length <= 0'), this.strip();
                    var littleEndian = 'le' === endian, res = new ArrayType(reqLength), q = this.clone();
                    if (littleEndian) {
                        for(i = 0; !q.isZero(); i++)b = q.andln(0xff), q.iushrn(8), res[i] = b;
                        for(; i < reqLength; i++)res[i] = 0;
                    } else {
                        for(i = 0; i < reqLength - byteLength; i++)res[i] = 0;
                        for(i = 0; !q.isZero(); i++)b = q.andln(0xff), q.iushrn(8), res[reqLength - i - 1] = b;
                    }
                    return res;
                }, Math.clz32 ? BN.prototype._countBits = function(w) {
                    return 32 - Math.clz32(w);
                } : BN.prototype._countBits = function(w) {
                    var t = w, r = 0;
                    return t >= 0x1000 && (r += 13, t >>>= 13), t >= 0x40 && (r += 7, t >>>= 7), t >= 0x8 && (r += 4, t >>>= 4), t >= 0x02 && (r += 2, t >>>= 2), r + t;
                }, BN.prototype._zeroBits = function(w) {
                    if (0 === w) return 26;
                    var t = w, r = 0;
                    return (0x1fff & t) == 0 && (r += 13, t >>>= 13), (0x7f & t) == 0 && (r += 7, t >>>= 7), (0xf & t) == 0 && (r += 4, t >>>= 4), (0x3 & t) == 0 && (r += 2, t >>>= 2), (0x1 & t) == 0 && r++, r;
                }, BN.prototype.bitLength = function() {
                    var w = this.words[this.length - 1], hi = this._countBits(w);
                    return (this.length - 1) * 26 + hi;
                }, BN.prototype.zeroBits = function() {
                    if (this.isZero()) return 0;
                    for(var r = 0, i = 0; i < this.length; i++){
                        var b = this._zeroBits(this.words[i]);
                        if (r += b, 26 !== b) break;
                    }
                    return r;
                }, BN.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8);
                }, BN.prototype.toTwos = function(width) {
                    return 0 !== this.negative ? this.abs().inotn(width).iaddn(1) : this.clone();
                }, BN.prototype.fromTwos = function(width) {
                    return this.testn(width - 1) ? this.notn(width).iaddn(1).ineg() : this.clone();
                }, BN.prototype.isNeg = function() {
                    return 0 !== this.negative;
                }, BN.prototype.neg = function() {
                    return this.clone().ineg();
                }, BN.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1), this;
                }, BN.prototype.iuor = function(num) {
                    for(; this.length < num.length;)this.words[this.length++] = 0;
                    for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
                    return this.strip();
                }, BN.prototype.ior = function(num) {
                    return assert((this.negative | num.negative) == 0), this.iuor(num);
                }, BN.prototype.or = function(num) {
                    return this.length > num.length ? this.clone().ior(num) : num.clone().ior(this);
                }, BN.prototype.uor = function(num) {
                    return this.length > num.length ? this.clone().iuor(num) : num.clone().iuor(this);
                }, BN.prototype.iuand = function(num) {
                    var b;
                    b = this.length > num.length ? num : this;
                    for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
                    return this.length = b.length, this.strip();
                }, BN.prototype.iand = function(num) {
                    return assert((this.negative | num.negative) == 0), this.iuand(num);
                }, BN.prototype.and = function(num) {
                    return this.length > num.length ? this.clone().iand(num) : num.clone().iand(this);
                }, BN.prototype.uand = function(num) {
                    return this.length > num.length ? this.clone().iuand(num) : num.clone().iuand(this);
                }, BN.prototype.iuxor = function(num) {
                    this.length > num.length ? (a = this, b = num) : (a = num, b = this);
                    for(var a, b, i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
                    if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
                    return this.length = a.length, this.strip();
                }, BN.prototype.ixor = function(num) {
                    return assert((this.negative | num.negative) == 0), this.iuxor(num);
                }, BN.prototype.xor = function(num) {
                    return this.length > num.length ? this.clone().ixor(num) : num.clone().ixor(this);
                }, BN.prototype.uxor = function(num) {
                    return this.length > num.length ? this.clone().iuxor(num) : num.clone().iuxor(this);
                }, BN.prototype.inotn = function(width) {
                    assert('number' == typeof width && width >= 0);
                    var bytesNeeded = 0 | Math.ceil(width / 26), bitsLeft = width % 26;
                    this._expand(bytesNeeded), bitsLeft > 0 && bytesNeeded--;
                    for(var i = 0; i < bytesNeeded; i++)this.words[i] = 0x3ffffff & ~this.words[i];
                    return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft), this.strip();
                }, BN.prototype.notn = function(width) {
                    return this.clone().inotn(width);
                }, BN.prototype.setn = function(bit, val) {
                    assert('number' == typeof bit && bit >= 0);
                    var off = bit / 26 | 0, wbit = bit % 26;
                    return this._expand(off + 1), val ? this.words[off] = this.words[off] | 1 << wbit : this.words[off] = this.words[off] & ~(1 << wbit), this.strip();
                }, BN.prototype.iadd = function(num) {
                    if (0 !== this.negative && 0 === num.negative) return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
                    if (0 === this.negative && 0 !== num.negative) return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
                    this.length > num.length ? (a = this, b = num) : (a = num, b = this);
                    for(var r, a, b, carry = 0, i = 0; i < b.length; i++)r = (0 | a.words[i]) + (0 | b.words[i]) + carry, this.words[i] = 0x3ffffff & r, carry = r >>> 26;
                    for(; 0 !== carry && i < a.length; i++)r = (0 | a.words[i]) + carry, this.words[i] = 0x3ffffff & r, carry = r >>> 26;
                    if (this.length = a.length, 0 !== carry) this.words[this.length] = carry, this.length++;
                    else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
                    return this;
                }, BN.prototype.add = function(num) {
                    var res;
                    return 0 !== num.negative && 0 === this.negative ? (num.negative = 0, res = this.sub(num), num.negative ^= 1, res) : 0 === num.negative && 0 !== this.negative ? (this.negative = 0, res = num.sub(this), this.negative = 1, res) : this.length > num.length ? this.clone().iadd(num) : num.clone().iadd(this);
                }, BN.prototype.isub = function(num) {
                    if (0 !== num.negative) {
                        num.negative = 0;
                        var a, b, r = this.iadd(num);
                        return num.negative = 1, r._normSign();
                    }
                    if (0 !== this.negative) return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
                    var cmp = this.cmp(num);
                    if (0 === cmp) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                    cmp > 0 ? (a = this, b = num) : (a = num, b = this);
                    for(var carry = 0, i = 0; i < b.length; i++)carry = (r = (0 | a.words[i]) - (0 | b.words[i]) + carry) >> 26, this.words[i] = 0x3ffffff & r;
                    for(; 0 !== carry && i < a.length; i++)carry = (r = (0 | a.words[i]) + carry) >> 26, this.words[i] = 0x3ffffff & r;
                    if (0 === carry && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
                    return this.length = Math.max(this.length, i), a !== this && (this.negative = 1), this.strip();
                }, BN.prototype.sub = function(num) {
                    return this.clone().isub(num);
                };
                var comb10MulTo = function(self1, num, out) {
                    var lo, mid, hi, a = self1.words, b = num.words, o = out.words, c = 0, a0 = 0 | a[0], al0 = 0x1fff & a0, ah0 = a0 >>> 13, a1 = 0 | a[1], al1 = 0x1fff & a1, ah1 = a1 >>> 13, a2 = 0 | a[2], al2 = 0x1fff & a2, ah2 = a2 >>> 13, a3 = 0 | a[3], al3 = 0x1fff & a3, ah3 = a3 >>> 13, a4 = 0 | a[4], al4 = 0x1fff & a4, ah4 = a4 >>> 13, a5 = 0 | a[5], al5 = 0x1fff & a5, ah5 = a5 >>> 13, a6 = 0 | a[6], al6 = 0x1fff & a6, ah6 = a6 >>> 13, a7 = 0 | a[7], al7 = 0x1fff & a7, ah7 = a7 >>> 13, a8 = 0 | a[8], al8 = 0x1fff & a8, ah8 = a8 >>> 13, a9 = 0 | a[9], al9 = 0x1fff & a9, ah9 = a9 >>> 13, b0 = 0 | b[0], bl0 = 0x1fff & b0, bh0 = b0 >>> 13, b1 = 0 | b[1], bl1 = 0x1fff & b1, bh1 = b1 >>> 13, b2 = 0 | b[2], bl2 = 0x1fff & b2, bh2 = b2 >>> 13, b3 = 0 | b[3], bl3 = 0x1fff & b3, bh3 = b3 >>> 13, b4 = 0 | b[4], bl4 = 0x1fff & b4, bh4 = b4 >>> 13, b5 = 0 | b[5], bl5 = 0x1fff & b5, bh5 = b5 >>> 13, b6 = 0 | b[6], bl6 = 0x1fff & b6, bh6 = b6 >>> 13, b7 = 0 | b[7], bl7 = 0x1fff & b7, bh7 = b7 >>> 13, b8 = 0 | b[8], bl8 = 0x1fff & b8, bh8 = b8 >>> 13, b9 = 0 | b[9], bl9 = 0x1fff & b9, bh9 = b9 >>> 13;
                    out.negative = self1.negative ^ num.negative, out.length = 19;
                    var w0 = (c + (lo = Math.imul(al0, bl0)) | 0) + ((0x1fff & (mid = (mid = Math.imul(al0, bh0)) + Math.imul(ah0, bl0) | 0)) << 13) | 0;
                    c = ((hi = Math.imul(ah0, bh0)) + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 0x3ffffff, lo = Math.imul(al1, bl0), mid = (mid = Math.imul(al1, bh0)) + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0);
                    var w1 = (c + (lo = lo + Math.imul(al0, bl1) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh1) | 0) + Math.imul(ah0, bl1) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh1) | 0) + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 0x3ffffff, lo = Math.imul(al2, bl0), mid = (mid = Math.imul(al2, bh0)) + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = (mid = mid + Math.imul(al1, bh1) | 0) + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0;
                    var w2 = (c + (lo = lo + Math.imul(al0, bl2) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh2) | 0) + Math.imul(ah0, bl2) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh2) | 0) + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 0x3ffffff, lo = Math.imul(al3, bl0), mid = (mid = Math.imul(al3, bh0)) + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = (mid = mid + Math.imul(al2, bh1) | 0) + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = (mid = mid + Math.imul(al1, bh2) | 0) + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0;
                    var w3 = (c + (lo = lo + Math.imul(al0, bl3) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh3) | 0) + Math.imul(ah0, bl3) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh3) | 0) + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 0x3ffffff, lo = Math.imul(al4, bl0), mid = (mid = Math.imul(al4, bh0)) + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = (mid = mid + Math.imul(al3, bh1) | 0) + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = (mid = mid + Math.imul(al2, bh2) | 0) + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = (mid = mid + Math.imul(al1, bh3) | 0) + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0;
                    var w4 = (c + (lo = lo + Math.imul(al0, bl4) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh4) | 0) + Math.imul(ah0, bl4) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh4) | 0) + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 0x3ffffff, lo = Math.imul(al5, bl0), mid = (mid = Math.imul(al5, bh0)) + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = (mid = mid + Math.imul(al4, bh1) | 0) + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = (mid = mid + Math.imul(al3, bh2) | 0) + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = (mid = mid + Math.imul(al2, bh3) | 0) + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = (mid = mid + Math.imul(al1, bh4) | 0) + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0;
                    var w5 = (c + (lo = lo + Math.imul(al0, bl5) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh5) | 0) + Math.imul(ah0, bl5) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh5) | 0) + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 0x3ffffff, lo = Math.imul(al6, bl0), mid = (mid = Math.imul(al6, bh0)) + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = (mid = mid + Math.imul(al5, bh1) | 0) + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = (mid = mid + Math.imul(al4, bh2) | 0) + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = (mid = mid + Math.imul(al3, bh3) | 0) + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = (mid = mid + Math.imul(al2, bh4) | 0) + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = (mid = mid + Math.imul(al1, bh5) | 0) + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0;
                    var w6 = (c + (lo = lo + Math.imul(al0, bl6) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh6) | 0) + Math.imul(ah0, bl6) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh6) | 0) + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 0x3ffffff, lo = Math.imul(al7, bl0), mid = (mid = Math.imul(al7, bh0)) + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = (mid = mid + Math.imul(al6, bh1) | 0) + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = (mid = mid + Math.imul(al5, bh2) | 0) + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = (mid = mid + Math.imul(al4, bh3) | 0) + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = (mid = mid + Math.imul(al3, bh4) | 0) + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = (mid = mid + Math.imul(al2, bh5) | 0) + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = (mid = mid + Math.imul(al1, bh6) | 0) + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0;
                    var w7 = (c + (lo = lo + Math.imul(al0, bl7) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh7) | 0) + Math.imul(ah0, bl7) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh7) | 0) + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 0x3ffffff, lo = Math.imul(al8, bl0), mid = (mid = Math.imul(al8, bh0)) + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = (mid = mid + Math.imul(al7, bh1) | 0) + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = (mid = mid + Math.imul(al6, bh2) | 0) + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = (mid = mid + Math.imul(al5, bh3) | 0) + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = (mid = mid + Math.imul(al4, bh4) | 0) + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = (mid = mid + Math.imul(al3, bh5) | 0) + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = (mid = mid + Math.imul(al2, bh6) | 0) + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = (mid = mid + Math.imul(al1, bh7) | 0) + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0;
                    var w8 = (c + (lo = lo + Math.imul(al0, bl8) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh8) | 0) + Math.imul(ah0, bl8) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh8) | 0) + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 0x3ffffff, lo = Math.imul(al9, bl0), mid = (mid = Math.imul(al9, bh0)) + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = (mid = mid + Math.imul(al8, bh1) | 0) + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = (mid = mid + Math.imul(al7, bh2) | 0) + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = (mid = mid + Math.imul(al6, bh3) | 0) + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = (mid = mid + Math.imul(al5, bh4) | 0) + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = (mid = mid + Math.imul(al4, bh5) | 0) + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = (mid = mid + Math.imul(al3, bh6) | 0) + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = (mid = mid + Math.imul(al2, bh7) | 0) + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = (mid = mid + Math.imul(al1, bh8) | 0) + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0;
                    var w9 = (c + (lo = lo + Math.imul(al0, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al0, bh9) | 0) + Math.imul(ah0, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh9) | 0) + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 0x3ffffff, lo = Math.imul(al9, bl1), mid = (mid = Math.imul(al9, bh1)) + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = (mid = mid + Math.imul(al8, bh2) | 0) + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = (mid = mid + Math.imul(al7, bh3) | 0) + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = (mid = mid + Math.imul(al6, bh4) | 0) + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = (mid = mid + Math.imul(al5, bh5) | 0) + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = (mid = mid + Math.imul(al4, bh6) | 0) + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = (mid = mid + Math.imul(al3, bh7) | 0) + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = (mid = mid + Math.imul(al2, bh8) | 0) + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0;
                    var w10 = (c + (lo = lo + Math.imul(al1, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al1, bh9) | 0) + Math.imul(ah1, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah1, bh9) | 0) + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 0x3ffffff, lo = Math.imul(al9, bl2), mid = (mid = Math.imul(al9, bh2)) + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = (mid = mid + Math.imul(al8, bh3) | 0) + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = (mid = mid + Math.imul(al7, bh4) | 0) + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = (mid = mid + Math.imul(al6, bh5) | 0) + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = (mid = mid + Math.imul(al5, bh6) | 0) + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = (mid = mid + Math.imul(al4, bh7) | 0) + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = (mid = mid + Math.imul(al3, bh8) | 0) + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0;
                    var w11 = (c + (lo = lo + Math.imul(al2, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al2, bh9) | 0) + Math.imul(ah2, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah2, bh9) | 0) + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 0x3ffffff, lo = Math.imul(al9, bl3), mid = (mid = Math.imul(al9, bh3)) + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = (mid = mid + Math.imul(al8, bh4) | 0) + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = (mid = mid + Math.imul(al7, bh5) | 0) + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = (mid = mid + Math.imul(al6, bh6) | 0) + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = (mid = mid + Math.imul(al5, bh7) | 0) + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = (mid = mid + Math.imul(al4, bh8) | 0) + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0;
                    var w12 = (c + (lo = lo + Math.imul(al3, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al3, bh9) | 0) + Math.imul(ah3, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah3, bh9) | 0) + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 0x3ffffff, lo = Math.imul(al9, bl4), mid = (mid = Math.imul(al9, bh4)) + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = (mid = mid + Math.imul(al8, bh5) | 0) + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = (mid = mid + Math.imul(al7, bh6) | 0) + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = (mid = mid + Math.imul(al6, bh7) | 0) + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = (mid = mid + Math.imul(al5, bh8) | 0) + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0;
                    var w13 = (c + (lo = lo + Math.imul(al4, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al4, bh9) | 0) + Math.imul(ah4, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah4, bh9) | 0) + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 0x3ffffff, lo = Math.imul(al9, bl5), mid = (mid = Math.imul(al9, bh5)) + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = (mid = mid + Math.imul(al8, bh6) | 0) + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = (mid = mid + Math.imul(al7, bh7) | 0) + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = (mid = mid + Math.imul(al6, bh8) | 0) + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0;
                    var w14 = (c + (lo = lo + Math.imul(al5, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al5, bh9) | 0) + Math.imul(ah5, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah5, bh9) | 0) + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 0x3ffffff, lo = Math.imul(al9, bl6), mid = (mid = Math.imul(al9, bh6)) + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = (mid = mid + Math.imul(al8, bh7) | 0) + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = (mid = mid + Math.imul(al7, bh8) | 0) + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0;
                    var w15 = (c + (lo = lo + Math.imul(al6, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al6, bh9) | 0) + Math.imul(ah6, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah6, bh9) | 0) + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 0x3ffffff, lo = Math.imul(al9, bl7), mid = (mid = Math.imul(al9, bh7)) + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = (mid = mid + Math.imul(al8, bh8) | 0) + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0;
                    var w16 = (c + (lo = lo + Math.imul(al7, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al7, bh9) | 0) + Math.imul(ah7, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah7, bh9) | 0) + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 0x3ffffff, lo = Math.imul(al9, bl8), mid = (mid = Math.imul(al9, bh8)) + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8);
                    var w17 = (c + (lo = lo + Math.imul(al8, bl9) | 0) | 0) + ((0x1fff & (mid = (mid = mid + Math.imul(al8, bh9) | 0) + Math.imul(ah8, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah8, bh9) | 0) + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 0x3ffffff;
                    var w18 = (c + (lo = Math.imul(al9, bl9)) | 0) + ((0x1fff & (mid = (mid = Math.imul(al9, bh9)) + Math.imul(ah9, bl9) | 0)) << 13) | 0;
                    return c = ((hi = Math.imul(ah9, bh9)) + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 0x3ffffff, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, 0 !== c && (o[19] = c, out.length++), out;
                };
                function bigMulTo(self1, num, out) {
                    out.negative = num.negative ^ self1.negative, out.length = self1.length + num.length;
                    for(var carry = 0, hncarry = 0, k = 0; k < out.length - 1; k++){
                        var ncarry = hncarry;
                        hncarry = 0;
                        for(var rword = 0x3ffffff & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
                            var i = k - j, r = (0 | self1.words[i]) * (0 | num.words[j]), lo = 0x3ffffff & r;
                            ncarry = ncarry + (r / 0x4000000 | 0) | 0, rword = 0x3ffffff & (lo = lo + rword | 0), hncarry += (ncarry = ncarry + (lo >>> 26) | 0) >>> 26, ncarry &= 0x3ffffff;
                        }
                        out.words[k] = rword, carry = ncarry, ncarry = hncarry;
                    }
                    return 0 !== carry ? out.words[k] = carry : out.length--, out.strip();
                }
                function jumboMulTo(self1, num, out) {
                    return new FFTM().mulp(self1, num, out);
                }
                function FFTM(x, y) {
                    this.x = x, this.y = y;
                }
                Math.imul || (comb10MulTo = smallMulTo), BN.prototype.mulTo = function(num, out) {
                    var len = this.length + num.length;
                    return 10 === this.length && 10 === num.length ? comb10MulTo(this, num, out) : len < 63 ? smallMulTo(this, num, out) : len < 1024 ? bigMulTo(this, num, out) : jumboMulTo(this, num, out);
                }, FFTM.prototype.makeRBT = function(N) {
                    for(var t = Array(N), l = BN.prototype._countBits(N) - 1, i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
                    return t;
                }, FFTM.prototype.revBin = function(x, l, N) {
                    if (0 === x || x === N - 1) return x;
                    for(var rb = 0, i = 0; i < l; i++)rb |= (1 & x) << l - i - 1, x >>= 1;
                    return rb;
                }, FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {
                    for(var i = 0; i < N; i++)rtws[i] = rws[rbt[i]], itws[i] = iws[rbt[i]];
                }, FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {
                    this.permute(rbt, rws, iws, rtws, itws, N);
                    for(var s = 1; s < N; s <<= 1)for(var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l), p = 0; p < N; p += l)for(var rtwdf_ = rtwdf, itwdf_ = itwdf, j = 0; j < s; j++){
                        var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
                        io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l && (rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx);
                    }
                }, FFTM.prototype.guessLen13b = function(n, m) {
                    var N = 1 | Math.max(m, n), odd = 1 & N, i = 0;
                    for(N = N / 2 | 0; N; N >>>= 1)i++;
                    return 1 << i + 1 + odd;
                }, FFTM.prototype.conjugate = function(rws, iws, N) {
                    if (!(N <= 1)) for(var i = 0; i < N / 2; i++){
                        var t = rws[i];
                        rws[i] = rws[N - i - 1], rws[N - i - 1] = t, t = iws[i], iws[i] = -iws[N - i - 1], iws[N - i - 1] = -t;
                    }
                }, FFTM.prototype.normalize13b = function(ws, N) {
                    for(var carry = 0, i = 0; i < N / 2; i++){
                        var w = 0x2000 * Math.round(ws[2 * i + 1] / N) + Math.round(ws[2 * i] / N) + carry;
                        ws[i] = 0x3ffffff & w, carry = w < 0x4000000 ? 0 : w / 0x4000000 | 0;
                    }
                    return ws;
                }, FFTM.prototype.convert13b = function(ws, len, rws, N) {
                    for(var carry = 0, i = 0; i < len; i++)carry += 0 | ws[i], rws[2 * i] = 0x1fff & carry, carry >>>= 13, rws[2 * i + 1] = 0x1fff & carry, carry >>>= 13;
                    for(i = 2 * len; i < N; ++i)rws[i] = 0;
                    assert(0 === carry), assert((-8192 & carry) == 0);
                }, FFTM.prototype.stub = function(N) {
                    for(var ph = Array(N), i = 0; i < N; i++)ph[i] = 0;
                    return ph;
                }, FFTM.prototype.mulp = function(x, y, out) {
                    var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = Array(N), rwst = Array(N), iwst = Array(N), nrws = Array(N), nrwst = Array(N), niwst = Array(N), rmws = out.words;
                    rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
                    for(var i = 0; i < N; i++){
                        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i], rwst[i] = rx;
                    }
                    return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
                }, BN.prototype.mul = function(num) {
                    var out = new BN(null);
                    return out.words = Array(this.length + num.length), this.mulTo(num, out);
                }, BN.prototype.mulf = function(num) {
                    var out = new BN(null);
                    return out.words = Array(this.length + num.length), jumboMulTo(this, num, out);
                }, BN.prototype.imul = function(num) {
                    return this.clone().mulTo(num, this);
                }, BN.prototype.imuln = function(num) {
                    assert('number' == typeof num), assert(num < 0x4000000);
                    for(var carry = 0, i = 0; i < this.length; i++){
                        var w = (0 | this.words[i]) * num, lo = (0x3ffffff & w) + (0x3ffffff & carry);
                        carry >>= 26, carry += w / 0x4000000 | 0, carry += lo >>> 26, this.words[i] = 0x3ffffff & lo;
                    }
                    return 0 !== carry && (this.words[i] = carry, this.length++), this;
                }, BN.prototype.muln = function(num) {
                    return this.clone().imuln(num);
                }, BN.prototype.sqr = function() {
                    return this.mul(this);
                }, BN.prototype.isqr = function() {
                    return this.imul(this.clone());
                }, BN.prototype.pow = function(num) {
                    var w = toBitArray(num);
                    if (0 === w.length) return new BN(1);
                    for(var res = this, i = 0; i < w.length && 0 === w[i]; i++, res = res.sqr());
                    if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr())0 !== w[i] && (res = res.mul(q));
                    return res;
                }, BN.prototype.iushln = function(bits) {
                    assert('number' == typeof bits && bits >= 0);
                    var i, r = bits % 26, s = (bits - r) / 26, carryMask = 0x3ffffff >>> 26 - r << 26 - r;
                    if (0 !== r) {
                        var carry = 0;
                        for(i = 0; i < this.length; i++){
                            var newCarry = this.words[i] & carryMask, c = (0 | this.words[i]) - newCarry << r;
                            this.words[i] = c | carry, carry = newCarry >>> 26 - r;
                        }
                        carry && (this.words[i] = carry, this.length++);
                    }
                    if (0 !== s) {
                        for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
                        for(i = 0; i < s; i++)this.words[i] = 0;
                        this.length += s;
                    }
                    return this.strip();
                }, BN.prototype.ishln = function(bits) {
                    return assert(0 === this.negative), this.iushln(bits);
                }, BN.prototype.iushrn = function(bits, hint, extended) {
                    assert('number' == typeof bits && bits >= 0), h = hint ? (hint - hint % 26) / 26 : 0;
                    var h, r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 0x3ffffff ^ 0x3ffffff >>> r << r, maskedWords = extended;
                    if (h -= s, h = Math.max(0, h), maskedWords) {
                        for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
                        maskedWords.length = s;
                    }
                    if (0 === s) ;
                    else if (this.length > s) for(this.length -= s, i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
                    else this.words[0] = 0, this.length = 1;
                    var carry = 0;
                    for(i = this.length - 1; i >= 0 && (0 !== carry || i >= h); i--){
                        var word = 0 | this.words[i];
                        this.words[i] = carry << 26 - r | word >>> r, carry = word & mask;
                    }
                    return maskedWords && 0 !== carry && (maskedWords.words[maskedWords.length++] = carry), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
                }, BN.prototype.ishrn = function(bits, hint, extended) {
                    return assert(0 === this.negative), this.iushrn(bits, hint, extended);
                }, BN.prototype.shln = function(bits) {
                    return this.clone().ishln(bits);
                }, BN.prototype.ushln = function(bits) {
                    return this.clone().iushln(bits);
                }, BN.prototype.shrn = function(bits) {
                    return this.clone().ishrn(bits);
                }, BN.prototype.ushrn = function(bits) {
                    return this.clone().iushrn(bits);
                }, BN.prototype.testn = function(bit) {
                    assert('number' == typeof bit && bit >= 0);
                    var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
                    return !(this.length <= s) && !!(this.words[s] & q);
                }, BN.prototype.imaskn = function(bits) {
                    assert('number' == typeof bits && bits >= 0);
                    var r = bits % 26, s = (bits - r) / 26;
                    if (assert(0 === this.negative, 'imaskn works only with positive numbers'), this.length <= s) return this;
                    if (0 !== r && s++, this.length = Math.min(s, this.length), 0 !== r) {
                        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
                        this.words[this.length - 1] &= mask;
                    }
                    return this.strip();
                }, BN.prototype.maskn = function(bits) {
                    return this.clone().imaskn(bits);
                }, BN.prototype.iaddn = function(num) {
                    return (assert('number' == typeof num), assert(num < 0x4000000), num < 0) ? this.isubn(-num) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < num ? (this.words[0] = num - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(num), this.negative = 1, this) : this._iaddn(num);
                }, BN.prototype._iaddn = function(num) {
                    this.words[0] += num;
                    for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++)this.words[i] -= 0x4000000, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
                    return this.length = Math.max(this.length, i + 1), this;
                }, BN.prototype.isubn = function(num) {
                    if (assert('number' == typeof num), assert(num < 0x4000000), num < 0) return this.iaddn(-num);
                    if (0 !== this.negative) return this.negative = 0, this.iaddn(num), this.negative = 1, this;
                    if (this.words[0] -= num, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                    else for(var i = 0; i < this.length && this.words[i] < 0; i++)this.words[i] += 0x4000000, this.words[i + 1] -= 1;
                    return this.strip();
                }, BN.prototype.addn = function(num) {
                    return this.clone().iaddn(num);
                }, BN.prototype.subn = function(num) {
                    return this.clone().isubn(num);
                }, BN.prototype.iabs = function() {
                    return this.negative = 0, this;
                }, BN.prototype.abs = function() {
                    return this.clone().iabs();
                }, BN.prototype._ishlnsubmul = function(num, mul, shift) {
                    var i, w, len = num.length + shift;
                    this._expand(len);
                    var carry = 0;
                    for(i = 0; i < num.length; i++){
                        w = (0 | this.words[i + shift]) + carry;
                        var right = (0 | num.words[i]) * mul;
                        w -= 0x3ffffff & right, carry = (w >> 26) - (right / 0x4000000 | 0), this.words[i + shift] = 0x3ffffff & w;
                    }
                    for(; i < this.length - shift; i++)carry = (w = (0 | this.words[i + shift]) + carry) >> 26, this.words[i + shift] = 0x3ffffff & w;
                    if (0 === carry) return this.strip();
                    for(assert(-1 === carry), carry = 0, i = 0; i < this.length; i++)carry = (w = -(0 | this.words[i]) + carry) >> 26, this.words[i] = 0x3ffffff & w;
                    return this.negative = 1, this.strip();
                }, BN.prototype._wordDiv = function(num, mode) {
                    var q, shift = this.length - num.length, a = this.clone(), b = num, bhi = 0 | b.words[b.length - 1];
                    0 != (shift = 26 - this._countBits(bhi)) && (b = b.ushln(shift), a.iushln(shift), bhi = 0 | b.words[b.length - 1]);
                    var m = a.length - b.length;
                    if ('mod' !== mode) {
                        (q = new BN(null)).length = m + 1, q.words = Array(q.length);
                        for(var i = 0; i < q.length; i++)q.words[i] = 0;
                    }
                    var diff = a.clone()._ishlnsubmul(b, 1, m);
                    0 === diff.negative && (a = diff, q && (q.words[m] = 1));
                    for(var j = m - 1; j >= 0; j--){
                        var qj = (0 | a.words[b.length + j]) * 0x4000000 + (0 | a.words[b.length + j - 1]);
                        for(qj = Math.min(qj / bhi | 0, 0x3ffffff), a._ishlnsubmul(b, qj, j); 0 !== a.negative;)qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), a.isZero() || (a.negative ^= 1);
                        q && (q.words[j] = qj);
                    }
                    return q && q.strip(), a.strip(), 'div' !== mode && 0 !== shift && a.iushrn(shift), {
                        div: q || null,
                        mod: a
                    };
                }, BN.prototype.divmod = function(num, mode, positive) {
                    var div, mod, res;
                    return (assert(!num.isZero()), this.isZero()) ? {
                        div: new BN(0),
                        mod: new BN(0)
                    } : 0 !== this.negative && 0 === num.negative ? (res = this.neg().divmod(num, mode), 'mod' !== mode && (div = res.div.neg()), 'div' !== mode && (mod = res.mod.neg(), positive && 0 !== mod.negative && mod.iadd(num)), {
                        div: div,
                        mod: mod
                    }) : 0 === this.negative && 0 !== num.negative ? (res = this.divmod(num.neg(), mode), 'mod' !== mode && (div = res.div.neg()), {
                        div: div,
                        mod: res.mod
                    }) : (this.negative & num.negative) != 0 ? (res = this.neg().divmod(num.neg(), mode), 'div' !== mode && (mod = res.mod.neg(), positive && 0 !== mod.negative && mod.isub(num)), {
                        div: res.div,
                        mod: mod
                    }) : num.length > this.length || 0 > this.cmp(num) ? {
                        div: new BN(0),
                        mod: this
                    } : 1 === num.length ? 'div' === mode ? {
                        div: this.divn(num.words[0]),
                        mod: null
                    } : 'mod' === mode ? {
                        div: null,
                        mod: new BN(this.modn(num.words[0]))
                    } : {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                    } : this._wordDiv(num, mode);
                }, BN.prototype.div = function(num) {
                    return this.divmod(num, 'div', !1).div;
                }, BN.prototype.mod = function(num) {
                    return this.divmod(num, 'mod', !1).mod;
                }, BN.prototype.umod = function(num) {
                    return this.divmod(num, 'mod', !0).mod;
                }, BN.prototype.divRound = function(num) {
                    var dm = this.divmod(num);
                    if (dm.mod.isZero()) return dm.div;
                    var mod = 0 !== dm.div.negative ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
                    return cmp < 0 || 1 === r2 && 0 === cmp ? dm.div : 0 !== dm.div.negative ? dm.div.isubn(1) : dm.div.iaddn(1);
                }, BN.prototype.modn = function(num) {
                    assert(num <= 0x3ffffff);
                    for(var p = 67108864 % num, acc = 0, i = this.length - 1; i >= 0; i--)acc = (p * acc + (0 | this.words[i])) % num;
                    return acc;
                }, BN.prototype.idivn = function(num) {
                    assert(num <= 0x3ffffff);
                    for(var carry = 0, i = this.length - 1; i >= 0; i--){
                        var w = (0 | this.words[i]) + 0x4000000 * carry;
                        this.words[i] = w / num | 0, carry = w % num;
                    }
                    return this.strip();
                }, BN.prototype.divn = function(num) {
                    return this.clone().idivn(num);
                }, BN.prototype.egcd = function(p) {
                    assert(0 === p.negative), assert(!p.isZero());
                    var x = this, y = p.clone();
                    x = 0 !== x.negative ? x.umod(p) : x.clone();
                    for(var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0; x.isEven() && y.isEven();)x.iushrn(1), y.iushrn(1), ++g;
                    for(var yp = y.clone(), xp = x.clone(); !x.isZero();){
                        for(var i = 0, im = 1; (x.words[0] & im) == 0 && i < 26; ++i, im <<= 1);
                        if (i > 0) for(x.iushrn(i); i-- > 0;)(A.isOdd() || B.isOdd()) && (A.iadd(yp), B.isub(xp)), A.iushrn(1), B.iushrn(1);
                        for(var j = 0, jm = 1; (y.words[0] & jm) == 0 && j < 26; ++j, jm <<= 1);
                        if (j > 0) for(y.iushrn(j); j-- > 0;)(C.isOdd() || D.isOdd()) && (C.iadd(yp), D.isub(xp)), C.iushrn(1), D.iushrn(1);
                        x.cmp(y) >= 0 ? (x.isub(y), A.isub(C), B.isub(D)) : (y.isub(x), C.isub(A), D.isub(B));
                    }
                    return {
                        a: C,
                        b: D,
                        gcd: y.iushln(g)
                    };
                }, BN.prototype._invmp = function(p) {
                    assert(0 === p.negative), assert(!p.isZero());
                    var res, a = this, b = p.clone();
                    a = 0 !== a.negative ? a.umod(p) : a.clone();
                    for(var x1 = new BN(1), x2 = new BN(0), delta = b.clone(); a.cmpn(1) > 0 && b.cmpn(1) > 0;){
                        for(var i = 0, im = 1; (a.words[0] & im) == 0 && i < 26; ++i, im <<= 1);
                        if (i > 0) for(a.iushrn(i); i-- > 0;)x1.isOdd() && x1.iadd(delta), x1.iushrn(1);
                        for(var j = 0, jm = 1; (b.words[0] & jm) == 0 && j < 26; ++j, jm <<= 1);
                        if (j > 0) for(b.iushrn(j); j-- > 0;)x2.isOdd() && x2.iadd(delta), x2.iushrn(1);
                        a.cmp(b) >= 0 ? (a.isub(b), x1.isub(x2)) : (b.isub(a), x2.isub(x1));
                    }
                    return 0 > (res = 0 === a.cmpn(1) ? x1 : x2).cmpn(0) && res.iadd(p), res;
                }, BN.prototype.gcd = function(num) {
                    if (this.isZero()) return num.abs();
                    if (num.isZero()) return this.abs();
                    var a = this.clone(), b = num.clone();
                    a.negative = 0, b.negative = 0;
                    for(var shift = 0; a.isEven() && b.isEven(); shift++)a.iushrn(1), b.iushrn(1);
                    for(;;){
                        for(; a.isEven();)a.iushrn(1);
                        for(; b.isEven();)b.iushrn(1);
                        var r = a.cmp(b);
                        if (r < 0) {
                            var t = a;
                            a = b, b = t;
                        } else if (0 === r || 0 === b.cmpn(1)) break;
                        a.isub(b);
                    }
                    return b.iushln(shift);
                }, BN.prototype.invm = function(num) {
                    return this.egcd(num).a.umod(num);
                }, BN.prototype.isEven = function() {
                    return (1 & this.words[0]) == 0;
                }, BN.prototype.isOdd = function() {
                    return (1 & this.words[0]) == 1;
                }, BN.prototype.andln = function(num) {
                    return this.words[0] & num;
                }, BN.prototype.bincn = function(bit) {
                    assert('number' == typeof bit);
                    var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
                    if (this.length <= s) return this._expand(s + 1), this.words[s] |= q, this;
                    for(var carry = q, i = s; 0 !== carry && i < this.length; i++){
                        var w = 0 | this.words[i];
                        w += carry, carry = w >>> 26, w &= 0x3ffffff, this.words[i] = w;
                    }
                    return 0 !== carry && (this.words[i] = carry, this.length++), this;
                }, BN.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0];
                }, BN.prototype.cmpn = function(num) {
                    var res, negative = num < 0;
                    if (0 !== this.negative && !negative) return -1;
                    if (0 === this.negative && negative) return 1;
                    if (this.strip(), this.length > 1) res = 1;
                    else {
                        negative && (num = -num), assert(num <= 0x3ffffff, 'Number is too big');
                        var w = 0 | this.words[0];
                        res = w === num ? 0 : w < num ? -1 : 1;
                    }
                    return 0 !== this.negative ? 0 | -res : res;
                }, BN.prototype.cmp = function(num) {
                    if (0 !== this.negative && 0 === num.negative) return -1;
                    if (0 === this.negative && 0 !== num.negative) return 1;
                    var res = this.ucmp(num);
                    return 0 !== this.negative ? 0 | -res : res;
                }, BN.prototype.ucmp = function(num) {
                    if (this.length > num.length) return 1;
                    if (this.length < num.length) return -1;
                    for(var res = 0, i = this.length - 1; i >= 0; i--){
                        var a = 0 | this.words[i], b = 0 | num.words[i];
                        if (a !== b) {
                            a < b ? res = -1 : a > b && (res = 1);
                            break;
                        }
                    }
                    return res;
                }, BN.prototype.gtn = function(num) {
                    return 1 === this.cmpn(num);
                }, BN.prototype.gt = function(num) {
                    return 1 === this.cmp(num);
                }, BN.prototype.gten = function(num) {
                    return this.cmpn(num) >= 0;
                }, BN.prototype.gte = function(num) {
                    return this.cmp(num) >= 0;
                }, BN.prototype.ltn = function(num) {
                    return -1 === this.cmpn(num);
                }, BN.prototype.lt = function(num) {
                    return -1 === this.cmp(num);
                }, BN.prototype.lten = function(num) {
                    return 0 >= this.cmpn(num);
                }, BN.prototype.lte = function(num) {
                    return 0 >= this.cmp(num);
                }, BN.prototype.eqn = function(num) {
                    return 0 === this.cmpn(num);
                }, BN.prototype.eq = function(num) {
                    return 0 === this.cmp(num);
                }, BN.red = function(num) {
                    return new Red(num);
                }, BN.prototype.toRed = function(ctx) {
                    return assert(!this.red, 'Already a number in reduction context'), assert(0 === this.negative, 'red works only with positives'), ctx.convertTo(this)._forceRed(ctx);
                }, BN.prototype.fromRed = function() {
                    return assert(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this);
                }, BN.prototype._forceRed = function(ctx) {
                    return this.red = ctx, this;
                }, BN.prototype.forceRed = function(ctx) {
                    return assert(!this.red, 'Already a number in reduction context'), this._forceRed(ctx);
                }, BN.prototype.redAdd = function(num) {
                    return assert(this.red, 'redAdd works only with red numbers'), this.red.add(this, num);
                }, BN.prototype.redIAdd = function(num) {
                    return assert(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, num);
                }, BN.prototype.redSub = function(num) {
                    return assert(this.red, 'redSub works only with red numbers'), this.red.sub(this, num);
                }, BN.prototype.redISub = function(num) {
                    return assert(this.red, 'redISub works only with red numbers'), this.red.isub(this, num);
                }, BN.prototype.redShl = function(num) {
                    return assert(this.red, 'redShl works only with red numbers'), this.red.shl(this, num);
                }, BN.prototype.redMul = function(num) {
                    return assert(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num), this.red.mul(this, num);
                }, BN.prototype.redIMul = function(num) {
                    return assert(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num), this.red.imul(this, num);
                }, BN.prototype.redSqr = function() {
                    return assert(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this);
                }, BN.prototype.redISqr = function() {
                    return assert(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this);
                }, BN.prototype.redSqrt = function() {
                    return assert(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this);
                }, BN.prototype.redInvm = function() {
                    return assert(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this);
                }, BN.prototype.redNeg = function() {
                    return assert(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this);
                }, BN.prototype.redPow = function(num) {
                    return assert(this.red && !num.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, num);
                };
                var primes = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                function MPrime(name, p) {
                    this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
                }
                function K256() {
                    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
                }
                function P224() {
                    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
                }
                function P192() {
                    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
                }
                function P25519() {
                    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
                }
                function Red(m) {
                    if ('string' == typeof m) {
                        var prime = BN._prime(m);
                        this.m = prime.p, this.prime = prime;
                    } else assert(m.gtn(1), 'modulus must be greater than 1'), this.m = m, this.prime = null;
                }
                function Mont(m) {
                    Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
                }
                MPrime.prototype._tmp = function() {
                    var tmp = new BN(null);
                    return tmp.words = Array(Math.ceil(this.n / 13)), tmp;
                }, MPrime.prototype.ireduce = function(num) {
                    var rlen, r = num;
                    do this.split(r, this.tmp), rlen = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength();
                    while (rlen > this.n)
                    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                    return 0 === cmp ? (r.words[0] = 0, r.length = 1) : cmp > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r;
                }, MPrime.prototype.split = function(input, out) {
                    input.iushrn(this.n, 0, out);
                }, MPrime.prototype.imulK = function(num) {
                    return num.imul(this.k);
                }, inherits(K256, MPrime), K256.prototype.split = function(input, output) {
                    for(var mask = 0x3fffff, outLen = Math.min(input.length, 9), i = 0; i < outLen; i++)output.words[i] = input.words[i];
                    if (output.length = outLen, input.length <= 9) {
                        input.words[0] = 0, input.length = 1;
                        return;
                    }
                    var prev = input.words[9];
                    for(i = 10, output.words[output.length++] = prev & mask; i < input.length; i++){
                        var next = 0 | input.words[i];
                        input.words[i - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
                    }
                    prev >>>= 22, input.words[i - 10] = prev, 0 === prev && input.length > 10 ? input.length -= 10 : input.length -= 9;
                }, K256.prototype.imulK = function(num) {
                    num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
                    for(var lo = 0, i = 0; i < num.length; i++){
                        var w = 0 | num.words[i];
                        lo += 0x3d1 * w, num.words[i] = 0x3ffffff & lo, lo = 0x40 * w + (lo / 0x4000000 | 0);
                    }
                    return 0 === num.words[num.length - 1] && (num.length--, 0 === num.words[num.length - 1] && num.length--), num;
                }, inherits(P224, MPrime), inherits(P192, MPrime), inherits(P25519, MPrime), P25519.prototype.imulK = function(num) {
                    for(var carry = 0, i = 0; i < num.length; i++){
                        var hi = (0 | num.words[i]) * 0x13 + carry, lo = 0x3ffffff & hi;
                        hi >>>= 26, num.words[i] = lo, carry = hi;
                    }
                    return 0 !== carry && (num.words[num.length++] = carry), num;
                }, BN._prime = function(name) {
                    var prime;
                    if (primes[name]) return primes[name];
                    if ('k256' === name) prime = new K256();
                    else if ('p224' === name) prime = new P224();
                    else if ('p192' === name) prime = new P192();
                    else if ('p25519' === name) prime = new P25519();
                    else throw Error('Unknown prime ' + name);
                    return primes[name] = prime, prime;
                }, Red.prototype._verify1 = function(a) {
                    assert(0 === a.negative, 'red works only with positives'), assert(a.red, 'red works only with red numbers');
                }, Red.prototype._verify2 = function(a, b) {
                    assert((a.negative | b.negative) == 0, 'red works only with positives'), assert(a.red && a.red === b.red, 'red works only with red numbers');
                }, Red.prototype.imod = function(a) {
                    return this.prime ? this.prime.ireduce(a)._forceRed(this) : a.umod(this.m)._forceRed(this);
                }, Red.prototype.neg = function(a) {
                    return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
                }, Red.prototype.add = function(a, b) {
                    this._verify2(a, b);
                    var res = a.add(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m), res._forceRed(this);
                }, Red.prototype.iadd = function(a, b) {
                    this._verify2(a, b);
                    var res = a.iadd(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m), res;
                }, Red.prototype.sub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.sub(b);
                    return 0 > res.cmpn(0) && res.iadd(this.m), res._forceRed(this);
                }, Red.prototype.isub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.isub(b);
                    return 0 > res.cmpn(0) && res.iadd(this.m), res;
                }, Red.prototype.shl = function(a, num) {
                    return this._verify1(a), this.imod(a.ushln(num));
                }, Red.prototype.imul = function(a, b) {
                    return this._verify2(a, b), this.imod(a.imul(b));
                }, Red.prototype.mul = function(a, b) {
                    return this._verify2(a, b), this.imod(a.mul(b));
                }, Red.prototype.isqr = function(a) {
                    return this.imul(a, a.clone());
                }, Red.prototype.sqr = function(a) {
                    return this.mul(a, a);
                }, Red.prototype.sqrt = function(a) {
                    if (a.isZero()) return a.clone();
                    var mod3 = this.m.andln(3);
                    if (assert(mod3 % 2 == 1), 3 === mod3) {
                        var pow = this.m.add(new BN(1)).iushrn(2);
                        return this.pow(a, pow);
                    }
                    for(var q = this.m.subn(1), s = 0; !q.isZero() && 0 === q.andln(1);)s++, q.iushrn(1);
                    assert(!q.isZero());
                    var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
                    for(z = new BN(2 * z * z).toRed(this); 0 !== this.pow(z, lpow).cmp(nOne);)z.redIAdd(nOne);
                    for(var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s; 0 !== t.cmp(one);){
                        for(var tmp = t, i = 0; 0 !== tmp.cmp(one); i++)tmp = tmp.redSqr();
                        assert(i < m);
                        var b = this.pow(c, new BN(1).iushln(m - i - 1));
                        r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i;
                    }
                    return r;
                }, Red.prototype.invm = function(a) {
                    var inv = a._invmp(this.m);
                    return 0 !== inv.negative ? (inv.negative = 0, this.imod(inv).redNeg()) : this.imod(inv);
                }, Red.prototype.pow = function(a, num) {
                    if (num.isZero()) return new BN(1).toRed(this);
                    if (0 === num.cmpn(1)) return a.clone();
                    var windowSize = 4, wnd = Array(1 << windowSize);
                    wnd[0] = new BN(1).toRed(this), wnd[1] = a;
                    for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
                    var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
                    for(0 === start && (start = 26), i = num.length - 1; i >= 0; i--){
                        for(var word = num.words[i], j = start - 1; j >= 0; j--){
                            var bit = word >> j & 1;
                            if (res !== wnd[0] && (res = this.sqr(res)), 0 === bit && 0 === current) {
                                currentLen = 0;
                                continue;
                            }
                            current <<= 1, current |= bit, (++currentLen === windowSize || 0 === i && 0 === j) && (res = this.mul(res, wnd[current]), currentLen = 0, current = 0);
                        }
                        start = 26;
                    }
                    return res;
                }, Red.prototype.convertTo = function(num) {
                    var r = num.umod(this.m);
                    return r === num ? r.clone() : r;
                }, Red.prototype.convertFrom = function(num) {
                    var res = num.clone();
                    return res.red = null, res;
                }, BN.mont = function(num) {
                    return new Mont(num);
                }, inherits(Mont, Red), Mont.prototype.convertTo = function(num) {
                    return this.imod(num.ushln(this.shift));
                }, Mont.prototype.convertFrom = function(num) {
                    var r = this.imod(num.mul(this.rinv));
                    return r.red = null, r;
                }, Mont.prototype.imul = function(a, b) {
                    if (a.isZero() || b.isZero()) return a.words[0] = 0, a.length = 1, a;
                    var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : 0 > u.cmpn(0) && (res = u.iadd(this.m)), res._forceRed(this);
                }, Mont.prototype.mul = function(a, b) {
                    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
                    var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : 0 > u.cmpn(0) && (res = u.iadd(this.m)), res._forceRed(this);
                }, Mont.prototype.invm = function(a) {
                    return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this);
                };
            }(module = __webpack_require__.nmd(module), this);
        },
        9931: function(module, __unused_webpack_exports, __webpack_require__) {
            var r;
            function Rand(rand) {
                this.rand = rand;
            }
            if (module.exports = function(len) {
                return r || (r = new Rand(null)), r.generate(len);
            }, module.exports.Rand = Rand, Rand.prototype.generate = function(len) {
                return this._rand(len);
            }, Rand.prototype._rand = function(n) {
                if (this.rand.getBytes) return this.rand.getBytes(n);
                for(var res = new Uint8Array(n), i = 0; i < res.length; i++)res[i] = this.rand.getByte();
                return res;
            }, 'object' == typeof self) self.crypto && self.crypto.getRandomValues ? Rand.prototype._rand = function(n) {
                var arr = new Uint8Array(n);
                return self.crypto.getRandomValues(arr), arr;
            } : self.msCrypto && self.msCrypto.getRandomValues ? Rand.prototype._rand = function(n) {
                var arr = new Uint8Array(n);
                return self.msCrypto.getRandomValues(arr), arr;
            } : 'object' == typeof window && (Rand.prototype._rand = function() {
                throw Error('Not implemented yet');
            });
            else try {
                var crypto1 = __webpack_require__(9214);
                if ('function' != typeof crypto1.randomBytes) throw Error('Not supported');
                Rand.prototype._rand = function(n) {
                    return crypto1.randomBytes(n);
                };
            } catch (e) {}
        },
        1708: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { AbstractLevel  } = __webpack_require__(875), ModuleError = __webpack_require__(4473), parallel = __webpack_require__(9967), { fromCallback  } = __webpack_require__(6957), { Iterator  } = __webpack_require__(8212), deserialize = __webpack_require__(9687), clear = __webpack_require__(7753), createKeyRange = __webpack_require__(1217), DEFAULT_PREFIX = 'level-js-', kIDB = Symbol('idb'), kNamePrefix = Symbol('namePrefix'), kLocation = Symbol('location'), kVersion = Symbol('version'), kStore = Symbol('store'), kOnComplete = Symbol('onComplete'), kPromise = Symbol('promise');
            class BrowserLevel extends AbstractLevel {
                constructor(location, options, _){
                    if ('function' == typeof options || 'function' == typeof _) throw new ModuleError('The levelup-style callback argument has been removed', {
                        code: 'LEVEL_LEGACY'
                    });
                    const { prefix , version , ...forward } = options || {};
                    if (super({
                        encodings: {
                            view: !0
                        },
                        snapshots: !1,
                        createIfMissing: !1,
                        errorIfExists: !1,
                        seek: !0
                    }, forward), 'string' != typeof location) throw Error('constructor requires a location string argument');
                    this[kLocation] = location, this[kNamePrefix] = null == prefix ? DEFAULT_PREFIX : prefix, this[kVersion] = parseInt(version || 1, 10), this[kIDB] = null;
                }
                get location() {
                    return this[kLocation];
                }
                get namePrefix() {
                    return this[kNamePrefix];
                }
                get version() {
                    return this[kVersion];
                }
                get db() {
                    return this[kIDB];
                }
                get type() {
                    return 'browser-level';
                }
                _open(options, callback) {
                    const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
                    req.onerror = function() {
                        callback(req.error || Error('unknown error'));
                    }, req.onsuccess = ()=>{
                        this[kIDB] = req.result, callback();
                    }, req.onupgradeneeded = (ev)=>{
                        const db = ev.target.result;
                        db.objectStoreNames.contains(this[kLocation]) || db.createObjectStore(this[kLocation]);
                    };
                }
                [kStore](mode) {
                    const transaction = this[kIDB].transaction([
                        this[kLocation]
                    ], mode);
                    return transaction.objectStore(this[kLocation]);
                }
                [kOnComplete](request, callback) {
                    const transaction = request.transaction;
                    transaction.onabort = function() {
                        callback(transaction.error || Error('aborted by user'));
                    }, transaction.oncomplete = function() {
                        callback(null, request.result);
                    };
                }
                _get(key, options, callback) {
                    const store = this[kStore]('readonly');
                    let req;
                    try {
                        req = store.get(key);
                    } catch (err) {
                        return this.nextTick(callback, err);
                    }
                    this[kOnComplete](req, function(err, value) {
                        return err ? callback(err) : void 0 === value ? callback(new ModuleError('Entry not found', {
                            code: 'LEVEL_NOT_FOUND'
                        })) : void callback(null, deserialize(value));
                    });
                }
                _getMany(keys, options, callback) {
                    const store = this[kStore]('readonly'), tasks = keys.map((key)=>(next)=>{
                            let request;
                            try {
                                request = store.get(key);
                            } catch (err) {
                                return next(err);
                            }
                            request.onsuccess = ()=>{
                                const value = request.result;
                                next(null, void 0 === value ? value : deserialize(value));
                            }, request.onerror = (ev)=>{
                                ev.stopPropagation(), next(request.error);
                            };
                        });
                    parallel(tasks, 16, callback);
                }
                _del(key, options, callback) {
                    const store = this[kStore]('readwrite');
                    let req;
                    try {
                        req = store.delete(key);
                    } catch (err) {
                        return this.nextTick(callback, err);
                    }
                    this[kOnComplete](req, callback);
                }
                _put(key, value, options, callback) {
                    const store = this[kStore]('readwrite');
                    let req;
                    try {
                        req = store.put(value, key);
                    } catch (err) {
                        return this.nextTick(callback, err);
                    }
                    this[kOnComplete](req, callback);
                }
                _iterator(options) {
                    return new Iterator(this, this[kLocation], options);
                }
                _batch(operations, options, callback) {
                    const store = this[kStore]('readwrite'), transaction = store.transaction;
                    let index = 0, error;
                    function loop() {
                        const op = operations[index++], key = op.key;
                        let req;
                        try {
                            req = 'del' === op.type ? store.delete(key) : store.put(op.value, key);
                        } catch (err) {
                            error = err, transaction.abort();
                            return;
                        }
                        index < operations.length ? req.onsuccess = loop : 'function' == typeof transaction.commit && transaction.commit();
                    }
                    transaction.onabort = function() {
                        callback(error || transaction.error || Error('aborted by user'));
                    }, transaction.oncomplete = function() {
                        callback();
                    }, loop();
                }
                _clear(options, callback) {
                    let keyRange, req;
                    try {
                        keyRange = createKeyRange(options);
                    } catch (e) {
                        return this.nextTick(callback);
                    }
                    if (options.limit >= 0) return clear(this, this[kLocation], keyRange, options, callback);
                    try {
                        const store = this[kStore]('readwrite');
                        req = keyRange ? store.delete(keyRange) : store.clear();
                    } catch (err) {
                        return this.nextTick(callback, err);
                    }
                    this[kOnComplete](req, callback);
                }
                _close(callback) {
                    this[kIDB].close(), this.nextTick(callback);
                }
            }
            BrowserLevel.destroy = function(location, prefix, callback) {
                'function' == typeof prefix && (callback = prefix, prefix = DEFAULT_PREFIX), callback = fromCallback(callback, kPromise);
                const request = indexedDB.deleteDatabase(prefix + location);
                return request.onsuccess = function() {
                    callback();
                }, request.onerror = function(err) {
                    callback(err);
                }, callback[kPromise];
            }, exports.BrowserLevel = BrowserLevel;
        },
        8212: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { AbstractIterator  } = __webpack_require__(875), createKeyRange = __webpack_require__(1217), deserialize = __webpack_require__(9687), kCache = Symbol('cache'), kFinished = Symbol('finished'), kOptions = Symbol('options'), kCurrentOptions = Symbol('currentOptions'), kPosition = Symbol('position'), kLocation = Symbol('location'), kFirst = Symbol('first'), emptyOptions = {};
            class Iterator extends AbstractIterator {
                constructor(db, location, options){
                    super(db, options), this[kCache] = [], this[kFinished] = 0 === this.limit, this[kOptions] = options, this[kCurrentOptions] = {
                        ...options
                    }, this[kPosition] = void 0, this[kLocation] = location, this[kFirst] = !0;
                }
                _nextv(size, options, callback) {
                    if (this[kFirst] = !1, this[kFinished]) return this.nextTick(callback, null, []);
                    if (this[kCache].length > 0) return size = Math.min(size, this[kCache].length), this.nextTick(callback, null, this[kCache].splice(0, size));
                    void 0 !== this[kPosition] && (this[kOptions].reverse ? (this[kCurrentOptions].lt = this[kPosition], this[kCurrentOptions].lte = void 0) : (this[kCurrentOptions].gt = this[kPosition], this[kCurrentOptions].gte = void 0));
                    let keyRange;
                    try {
                        keyRange = createKeyRange(this[kCurrentOptions]);
                    } catch (_) {
                        return this[kFinished] = !0, this.nextTick(callback, null, []);
                    }
                    const transaction = this.db.db.transaction([
                        this[kLocation]
                    ], 'readonly'), store = transaction.objectStore(this[kLocation]), entries = [];
                    if (this[kOptions].reverse) {
                        const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor';
                        store[method](keyRange, 'prev').onsuccess = (ev)=>{
                            const cursor = ev.target.result;
                            if (cursor) {
                                const { key , value  } = cursor;
                                this[kPosition] = key, entries.push([
                                    this[kOptions].keys && void 0 !== key ? deserialize(key) : void 0,
                                    this[kOptions].values && void 0 !== value ? deserialize(value) : void 0
                                ]), entries.length < size ? cursor.continue() : maybeCommit(transaction);
                            } else this[kFinished] = !0;
                        };
                    } else {
                        let keys, values;
                        const complete = ()=>{
                            if (void 0 === keys || void 0 === values) return;
                            const length = Math.max(keys.length, values.length);
                            0 === length || size === 1 / 0 ? this[kFinished] = !0 : this[kPosition] = keys[length - 1], entries.length = length;
                            for(let i = 0; i < length; i++){
                                const key = keys[i], value = values[i];
                                entries[i] = [
                                    this[kOptions].keys && void 0 !== key ? deserialize(key) : void 0,
                                    this[kOptions].values && void 0 !== value ? deserialize(value) : void 0
                                ];
                            }
                            maybeCommit(transaction);
                        };
                        this[kOptions].keys || size < 1 / 0 ? store.getAllKeys(keyRange, size < 1 / 0 ? size : void 0).onsuccess = (ev)=>{
                            keys = ev.target.result, complete();
                        } : (keys = [], this.nextTick(complete)), this[kOptions].values ? store.getAll(keyRange, size < 1 / 0 ? size : void 0).onsuccess = (ev)=>{
                            values = ev.target.result, complete();
                        } : (values = [], this.nextTick(complete));
                    }
                    transaction.onabort = ()=>{
                        callback(transaction.error || Error('aborted by user')), callback = null;
                    }, transaction.oncomplete = ()=>{
                        callback(null, entries), callback = null;
                    };
                }
                _next(callback) {
                    if (this[kCache].length > 0) {
                        const [key, value] = this[kCache].shift();
                        this.nextTick(callback, null, key, value);
                    } else if (this[kFinished]) this.nextTick(callback);
                    else {
                        let size = Math.min(100, this.limit - this.count);
                        this[kFirst] && (this[kFirst] = !1, size = 1), this._nextv(size, emptyOptions, (err, entries)=>{
                            if (err) return callback(err);
                            this[kCache] = entries, this._next(callback);
                        });
                    }
                }
                _all(options, callback) {
                    this[kFirst] = !1;
                    const cache = this[kCache].splice(0, this[kCache].length), size = this.limit - this.count - cache.length;
                    if (size <= 0) return this.nextTick(callback, null, cache);
                    this._nextv(size, emptyOptions, (err, entries)=>{
                        if (err) return callback(err);
                        cache.length > 0 && (entries = cache.concat(entries)), callback(null, entries);
                    });
                }
                _seek(target, options) {
                    this[kFirst] = !0, this[kCache] = [], this[kFinished] = !1, this[kPosition] = void 0, this[kCurrentOptions] = {
                        ...this[kOptions]
                    };
                    let keyRange;
                    try {
                        keyRange = createKeyRange(this[kOptions]);
                    } catch (_) {
                        this[kFinished] = !0;
                        return;
                    }
                    null === keyRange || keyRange.includes(target) ? this[kOptions].reverse ? this[kCurrentOptions].lte = target : this[kCurrentOptions].gte = target : this[kFinished] = !0;
                }
            }
            function maybeCommit(transaction) {
                'function' == typeof transaction.commit && transaction.commit();
            }
            exports.Iterator = Iterator;
        },
        7753: function(module) {
            "use strict";
            module.exports = function(db, location, keyRange, options, callback) {
                if (0 === options.limit) return db.nextTick(callback);
                const transaction = db.db.transaction([
                    location
                ], 'readwrite'), store = transaction.objectStore(location);
                let count = 0;
                transaction.oncomplete = function() {
                    callback();
                }, transaction.onabort = function() {
                    callback(transaction.error || Error('aborted by user'));
                };
                const method = store.openKeyCursor ? 'openKeyCursor' : 'openCursor', direction = options.reverse ? 'prev' : 'next';
                store[method](keyRange, direction).onsuccess = function(ev) {
                    const cursor = ev.target.result;
                    cursor && (store.delete(cursor.key).onsuccess = function() {
                        (options.limit <= 0 || ++count < options.limit) && cursor.continue();
                    });
                };
            };
        },
        9687: function(module) {
            "use strict";
            const textEncoder = new TextEncoder();
            module.exports = function(data) {
                return data instanceof Uint8Array ? data : data instanceof ArrayBuffer ? new Uint8Array(data) : textEncoder.encode(data);
            };
        },
        1217: function(module) {
            "use strict";
            module.exports = function(options) {
                const lower = void 0 !== options.gte ? options.gte : void 0 !== options.gt ? options.gt : void 0, upper = void 0 !== options.lte ? options.lte : void 0 !== options.lt ? options.lt : void 0, lowerExclusive = void 0 === options.gte, upperExclusive = void 0 === options.lte;
                return void 0 !== lower && void 0 !== upper ? IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive) : void 0 !== lower ? IDBKeyRange.lowerBound(lower, lowerExclusive) : void 0 !== upper ? IDBKeyRange.upperBound(upper, upperExclusive) : null;
            };
        },
        3533: function(module, __unused_webpack_exports, __webpack_require__) {
            const Buffer = __webpack_require__(9509).Buffer;
            module.exports = class {
                constructor(buf = Buffer.from([])){
                    this.buffer = buf;
                }
                read(num) {
                    const data = this.buffer.subarray(0, num);
                    return this.buffer = this.buffer.subarray(num), data;
                }
                write(buf) {
                    buf = Buffer.from(buf), this.buffer = Buffer.concat([
                        this.buffer,
                        buf
                    ]);
                }
            };
        },
        8764: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const base64 = __webpack_require__(9742), ieee754 = __webpack_require__(645), customInspectSymbol = 'function' == typeof Symbol && 'function' == typeof Symbol.for ? Symbol.for('nodejs.util.inspect.custom') : null;
            exports.Buffer = Buffer, exports.SlowBuffer = SlowBuffer, exports.INSPECT_MAX_BYTES = 50;
            const K_MAX_LENGTH = 0x7fffffff;
            function typedArraySupport() {
                try {
                    const arr = new Uint8Array(1), proto = {
                        foo: function() {
                            return 42;
                        }
                    };
                    return Object.setPrototypeOf(proto, Uint8Array.prototype), Object.setPrototypeOf(arr, proto), 42 === arr.foo();
                } catch (e) {
                    return !1;
                }
            }
            function createBuffer(length) {
                if (length > K_MAX_LENGTH) throw RangeError('The value "' + length + '" is invalid for option "size"');
                const buf = new Uint8Array(length);
                return Object.setPrototypeOf(buf, Buffer.prototype), buf;
            }
            function Buffer(arg, encodingOrOffset, length) {
                if ('number' == typeof arg) {
                    if ('string' == typeof encodingOrOffset) throw TypeError('The "string" argument must be of type string. Received type number');
                    return allocUnsafe(arg);
                }
                return from(arg, encodingOrOffset, length);
            }
            function from(value, encodingOrOffset, length) {
                if ('string' == typeof value) return fromString(value, encodingOrOffset);
                if (ArrayBuffer.isView(value)) return fromArrayView(value);
                if (null == value) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer) || 'undefined' != typeof SharedArrayBuffer && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
                if ('number' == typeof value) throw TypeError('The "value" argument must not be of type number. Received type number');
                const valueOf = value.valueOf && value.valueOf();
                if (null != valueOf && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
                const b = fromObject(value);
                if (b) return b;
                if ('undefined' != typeof Symbol && null != Symbol.toPrimitive && 'function' == typeof value[Symbol.toPrimitive]) return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
            }
            function assertSize(size) {
                if ('number' != typeof size) throw TypeError('"size" argument must be of type number');
                if (size < 0) throw RangeError('The value "' + size + '" is invalid for option "size"');
            }
            function alloc(size, fill, encoding) {
                return (assertSize(size), size <= 0) ? createBuffer(size) : void 0 !== fill ? 'string' == typeof encoding ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill) : createBuffer(size);
            }
            function allocUnsafe(size) {
                return assertSize(size), createBuffer(size < 0 ? 0 : 0 | checked(size));
            }
            function fromString(string, encoding) {
                if (('string' != typeof encoding || '' === encoding) && (encoding = 'utf8'), !Buffer.isEncoding(encoding)) throw TypeError('Unknown encoding: ' + encoding);
                const length = 0 | byteLength(string, encoding);
                let buf = createBuffer(length);
                const actual = buf.write(string, encoding);
                return actual !== length && (buf = buf.slice(0, actual)), buf;
            }
            function fromArrayLike(array) {
                const length = array.length < 0 ? 0 : 0 | checked(array.length), buf = createBuffer(length);
                for(let i = 0; i < length; i += 1)buf[i] = 255 & array[i];
                return buf;
            }
            function fromArrayView(arrayView) {
                if (isInstance(arrayView, Uint8Array)) {
                    const copy = new Uint8Array(arrayView);
                    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
                }
                return fromArrayLike(arrayView);
            }
            function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) throw RangeError('"offset" is outside of buffer bounds');
                if (array.byteLength < byteOffset + (length || 0)) throw RangeError('"length" is outside of buffer bounds');
                let buf;
                return Object.setPrototypeOf(buf = void 0 === byteOffset && void 0 === length ? new Uint8Array(array) : void 0 === length ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length), Buffer.prototype), buf;
            }
            function fromObject(obj) {
                if (Buffer.isBuffer(obj)) {
                    const len = 0 | checked(obj.length), buf = createBuffer(len);
                    return 0 === buf.length || obj.copy(buf, 0, 0, len), buf;
                }
                return void 0 !== obj.length ? 'number' != typeof obj.length || numberIsNaN(obj.length) ? createBuffer(0) : fromArrayLike(obj) : 'Buffer' === obj.type && Array.isArray(obj.data) ? fromArrayLike(obj.data) : void 0;
            }
            function checked(length) {
                if (length >= K_MAX_LENGTH) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
                return 0 | length;
            }
            function SlowBuffer(length) {
                return +length != length && (length = 0), Buffer.alloc(+length);
            }
            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) return string.length;
                if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
                if ('string' != typeof string) throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
                const len = string.length, mustMatch = arguments.length > 2 && !0 === arguments[2];
                if (!mustMatch && 0 === len) return 0;
                let loweredCase = !1;
                for(;;)switch(encoding){
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                        return len;
                    case 'utf8':
                    case 'utf-8':
                        return utf8ToBytes(string).length;
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return 2 * len;
                    case 'hex':
                        return len >>> 1;
                    case 'base64':
                        return base64ToBytes(string).length;
                    default:
                        if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length;
                        encoding = ('' + encoding).toLowerCase(), loweredCase = !0;
                }
            }
            function slowToString(encoding, start, end) {
                let loweredCase = !1;
                if ((void 0 === start || start < 0) && (start = 0), start > this.length || ((void 0 === end || end > this.length) && (end = this.length), end <= 0 || (end >>>= 0) <= (start >>>= 0))) return '';
                for(encoding || (encoding = 'utf8');;)switch(encoding){
                    case 'hex':
                        return hexSlice(this, start, end);
                    case 'utf8':
                    case 'utf-8':
                        return utf8Slice(this, start, end);
                    case 'ascii':
                        return asciiSlice(this, start, end);
                    case 'latin1':
                    case 'binary':
                        return latin1Slice(this, start, end);
                    case 'base64':
                        return base64Slice(this, start, end);
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return utf16leSlice(this, start, end);
                    default:
                        if (loweredCase) throw TypeError('Unknown encoding: ' + encoding);
                        encoding = (encoding + '').toLowerCase(), loweredCase = !0;
                }
            }
            function swap(b, n, m) {
                const i = b[n];
                b[n] = b[m], b[m] = i;
            }
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (0 === buffer.length) return -1;
                if ('string' == typeof byteOffset ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 0x7fffffff ? byteOffset = 0x7fffffff : byteOffset < -2147483648 && (byteOffset = -2147483648), numberIsNaN(byteOffset = +byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1), byteOffset < 0 && (byteOffset = buffer.length + byteOffset), byteOffset >= buffer.length) {
                    if (dir) return -1;
                    byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                    if (!dir) return -1;
                    byteOffset = 0;
                }
                if ('string' == typeof val && (val = Buffer.from(val, encoding)), Buffer.isBuffer(val)) return 0 === val.length ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                if ('number' == typeof val) return (val &= 0xFF, 'function' == typeof Uint8Array.prototype.indexOf) ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [
                    val
                ], byteOffset, encoding, dir);
                throw TypeError('val must be string, number or Buffer');
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                let indexSize = 1, arrLength = arr.length, valLength = val.length;
                if (void 0 !== encoding && ('ucs2' === (encoding = String(encoding).toLowerCase()) || 'ucs-2' === encoding || 'utf16le' === encoding || 'utf-16le' === encoding)) {
                    if (arr.length < 2 || val.length < 2) return -1;
                    indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
                }
                function read(buf, i) {
                    return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize);
                }
                let i;
                if (dir) {
                    let foundIndex = -1;
                    for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                        if (-1 === foundIndex && (foundIndex = i), i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                    } else -1 !== foundIndex && (i -= i - foundIndex), foundIndex = -1;
                } else for(byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength), i = byteOffset; i >= 0; i--){
                    let found = !0;
                    for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                        found = !1;
                        break;
                    }
                    if (found) return i;
                }
                return -1;
            }
            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                const remaining = buf.length - offset;
                length ? (length = Number(length)) > remaining && (length = remaining) : length = remaining;
                const strLen = string.length;
                length > strLen / 2 && (length = strLen / 2);
                let i;
                for(i = 0; i < length; ++i){
                    const parsed = parseInt(string.substr(2 * i, 2), 16);
                    if (numberIsNaN(parsed)) break;
                    buf[offset + i] = parsed;
                }
                return i;
            }
            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            function base64Slice(buf, start, end) {
                return 0 === start && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end));
            }
            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                const res = [];
                let i = start;
                for(; i < end;){
                    const firstByte = buf[i];
                    let codePoint = null, bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                        let secondByte, thirdByte, fourthByte, tempCodePoint;
                        switch(bytesPerSequence){
                            case 1:
                                firstByte < 0x80 && (codePoint = firstByte);
                                break;
                            case 2:
                                (0xC0 & (secondByte = buf[i + 1])) == 0x80 && (tempCodePoint = (0x1F & firstByte) << 0x6 | 0x3F & secondByte) > 0x7F && (codePoint = tempCodePoint);
                                break;
                            case 3:
                                secondByte = buf[i + 1], thirdByte = buf[i + 2], (0xC0 & secondByte) == 0x80 && (0xC0 & thirdByte) == 0x80 && (tempCodePoint = (0xF & firstByte) << 0xC | (0x3F & secondByte) << 0x6 | 0x3F & thirdByte) > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF) && (codePoint = tempCodePoint);
                                break;
                            case 4:
                                secondByte = buf[i + 1], thirdByte = buf[i + 2], fourthByte = buf[i + 3], (0xC0 & secondByte) == 0x80 && (0xC0 & thirdByte) == 0x80 && (0xC0 & fourthByte) == 0x80 && (tempCodePoint = (0xF & firstByte) << 0x12 | (0x3F & secondByte) << 0xC | (0x3F & thirdByte) << 0x6 | 0x3F & fourthByte) > 0xFFFF && tempCodePoint < 0x110000 && (codePoint = tempCodePoint);
                        }
                    }
                    null === codePoint ? (codePoint = 0xFFFD, bytesPerSequence = 1) : codePoint > 0xFFFF && (codePoint -= 0x10000, res.push(codePoint >>> 10 & 0x3FF | 0xD800), codePoint = 0xDC00 | 0x3FF & codePoint), res.push(codePoint), i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
            }
            exports.kMaxLength = K_MAX_LENGTH, Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport(), Buffer.TYPED_ARRAY_SUPPORT || 'undefined' == typeof console || 'function' != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer.prototype, 'parent', {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this)) return this.buffer;
                }
            }), Object.defineProperty(Buffer.prototype, 'offset', {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this)) return this.byteOffset;
                }
            }), Buffer.poolSize = 8192, Buffer.from = function(value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length);
            }, Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer, Uint8Array), Buffer.alloc = function(size, fill, encoding) {
                return alloc(size, fill, encoding);
            }, Buffer.allocUnsafe = function(size) {
                return allocUnsafe(size);
            }, Buffer.allocUnsafeSlow = function(size) {
                return allocUnsafe(size);
            }, Buffer.isBuffer = function(b) {
                return null != b && !0 === b._isBuffer && b !== Buffer.prototype;
            }, Buffer.compare = function(a, b) {
                if (isInstance(a, Uint8Array) && (a = Buffer.from(a, a.offset, a.byteLength)), isInstance(b, Uint8Array) && (b = Buffer.from(b, b.offset, b.byteLength)), !Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (a === b) return 0;
                let x = a.length, y = b.length;
                for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
                    x = a[i], y = b[i];
                    break;
                }
                return x < y ? -1 : y < x ? 1 : 0;
            }, Buffer.isEncoding = function(encoding) {
                switch(String(encoding).toLowerCase()){
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return !0;
                    default:
                        return !1;
                }
            }, Buffer.concat = function(list, length) {
                if (!Array.isArray(list)) throw TypeError('"list" argument must be an Array of Buffers');
                if (0 === list.length) return Buffer.alloc(0);
                let i;
                if (void 0 === length) for(i = 0, length = 0; i < list.length; ++i)length += list[i].length;
                const buffer = Buffer.allocUnsafe(length);
                let pos = 0;
                for(i = 0; i < list.length; ++i){
                    let buf = list[i];
                    if (isInstance(buf, Uint8Array)) pos + buf.length > buffer.length ? (Buffer.isBuffer(buf) || (buf = Buffer.from(buf)), buf.copy(buffer, pos)) : Uint8Array.prototype.set.call(buffer, buf, pos);
                    else if (Buffer.isBuffer(buf)) buf.copy(buffer, pos);
                    else throw TypeError('"list" argument must be an Array of Buffers');
                    pos += buf.length;
                }
                return buffer;
            }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
                const len = this.length;
                if (len % 2 != 0) throw RangeError('Buffer size must be a multiple of 16-bits');
                for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
                return this;
            }, Buffer.prototype.swap32 = function() {
                const len = this.length;
                if (len % 4 != 0) throw RangeError('Buffer size must be a multiple of 32-bits');
                for(let i = 0; i < len; i += 4)swap(this, i, i + 3), swap(this, i + 1, i + 2);
                return this;
            }, Buffer.prototype.swap64 = function() {
                const len = this.length;
                if (len % 8 != 0) throw RangeError('Buffer size must be a multiple of 64-bits');
                for(let i = 0; i < len; i += 8)swap(this, i, i + 7), swap(this, i + 1, i + 6), swap(this, i + 2, i + 5), swap(this, i + 3, i + 4);
                return this;
            }, Buffer.prototype.toString = function() {
                const length = this.length;
                return 0 === length ? '' : 0 === arguments.length ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments);
            }, Buffer.prototype.toLocaleString = Buffer.prototype.toString, Buffer.prototype.equals = function(b) {
                if (!Buffer.isBuffer(b)) throw TypeError('Argument must be a Buffer');
                return this === b || 0 === Buffer.compare(this, b);
            }, Buffer.prototype.inspect = function() {
                let str = '';
                const max = exports.INSPECT_MAX_BYTES;
                return str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim(), this.length > max && (str += ' ... '), '<Buffer ' + str + '>';
            }, customInspectSymbol && (Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect), Buffer.prototype.compare = function(target, start, end, thisStart, thisEnd) {
                if (isInstance(target, Uint8Array) && (target = Buffer.from(target, target.offset, target.byteLength)), !Buffer.isBuffer(target)) throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
                if (void 0 === start && (start = 0), void 0 === end && (end = target ? target.length : 0), void 0 === thisStart && (thisStart = 0), void 0 === thisEnd && (thisEnd = this.length), start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw RangeError('out of range index');
                if (thisStart >= thisEnd && start >= end) return 0;
                if (thisStart >= thisEnd) return -1;
                if (start >= end) return 1;
                if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target) return 0;
                let x = thisEnd - thisStart, y = end - start;
                const len = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end);
                for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i], y = targetCopy[i];
                    break;
                }
                return x < y ? -1 : y < x ? 1 : 0;
            }, Buffer.prototype.includes = function(val, byteOffset, encoding) {
                return -1 !== this.indexOf(val, byteOffset, encoding);
            }, Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
            }, Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
            }, Buffer.prototype.write = function(string, offset, length, encoding) {
                if (void 0 === offset) encoding = 'utf8', length = this.length, offset = 0;
                else if (void 0 === length && 'string' == typeof offset) encoding = offset, length = this.length, offset = 0;
                else if (isFinite(offset)) offset >>>= 0, isFinite(length) ? (length >>>= 0, void 0 === encoding && (encoding = 'utf8')) : (encoding = length, length = void 0);
                else throw Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
                const remaining = this.length - offset;
                if ((void 0 === length || length > remaining) && (length = remaining), string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw RangeError('Attempt to write outside buffer bounds');
                encoding || (encoding = 'utf8');
                let loweredCase = !1;
                for(;;)switch(encoding){
                    case 'hex':
                        return hexWrite(this, string, offset, length);
                    case 'utf8':
                    case 'utf-8':
                        return utf8Write(this, string, offset, length);
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                        return asciiWrite(this, string, offset, length);
                    case 'base64':
                        return base64Write(this, string, offset, length);
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return ucs2Write(this, string, offset, length);
                    default:
                        if (loweredCase) throw TypeError('Unknown encoding: ' + encoding);
                        encoding = ('' + encoding).toLowerCase(), loweredCase = !0;
                }
            }, Buffer.prototype.toJSON = function() {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            const MAX_ARGUMENTS_LENGTH = 0x1000;
            function decodeCodePointsArray(codePoints) {
                const len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
                let res = '', i = 0;
                for(; i < len;)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                return res;
            }
            function asciiSlice(buf, start, end) {
                let ret = '';
                end = Math.min(buf.length, end);
                for(let i = start; i < end; ++i)ret += String.fromCharCode(0x7F & buf[i]);
                return ret;
            }
            function latin1Slice(buf, start, end) {
                let ret = '';
                end = Math.min(buf.length, end);
                for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
                return ret;
            }
            function hexSlice(buf, start, end) {
                const len = buf.length;
                (!start || start < 0) && (start = 0), (!end || end < 0 || end > len) && (end = len);
                let out = '';
                for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
                return out;
            }
            function utf16leSlice(buf, start, end) {
                const bytes = buf.slice(start, end);
                let res = '';
                for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
                return res;
            }
            function checkOffset(offset, ext, length) {
                if (offset % 1 != 0 || offset < 0) throw RangeError('offset is not uint');
                if (offset + ext > length) throw RangeError('Trying to access beyond buffer length');
            }
            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min) throw RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length) throw RangeError('Index out of range');
            }
            function wrtBigUInt64LE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(0xffffffff));
                buf[offset++] = lo, lo >>= 8, buf[offset++] = lo, lo >>= 8, buf[offset++] = lo, lo >>= 8, buf[offset++] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
                return buf[offset++] = hi, hi >>= 8, buf[offset++] = hi, hi >>= 8, buf[offset++] = hi, hi >>= 8, buf[offset++] = hi, offset;
            }
            function wrtBigUInt64BE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(0xffffffff));
                buf[offset + 7] = lo, lo >>= 8, buf[offset + 6] = lo, lo >>= 8, buf[offset + 5] = lo, lo >>= 8, buf[offset + 4] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
                return buf[offset + 3] = hi, hi >>= 8, buf[offset + 2] = hi, hi >>= 8, buf[offset + 1] = hi, hi >>= 8, buf[offset] = hi, offset + 8;
            }
            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length || offset < 0) throw RangeError('Index out of range');
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000), ieee754.write(buf, value, offset, littleEndian, 23, 4), offset + 4;
            }
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), ieee754.write(buf, value, offset, littleEndian, 52, 8), offset + 8;
            }
            Buffer.prototype.slice = function(start, end) {
                const len = this.length;
                start = ~~start, end = void 0 === end ? len : ~~end, start < 0 ? (start += len) < 0 && (start = 0) : start > len && (start = len), end < 0 ? (end += len) < 0 && (end = 0) : end > len && (end = len), end < start && (end = start);
                const newBuf = this.subarray(start, end);
                return Object.setPrototypeOf(newBuf, Buffer.prototype), newBuf;
            }, Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
                offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                let val = this[offset], mul = 1, i = 0;
                for(; ++i < byteLength && (mul *= 0x100);)val += this[offset + i] * mul;
                return val;
            }, Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
                offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                let val = this[offset + --byteLength], mul = 1;
                for(; byteLength > 0 && (mul *= 0x100);)val += this[offset + --byteLength] * mul;
                return val;
            }, Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), this[offset];
            }, Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
            }, Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
            }, Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 0x1000000 * this[offset + 3];
            }, Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), 0x1000000 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
            }, Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function(offset) {
                validateNumber(offset >>>= 0, 'offset');
                const first = this[offset], last = this[offset + 7];
                (void 0 === first || void 0 === last) && boundsError(offset, this.length - 8);
                const lo = first + 256 * this[++offset] + 65536 * this[++offset] + 16777216 * this[++offset], hi = this[++offset] + 256 * this[++offset] + 65536 * this[++offset] + 16777216 * last;
                return BigInt(lo) + (BigInt(hi) << BigInt(32));
            }), Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function(offset) {
                validateNumber(offset >>>= 0, 'offset');
                const first = this[offset], last = this[offset + 7];
                (void 0 === first || void 0 === last) && boundsError(offset, this.length - 8);
                const hi = 16777216 * first + 65536 * this[++offset] + 256 * this[++offset] + this[++offset], lo = 16777216 * this[++offset] + 65536 * this[++offset] + 256 * this[++offset] + last;
                return (BigInt(hi) << BigInt(32)) + BigInt(lo);
            }), Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
                offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                let val = this[offset], mul = 1, i = 0;
                for(; ++i < byteLength && (mul *= 0x100);)val += this[offset + i] * mul;
                return val >= (mul *= 0x80) && (val -= Math.pow(2, 8 * byteLength)), val;
            }, Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
                offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                let i = byteLength, mul = 1, val = this[offset + --i];
                for(; i > 0 && (mul *= 0x100);)val += this[offset + --i] * mul;
                return val >= (mul *= 0x80) && (val -= Math.pow(2, 8 * byteLength)), val;
            }, Buffer.prototype.readInt8 = function(offset, noAssert) {
                return (offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), 0x80 & this[offset]) ? -((0xff - this[offset] + 1) * 1) : this[offset];
            }, Buffer.prototype.readInt16LE = function(offset, noAssert) {
                offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
                const val = this[offset] | this[offset + 1] << 8;
                return 0x8000 & val ? 0xFFFF0000 | val : val;
            }, Buffer.prototype.readInt16BE = function(offset, noAssert) {
                offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
                const val = this[offset + 1] | this[offset] << 8;
                return 0x8000 & val ? 0xFFFF0000 | val : val;
            }, Buffer.prototype.readInt32LE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
            }, Buffer.prototype.readInt32BE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
            }, Buffer.prototype.readBigInt64LE = defineBigIntMethod(function(offset) {
                validateNumber(offset >>>= 0, 'offset');
                const first = this[offset], last = this[offset + 7];
                (void 0 === first || void 0 === last) && boundsError(offset, this.length - 8);
                const val = this[offset + 4] + 256 * this[offset + 5] + 65536 * this[offset + 6] + (last << 24);
                return (BigInt(val) << BigInt(32)) + BigInt(first + 256 * this[++offset] + 65536 * this[++offset] + 16777216 * this[++offset]);
            }), Buffer.prototype.readBigInt64BE = defineBigIntMethod(function(offset) {
                validateNumber(offset >>>= 0, 'offset');
                const first = this[offset], last = this[offset + 7];
                (void 0 === first || void 0 === last) && boundsError(offset, this.length - 8);
                const val = (first << 24) + 65536 * this[++offset] + 256 * this[++offset] + this[++offset];
                return (BigInt(val) << BigInt(32)) + BigInt(16777216 * this[++offset] + 65536 * this[++offset] + 256 * this[++offset] + last);
            }), Buffer.prototype.readFloatLE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !0, 23, 4);
            }, Buffer.prototype.readFloatBE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !1, 23, 4);
            }, Buffer.prototype.readDoubleLE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !0, 52, 8);
            }, Buffer.prototype.readDoubleBE = function(offset, noAssert) {
                return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !1, 52, 8);
            }, Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
                if (value = +value, offset >>>= 0, byteLength >>>= 0, !noAssert) {
                    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                let mul = 1, i = 0;
                for(this[offset] = 0xFF & value; ++i < byteLength && (mul *= 0x100);)this[offset + i] = value / mul & 0xFF;
                return offset + byteLength;
            }, Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
                if (value = +value, offset >>>= 0, byteLength >>>= 0, !noAssert) {
                    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                let i = byteLength - 1, mul = 1;
                for(this[offset + i] = 0xFF & value; --i >= 0 && (mul *= 0x100);)this[offset + i] = value / mul & 0xFF;
                return offset + byteLength;
            }, Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 0xff, 0), this[offset] = 0xff & value, offset + 1;
            }, Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0xffff, 0), this[offset] = 0xff & value, this[offset + 1] = value >>> 8, offset + 2;
            }, Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0xffff, 0), this[offset] = value >>> 8, this[offset + 1] = 0xff & value, offset + 2;
            }, Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0xffffffff, 0), this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = 0xff & value, offset + 4;
            }, Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0xffffffff, 0), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 0xff & value, offset + 4;
            }, Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function(value, offset = 0) {
                return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
            }), Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function(value, offset = 0) {
                return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
            }), Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
                if (value = +value, offset >>>= 0, !noAssert) {
                    const limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                let i = 0, mul = 1, sub = 0;
                for(this[offset] = 0xFF & value; ++i < byteLength && (mul *= 0x100);)value < 0 && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                return offset + byteLength;
            }, Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
                if (value = +value, offset >>>= 0, !noAssert) {
                    const limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                let i = byteLength - 1, mul = 1, sub = 0;
                for(this[offset + i] = 0xFF & value; --i >= 0 && (mul *= 0x100);)value < 0 && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                return offset + byteLength;
            }, Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 0x7f, -128), value < 0 && (value = 0xff + value + 1), this[offset] = 0xff & value, offset + 1;
            }, Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0x7fff, -32768), this[offset] = 0xff & value, this[offset + 1] = value >>> 8, offset + 2;
            }, Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0x7fff, -32768), this[offset] = value >>> 8, this[offset + 1] = 0xff & value, offset + 2;
            }, Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0x7fffffff, -2147483648), this[offset] = 0xff & value, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
            }, Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
                return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0x7fffffff, -2147483648), value < 0 && (value = 0xffffffff + value + 1), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 0xff & value, offset + 4;
            }, Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function(value, offset = 0) {
                return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
            }), Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function(value, offset = 0) {
                return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
            }), Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
                return writeFloat(this, value, offset, !0, noAssert);
            }, Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
                return writeFloat(this, value, offset, !1, noAssert);
            }, Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
                return writeDouble(this, value, offset, !0, noAssert);
            }, Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
                return writeDouble(this, value, offset, !1, noAssert);
            }, Buffer.prototype.copy = function(target, targetStart, start, end) {
                if (!Buffer.isBuffer(target)) throw TypeError('argument should be a Buffer');
                if (start || (start = 0), end || 0 === end || (end = this.length), targetStart >= target.length && (targetStart = target.length), targetStart || (targetStart = 0), end > 0 && end < start && (end = start), end === start || 0 === target.length || 0 === this.length) return 0;
                if (targetStart < 0) throw RangeError('targetStart out of bounds');
                if (start < 0 || start >= this.length) throw RangeError('Index out of range');
                if (end < 0) throw RangeError('sourceEnd out of bounds');
                end > this.length && (end = this.length), target.length - targetStart < end - start && (end = target.length - targetStart + start);
                const len = end - start;
                return this === target && 'function' == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(targetStart, start, end) : Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart), len;
            }, Buffer.prototype.fill = function(val, start, end, encoding) {
                if ('string' == typeof val) {
                    if ('string' == typeof start ? (encoding = start, start = 0, end = this.length) : 'string' == typeof end && (encoding = end, end = this.length), void 0 !== encoding && 'string' != typeof encoding) throw TypeError('encoding must be a string');
                    if ('string' == typeof encoding && !Buffer.isEncoding(encoding)) throw TypeError('Unknown encoding: ' + encoding);
                    if (1 === val.length) {
                        const code = val.charCodeAt(0);
                        ('utf8' === encoding && code < 128 || 'latin1' === encoding) && (val = code);
                    }
                } else 'number' == typeof val ? val &= 255 : 'boolean' == typeof val && (val = Number(val));
                if (start < 0 || this.length < start || this.length < end) throw RangeError('Out of range index');
                if (end <= start) return this;
                start >>>= 0, end = void 0 === end ? this.length : end >>> 0, val || (val = 0);
                let i;
                if ('number' == typeof val) for(i = start; i < end; ++i)this[i] = val;
                else {
                    const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding), len = bytes.length;
                    if (0 === len) throw TypeError('The value "' + val + '" is invalid for argument "value"');
                    for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
                }
                return this;
            };
            const errors = {};
            function E(sym, getMessage, Base) {
                errors[sym] = class extends Base {
                    constructor(){
                        super(), Object.defineProperty(this, 'message', {
                            value: getMessage.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
                    }
                    get code() {
                        return sym;
                    }
                    set code(value) {
                        Object.defineProperty(this, 'code', {
                            configurable: !0,
                            enumerable: !0,
                            value,
                            writable: !0
                        });
                    }
                    toString() {
                        return `${this.name} [${sym}]: ${this.message}`;
                    }
                };
            }
            function addNumericalSeparator(val) {
                let res = '', i = val.length;
                const start = '-' === val[0] ? 1 : 0;
                for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
                return `${val.slice(0, i)}${res}`;
            }
            function checkBounds(buf, offset, byteLength) {
                validateNumber(offset, 'offset'), (void 0 === buf[offset] || void 0 === buf[offset + byteLength]) && boundsError(offset, buf.length - (byteLength + 1));
            }
            function checkIntBI(value, min, max, buf, offset, byteLength) {
                if (value > max || value < min) {
                    const n = 'bigint' == typeof min ? 'n' : '';
                    let range;
                    throw range = byteLength > 3 ? 0 === min || min === BigInt(0) ? `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}` : `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength + 1) * 8 - 1}${n}` : `>= ${min}${n} and <= ${max}${n}`, new errors.ERR_OUT_OF_RANGE('value', range, value);
                }
                checkBounds(buf, offset, byteLength);
            }
            function validateNumber(value, name) {
                if ('number' != typeof value) throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
            }
            function boundsError(value, length, type) {
                if (Math.floor(value) !== value) throw validateNumber(value, type), new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
                if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
                throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
            }
            E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
                return name ? `${name} is outside of buffer bounds` : 'Attempt to access memory outside buffer bounds';
            }, RangeError), E('ERR_INVALID_ARG_TYPE', function(name, actual) {
                return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
            }, TypeError), E('ERR_OUT_OF_RANGE', function(str, range, input) {
                let msg = `The value of "${str}" is out of range.`, received = input;
                return Number.isInteger(input) && Math.abs(input) > 4294967296 ? received = addNumericalSeparator(String(input)) : 'bigint' == typeof input && (received = String(input), (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) && (received = addNumericalSeparator(received)), received += 'n'), msg += ` It must be ${range}. Received ${received}`;
            }, RangeError);
            const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
                if ((str = (str = str.split('=')[0]).trim().replace(INVALID_BASE64_RE, '')).length < 2) return '';
                for(; str.length % 4 != 0;)str += '=';
                return str;
            }
            function utf8ToBytes(string, units) {
                units = units || 1 / 0;
                let codePoint;
                const length = string.length;
                let leadSurrogate = null;
                const bytes = [];
                for(let i = 0; i < length; ++i){
                    if ((codePoint = string.charCodeAt(i)) > 0xD7FF && codePoint < 0xE000) {
                        if (!leadSurrogate) {
                            if (codePoint > 0xDBFF || i + 1 === length) {
                                (units -= 3) > -1 && bytes.push(0xEF, 0xBF, 0xBD);
                                continue;
                            }
                            leadSurrogate = codePoint;
                            continue;
                        }
                        if (codePoint < 0xDC00) {
                            (units -= 3) > -1 && bytes.push(0xEF, 0xBF, 0xBD), leadSurrogate = codePoint;
                            continue;
                        }
                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                    } else leadSurrogate && (units -= 3) > -1 && bytes.push(0xEF, 0xBF, 0xBD);
                    if (leadSurrogate = null, codePoint < 0x80) {
                        if ((units -= 1) < 0) break;
                        bytes.push(codePoint);
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0) break;
                        bytes.push(codePoint >> 0x6 | 0xC0, 0x3F & codePoint | 0x80);
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0) break;
                        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, 0x3F & codePoint | 0x80);
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0) break;
                        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, 0x3F & codePoint | 0x80);
                    } else throw Error('Invalid code point');
                }
                return bytes;
            }
            function asciiToBytes(str) {
                const byteArray = [];
                for(let i = 0; i < str.length; ++i)byteArray.push(0xFF & str.charCodeAt(i));
                return byteArray;
            }
            function utf16leToBytes(str, units) {
                let c, hi, lo;
                const byteArray = [];
                for(let i = 0; i < str.length && !((units -= 2) < 0); ++i)hi = (c = str.charCodeAt(i)) >> 8, byteArray.push(lo = c % 256), byteArray.push(hi);
                return byteArray;
            }
            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
                let i;
                for(i = 0; i < length && !(i + offset >= dst.length) && !(i >= src.length); ++i)dst[i + offset] = src[i];
                return i;
            }
            function isInstance(obj, type) {
                return obj instanceof type || null != obj && null != obj.constructor && null != obj.constructor.name && obj.constructor.name === type.name;
            }
            function numberIsNaN(obj) {
                return obj != obj;
            }
            const hexSliceLookupTable = function() {
                const alphabet = '0123456789abcdef', table = Array(256);
                for(let i = 0; i < 16; ++i){
                    const i16 = 16 * i;
                    for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
                }
                return table;
            }();
            function defineBigIntMethod(fn) {
                return 'undefined' == typeof BigInt ? BufferBigIntNotDefined : fn;
            }
            function BufferBigIntNotDefined() {
                throw Error('BigInt not supported');
            }
        },
        1924: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var GetIntrinsic = __webpack_require__(210), callBind = __webpack_require__(5559), $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
            module.exports = function(name, allowMissing) {
                var intrinsic = GetIntrinsic(name, !!allowMissing);
                return 'function' == typeof intrinsic && $indexOf(name, '.prototype.') > -1 ? callBind(intrinsic) : intrinsic;
            };
        },
        5559: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var bind = __webpack_require__(8612), GetIntrinsic = __webpack_require__(210), $apply = GetIntrinsic('%Function.prototype.apply%'), $call = GetIntrinsic('%Function.prototype.call%'), $reflectApply = GetIntrinsic('%Reflect.apply%', !0) || bind.call($call, $apply), $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', !0), $defineProperty = GetIntrinsic('%Object.defineProperty%', !0), $max = GetIntrinsic('%Math.max%');
            if ($defineProperty) try {
                $defineProperty({}, 'a', {
                    value: 1
                });
            } catch (e) {
                $defineProperty = null;
            }
            module.exports = function(originalFunction) {
                var func = $reflectApply(bind, $call, arguments);
                return $gOPD && $defineProperty && $gOPD(func, 'length').configurable && $defineProperty(func, 'length', {
                    value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                }), func;
            };
            var applyBind = function() {
                return $reflectApply(bind, $apply, arguments);
            };
            $defineProperty ? $defineProperty(module.exports, 'apply', {
                value: applyBind
            }) : module.exports.apply = applyBind;
        },
        6957: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var nextTick = __webpack_require__(886);
            exports.fromCallback = function(callback, symbol) {
                if (void 0 === callback) {
                    var promise = new Promise(function(resolve, reject) {
                        callback = function(err, res) {
                            err ? reject(err) : resolve(res);
                        };
                    });
                    callback[void 0 !== symbol ? symbol : 'promise'] = promise;
                } else if ('function' != typeof callback) throw TypeError('Callback must be a function');
                return callback;
            }, exports.fromPromise = function(promise, callback) {
                if (void 0 === callback) return promise;
                promise.then(function(res) {
                    nextTick(()=>callback(null, res));
                }).catch(function(err) {
                    nextTick(()=>callback(err));
                });
            };
        },
        886: function(module) {
            module.exports = 'function' == typeof queueMicrotask ? queueMicrotask : (fn)=>Promise.resolve().then(fn);
        },
        6266: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var elliptic = exports;
            elliptic.version = __webpack_require__(8597).i8, elliptic.utils = __webpack_require__(953), elliptic.rand = __webpack_require__(9931), elliptic.curve = __webpack_require__(8254), elliptic.curves = __webpack_require__(5427), elliptic.ec = __webpack_require__(7954), elliptic.eddsa = __webpack_require__(5980);
        },
        4918: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var BN = __webpack_require__(3550), utils = __webpack_require__(953), getNAF = utils.getNAF, getJSF = utils.getJSF, assert = utils.assert;
            function BaseCurve(type, conf) {
                this.type = type, this.p = new BN(conf.p, 16), this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = conf.n && new BN(conf.n, 16), this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed), this._wnafT1 = [
                    ,
                    ,
                    ,
                    , 
                ], this._wnafT2 = [
                    ,
                    ,
                    ,
                    , 
                ], this._wnafT3 = [
                    ,
                    ,
                    ,
                    , 
                ], this._wnafT4 = [
                    ,
                    ,
                    ,
                    , 
                ], this._bitLength = this.n ? this.n.bitLength() : 0;
                var adjustCount = this.n && this.p.div(this.n);
                !adjustCount || adjustCount.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
            }
            function BasePoint(curve, type) {
                this.curve = curve, this.type = type, this.precomputed = null;
            }
            module.exports = BaseCurve, BaseCurve.prototype.point = function() {
                throw Error('Not implemented');
            }, BaseCurve.prototype.validate = function() {
                throw Error('Not implemented');
            }, BaseCurve.prototype._fixedNafMul = function(p, k) {
                assert(p.precomputed);
                var j, nafW, doubles = p._getDoubles(), naf = getNAF(k, 1, this._bitLength), I = (1 << doubles.step + 1) - (doubles.step % 2 == 0 ? 2 : 1);
                I /= 3;
                var repr = [];
                for(j = 0; j < naf.length; j += doubles.step){
                    nafW = 0;
                    for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];
                    repr.push(nafW);
                }
                for(var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null), i = I; i > 0; i--){
                    for(j = 0; j < repr.length; j++)(nafW = repr[j]) === i ? b = b.mixedAdd(doubles.points[j]) : nafW === -i && (b = b.mixedAdd(doubles.points[j].neg()));
                    a = a.add(b);
                }
                return a.toP();
            }, BaseCurve.prototype._wnafMul = function(p, k) {
                var w = 4, nafPoints = p._getNAFPoints(w);
                w = nafPoints.wnd;
                for(var wnd = nafPoints.points, naf = getNAF(k, w, this._bitLength), acc = this.jpoint(null, null, null), i = naf.length - 1; i >= 0; i--){
                    for(var l = 0; i >= 0 && 0 === naf[i]; i--)l++;
                    if (i >= 0 && l++, acc = acc.dblp(l), i < 0) break;
                    var z = naf[i];
                    assert(0 !== z), acc = 'affine' === p.type ? z > 0 ? acc.mixedAdd(wnd[z - 1 >> 1]) : acc.mixedAdd(wnd[-z - 1 >> 1].neg()) : z > 0 ? acc.add(wnd[z - 1 >> 1]) : acc.add(wnd[-z - 1 >> 1].neg());
                }
                return 'affine' === p.type ? acc.toP() : acc;
            }, BaseCurve.prototype._wnafMulAdd = function(defW, points, coeffs, len, jacobianResult) {
                var i, j, p, wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max = 0;
                for(i = 0; i < len; i++){
                    var nafPoints = (p = points[i])._getNAFPoints(defW);
                    wndWidth[i] = nafPoints.wnd, wnd[i] = nafPoints.points;
                }
                for(i = len - 1; i >= 1; i -= 2){
                    var a = i - 1, b = i;
                    if (1 !== wndWidth[a] || 1 !== wndWidth[b]) {
                        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength), naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength), max = Math.max(naf[a].length, max), max = Math.max(naf[b].length, max);
                        continue;
                    }
                    var comb = [
                        points[a],
                        null,
                        null,
                        points[b]
                    ];
                    0 === points[a].y.cmp(points[b].y) ? (comb[1] = points[a].add(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg())) : 0 === points[a].y.cmp(points[b].y.redNeg()) ? (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].add(points[b].neg())) : (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg()));
                    var index = [
                        -3,
                        -1,
                        -5,
                        -7,
                        0,
                        7,
                        5,
                        1,
                        3
                    ], jsf = getJSF(coeffs[a], coeffs[b]);
                    for(j = 0, max = Math.max(jsf[0].length, max), naf[a] = Array(max), naf[b] = Array(max); j < max; j++){
                        var ja = 0 | jsf[0][j], jb = 0 | jsf[1][j];
                        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)], naf[b][j] = 0, wnd[a] = comb;
                    }
                }
                var acc = this.jpoint(null, null, null), tmp = this._wnafT4;
                for(i = max; i >= 0; i--){
                    for(var k = 0; i >= 0;){
                        var zero = !0;
                        for(j = 0; j < len; j++)tmp[j] = 0 | naf[j][i], 0 !== tmp[j] && (zero = !1);
                        if (!zero) break;
                        k++, i--;
                    }
                    if (i >= 0 && k++, acc = acc.dblp(k), i < 0) break;
                    for(j = 0; j < len; j++){
                        var z = tmp[j];
                        0 !== z && (z > 0 ? p = wnd[j][z - 1 >> 1] : z < 0 && (p = wnd[j][-z - 1 >> 1].neg()), acc = 'affine' === p.type ? acc.mixedAdd(p) : acc.add(p));
                    }
                }
                for(i = 0; i < len; i++)wnd[i] = null;
                return jacobianResult ? acc : acc.toP();
            }, BaseCurve.BasePoint = BasePoint, BasePoint.prototype.eq = function() {
                throw Error('Not implemented');
            }, BasePoint.prototype.validate = function() {
                return this.curve.validate(this);
            }, BaseCurve.prototype.decodePoint = function(bytes, enc) {
                bytes = utils.toArray(bytes, enc);
                var len = this.p.byteLength();
                if ((0x04 === bytes[0] || 0x06 === bytes[0] || 0x07 === bytes[0]) && bytes.length - 1 == 2 * len) return 0x06 === bytes[0] ? assert(bytes[bytes.length - 1] % 2 == 0) : 0x07 === bytes[0] && assert(bytes[bytes.length - 1] % 2 == 1), this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
                if ((0x02 === bytes[0] || 0x03 === bytes[0]) && bytes.length - 1 === len) return this.pointFromX(bytes.slice(1, 1 + len), 0x03 === bytes[0]);
                throw Error('Unknown point format');
            }, BasePoint.prototype.encodeCompressed = function(enc) {
                return this.encode(enc, !0);
            }, BasePoint.prototype._encode = function(compact) {
                var len = this.curve.p.byteLength(), x = this.getX().toArray('be', len);
                return compact ? [
                    this.getY().isEven() ? 0x02 : 0x03
                ].concat(x) : [
                    0x04
                ].concat(x, this.getY().toArray('be', len));
            }, BasePoint.prototype.encode = function(enc, compact) {
                return utils.encode(this._encode(compact), enc);
            }, BasePoint.prototype.precompute = function(power) {
                if (this.precomputed) return this;
                var precomputed = {
                    doubles: null,
                    naf: null,
                    beta: null
                };
                return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;
            }, BasePoint.prototype._hasDoubles = function(k) {
                if (!this.precomputed) return !1;
                var doubles = this.precomputed.doubles;
                return !!doubles && doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
            }, BasePoint.prototype._getDoubles = function(step, power) {
                if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
                for(var doubles = [
                    this
                ], acc = this, i = 0; i < power; i += step){
                    for(var j = 0; j < step; j++)acc = acc.dbl();
                    doubles.push(acc);
                }
                return {
                    step: step,
                    points: doubles
                };
            }, BasePoint.prototype._getNAFPoints = function(wnd) {
                if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
                for(var res = [
                    this
                ], max = (1 << wnd) - 1, dbl = 1 === max ? null : this.dbl(), i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);
                return {
                    wnd: wnd,
                    points: res
                };
            }, BasePoint.prototype._getBeta = function() {
                return null;
            }, BasePoint.prototype.dblp = function(k) {
                for(var r = this, i = 0; i < k; i++)r = r.dbl();
                return r;
            };
        },
        1138: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(953), BN = __webpack_require__(3550), inherits = __webpack_require__(5717), Base = __webpack_require__(4918), assert = utils.assert;
            function EdwardsCurve(conf) {
                this.twisted = (0 | conf.a) != 1, this.mOneA = this.twisted && (0 | conf.a) == -1, this.extended = this.mOneA, Base.call(this, 'edwards', conf), this.a = new BN(conf.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN(conf.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN(conf.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = (0 | conf.c) == 1;
            }
            function Point(curve, x, y, z, t) {
                Base.BasePoint.call(this, curve, 'projective'), null === x && null === y && null === z ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = z ? new BN(z, 16) : this.curve.one, this.t = t && new BN(t, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, !this.curve.extended || this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
            }
            inherits(EdwardsCurve, Base), module.exports = EdwardsCurve, EdwardsCurve.prototype._mulA = function(num) {
                return this.mOneA ? num.redNeg() : this.a.redMul(num);
            }, EdwardsCurve.prototype._mulC = function(num) {
                return this.oneC ? num : this.c.redMul(num);
            }, EdwardsCurve.prototype.jpoint = function(x, y, z, t) {
                return this.point(x, y, z, t);
            }, EdwardsCurve.prototype.pointFromX = function(x, odd) {
                (x = new BN(x, 16)).red || (x = x.toRed(this.red));
                var x2 = x.redSqr(), rhs = this.c2.redSub(this.a.redMul(x2)), lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2)), y2 = rhs.redMul(lhs.redInvm()), y = y2.redSqrt();
                if (0 !== y.redSqr().redSub(y2).cmp(this.zero)) throw Error('invalid point');
                var isOdd = y.fromRed().isOdd();
                return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);
            }, EdwardsCurve.prototype.pointFromY = function(y, odd) {
                (y = new BN(y, 16)).red || (y = y.toRed(this.red));
                var y2 = y.redSqr(), lhs = y2.redSub(this.c2), rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a), x2 = lhs.redMul(rhs.redInvm());
                if (0 === x2.cmp(this.zero)) {
                    if (!odd) return this.point(this.zero, y);
                    throw Error('invalid point');
                }
                var x = x2.redSqrt();
                if (0 !== x.redSqr().redSub(x2).cmp(this.zero)) throw Error('invalid point');
                return x.fromRed().isOdd() !== odd && (x = x.redNeg()), this.point(x, y);
            }, EdwardsCurve.prototype.validate = function(point) {
                if (point.isInfinity()) return !0;
                point.normalize();
                var x2 = point.x.redSqr(), y2 = point.y.redSqr(), lhs = x2.redMul(this.a).redAdd(y2), rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
                return 0 === lhs.cmp(rhs);
            }, inherits(Point, Base.BasePoint), EdwardsCurve.prototype.pointFromJSON = function(obj) {
                return Point.fromJSON(this, obj);
            }, EdwardsCurve.prototype.point = function(x, y, z, t) {
                return new Point(this, x, y, z, t);
            }, Point.fromJSON = function(curve, obj) {
                return new Point(curve, obj[0], obj[1], obj[2]);
            }, Point.prototype.inspect = function() {
                return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            }, Point.prototype.isInfinity = function() {
                return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
            }, Point.prototype._extDbl = function() {
                var a = this.x.redSqr(), b = this.y.redSqr(), c = this.z.redSqr();
                c = c.redIAdd(c);
                var d = this.curve._mulA(a), e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b), g = d.redAdd(b), f = g.redSub(c), h = d.redSub(b), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt);
            }, Point.prototype._projDbl = function() {
                var nx, ny, nz, e, h, j, b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d = this.y.redSqr();
                if (this.curve.twisted) {
                    var f = (e = this.curve._mulA(c)).redAdd(d);
                    this.zOne ? (nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)), ny = f.redMul(e.redSub(d)), nz = f.redSqr().redSub(f).redSub(f)) : (h = this.z.redSqr(), j = f.redSub(h).redISub(h), nx = b.redSub(c).redISub(d).redMul(j), ny = f.redMul(e.redSub(d)), nz = f.redMul(j));
                } else e = c.redAdd(d), h = this.curve._mulC(this.z).redSqr(), j = e.redSub(h).redSub(h), nx = this.curve._mulC(b.redISub(e)).redMul(j), ny = this.curve._mulC(e).redMul(c.redISub(d)), nz = e.redMul(j);
                return this.curve.point(nx, ny, nz);
            }, Point.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
            }, Point.prototype._extAdd = function(p) {
                var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)), b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)), c = this.t.redMul(this.curve.dd).redMul(p.t), d = this.z.redMul(p.z.redAdd(p.z)), e = b.redSub(a), f = d.redSub(c), g = d.redAdd(c), h = b.redAdd(a), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt);
            }, Point.prototype._projAdd = function(p) {
                var ny, nz, a = this.z.redMul(p.z), b = a.redSqr(), c = this.x.redMul(p.x), d = this.y.redMul(p.y), e = this.curve.d.redMul(c).redMul(d), f = b.redSub(e), g = b.redAdd(e), tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d), nx = a.redMul(f).redMul(tmp);
                return this.curve.twisted ? (ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))), nz = f.redMul(g)) : (ny = a.redMul(g).redMul(d.redSub(c)), nz = this.curve._mulC(f).redMul(g)), this.curve.point(nx, ny, nz);
            }, Point.prototype.add = function(p) {
                return this.isInfinity() ? p : p.isInfinity() ? this : this.curve.extended ? this._extAdd(p) : this._projAdd(p);
            }, Point.prototype.mul = function(k) {
                return this._hasDoubles(k) ? this.curve._fixedNafMul(this, k) : this.curve._wnafMul(this, k);
            }, Point.prototype.mulAdd = function(k1, p, k2) {
                return this.curve._wnafMulAdd(1, [
                    this,
                    p
                ], [
                    k1,
                    k2
                ], 2, !1);
            }, Point.prototype.jmulAdd = function(k1, p, k2) {
                return this.curve._wnafMulAdd(1, [
                    this,
                    p
                ], [
                    k1,
                    k2
                ], 2, !0);
            }, Point.prototype.normalize = function() {
                if (this.zOne) return this;
                var zi = this.z.redInvm();
                return this.x = this.x.redMul(zi), this.y = this.y.redMul(zi), this.t && (this.t = this.t.redMul(zi)), this.z = this.curve.one, this.zOne = !0, this;
            }, Point.prototype.neg = function() {
                return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
            }, Point.prototype.getX = function() {
                return this.normalize(), this.x.fromRed();
            }, Point.prototype.getY = function() {
                return this.normalize(), this.y.fromRed();
            }, Point.prototype.eq = function(other) {
                return this === other || 0 === this.getX().cmp(other.getX()) && 0 === this.getY().cmp(other.getY());
            }, Point.prototype.eqXToP = function(x) {
                var rx = x.toRed(this.curve.red).redMul(this.z);
                if (0 === this.x.cmp(rx)) return !0;
                for(var xc = x.clone(), t = this.curve.redN.redMul(this.z);;){
                    if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0) return !1;
                    if (rx.redIAdd(t), 0 === this.x.cmp(rx)) return !0;
                }
            }, Point.prototype.toP = Point.prototype.normalize, Point.prototype.mixedAdd = Point.prototype.add;
        },
        8254: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var curve = exports;
            curve.base = __webpack_require__(4918), curve.short = __webpack_require__(6673), curve.mont = __webpack_require__(2881), curve.edwards = __webpack_require__(1138);
        },
        2881: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var BN = __webpack_require__(3550), inherits = __webpack_require__(5717), Base = __webpack_require__(4918), utils = __webpack_require__(953);
            function MontCurve(conf) {
                Base.call(this, 'mont', conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.i4 = new BN(4).toRed(this.red).redInvm(), this.two = new BN(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
            }
            function Point(curve, x, z) {
                Base.BasePoint.call(this, curve, 'projective'), null === x && null === z ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN(x, 16), this.z = new BN(z, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
            }
            inherits(MontCurve, Base), module.exports = MontCurve, MontCurve.prototype.validate = function(point) {
                var x = point.normalize().x, x2 = x.redSqr(), rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
                return 0 === rhs.redSqrt().redSqr().cmp(rhs);
            }, inherits(Point, Base.BasePoint), MontCurve.prototype.decodePoint = function(bytes, enc) {
                return this.point(utils.toArray(bytes, enc), 1);
            }, MontCurve.prototype.point = function(x, z) {
                return new Point(this, x, z);
            }, MontCurve.prototype.pointFromJSON = function(obj) {
                return Point.fromJSON(this, obj);
            }, Point.prototype.precompute = function() {}, Point.prototype._encode = function() {
                return this.getX().toArray('be', this.curve.p.byteLength());
            }, Point.fromJSON = function(curve, obj) {
                return new Point(curve, obj[0], obj[1] || curve.one);
            }, Point.prototype.inspect = function() {
                return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            }, Point.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0);
            }, Point.prototype.dbl = function() {
                var aa = this.x.redAdd(this.z).redSqr(), bb = this.x.redSub(this.z).redSqr(), c = aa.redSub(bb), nx = aa.redMul(bb), nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
                return this.curve.point(nx, nz);
            }, Point.prototype.add = function() {
                throw Error('Not supported on Montgomery curve');
            }, Point.prototype.diffAdd = function(p, diff) {
                var a = this.x.redAdd(this.z), b = this.x.redSub(this.z), c = p.x.redAdd(p.z), da = p.x.redSub(p.z).redMul(a), cb = c.redMul(b), nx = diff.z.redMul(da.redAdd(cb).redSqr()), nz = diff.x.redMul(da.redISub(cb).redSqr());
                return this.curve.point(nx, nz);
            }, Point.prototype.mul = function(k) {
                for(var t = k.clone(), a = this, b = this.curve.point(null, null), c = this, bits = []; 0 !== t.cmpn(0); t.iushrn(1))bits.push(t.andln(1));
                for(var i = bits.length - 1; i >= 0; i--)0 === bits[i] ? (a = a.diffAdd(b, c), b = b.dbl()) : (b = a.diffAdd(b, c), a = a.dbl());
                return b;
            }, Point.prototype.mulAdd = function() {
                throw Error('Not supported on Montgomery curve');
            }, Point.prototype.jumlAdd = function() {
                throw Error('Not supported on Montgomery curve');
            }, Point.prototype.eq = function(other) {
                return 0 === this.getX().cmp(other.getX());
            }, Point.prototype.normalize = function() {
                return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
            }, Point.prototype.getX = function() {
                return this.normalize(), this.x.fromRed();
            };
        },
        6673: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(953), BN = __webpack_require__(3550), inherits = __webpack_require__(5717), Base = __webpack_require__(4918), assert = utils.assert;
            function ShortCurve(conf) {
                Base.call(this, 'short', conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(conf), this._endoWnafT1 = [
                    ,
                    ,
                    ,
                    , 
                ], this._endoWnafT2 = [
                    ,
                    ,
                    ,
                    , 
                ];
            }
            function Point(curve, x, y, isRed) {
                Base.BasePoint.call(this, curve, 'affine'), null === x && null === y ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), isRed && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
            }
            function JPoint(curve, x, y, z) {
                Base.BasePoint.call(this, curve, 'jacobian'), null === x && null === y && null === z ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0)) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = new BN(z, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
            }
            inherits(ShortCurve, Base), module.exports = ShortCurve, ShortCurve.prototype._getEndomorphism = function(conf) {
                if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                    if (conf.beta) beta = new BN(conf.beta, 16).toRed(this.red);
                    else {
                        var beta, lambda, basis, betas = this._getEndoRoots(this.p);
                        beta = (beta = 0 > betas[0].cmp(betas[1]) ? betas[0] : betas[1]).toRed(this.red);
                    }
                    if (conf.lambda) lambda = new BN(conf.lambda, 16);
                    else {
                        var lambdas = this._getEndoRoots(this.n);
                        0 === this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) ? lambda = lambdas[0] : (lambda = lambdas[1], assert(0 === this.g.mul(lambda).x.cmp(this.g.x.redMul(beta))));
                    }
                    return basis = conf.basis ? conf.basis.map(function(vec) {
                        return {
                            a: new BN(vec.a, 16),
                            b: new BN(vec.b, 16)
                        };
                    }) : this._getEndoBasis(lambda), {
                        beta: beta,
                        lambda: lambda,
                        basis: basis
                    };
                }
            }, ShortCurve.prototype._getEndoRoots = function(num) {
                var red = num === this.p ? this.red : BN.mont(num), tinv = new BN(2).toRed(red).redInvm(), ntinv = tinv.redNeg(), s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv), l1 = ntinv.redAdd(s).fromRed(), l2 = ntinv.redSub(s).fromRed();
                return [
                    l1,
                    l2
                ];
            }, ShortCurve.prototype._getEndoBasis = function(lambda) {
                for(var a0, b0, a1, b1, a2, b2, prevR, r, x, aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x2 = new BN(0), y2 = new BN(1), i = 0; 0 !== u.cmpn(0);){
                    var q = v.div(u);
                    r = v.sub(q.mul(u)), x = x2.sub(q.mul(x1));
                    var y = y2.sub(q.mul(y1));
                    if (!a1 && 0 > r.cmp(aprxSqrt)) a0 = prevR.neg(), b0 = x1, a1 = r.neg(), b1 = x;
                    else if (a1 && 2 == ++i) break;
                    prevR = r, v = u, u = r, x2 = x1, x1 = x, y2 = y1, y1 = y;
                }
                a2 = r.neg(), b2 = x;
                var len1 = a1.sqr().add(b1.sqr());
                return a2.sqr().add(b2.sqr()).cmp(len1) >= 0 && (a2 = a0, b2 = b0), a1.negative && (a1 = a1.neg(), b1 = b1.neg()), a2.negative && (a2 = a2.neg(), b2 = b2.neg()), [
                    {
                        a: a1,
                        b: b1
                    },
                    {
                        a: a2,
                        b: b2
                    }, 
                ];
            }, ShortCurve.prototype._endoSplit = function(k) {
                var basis = this.endo.basis, v1 = basis[0], v2 = basis[1], c1 = v2.b.mul(k).divRound(this.n), c2 = v1.b.neg().mul(k).divRound(this.n), p1 = c1.mul(v1.a), p2 = c2.mul(v2.a), q1 = c1.mul(v1.b), q2 = c2.mul(v2.b);
                return {
                    k1: k.sub(p1).sub(p2),
                    k2: q1.add(q2).neg()
                };
            }, ShortCurve.prototype.pointFromX = function(x, odd) {
                (x = new BN(x, 16)).red || (x = x.toRed(this.red));
                var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b), y = y2.redSqrt();
                if (0 !== y.redSqr().redSub(y2).cmp(this.zero)) throw Error('invalid point');
                var isOdd = y.fromRed().isOdd();
                return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);
            }, ShortCurve.prototype.validate = function(point) {
                if (point.inf) return !0;
                var x = point.x, y = point.y, ax = this.a.redMul(x), rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
                return 0 === y.redSqr().redISub(rhs).cmpn(0);
            }, ShortCurve.prototype._endoWnafMulAdd = function(points, coeffs, jacobianResult) {
                for(var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2, i = 0; i < points.length; i++){
                    var split = this._endoSplit(coeffs[i]), p = points[i], beta = p._getBeta();
                    split.k1.negative && (split.k1.ineg(), p = p.neg(!0)), split.k2.negative && (split.k2.ineg(), beta = beta.neg(!0)), npoints[2 * i] = p, npoints[2 * i + 1] = beta, ncoeffs[2 * i] = split.k1, ncoeffs[2 * i + 1] = split.k2;
                }
                for(var res = this._wnafMulAdd(1, npoints, ncoeffs, 2 * i, jacobianResult), j = 0; j < 2 * i; j++)npoints[j] = null, ncoeffs[j] = null;
                return res;
            }, inherits(Point, Base.BasePoint), ShortCurve.prototype.point = function(x, y, isRed) {
                return new Point(this, x, y, isRed);
            }, ShortCurve.prototype.pointFromJSON = function(obj, red) {
                return Point.fromJSON(this, obj, red);
            }, Point.prototype._getBeta = function() {
                if (this.curve.endo) {
                    var pre = this.precomputed;
                    if (pre && pre.beta) return pre.beta;
                    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                    if (pre) {
                        var curve = this.curve, endoMul = function(p) {
                            return curve.point(p.x.redMul(curve.endo.beta), p.y);
                        };
                        pre.beta = beta, beta.precomputed = {
                            beta: null,
                            naf: pre.naf && {
                                wnd: pre.naf.wnd,
                                points: pre.naf.points.map(endoMul)
                            },
                            doubles: pre.doubles && {
                                step: pre.doubles.step,
                                points: pre.doubles.points.map(endoMul)
                            }
                        };
                    }
                    return beta;
                }
            }, Point.prototype.toJSON = function() {
                return this.precomputed ? [
                    this.x,
                    this.y,
                    this.precomputed && {
                        doubles: this.precomputed.doubles && {
                            step: this.precomputed.doubles.step,
                            points: this.precomputed.doubles.points.slice(1)
                        },
                        naf: this.precomputed.naf && {
                            wnd: this.precomputed.naf.wnd,
                            points: this.precomputed.naf.points.slice(1)
                        }
                    }
                ] : [
                    this.x,
                    this.y
                ];
            }, Point.fromJSON = function(curve, obj, red) {
                'string' == typeof obj && (obj = JSON.parse(obj));
                var res = curve.point(obj[0], obj[1], red);
                if (!obj[2]) return res;
                function obj2point(obj) {
                    return curve.point(obj[0], obj[1], red);
                }
                var pre = obj[2];
                return res.precomputed = {
                    beta: null,
                    doubles: pre.doubles && {
                        step: pre.doubles.step,
                        points: [
                            res
                        ].concat(pre.doubles.points.map(obj2point))
                    },
                    naf: pre.naf && {
                        wnd: pre.naf.wnd,
                        points: [
                            res
                        ].concat(pre.naf.points.map(obj2point))
                    }
                }, res;
            }, Point.prototype.inspect = function() {
                return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
            }, Point.prototype.isInfinity = function() {
                return this.inf;
            }, Point.prototype.add = function(p) {
                if (this.inf) return p;
                if (p.inf) return this;
                if (this.eq(p)) return this.dbl();
                if (this.neg().eq(p) || 0 === this.x.cmp(p.x)) return this.curve.point(null, null);
                var c = this.y.redSub(p.y);
                0 !== c.cmpn(0) && (c = c.redMul(this.x.redSub(p.x).redInvm()));
                var nx = c.redSqr().redISub(this.x).redISub(p.x), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny);
            }, Point.prototype.dbl = function() {
                if (this.inf) return this;
                var ys1 = this.y.redAdd(this.y);
                if (0 === ys1.cmpn(0)) return this.curve.point(null, null);
                var a = this.curve.a, x2 = this.x.redSqr(), dyinv = ys1.redInvm(), c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv), nx = c.redSqr().redISub(this.x.redAdd(this.x)), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny);
            }, Point.prototype.getX = function() {
                return this.x.fromRed();
            }, Point.prototype.getY = function() {
                return this.y.fromRed();
            }, Point.prototype.mul = function(k) {
                return (k = new BN(k, 16), this.isInfinity()) ? this : this._hasDoubles(k) ? this.curve._fixedNafMul(this, k) : this.curve.endo ? this.curve._endoWnafMulAdd([
                    this
                ], [
                    k
                ]) : this.curve._wnafMul(this, k);
            }, Point.prototype.mulAdd = function(k1, p2, k2) {
                var points = [
                    this,
                    p2
                ], coeffs = [
                    k1,
                    k2
                ];
                return this.curve.endo ? this.curve._endoWnafMulAdd(points, coeffs) : this.curve._wnafMulAdd(1, points, coeffs, 2);
            }, Point.prototype.jmulAdd = function(k1, p2, k2) {
                var points = [
                    this,
                    p2
                ], coeffs = [
                    k1,
                    k2
                ];
                return this.curve.endo ? this.curve._endoWnafMulAdd(points, coeffs, !0) : this.curve._wnafMulAdd(1, points, coeffs, 2, !0);
            }, Point.prototype.eq = function(p) {
                return this === p || this.inf === p.inf && (this.inf || 0 === this.x.cmp(p.x) && 0 === this.y.cmp(p.y));
            }, Point.prototype.neg = function(_precompute) {
                if (this.inf) return this;
                var res = this.curve.point(this.x, this.y.redNeg());
                if (_precompute && this.precomputed) {
                    var pre = this.precomputed, negate = function(p) {
                        return p.neg();
                    };
                    res.precomputed = {
                        naf: pre.naf && {
                            wnd: pre.naf.wnd,
                            points: pre.naf.points.map(negate)
                        },
                        doubles: pre.doubles && {
                            step: pre.doubles.step,
                            points: pre.doubles.points.map(negate)
                        }
                    };
                }
                return res;
            }, Point.prototype.toJ = function() {
                return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
            }, inherits(JPoint, Base.BasePoint), ShortCurve.prototype.jpoint = function(x, y, z) {
                return new JPoint(this, x, y, z);
            }, JPoint.prototype.toP = function() {
                if (this.isInfinity()) return this.curve.point(null, null);
                var zinv = this.z.redInvm(), zinv2 = zinv.redSqr(), ax = this.x.redMul(zinv2), ay = this.y.redMul(zinv2).redMul(zinv);
                return this.curve.point(ax, ay);
            }, JPoint.prototype.neg = function() {
                return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
            }, JPoint.prototype.add = function(p) {
                if (this.isInfinity()) return p;
                if (p.isInfinity()) return this;
                var pz2 = p.z.redSqr(), z2 = this.z.redSqr(), u1 = this.x.redMul(pz2), u2 = p.x.redMul(z2), s1 = this.y.redMul(pz2.redMul(p.z)), s2 = p.y.redMul(z2.redMul(this.z)), h = u1.redSub(u2), r = s1.redSub(s2);
                if (0 === h.cmpn(0)) return 0 !== r.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(p.z).redMul(h);
                return this.curve.jpoint(nx, ny, nz);
            }, JPoint.prototype.mixedAdd = function(p) {
                if (this.isInfinity()) return p.toJ();
                if (p.isInfinity()) return this;
                var z2 = this.z.redSqr(), u1 = this.x, u2 = p.x.redMul(z2), s1 = this.y, s2 = p.y.redMul(z2).redMul(this.z), h = u1.redSub(u2), r = s1.redSub(s2);
                if (0 === h.cmpn(0)) return 0 !== r.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(h);
                return this.curve.jpoint(nx, ny, nz);
            }, JPoint.prototype.dblp = function(pow) {
                if (0 === pow || this.isInfinity()) return this;
                if (!pow) return this.dbl();
                if (this.curve.zeroA || this.curve.threeA) {
                    var i, r = this;
                    for(i = 0; i < pow; i++)r = r.dbl();
                    return r;
                }
                var a = this.curve.a, tinv = this.curve.tinv, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jyd = jy.redAdd(jy);
                for(i = 0; i < pow; i++){
                    var jx2 = jx.redSqr(), jyd2 = jyd.redSqr(), jyd4 = jyd2.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), t1 = jx.redMul(jyd2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), dny = c.redMul(t2);
                    dny = dny.redIAdd(dny).redISub(jyd4);
                    var nz = jyd.redMul(jz);
                    i + 1 < pow && (jz4 = jz4.redMul(jyd4)), jx = nx, jz = nz, jyd = dny;
                }
                return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
            }, JPoint.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
            }, JPoint.prototype._zeroDbl = function() {
                if (this.zOne) {
                    var nx, ny, nz, xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    var m = xx.redAdd(xx).redIAdd(xx), t = m.redSqr().redISub(s).redISub(s), yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = (yyyy8 = yyyy8.redIAdd(yyyy8)).redIAdd(yyyy8), nx = t, ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);
                } else {
                    var a = this.x.redSqr(), b = this.y.redSqr(), c = b.redSqr(), d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
                    d = d.redIAdd(d);
                    var e = a.redAdd(a).redIAdd(a), f = e.redSqr(), c8 = c.redIAdd(c);
                    c8 = (c8 = c8.redIAdd(c8)).redIAdd(c8), nx = f.redISub(d).redISub(d), ny = e.redMul(d.redISub(nx)).redISub(c8), nz = (nz = this.y.redMul(this.z)).redIAdd(nz);
                }
                return this.curve.jpoint(nx, ny, nz);
            }, JPoint.prototype._threeDbl = function() {
                if (this.zOne) {
                    var nx, ny, nz, xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a), t = m.redSqr().redISub(s).redISub(s);
                    nx = t;
                    var yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = (yyyy8 = yyyy8.redIAdd(yyyy8)).redIAdd(yyyy8), ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);
                } else {
                    var delta = this.z.redSqr(), gamma = this.y.redSqr(), beta = this.x.redMul(gamma), alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
                    alpha = alpha.redAdd(alpha).redIAdd(alpha);
                    var beta4 = beta.redIAdd(beta), beta8 = (beta4 = beta4.redIAdd(beta4)).redAdd(beta4);
                    nx = alpha.redSqr().redISub(beta8), nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
                    var ggamma8 = gamma.redSqr();
                    ggamma8 = (ggamma8 = (ggamma8 = ggamma8.redIAdd(ggamma8)).redIAdd(ggamma8)).redIAdd(ggamma8), ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
                }
                return this.curve.jpoint(nx, ny, nz);
            }, JPoint.prototype._dbl = function() {
                var a = this.curve.a, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jx2 = jx.redSqr(), jy2 = jy.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), jxd4 = jx.redAdd(jx), t1 = (jxd4 = jxd4.redIAdd(jxd4)).redMul(jy2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), jyd8 = jy2.redSqr();
                jyd8 = (jyd8 = (jyd8 = jyd8.redIAdd(jyd8)).redIAdd(jyd8)).redIAdd(jyd8);
                var ny = c.redMul(t2).redISub(jyd8), nz = jy.redAdd(jy).redMul(jz);
                return this.curve.jpoint(nx, ny, nz);
            }, JPoint.prototype.trpl = function() {
                if (!this.curve.zeroA) return this.dbl().add(this);
                var xx = this.x.redSqr(), yy = this.y.redSqr(), zz = this.z.redSqr(), yyyy = yy.redSqr(), m = xx.redAdd(xx).redIAdd(xx), mm = m.redSqr(), e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy), ee = (e = (e = (e = e.redIAdd(e)).redAdd(e).redIAdd(e)).redISub(mm)).redSqr(), t = yyyy.redIAdd(yyyy);
                t = (t = (t = t.redIAdd(t)).redIAdd(t)).redIAdd(t);
                var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t), yyu4 = yy.redMul(u);
                yyu4 = (yyu4 = yyu4.redIAdd(yyu4)).redIAdd(yyu4);
                var nx = this.x.redMul(ee).redISub(yyu4);
                nx = (nx = nx.redIAdd(nx)).redIAdd(nx);
                var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
                ny = (ny = (ny = ny.redIAdd(ny)).redIAdd(ny)).redIAdd(ny);
                var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
                return this.curve.jpoint(nx, ny, nz);
            }, JPoint.prototype.mul = function(k, kbase) {
                return k = new BN(k, kbase), this.curve._wnafMul(this, k);
            }, JPoint.prototype.eq = function(p) {
                if ('affine' === p.type) return this.eq(p.toJ());
                if (this === p) return !0;
                var z2 = this.z.redSqr(), pz2 = p.z.redSqr();
                if (0 !== this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0)) return !1;
                var z3 = z2.redMul(this.z), pz3 = pz2.redMul(p.z);
                return 0 === this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0);
            }, JPoint.prototype.eqXToP = function(x) {
                var zs = this.z.redSqr(), rx = x.toRed(this.curve.red).redMul(zs);
                if (0 === this.x.cmp(rx)) return !0;
                for(var xc = x.clone(), t = this.curve.redN.redMul(zs);;){
                    if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0) return !1;
                    if (rx.redIAdd(t), 0 === this.x.cmp(rx)) return !0;
                }
            }, JPoint.prototype.inspect = function() {
                return this.isInfinity() ? '<EC JPoint Infinity>' : '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
            }, JPoint.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0);
            };
        },
        5427: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var pre, curves = exports, hash = __webpack_require__(3715), curve = __webpack_require__(8254), assert = __webpack_require__(953).assert;
            function PresetCurve(options) {
                'short' === options.type ? this.curve = new curve.short(options) : 'edwards' === options.type ? this.curve = new curve.edwards(options) : this.curve = new curve.mont(options), this.g = this.curve.g, this.n = this.curve.n, this.hash = options.hash, assert(this.g.validate(), 'Invalid curve'), assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
            }
            function defineCurve(name, options) {
                Object.defineProperty(curves, name, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        var curve = new PresetCurve(options);
                        return Object.defineProperty(curves, name, {
                            configurable: !0,
                            enumerable: !0,
                            value: curve
                        }), curve;
                    }
                });
            }
            curves.PresetCurve = PresetCurve, defineCurve('p192', {
                type: 'short',
                prime: 'p192',
                p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
                b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
                n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
                hash: hash.sha256,
                gRed: !1,
                g: [
                    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
                    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811', 
                ]
            }), defineCurve('p224', {
                type: 'short',
                prime: 'p224',
                p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
                b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
                n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
                hash: hash.sha256,
                gRed: !1,
                g: [
                    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
                    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34', 
                ]
            }), defineCurve('p256', {
                type: 'short',
                prime: null,
                p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
                a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
                b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
                n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
                hash: hash.sha256,
                gRed: !1,
                g: [
                    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
                    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5', 
                ]
            }), defineCurve('p384', {
                type: 'short',
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: hash.sha384,
                gRed: !1,
                g: [
                    "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                    "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f", 
                ]
            }), defineCurve('p521', {
                type: 'short',
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: hash.sha512,
                gRed: !1,
                g: [
                    "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                    "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650", 
                ]
            }), defineCurve('curve25519', {
                type: 'mont',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '76d06',
                b: '1',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash.sha256,
                gRed: !1,
                g: [
                    '9', 
                ]
            }), defineCurve('ed25519', {
                type: 'edwards',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '-1',
                c: '1',
                d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash.sha256,
                gRed: !1,
                g: [
                    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
                    '6666666666666666666666666666666666666666666666666666666666666658', 
                ]
            });
            try {
                pre = __webpack_require__(1037);
            } catch (e) {
                pre = void 0;
            }
            defineCurve('secp256k1', {
                type: 'short',
                prime: 'k256',
                p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
                a: '0',
                b: '7',
                n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
                h: '1',
                hash: hash.sha256,
                beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
                lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
                basis: [
                    {
                        a: '3086d221a7d46bcde86c90e49284eb15',
                        b: '-e4437ed6010e88286f547fa90abfe4c3'
                    },
                    {
                        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                        b: '3086d221a7d46bcde86c90e49284eb15'
                    }, 
                ],
                gRed: !1,
                g: [
                    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
                    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                    pre, 
                ]
            });
        },
        7954: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var BN = __webpack_require__(3550), HmacDRBG = __webpack_require__(2156), utils = __webpack_require__(953), curves = __webpack_require__(5427), rand = __webpack_require__(9931), assert = utils.assert, KeyPair = __webpack_require__(1251), Signature = __webpack_require__(611);
            function EC(options) {
                if (!(this instanceof EC)) return new EC(options);
                'string' == typeof options && (assert(Object.prototype.hasOwnProperty.call(curves, options), 'Unknown curve ' + options), options = curves[options]), options instanceof curves.PresetCurve && (options = {
                    curve: options
                }), this.curve = options.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options.curve.g, this.g.precompute(options.curve.n.bitLength() + 1), this.hash = options.hash || options.curve.hash;
            }
            module.exports = EC, EC.prototype.keyPair = function(options) {
                return new KeyPair(this, options);
            }, EC.prototype.keyFromPrivate = function(priv, enc) {
                return KeyPair.fromPrivate(this, priv, enc);
            }, EC.prototype.keyFromPublic = function(pub, enc) {
                return KeyPair.fromPublic(this, pub, enc);
            }, EC.prototype.genKeyPair = function(options) {
                options || (options = {});
                for(var drbg = new HmacDRBG({
                    hash: this.hash,
                    pers: options.pers,
                    persEnc: options.persEnc || 'utf8',
                    entropy: options.entropy || rand(this.hash.hmacStrength),
                    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
                    nonce: this.n.toArray()
                }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2));;){
                    var priv = new BN(drbg.generate(bytes));
                    if (!(priv.cmp(ns2) > 0)) return priv.iaddn(1), this.keyFromPrivate(priv);
                }
            }, EC.prototype._truncateToN = function(msg, truncOnly) {
                var delta = 8 * msg.byteLength() - this.n.bitLength();
                return (delta > 0 && (msg = msg.ushrn(delta)), !truncOnly && msg.cmp(this.n) >= 0) ? msg.sub(this.n) : msg;
            }, EC.prototype.sign = function(msg, key, enc, options) {
                'object' == typeof enc && (options = enc, enc = null), options || (options = {}), key = this.keyFromPrivate(key, enc), msg = this._truncateToN(new BN(msg, 16));
                for(var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray('be', bytes), nonce = msg.toArray('be', bytes), drbg = new HmacDRBG({
                    hash: this.hash,
                    entropy: bkey,
                    nonce: nonce,
                    pers: options.pers,
                    persEnc: options.persEnc || 'utf8'
                }), ns1 = this.n.sub(new BN(1)), iter = 0;; iter++){
                    var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
                    if (!(0 >= (k = this._truncateToN(k, !0)).cmpn(1) || k.cmp(ns1) >= 0)) {
                        var kp = this.g.mul(k);
                        if (!kp.isInfinity()) {
                            var kpX = kp.getX(), r = kpX.umod(this.n);
                            if (0 !== r.cmpn(0)) {
                                var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
                                if (0 !== (s = s.umod(this.n)).cmpn(0)) {
                                    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (0 !== kpX.cmp(r) ? 2 : 0);
                                    return options.canonical && s.cmp(this.nh) > 0 && (s = this.n.sub(s), recoveryParam ^= 1), new Signature({
                                        r: r,
                                        s: s,
                                        recoveryParam: recoveryParam
                                    });
                                }
                            }
                        }
                    }
                }
            }, EC.prototype.verify = function(msg, signature, key, enc) {
                msg = this._truncateToN(new BN(msg, 16)), key = this.keyFromPublic(key, enc);
                var p, r = (signature = new Signature(signature, 'hex')).r, s = signature.s;
                if (0 > r.cmpn(1) || r.cmp(this.n) >= 0 || 0 > s.cmpn(1) || s.cmp(this.n) >= 0) return !1;
                var sinv = s.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n);
                return this.curve._maxwellTrick ? !(p = this.g.jmulAdd(u1, key.getPublic(), u2)).isInfinity() && p.eqXToP(r) : !(p = this.g.mulAdd(u1, key.getPublic(), u2)).isInfinity() && 0 === p.getX().umod(this.n).cmp(r);
            }, EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
                assert((3 & j) === j, 'The recovery param is more than two bits'), signature = new Signature(signature, enc);
                var n = this.n, e = new BN(msg), r = signature.r, s = signature.s, isYOdd = 1 & j, isSecondKey = j >> 1;
                if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw Error('Unable to find sencond key candinate');
                r = isSecondKey ? this.curve.pointFromX(r.add(this.curve.n), isYOdd) : this.curve.pointFromX(r, isYOdd);
                var rInv = signature.r.invm(n), s1 = n.sub(e).mul(rInv).umod(n), s2 = s.mul(rInv).umod(n);
                return this.g.mulAdd(s1, r, s2);
            }, EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
                if (null !== (signature = new Signature(signature, enc)).recoveryParam) return signature.recoveryParam;
                for(var Qprime, i = 0; i < 4; i++){
                    try {
                        Qprime = this.recoverPubKey(e, signature, i);
                    } catch (e1) {
                        continue;
                    }
                    if (Qprime.eq(Q)) return i;
                }
                throw Error('Unable to find valid recovery factor');
            };
        },
        1251: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var BN = __webpack_require__(3550), assert = __webpack_require__(953).assert;
            function KeyPair(ec, options) {
                this.ec = ec, this.priv = null, this.pub = null, options.priv && this._importPrivate(options.priv, options.privEnc), options.pub && this._importPublic(options.pub, options.pubEnc);
            }
            module.exports = KeyPair, KeyPair.fromPublic = function(ec, pub, enc) {
                return pub instanceof KeyPair ? pub : new KeyPair(ec, {
                    pub: pub,
                    pubEnc: enc
                });
            }, KeyPair.fromPrivate = function(ec, priv, enc) {
                return priv instanceof KeyPair ? priv : new KeyPair(ec, {
                    priv: priv,
                    privEnc: enc
                });
            }, KeyPair.prototype.validate = function() {
                var pub = this.getPublic();
                return pub.isInfinity() ? {
                    result: !1,
                    reason: 'Invalid public key'
                } : pub.validate() ? pub.mul(this.ec.curve.n).isInfinity() ? {
                    result: !0,
                    reason: null
                } : {
                    result: !1,
                    reason: 'Public key * N != O'
                } : {
                    result: !1,
                    reason: 'Public key is not a point'
                };
            }, KeyPair.prototype.getPublic = function(compact, enc) {
                return ('string' == typeof compact && (enc = compact, compact = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), enc) ? this.pub.encode(enc, compact) : this.pub;
            }, KeyPair.prototype.getPrivate = function(enc) {
                return 'hex' === enc ? this.priv.toString(16, 2) : this.priv;
            }, KeyPair.prototype._importPrivate = function(key, enc) {
                this.priv = new BN(key, enc || 16), this.priv = this.priv.umod(this.ec.curve.n);
            }, KeyPair.prototype._importPublic = function(key, enc) {
                if (key.x || key.y) {
                    'mont' === this.ec.curve.type ? assert(key.x, 'Need x coordinate') : ('short' === this.ec.curve.type || 'edwards' === this.ec.curve.type) && assert(key.x && key.y, 'Need both x and y coordinate'), this.pub = this.ec.curve.point(key.x, key.y);
                    return;
                }
                this.pub = this.ec.curve.decodePoint(key, enc);
            }, KeyPair.prototype.derive = function(pub) {
                return pub.validate() || assert(pub.validate(), 'public point not validated'), pub.mul(this.priv).getX();
            }, KeyPair.prototype.sign = function(msg, enc, options) {
                return this.ec.sign(msg, this, enc, options);
            }, KeyPair.prototype.verify = function(msg, signature) {
                return this.ec.verify(msg, signature, this);
            }, KeyPair.prototype.inspect = function() {
                return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
            };
        },
        611: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var BN = __webpack_require__(3550), utils = __webpack_require__(953), assert = utils.assert;
            function Signature(options, enc) {
                if (options instanceof Signature) return options;
                this._importDER(options, enc) || (assert(options.r && options.s, 'Signature without r or s'), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), void 0 === options.recoveryParam ? this.recoveryParam = null : this.recoveryParam = options.recoveryParam);
            }
            function Position() {
                this.place = 0;
            }
            function getLength(buf, p) {
                var initial = buf[p.place++];
                if (!(0x80 & initial)) return initial;
                var octetLen = 0xf & initial;
                if (0 === octetLen || octetLen > 4) return !1;
                for(var val = 0, i = 0, off = p.place; i < octetLen; i++, off++)val <<= 8, val |= buf[off], val >>>= 0;
                return !(val <= 0x7f) && (p.place = off, val);
            }
            function rmPadding(buf) {
                for(var i = 0, len = buf.length - 1; !buf[i] && !(0x80 & buf[i + 1]) && i < len;)i++;
                return 0 === i ? buf : buf.slice(i);
            }
            function constructLength(arr, len) {
                if (len < 0x80) {
                    arr.push(len);
                    return;
                }
                var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
                for(arr.push(0x80 | octets); --octets;)arr.push(len >>> (octets << 3) & 0xff);
                arr.push(len);
            }
            module.exports = Signature, Signature.prototype._importDER = function(data, enc) {
                data = utils.toArray(data, enc);
                var p = new Position();
                if (0x30 !== data[p.place++]) return !1;
                var len = getLength(data, p);
                if (!1 === len || len + p.place !== data.length || 0x02 !== data[p.place++]) return !1;
                var rlen = getLength(data, p);
                if (!1 === rlen) return !1;
                var r = data.slice(p.place, rlen + p.place);
                if (p.place += rlen, 0x02 !== data[p.place++]) return !1;
                var slen = getLength(data, p);
                if (!1 === slen || data.length !== slen + p.place) return !1;
                var s = data.slice(p.place, slen + p.place);
                if (0 === r[0]) {
                    if (!(0x80 & r[1])) return !1;
                    r = r.slice(1);
                }
                if (0 === s[0]) {
                    if (!(0x80 & s[1])) return !1;
                    s = s.slice(1);
                }
                return this.r = new BN(r), this.s = new BN(s), this.recoveryParam = null, !0;
            }, Signature.prototype.toDER = function(enc) {
                var r = this.r.toArray(), s = this.s.toArray();
                for(0x80 & r[0] && (r = [
                    0
                ].concat(r)), 0x80 & s[0] && (s = [
                    0
                ].concat(s)), r = rmPadding(r), s = rmPadding(s); !s[0] && !(0x80 & s[1]);)s = s.slice(1);
                var arr = [
                    0x02
                ];
                constructLength(arr, r.length), (arr = arr.concat(r)).push(0x02), constructLength(arr, s.length);
                var backHalf = arr.concat(s), res = [
                    0x30
                ];
                return constructLength(res, backHalf.length), res = res.concat(backHalf), utils.encode(res, enc);
            };
        },
        5980: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var hash = __webpack_require__(3715), curves = __webpack_require__(5427), utils = __webpack_require__(953), assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = __webpack_require__(9087), Signature = __webpack_require__(3622);
            function EDDSA(curve) {
                if (assert('ed25519' === curve, 'only tested with ed25519 so far'), !(this instanceof EDDSA)) return new EDDSA(curve);
                curve = curves[curve].curve, this.curve = curve, this.g = curve.g, this.g.precompute(curve.n.bitLength() + 1), this.pointClass = curve.point().constructor, this.encodingLength = Math.ceil(curve.n.bitLength() / 8), this.hash = hash.sha512;
            }
            module.exports = EDDSA, EDDSA.prototype.sign = function(message, secret) {
                message = parseBytes(message);
                var key = this.keyFromSecret(secret), r = this.hashInt(key.messagePrefix(), message), R = this.g.mul(r), Rencoded = this.encodePoint(R), s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv()), S = r.add(s_).umod(this.curve.n);
                return this.makeSignature({
                    R: R,
                    S: S,
                    Rencoded: Rencoded
                });
            }, EDDSA.prototype.verify = function(message, sig, pub) {
                message = parseBytes(message), sig = this.makeSignature(sig);
                var key = this.keyFromPublic(pub), h = this.hashInt(sig.Rencoded(), key.pubBytes(), message), SG = this.g.mul(sig.S());
                return sig.R().add(key.pub().mul(h)).eq(SG);
            }, EDDSA.prototype.hashInt = function() {
                for(var hash = this.hash(), i = 0; i < arguments.length; i++)hash.update(arguments[i]);
                return utils.intFromLE(hash.digest()).umod(this.curve.n);
            }, EDDSA.prototype.keyFromPublic = function(pub) {
                return KeyPair.fromPublic(this, pub);
            }, EDDSA.prototype.keyFromSecret = function(secret) {
                return KeyPair.fromSecret(this, secret);
            }, EDDSA.prototype.makeSignature = function(sig) {
                return sig instanceof Signature ? sig : new Signature(this, sig);
            }, EDDSA.prototype.encodePoint = function(point) {
                var enc = point.getY().toArray('le', this.encodingLength);
                return enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0, enc;
            }, EDDSA.prototype.decodePoint = function(bytes) {
                var lastIx = (bytes = utils.parseBytes(bytes)).length - 1, normed = bytes.slice(0, lastIx).concat(-129 & bytes[lastIx]), xIsOdd = (0x80 & bytes[lastIx]) != 0, y = utils.intFromLE(normed);
                return this.curve.pointFromY(y, xIsOdd);
            }, EDDSA.prototype.encodeInt = function(num) {
                return num.toArray('le', this.encodingLength);
            }, EDDSA.prototype.decodeInt = function(bytes) {
                return utils.intFromLE(bytes);
            }, EDDSA.prototype.isPoint = function(val) {
                return val instanceof this.pointClass;
            };
        },
        9087: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(953), assert = utils.assert, parseBytes = utils.parseBytes, cachedProperty = utils.cachedProperty;
            function KeyPair(eddsa, params) {
                this.eddsa = eddsa, this._secret = parseBytes(params.secret), eddsa.isPoint(params.pub) ? this._pub = params.pub : this._pubBytes = parseBytes(params.pub);
            }
            KeyPair.fromPublic = function(eddsa, pub) {
                return pub instanceof KeyPair ? pub : new KeyPair(eddsa, {
                    pub: pub
                });
            }, KeyPair.fromSecret = function(eddsa, secret) {
                return secret instanceof KeyPair ? secret : new KeyPair(eddsa, {
                    secret: secret
                });
            }, KeyPair.prototype.secret = function() {
                return this._secret;
            }, cachedProperty(KeyPair, 'pubBytes', function() {
                return this.eddsa.encodePoint(this.pub());
            }), cachedProperty(KeyPair, 'pub', function() {
                return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
            }), cachedProperty(KeyPair, 'privBytes', function() {
                var eddsa = this.eddsa, hash = this.hash(), lastIx = eddsa.encodingLength - 1, a = hash.slice(0, eddsa.encodingLength);
                return a[0] &= 248, a[lastIx] &= 127, a[lastIx] |= 64, a;
            }), cachedProperty(KeyPair, 'priv', function() {
                return this.eddsa.decodeInt(this.privBytes());
            }), cachedProperty(KeyPair, 'hash', function() {
                return this.eddsa.hash().update(this.secret()).digest();
            }), cachedProperty(KeyPair, 'messagePrefix', function() {
                return this.hash().slice(this.eddsa.encodingLength);
            }), KeyPair.prototype.sign = function(message) {
                return assert(this._secret, 'KeyPair can only verify'), this.eddsa.sign(message, this);
            }, KeyPair.prototype.verify = function(message, sig) {
                return this.eddsa.verify(message, sig, this);
            }, KeyPair.prototype.getSecret = function(enc) {
                return assert(this._secret, 'KeyPair is public only'), utils.encode(this.secret(), enc);
            }, KeyPair.prototype.getPublic = function(enc) {
                return utils.encode(this.pubBytes(), enc);
            }, module.exports = KeyPair;
        },
        3622: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var BN = __webpack_require__(3550), utils = __webpack_require__(953), assert = utils.assert, cachedProperty = utils.cachedProperty, parseBytes = utils.parseBytes;
            function Signature(eddsa, sig) {
                this.eddsa = eddsa, 'object' != typeof sig && (sig = parseBytes(sig)), Array.isArray(sig) && (sig = {
                    R: sig.slice(0, eddsa.encodingLength),
                    S: sig.slice(eddsa.encodingLength)
                }), assert(sig.R && sig.S, 'Signature without R or S'), eddsa.isPoint(sig.R) && (this._R = sig.R), sig.S instanceof BN && (this._S = sig.S), this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded, this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
            }
            cachedProperty(Signature, 'S', function() {
                return this.eddsa.decodeInt(this.Sencoded());
            }), cachedProperty(Signature, 'R', function() {
                return this.eddsa.decodePoint(this.Rencoded());
            }), cachedProperty(Signature, 'Rencoded', function() {
                return this.eddsa.encodePoint(this.R());
            }), cachedProperty(Signature, 'Sencoded', function() {
                return this.eddsa.encodeInt(this.S());
            }), Signature.prototype.toBytes = function() {
                return this.Rencoded().concat(this.Sencoded());
            }, Signature.prototype.toHex = function() {
                return utils.encode(this.toBytes(), 'hex').toUpperCase();
            }, module.exports = Signature;
        },
        1037: function(module) {
            module.exports = {
                doubles: {
                    step: 4,
                    points: [
                        [
                            'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                            'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821', 
                        ],
                        [
                            '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                            '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf', 
                        ],
                        [
                            '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                            'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695', 
                        ],
                        [
                            '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                            '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9', 
                        ],
                        [
                            '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                            '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36', 
                        ],
                        [
                            '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                            '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f', 
                        ],
                        [
                            'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                            '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999', 
                        ],
                        [
                            '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                            'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09', 
                        ],
                        [
                            'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                            '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d', 
                        ],
                        [
                            'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                            'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088', 
                        ],
                        [
                            'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                            '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d', 
                        ],
                        [
                            '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                            '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8', 
                        ],
                        [
                            '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                            '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a', 
                        ],
                        [
                            '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                            '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453', 
                        ],
                        [
                            '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                            '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160', 
                        ],
                        [
                            '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                            '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0', 
                        ],
                        [
                            '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                            '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6', 
                        ],
                        [
                            '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                            '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589', 
                        ],
                        [
                            '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                            'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17', 
                        ],
                        [
                            'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                            '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda', 
                        ],
                        [
                            'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                            '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd', 
                        ],
                        [
                            '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                            '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2', 
                        ],
                        [
                            '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                            '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6', 
                        ],
                        [
                            'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                            '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f', 
                        ],
                        [
                            '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                            'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01', 
                        ],
                        [
                            'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                            '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3', 
                        ],
                        [
                            'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                            'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f', 
                        ],
                        [
                            'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                            '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7', 
                        ],
                        [
                            'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                            'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78', 
                        ],
                        [
                            'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                            '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1', 
                        ],
                        [
                            '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                            'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150', 
                        ],
                        [
                            '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                            '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82', 
                        ],
                        [
                            'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                            '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc', 
                        ],
                        [
                            '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                            'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b', 
                        ],
                        [
                            'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                            '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51', 
                        ],
                        [
                            'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                            '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45', 
                        ],
                        [
                            'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                            'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120', 
                        ],
                        [
                            '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                            '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84', 
                        ],
                        [
                            '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                            '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d', 
                        ],
                        [
                            '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                            'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d', 
                        ],
                        [
                            '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                            '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8', 
                        ],
                        [
                            'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                            '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8', 
                        ],
                        [
                            '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                            '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac', 
                        ],
                        [
                            '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                            'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f', 
                        ],
                        [
                            '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                            '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962', 
                        ],
                        [
                            'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                            '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907', 
                        ],
                        [
                            '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                            'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec', 
                        ],
                        [
                            'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                            'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d', 
                        ],
                        [
                            'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                            '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414', 
                        ],
                        [
                            '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                            'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd', 
                        ],
                        [
                            '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                            'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0', 
                        ],
                        [
                            'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                            '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811', 
                        ],
                        [
                            'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                            '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1', 
                        ],
                        [
                            'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                            '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c', 
                        ],
                        [
                            '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                            'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73', 
                        ],
                        [
                            '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                            '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd', 
                        ],
                        [
                            'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                            'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405', 
                        ],
                        [
                            '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                            'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589', 
                        ],
                        [
                            '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                            '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e', 
                        ],
                        [
                            '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                            '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27', 
                        ],
                        [
                            'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                            'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1', 
                        ],
                        [
                            '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                            '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482', 
                        ],
                        [
                            '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                            '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945', 
                        ],
                        [
                            'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                            '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573', 
                        ],
                        [
                            'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                            'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82', 
                        ], 
                    ]
                },
                naf: {
                    wnd: 7,
                    points: [
                        [
                            'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                            '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672', 
                        ],
                        [
                            '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                            'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6', 
                        ],
                        [
                            '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                            '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da', 
                        ],
                        [
                            'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                            'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37', 
                        ],
                        [
                            '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                            'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b', 
                        ],
                        [
                            'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                            'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81', 
                        ],
                        [
                            'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                            '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58', 
                        ],
                        [
                            'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                            '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77', 
                        ],
                        [
                            '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                            '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a', 
                        ],
                        [
                            '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                            '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c', 
                        ],
                        [
                            '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                            '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67', 
                        ],
                        [
                            '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                            '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402', 
                        ],
                        [
                            'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                            'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55', 
                        ],
                        [
                            'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                            '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482', 
                        ],
                        [
                            '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                            'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82', 
                        ],
                        [
                            '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                            'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396', 
                        ],
                        [
                            '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                            '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49', 
                        ],
                        [
                            '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                            '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf', 
                        ],
                        [
                            '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                            '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a', 
                        ],
                        [
                            '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                            'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7', 
                        ],
                        [
                            'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                            'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933', 
                        ],
                        [
                            '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                            '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a', 
                        ],
                        [
                            '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                            '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6', 
                        ],
                        [
                            'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                            'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37', 
                        ],
                        [
                            '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                            '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e', 
                        ],
                        [
                            'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                            'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6', 
                        ],
                        [
                            'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                            'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476', 
                        ],
                        [
                            '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                            '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40', 
                        ],
                        [
                            '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                            '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61', 
                        ],
                        [
                            '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                            '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683', 
                        ],
                        [
                            'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                            '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5', 
                        ],
                        [
                            '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                            '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b', 
                        ],
                        [
                            'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                            '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417', 
                        ],
                        [
                            '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                            'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868', 
                        ],
                        [
                            '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                            'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a', 
                        ],
                        [
                            'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                            'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6', 
                        ],
                        [
                            '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                            '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996', 
                        ],
                        [
                            '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                            'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e', 
                        ],
                        [
                            'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                            'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d', 
                        ],
                        [
                            '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                            '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2', 
                        ],
                        [
                            '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                            'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e', 
                        ],
                        [
                            '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                            '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437', 
                        ],
                        [
                            '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                            'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311', 
                        ],
                        [
                            'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                            '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4', 
                        ],
                        [
                            '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                            '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575', 
                        ],
                        [
                            '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                            'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d', 
                        ],
                        [
                            '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                            'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d', 
                        ],
                        [
                            'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                            'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629', 
                        ],
                        [
                            'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                            'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06', 
                        ],
                        [
                            '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                            '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374', 
                        ],
                        [
                            '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                            '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee', 
                        ],
                        [
                            'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                            '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1', 
                        ],
                        [
                            'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                            'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b', 
                        ],
                        [
                            '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                            '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661', 
                        ],
                        [
                            '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                            '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6', 
                        ],
                        [
                            'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                            '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e', 
                        ],
                        [
                            '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                            '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d', 
                        ],
                        [
                            'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                            'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc', 
                        ],
                        [
                            '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                            'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4', 
                        ],
                        [
                            '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                            '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c', 
                        ],
                        [
                            'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                            '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b', 
                        ],
                        [
                            'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                            '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913', 
                        ],
                        [
                            '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                            '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154', 
                        ],
                        [
                            '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                            '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865', 
                        ],
                        [
                            '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                            'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc', 
                        ],
                        [
                            '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                            'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224', 
                        ],
                        [
                            '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                            '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e', 
                        ],
                        [
                            '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                            '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6', 
                        ],
                        [
                            '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                            '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511', 
                        ],
                        [
                            '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                            'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b', 
                        ],
                        [
                            'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                            'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2', 
                        ],
                        [
                            '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                            'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c', 
                        ],
                        [
                            'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                            '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3', 
                        ],
                        [
                            'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                            '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d', 
                        ],
                        [
                            'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                            '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700', 
                        ],
                        [
                            'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                            '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4', 
                        ],
                        [
                            '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                            'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196', 
                        ],
                        [
                            '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                            '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4', 
                        ],
                        [
                            '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                            'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257', 
                        ],
                        [
                            'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                            'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13', 
                        ],
                        [
                            'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                            '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096', 
                        ],
                        [
                            'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                            'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38', 
                        ],
                        [
                            'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                            '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f', 
                        ],
                        [
                            '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                            '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448', 
                        ],
                        [
                            'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                            '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a', 
                        ],
                        [
                            'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                            '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4', 
                        ],
                        [
                            '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                            '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437', 
                        ],
                        [
                            '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                            'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7', 
                        ],
                        [
                            'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                            '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d', 
                        ],
                        [
                            'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                            '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a', 
                        ],
                        [
                            'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                            '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54', 
                        ],
                        [
                            '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                            '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77', 
                        ],
                        [
                            'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                            'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517', 
                        ],
                        [
                            '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                            'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10', 
                        ],
                        [
                            'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                            'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125', 
                        ],
                        [
                            'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                            '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e', 
                        ],
                        [
                            '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                            'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1', 
                        ],
                        [
                            'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                            '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2', 
                        ],
                        [
                            'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                            '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423', 
                        ],
                        [
                            'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                            '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8', 
                        ],
                        [
                            '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                            'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758', 
                        ],
                        [
                            '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                            'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375', 
                        ],
                        [
                            'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                            '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d', 
                        ],
                        [
                            '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                            'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec', 
                        ],
                        [
                            '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                            '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0', 
                        ],
                        [
                            '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                            'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c', 
                        ],
                        [
                            'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                            'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4', 
                        ],
                        [
                            '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                            'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f', 
                        ],
                        [
                            '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                            '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649', 
                        ],
                        [
                            '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                            'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826', 
                        ],
                        [
                            '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                            '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5', 
                        ],
                        [
                            'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                            'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87', 
                        ],
                        [
                            '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                            '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b', 
                        ],
                        [
                            'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                            '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc', 
                        ],
                        [
                            '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                            '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c', 
                        ],
                        [
                            'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                            'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f', 
                        ],
                        [
                            'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                            '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a', 
                        ],
                        [
                            'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                            'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46', 
                        ],
                        [
                            '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                            'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f', 
                        ],
                        [
                            '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                            '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03', 
                        ],
                        [
                            '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                            'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08', 
                        ],
                        [
                            '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                            '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8', 
                        ],
                        [
                            '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                            '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373', 
                        ],
                        [
                            '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                            'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3', 
                        ],
                        [
                            '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                            '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8', 
                        ],
                        [
                            '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                            '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1', 
                        ],
                        [
                            '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                            '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9', 
                        ], 
                    ]
                }
            };
        },
        953: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var utils = exports, BN = __webpack_require__(3550), minAssert = __webpack_require__(9746), minUtils = __webpack_require__(4504);
            function getNAF(num, w, bits) {
                var naf = Array(Math.max(num.bitLength(), bits) + 1);
                naf.fill(0);
                for(var ws = 1 << w + 1, k = num.clone(), i = 0; i < naf.length; i++){
                    var z, mod = k.andln(ws - 1);
                    k.isOdd() ? (z = mod > (ws >> 1) - 1 ? (ws >> 1) - mod : mod, k.isubn(z)) : z = 0, naf[i] = z, k.iushrn(1);
                }
                return naf;
            }
            function getJSF(k1, k2) {
                var jsf = [
                    [],
                    [], 
                ];
                k1 = k1.clone(), k2 = k2.clone();
                for(var d1 = 0, d2 = 0; k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0;){
                    var m8, u1, u2, m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;
                    3 === m14 && (m14 = -1), 3 === m24 && (m24 = -1), u1 = (1 & m14) == 0 ? 0 : (3 == (m8 = k1.andln(7) + d1 & 7) || 5 === m8) && 2 === m24 ? -m14 : m14, jsf[0].push(u1), u2 = (1 & m24) == 0 ? 0 : (3 == (m8 = k2.andln(7) + d2 & 7) || 5 === m8) && 2 === m14 ? -m24 : m24, jsf[1].push(u2), 2 * d1 === u1 + 1 && (d1 = 1 - d1), 2 * d2 === u2 + 1 && (d2 = 1 - d2), k1.iushrn(1), k2.iushrn(1);
                }
                return jsf;
            }
            function cachedProperty(obj, name, computer) {
                var key = '_' + name;
                obj.prototype[name] = function() {
                    return void 0 !== this[key] ? this[key] : this[key] = computer.call(this);
                };
            }
            function parseBytes(bytes) {
                return 'string' == typeof bytes ? utils.toArray(bytes, 'hex') : bytes;
            }
            function intFromLE(bytes) {
                return new BN(bytes, 'hex', 'le');
            }
            utils.assert = minAssert, utils.toArray = minUtils.toArray, utils.zero2 = minUtils.zero2, utils.toHex = minUtils.toHex, utils.encode = minUtils.encode, utils.getNAF = getNAF, utils.getJSF = getJSF, utils.cachedProperty = cachedProperty, utils.parseBytes = parseBytes, utils.intFromLE = intFromLE;
        },
        7187: function(module) {
            "use strict";
            var ReflectOwnKeys, R = 'object' == typeof Reflect ? Reflect : null, ReflectApply = R && 'function' == typeof R.apply ? R.apply : function(target, receiver, args) {
                return Function.prototype.apply.call(target, receiver, args);
            };
            function ProcessEmitWarning(warning) {
                console && console.warn && console.warn(warning);
            }
            ReflectOwnKeys = R && 'function' == typeof R.ownKeys ? R.ownKeys : Object.getOwnPropertySymbols ? function(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
            } : function(target) {
                return Object.getOwnPropertyNames(target);
            };
            var NumberIsNaN = Number.isNaN || function(value) {
                return value != value;
            };
            function EventEmitter() {
                EventEmitter.init.call(this);
            }
            module.exports = EventEmitter, module.exports.once = once, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._eventsCount = 0, EventEmitter.prototype._maxListeners = void 0;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
                if ('function' != typeof listener) throw TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
            }
            function _getMaxListeners(that) {
                return void 0 === that._maxListeners ? EventEmitter.defaultMaxListeners : that._maxListeners;
            }
            function _addListener(target, type, listener, prepend) {
                if (checkListener(listener), void 0 === (events = target._events) ? (events = target._events = Object.create(null), target._eventsCount = 0) : (void 0 !== events.newListener && (target.emit('newListener', type, listener.listener ? listener.listener : listener), events = target._events), existing = events[type]), void 0 === existing) existing = events[type] = listener, ++target._eventsCount;
                else if ('function' == typeof existing ? existing = events[type] = prepend ? [
                    listener,
                    existing
                ] : [
                    existing,
                    listener
                ] : prepend ? existing.unshift(listener) : existing.push(listener), (m = _getMaxListeners(target)) > 0 && existing.length > m && !existing.warned) {
                    existing.warned = !0;
                    var m, events, existing, w = Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    w.name = 'MaxListenersExceededWarning', w.emitter = target, w.type = type, w.count = existing.length, ProcessEmitWarning(w);
                }
                return target;
            }
            function onceWrapper() {
                if (!this.fired) return (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length) ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
            }
            function _onceWrap(target, type, listener) {
                var state = {
                    fired: !1,
                    wrapFn: void 0,
                    target: target,
                    type: type,
                    listener: listener
                }, wrapped = onceWrapper.bind(state);
                return wrapped.listener = listener, state.wrapFn = wrapped, wrapped;
            }
            function _listeners(target, type, unwrap) {
                var events = target._events;
                if (void 0 === events) return [];
                var evlistener = events[type];
                return void 0 === evlistener ? [] : 'function' == typeof evlistener ? unwrap ? [
                    evlistener.listener || evlistener
                ] : [
                    evlistener
                ] : unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            function listenerCount(type) {
                var events = this._events;
                if (void 0 !== events) {
                    var evlistener = events[type];
                    if ('function' == typeof evlistener) return 1;
                    if (void 0 !== evlistener) return evlistener.length;
                }
                return 0;
            }
            function arrayClone(arr, n) {
                for(var copy = Array(n), i = 0; i < n; ++i)copy[i] = arr[i];
                return copy;
            }
            function spliceOne(list, index) {
                for(; index + 1 < list.length; index++)list[index] = list[index + 1];
                list.pop();
            }
            function unwrapListeners(arr) {
                for(var ret = Array(arr.length), i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
                return ret;
            }
            function once(emitter, name) {
                return new Promise(function(resolve, reject) {
                    function errorListener(err) {
                        emitter.removeListener(name, resolver), reject(err);
                    }
                    function resolver() {
                        'function' == typeof emitter.removeListener && emitter.removeListener('error', errorListener), resolve([].slice.call(arguments));
                    }
                    eventTargetAgnosticAddListener(emitter, name, resolver, {
                        once: !0
                    }), 'error' !== name && addErrorHandlerIfEventEmitter(emitter, errorListener, {
                        once: !0
                    });
                });
            }
            function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                'function' == typeof emitter.on && eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
            }
            function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                if ('function' == typeof emitter.on) flags.once ? emitter.once(name, listener) : emitter.on(name, listener);
                else if ('function' == typeof emitter.addEventListener) emitter.addEventListener(name, function wrapListener(arg) {
                    flags.once && emitter.removeEventListener(name, wrapListener), listener(arg);
                });
                else throw TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
            }
            Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
                enumerable: !0,
                get: function() {
                    return defaultMaxListeners;
                },
                set: function(arg) {
                    if ('number' != typeof arg || arg < 0 || NumberIsNaN(arg)) throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
                    defaultMaxListeners = arg;
                }
            }), EventEmitter.init = function() {
                (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
            }, EventEmitter.prototype.setMaxListeners = function(n) {
                if ('number' != typeof n || n < 0 || NumberIsNaN(n)) throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
                return this._maxListeners = n, this;
            }, EventEmitter.prototype.getMaxListeners = function() {
                return _getMaxListeners(this);
            }, EventEmitter.prototype.emit = function(type) {
                for(var args = [], i = 1; i < arguments.length; i++)args.push(arguments[i]);
                var doError = 'error' === type, events = this._events;
                if (void 0 !== events) doError = doError && void 0 === events.error;
                else if (!doError) return !1;
                if (doError) {
                    if (args.length > 0 && (er = args[0]), er instanceof Error) throw er;
                    var er, err = Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
                    throw err.context = er, err;
                }
                var handler = events[type];
                if (void 0 === handler) return !1;
                if ('function' == typeof handler) ReflectApply(handler, this, args);
                else for(var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
                return !0;
            }, EventEmitter.prototype.addListener = function(type, listener) {
                return _addListener(this, type, listener, !1);
            }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.prependListener = function(type, listener) {
                return _addListener(this, type, listener, !0);
            }, EventEmitter.prototype.once = function(type, listener) {
                return checkListener(listener), this.on(type, _onceWrap(this, type, listener)), this;
            }, EventEmitter.prototype.prependOnceListener = function(type, listener) {
                return checkListener(listener), this.prependListener(type, _onceWrap(this, type, listener)), this;
            }, EventEmitter.prototype.removeListener = function(type, listener) {
                var list, events, position, i, originalListener;
                if (checkListener(listener), void 0 === (events = this._events) || void 0 === (list = events[type])) return this;
                if (list === listener || list.listener === listener) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete events[type], events.removeListener && this.emit('removeListener', type, list.listener || listener));
                else if ('function' != typeof list) {
                    for(position = -1, i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener, position = i;
                        break;
                    }
                    if (position < 0) return this;
                    0 === position ? list.shift() : spliceOne(list, position), 1 === list.length && (events[type] = list[0]), void 0 !== events.removeListener && this.emit('removeListener', type, originalListener || listener);
                }
                return this;
            }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.removeAllListeners = function(type) {
                var listeners, events, i;
                if (void 0 === (events = this._events)) return this;
                if (void 0 === events.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== events[type] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete events[type]), this;
                if (0 === arguments.length) {
                    var key, keys = Object.keys(events);
                    for(i = 0; i < keys.length; ++i)'removeListener' !== (key = keys[i]) && this.removeAllListeners(key);
                    return this.removeAllListeners('removeListener'), this._events = Object.create(null), this._eventsCount = 0, this;
                }
                if ('function' == typeof (listeners = events[type])) this.removeListener(type, listeners);
                else if (void 0 !== listeners) for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
                return this;
            }, EventEmitter.prototype.listeners = function(type) {
                return _listeners(this, type, !0);
            }, EventEmitter.prototype.rawListeners = function(type) {
                return _listeners(this, type, !1);
            }, EventEmitter.listenerCount = function(emitter, type) {
                return 'function' == typeof emitter.listenerCount ? emitter.listenerCount(type) : listenerCount.call(emitter, type);
            }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function() {
                return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
        },
        3346: function(module, __unused_webpack_exports, __webpack_require__) {
            !function(global, factory) {
                module.exports = factory();
            }(this, function() {
                'use strict';
                var toStringFunction = Function.prototype.toString, create = Object.create, defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getPrototypeOf$1 = Object.getPrototypeOf, _a = Object.prototype, hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable, SYMBOL_PROPERTIES = 'function' == typeof getOwnPropertySymbols, WEAK_MAP = 'function' == typeof WeakMap, createCache = function() {
                    if (WEAK_MAP) return function() {
                        return new WeakMap();
                    };
                    var Cache = function() {
                        function Cache() {
                            this._keys = [], this._values = [];
                        }
                        return Cache.prototype.has = function(key) {
                            return !!~this._keys.indexOf(key);
                        }, Cache.prototype.get = function(key) {
                            return this._values[this._keys.indexOf(key)];
                        }, Cache.prototype.set = function(key, value) {
                            this._keys.push(key), this._values.push(value);
                        }, Cache;
                    }();
                    return function() {
                        return new Cache();
                    };
                }(), getCleanClone = function(object, realm) {
                    var prototype = object.__proto__ || getPrototypeOf$1(object);
                    if (!prototype) return create(null);
                    var Constructor = prototype.constructor;
                    if (Constructor === realm.Object) return prototype === realm.Object.prototype ? {} : create(prototype);
                    if (~toStringFunction.call(Constructor).indexOf('[native code]')) try {
                        return new Constructor();
                    } catch (_a) {}
                    return create(prototype);
                }, getObjectCloneLoose = function(object, realm, handleCopy, cache) {
                    var clone = getCleanClone(object, realm);
                    for(var key in cache.set(object, clone), object)hasOwnProperty.call(object, key) && (clone[key] = handleCopy(object[key], cache));
                    if (SYMBOL_PROPERTIES) for(var symbols = getOwnPropertySymbols(object), index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index)symbol = symbols[index], propertyIsEnumerable.call(object, symbol) && (clone[symbol] = handleCopy(object[symbol], cache));
                    return clone;
                }, getObjectCloneStrict = function(object, realm, handleCopy, cache) {
                    var clone = getCleanClone(object, realm);
                    cache.set(object, clone);
                    for(var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object), index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index)if ('callee' !== (property = properties[index]) && 'caller' !== property) {
                        if (descriptor = getOwnPropertyDescriptor(object, property)) {
                            descriptor.get || descriptor.set || (descriptor.value = handleCopy(object[property], cache));
                            try {
                                defineProperty(clone, property, descriptor);
                            } catch (error) {
                                clone[property] = descriptor.value;
                            }
                        } else clone[property] = handleCopy(object[property], cache);
                    }
                    return clone;
                }, getRegExpFlags = function(regExp) {
                    var flags = '';
                    return regExp.global && (flags += 'g'), regExp.ignoreCase && (flags += 'i'), regExp.multiline && (flags += 'm'), regExp.unicode && (flags += 'u'), regExp.sticky && (flags += 'y'), flags;
                }, isArray = Array.isArray, getPrototypeOf = Object.getPrototypeOf, GLOBAL_THIS = function() {
                    return 'undefined' != typeof globalThis ? globalThis : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : void 0 !== __webpack_require__.g ? __webpack_require__.g : (console && console.error && console.error('Unable to locate global object, returning "this".'), this);
                }();
                function copy(value, options) {
                    var isStrict = !!(options && options.isStrict), realm = options && options.realm || GLOBAL_THIS, getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose, handleCopy = function(value, cache) {
                        if (!value || 'object' != typeof value) return value;
                        if (cache.has(value)) return cache.get(value);
                        var clone, prototype = value.__proto__ || getPrototypeOf(value), Constructor = prototype && prototype.constructor;
                        if (!Constructor || Constructor === realm.Object) return getObjectClone(value, realm, handleCopy, cache);
                        if (isArray(value)) {
                            if (isStrict) return getObjectCloneStrict(value, realm, handleCopy, cache);
                            clone = new Constructor(), cache.set(value, clone);
                            for(var index = 0, length_1 = value.length; index < length_1; ++index)clone[index] = handleCopy(value[index], cache);
                            return clone;
                        }
                        if (value instanceof realm.Date) return new Constructor(value.getTime());
                        if (value instanceof realm.RegExp) return (clone = new Constructor(value.source, value.flags || getRegExpFlags(value))).lastIndex = value.lastIndex, clone;
                        if (realm.Map && value instanceof realm.Map) return clone = new Constructor(), cache.set(value, clone), value.forEach(function(value, key) {
                            clone.set(key, handleCopy(value, cache));
                        }), clone;
                        if (realm.Set && value instanceof realm.Set) return clone = new Constructor(), cache.set(value, clone), value.forEach(function(value) {
                            clone.add(handleCopy(value, cache));
                        }), clone;
                        if (realm.Blob && value instanceof realm.Blob) return value.slice(0, value.size, value.type);
                        if (realm.Buffer && realm.Buffer.isBuffer(value)) return clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value.length) : new Constructor(value.length), cache.set(value, clone), value.copy(clone), clone;
                        if (realm.ArrayBuffer) {
                            if (realm.ArrayBuffer.isView(value)) return clone = new Constructor(value.buffer.slice(0)), cache.set(value, clone), clone;
                            if (value instanceof realm.ArrayBuffer) return clone = value.slice(0), cache.set(value, clone), clone;
                        }
                        return 'function' == typeof value.then || value instanceof Error || realm.WeakMap && value instanceof realm.WeakMap || realm.WeakSet && value instanceof realm.WeakSet ? value : getObjectClone(value, realm, handleCopy, cache);
                    };
                    return handleCopy(value, createCache());
                }
                return copy.default = copy, copy.strict = function(value, options) {
                    return copy(value, {
                        isStrict: !0,
                        realm: options ? options.realm : void 0
                    });
                }, copy;
            });
        },
        4029: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var isCallable = __webpack_require__(5320), toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(array, iterator, receiver) {
                for(var i = 0, len = array.length; i < len; i++)hasOwnProperty.call(array, i) && (null == receiver ? iterator(array[i], i, array) : iterator.call(receiver, array[i], i, array));
            }, forEachString = function(string, iterator, receiver) {
                for(var i = 0, len = string.length; i < len; i++)null == receiver ? iterator(string.charAt(i), i, string) : iterator.call(receiver, string.charAt(i), i, string);
            }, forEachObject = function(object, iterator, receiver) {
                for(var k in object)hasOwnProperty.call(object, k) && (null == receiver ? iterator(object[k], k, object) : iterator.call(receiver, object[k], k, object));
            }, forEach = function(list, iterator, thisArg) {
                var receiver;
                if (!isCallable(iterator)) throw TypeError('iterator must be a function');
                arguments.length >= 3 && (receiver = thisArg), '[object Array]' === toStr.call(list) ? forEachArray(list, iterator, receiver) : 'string' == typeof list ? forEachString(list, iterator, receiver) : forEachObject(list, iterator, receiver);
            };
            module.exports = forEach;
        },
        7648: function(module) {
            "use strict";
            var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ', slice = Array.prototype.slice, toStr = Object.prototype.toString, funcType = '[object Function]';
            module.exports = function(that) {
                var bound, target = this;
                if ('function' != typeof target || toStr.call(target) !== funcType) throw TypeError(ERROR_MESSAGE + target);
                for(var args = slice.call(arguments, 1), binder = function() {
                    if (!(this instanceof bound)) return target.apply(that, args.concat(slice.call(arguments)));
                    var result = target.apply(this, args.concat(slice.call(arguments)));
                    return Object(result) === result ? result : this;
                }, boundLength = Math.max(0, target.length - args.length), boundArgs = [], i = 0; i < boundLength; i++)boundArgs.push('$' + i);
                if (bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder), target.prototype) {
                    var Empty = function() {};
                    Empty.prototype = target.prototype, bound.prototype = new Empty(), Empty.prototype = null;
                }
                return bound;
            };
        },
        8612: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var implementation = __webpack_require__(7648);
            module.exports = Function.prototype.bind || implementation;
        },
        4977: function(module) {
            "use strict";
            module.exports = createRBTree;
            var RED = 0, BLACK = 1;
            function RBNode(color, key, value, left, right, count) {
                this._color = color, this.key = key, this.value = value, this.left = left, this.right = right, this._count = count;
            }
            function cloneNode(node) {
                return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
            }
            function repaint(color, node) {
                return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
            }
            function recount(node) {
                node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
            }
            function RedBlackTree(compare, root) {
                this._compare = compare, this.root = root;
            }
            var proto = RedBlackTree.prototype;
            function doVisitFull(visit, node) {
                if (node.left) {
                    var v = doVisitFull(visit, node.left);
                    if (v) return v;
                }
                var v = visit(node.key, node.value);
                return v || (node.right ? doVisitFull(visit, node.right) : void 0);
            }
            function doVisitHalf(lo, compare, visit, node) {
                if (0 >= compare(lo, node.key)) {
                    if (node.left) {
                        var v = doVisitHalf(lo, compare, visit, node.left);
                        if (v) return v;
                    }
                    var v = visit(node.key, node.value);
                    if (v) return v;
                }
                if (node.right) return doVisitHalf(lo, compare, visit, node.right);
            }
            function doVisit(lo, hi, compare, visit, node) {
                var v, l = compare(lo, node.key), h = compare(hi, node.key);
                return l <= 0 && (node.left && (v = doVisit(lo, hi, compare, visit, node.left)) || h > 0 && (v = visit(node.key, node.value))) ? v : h > 0 && node.right ? doVisit(lo, hi, compare, visit, node.right) : void 0;
            }
            function RedBlackTreeIterator(tree, stack) {
                this.tree = tree, this._stack = stack;
            }
            Object.defineProperty(proto, "keys", {
                get: function() {
                    var result = [];
                    return this.forEach(function(k, v) {
                        result.push(k);
                    }), result;
                }
            }), Object.defineProperty(proto, "values", {
                get: function() {
                    var result = [];
                    return this.forEach(function(k, v) {
                        result.push(v);
                    }), result;
                }
            }), Object.defineProperty(proto, "length", {
                get: function() {
                    return this.root ? this.root._count : 0;
                }
            }), proto.insert = function(key, value) {
                for(var cmp = this._compare, n = this.root, n_stack = [], d_stack = []; n;){
                    var d = cmp(key, n.key);
                    n_stack.push(n), d_stack.push(d), n = d <= 0 ? n.left : n.right;
                }
                n_stack.push(new RBNode(RED, key, value, null, null, 1));
                for(var s = n_stack.length - 2; s >= 0; --s){
                    var n = n_stack[s];
                    d_stack[s] <= 0 ? n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1) : n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
                }
                for(var s = n_stack.length - 1; s > 1; --s){
                    var p = n_stack[s - 1], n = n_stack[s];
                    if (p._color === BLACK || n._color === BLACK) break;
                    var pp = n_stack[s - 2];
                    if (pp.left === p) {
                        if (p.left === n) {
                            var y = pp.right;
                            if (y && y._color === RED) p._color = BLACK, pp.right = repaint(BLACK, y), pp._color = RED, s -= 1;
                            else {
                                if (pp._color = RED, pp.left = p.right, p._color = BLACK, p.right = pp, n_stack[s - 2] = p, n_stack[s - 1] = n, recount(pp), recount(p), s >= 3) {
                                    var ppp = n_stack[s - 3];
                                    ppp.left === pp ? ppp.left = p : ppp.right = p;
                                }
                                break;
                            }
                        } else {
                            var y = pp.right;
                            if (y && y._color === RED) p._color = BLACK, pp.right = repaint(BLACK, y), pp._color = RED, s -= 1;
                            else {
                                if (p.right = n.left, pp._color = RED, pp.left = n.right, n._color = BLACK, n.left = p, n.right = pp, n_stack[s - 2] = n, n_stack[s - 1] = p, recount(pp), recount(p), recount(n), s >= 3) {
                                    var ppp = n_stack[s - 3];
                                    ppp.left === pp ? ppp.left = n : ppp.right = n;
                                }
                                break;
                            }
                        }
                    } else if (p.right === n) {
                        var y = pp.left;
                        if (y && y._color === RED) p._color = BLACK, pp.left = repaint(BLACK, y), pp._color = RED, s -= 1;
                        else {
                            if (pp._color = RED, pp.right = p.left, p._color = BLACK, p.left = pp, n_stack[s - 2] = p, n_stack[s - 1] = n, recount(pp), recount(p), s >= 3) {
                                var ppp = n_stack[s - 3];
                                ppp.right === pp ? ppp.right = p : ppp.left = p;
                            }
                            break;
                        }
                    } else {
                        var y = pp.left;
                        if (y && y._color === RED) p._color = BLACK, pp.left = repaint(BLACK, y), pp._color = RED, s -= 1;
                        else {
                            if (p.left = n.right, pp._color = RED, pp.right = n.left, n._color = BLACK, n.right = p, n.left = pp, n_stack[s - 2] = n, n_stack[s - 1] = p, recount(pp), recount(p), recount(n), s >= 3) {
                                var ppp = n_stack[s - 3];
                                ppp.right === pp ? ppp.right = n : ppp.left = n;
                            }
                            break;
                        }
                    }
                }
                return n_stack[0]._color = BLACK, new RedBlackTree(cmp, n_stack[0]);
            }, proto.forEach = function(visit, lo, hi) {
                if (this.root) switch(arguments.length){
                    case 1:
                        return doVisitFull(visit, this.root);
                    case 2:
                        return doVisitHalf(lo, this._compare, visit, this.root);
                    case 3:
                        if (this._compare(lo, hi) >= 0) return;
                        return doVisit(lo, hi, this._compare, visit, this.root);
                }
            }, Object.defineProperty(proto, "begin", {
                get: function() {
                    for(var stack = [], n = this.root; n;)stack.push(n), n = n.left;
                    return new RedBlackTreeIterator(this, stack);
                }
            }), Object.defineProperty(proto, "end", {
                get: function() {
                    for(var stack = [], n = this.root; n;)stack.push(n), n = n.right;
                    return new RedBlackTreeIterator(this, stack);
                }
            }), proto.at = function(idx) {
                if (idx < 0) return new RedBlackTreeIterator(this, []);
                for(var n = this.root, stack = [];;){
                    if (stack.push(n), n.left) {
                        if (idx < n.left._count) {
                            n = n.left;
                            continue;
                        }
                        idx -= n.left._count;
                    }
                    if (!idx) return new RedBlackTreeIterator(this, stack);
                    if (idx -= 1, n.right) {
                        if (idx >= n.right._count) break;
                        n = n.right;
                    } else break;
                }
                return new RedBlackTreeIterator(this, []);
            }, proto.ge = function(key) {
                for(var cmp = this._compare, n = this.root, stack = [], last_ptr = 0; n;){
                    var d = cmp(key, n.key);
                    stack.push(n), d <= 0 && (last_ptr = stack.length), n = d <= 0 ? n.left : n.right;
                }
                return stack.length = last_ptr, new RedBlackTreeIterator(this, stack);
            }, proto.gt = function(key) {
                for(var cmp = this._compare, n = this.root, stack = [], last_ptr = 0; n;){
                    var d = cmp(key, n.key);
                    stack.push(n), d < 0 && (last_ptr = stack.length), n = d < 0 ? n.left : n.right;
                }
                return stack.length = last_ptr, new RedBlackTreeIterator(this, stack);
            }, proto.lt = function(key) {
                for(var cmp = this._compare, n = this.root, stack = [], last_ptr = 0; n;){
                    var d = cmp(key, n.key);
                    stack.push(n), d > 0 && (last_ptr = stack.length), n = d <= 0 ? n.left : n.right;
                }
                return stack.length = last_ptr, new RedBlackTreeIterator(this, stack);
            }, proto.le = function(key) {
                for(var cmp = this._compare, n = this.root, stack = [], last_ptr = 0; n;){
                    var d = cmp(key, n.key);
                    stack.push(n), d >= 0 && (last_ptr = stack.length), n = d < 0 ? n.left : n.right;
                }
                return stack.length = last_ptr, new RedBlackTreeIterator(this, stack);
            }, proto.find = function(key) {
                for(var cmp = this._compare, n = this.root, stack = []; n;){
                    var d = cmp(key, n.key);
                    if (stack.push(n), 0 === d) return new RedBlackTreeIterator(this, stack);
                    n = d <= 0 ? n.left : n.right;
                }
                return new RedBlackTreeIterator(this, []);
            }, proto.remove = function(key) {
                var iter = this.find(key);
                return iter ? iter.remove() : this;
            }, proto.get = function(key) {
                for(var cmp = this._compare, n = this.root; n;){
                    var d = cmp(key, n.key);
                    if (0 === d) return n.value;
                    n = d <= 0 ? n.left : n.right;
                }
            };
            var iproto = RedBlackTreeIterator.prototype;
            function swapNode(n, v) {
                n.key = v.key, n.value = v.value, n.left = v.left, n.right = v.right, n._color = v._color, n._count = v._count;
            }
            function fixDoubleBlack(stack) {
                for(var n, p, s, z, i = stack.length - 1; i >= 0; --i){
                    if (n = stack[i], 0 === i) {
                        n._color = BLACK;
                        return;
                    }
                    if ((p = stack[i - 1]).left === n) {
                        if ((s = p.right).right && s.right._color === RED) {
                            if (z = (s = p.right = cloneNode(s)).right = cloneNode(s.right), p.right = s.left, s.left = p, s.right = z, s._color = p._color, n._color = BLACK, p._color = BLACK, z._color = BLACK, recount(p), recount(s), i > 1) {
                                var pp = stack[i - 2];
                                pp.left === p ? pp.left = s : pp.right = s;
                            }
                            stack[i - 1] = s;
                            return;
                        }
                        if (s.left && s.left._color === RED) {
                            if (z = (s = p.right = cloneNode(s)).left = cloneNode(s.left), p.right = z.left, s.left = z.right, z.left = p, z.right = s, z._color = p._color, p._color = BLACK, s._color = BLACK, n._color = BLACK, recount(p), recount(s), recount(z), i > 1) {
                                var pp = stack[i - 2];
                                pp.left === p ? pp.left = z : pp.right = z;
                            }
                            stack[i - 1] = z;
                            return;
                        }
                        if (s._color === BLACK) {
                            if (p._color === RED) {
                                p._color = BLACK, p.right = repaint(RED, s);
                                return;
                            }
                            p.right = repaint(RED, s);
                            continue;
                        }
                        if (s = cloneNode(s), p.right = s.left, s.left = p, s._color = p._color, p._color = RED, recount(p), recount(s), i > 1) {
                            var pp = stack[i - 2];
                            pp.left === p ? pp.left = s : pp.right = s;
                        }
                        stack[i - 1] = s, stack[i] = p, i + 1 < stack.length ? stack[i + 1] = n : stack.push(n), i += 2;
                    } else {
                        if ((s = p.left).left && s.left._color === RED) {
                            if (z = (s = p.left = cloneNode(s)).left = cloneNode(s.left), p.left = s.right, s.right = p, s.left = z, s._color = p._color, n._color = BLACK, p._color = BLACK, z._color = BLACK, recount(p), recount(s), i > 1) {
                                var pp = stack[i - 2];
                                pp.right === p ? pp.right = s : pp.left = s;
                            }
                            stack[i - 1] = s;
                            return;
                        }
                        if (s.right && s.right._color === RED) {
                            if (z = (s = p.left = cloneNode(s)).right = cloneNode(s.right), p.left = z.right, s.right = z.left, z.right = p, z.left = s, z._color = p._color, p._color = BLACK, s._color = BLACK, n._color = BLACK, recount(p), recount(s), recount(z), i > 1) {
                                var pp = stack[i - 2];
                                pp.right === p ? pp.right = z : pp.left = z;
                            }
                            stack[i - 1] = z;
                            return;
                        }
                        if (s._color === BLACK) {
                            if (p._color === RED) {
                                p._color = BLACK, p.left = repaint(RED, s);
                                return;
                            }
                            p.left = repaint(RED, s);
                            continue;
                        }
                        if (s = cloneNode(s), p.left = s.right, s.right = p, s._color = p._color, p._color = RED, recount(p), recount(s), i > 1) {
                            var pp = stack[i - 2];
                            pp.right === p ? pp.right = s : pp.left = s;
                        }
                        stack[i - 1] = s, stack[i] = p, i + 1 < stack.length ? stack[i + 1] = n : stack.push(n), i += 2;
                    }
                }
            }
            function defaultCompare(a, b) {
                return a < b ? -1 : a > b ? 1 : 0;
            }
            function createRBTree(compare) {
                return new RedBlackTree(compare || defaultCompare, null);
            }
            Object.defineProperty(iproto, "valid", {
                get: function() {
                    return this._stack.length > 0;
                }
            }), Object.defineProperty(iproto, "node", {
                get: function() {
                    return this._stack.length > 0 ? this._stack[this._stack.length - 1] : null;
                },
                enumerable: !0
            }), iproto.clone = function() {
                return new RedBlackTreeIterator(this.tree, this._stack.slice());
            }, iproto.remove = function() {
                var stack = this._stack;
                if (0 === stack.length) return this.tree;
                var cstack = Array(stack.length), n = stack[stack.length - 1];
                cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
                for(var i = stack.length - 2; i >= 0; --i){
                    var n = stack[i];
                    n.left === stack[i + 1] ? cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count) : cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
                }
                if ((n = cstack[cstack.length - 1]).left && n.right) {
                    var split = cstack.length;
                    for(n = n.left; n.right;)cstack.push(n), n = n.right;
                    var v = cstack[split - 1];
                    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count)), cstack[split - 1].key = n.key, cstack[split - 1].value = n.value;
                    for(var i = cstack.length - 2; i >= split; --i)n = cstack[i], cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
                    cstack[split - 1].left = cstack[split];
                }
                if ((n = cstack[cstack.length - 1])._color === RED) {
                    var p = cstack[cstack.length - 2];
                    p.left === n ? p.left = null : p.right === n && (p.right = null), cstack.pop();
                    for(var i = 0; i < cstack.length; ++i)cstack[i]._count--;
                } else if (n.left || n.right) {
                    n.left ? swapNode(n, n.left) : n.right && swapNode(n, n.right), n._color = BLACK;
                    for(var i = 0; i < cstack.length - 1; ++i)cstack[i]._count--;
                } else {
                    if (1 === cstack.length) return new RedBlackTree(this.tree._compare, null);
                    for(var i = 0; i < cstack.length; ++i)cstack[i]._count--;
                    var parent = cstack[cstack.length - 2];
                    fixDoubleBlack(cstack), parent.left === n ? parent.left = null : parent.right = null;
                }
                return new RedBlackTree(this.tree._compare, cstack[0]);
            }, Object.defineProperty(iproto, "key", {
                get: function() {
                    if (this._stack.length > 0) return this._stack[this._stack.length - 1].key;
                },
                enumerable: !0
            }), Object.defineProperty(iproto, "value", {
                get: function() {
                    if (this._stack.length > 0) return this._stack[this._stack.length - 1].value;
                },
                enumerable: !0
            }), Object.defineProperty(iproto, "index", {
                get: function() {
                    var idx = 0, stack = this._stack;
                    if (0 === stack.length) {
                        var r = this.tree.root;
                        return r ? r._count : 0;
                    }
                    stack[stack.length - 1].left && (idx = stack[stack.length - 1].left._count);
                    for(var s = stack.length - 2; s >= 0; --s)stack[s + 1] === stack[s].right && (++idx, stack[s].left && (idx += stack[s].left._count));
                    return idx;
                },
                enumerable: !0
            }), iproto.next = function() {
                var stack = this._stack;
                if (0 !== stack.length) {
                    var n = stack[stack.length - 1];
                    if (n.right) for(n = n.right; n;)stack.push(n), n = n.left;
                    else for(stack.pop(); stack.length > 0 && stack[stack.length - 1].right === n;)n = stack[stack.length - 1], stack.pop();
                }
            }, Object.defineProperty(iproto, "hasNext", {
                get: function() {
                    var stack = this._stack;
                    if (0 === stack.length) return !1;
                    if (stack[stack.length - 1].right) return !0;
                    for(var s = stack.length - 1; s > 0; --s)if (stack[s - 1].left === stack[s]) return !0;
                    return !1;
                }
            }), iproto.update = function(value) {
                var stack = this._stack;
                if (0 === stack.length) throw Error("Can't update empty node!");
                var cstack = Array(stack.length), n = stack[stack.length - 1];
                cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
                for(var i = stack.length - 2; i >= 0; --i)(n = stack[i]).left === stack[i + 1] ? cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count) : cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
                return new RedBlackTree(this.tree._compare, cstack[0]);
            }, iproto.prev = function() {
                var stack = this._stack;
                if (0 !== stack.length) {
                    var n = stack[stack.length - 1];
                    if (n.left) for(n = n.left; n;)stack.push(n), n = n.right;
                    else for(stack.pop(); stack.length > 0 && stack[stack.length - 1].left === n;)n = stack[stack.length - 1], stack.pop();
                }
            }, Object.defineProperty(iproto, "hasPrev", {
                get: function() {
                    var stack = this._stack;
                    if (0 === stack.length) return !1;
                    if (stack[stack.length - 1].left) return !0;
                    for(var s = stack.length - 1; s > 0; --s)if (stack[s - 1].right === stack[s]) return !0;
                    return !1;
                }
            });
        },
        210: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var undefined, $SyntaxError = SyntaxError, $Function = Function, $TypeError = TypeError, getEvalledConstructor = function(expressionSyntax) {
                try {
                    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                } catch (e) {}
            }, $gOPD = Object.getOwnPropertyDescriptor;
            if ($gOPD) try {
                $gOPD({}, '');
            } catch (e) {
                $gOPD = null;
            }
            var throwTypeError = function() {
                throw new $TypeError();
            }, ThrowTypeError = $gOPD ? function() {
                try {
                    return arguments.callee, throwTypeError;
                } catch (calleeThrows) {
                    try {
                        return $gOPD(arguments, 'callee').get;
                    } catch (gOPDthrows) {
                        return throwTypeError;
                    }
                }
            }() : throwTypeError, hasSymbols = __webpack_require__(1405)(), getProto = Object.getPrototypeOf || function(x) {
                return x.__proto__;
            }, needsEval = {}, TypedArray = 'undefined' == typeof Uint8Array ? undefined : getProto(Uint8Array), INTRINSICS = {
                '%AggregateError%': 'undefined' == typeof AggregateError ? undefined : AggregateError,
                '%Array%': Array,
                '%ArrayBuffer%': 'undefined' == typeof ArrayBuffer ? undefined : ArrayBuffer,
                '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
                '%AsyncFromSyncIteratorPrototype%': undefined,
                '%AsyncFunction%': needsEval,
                '%AsyncGenerator%': needsEval,
                '%AsyncGeneratorFunction%': needsEval,
                '%AsyncIteratorPrototype%': needsEval,
                '%Atomics%': 'undefined' == typeof Atomics ? undefined : Atomics,
                '%BigInt%': 'undefined' == typeof BigInt ? undefined : BigInt,
                '%Boolean%': Boolean,
                '%DataView%': 'undefined' == typeof DataView ? undefined : DataView,
                '%Date%': Date,
                '%decodeURI%': decodeURI,
                '%decodeURIComponent%': decodeURIComponent,
                '%encodeURI%': encodeURI,
                '%encodeURIComponent%': encodeURIComponent,
                '%Error%': Error,
                '%eval%': eval,
                '%EvalError%': EvalError,
                '%Float32Array%': 'undefined' == typeof Float32Array ? undefined : Float32Array,
                '%Float64Array%': 'undefined' == typeof Float64Array ? undefined : Float64Array,
                '%FinalizationRegistry%': 'undefined' == typeof FinalizationRegistry ? undefined : FinalizationRegistry,
                '%Function%': $Function,
                '%GeneratorFunction%': needsEval,
                '%Int8Array%': 'undefined' == typeof Int8Array ? undefined : Int8Array,
                '%Int16Array%': 'undefined' == typeof Int16Array ? undefined : Int16Array,
                '%Int32Array%': 'undefined' == typeof Int32Array ? undefined : Int32Array,
                '%isFinite%': isFinite,
                '%isNaN%': isNaN,
                '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
                '%JSON%': 'object' == typeof JSON ? JSON : undefined,
                '%Map%': 'undefined' == typeof Map ? undefined : Map,
                '%MapIteratorPrototype%': 'undefined' != typeof Map && hasSymbols ? getProto(new Map()[Symbol.iterator]()) : undefined,
                '%Math%': Math,
                '%Number%': Number,
                '%Object%': Object,
                '%parseFloat%': parseFloat,
                '%parseInt%': parseInt,
                '%Promise%': 'undefined' == typeof Promise ? undefined : Promise,
                '%Proxy%': 'undefined' == typeof Proxy ? undefined : Proxy,
                '%RangeError%': RangeError,
                '%ReferenceError%': ReferenceError,
                '%Reflect%': 'undefined' == typeof Reflect ? undefined : Reflect,
                '%RegExp%': RegExp,
                '%Set%': 'undefined' == typeof Set ? undefined : Set,
                '%SetIteratorPrototype%': 'undefined' != typeof Set && hasSymbols ? getProto(new Set()[Symbol.iterator]()) : undefined,
                '%SharedArrayBuffer%': 'undefined' == typeof SharedArrayBuffer ? undefined : SharedArrayBuffer,
                '%String%': String,
                '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
                '%Symbol%': hasSymbols ? Symbol : undefined,
                '%SyntaxError%': $SyntaxError,
                '%ThrowTypeError%': ThrowTypeError,
                '%TypedArray%': TypedArray,
                '%TypeError%': $TypeError,
                '%Uint8Array%': 'undefined' == typeof Uint8Array ? undefined : Uint8Array,
                '%Uint8ClampedArray%': 'undefined' == typeof Uint8ClampedArray ? undefined : Uint8ClampedArray,
                '%Uint16Array%': 'undefined' == typeof Uint16Array ? undefined : Uint16Array,
                '%Uint32Array%': 'undefined' == typeof Uint32Array ? undefined : Uint32Array,
                '%URIError%': URIError,
                '%WeakMap%': 'undefined' == typeof WeakMap ? undefined : WeakMap,
                '%WeakRef%': 'undefined' == typeof WeakRef ? undefined : WeakRef,
                '%WeakSet%': 'undefined' == typeof WeakSet ? undefined : WeakSet
            }, doEval = function doEval(name) {
                var value;
                if ('%AsyncFunction%' === name) value = getEvalledConstructor('async function () {}');
                else if ('%GeneratorFunction%' === name) value = getEvalledConstructor('function* () {}');
                else if ('%AsyncGeneratorFunction%' === name) value = getEvalledConstructor('async function* () {}');
                else if ('%AsyncGenerator%' === name) {
                    var fn = doEval('%AsyncGeneratorFunction%');
                    fn && (value = fn.prototype);
                } else if ('%AsyncIteratorPrototype%' === name) {
                    var gen = doEval('%AsyncGenerator%');
                    gen && (value = getProto(gen.prototype));
                }
                return INTRINSICS[name] = value, value;
            }, LEGACY_ALIASES = {
                '%ArrayBufferPrototype%': [
                    'ArrayBuffer',
                    'prototype'
                ],
                '%ArrayPrototype%': [
                    'Array',
                    'prototype'
                ],
                '%ArrayProto_entries%': [
                    'Array',
                    'prototype',
                    'entries'
                ],
                '%ArrayProto_forEach%': [
                    'Array',
                    'prototype',
                    'forEach'
                ],
                '%ArrayProto_keys%': [
                    'Array',
                    'prototype',
                    'keys'
                ],
                '%ArrayProto_values%': [
                    'Array',
                    'prototype',
                    'values'
                ],
                '%AsyncFunctionPrototype%': [
                    'AsyncFunction',
                    'prototype'
                ],
                '%AsyncGenerator%': [
                    'AsyncGeneratorFunction',
                    'prototype'
                ],
                '%AsyncGeneratorPrototype%': [
                    'AsyncGeneratorFunction',
                    'prototype',
                    'prototype'
                ],
                '%BooleanPrototype%': [
                    'Boolean',
                    'prototype'
                ],
                '%DataViewPrototype%': [
                    'DataView',
                    'prototype'
                ],
                '%DatePrototype%': [
                    'Date',
                    'prototype'
                ],
                '%ErrorPrototype%': [
                    'Error',
                    'prototype'
                ],
                '%EvalErrorPrototype%': [
                    'EvalError',
                    'prototype'
                ],
                '%Float32ArrayPrototype%': [
                    'Float32Array',
                    'prototype'
                ],
                '%Float64ArrayPrototype%': [
                    'Float64Array',
                    'prototype'
                ],
                '%FunctionPrototype%': [
                    'Function',
                    'prototype'
                ],
                '%Generator%': [
                    'GeneratorFunction',
                    'prototype'
                ],
                '%GeneratorPrototype%': [
                    'GeneratorFunction',
                    'prototype',
                    'prototype'
                ],
                '%Int8ArrayPrototype%': [
                    'Int8Array',
                    'prototype'
                ],
                '%Int16ArrayPrototype%': [
                    'Int16Array',
                    'prototype'
                ],
                '%Int32ArrayPrototype%': [
                    'Int32Array',
                    'prototype'
                ],
                '%JSONParse%': [
                    'JSON',
                    'parse'
                ],
                '%JSONStringify%': [
                    'JSON',
                    'stringify'
                ],
                '%MapPrototype%': [
                    'Map',
                    'prototype'
                ],
                '%NumberPrototype%': [
                    'Number',
                    'prototype'
                ],
                '%ObjectPrototype%': [
                    'Object',
                    'prototype'
                ],
                '%ObjProto_toString%': [
                    'Object',
                    'prototype',
                    'toString'
                ],
                '%ObjProto_valueOf%': [
                    'Object',
                    'prototype',
                    'valueOf'
                ],
                '%PromisePrototype%': [
                    'Promise',
                    'prototype'
                ],
                '%PromiseProto_then%': [
                    'Promise',
                    'prototype',
                    'then'
                ],
                '%Promise_all%': [
                    'Promise',
                    'all'
                ],
                '%Promise_reject%': [
                    'Promise',
                    'reject'
                ],
                '%Promise_resolve%': [
                    'Promise',
                    'resolve'
                ],
                '%RangeErrorPrototype%': [
                    'RangeError',
                    'prototype'
                ],
                '%ReferenceErrorPrototype%': [
                    'ReferenceError',
                    'prototype'
                ],
                '%RegExpPrototype%': [
                    'RegExp',
                    'prototype'
                ],
                '%SetPrototype%': [
                    'Set',
                    'prototype'
                ],
                '%SharedArrayBufferPrototype%': [
                    'SharedArrayBuffer',
                    'prototype'
                ],
                '%StringPrototype%': [
                    'String',
                    'prototype'
                ],
                '%SymbolPrototype%': [
                    'Symbol',
                    'prototype'
                ],
                '%SyntaxErrorPrototype%': [
                    'SyntaxError',
                    'prototype'
                ],
                '%TypedArrayPrototype%': [
                    'TypedArray',
                    'prototype'
                ],
                '%TypeErrorPrototype%': [
                    'TypeError',
                    'prototype'
                ],
                '%Uint8ArrayPrototype%': [
                    'Uint8Array',
                    'prototype'
                ],
                '%Uint8ClampedArrayPrototype%': [
                    'Uint8ClampedArray',
                    'prototype'
                ],
                '%Uint16ArrayPrototype%': [
                    'Uint16Array',
                    'prototype'
                ],
                '%Uint32ArrayPrototype%': [
                    'Uint32Array',
                    'prototype'
                ],
                '%URIErrorPrototype%': [
                    'URIError',
                    'prototype'
                ],
                '%WeakMapPrototype%': [
                    'WeakMap',
                    'prototype'
                ],
                '%WeakSetPrototype%': [
                    'WeakSet',
                    'prototype'
                ]
            }, bind = __webpack_require__(8612), hasOwn = __webpack_require__(7642), $concat = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(string) {
                var first = $strSlice(string, 0, 1), last = $strSlice(string, -1);
                if ('%' === first && '%' !== last) throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                if ('%' === last && '%' !== first) throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                var result = [];
                return $replace(string, rePropName, function(match, number, quote, subString) {
                    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                }), result;
            }, getBaseIntrinsic = function(name, allowMissing) {
                var alias, intrinsicName = name;
                if (hasOwn(LEGACY_ALIASES, intrinsicName) && (intrinsicName = '%' + (alias = LEGACY_ALIASES[intrinsicName])[0] + '%'), hasOwn(INTRINSICS, intrinsicName)) {
                    var value = INTRINSICS[intrinsicName];
                    if (value === needsEval && (value = doEval(intrinsicName)), void 0 === value && !allowMissing) throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                    return {
                        alias: alias,
                        name: intrinsicName,
                        value: value
                    };
                }
                throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
            };
            module.exports = function(name, allowMissing) {
                if ('string' != typeof name || 0 === name.length) throw new $TypeError('intrinsic name must be a non-empty string');
                if (arguments.length > 1 && 'boolean' != typeof allowMissing) throw new $TypeError('"allowMissing" argument must be a boolean');
                if (null === $exec(/^%?[^%]*%?$/g, name)) throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                var parts = stringToPath(name), intrinsicBaseName = parts.length > 0 ? parts[0] : '', intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing), intrinsicRealName = intrinsic.name, value = intrinsic.value, skipFurtherCaching = !1, alias = intrinsic.alias;
                alias && (intrinsicBaseName = alias[0], $spliceApply(parts, $concat([
                    0,
                    1
                ], alias)));
                for(var i = 1, isOwn = !0; i < parts.length; i += 1){
                    var part = parts[i], first = $strSlice(part, 0, 1), last = $strSlice(part, -1);
                    if (('"' === first || "'" === first || '`' === first || '"' === last || "'" === last || '`' === last) && first !== last) throw new $SyntaxError('property names with quotes must have matching quotes');
                    if ('constructor' !== part && isOwn || (skipFurtherCaching = !0), intrinsicBaseName += '.' + part, hasOwn(INTRINSICS, intrinsicRealName = '%' + intrinsicBaseName + '%')) value = INTRINSICS[intrinsicRealName];
                    else if (null != value) {
                        if (!(part in value)) {
                            if (!allowMissing) throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                            return;
                        }
                        if ($gOPD && i + 1 >= parts.length) {
                            var desc = $gOPD(value, part);
                            value = (isOwn = !!desc) && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[part];
                        } else isOwn = hasOwn(value, part), value = value[part];
                        isOwn && !skipFurtherCaching && (INTRINSICS[intrinsicRealName] = value);
                    }
                }
                return value;
            };
        },
        1405: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var origSymbol = 'undefined' != typeof Symbol && Symbol, hasSymbolSham = __webpack_require__(5419);
            module.exports = function() {
                return 'function' == typeof origSymbol && 'function' == typeof Symbol && 'symbol' == typeof origSymbol('foo') && 'symbol' == typeof Symbol('bar') && hasSymbolSham();
            };
        },
        5419: function(module) {
            "use strict";
            module.exports = function() {
                if ('function' != typeof Symbol || 'function' != typeof Object.getOwnPropertySymbols) return !1;
                if ('symbol' == typeof Symbol.iterator) return !0;
                var obj = {}, sym = Symbol('test'), symObj = Object(sym);
                if ('string' == typeof sym || '[object Symbol]' !== Object.prototype.toString.call(sym) || '[object Symbol]' !== Object.prototype.toString.call(symObj)) return !1;
                var symVal = 42;
                for(sym in obj[sym] = symVal, obj)return !1;
                if ('function' == typeof Object.keys && 0 !== Object.keys(obj).length || 'function' == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(obj).length) return !1;
                var syms = Object.getOwnPropertySymbols(obj);
                if (1 !== syms.length || syms[0] !== sym || !Object.prototype.propertyIsEnumerable.call(obj, sym)) return !1;
                if ('function' == typeof Object.getOwnPropertyDescriptor) {
                    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                    if (descriptor.value !== symVal || !0 !== descriptor.enumerable) return !1;
                }
                return !0;
            };
        },
        6410: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var hasSymbols = __webpack_require__(5419);
            module.exports = function() {
                return hasSymbols() && !!Symbol.toStringTag;
            };
        },
        7642: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var bind = __webpack_require__(8612);
            module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
        },
        3715: function(__unused_webpack_module, exports, __webpack_require__) {
            var hash = exports;
            hash.utils = __webpack_require__(6436), hash.common = __webpack_require__(5772), hash.sha = __webpack_require__(9041), hash.ripemd = __webpack_require__(2949), hash.hmac = __webpack_require__(2344), hash.sha1 = hash.sha.sha1, hash.sha256 = hash.sha.sha256, hash.sha224 = hash.sha.sha224, hash.sha384 = hash.sha.sha384, hash.sha512 = hash.sha.sha512, hash.ripemd160 = hash.ripemd.ripemd160;
        },
        5772: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), assert = __webpack_require__(9746);
            function BlockHash() {
                this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = 'big', this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
            }
            exports.BlockHash = BlockHash, BlockHash.prototype.update = function(msg, enc) {
                if (msg = utils.toArray(msg, enc), this.pending ? this.pending = this.pending.concat(msg) : this.pending = msg, this.pendingTotal += msg.length, this.pending.length >= this._delta8) {
                    var r = (msg = this.pending).length % this._delta8;
                    this.pending = msg.slice(msg.length - r, msg.length), 0 === this.pending.length && (this.pending = null), msg = utils.join32(msg, 0, msg.length - r, this.endian);
                    for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
                }
                return this;
            }, BlockHash.prototype.digest = function(enc) {
                return this.update(this._pad()), assert(null === this.pending), this._digest(enc);
            }, BlockHash.prototype._pad = function() {
                var len = this.pendingTotal, bytes = this._delta8, k = bytes - (len + this.padLength) % bytes, res = Array(k + this.padLength);
                res[0] = 0x80;
                for(var i = 1; i < k; i++)res[i] = 0;
                if (len <<= 3, 'big' === this.endian) {
                    for(var t = 8; t < this.padLength; t++)res[i++] = 0;
                    res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = len >>> 24 & 0xff, res[i++] = len >>> 16 & 0xff, res[i++] = len >>> 8 & 0xff, res[i++] = 0xff & len;
                } else for(t = 8, res[i++] = 0xff & len, res[i++] = len >>> 8 & 0xff, res[i++] = len >>> 16 & 0xff, res[i++] = len >>> 24 & 0xff, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0; t < this.padLength; t++)res[i++] = 0;
                return res;
            };
        },
        2344: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), assert = __webpack_require__(9746);
            function Hmac(hash, key, enc) {
                if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
                this.Hash = hash, this.blockSize = hash.blockSize / 8, this.outSize = hash.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(key, enc));
            }
            module.exports = Hmac, Hmac.prototype._init = function(key) {
                key.length > this.blockSize && (key = new this.Hash().update(key).digest()), assert(key.length <= this.blockSize);
                for(var i = key.length; i < this.blockSize; i++)key.push(0);
                for(i = 0; i < key.length; i++)key[i] ^= 0x36;
                for(i = 0, this.inner = new this.Hash().update(key); i < key.length; i++)key[i] ^= 0x6a;
                this.outer = new this.Hash().update(key);
            }, Hmac.prototype.update = function(msg, enc) {
                return this.inner.update(msg, enc), this;
            }, Hmac.prototype.digest = function(enc) {
                return this.outer.update(this.inner.digest()), this.outer.digest(enc);
            };
        },
        2949: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), common = __webpack_require__(5772), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_3 = utils.sum32_3, sum32_4 = utils.sum32_4, BlockHash = common.BlockHash;
            function RIPEMD160() {
                if (!(this instanceof RIPEMD160)) return new RIPEMD160();
                BlockHash.call(this), this.h = [
                    0x67452301,
                    0xefcdab89,
                    0x98badcfe,
                    0x10325476,
                    0xc3d2e1f0
                ], this.endian = 'little';
            }
            function f(j, x, y, z) {
                return j <= 15 ? x ^ y ^ z : j <= 31 ? x & y | ~x & z : j <= 47 ? (x | ~y) ^ z : j <= 63 ? x & z | y & ~z : x ^ (y | ~z);
            }
            function K(j) {
                return j <= 15 ? 0x00000000 : j <= 31 ? 0x5a827999 : j <= 47 ? 0x6ed9eba1 : j <= 63 ? 0x8f1bbcdc : 0xa953fd4e;
            }
            function Kh(j) {
                return j <= 15 ? 0x50a28be6 : j <= 31 ? 0x5c4dd124 : j <= 47 ? 0x6d703ef3 : j <= 63 ? 0x7a6d76e9 : 0x00000000;
            }
            utils.inherits(RIPEMD160, BlockHash), exports.ripemd160 = RIPEMD160, RIPEMD160.blockSize = 512, RIPEMD160.outSize = 160, RIPEMD160.hmacStrength = 192, RIPEMD160.padLength = 64, RIPEMD160.prototype._update = function(msg, start) {
                for(var A = this.h[0], B = this.h[1], C = this.h[2], D = this.h[3], E = this.h[4], Ah = A, Bh = B, Ch = C, Dh = D, Eh = E, j = 0; j < 80; j++){
                    var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
                    A = E, E = D, D = rotl32(C, 10), C = B, B = T, T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh), Ah = Eh, Eh = Dh, Dh = rotl32(Ch, 10), Ch = Bh, Bh = T;
                }
                T = sum32_3(this.h[1], C, Dh), this.h[1] = sum32_3(this.h[2], D, Eh), this.h[2] = sum32_3(this.h[3], E, Ah), this.h[3] = sum32_3(this.h[4], A, Bh), this.h[4] = sum32_3(this.h[0], B, Ch), this.h[0] = T;
            }, RIPEMD160.prototype._digest = function(enc) {
                return 'hex' === enc ? utils.toHex32(this.h, 'little') : utils.split32(this.h, 'little');
            };
            var r = [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                7,
                4,
                13,
                1,
                10,
                6,
                15,
                3,
                12,
                0,
                9,
                5,
                2,
                14,
                11,
                8,
                3,
                10,
                14,
                4,
                9,
                15,
                8,
                1,
                2,
                7,
                0,
                6,
                13,
                11,
                5,
                12,
                1,
                9,
                11,
                10,
                0,
                8,
                12,
                4,
                13,
                3,
                7,
                15,
                14,
                5,
                6,
                2,
                4,
                0,
                5,
                9,
                7,
                12,
                2,
                10,
                14,
                1,
                3,
                8,
                11,
                6,
                15,
                13
            ], rh = [
                5,
                14,
                7,
                0,
                9,
                2,
                11,
                4,
                13,
                6,
                15,
                8,
                1,
                10,
                3,
                12,
                6,
                11,
                3,
                7,
                0,
                13,
                5,
                10,
                14,
                15,
                8,
                12,
                4,
                9,
                1,
                2,
                15,
                5,
                1,
                3,
                7,
                14,
                6,
                9,
                11,
                8,
                12,
                2,
                10,
                0,
                4,
                13,
                8,
                6,
                4,
                1,
                3,
                11,
                15,
                0,
                5,
                12,
                2,
                13,
                9,
                7,
                10,
                14,
                12,
                15,
                10,
                4,
                1,
                5,
                8,
                7,
                6,
                2,
                13,
                14,
                0,
                3,
                9,
                11
            ], s = [
                11,
                14,
                15,
                12,
                5,
                8,
                7,
                9,
                11,
                13,
                14,
                15,
                6,
                7,
                9,
                8,
                7,
                6,
                8,
                13,
                11,
                9,
                7,
                15,
                7,
                12,
                15,
                9,
                11,
                7,
                13,
                12,
                11,
                13,
                6,
                7,
                14,
                9,
                13,
                15,
                14,
                8,
                13,
                6,
                5,
                12,
                7,
                5,
                11,
                12,
                14,
                15,
                14,
                15,
                9,
                8,
                9,
                14,
                5,
                6,
                8,
                6,
                5,
                12,
                9,
                15,
                5,
                11,
                6,
                8,
                13,
                12,
                5,
                12,
                13,
                14,
                11,
                8,
                5,
                6
            ], sh = [
                8,
                9,
                9,
                11,
                13,
                15,
                15,
                5,
                7,
                7,
                8,
                11,
                14,
                14,
                12,
                6,
                9,
                13,
                15,
                7,
                12,
                8,
                9,
                11,
                7,
                7,
                12,
                7,
                6,
                15,
                13,
                11,
                9,
                7,
                15,
                11,
                8,
                6,
                6,
                14,
                12,
                13,
                5,
                14,
                13,
                13,
                7,
                5,
                15,
                5,
                8,
                11,
                14,
                14,
                6,
                14,
                6,
                9,
                12,
                9,
                12,
                5,
                15,
                8,
                8,
                5,
                12,
                9,
                12,
                5,
                14,
                6,
                8,
                13,
                6,
                5,
                15,
                13,
                11,
                11
            ];
        },
        9041: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            exports.sha1 = __webpack_require__(4761), exports.sha224 = __webpack_require__(799), exports.sha256 = __webpack_require__(9344), exports.sha384 = __webpack_require__(772), exports.sha512 = __webpack_require__(5900);
        },
        4761: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), common = __webpack_require__(5772), shaCommon = __webpack_require__(7038), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_5 = utils.sum32_5, ft_1 = shaCommon.ft_1, BlockHash = common.BlockHash, sha1_K = [
                0x5A827999,
                0x6ED9EBA1,
                0x8F1BBCDC,
                0xCA62C1D6
            ];
            function SHA1() {
                if (!(this instanceof SHA1)) return new SHA1();
                BlockHash.call(this), this.h = [
                    0x67452301,
                    0xefcdab89,
                    0x98badcfe,
                    0x10325476,
                    0xc3d2e1f0
                ], this.W = Array(80);
            }
            utils.inherits(SHA1, BlockHash), module.exports = SHA1, SHA1.blockSize = 512, SHA1.outSize = 160, SHA1.hmacStrength = 80, SHA1.padLength = 64, SHA1.prototype._update = function(msg, start) {
                for(var W = this.W, i = 0; i < 16; i++)W[i] = msg[start + i];
                for(; i < W.length; i++)W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4];
                for(i = 0; i < W.length; i++){
                    var s = ~~(i / 20), t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
                    e = d, d = c, c = rotl32(b, 30), b = a, a = t;
                }
                this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e);
            }, SHA1.prototype._digest = function(enc) {
                return 'hex' === enc ? utils.toHex32(this.h, 'big') : utils.split32(this.h, 'big');
            };
        },
        799: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), SHA256 = __webpack_require__(9344);
            function SHA224() {
                if (!(this instanceof SHA224)) return new SHA224();
                SHA256.call(this), this.h = [
                    0xc1059ed8,
                    0x367cd507,
                    0x3070dd17,
                    0xf70e5939,
                    0xffc00b31,
                    0x68581511,
                    0x64f98fa7,
                    0xbefa4fa4
                ];
            }
            utils.inherits(SHA224, SHA256), module.exports = SHA224, SHA224.blockSize = 512, SHA224.outSize = 224, SHA224.hmacStrength = 192, SHA224.padLength = 64, SHA224.prototype._digest = function(enc) {
                return 'hex' === enc ? utils.toHex32(this.h.slice(0, 7), 'big') : utils.split32(this.h.slice(0, 7), 'big');
            };
        },
        9344: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), common = __webpack_require__(5772), shaCommon = __webpack_require__(7038), assert = __webpack_require__(9746), sum32 = utils.sum32, sum32_4 = utils.sum32_4, sum32_5 = utils.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash = common.BlockHash, sha256_K = [
                0x428a2f98,
                0x71374491,
                0xb5c0fbcf,
                0xe9b5dba5,
                0x3956c25b,
                0x59f111f1,
                0x923f82a4,
                0xab1c5ed5,
                0xd807aa98,
                0x12835b01,
                0x243185be,
                0x550c7dc3,
                0x72be5d74,
                0x80deb1fe,
                0x9bdc06a7,
                0xc19bf174,
                0xe49b69c1,
                0xefbe4786,
                0x0fc19dc6,
                0x240ca1cc,
                0x2de92c6f,
                0x4a7484aa,
                0x5cb0a9dc,
                0x76f988da,
                0x983e5152,
                0xa831c66d,
                0xb00327c8,
                0xbf597fc7,
                0xc6e00bf3,
                0xd5a79147,
                0x06ca6351,
                0x14292967,
                0x27b70a85,
                0x2e1b2138,
                0x4d2c6dfc,
                0x53380d13,
                0x650a7354,
                0x766a0abb,
                0x81c2c92e,
                0x92722c85,
                0xa2bfe8a1,
                0xa81a664b,
                0xc24b8b70,
                0xc76c51a3,
                0xd192e819,
                0xd6990624,
                0xf40e3585,
                0x106aa070,
                0x19a4c116,
                0x1e376c08,
                0x2748774c,
                0x34b0bcb5,
                0x391c0cb3,
                0x4ed8aa4a,
                0x5b9cca4f,
                0x682e6ff3,
                0x748f82ee,
                0x78a5636f,
                0x84c87814,
                0x8cc70208,
                0x90befffa,
                0xa4506ceb,
                0xbef9a3f7,
                0xc67178f2
            ];
            function SHA256() {
                if (!(this instanceof SHA256)) return new SHA256();
                BlockHash.call(this), this.h = [
                    0x6a09e667,
                    0xbb67ae85,
                    0x3c6ef372,
                    0xa54ff53a,
                    0x510e527f,
                    0x9b05688c,
                    0x1f83d9ab,
                    0x5be0cd19
                ], this.k = sha256_K, this.W = Array(64);
            }
            utils.inherits(SHA256, BlockHash), module.exports = SHA256, SHA256.blockSize = 512, SHA256.outSize = 256, SHA256.hmacStrength = 192, SHA256.padLength = 64, SHA256.prototype._update = function(msg, start) {
                for(var W = this.W, i = 0; i < 16; i++)W[i] = msg[start + i];
                for(; i < W.length; i++)W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
                var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4], f = this.h[5], g = this.h[6], h = this.h[7];
                for(assert(this.k.length === W.length), i = 0; i < W.length; i++){
                    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]), T2 = sum32(s0_256(a), maj32(a, b, c));
                    h = g, g = f, f = e, e = sum32(d, T1), d = c, c = b, b = a, a = sum32(T1, T2);
                }
                this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e), this.h[5] = sum32(this.h[5], f), this.h[6] = sum32(this.h[6], g), this.h[7] = sum32(this.h[7], h);
            }, SHA256.prototype._digest = function(enc) {
                return 'hex' === enc ? utils.toHex32(this.h, 'big') : utils.split32(this.h, 'big');
            };
        },
        772: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), SHA512 = __webpack_require__(5900);
            function SHA384() {
                if (!(this instanceof SHA384)) return new SHA384();
                SHA512.call(this), this.h = [
                    0xcbbb9d5d,
                    0xc1059ed8,
                    0x629a292a,
                    0x367cd507,
                    0x9159015a,
                    0x3070dd17,
                    0x152fecd8,
                    0xf70e5939,
                    0x67332667,
                    0xffc00b31,
                    0x8eb44a87,
                    0x68581511,
                    0xdb0c2e0d,
                    0x64f98fa7,
                    0x47b5481d,
                    0xbefa4fa4
                ];
            }
            utils.inherits(SHA384, SHA512), module.exports = SHA384, SHA384.blockSize = 1024, SHA384.outSize = 384, SHA384.hmacStrength = 192, SHA384.padLength = 128, SHA384.prototype._digest = function(enc) {
                return 'hex' === enc ? utils.toHex32(this.h.slice(0, 12), 'big') : utils.split32(this.h.slice(0, 12), 'big');
            };
        },
        5900: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(6436), common = __webpack_require__(5772), assert = __webpack_require__(9746), rotr64_hi = utils.rotr64_hi, rotr64_lo = utils.rotr64_lo, shr64_hi = utils.shr64_hi, shr64_lo = utils.shr64_lo, sum64 = utils.sum64, sum64_hi = utils.sum64_hi, sum64_lo = utils.sum64_lo, sum64_4_hi = utils.sum64_4_hi, sum64_4_lo = utils.sum64_4_lo, sum64_5_hi = utils.sum64_5_hi, sum64_5_lo = utils.sum64_5_lo, BlockHash = common.BlockHash, sha512_K = [
                0x428a2f98,
                0xd728ae22,
                0x71374491,
                0x23ef65cd,
                0xb5c0fbcf,
                0xec4d3b2f,
                0xe9b5dba5,
                0x8189dbbc,
                0x3956c25b,
                0xf348b538,
                0x59f111f1,
                0xb605d019,
                0x923f82a4,
                0xaf194f9b,
                0xab1c5ed5,
                0xda6d8118,
                0xd807aa98,
                0xa3030242,
                0x12835b01,
                0x45706fbe,
                0x243185be,
                0x4ee4b28c,
                0x550c7dc3,
                0xd5ffb4e2,
                0x72be5d74,
                0xf27b896f,
                0x80deb1fe,
                0x3b1696b1,
                0x9bdc06a7,
                0x25c71235,
                0xc19bf174,
                0xcf692694,
                0xe49b69c1,
                0x9ef14ad2,
                0xefbe4786,
                0x384f25e3,
                0x0fc19dc6,
                0x8b8cd5b5,
                0x240ca1cc,
                0x77ac9c65,
                0x2de92c6f,
                0x592b0275,
                0x4a7484aa,
                0x6ea6e483,
                0x5cb0a9dc,
                0xbd41fbd4,
                0x76f988da,
                0x831153b5,
                0x983e5152,
                0xee66dfab,
                0xa831c66d,
                0x2db43210,
                0xb00327c8,
                0x98fb213f,
                0xbf597fc7,
                0xbeef0ee4,
                0xc6e00bf3,
                0x3da88fc2,
                0xd5a79147,
                0x930aa725,
                0x06ca6351,
                0xe003826f,
                0x14292967,
                0x0a0e6e70,
                0x27b70a85,
                0x46d22ffc,
                0x2e1b2138,
                0x5c26c926,
                0x4d2c6dfc,
                0x5ac42aed,
                0x53380d13,
                0x9d95b3df,
                0x650a7354,
                0x8baf63de,
                0x766a0abb,
                0x3c77b2a8,
                0x81c2c92e,
                0x47edaee6,
                0x92722c85,
                0x1482353b,
                0xa2bfe8a1,
                0x4cf10364,
                0xa81a664b,
                0xbc423001,
                0xc24b8b70,
                0xd0f89791,
                0xc76c51a3,
                0x0654be30,
                0xd192e819,
                0xd6ef5218,
                0xd6990624,
                0x5565a910,
                0xf40e3585,
                0x5771202a,
                0x106aa070,
                0x32bbd1b8,
                0x19a4c116,
                0xb8d2d0c8,
                0x1e376c08,
                0x5141ab53,
                0x2748774c,
                0xdf8eeb99,
                0x34b0bcb5,
                0xe19b48a8,
                0x391c0cb3,
                0xc5c95a63,
                0x4ed8aa4a,
                0xe3418acb,
                0x5b9cca4f,
                0x7763e373,
                0x682e6ff3,
                0xd6b2b8a3,
                0x748f82ee,
                0x5defb2fc,
                0x78a5636f,
                0x43172f60,
                0x84c87814,
                0xa1f0ab72,
                0x8cc70208,
                0x1a6439ec,
                0x90befffa,
                0x23631e28,
                0xa4506ceb,
                0xde82bde9,
                0xbef9a3f7,
                0xb2c67915,
                0xc67178f2,
                0xe372532b,
                0xca273ece,
                0xea26619c,
                0xd186b8c7,
                0x21c0c207,
                0xeada7dd6,
                0xcde0eb1e,
                0xf57d4f7f,
                0xee6ed178,
                0x06f067aa,
                0x72176fba,
                0x0a637dc5,
                0xa2c898a6,
                0x113f9804,
                0xbef90dae,
                0x1b710b35,
                0x131c471b,
                0x28db77f5,
                0x23047d84,
                0x32caab7b,
                0x40c72493,
                0x3c9ebe0a,
                0x15c9bebc,
                0x431d67c4,
                0x9c100d4c,
                0x4cc5d4be,
                0xcb3e42b6,
                0x597f299c,
                0xfc657e2a,
                0x5fcb6fab,
                0x3ad6faec,
                0x6c44198c,
                0x4a475817
            ];
            function SHA512() {
                if (!(this instanceof SHA512)) return new SHA512();
                BlockHash.call(this), this.h = [
                    0x6a09e667,
                    0xf3bcc908,
                    0xbb67ae85,
                    0x84caa73b,
                    0x3c6ef372,
                    0xfe94f82b,
                    0xa54ff53a,
                    0x5f1d36f1,
                    0x510e527f,
                    0xade682d1,
                    0x9b05688c,
                    0x2b3e6c1f,
                    0x1f83d9ab,
                    0xfb41bd6b,
                    0x5be0cd19,
                    0x137e2179
                ], this.k = sha512_K, this.W = Array(160);
            }
            function ch64_hi(xh, xl, yh, yl, zh) {
                var r = xh & yh ^ ~xh & zh;
                return r < 0 && (r += 0x100000000), r;
            }
            function ch64_lo(xh, xl, yh, yl, zh, zl) {
                var r = xl & yl ^ ~xl & zl;
                return r < 0 && (r += 0x100000000), r;
            }
            function maj64_hi(xh, xl, yh, yl, zh) {
                var r = xh & yh ^ xh & zh ^ yh & zh;
                return r < 0 && (r += 0x100000000), r;
            }
            function maj64_lo(xh, xl, yh, yl, zh, zl) {
                var r = xl & yl ^ xl & zl ^ yl & zl;
                return r < 0 && (r += 0x100000000), r;
            }
            function s0_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 28), c1_hi = rotr64_hi(xl, xh, 2), c2_hi = rotr64_hi(xl, xh, 7), r = c0_hi ^ c1_hi ^ c2_hi;
                return r < 0 && (r += 0x100000000), r;
            }
            function s0_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 28), c1_lo = rotr64_lo(xl, xh, 2), c2_lo = rotr64_lo(xl, xh, 7), r = c0_lo ^ c1_lo ^ c2_lo;
                return r < 0 && (r += 0x100000000), r;
            }
            function s1_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 14), c1_hi = rotr64_hi(xh, xl, 18), c2_hi = rotr64_hi(xl, xh, 9), r = c0_hi ^ c1_hi ^ c2_hi;
                return r < 0 && (r += 0x100000000), r;
            }
            function s1_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 14), c1_lo = rotr64_lo(xh, xl, 18), c2_lo = rotr64_lo(xl, xh, 9), r = c0_lo ^ c1_lo ^ c2_lo;
                return r < 0 && (r += 0x100000000), r;
            }
            function g0_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 1), c1_hi = rotr64_hi(xh, xl, 8), c2_hi = shr64_hi(xh, xl, 7), r = c0_hi ^ c1_hi ^ c2_hi;
                return r < 0 && (r += 0x100000000), r;
            }
            function g0_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 1), c1_lo = rotr64_lo(xh, xl, 8), c2_lo = shr64_lo(xh, xl, 7), r = c0_lo ^ c1_lo ^ c2_lo;
                return r < 0 && (r += 0x100000000), r;
            }
            function g1_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 19), c1_hi = rotr64_hi(xl, xh, 29), c2_hi = shr64_hi(xh, xl, 6), r = c0_hi ^ c1_hi ^ c2_hi;
                return r < 0 && (r += 0x100000000), r;
            }
            function g1_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 19), c1_lo = rotr64_lo(xl, xh, 29), c2_lo = shr64_lo(xh, xl, 6), r = c0_lo ^ c1_lo ^ c2_lo;
                return r < 0 && (r += 0x100000000), r;
            }
            utils.inherits(SHA512, BlockHash), module.exports = SHA512, SHA512.blockSize = 1024, SHA512.outSize = 512, SHA512.hmacStrength = 192, SHA512.padLength = 128, SHA512.prototype._prepareBlock = function(msg, start) {
                for(var W = this.W, i = 0; i < 32; i++)W[i] = msg[start + i];
                for(; i < W.length; i += 2){
                    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]), c0_lo = g1_512_lo(W[i - 4], W[i - 3]), c1_hi = W[i - 14], c1_lo = W[i - 13], c2_hi = g0_512_hi(W[i - 30], W[i - 29]), c2_lo = g0_512_lo(W[i - 30], W[i - 29]), c3_hi = W[i - 32], c3_lo = W[i - 31];
                    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo), W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
                }
            }, SHA512.prototype._update = function(msg, start) {
                this._prepareBlock(msg, start);
                var W = this.W, ah = this.h[0], al = this.h[1], bh = this.h[2], bl = this.h[3], ch = this.h[4], cl = this.h[5], dh = this.h[6], dl = this.h[7], eh = this.h[8], el = this.h[9], fh = this.h[10], fl = this.h[11], gh = this.h[12], gl = this.h[13], hh = this.h[14], hl = this.h[15];
                assert(this.k.length === W.length);
                for(var i = 0; i < W.length; i += 2){
                    var c0_hi = hh, c0_lo = hl, c1_hi = s1_512_hi(eh, el), c1_lo = s1_512_lo(eh, el), c2_hi = ch64_hi(eh, el, fh, fl, gh, gl), c2_lo = ch64_lo(eh, el, fh, fl, gh, gl), c3_hi = this.k[i], c3_lo = this.k[i + 1], c4_hi = W[i], c4_lo = W[i + 1], T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo), T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
                    c0_hi = s0_512_hi(ah, al), c0_lo = s0_512_lo(ah, al), c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
                    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo = maj64_lo(ah, al, bh, bl, ch, cl)), T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
                    hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, eh = sum64_hi(dh, dl, T1_hi, T1_lo), el = sum64_lo(dl, dl, T1_hi, T1_lo), dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo), al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
                }
                sum64(this.h, 0, ah, al), sum64(this.h, 2, bh, bl), sum64(this.h, 4, ch, cl), sum64(this.h, 6, dh, dl), sum64(this.h, 8, eh, el), sum64(this.h, 10, fh, fl), sum64(this.h, 12, gh, gl), sum64(this.h, 14, hh, hl);
            }, SHA512.prototype._digest = function(enc) {
                return 'hex' === enc ? utils.toHex32(this.h, 'big') : utils.split32(this.h, 'big');
            };
        },
        7038: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var rotr32 = __webpack_require__(6436).rotr32;
            function ft_1(s, x, y, z) {
                return 0 === s ? ch32(x, y, z) : 1 === s || 3 === s ? p32(x, y, z) : 2 === s ? maj32(x, y, z) : void 0;
            }
            function ch32(x, y, z) {
                return x & y ^ ~x & z;
            }
            function maj32(x, y, z) {
                return x & y ^ x & z ^ y & z;
            }
            function p32(x, y, z) {
                return x ^ y ^ z;
            }
            function s0_256(x) {
                return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
            }
            function s1_256(x) {
                return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
            }
            function g0_256(x) {
                return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
            }
            function g1_256(x) {
                return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
            }
            exports.ft_1 = ft_1, exports.ch32 = ch32, exports.maj32 = maj32, exports.p32 = p32, exports.s0_256 = s0_256, exports.s1_256 = s1_256, exports.g0_256 = g0_256, exports.g1_256 = g1_256;
        },
        6436: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var assert = __webpack_require__(9746), inherits = __webpack_require__(5717);
            function isSurrogatePair(msg, i) {
                return (0xFC00 & msg.charCodeAt(i)) == 0xD800 && !(i < 0) && !(i + 1 >= msg.length) && (0xFC00 & msg.charCodeAt(i + 1)) == 0xDC00;
            }
            function toArray(msg, enc) {
                if (Array.isArray(msg)) return msg.slice();
                if (!msg) return [];
                var res = [];
                if ('string' == typeof msg) {
                    if (enc) {
                        if ('hex' === enc) for((msg = msg.replace(/[^a-z0-9]+/ig, '')).length % 2 != 0 && (msg = '0' + msg), i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
                    } else for(var p = 0, i = 0; i < msg.length; i++){
                        var c = msg.charCodeAt(i);
                        c < 128 ? res[p++] = c : c < 2048 ? (res[p++] = c >> 6 | 192, res[p++] = 63 & c | 128) : isSurrogatePair(msg, i) ? (c = 0x10000 + ((0x03FF & c) << 10) + (0x03FF & msg.charCodeAt(++i)), res[p++] = c >> 18 | 240, res[p++] = c >> 12 & 63 | 128, res[p++] = c >> 6 & 63 | 128, res[p++] = 63 & c | 128) : (res[p++] = c >> 12 | 224, res[p++] = c >> 6 & 63 | 128, res[p++] = 63 & c | 128);
                    }
                } else for(i = 0; i < msg.length; i++)res[i] = 0 | msg[i];
                return res;
            }
            function toHex(msg) {
                for(var res = '', i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
                return res;
            }
            function htonl(w) {
                return (w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (0xff & w) << 24) >>> 0;
            }
            function toHex32(msg, endian) {
                for(var res = '', i = 0; i < msg.length; i++){
                    var w = msg[i];
                    'little' === endian && (w = htonl(w)), res += zero8(w.toString(16));
                }
                return res;
            }
            function zero2(word) {
                return 1 === word.length ? '0' + word : word;
            }
            function zero8(word) {
                return 7 === word.length ? '0' + word : 6 === word.length ? '00' + word : 5 === word.length ? '000' + word : 4 === word.length ? '0000' + word : 3 === word.length ? '00000' + word : 2 === word.length ? '000000' + word : 1 === word.length ? '0000000' + word : word;
            }
            function join32(msg, start, end, endian) {
                var w, len = end - start;
                assert(len % 4 == 0);
                for(var res = Array(len / 4), i = 0, k = start; i < res.length; i++, k += 4)w = 'big' === endian ? msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3] : msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k], res[i] = w >>> 0;
                return res;
            }
            function split32(msg, endian) {
                for(var res = Array(4 * msg.length), i = 0, k = 0; i < msg.length; i++, k += 4){
                    var m = msg[i];
                    'big' === endian ? (res[k] = m >>> 24, res[k + 1] = m >>> 16 & 0xff, res[k + 2] = m >>> 8 & 0xff, res[k + 3] = 0xff & m) : (res[k + 3] = m >>> 24, res[k + 2] = m >>> 16 & 0xff, res[k + 1] = m >>> 8 & 0xff, res[k] = 0xff & m);
                }
                return res;
            }
            function rotr32(w, b) {
                return w >>> b | w << 32 - b;
            }
            function rotl32(w, b) {
                return w << b | w >>> 32 - b;
            }
            function sum32(a, b) {
                return a + b >>> 0;
            }
            function sum32_3(a, b, c) {
                return a + b + c >>> 0;
            }
            function sum32_4(a, b, c, d) {
                return a + b + c + d >>> 0;
            }
            function sum32_5(a, b, c, d, e) {
                return a + b + c + d + e >>> 0;
            }
            function sum64(buf, pos, ah, al) {
                var bh = buf[pos], lo = al + buf[pos + 1] >>> 0, hi = (lo < al ? 1 : 0) + ah + bh;
                buf[pos] = hi >>> 0, buf[pos + 1] = lo;
            }
            function sum64_hi(ah, al, bh, bl) {
                return (al + bl >>> 0 < al ? 1 : 0) + ah + bh >>> 0;
            }
            function sum64_lo(ah, al, bh, bl) {
                return al + bl >>> 0;
            }
            function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
                var carry = 0, lo = al;
                return carry += (lo = lo + bl >>> 0) < al ? 1 : 0, carry += (lo = lo + cl >>> 0) < cl ? 1 : 0, ah + bh + ch + dh + (carry += (lo = lo + dl >>> 0) < dl ? 1 : 0) >>> 0;
            }
            function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
                return al + bl + cl + dl >>> 0;
            }
            function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                var carry = 0, lo = al;
                return carry += (lo = lo + bl >>> 0) < al ? 1 : 0, carry += (lo = lo + cl >>> 0) < cl ? 1 : 0, carry += (lo = lo + dl >>> 0) < dl ? 1 : 0, ah + bh + ch + dh + eh + (carry += (lo = lo + el >>> 0) < el ? 1 : 0) >>> 0;
            }
            function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                return al + bl + cl + dl + el >>> 0;
            }
            function rotr64_hi(ah, al, num) {
                return (al << 32 - num | ah >>> num) >>> 0;
            }
            function rotr64_lo(ah, al, num) {
                return (ah << 32 - num | al >>> num) >>> 0;
            }
            function shr64_hi(ah, al, num) {
                return ah >>> num;
            }
            function shr64_lo(ah, al, num) {
                return (ah << 32 - num | al >>> num) >>> 0;
            }
            exports.inherits = inherits, exports.toArray = toArray, exports.toHex = toHex, exports.htonl = htonl, exports.toHex32 = toHex32, exports.zero2 = zero2, exports.zero8 = zero8, exports.join32 = join32, exports.split32 = split32, exports.rotr32 = rotr32, exports.rotl32 = rotl32, exports.sum32 = sum32, exports.sum32_3 = sum32_3, exports.sum32_4 = sum32_4, exports.sum32_5 = sum32_5, exports.sum64 = sum64, exports.sum64_hi = sum64_hi, exports.sum64_lo = sum64_lo, exports.sum64_4_hi = sum64_4_hi, exports.sum64_4_lo = sum64_4_lo, exports.sum64_5_hi = sum64_5_hi, exports.sum64_5_lo = sum64_5_lo, exports.rotr64_hi = rotr64_hi, exports.rotr64_lo = rotr64_lo, exports.shr64_hi = shr64_hi, exports.shr64_lo = shr64_lo;
        },
        2156: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var hash = __webpack_require__(3715), utils = __webpack_require__(4504), assert = __webpack_require__(9746);
            function HmacDRBG(options) {
                if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
                this.hash = options.hash, this.predResist = !!options.predResist, this.outLen = this.hash.outSize, this.minEntropy = options.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
                var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex'), nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex'), pers = utils.toArray(options.pers, options.persEnc || 'hex');
                assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._init(entropy, nonce, pers);
            }
            module.exports = HmacDRBG, HmacDRBG.prototype._init = function(entropy, nonce, pers) {
                var seed = entropy.concat(nonce).concat(pers);
                this.K = Array(this.outLen / 8), this.V = Array(this.outLen / 8);
                for(var i = 0; i < this.V.length; i++)this.K[i] = 0x00, this.V[i] = 0x01;
                this._update(seed), this._reseed = 1, this.reseedInterval = 0x1000000000000;
            }, HmacDRBG.prototype._hmac = function() {
                return new hash.hmac(this.hash, this.K);
            }, HmacDRBG.prototype._update = function(seed) {
                var kmac = this._hmac().update(this.V).update([
                    0x00
                ]);
                seed && (kmac = kmac.update(seed)), this.K = kmac.digest(), this.V = this._hmac().update(this.V).digest(), seed && (this.K = this._hmac().update(this.V).update([
                    0x01
                ]).update(seed).digest(), this.V = this._hmac().update(this.V).digest());
            }, HmacDRBG.prototype.reseed = function(entropy, entropyEnc, add, addEnc) {
                'string' != typeof entropyEnc && (addEnc = add, add = entropyEnc, entropyEnc = null), entropy = utils.toArray(entropy, entropyEnc), add = utils.toArray(add, addEnc), assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._update(entropy.concat(add || [])), this._reseed = 1;
            }, HmacDRBG.prototype.generate = function(len, enc, add, addEnc) {
                if (this._reseed > this.reseedInterval) throw Error('Reseed is required');
                'string' != typeof enc && (addEnc = add, add = enc, enc = null), add && (add = utils.toArray(add, addEnc || 'hex'), this._update(add));
                for(var temp = []; temp.length < len;)this.V = this._hmac().update(this.V).digest(), temp = temp.concat(this.V);
                var res = temp.slice(0, len);
                return this._update(add), this._reseed++, utils.encode(res, enc);
            };
        },
        645: function(__unused_webpack_module, exports) {
            exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                var e, m, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
                for(i += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = 256 * e + buffer[offset + i], i += d, nBits -= 8);
                for(m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = 256 * m + buffer[offset + i], i += d, nBits -= 8);
                if (0 === e) e = 1 - eBias;
                else {
                    if (e === eMax) return m ? NaN : (s ? -1 : 1) * (1 / 0);
                    m += Math.pow(2, mLen), e -= eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            }, exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = 23 === mLen ? 0.00000005960464477539062 : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
                for(isNaN(value = Math.abs(value)) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1 && (e--, c *= 2), e + eBias >= 1 ? value += rt / c : value += rt * Math.pow(2, 1 - eBias), value * c >= 2 && (e++, c /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * Math.pow(2, mLen), e += eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); mLen >= 8; buffer[offset + i] = 0xff & m, i += d, m /= 256, mLen -= 8);
                for(e = e << mLen | m, eLen += mLen; eLen > 0; buffer[offset + i] = 0xff & e, i += d, e /= 256, eLen -= 8);
                buffer[offset + i - d] |= 128 * s;
            };
        },
        5717: function(module) {
            'function' == typeof Object.create ? module.exports = function(ctor, superCtor) {
                superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }));
            } : module.exports = function(ctor, superCtor) {
                if (superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
                }
            };
        },
        2584: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var hasToStringTag = __webpack_require__(6410)(), $toString = __webpack_require__(1924)('Object.prototype.toString'), isStandardArguments = function(value) {
                return (!hasToStringTag || !value || 'object' != typeof value || !(Symbol.toStringTag in value)) && '[object Arguments]' === $toString(value);
            }, isLegacyArguments = function(value) {
                return !!isStandardArguments(value) || null !== value && 'object' == typeof value && 'number' == typeof value.length && value.length >= 0 && '[object Array]' !== $toString(value) && '[object Function]' === $toString(value.callee);
            }, supportsStandardArguments = function() {
                return isStandardArguments(arguments);
            }();
            isStandardArguments.isLegacyArguments = isLegacyArguments, module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
        },
        5320: function(module) {
            "use strict";
            var badArrayLike, isCallableMarker, fnToStr = Function.prototype.toString, reflectApply = 'object' == typeof Reflect && null !== Reflect && Reflect.apply;
            if ('function' == typeof reflectApply && 'function' == typeof Object.defineProperty) try {
                badArrayLike = Object.defineProperty({}, 'length', {
                    get: function() {
                        throw isCallableMarker;
                    }
                }), isCallableMarker = {}, reflectApply(function() {
                    throw 42;
                }, null, badArrayLike);
            } catch (_) {
                _ !== isCallableMarker && (reflectApply = null);
            }
            else reflectApply = null;
            var constructorRegex = /^\s*class\b/, isES6ClassFn = function(value) {
                try {
                    var fnStr = fnToStr.call(value);
                    return constructorRegex.test(fnStr);
                } catch (e) {
                    return !1;
                }
            }, tryFunctionObject = function(value) {
                try {
                    if (isES6ClassFn(value)) return !1;
                    return fnToStr.call(value), !0;
                } catch (e) {
                    return !1;
                }
            }, toStr = Object.prototype.toString, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', hasToStringTag = 'function' == typeof Symbol && !!Symbol.toStringTag, documentDotAll = 'object' == typeof document && void 0 === document.all && void 0 !== document.all ? document.all : {};
            module.exports = reflectApply ? function(value) {
                if (value === documentDotAll) return !0;
                if (!value || 'function' != typeof value && 'object' != typeof value) return !1;
                if ('function' == typeof value && !value.prototype) return !0;
                try {
                    reflectApply(value, null, badArrayLike);
                } catch (e) {
                    if (e !== isCallableMarker) return !1;
                }
                return !isES6ClassFn(value);
            } : function(value) {
                if (value === documentDotAll) return !0;
                if (!value || 'function' != typeof value && 'object' != typeof value) return !1;
                if ('function' == typeof value && !value.prototype) return !0;
                if (hasToStringTag) return tryFunctionObject(value);
                if (isES6ClassFn(value)) return !1;
                var strClass = toStr.call(value);
                return strClass === fnClass || strClass === genClass;
            };
        },
        8662: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var GeneratorFunction, toStr = Object.prototype.toString, fnToStr = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag = __webpack_require__(6410)(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
                if (!hasToStringTag) return !1;
                try {
                    return Function('return function*() {}')();
                } catch (e) {}
            };
            module.exports = function(fn) {
                if ('function' != typeof fn) return !1;
                if (isFnRegex.test(fnToStr.call(fn))) return !0;
                if (!hasToStringTag) return '[object GeneratorFunction]' === toStr.call(fn);
                if (!getProto) return !1;
                if (void 0 === GeneratorFunction) {
                    var generatorFunc = getGeneratorFunc();
                    GeneratorFunction = !!generatorFunc && getProto(generatorFunc);
                }
                return getProto(fn) === GeneratorFunction;
            };
        },
        5692: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var forEach = __webpack_require__(4029), availableTypedArrays = __webpack_require__(3083), callBound = __webpack_require__(1924), $toString = callBound('Object.prototype.toString'), hasToStringTag = __webpack_require__(6410)(), g = 'undefined' == typeof globalThis ? __webpack_require__.g : globalThis, typedArrays = availableTypedArrays(), $indexOf = callBound('Array.prototype.indexOf', !0) || function(array, value) {
                for(var i = 0; i < array.length; i += 1)if (array[i] === value) return i;
                return -1;
            }, $slice = callBound('String.prototype.slice'), toStrTags = {}, gOPD = __webpack_require__(882), getPrototypeOf = Object.getPrototypeOf;
            hasToStringTag && gOPD && getPrototypeOf && forEach(typedArrays, function(typedArray) {
                var arr = new g[typedArray]();
                if (Symbol.toStringTag in arr) {
                    var proto = getPrototypeOf(arr), descriptor = gOPD(proto, Symbol.toStringTag);
                    if (!descriptor) {
                        var superProto = getPrototypeOf(proto);
                        descriptor = gOPD(superProto, Symbol.toStringTag);
                    }
                    toStrTags[typedArray] = descriptor.get;
                }
            });
            var tryTypedArrays = function(value) {
                var anyTrue = !1;
                return forEach(toStrTags, function(getter, typedArray) {
                    if (!anyTrue) try {
                        anyTrue = getter.call(value) === typedArray;
                    } catch (e) {}
                }), anyTrue;
            };
            module.exports = function(value) {
                if (!value || 'object' != typeof value) return !1;
                if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                    var tag = $slice($toString(value), 8, -1);
                    return $indexOf(typedArrays, tag) > -1;
                }
                return !!gOPD && tryTypedArrays(value);
            };
        },
        2023: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__, process = __webpack_require__(3454);
            !function() {
                'use strict';
                var ERROR = 'input is invalid type', WINDOW = 'object' == typeof window, root = WINDOW ? window : {};
                root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
                var WEB_WORKER = !WINDOW && 'object' == typeof self, NODE_JS = !root.JS_SHA256_NO_NODE_JS && 'object' == typeof process && process.versions && process.versions.node;
                NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
                var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && module.exports, AMD = __webpack_require__.amdO, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && 'undefined' != typeof ArrayBuffer, HEX_CHARS = '0123456789abcdef'.split(''), EXTRA = [
                    -2147483648,
                    8388608,
                    32768,
                    128
                ], SHIFT = [
                    24,
                    16,
                    8,
                    0
                ], K = [
                    0x428a2f98,
                    0x71374491,
                    0xb5c0fbcf,
                    0xe9b5dba5,
                    0x3956c25b,
                    0x59f111f1,
                    0x923f82a4,
                    0xab1c5ed5,
                    0xd807aa98,
                    0x12835b01,
                    0x243185be,
                    0x550c7dc3,
                    0x72be5d74,
                    0x80deb1fe,
                    0x9bdc06a7,
                    0xc19bf174,
                    0xe49b69c1,
                    0xefbe4786,
                    0x0fc19dc6,
                    0x240ca1cc,
                    0x2de92c6f,
                    0x4a7484aa,
                    0x5cb0a9dc,
                    0x76f988da,
                    0x983e5152,
                    0xa831c66d,
                    0xb00327c8,
                    0xbf597fc7,
                    0xc6e00bf3,
                    0xd5a79147,
                    0x06ca6351,
                    0x14292967,
                    0x27b70a85,
                    0x2e1b2138,
                    0x4d2c6dfc,
                    0x53380d13,
                    0x650a7354,
                    0x766a0abb,
                    0x81c2c92e,
                    0x92722c85,
                    0xa2bfe8a1,
                    0xa81a664b,
                    0xc24b8b70,
                    0xc76c51a3,
                    0xd192e819,
                    0xd6990624,
                    0xf40e3585,
                    0x106aa070,
                    0x19a4c116,
                    0x1e376c08,
                    0x2748774c,
                    0x34b0bcb5,
                    0x391c0cb3,
                    0x4ed8aa4a,
                    0x5b9cca4f,
                    0x682e6ff3,
                    0x748f82ee,
                    0x78a5636f,
                    0x84c87814,
                    0x8cc70208,
                    0x90befffa,
                    0xa4506ceb,
                    0xbef9a3f7,
                    0xc67178f2
                ], OUTPUT_TYPES = [
                    'hex',
                    'array',
                    'digest',
                    'arrayBuffer'
                ], blocks = [];
                (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(obj) {
                    return '[object Array]' === Object.prototype.toString.call(obj);
                }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(obj) {
                    return 'object' == typeof obj && obj.buffer && obj.buffer.constructor === ArrayBuffer;
                });
                var createOutputMethod = function(outputType, is224) {
                    return function(message) {
                        return new Sha256(is224, !0).update(message)[outputType]();
                    };
                }, createMethod = function(is224) {
                    var method = createOutputMethod('hex', is224);
                    NODE_JS && (method = nodeWrap(method, is224)), method.create = function() {
                        return new Sha256(is224);
                    }, method.update = function(message) {
                        return method.create().update(message);
                    };
                    for(var i = 0; i < OUTPUT_TYPES.length; ++i){
                        var type = OUTPUT_TYPES[i];
                        method[type] = createOutputMethod(type, is224);
                    }
                    return method;
                }, nodeWrap = function(method, is224) {
                    var nodeMethod, crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? 'sha224' : 'sha256';
                    return function(message) {
                        if ('string' == typeof message) return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
                        if (null == message) throw Error(ERROR);
                        return message.constructor === ArrayBuffer && (message = new Uint8Array(message)), Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(message)).digest('hex') : method(message);
                    };
                }, createHmacOutputMethod = function(outputType, is224) {
                    return function(key, message) {
                        return new HmacSha256(key, is224, !0).update(message)[outputType]();
                    };
                }, createHmacMethod = function(is224) {
                    var method = createHmacOutputMethod('hex', is224);
                    method.create = function(key) {
                        return new HmacSha256(key, is224);
                    }, method.update = function(key, message) {
                        return method.create(key).update(message);
                    };
                    for(var i = 0; i < OUTPUT_TYPES.length; ++i){
                        var type = OUTPUT_TYPES[i];
                        method[type] = createHmacOutputMethod(type, is224);
                    }
                    return method;
                };
                function Sha256(is224, sharedMemory) {
                    sharedMemory ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], is224 ? (this.h0 = 0xc1059ed8, this.h1 = 0x367cd507, this.h2 = 0x3070dd17, this.h3 = 0xf70e5939, this.h4 = 0xffc00b31, this.h5 = 0x68581511, this.h6 = 0x64f98fa7, this.h7 = 0xbefa4fa4) : (this.h0 = 0x6a09e667, this.h1 = 0xbb67ae85, this.h2 = 0x3c6ef372, this.h3 = 0xa54ff53a, this.h4 = 0x510e527f, this.h5 = 0x9b05688c, this.h6 = 0x1f83d9ab, this.h7 = 0x5be0cd19), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = is224;
                }
                function HmacSha256(key, is224, sharedMemory) {
                    var i, type = typeof key;
                    if ('string' === type) {
                        var code, bytes = [], length = key.length, index = 0;
                        for(i = 0; i < length; ++i)(code = key.charCodeAt(i)) < 0x80 ? bytes[index++] = code : code < 0x800 ? (bytes[index++] = 0xc0 | code >> 6, bytes[index++] = 0x80 | 0x3f & code) : code < 0xd800 || code >= 0xe000 ? (bytes[index++] = 0xe0 | code >> 12, bytes[index++] = 0x80 | code >> 6 & 0x3f, bytes[index++] = 0x80 | 0x3f & code) : (code = 0x10000 + ((0x3ff & code) << 10 | 0x3ff & key.charCodeAt(++i)), bytes[index++] = 0xf0 | code >> 18, bytes[index++] = 0x80 | code >> 12 & 0x3f, bytes[index++] = 0x80 | code >> 6 & 0x3f, bytes[index++] = 0x80 | 0x3f & code);
                        key = bytes;
                    } else if ('object' === type) {
                        if (null === key) throw Error(ERROR);
                        if (ARRAY_BUFFER && key.constructor === ArrayBuffer) key = new Uint8Array(key);
                        else if (!Array.isArray(key) && (!ARRAY_BUFFER || !ArrayBuffer.isView(key))) throw Error(ERROR);
                    } else throw Error(ERROR);
                    key.length > 64 && (key = new Sha256(is224, !0).update(key).array());
                    var oKeyPad = [], iKeyPad = [];
                    for(i = 0; i < 64; ++i){
                        var b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b, iKeyPad[i] = 0x36 ^ b;
                    }
                    Sha256.call(this, is224, sharedMemory), this.update(iKeyPad), this.oKeyPad = oKeyPad, this.inner = !0, this.sharedMemory = sharedMemory;
                }
                Sha256.prototype.update = function(message) {
                    if (!this.finalized) {
                        var notString, type = typeof message;
                        if ('string' !== type) {
                            if ('object' === type) {
                                if (null === message) throw Error(ERROR);
                                if (ARRAY_BUFFER && message.constructor === ArrayBuffer) message = new Uint8Array(message);
                                else if (!Array.isArray(message) && (!ARRAY_BUFFER || !ArrayBuffer.isView(message))) throw Error(ERROR);
                            } else throw Error(ERROR);
                            notString = !0;
                        }
                        for(var code, i, index = 0, length = message.length, blocks = this.blocks; index < length;){
                            if (this.hashed && (this.hashed = !1, blocks[0] = this.block, blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0), notString) for(i = this.start; index < length && i < 64; ++index)blocks[i >> 2] |= message[index] << SHIFT[3 & i++];
                            else for(i = this.start; index < length && i < 64; ++index)(code = message.charCodeAt(index)) < 0x80 ? blocks[i >> 2] |= code << SHIFT[3 & i++] : code < 0x800 ? (blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | 0x3f & code) << SHIFT[3 & i++]) : code < 0xd800 || code >= 0xe000 ? (blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | 0x3f & code) << SHIFT[3 & i++]) : (code = 0x10000 + ((0x3ff & code) << 10 | 0x3ff & message.charCodeAt(++index)), blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | 0x3f & code) << SHIFT[3 & i++]);
                            this.lastByteIndex = i, this.bytes += i - this.start, i >= 64 ? (this.block = blocks[16], this.start = i - 64, this.hash(), this.hashed = !0) : this.start = i;
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
                    }
                }, Sha256.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var blocks = this.blocks, i = this.lastByteIndex;
                        blocks[16] = this.block, blocks[i >> 2] |= EXTRA[3 & i], this.block = blocks[16], i >= 56 && (this.hashed || this.hash(), blocks[0] = this.block, blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0), blocks[14] = this.hBytes << 3 | this.bytes >>> 29, blocks[15] = this.bytes << 3, this.hash();
                    }
                }, Sha256.prototype.hash = function() {
                    var j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc, a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks = this.blocks;
                    for(j = 16; j < 64; ++j)s0 = ((t1 = blocks[j - 15]) >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3, s1 = ((t1 = blocks[j - 2]) >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10, blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
                    for(j = 0, bc = b & c; j < 64; j += 4)this.first ? (this.is224 ? (ab = 300032, h = (t1 = blocks[0] - 1413257819) - 150054599 << 0, d = t1 + 24177077 << 0) : (ab = 704751109, h = (t1 = blocks[0] - 210244248) - 1521486534 << 0, d = t1 + 143694565 << 0), this.first = !1) : (s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10), s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7), maj = (ab = a & b) ^ a & c ^ bc, t1 = h + s1 + (ch = e & f ^ ~e & g) + K[j] + blocks[j], t2 = s0 + maj, h = d + t1 << 0, d = t1 + t2 << 0), s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10), s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7), maj = (da = d & a) ^ d & b ^ ab, t1 = g + s1 + (ch = h & e ^ ~h & f) + K[j + 1] + blocks[j + 1], t2 = s0 + maj, g = c + t1 << 0, s0 = ((c = t1 + t2 << 0) >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7), maj = (cd = c & d) ^ c & a ^ da, t1 = f + s1 + (ch = g & h ^ ~g & e) + K[j + 2] + blocks[j + 2], t2 = s0 + maj, f = b + t1 << 0, s0 = ((b = t1 + t2 << 0) >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10), s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7), maj = (bc = b & c) ^ b & d ^ cd, t1 = e + s1 + (ch = f & g ^ ~f & h) + K[j + 3] + blocks[j + 3], t2 = s0 + maj, e = a + t1 << 0, a = t1 + t2 << 0;
                    this.h0 = this.h0 + a << 0, this.h1 = this.h1 + b << 0, this.h2 = this.h2 + c << 0, this.h3 = this.h3 + d << 0, this.h4 = this.h4 + e << 0, this.h5 = this.h5 + f << 0, this.h6 = this.h6 + g << 0, this.h7 = this.h7 + h << 0;
                }, Sha256.prototype.hex = function() {
                    this.finalize();
                    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7, hex = HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[0x0F & h0] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[0x0F & h1] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[0x0F & h2] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[0x0F & h3] + HEX_CHARS[h4 >> 28 & 0x0F] + HEX_CHARS[h4 >> 24 & 0x0F] + HEX_CHARS[h4 >> 20 & 0x0F] + HEX_CHARS[h4 >> 16 & 0x0F] + HEX_CHARS[h4 >> 12 & 0x0F] + HEX_CHARS[h4 >> 8 & 0x0F] + HEX_CHARS[h4 >> 4 & 0x0F] + HEX_CHARS[0x0F & h4] + HEX_CHARS[h5 >> 28 & 0x0F] + HEX_CHARS[h5 >> 24 & 0x0F] + HEX_CHARS[h5 >> 20 & 0x0F] + HEX_CHARS[h5 >> 16 & 0x0F] + HEX_CHARS[h5 >> 12 & 0x0F] + HEX_CHARS[h5 >> 8 & 0x0F] + HEX_CHARS[h5 >> 4 & 0x0F] + HEX_CHARS[0x0F & h5] + HEX_CHARS[h6 >> 28 & 0x0F] + HEX_CHARS[h6 >> 24 & 0x0F] + HEX_CHARS[h6 >> 20 & 0x0F] + HEX_CHARS[h6 >> 16 & 0x0F] + HEX_CHARS[h6 >> 12 & 0x0F] + HEX_CHARS[h6 >> 8 & 0x0F] + HEX_CHARS[h6 >> 4 & 0x0F] + HEX_CHARS[0x0F & h6];
                    return this.is224 || (hex += HEX_CHARS[h7 >> 28 & 0x0F] + HEX_CHARS[h7 >> 24 & 0x0F] + HEX_CHARS[h7 >> 20 & 0x0F] + HEX_CHARS[h7 >> 16 & 0x0F] + HEX_CHARS[h7 >> 12 & 0x0F] + HEX_CHARS[h7 >> 8 & 0x0F] + HEX_CHARS[h7 >> 4 & 0x0F] + HEX_CHARS[0x0F & h7]), hex;
                }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
                    this.finalize();
                    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7, arr = [
                        h0 >> 24 & 0xFF,
                        h0 >> 16 & 0xFF,
                        h0 >> 8 & 0xFF,
                        0xFF & h0,
                        h1 >> 24 & 0xFF,
                        h1 >> 16 & 0xFF,
                        h1 >> 8 & 0xFF,
                        0xFF & h1,
                        h2 >> 24 & 0xFF,
                        h2 >> 16 & 0xFF,
                        h2 >> 8 & 0xFF,
                        0xFF & h2,
                        h3 >> 24 & 0xFF,
                        h3 >> 16 & 0xFF,
                        h3 >> 8 & 0xFF,
                        0xFF & h3,
                        h4 >> 24 & 0xFF,
                        h4 >> 16 & 0xFF,
                        h4 >> 8 & 0xFF,
                        0xFF & h4,
                        h5 >> 24 & 0xFF,
                        h5 >> 16 & 0xFF,
                        h5 >> 8 & 0xFF,
                        0xFF & h5,
                        h6 >> 24 & 0xFF,
                        h6 >> 16 & 0xFF,
                        h6 >> 8 & 0xFF,
                        0xFF & h6
                    ];
                    return this.is224 || arr.push(h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, 0xFF & h7), arr;
                }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
                    this.finalize();
                    var buffer = new ArrayBuffer(this.is224 ? 28 : 32), dataView = new DataView(buffer);
                    return dataView.setUint32(0, this.h0), dataView.setUint32(4, this.h1), dataView.setUint32(8, this.h2), dataView.setUint32(12, this.h3), dataView.setUint32(16, this.h4), dataView.setUint32(20, this.h5), dataView.setUint32(24, this.h6), this.is224 || dataView.setUint32(28, this.h7), buffer;
                }, HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
                    if (Sha256.prototype.finalize.call(this), this.inner) {
                        this.inner = !1;
                        var innerHash = this.array();
                        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(innerHash), Sha256.prototype.finalize.call(this);
                    }
                };
                var exports = createMethod();
                exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224, AMD && void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return exports;
                }).call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }();
        },
        3434: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__, process = __webpack_require__(3454);
            !function() {
                'use strict';
                var INPUT_ERROR = 'input is invalid type', FINALIZE_ERROR = 'finalize already called', WINDOW = 'object' == typeof window, root = WINDOW ? window : {};
                root.JS_SHA512_NO_WINDOW && (WINDOW = !1);
                var WEB_WORKER = !WINDOW && 'object' == typeof self;
                !root.JS_SHA512_NO_NODE_JS && 'object' == typeof process && process.versions && process.versions.node ? root = __webpack_require__.g : WEB_WORKER && (root = self);
                var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && module.exports, AMD = __webpack_require__.amdO, ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && 'undefined' != typeof ArrayBuffer, HEX_CHARS = '0123456789abcdef'.split(''), EXTRA = [
                    -2147483648,
                    8388608,
                    32768,
                    128
                ], SHIFT = [
                    24,
                    16,
                    8,
                    0
                ], K = [
                    0x428A2F98,
                    0xD728AE22,
                    0x71374491,
                    0x23EF65CD,
                    0xB5C0FBCF,
                    0xEC4D3B2F,
                    0xE9B5DBA5,
                    0x8189DBBC,
                    0x3956C25B,
                    0xF348B538,
                    0x59F111F1,
                    0xB605D019,
                    0x923F82A4,
                    0xAF194F9B,
                    0xAB1C5ED5,
                    0xDA6D8118,
                    0xD807AA98,
                    0xA3030242,
                    0x12835B01,
                    0x45706FBE,
                    0x243185BE,
                    0x4EE4B28C,
                    0x550C7DC3,
                    0xD5FFB4E2,
                    0x72BE5D74,
                    0xF27B896F,
                    0x80DEB1FE,
                    0x3B1696B1,
                    0x9BDC06A7,
                    0x25C71235,
                    0xC19BF174,
                    0xCF692694,
                    0xE49B69C1,
                    0x9EF14AD2,
                    0xEFBE4786,
                    0x384F25E3,
                    0x0FC19DC6,
                    0x8B8CD5B5,
                    0x240CA1CC,
                    0x77AC9C65,
                    0x2DE92C6F,
                    0x592B0275,
                    0x4A7484AA,
                    0x6EA6E483,
                    0x5CB0A9DC,
                    0xBD41FBD4,
                    0x76F988DA,
                    0x831153B5,
                    0x983E5152,
                    0xEE66DFAB,
                    0xA831C66D,
                    0x2DB43210,
                    0xB00327C8,
                    0x98FB213F,
                    0xBF597FC7,
                    0xBEEF0EE4,
                    0xC6E00BF3,
                    0x3DA88FC2,
                    0xD5A79147,
                    0x930AA725,
                    0x06CA6351,
                    0xE003826F,
                    0x14292967,
                    0x0A0E6E70,
                    0x27B70A85,
                    0x46D22FFC,
                    0x2E1B2138,
                    0x5C26C926,
                    0x4D2C6DFC,
                    0x5AC42AED,
                    0x53380D13,
                    0x9D95B3DF,
                    0x650A7354,
                    0x8BAF63DE,
                    0x766A0ABB,
                    0x3C77B2A8,
                    0x81C2C92E,
                    0x47EDAEE6,
                    0x92722C85,
                    0x1482353B,
                    0xA2BFE8A1,
                    0x4CF10364,
                    0xA81A664B,
                    0xBC423001,
                    0xC24B8B70,
                    0xD0F89791,
                    0xC76C51A3,
                    0x0654BE30,
                    0xD192E819,
                    0xD6EF5218,
                    0xD6990624,
                    0x5565A910,
                    0xF40E3585,
                    0x5771202A,
                    0x106AA070,
                    0x32BBD1B8,
                    0x19A4C116,
                    0xB8D2D0C8,
                    0x1E376C08,
                    0x5141AB53,
                    0x2748774C,
                    0xDF8EEB99,
                    0x34B0BCB5,
                    0xE19B48A8,
                    0x391C0CB3,
                    0xC5C95A63,
                    0x4ED8AA4A,
                    0xE3418ACB,
                    0x5B9CCA4F,
                    0x7763E373,
                    0x682E6FF3,
                    0xD6B2B8A3,
                    0x748F82EE,
                    0x5DEFB2FC,
                    0x78A5636F,
                    0x43172F60,
                    0x84C87814,
                    0xA1F0AB72,
                    0x8CC70208,
                    0x1A6439EC,
                    0x90BEFFFA,
                    0x23631E28,
                    0xA4506CEB,
                    0xDE82BDE9,
                    0xBEF9A3F7,
                    0xB2C67915,
                    0xC67178F2,
                    0xE372532B,
                    0xCA273ECE,
                    0xEA26619C,
                    0xD186B8C7,
                    0x21C0C207,
                    0xEADA7DD6,
                    0xCDE0EB1E,
                    0xF57D4F7F,
                    0xEE6ED178,
                    0x06F067AA,
                    0x72176FBA,
                    0x0A637DC5,
                    0xA2C898A6,
                    0x113F9804,
                    0xBEF90DAE,
                    0x1B710B35,
                    0x131C471B,
                    0x28DB77F5,
                    0x23047D84,
                    0x32CAAB7B,
                    0x40C72493,
                    0x3C9EBE0A,
                    0x15C9BEBC,
                    0x431D67C4,
                    0x9C100D4C,
                    0x4CC5D4BE,
                    0xCB3E42B6,
                    0x597F299C,
                    0xFC657E2A,
                    0x5FCB6FAB,
                    0x3AD6FAEC,
                    0x6C44198C,
                    0x4A475817
                ], OUTPUT_TYPES = [
                    'hex',
                    'array',
                    'digest',
                    'arrayBuffer'
                ], blocks = [];
                (root.JS_SHA512_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(obj) {
                    return '[object Array]' === Object.prototype.toString.call(obj);
                }), ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(obj) {
                    return 'object' == typeof obj && obj.buffer && obj.buffer.constructor === ArrayBuffer;
                });
                var createOutputMethod = function(outputType, bits) {
                    return function(message) {
                        return new Sha512(bits, !0).update(message)[outputType]();
                    };
                }, createMethod = function(bits) {
                    var method = createOutputMethod('hex', bits);
                    method.create = function() {
                        return new Sha512(bits);
                    }, method.update = function(message) {
                        return method.create().update(message);
                    };
                    for(var i = 0; i < OUTPUT_TYPES.length; ++i){
                        var type = OUTPUT_TYPES[i];
                        method[type] = createOutputMethod(type, bits);
                    }
                    return method;
                }, createHmacOutputMethod = function(outputType, bits) {
                    return function(key, message) {
                        return new HmacSha512(key, bits, !0).update(message)[outputType]();
                    };
                }, createHmacMethod = function(bits) {
                    var method = createHmacOutputMethod('hex', bits);
                    method.create = function(key) {
                        return new HmacSha512(key, bits);
                    }, method.update = function(key, message) {
                        return method.create(key).update(message);
                    };
                    for(var i = 0; i < OUTPUT_TYPES.length; ++i){
                        var type = OUTPUT_TYPES[i];
                        method[type] = createHmacOutputMethod(type, bits);
                    }
                    return method;
                };
                function Sha512(bits, sharedMemory) {
                    sharedMemory ? (blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0, this.blocks = blocks) : this.blocks = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], 384 == bits ? (this.h0h = 0xCBBB9D5D, this.h0l = 0xC1059ED8, this.h1h = 0x629A292A, this.h1l = 0x367CD507, this.h2h = 0x9159015A, this.h2l = 0x3070DD17, this.h3h = 0x152FECD8, this.h3l = 0xF70E5939, this.h4h = 0x67332667, this.h4l = 0xFFC00B31, this.h5h = 0x8EB44A87, this.h5l = 0x68581511, this.h6h = 0xDB0C2E0D, this.h6l = 0x64F98FA7, this.h7h = 0x47B5481D, this.h7l = 0xBEFA4FA4) : 256 == bits ? (this.h0h = 0x22312194, this.h0l = 0xFC2BF72C, this.h1h = 0x9F555FA3, this.h1l = 0xC84C64C2, this.h2h = 0x2393B86B, this.h2l = 0x6F53B151, this.h3h = 0x96387719, this.h3l = 0x5940EABD, this.h4h = 0x96283EE2, this.h4l = 0xA88EFFE3, this.h5h = 0xBE5E1E25, this.h5l = 0x53863992, this.h6h = 0x2B0199FC, this.h6l = 0x2C85B8AA, this.h7h = 0x0EB72DDC, this.h7l = 0x81C52CA2) : 224 == bits ? (this.h0h = 0x8C3D37C8, this.h0l = 0x19544DA2, this.h1h = 0x73E19966, this.h1l = 0x89DCD4D6, this.h2h = 0x1DFAB7AE, this.h2l = 0x32FF9C82, this.h3h = 0x679DD514, this.h3l = 0x582F9FCF, this.h4h = 0x0F6D2B69, this.h4l = 0x7BD44DA8, this.h5h = 0x77E36F73, this.h5l = 0x04C48942, this.h6h = 0x3F9D85A8, this.h6l = 0x6A1D36C8, this.h7h = 0x1112E6AD, this.h7l = 0x91D692A1) : (this.h0h = 0x6A09E667, this.h0l = 0xF3BCC908, this.h1h = 0xBB67AE85, this.h1l = 0x84CAA73B, this.h2h = 0x3C6EF372, this.h2l = 0xFE94F82B, this.h3h = 0xA54FF53A, this.h3l = 0x5F1D36F1, this.h4h = 0x510E527F, this.h4l = 0xADE682D1, this.h5h = 0x9B05688C, this.h5l = 0x2B3E6C1F, this.h6h = 0x1F83D9AB, this.h6l = 0xFB41BD6B, this.h7h = 0x5BE0CD19, this.h7l = 0x137E2179), this.bits = bits, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1;
                }
                function HmacSha512(key, bits, sharedMemory) {
                    var notString, type = typeof key;
                    if ('string' !== type) {
                        if ('object' === type) {
                            if (null === key) throw Error(INPUT_ERROR);
                            if (ARRAY_BUFFER && key.constructor === ArrayBuffer) key = new Uint8Array(key);
                            else if (!Array.isArray(key) && (!ARRAY_BUFFER || !ArrayBuffer.isView(key))) throw Error(INPUT_ERROR);
                        } else throw Error(INPUT_ERROR);
                        notString = !0;
                    }
                    var length = key.length;
                    if (!notString) {
                        for(var code, bytes = [], length = key.length, index = 0, i = 0; i < length; ++i)(code = key.charCodeAt(i)) < 0x80 ? bytes[index++] = code : code < 0x800 ? (bytes[index++] = 0xc0 | code >> 6, bytes[index++] = 0x80 | 0x3f & code) : code < 0xd800 || code >= 0xe000 ? (bytes[index++] = 0xe0 | code >> 12, bytes[index++] = 0x80 | code >> 6 & 0x3f, bytes[index++] = 0x80 | 0x3f & code) : (code = 0x10000 + ((0x3ff & code) << 10 | 0x3ff & key.charCodeAt(++i)), bytes[index++] = 0xf0 | code >> 18, bytes[index++] = 0x80 | code >> 12 & 0x3f, bytes[index++] = 0x80 | code >> 6 & 0x3f, bytes[index++] = 0x80 | 0x3f & code);
                        key = bytes;
                    }
                    key.length > 128 && (key = new Sha512(bits, !0).update(key).array());
                    for(var oKeyPad = [], iKeyPad = [], i = 0; i < 128; ++i){
                        var b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b, iKeyPad[i] = 0x36 ^ b;
                    }
                    Sha512.call(this, bits, sharedMemory), this.update(iKeyPad), this.oKeyPad = oKeyPad, this.inner = !0, this.sharedMemory = sharedMemory;
                }
                Sha512.prototype.update = function(message) {
                    if (this.finalized) throw Error(FINALIZE_ERROR);
                    var notString, type = typeof message;
                    if ('string' !== type) {
                        if ('object' === type) {
                            if (null === message) throw Error(INPUT_ERROR);
                            if (ARRAY_BUFFER && message.constructor === ArrayBuffer) message = new Uint8Array(message);
                            else if (!Array.isArray(message) && (!ARRAY_BUFFER || !ArrayBuffer.isView(message))) throw Error(INPUT_ERROR);
                        } else throw Error(INPUT_ERROR);
                        notString = !0;
                    }
                    for(var code, i, index = 0, length = message.length, blocks = this.blocks; index < length;){
                        if (this.hashed && (this.hashed = !1, blocks[0] = this.block, blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0), notString) for(i = this.start; index < length && i < 128; ++index)blocks[i >> 2] |= message[index] << SHIFT[3 & i++];
                        else for(i = this.start; index < length && i < 128; ++index)(code = message.charCodeAt(index)) < 0x80 ? blocks[i >> 2] |= code << SHIFT[3 & i++] : code < 0x800 ? (blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | 0x3f & code) << SHIFT[3 & i++]) : code < 0xd800 || code >= 0xe000 ? (blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | 0x3f & code) << SHIFT[3 & i++]) : (code = 0x10000 + ((0x3ff & code) << 10 | 0x3ff & message.charCodeAt(++index)), blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[3 & i++], blocks[i >> 2] |= (0x80 | 0x3f & code) << SHIFT[3 & i++]);
                        this.lastByteIndex = i, this.bytes += i - this.start, i >= 128 ? (this.block = blocks[32], this.start = i - 128, this.hash(), this.hashed = !0) : this.start = i;
                    }
                    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
                }, Sha512.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var blocks = this.blocks, i = this.lastByteIndex;
                        blocks[32] = this.block, blocks[i >> 2] |= EXTRA[3 & i], this.block = blocks[32], i >= 112 && (this.hashed || this.hash(), blocks[0] = this.block, blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0), blocks[30] = this.hBytes << 3 | this.bytes >>> 29, blocks[31] = this.bytes << 3, this.hash();
                    }
                }, Sha512.prototype.hash = function() {
                    var j, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl, h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks = this.blocks;
                    for(j = 32; j < 160; j += 2)s0h = ((t1h = blocks[j - 30]) >>> 1 | (t1l = blocks[j - 29]) << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7, s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25), s1h = ((t1h = blocks[j - 4]) >>> 19 | (t1l = blocks[j - 3]) << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6, s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26), t1h = blocks[j - 32], t1l = blocks[j - 31], t2h = blocks[j - 14], c1 = (0xFFFF & (t2l = blocks[j - 13])) + (0xFFFF & t1l) + (0xFFFF & s0l) + (0xFFFF & s1l), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + (0xFFFF & s0h) + (0xFFFF & s1h) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16)) >>> 16), c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16), blocks[j] = c4 << 16 | 0xFFFF & c3, blocks[j + 1] = c2 << 16 | 0xFFFF & c1;
                    var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
                    for(j = 0, bch = bh & ch, bcl = bl & cl; j < 160; j += 8)s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25), s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25), s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23), s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23), abh = ah & bh, abl = al & bl, majh = abh ^ ah & ch ^ bch, majl = abl ^ al & cl ^ bcl, chh = eh & fh ^ ~eh & gh, chl = el & fl ^ ~el & gl, t1h = blocks[j], t1l = blocks[j + 1], t2h = K[j], c1 = (0xFFFF & (t2l = K[j + 1])) + (0xFFFF & t1l) + (0xFFFF & chl) + (0xFFFF & s1l) + (0xFFFF & hl), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + (0xFFFF & chh) + (0xFFFF & s1h) + (0xFFFF & hh) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16)) >>> 16), t1h = (c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t1l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & majl) + (0xFFFF & s0l), c3 = (0xFFFF & majh) + (0xFFFF & s0h) + ((c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16)) >>> 16), t2h = (c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t2l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & dl) + (0xFFFF & t1l), c3 = (0xFFFF & dh) + (0xFFFF & t1h) + ((c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), hh = (c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, hl = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & t2l) + (0xFFFF & t1l), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), s0h = ((dh = (c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3) >>> 28 | (dl = c2 << 16 | 0xFFFF & c1) << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25), s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25), s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23), s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23), dah = dh & ah, dal = dl & al, majh = dah ^ dh & bh ^ abh, majl = dal ^ dl & bl ^ abl, chh = hh & eh ^ ~hh & fh, chl = hl & el ^ ~hl & fl, t1h = blocks[j + 2], t1l = blocks[j + 3], t2h = K[j + 2], c1 = (0xFFFF & (t2l = K[j + 3])) + (0xFFFF & t1l) + (0xFFFF & chl) + (0xFFFF & s1l) + (0xFFFF & gl), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + (0xFFFF & chh) + (0xFFFF & s1h) + (0xFFFF & gh) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16)) >>> 16), t1h = (c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t1l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & majl) + (0xFFFF & s0l), c3 = (0xFFFF & majh) + (0xFFFF & s0h) + ((c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16)) >>> 16), t2h = (c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t2l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & cl) + (0xFFFF & t1l), c3 = (0xFFFF & ch) + (0xFFFF & t1h) + ((c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), gh = (c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, gl = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & t2l) + (0xFFFF & t1l), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), s0h = ((ch = (c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3) >>> 28 | (cl = c2 << 16 | 0xFFFF & c1) << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25), s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25), s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23), s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23), cdh = ch & dh, cdl = cl & dl, majh = cdh ^ ch & ah ^ dah, majl = cdl ^ cl & al ^ dal, chh = gh & hh ^ ~gh & eh, chl = gl & hl ^ ~gl & el, t1h = blocks[j + 4], t1l = blocks[j + 5], t2h = K[j + 4], c1 = (0xFFFF & (t2l = K[j + 5])) + (0xFFFF & t1l) + (0xFFFF & chl) + (0xFFFF & s1l) + (0xFFFF & fl), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + (0xFFFF & chh) + (0xFFFF & s1h) + (0xFFFF & fh) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16)) >>> 16), t1h = (c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t1l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & majl) + (0xFFFF & s0l), c3 = (0xFFFF & majh) + (0xFFFF & s0h) + ((c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16)) >>> 16), t2h = (c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t2l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & bl) + (0xFFFF & t1l), c3 = (0xFFFF & bh) + (0xFFFF & t1h) + ((c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), fh = (c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, fl = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & t2l) + (0xFFFF & t1l), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), s0h = ((bh = (c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3) >>> 28 | (bl = c2 << 16 | 0xFFFF & c1) << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25), s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25), s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23), s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23), bch = bh & ch, bcl = bl & cl, majh = bch ^ bh & dh ^ cdh, majl = bcl ^ bl & dl ^ cdl, chh = fh & gh ^ ~fh & hh, chl = fl & gl ^ ~fl & hl, t1h = blocks[j + 6], t1l = blocks[j + 7], t2h = K[j + 6], c1 = (0xFFFF & (t2l = K[j + 7])) + (0xFFFF & t1l) + (0xFFFF & chl) + (0xFFFF & s1l) + (0xFFFF & el), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + (0xFFFF & chh) + (0xFFFF & s1h) + (0xFFFF & eh) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16)) >>> 16), t1h = (c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t1l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & majl) + (0xFFFF & s0l), c3 = (0xFFFF & majh) + (0xFFFF & s0h) + ((c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16)) >>> 16), t2h = (c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, t2l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & al) + (0xFFFF & t1l), c3 = (0xFFFF & ah) + (0xFFFF & t1h) + ((c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), eh = (c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, el = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & t2l) + (0xFFFF & t1l), c3 = (0xFFFF & t2h) + (0xFFFF & t1h) + ((c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16)) >>> 16), ah = (c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16)) << 16 | 0xFFFF & c3, al = c2 << 16 | 0xFFFF & c1;
                    c1 = (0xFFFF & h0l) + (0xFFFF & al), c3 = (0xFFFF & h0h) + (0xFFFF & ah) + ((c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16), this.h0h = c4 << 16 | 0xFFFF & c3, this.h0l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & h1l) + (0xFFFF & bl), c3 = (0xFFFF & h1h) + (0xFFFF & bh) + ((c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16), this.h1h = c4 << 16 | 0xFFFF & c3, this.h1l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & h2l) + (0xFFFF & cl), c3 = (0xFFFF & h2h) + (0xFFFF & ch) + ((c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16), this.h2h = c4 << 16 | 0xFFFF & c3, this.h2l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & h3l) + (0xFFFF & dl), c3 = (0xFFFF & h3h) + (0xFFFF & dh) + ((c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16), this.h3h = c4 << 16 | 0xFFFF & c3, this.h3l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & h4l) + (0xFFFF & el), c3 = (0xFFFF & h4h) + (0xFFFF & eh) + ((c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16), this.h4h = c4 << 16 | 0xFFFF & c3, this.h4l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & h5l) + (0xFFFF & fl), c3 = (0xFFFF & h5h) + (0xFFFF & fh) + ((c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16), this.h5h = c4 << 16 | 0xFFFF & c3, this.h5l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & h6l) + (0xFFFF & gl), c3 = (0xFFFF & h6h) + (0xFFFF & gh) + ((c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16), this.h6h = c4 << 16 | 0xFFFF & c3, this.h6l = c2 << 16 | 0xFFFF & c1, c1 = (0xFFFF & h7l) + (0xFFFF & hl), c3 = (0xFFFF & h7h) + (0xFFFF & hh) + ((c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16)) >>> 16), c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16), this.h7h = c4 << 16 | 0xFFFF & c3, this.h7l = c2 << 16 | 0xFFFF & c1;
                }, Sha512.prototype.hex = function() {
                    this.finalize();
                    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits, hex = HEX_CHARS[h0h >> 28 & 0x0F] + HEX_CHARS[h0h >> 24 & 0x0F] + HEX_CHARS[h0h >> 20 & 0x0F] + HEX_CHARS[h0h >> 16 & 0x0F] + HEX_CHARS[h0h >> 12 & 0x0F] + HEX_CHARS[h0h >> 8 & 0x0F] + HEX_CHARS[h0h >> 4 & 0x0F] + HEX_CHARS[0x0F & h0h] + HEX_CHARS[h0l >> 28 & 0x0F] + HEX_CHARS[h0l >> 24 & 0x0F] + HEX_CHARS[h0l >> 20 & 0x0F] + HEX_CHARS[h0l >> 16 & 0x0F] + HEX_CHARS[h0l >> 12 & 0x0F] + HEX_CHARS[h0l >> 8 & 0x0F] + HEX_CHARS[h0l >> 4 & 0x0F] + HEX_CHARS[0x0F & h0l] + HEX_CHARS[h1h >> 28 & 0x0F] + HEX_CHARS[h1h >> 24 & 0x0F] + HEX_CHARS[h1h >> 20 & 0x0F] + HEX_CHARS[h1h >> 16 & 0x0F] + HEX_CHARS[h1h >> 12 & 0x0F] + HEX_CHARS[h1h >> 8 & 0x0F] + HEX_CHARS[h1h >> 4 & 0x0F] + HEX_CHARS[0x0F & h1h] + HEX_CHARS[h1l >> 28 & 0x0F] + HEX_CHARS[h1l >> 24 & 0x0F] + HEX_CHARS[h1l >> 20 & 0x0F] + HEX_CHARS[h1l >> 16 & 0x0F] + HEX_CHARS[h1l >> 12 & 0x0F] + HEX_CHARS[h1l >> 8 & 0x0F] + HEX_CHARS[h1l >> 4 & 0x0F] + HEX_CHARS[0x0F & h1l] + HEX_CHARS[h2h >> 28 & 0x0F] + HEX_CHARS[h2h >> 24 & 0x0F] + HEX_CHARS[h2h >> 20 & 0x0F] + HEX_CHARS[h2h >> 16 & 0x0F] + HEX_CHARS[h2h >> 12 & 0x0F] + HEX_CHARS[h2h >> 8 & 0x0F] + HEX_CHARS[h2h >> 4 & 0x0F] + HEX_CHARS[0x0F & h2h] + HEX_CHARS[h2l >> 28 & 0x0F] + HEX_CHARS[h2l >> 24 & 0x0F] + HEX_CHARS[h2l >> 20 & 0x0F] + HEX_CHARS[h2l >> 16 & 0x0F] + HEX_CHARS[h2l >> 12 & 0x0F] + HEX_CHARS[h2l >> 8 & 0x0F] + HEX_CHARS[h2l >> 4 & 0x0F] + HEX_CHARS[0x0F & h2l] + HEX_CHARS[h3h >> 28 & 0x0F] + HEX_CHARS[h3h >> 24 & 0x0F] + HEX_CHARS[h3h >> 20 & 0x0F] + HEX_CHARS[h3h >> 16 & 0x0F] + HEX_CHARS[h3h >> 12 & 0x0F] + HEX_CHARS[h3h >> 8 & 0x0F] + HEX_CHARS[h3h >> 4 & 0x0F] + HEX_CHARS[0x0F & h3h];
                    return bits >= 256 && (hex += HEX_CHARS[h3l >> 28 & 0x0F] + HEX_CHARS[h3l >> 24 & 0x0F] + HEX_CHARS[h3l >> 20 & 0x0F] + HEX_CHARS[h3l >> 16 & 0x0F] + HEX_CHARS[h3l >> 12 & 0x0F] + HEX_CHARS[h3l >> 8 & 0x0F] + HEX_CHARS[h3l >> 4 & 0x0F] + HEX_CHARS[0x0F & h3l]), bits >= 384 && (hex += HEX_CHARS[h4h >> 28 & 0x0F] + HEX_CHARS[h4h >> 24 & 0x0F] + HEX_CHARS[h4h >> 20 & 0x0F] + HEX_CHARS[h4h >> 16 & 0x0F] + HEX_CHARS[h4h >> 12 & 0x0F] + HEX_CHARS[h4h >> 8 & 0x0F] + HEX_CHARS[h4h >> 4 & 0x0F] + HEX_CHARS[0x0F & h4h] + HEX_CHARS[h4l >> 28 & 0x0F] + HEX_CHARS[h4l >> 24 & 0x0F] + HEX_CHARS[h4l >> 20 & 0x0F] + HEX_CHARS[h4l >> 16 & 0x0F] + HEX_CHARS[h4l >> 12 & 0x0F] + HEX_CHARS[h4l >> 8 & 0x0F] + HEX_CHARS[h4l >> 4 & 0x0F] + HEX_CHARS[0x0F & h4l] + HEX_CHARS[h5h >> 28 & 0x0F] + HEX_CHARS[h5h >> 24 & 0x0F] + HEX_CHARS[h5h >> 20 & 0x0F] + HEX_CHARS[h5h >> 16 & 0x0F] + HEX_CHARS[h5h >> 12 & 0x0F] + HEX_CHARS[h5h >> 8 & 0x0F] + HEX_CHARS[h5h >> 4 & 0x0F] + HEX_CHARS[0x0F & h5h] + HEX_CHARS[h5l >> 28 & 0x0F] + HEX_CHARS[h5l >> 24 & 0x0F] + HEX_CHARS[h5l >> 20 & 0x0F] + HEX_CHARS[h5l >> 16 & 0x0F] + HEX_CHARS[h5l >> 12 & 0x0F] + HEX_CHARS[h5l >> 8 & 0x0F] + HEX_CHARS[h5l >> 4 & 0x0F] + HEX_CHARS[0x0F & h5l]), 512 == bits && (hex += HEX_CHARS[h6h >> 28 & 0x0F] + HEX_CHARS[h6h >> 24 & 0x0F] + HEX_CHARS[h6h >> 20 & 0x0F] + HEX_CHARS[h6h >> 16 & 0x0F] + HEX_CHARS[h6h >> 12 & 0x0F] + HEX_CHARS[h6h >> 8 & 0x0F] + HEX_CHARS[h6h >> 4 & 0x0F] + HEX_CHARS[0x0F & h6h] + HEX_CHARS[h6l >> 28 & 0x0F] + HEX_CHARS[h6l >> 24 & 0x0F] + HEX_CHARS[h6l >> 20 & 0x0F] + HEX_CHARS[h6l >> 16 & 0x0F] + HEX_CHARS[h6l >> 12 & 0x0F] + HEX_CHARS[h6l >> 8 & 0x0F] + HEX_CHARS[h6l >> 4 & 0x0F] + HEX_CHARS[0x0F & h6l] + HEX_CHARS[h7h >> 28 & 0x0F] + HEX_CHARS[h7h >> 24 & 0x0F] + HEX_CHARS[h7h >> 20 & 0x0F] + HEX_CHARS[h7h >> 16 & 0x0F] + HEX_CHARS[h7h >> 12 & 0x0F] + HEX_CHARS[h7h >> 8 & 0x0F] + HEX_CHARS[h7h >> 4 & 0x0F] + HEX_CHARS[0x0F & h7h] + HEX_CHARS[h7l >> 28 & 0x0F] + HEX_CHARS[h7l >> 24 & 0x0F] + HEX_CHARS[h7l >> 20 & 0x0F] + HEX_CHARS[h7l >> 16 & 0x0F] + HEX_CHARS[h7l >> 12 & 0x0F] + HEX_CHARS[h7l >> 8 & 0x0F] + HEX_CHARS[h7l >> 4 & 0x0F] + HEX_CHARS[0x0F & h7l]), hex;
                }, Sha512.prototype.toString = Sha512.prototype.hex, Sha512.prototype.digest = function() {
                    this.finalize();
                    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits, arr = [
                        h0h >> 24 & 0xFF,
                        h0h >> 16 & 0xFF,
                        h0h >> 8 & 0xFF,
                        0xFF & h0h,
                        h0l >> 24 & 0xFF,
                        h0l >> 16 & 0xFF,
                        h0l >> 8 & 0xFF,
                        0xFF & h0l,
                        h1h >> 24 & 0xFF,
                        h1h >> 16 & 0xFF,
                        h1h >> 8 & 0xFF,
                        0xFF & h1h,
                        h1l >> 24 & 0xFF,
                        h1l >> 16 & 0xFF,
                        h1l >> 8 & 0xFF,
                        0xFF & h1l,
                        h2h >> 24 & 0xFF,
                        h2h >> 16 & 0xFF,
                        h2h >> 8 & 0xFF,
                        0xFF & h2h,
                        h2l >> 24 & 0xFF,
                        h2l >> 16 & 0xFF,
                        h2l >> 8 & 0xFF,
                        0xFF & h2l,
                        h3h >> 24 & 0xFF,
                        h3h >> 16 & 0xFF,
                        h3h >> 8 & 0xFF,
                        0xFF & h3h
                    ];
                    return bits >= 256 && arr.push(h3l >> 24 & 0xFF, h3l >> 16 & 0xFF, h3l >> 8 & 0xFF, 0xFF & h3l), bits >= 384 && arr.push(h4h >> 24 & 0xFF, h4h >> 16 & 0xFF, h4h >> 8 & 0xFF, 0xFF & h4h, h4l >> 24 & 0xFF, h4l >> 16 & 0xFF, h4l >> 8 & 0xFF, 0xFF & h4l, h5h >> 24 & 0xFF, h5h >> 16 & 0xFF, h5h >> 8 & 0xFF, 0xFF & h5h, h5l >> 24 & 0xFF, h5l >> 16 & 0xFF, h5l >> 8 & 0xFF, 0xFF & h5l), 512 == bits && arr.push(h6h >> 24 & 0xFF, h6h >> 16 & 0xFF, h6h >> 8 & 0xFF, 0xFF & h6h, h6l >> 24 & 0xFF, h6l >> 16 & 0xFF, h6l >> 8 & 0xFF, 0xFF & h6l, h7h >> 24 & 0xFF, h7h >> 16 & 0xFF, h7h >> 8 & 0xFF, 0xFF & h7h, h7l >> 24 & 0xFF, h7l >> 16 & 0xFF, h7l >> 8 & 0xFF, 0xFF & h7l), arr;
                }, Sha512.prototype.array = Sha512.prototype.digest, Sha512.prototype.arrayBuffer = function() {
                    this.finalize();
                    var bits = this.bits, buffer = new ArrayBuffer(bits / 8), dataView = new DataView(buffer);
                    return dataView.setUint32(0, this.h0h), dataView.setUint32(4, this.h0l), dataView.setUint32(8, this.h1h), dataView.setUint32(12, this.h1l), dataView.setUint32(16, this.h2h), dataView.setUint32(20, this.h2l), dataView.setUint32(24, this.h3h), bits >= 256 && dataView.setUint32(28, this.h3l), bits >= 384 && (dataView.setUint32(32, this.h4h), dataView.setUint32(36, this.h4l), dataView.setUint32(40, this.h5h), dataView.setUint32(44, this.h5l)), 512 == bits && (dataView.setUint32(48, this.h6h), dataView.setUint32(52, this.h6l), dataView.setUint32(56, this.h7h), dataView.setUint32(60, this.h7l)), buffer;
                }, Sha512.prototype.clone = function() {
                    var hash = new Sha512(this.bits, !1);
                    return this.copyTo(hash), hash;
                }, Sha512.prototype.copyTo = function(hash) {
                    var i = 0, attrs = [
                        'h0h',
                        'h0l',
                        'h1h',
                        'h1l',
                        'h2h',
                        'h2l',
                        'h3h',
                        'h3l',
                        'h4h',
                        'h4l',
                        'h5h',
                        'h5l',
                        'h6h',
                        'h6l',
                        'h7h',
                        'h7l',
                        'start',
                        'bytes',
                        'hBytes',
                        'finalized',
                        'hashed',
                        'lastByteIndex'
                    ];
                    for(i = 0; i < attrs.length; ++i)hash[attrs[i]] = this[attrs[i]];
                    for(i = 0; i < this.blocks.length; ++i)hash.blocks[i] = this.blocks[i];
                }, HmacSha512.prototype = new Sha512(), HmacSha512.prototype.finalize = function() {
                    if (Sha512.prototype.finalize.call(this), this.inner) {
                        this.inner = !1;
                        var innerHash = this.array();
                        Sha512.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(innerHash), Sha512.prototype.finalize.call(this);
                    }
                }, HmacSha512.prototype.clone = function() {
                    var hash = new HmacSha512([], this.bits, !1);
                    this.copyTo(hash), hash.inner = this.inner;
                    for(var i = 0; i < this.oKeyPad.length; ++i)hash.oKeyPad[i] = this.oKeyPad[i];
                    return hash;
                };
                var exports = createMethod(512);
                exports.sha512 = exports, exports.sha384 = createMethod(384), exports.sha512_256 = createMethod(256), exports.sha512_224 = createMethod(224), exports.sha512.hmac = createHmacMethod(512), exports.sha384.hmac = createHmacMethod(384), exports.sha512_256.hmac = createHmacMethod(256), exports.sha512_224.hmac = createHmacMethod(224), COMMON_JS ? module.exports = exports : (root.sha512 = exports.sha512, root.sha384 = exports.sha384, root.sha512_256 = exports.sha512_256, root.sha512_224 = exports.sha512_224, AMD && void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return exports;
                }).call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }();
        },
        5548: function(__unused_webpack_module, exports, __webpack_require__) {
            exports.unsigned = __webpack_require__(6922), exports.signed = __webpack_require__(4927);
        },
        4927: function(module, __unused_webpack_exports, __webpack_require__) {
            const Bn = __webpack_require__(3550), Pipe = __webpack_require__(3533);
            function read(stream) {
                return readBn(stream).toString();
            }
            function readBn(stream) {
                const num = new Bn(0);
                let shift = 0, byt;
                for(; byt = stream.read(1)[0], num.ior(new Bn(0x7f & byt).shln(shift)), shift += 7, byt >> 7 != 0;);
                return 0x40 & byt && num.setn(shift), num.fromTwos(shift);
            }
            function write(number, stream) {
                let num = new Bn(number);
                const isNeg = num.isNeg();
                for(isNeg && (num = num.toTwos(num.bitLength() + 8));;){
                    const i = num.maskn(7).toNumber();
                    if (num.ishrn(7), isNegOne(num) && (0x40 & i) != 0 || num.isZero() && (0x40 & i) == 0) {
                        stream.write([
                            i
                        ]);
                        break;
                    }
                    stream.write([
                        0x80 | i
                    ]);
                }
                function isNegOne(num) {
                    return isNeg && 0 > num.toString(2).indexOf('0');
                }
            }
            function encode(num) {
                const stream = new Pipe();
                return write(num, stream), stream.buffer;
            }
            function decode(buffer) {
                const stream = new Pipe(buffer);
                return read(stream);
            }
            module.exports = {
                encode,
                decode,
                write,
                read,
                readBn
            };
        },
        6922: function(module, __unused_webpack_exports, __webpack_require__) {
            const Bn = __webpack_require__(3550), Pipe = __webpack_require__(3533);
            function read(stream) {
                return readBn(stream).toString();
            }
            function readBn(stream) {
                const num = new Bn(0);
                let shift = 0, byt;
                for(; byt = stream.read(1)[0], num.ior(new Bn(0x7f & byt).shln(shift)), byt >> 7 != 0;)shift += 7;
                return num;
            }
            function write(number, stream) {
                const num = new Bn(number);
                for(;;){
                    const i = num.maskn(7).toNumber();
                    if (num.ishrn(7), num.isZero()) {
                        stream.write([
                            i
                        ]);
                        break;
                    }
                    stream.write([
                        0x80 | i
                    ]);
                }
            }
            function encode(num) {
                const stream = new Pipe();
                return write(num, stream), stream.buffer;
            }
            function decode(buffer) {
                const stream = new Pipe(buffer);
                return read(stream);
            }
            module.exports = {
                encode,
                decode,
                read,
                readBn,
                write
            };
        },
        1675: function(__unused_webpack_module, exports) {
            "use strict";
            exports.supports = function(...manifests) {
                const manifest = manifests.reduce((acc, m)=>Object.assign(acc, m), {});
                return Object.assign(manifest, {
                    snapshots: manifest.snapshots || !1,
                    permanence: manifest.permanence || !1,
                    seek: manifest.seek || !1,
                    clear: manifest.clear || !1,
                    getMany: manifest.getMany || !1,
                    keyIterator: manifest.keyIterator || !1,
                    valueIterator: manifest.valueIterator || !1,
                    iteratorNextv: manifest.iteratorNextv || !1,
                    iteratorAll: manifest.iteratorAll || !1,
                    status: manifest.status || !1,
                    createIfMissing: manifest.createIfMissing || !1,
                    errorIfExists: manifest.errorIfExists || !1,
                    deferredOpen: manifest.deferredOpen || !1,
                    promises: manifest.promises || !1,
                    streams: manifest.streams || !1,
                    encodings: Object.assign({}, manifest.encodings),
                    events: Object.assign({}, manifest.events),
                    additionalMethods: Object.assign({}, manifest.additionalMethods)
                });
            };
        },
        8499: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const ModuleError = __webpack_require__(4473), encodings = __webpack_require__(8002), { Encoding  } = __webpack_require__(8266), { BufferFormat , ViewFormat , UTF8Format  } = __webpack_require__(2376), kFormats = Symbol('formats'), kEncodings = Symbol('encodings'), validFormats = new Set([
                'buffer',
                'view',
                'utf8'
            ]);
            class Transcoder {
                constructor(formats){
                    if (Array.isArray(formats)) {
                        if (!formats.every((f)=>validFormats.has(f))) throw TypeError("Format must be one of 'buffer', 'view', 'utf8'");
                    } else throw TypeError("The first argument 'formats' must be an array");
                    for(const k in this[kEncodings] = new Map(), this[kFormats] = new Set(formats), encodings)try {
                        this.encoding(k);
                    } catch (err) {
                        if ('LEVEL_ENCODING_NOT_SUPPORTED' !== err.code) throw err;
                    }
                }
                encodings() {
                    return Array.from(new Set(this[kEncodings].values()));
                }
                encoding(encoding) {
                    let resolved = this[kEncodings].get(encoding);
                    if (void 0 === resolved) {
                        if ('string' == typeof encoding && '' !== encoding) {
                            if (!(resolved = lookup[encoding])) throw new ModuleError(`Encoding '${encoding}' is not found`, {
                                code: 'LEVEL_ENCODING_NOT_FOUND'
                            });
                        } else if ('object' != typeof encoding || null === encoding) throw TypeError("First argument 'encoding' must be a string or object");
                        else resolved = from(encoding);
                        const { name , format  } = resolved;
                        if (!this[kFormats].has(format)) {
                            if (this[kFormats].has('view')) resolved = resolved.createViewTranscoder();
                            else if (this[kFormats].has('buffer')) resolved = resolved.createBufferTranscoder();
                            else if (this[kFormats].has('utf8')) resolved = resolved.createUTF8Transcoder();
                            else throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {
                                code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                            });
                        }
                        for (const k of [
                            encoding,
                            name,
                            resolved.name,
                            resolved.commonName
                        ])this[kEncodings].set(k, resolved);
                    }
                    return resolved;
                }
            }
            function from(options) {
                if (options instanceof Encoding) return options;
                const maybeType = 'type' in options && 'string' == typeof options.type ? options.type : void 0, name = options.name || maybeType || `anonymous-${anonymousCount++}`;
                switch(detectFormat(options)){
                    case 'view':
                        return new ViewFormat({
                            ...options,
                            name
                        });
                    case 'utf8':
                        return new UTF8Format({
                            ...options,
                            name
                        });
                    case 'buffer':
                        return new BufferFormat({
                            ...options,
                            name
                        });
                    default:
                        throw TypeError("Format must be one of 'buffer', 'view', 'utf8'");
                }
            }
            function detectFormat(options) {
                return 'format' in options && void 0 !== options.format ? options.format : 'buffer' in options && 'boolean' == typeof options.buffer ? options.buffer ? 'buffer' : 'utf8' : 'code' in options && Number.isInteger(options.code) ? 'view' : 'buffer';
            }
            exports.Transcoder = Transcoder;
            const aliases = {
                binary: encodings.buffer,
                'utf-8': encodings.utf8
            }, lookup = {
                ...encodings,
                ...aliases
            };
            let anonymousCount = 0;
        },
        8266: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const ModuleError = __webpack_require__(4473), formats = new Set([
                'buffer',
                'view',
                'utf8'
            ]);
            class Encoding {
                constructor(options){
                    if (this.encode = options.encode || this.encode, this.decode = options.decode || this.decode, this.name = options.name || this.name, this.format = options.format || this.format, 'function' != typeof this.encode) throw TypeError("The 'encode' property must be a function");
                    if ('function' != typeof this.decode) throw TypeError("The 'decode' property must be a function");
                    if (this.encode = this.encode.bind(this), this.decode = this.decode.bind(this), 'string' != typeof this.name || '' === this.name) throw TypeError("The 'name' property must be a string");
                    if ('string' != typeof this.format || !formats.has(this.format)) throw TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
                    options.createViewTranscoder && (this.createViewTranscoder = options.createViewTranscoder), options.createBufferTranscoder && (this.createBufferTranscoder = options.createBufferTranscoder), options.createUTF8Transcoder && (this.createUTF8Transcoder = options.createUTF8Transcoder);
                }
                get commonName() {
                    return this.name.split('+')[0];
                }
                createBufferTranscoder() {
                    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                }
                createViewTranscoder() {
                    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                }
                createUTF8Transcoder() {
                    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                }
            }
            exports.Encoding = Encoding;
        },
        8002: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { Buffer  } = __webpack_require__(8764) || {
                Buffer: {
                    isBuffer: ()=>!1
                }
            }, { textEncoder , textDecoder  } = __webpack_require__(5850)(), { BufferFormat , ViewFormat , UTF8Format  } = __webpack_require__(2376), identity = (v)=>v;
            exports.utf8 = new UTF8Format({
                encode: function(data) {
                    return Buffer.isBuffer(data) ? data.toString('utf8') : ArrayBuffer.isView(data) ? textDecoder.decode(data) : String(data);
                },
                decode: identity,
                name: 'utf8',
                createViewTranscoder () {
                    return new ViewFormat({
                        encode: function(data) {
                            return ArrayBuffer.isView(data) ? data : textEncoder.encode(data);
                        },
                        decode: function(data) {
                            return textDecoder.decode(data);
                        },
                        name: `${this.name}+view`
                    });
                },
                createBufferTranscoder () {
                    return new BufferFormat({
                        encode: function(data) {
                            return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), 'utf8');
                        },
                        decode: function(data) {
                            return data.toString('utf8');
                        },
                        name: `${this.name}+buffer`
                    });
                }
            }), exports.json = new UTF8Format({
                encode: JSON.stringify,
                decode: JSON.parse,
                name: 'json'
            }), exports.buffer = new BufferFormat({
                encode: function(data) {
                    return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), 'utf8');
                },
                decode: identity,
                name: 'buffer',
                createViewTranscoder () {
                    return new ViewFormat({
                        encode: function(data) {
                            return ArrayBuffer.isView(data) ? data : Buffer.from(String(data), 'utf8');
                        },
                        decode: function(data) {
                            return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                        },
                        name: `${this.name}+view`
                    });
                }
            }), exports.view = new ViewFormat({
                encode: function(data) {
                    return ArrayBuffer.isView(data) ? data : textEncoder.encode(data);
                },
                decode: identity,
                name: 'view',
                createBufferTranscoder () {
                    return new BufferFormat({
                        encode: function(data) {
                            return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), 'utf8');
                        },
                        decode: identity,
                        name: `${this.name}+buffer`
                    });
                }
            }), exports.hex = new BufferFormat({
                encode: function(data) {
                    return Buffer.isBuffer(data) ? data : Buffer.from(String(data), 'hex');
                },
                decode: function(buffer) {
                    return buffer.toString('hex');
                },
                name: 'hex'
            }), exports.base64 = new BufferFormat({
                encode: function(data) {
                    return Buffer.isBuffer(data) ? data : Buffer.from(String(data), 'base64');
                },
                decode: function(buffer) {
                    return buffer.toString('base64');
                },
                name: 'base64'
            });
        },
        2376: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            const { Buffer  } = __webpack_require__(8764) || {}, { Encoding  } = __webpack_require__(8266), textEndec = __webpack_require__(5850);
            class BufferFormat extends Encoding {
                constructor(options){
                    super({
                        ...options,
                        format: 'buffer'
                    });
                }
                createViewTranscoder() {
                    return new ViewFormat({
                        encode: this.encode,
                        decode: (data)=>this.decode(Buffer.from(data.buffer, data.byteOffset, data.byteLength)),
                        name: `${this.name}+view`
                    });
                }
                createBufferTranscoder() {
                    return this;
                }
            }
            class ViewFormat extends Encoding {
                constructor(options){
                    super({
                        ...options,
                        format: 'view'
                    });
                }
                createBufferTranscoder() {
                    return new BufferFormat({
                        encode: (data)=>{
                            const view = this.encode(data);
                            return Buffer.from(view.buffer, view.byteOffset, view.byteLength);
                        },
                        decode: this.decode,
                        name: `${this.name}+buffer`
                    });
                }
                createViewTranscoder() {
                    return this;
                }
            }
            class UTF8Format extends Encoding {
                constructor(options){
                    super({
                        ...options,
                        format: 'utf8'
                    });
                }
                createBufferTranscoder() {
                    return new BufferFormat({
                        encode: (data)=>Buffer.from(this.encode(data), 'utf8'),
                        decode: (data)=>this.decode(data.toString('utf8')),
                        name: `${this.name}+buffer`
                    });
                }
                createViewTranscoder() {
                    const { textEncoder , textDecoder  } = textEndec();
                    return new ViewFormat({
                        encode: (data)=>textEncoder.encode(this.encode(data)),
                        decode: (data)=>this.decode(textDecoder.decode(data)),
                        name: `${this.name}+view`
                    });
                }
                createUTF8Transcoder() {
                    return this;
                }
            }
            exports.BufferFormat = BufferFormat, exports.ViewFormat = ViewFormat, exports.UTF8Format = UTF8Format;
        },
        5850: function(module) {
            "use strict";
            let lazy = null;
            module.exports = function() {
                return null === lazy && (lazy = {
                    textEncoder: new TextEncoder(),
                    textDecoder: new TextDecoder()
                }), lazy;
            };
        },
        3145: function(__unused_webpack_module, exports, __webpack_require__) {
            exports.Level = __webpack_require__(1708).BrowserLevel;
        },
        8552: function(module, __unused_webpack_exports, __webpack_require__) {
            var getNative = __webpack_require__(852), root = __webpack_require__(5639), DataView1 = getNative(root, 'DataView');
            module.exports = DataView1;
        },
        1989: function(module, __unused_webpack_exports, __webpack_require__) {
            var hashClear = __webpack_require__(1789), hashDelete = __webpack_require__(401), hashGet = __webpack_require__(7667), hashHas = __webpack_require__(1327), hashSet = __webpack_require__(1866);
            function Hash(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for(this.clear(); ++index < length;){
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, module.exports = Hash;
        },
        8407: function(module, __unused_webpack_exports, __webpack_require__) {
            var listCacheClear = __webpack_require__(7040), listCacheDelete = __webpack_require__(4125), listCacheGet = __webpack_require__(2117), listCacheHas = __webpack_require__(7518), listCacheSet = __webpack_require__(4705);
            function ListCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for(this.clear(); ++index < length;){
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, module.exports = ListCache;
        },
        7071: function(module, __unused_webpack_exports, __webpack_require__) {
            var getNative = __webpack_require__(852), root = __webpack_require__(5639), Map1 = getNative(root, 'Map');
            module.exports = Map1;
        },
        3369: function(module, __unused_webpack_exports, __webpack_require__) {
            var mapCacheClear = __webpack_require__(4785), mapCacheDelete = __webpack_require__(1285), mapCacheGet = __webpack_require__(6000), mapCacheHas = __webpack_require__(9916), mapCacheSet = __webpack_require__(5265);
            function MapCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for(this.clear(); ++index < length;){
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, module.exports = MapCache;
        },
        3818: function(module, __unused_webpack_exports, __webpack_require__) {
            var getNative = __webpack_require__(852), root = __webpack_require__(5639), Promise1 = getNative(root, 'Promise');
            module.exports = Promise1;
        },
        8525: function(module, __unused_webpack_exports, __webpack_require__) {
            var getNative = __webpack_require__(852), root = __webpack_require__(5639), Set1 = getNative(root, 'Set');
            module.exports = Set1;
        },
        6384: function(module, __unused_webpack_exports, __webpack_require__) {
            var ListCache = __webpack_require__(8407), stackClear = __webpack_require__(7465), stackDelete = __webpack_require__(3779), stackGet = __webpack_require__(7599), stackHas = __webpack_require__(4758), stackSet = __webpack_require__(4309);
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }
            Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet, module.exports = Stack;
        },
        2705: function(module, __unused_webpack_exports, __webpack_require__) {
            var Symbol1 = __webpack_require__(5639).Symbol;
            module.exports = Symbol1;
        },
        1149: function(module, __unused_webpack_exports, __webpack_require__) {
            var Uint8Array1 = __webpack_require__(5639).Uint8Array;
            module.exports = Uint8Array1;
        },
        577: function(module, __unused_webpack_exports, __webpack_require__) {
            var getNative = __webpack_require__(852), root = __webpack_require__(5639), WeakMap1 = getNative(root, 'WeakMap');
            module.exports = WeakMap1;
        },
        7412: function(module) {
            function arrayEach(array, iteratee) {
                for(var index = -1, length = null == array ? 0 : array.length; ++index < length && !1 !== iteratee(array[index], index, array););
                return array;
            }
            module.exports = arrayEach;
        },
        4963: function(module) {
            function arrayFilter(array, predicate) {
                for(var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length;){
                    var value = array[index];
                    predicate(value, index, array) && (result[resIndex++] = value);
                }
                return result;
            }
            module.exports = arrayFilter;
        },
        4636: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseTimes = __webpack_require__(2545), isArguments = __webpack_require__(5694), isArray = __webpack_require__(1469), isBuffer = __webpack_require__(4144), isIndex = __webpack_require__(213), isTypedArray = __webpack_require__(6719), hasOwnProperty = Object.prototype.hasOwnProperty;
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for(var key in value)(inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ('length' == key || isBuff && ('offset' == key || 'parent' == key) || isType && ('buffer' == key || 'byteLength' == key || 'byteOffset' == key) || isIndex(key, length))) && result.push(key);
                return result;
            }
            module.exports = arrayLikeKeys;
        },
        2488: function(module) {
            function arrayPush(array, values) {
                for(var index = -1, length = values.length, offset = array.length; ++index < length;)array[offset + index] = values[index];
                return array;
            }
            module.exports = arrayPush;
        },
        4865: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseAssignValue = __webpack_require__(9465), eq = __webpack_require__(7813), hasOwnProperty = Object.prototype.hasOwnProperty;
            function assignValue(object, key, value) {
                var objValue = object[key];
                hasOwnProperty.call(object, key) && eq(objValue, value) && (void 0 !== value || key in object) || baseAssignValue(object, key, value);
            }
            module.exports = assignValue;
        },
        8470: function(module, __unused_webpack_exports, __webpack_require__) {
            var eq = __webpack_require__(7813);
            function assocIndexOf(array, key) {
                for(var length = array.length; length--;)if (eq(array[length][0], key)) return length;
                return -1;
            }
            module.exports = assocIndexOf;
        },
        4037: function(module, __unused_webpack_exports, __webpack_require__) {
            var copyObject = __webpack_require__(8363), keys = __webpack_require__(3674);
            function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
            }
            module.exports = baseAssign;
        },
        3886: function(module, __unused_webpack_exports, __webpack_require__) {
            var copyObject = __webpack_require__(8363), keysIn = __webpack_require__(1704);
            function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object);
            }
            module.exports = baseAssignIn;
        },
        9465: function(module, __unused_webpack_exports, __webpack_require__) {
            var defineProperty = __webpack_require__(8777);
            function baseAssignValue(object, key, value) {
                '__proto__' == key && defineProperty ? defineProperty(object, key, {
                    configurable: !0,
                    enumerable: !0,
                    value: value,
                    writable: !0
                }) : object[key] = value;
            }
            module.exports = baseAssignValue;
        },
        5990: function(module, __unused_webpack_exports, __webpack_require__) {
            var Stack = __webpack_require__(6384), arrayEach = __webpack_require__(7412), assignValue = __webpack_require__(4865), baseAssign = __webpack_require__(4037), baseAssignIn = __webpack_require__(3886), cloneBuffer = __webpack_require__(4626), copyArray = __webpack_require__(278), copySymbols = __webpack_require__(8805), copySymbolsIn = __webpack_require__(1911), getAllKeys = __webpack_require__(8234), getAllKeysIn = __webpack_require__(6904), getTag = __webpack_require__(4160), initCloneArray = __webpack_require__(3824), initCloneByTag = __webpack_require__(9148), initCloneObject = __webpack_require__(8517), isArray = __webpack_require__(1469), isBuffer = __webpack_require__(4144), isMap = __webpack_require__(6688), isObject = __webpack_require__(3218), isSet = __webpack_require__(2928), keys = __webpack_require__(3674), keysIn = __webpack_require__(1704), CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]', arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]', cloneableTags = {};
            function baseClone(value, bitmask, customizer, key, object, stack) {
                var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), void 0 !== result) return result;
                if (!isObject(value)) return value;
                var isArr = isArray(value);
                if (isArr) {
                    if (result = initCloneArray(value), !isDeep) return copyArray(value, result);
                } else {
                    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                    if (isBuffer(value)) return cloneBuffer(value, isDeep);
                    if (tag == objectTag || tag == argsTag || isFunc && !object) {
                        if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                    } else {
                        if (!cloneableTags[tag]) return object ? value : {};
                        result = initCloneByTag(value, tag, isDeep);
                    }
                }
                stack || (stack = new Stack);
                var stacked = stack.get(value);
                if (stacked) return stacked;
                stack.set(value, result), isSet(value) ? value.forEach(function(subValue) {
                    result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                }) : isMap(value) && value.forEach(function(subValue, key) {
                    result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                });
                var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? void 0 : keysFunc(value);
                return arrayEach(props || value, function(subValue, key) {
                    props && (subValue = value[key = subValue]), assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                }), result;
            }
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1, module.exports = baseClone;
        },
        3118: function(module, __unused_webpack_exports, __webpack_require__) {
            var isObject = __webpack_require__(3218), objectCreate = Object.create, baseCreate = function() {
                function object() {}
                return function(proto) {
                    if (!isObject(proto)) return {};
                    if (objectCreate) return objectCreate(proto);
                    object.prototype = proto;
                    var result = new object;
                    return object.prototype = void 0, result;
                };
            }();
            module.exports = baseCreate;
        },
        8866: function(module, __unused_webpack_exports, __webpack_require__) {
            var arrayPush = __webpack_require__(2488), isArray = __webpack_require__(1469);
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
            }
            module.exports = baseGetAllKeys;
        },
        4239: function(module, __unused_webpack_exports, __webpack_require__) {
            var Symbol1 = __webpack_require__(2705), getRawTag = __webpack_require__(9607), objectToString = __webpack_require__(2333), nullTag = '[object Null]', undefinedTag = '[object Undefined]', symToStringTag = Symbol1 ? Symbol1.toStringTag : void 0;
            function baseGetTag(value) {
                return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
            }
            module.exports = baseGetTag;
        },
        9454: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseGetTag = __webpack_require__(4239), isObjectLike = __webpack_require__(7005), argsTag = '[object Arguments]';
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            module.exports = baseIsArguments;
        },
        5588: function(module, __unused_webpack_exports, __webpack_require__) {
            var getTag = __webpack_require__(4160), isObjectLike = __webpack_require__(7005), mapTag = '[object Map]';
            function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
            }
            module.exports = baseIsMap;
        },
        8458: function(module, __unused_webpack_exports, __webpack_require__) {
            var isFunction = __webpack_require__(3560), isMasked = __webpack_require__(5346), isObject = __webpack_require__(3218), toSource = __webpack_require__(346), reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
            function baseIsNative(value) {
                return !(!isObject(value) || isMasked(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
            }
            module.exports = baseIsNative;
        },
        9221: function(module, __unused_webpack_exports, __webpack_require__) {
            var getTag = __webpack_require__(4160), isObjectLike = __webpack_require__(7005), setTag = '[object Set]';
            function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
            }
            module.exports = baseIsSet;
        },
        8749: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseGetTag = __webpack_require__(4239), isLength = __webpack_require__(1780), isObjectLike = __webpack_require__(7005), argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]', arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]', typedArrayTags = {};
            function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            }
            typedArrayTags['[object Float32Array]'] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1, module.exports = baseIsTypedArray;
        },
        280: function(module, __unused_webpack_exports, __webpack_require__) {
            var isPrototype = __webpack_require__(5726), nativeKeys = __webpack_require__(6916), hasOwnProperty = Object.prototype.hasOwnProperty;
            function baseKeys(object) {
                if (!isPrototype(object)) return nativeKeys(object);
                var result = [];
                for(var key in Object(object))hasOwnProperty.call(object, key) && 'constructor' != key && result.push(key);
                return result;
            }
            module.exports = baseKeys;
        },
        313: function(module, __unused_webpack_exports, __webpack_require__) {
            var isObject = __webpack_require__(3218), isPrototype = __webpack_require__(5726), nativeKeysIn = __webpack_require__(3498), hasOwnProperty = Object.prototype.hasOwnProperty;
            function baseKeysIn(object) {
                if (!isObject(object)) return nativeKeysIn(object);
                var isProto = isPrototype(object), result = [];
                for(var key in object)'constructor' == key && (isProto || !hasOwnProperty.call(object, key)) || result.push(key);
                return result;
            }
            module.exports = baseKeysIn;
        },
        2545: function(module) {
            function baseTimes(n, iteratee) {
                for(var index = -1, result = Array(n); ++index < n;)result[index] = iteratee(index);
                return result;
            }
            module.exports = baseTimes;
        },
        1717: function(module) {
            function baseUnary(func) {
                return function(value) {
                    return func(value);
                };
            }
            module.exports = baseUnary;
        },
        4318: function(module, __unused_webpack_exports, __webpack_require__) {
            var Uint8Array1 = __webpack_require__(1149);
            function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                return new Uint8Array1(result).set(new Uint8Array1(arrayBuffer)), result;
            }
            module.exports = cloneArrayBuffer;
        },
        4626: function(module, exports, __webpack_require__) {
            module = __webpack_require__.nmd(module);
            var root = __webpack_require__(5639), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && module && !module.nodeType && module, Buffer = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
            function cloneBuffer(buffer, isDeep) {
                if (isDeep) return buffer.slice();
                var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                return buffer.copy(result), result;
            }
            module.exports = cloneBuffer;
        },
        7157: function(module, __unused_webpack_exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__(4318);
            function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
            }
            module.exports = cloneDataView;
        },
        3147: function(module) {
            var reFlags = /\w*$/;
            function cloneRegExp(regexp) {
                var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                return result.lastIndex = regexp.lastIndex, result;
            }
            module.exports = cloneRegExp;
        },
        419: function(module, __unused_webpack_exports, __webpack_require__) {
            var Symbol1 = __webpack_require__(2705), symbolProto = Symbol1 ? Symbol1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
            function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
            }
            module.exports = cloneSymbol;
        },
        7133: function(module, __unused_webpack_exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__(4318);
            function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
            }
            module.exports = cloneTypedArray;
        },
        278: function(module) {
            function copyArray(source, array) {
                var index = -1, length = source.length;
                for(array || (array = Array(length)); ++index < length;)array[index] = source[index];
                return array;
            }
            module.exports = copyArray;
        },
        8363: function(module, __unused_webpack_exports, __webpack_require__) {
            var assignValue = __webpack_require__(4865), baseAssignValue = __webpack_require__(9465);
            function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                for(var index = -1, length = props.length; ++index < length;){
                    var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                    void 0 === newValue && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
                }
                return object;
            }
            module.exports = copyObject;
        },
        8805: function(module, __unused_webpack_exports, __webpack_require__) {
            var copyObject = __webpack_require__(8363), getSymbols = __webpack_require__(9551);
            function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
            }
            module.exports = copySymbols;
        },
        1911: function(module, __unused_webpack_exports, __webpack_require__) {
            var copyObject = __webpack_require__(8363), getSymbolsIn = __webpack_require__(1442);
            function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object);
            }
            module.exports = copySymbolsIn;
        },
        4429: function(module, __unused_webpack_exports, __webpack_require__) {
            var coreJsData = __webpack_require__(5639)['__core-js_shared__'];
            module.exports = coreJsData;
        },
        8777: function(module, __unused_webpack_exports, __webpack_require__) {
            var getNative = __webpack_require__(852), defineProperty = function() {
                try {
                    var func = getNative(Object, 'defineProperty');
                    return func({}, '', {}), func;
                } catch (e) {}
            }();
            module.exports = defineProperty;
        },
        1957: function(module, __unused_webpack_exports, __webpack_require__) {
            var freeGlobal = 'object' == typeof __webpack_require__.g && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
            module.exports = freeGlobal;
        },
        8234: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseGetAllKeys = __webpack_require__(8866), getSymbols = __webpack_require__(9551), keys = __webpack_require__(3674);
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
            }
            module.exports = getAllKeys;
        },
        6904: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseGetAllKeys = __webpack_require__(8866), getSymbolsIn = __webpack_require__(1442), keysIn = __webpack_require__(1704);
            function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
            }
            module.exports = getAllKeysIn;
        },
        5050: function(module, __unused_webpack_exports, __webpack_require__) {
            var isKeyable = __webpack_require__(7019);
            function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data['string' == typeof key ? 'string' : 'hash'] : data.map;
            }
            module.exports = getMapData;
        },
        852: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseIsNative = __webpack_require__(8458), getValue = __webpack_require__(7801);
            function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
            }
            module.exports = getNative;
        },
        5924: function(module, __unused_webpack_exports, __webpack_require__) {
            var getPrototype = __webpack_require__(5569)(Object.getPrototypeOf, Object);
            module.exports = getPrototype;
        },
        9607: function(module, __unused_webpack_exports, __webpack_require__) {
            var Symbol1 = __webpack_require__(2705), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol1 ? Symbol1.toStringTag : void 0;
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                    value[symToStringTag] = void 0;
                    var unmasked = !0;
                } catch (e) {}
                var result = nativeObjectToString.call(value);
                return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
            }
            module.exports = getRawTag;
        },
        9551: function(module, __unused_webpack_exports, __webpack_require__) {
            var arrayFilter = __webpack_require__(4963), stubArray = __webpack_require__(479), propertyIsEnumerable = Object.prototype.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(object) {
                return null == object ? [] : arrayFilter(nativeGetSymbols(object = Object(object)), function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                });
            } : stubArray;
            module.exports = getSymbols;
        },
        1442: function(module, __unused_webpack_exports, __webpack_require__) {
            var arrayPush = __webpack_require__(2488), getPrototype = __webpack_require__(5924), getSymbols = __webpack_require__(9551), stubArray = __webpack_require__(479), getSymbolsIn = Object.getOwnPropertySymbols ? function(object) {
                for(var result = []; object;)arrayPush(result, getSymbols(object)), object = getPrototype(object);
                return result;
            } : stubArray;
            module.exports = getSymbolsIn;
        },
        4160: function(module, __unused_webpack_exports, __webpack_require__) {
            var DataView1 = __webpack_require__(8552), Map1 = __webpack_require__(7071), Promise1 = __webpack_require__(3818), Set1 = __webpack_require__(8525), WeakMap1 = __webpack_require__(577), baseGetTag = __webpack_require__(4239), toSource = __webpack_require__(346), mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]', dataViewTag = '[object DataView]', dataViewCtorString = toSource(DataView1), mapCtorString = toSource(Map1), promiseCtorString = toSource(Promise1), setCtorString = toSource(Set1), weakMapCtorString = toSource(WeakMap1), getTag = baseGetTag;
            (DataView1 && getTag(new DataView1(new ArrayBuffer(1))) != dataViewTag || Map1 && getTag(new Map1) != mapTag || Promise1 && getTag(Promise1.resolve()) != promiseTag || Set1 && getTag(new Set1) != setTag || WeakMap1 && getTag(new WeakMap1) != weakMapTag) && (getTag = function(value) {
                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : '';
                if (ctorString) switch(ctorString){
                    case dataViewCtorString:
                        return dataViewTag;
                    case mapCtorString:
                        return mapTag;
                    case promiseCtorString:
                        return promiseTag;
                    case setCtorString:
                        return setTag;
                    case weakMapCtorString:
                        return weakMapTag;
                }
                return result;
            }), module.exports = getTag;
        },
        7801: function(module) {
            function getValue(object, key) {
                return null == object ? void 0 : object[key];
            }
            module.exports = getValue;
        },
        1789: function(module, __unused_webpack_exports, __webpack_require__) {
            var nativeCreate = __webpack_require__(4536);
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
            }
            module.exports = hashClear;
        },
        401: function(module) {
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                return this.size -= result ? 1 : 0, result;
            }
            module.exports = hashDelete;
        },
        7667: function(module, __unused_webpack_exports, __webpack_require__) {
            var nativeCreate = __webpack_require__(4536), HASH_UNDEFINED = '__lodash_hash_undefined__', hasOwnProperty = Object.prototype.hasOwnProperty;
            function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }
            module.exports = hashGet;
        },
        1327: function(module, __unused_webpack_exports, __webpack_require__) {
            var nativeCreate = __webpack_require__(4536), hasOwnProperty = Object.prototype.hasOwnProperty;
            function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
            }
            module.exports = hashHas;
        },
        1866: function(module, __unused_webpack_exports, __webpack_require__) {
            var nativeCreate = __webpack_require__(4536), HASH_UNDEFINED = '__lodash_hash_undefined__';
            function hashSet(key, value) {
                var data = this.__data__;
                return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? HASH_UNDEFINED : value, this;
            }
            module.exports = hashSet;
        },
        3824: function(module) {
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            function initCloneArray(array) {
                var length = array.length, result = new array.constructor(length);
                return length && 'string' == typeof array[0] && hasOwnProperty.call(array, 'index') && (result.index = array.index, result.input = array.input), result;
            }
            module.exports = initCloneArray;
        },
        9148: function(module, __unused_webpack_exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__(4318), cloneDataView = __webpack_require__(7157), cloneRegExp = __webpack_require__(3147), cloneSymbol = __webpack_require__(419), cloneTypedArray = __webpack_require__(7133), boolTag = '[object Boolean]', dateTag = '[object Date]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
            function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch(tag){
                    case arrayBufferTag:
                        return cloneArrayBuffer(object);
                    case boolTag:
                    case dateTag:
                        return new Ctor(+object);
                    case dataViewTag:
                        return cloneDataView(object, isDeep);
                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                        return cloneTypedArray(object, isDeep);
                    case mapTag:
                        return new Ctor;
                    case numberTag:
                    case stringTag:
                        return new Ctor(object);
                    case regexpTag:
                        return cloneRegExp(object);
                    case setTag:
                        return new Ctor;
                    case symbolTag:
                        return cloneSymbol(object);
                }
            }
            module.exports = initCloneByTag;
        },
        8517: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseCreate = __webpack_require__(3118), getPrototype = __webpack_require__(5924), isPrototype = __webpack_require__(5726);
            function initCloneObject(object) {
                return 'function' != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
            }
            module.exports = initCloneObject;
        },
        213: function(module) {
            var MAX_SAFE_INTEGER = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
            function isIndex(value, length) {
                var type = typeof value;
                return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ('number' == type || 'symbol' != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            module.exports = isIndex;
        },
        7019: function(module) {
            function isKeyable(value) {
                var type = typeof value;
                return 'string' == type || 'number' == type || 'symbol' == type || 'boolean' == type ? '__proto__' !== value : null === value;
            }
            module.exports = isKeyable;
        },
        5346: function(module, __unused_webpack_exports, __webpack_require__) {
            var uid, coreJsData = __webpack_require__(4429), maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '')) ? 'Symbol(src)_1.' + uid : '';
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
            }
            module.exports = isMasked;
        },
        5726: function(module) {
            var objectProto = Object.prototype;
            function isPrototype(value) {
                var Ctor = value && value.constructor;
                return value === ('function' == typeof Ctor && Ctor.prototype || objectProto);
            }
            module.exports = isPrototype;
        },
        7040: function(module) {
            function listCacheClear() {
                this.__data__ = [], this.size = 0;
            }
            module.exports = listCacheClear;
        },
        4125: function(module, __unused_webpack_exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__(8470), splice = Array.prototype.splice;
            function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), --this.size, !0);
            }
            module.exports = listCacheDelete;
        },
        2117: function(module, __unused_webpack_exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__(8470);
            function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
            }
            module.exports = listCacheGet;
        },
        7518: function(module, __unused_webpack_exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__(8470);
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }
            module.exports = listCacheHas;
        },
        4705: function(module, __unused_webpack_exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__(8470);
            function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? (++this.size, data.push([
                    key,
                    value
                ])) : data[index][1] = value, this;
            }
            module.exports = listCacheSet;
        },
        4785: function(module, __unused_webpack_exports, __webpack_require__) {
            var Hash = __webpack_require__(1989), ListCache = __webpack_require__(8407), Map1 = __webpack_require__(7071);
            function mapCacheClear() {
                this.size = 0, this.__data__ = {
                    hash: new Hash,
                    map: new (Map1 || ListCache),
                    string: new Hash
                };
            }
            module.exports = mapCacheClear;
        },
        1285: function(module, __unused_webpack_exports, __webpack_require__) {
            var getMapData = __webpack_require__(5050);
            function mapCacheDelete(key) {
                var result = getMapData(this, key).delete(key);
                return this.size -= result ? 1 : 0, result;
            }
            module.exports = mapCacheDelete;
        },
        6000: function(module, __unused_webpack_exports, __webpack_require__) {
            var getMapData = __webpack_require__(5050);
            function mapCacheGet(key) {
                return getMapData(this, key).get(key);
            }
            module.exports = mapCacheGet;
        },
        9916: function(module, __unused_webpack_exports, __webpack_require__) {
            var getMapData = __webpack_require__(5050);
            function mapCacheHas(key) {
                return getMapData(this, key).has(key);
            }
            module.exports = mapCacheHas;
        },
        5265: function(module, __unused_webpack_exports, __webpack_require__) {
            var getMapData = __webpack_require__(5050);
            function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
            }
            module.exports = mapCacheSet;
        },
        4536: function(module, __unused_webpack_exports, __webpack_require__) {
            var nativeCreate = __webpack_require__(852)(Object, 'create');
            module.exports = nativeCreate;
        },
        6916: function(module, __unused_webpack_exports, __webpack_require__) {
            var nativeKeys = __webpack_require__(5569)(Object.keys, Object);
            module.exports = nativeKeys;
        },
        3498: function(module) {
            function nativeKeysIn(object) {
                var result = [];
                if (null != object) for(var key in Object(object))result.push(key);
                return result;
            }
            module.exports = nativeKeysIn;
        },
        1167: function(module, exports, __webpack_require__) {
            module = __webpack_require__.nmd(module);
            var freeGlobal = __webpack_require__(1957), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && module && !module.nodeType && module, freeProcess = freeModule && freeModule.exports === freeExports && freeGlobal.process, nodeUtil = function() {
                try {
                    var types = freeModule && freeModule.require && freeModule.require('util').types;
                    if (types) return types;
                    return freeProcess && freeProcess.binding && freeProcess.binding('util');
                } catch (e) {}
            }();
            module.exports = nodeUtil;
        },
        2333: function(module) {
            var nativeObjectToString = Object.prototype.toString;
            function objectToString(value) {
                return nativeObjectToString.call(value);
            }
            module.exports = objectToString;
        },
        5569: function(module) {
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }
            module.exports = overArg;
        },
        5639: function(module, __unused_webpack_exports, __webpack_require__) {
            var freeGlobal = __webpack_require__(1957), freeSelf = 'object' == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function('return this')();
            module.exports = root;
        },
        7465: function(module, __unused_webpack_exports, __webpack_require__) {
            var ListCache = __webpack_require__(8407);
            function stackClear() {
                this.__data__ = new ListCache, this.size = 0;
            }
            module.exports = stackClear;
        },
        3779: function(module) {
            function stackDelete(key) {
                var data = this.__data__, result = data.delete(key);
                return this.size = data.size, result;
            }
            module.exports = stackDelete;
        },
        7599: function(module) {
            function stackGet(key) {
                return this.__data__.get(key);
            }
            module.exports = stackGet;
        },
        4758: function(module) {
            function stackHas(key) {
                return this.__data__.has(key);
            }
            module.exports = stackHas;
        },
        4309: function(module, __unused_webpack_exports, __webpack_require__) {
            var ListCache = __webpack_require__(8407), Map1 = __webpack_require__(7071), MapCache = __webpack_require__(3369), LARGE_ARRAY_SIZE = 200;
            function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map1 || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([
                        key,
                        value
                    ]), this.size = ++data.size, this;
                    data = this.__data__ = new MapCache(pairs);
                }
                return data.set(key, value), this.size = data.size, this;
            }
            module.exports = stackSet;
        },
        346: function(module) {
            var funcToString = Function.prototype.toString;
            function toSource(func) {
                if (null != func) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {}
                    try {
                        return func + '';
                    } catch (e1) {}
                }
                return '';
            }
            module.exports = toSource;
        },
        361: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseClone = __webpack_require__(5990), CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
            function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
            }
            module.exports = cloneDeep;
        },
        7813: function(module) {
            function eq(value, other) {
                return value === other || value != value && other != other;
            }
            module.exports = eq;
        },
        5694: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseIsArguments = __webpack_require__(9454), isObjectLike = __webpack_require__(7005), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, propertyIsEnumerable = objectProto.propertyIsEnumerable, isArguments = baseIsArguments(function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
            };
            module.exports = isArguments;
        },
        1469: function(module) {
            var isArray = Array.isArray;
            module.exports = isArray;
        },
        1240: function(module, __unused_webpack_exports, __webpack_require__) {
            var isFunction = __webpack_require__(3560), isLength = __webpack_require__(1780);
            function isArrayLike(value) {
                return null != value && isLength(value.length) && !isFunction(value);
            }
            module.exports = isArrayLike;
        },
        4144: function(module, exports, __webpack_require__) {
            module = __webpack_require__.nmd(module);
            var root = __webpack_require__(5639), stubFalse = __webpack_require__(5062), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && module && !module.nodeType && module, Buffer = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0, isBuffer = (Buffer ? Buffer.isBuffer : void 0) || stubFalse;
            module.exports = isBuffer;
        },
        3560: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseGetTag = __webpack_require__(4239), isObject = __webpack_require__(3218), asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
            function isFunction(value) {
                if (!isObject(value)) return !1;
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            module.exports = isFunction;
        },
        1780: function(module) {
            var MAX_SAFE_INTEGER = 9007199254740991;
            function isLength(value) {
                return 'number' == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            module.exports = isLength;
        },
        6688: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseIsMap = __webpack_require__(5588), baseUnary = __webpack_require__(1717), nodeUtil = __webpack_require__(1167), nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
            module.exports = isMap;
        },
        3218: function(module) {
            function isObject(value) {
                var type = typeof value;
                return null != value && ('object' == type || 'function' == type);
            }
            module.exports = isObject;
        },
        7005: function(module) {
            function isObjectLike(value) {
                return null != value && 'object' == typeof value;
            }
            module.exports = isObjectLike;
        },
        2928: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseIsSet = __webpack_require__(9221), baseUnary = __webpack_require__(1717), nodeUtil = __webpack_require__(1167), nodeIsSet = nodeUtil && nodeUtil.isSet, isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
            module.exports = isSet;
        },
        6719: function(module, __unused_webpack_exports, __webpack_require__) {
            var baseIsTypedArray = __webpack_require__(8749), baseUnary = __webpack_require__(1717), nodeUtil = __webpack_require__(1167), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
            module.exports = isTypedArray;
        },
        3674: function(module, __unused_webpack_exports, __webpack_require__) {
            var arrayLikeKeys = __webpack_require__(4636), baseKeys = __webpack_require__(280), isArrayLike = __webpack_require__(1240);
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            module.exports = keys;
        },
        1704: function(module, __unused_webpack_exports, __webpack_require__) {
            var arrayLikeKeys = __webpack_require__(4636), baseKeysIn = __webpack_require__(313), isArrayLike = __webpack_require__(1240);
            function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
            }
            module.exports = keysIn;
        },
        479: function(module) {
            function stubArray() {
                return [];
            }
            module.exports = stubArray;
        },
        5062: function(module) {
            function stubFalse() {
                return !1;
            }
            module.exports = stubFalse;
        },
        1271: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            __webpack_require__(3454);
            const { AbstractLevel , AbstractIterator , AbstractKeyIterator , AbstractValueIterator  } = __webpack_require__(875), ModuleError = __webpack_require__(4473), createRBT = __webpack_require__(4977), rangeOptions = new Set([
                'gt',
                'gte',
                'lt',
                'lte'
            ]), kNone = Symbol('none'), kTree = Symbol('tree'), kIterator = Symbol('iterator'), kLowerBound = Symbol('lowerBound'), kUpperBound = Symbol('upperBound'), kOutOfRange = Symbol('outOfRange'), kReverse = Symbol('reverse'), kOptions = Symbol('options'), kTest = Symbol('test'), kAdvance = Symbol('advance'), kInit = Symbol('init');
            function compare(a, b) {
                if ('string' == typeof a) return a < b ? -1 : a > b ? 1 : 0;
                const length = Math.min(a.byteLength, b.byteLength);
                for(let i = 0; i < length; i++){
                    const cmp = a[i] - b[i];
                    if (0 !== cmp) return cmp;
                }
                return a.byteLength - b.byteLength;
            }
            function gt(value) {
                return compare(value, this[kUpperBound]) > 0;
            }
            function gte(value) {
                return compare(value, this[kUpperBound]) >= 0;
            }
            function lt(value) {
                return 0 > compare(value, this[kUpperBound]);
            }
            function lte(value) {
                return 0 >= compare(value, this[kUpperBound]);
            }
            class MemoryIterator extends AbstractIterator {
                constructor(db, options){
                    super(db, options), this[kInit](db[kTree], options);
                }
                _next(callback) {
                    if (!this[kIterator].valid) return this.nextTick(callback);
                    const key = this[kIterator].key, value = this[kIterator].value;
                    if (!this[kTest](key)) return this.nextTick(callback);
                    this[kIterator][this[kAdvance]](), this.nextTick(callback, null, key, value);
                }
                _nextv(size, options, callback) {
                    const it = this[kIterator], entries = [];
                    for(; it.valid && entries.length < size && this[kTest](it.key);)entries.push([
                        it.key,
                        it.value
                    ]), it[this[kAdvance]]();
                    this.nextTick(callback, null, entries);
                }
                _all(options, callback) {
                    const size = this.limit - this.count, it = this[kIterator], entries = [];
                    for(; it.valid && entries.length < size && this[kTest](it.key);)entries.push([
                        it.key,
                        it.value
                    ]), it[this[kAdvance]]();
                    this.nextTick(callback, null, entries);
                }
            }
            class MemoryKeyIterator extends AbstractKeyIterator {
                constructor(db, options){
                    super(db, options), this[kInit](db[kTree], options);
                }
                _next(callback) {
                    if (!this[kIterator].valid) return this.nextTick(callback);
                    const key = this[kIterator].key;
                    if (!this[kTest](key)) return this.nextTick(callback);
                    this[kIterator][this[kAdvance]](), this.nextTick(callback, null, key);
                }
                _nextv(size, options, callback) {
                    const it = this[kIterator], keys = [];
                    for(; it.valid && keys.length < size && this[kTest](it.key);)keys.push(it.key), it[this[kAdvance]]();
                    this.nextTick(callback, null, keys);
                }
                _all(options, callback) {
                    const size = this.limit - this.count, it = this[kIterator], keys = [];
                    for(; it.valid && keys.length < size && this[kTest](it.key);)keys.push(it.key), it[this[kAdvance]]();
                    this.nextTick(callback, null, keys);
                }
            }
            class MemoryValueIterator extends AbstractValueIterator {
                constructor(db, options){
                    super(db, options), this[kInit](db[kTree], options);
                }
                _next(callback) {
                    if (!this[kIterator].valid) return this.nextTick(callback);
                    const key = this[kIterator].key, value = this[kIterator].value;
                    if (!this[kTest](key)) return this.nextTick(callback);
                    this[kIterator][this[kAdvance]](), this.nextTick(callback, null, value);
                }
                _nextv(size, options, callback) {
                    const it = this[kIterator], values = [];
                    for(; it.valid && values.length < size && this[kTest](it.key);)values.push(it.value), it[this[kAdvance]]();
                    this.nextTick(callback, null, values);
                }
                _all(options, callback) {
                    const size = this.limit - this.count, it = this[kIterator], values = [];
                    for(; it.valid && values.length < size && this[kTest](it.key);)values.push(it.value), it[this[kAdvance]]();
                    this.nextTick(callback, null, values);
                }
            }
            for (const Ctor of [
                MemoryIterator,
                MemoryKeyIterator,
                MemoryValueIterator
            ])Ctor.prototype[kInit] = function(tree, options) {
                this[kReverse] = options.reverse, this[kOptions] = options, this[kReverse] ? (this[kAdvance] = 'prev', this[kLowerBound] = 'lte' in options ? options.lte : 'lt' in options ? options.lt : kNone, this[kUpperBound] = 'gte' in options ? options.gte : 'gt' in options ? options.gt : kNone, this[kLowerBound] === kNone ? this[kIterator] = tree.end : 'lte' in options ? this[kIterator] = tree.le(this[kLowerBound]) : this[kIterator] = tree.lt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = 'gte' in options ? gte : gt)) : (this[kAdvance] = 'next', this[kLowerBound] = 'gte' in options ? options.gte : 'gt' in options ? options.gt : kNone, this[kUpperBound] = 'lte' in options ? options.lte : 'lt' in options ? options.lt : kNone, this[kLowerBound] === kNone ? this[kIterator] = tree.begin : 'gte' in options ? this[kIterator] = tree.ge(this[kLowerBound]) : this[kIterator] = tree.gt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = 'lte' in options ? lte : lt));
            }, Ctor.prototype[kTest] = function() {
                return !0;
            }, Ctor.prototype[kOutOfRange] = function(target) {
                return !this[kTest](target) || this[kLowerBound] !== kNone && (this[kReverse] ? 'lte' in this[kOptions] ? compare(target, this[kLowerBound]) > 0 : compare(target, this[kLowerBound]) >= 0 : 'gte' in this[kOptions] ? 0 > compare(target, this[kLowerBound]) : 0 >= compare(target, this[kLowerBound]));
            }, Ctor.prototype._seek = function(target, options) {
                this[kOutOfRange](target) ? (this[kIterator] = this[kIterator].tree.end, this[kIterator].next()) : this[kReverse] ? this[kIterator] = this[kIterator].tree.le(target) : this[kIterator] = this[kIterator].tree.ge(target);
            };
            class MemoryLevel extends AbstractLevel {
                constructor(location, options, _){
                    if ('object' == typeof location && null !== location && (options = location), 'function' == typeof location || 'function' == typeof options || 'function' == typeof _) throw new ModuleError('The levelup-style callback argument has been removed', {
                        code: 'LEVEL_LEGACY'
                    });
                    let { storeEncoding , ...forward } = options || {};
                    if (![
                        'buffer',
                        'view',
                        'utf8'
                    ].includes(storeEncoding = storeEncoding || 'buffer')) throw new ModuleError("The storeEncoding option must be 'buffer', 'view' or 'utf8'", {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                    super({
                        seek: !0,
                        permanence: !1,
                        createIfMissing: !1,
                        errorIfExists: !1,
                        encodings: {
                            [storeEncoding]: !0
                        }
                    }, forward), this[kTree] = createRBT(compare);
                }
                _put(key, value, options, callback) {
                    const it = this[kTree].find(key);
                    it.valid ? this[kTree] = it.update(value) : this[kTree] = this[kTree].insert(key, value), this.nextTick(callback);
                }
                _get(key, options, callback) {
                    const value = this[kTree].get(key);
                    if (void 0 === value) return this.nextTick(callback, Error('NotFound'));
                    this.nextTick(callback, null, value);
                }
                _getMany(keys, options, callback) {
                    this.nextTick(callback, null, keys.map((key)=>this[kTree].get(key)));
                }
                _del(key, options, callback) {
                    this[kTree] = this[kTree].remove(key), this.nextTick(callback);
                }
                _batch(operations, options, callback) {
                    let tree = this[kTree];
                    for (const op of operations){
                        const key = op.key, it = tree.find(key);
                        tree = 'put' === op.type ? it.valid ? it.update(op.value) : tree.insert(key, op.value) : it.remove();
                    }
                    this[kTree] = tree, this.nextTick(callback);
                }
                _clear(options, callback) {
                    if (-1 === options.limit && !Object.keys(options).some(isRangeOption)) return this[kTree] = createRBT(compare), this.nextTick(callback);
                    const iterator = this._keys({
                        ...options
                    }), limit = iterator.limit;
                    let count = 0;
                    const loop = ()=>{
                        for(let i = 0; i < 500; i++){
                            if (++count > limit || !iterator[kIterator].valid || !iterator[kTest](iterator[kIterator].key)) return callback();
                            this[kTree] = this[kTree].remove(iterator[kIterator].key), iterator[kIterator][iterator[kAdvance]]();
                        }
                        this.nextTick(loop);
                    };
                    this.nextTick(loop);
                }
                _iterator(options) {
                    return new MemoryIterator(this, options);
                }
                _keys(options) {
                    return new MemoryKeyIterator(this, options);
                }
                _values(options) {
                    return new MemoryValueIterator(this, options);
                }
            }
            function isRangeOption(k) {
                return rangeOptions.has(k);
            }
            exports.MemoryLevel = MemoryLevel;
        },
        9746: function(module) {
            function assert(val, msg) {
                if (!val) throw Error(msg || 'Assertion failed');
            }
            module.exports = assert, assert.equal = function(l, r, msg) {
                if (l != r) throw Error(msg || 'Assertion failed: ' + l + ' != ' + r);
            };
        },
        4504: function(__unused_webpack_module, exports) {
            "use strict";
            var utils = exports;
            function toArray(msg, enc) {
                if (Array.isArray(msg)) return msg.slice();
                if (!msg) return [];
                var res = [];
                if ('string' != typeof msg) {
                    for(var i = 0; i < msg.length; i++)res[i] = 0 | msg[i];
                    return res;
                }
                if ('hex' === enc) {
                    (msg = msg.replace(/[^a-z0-9]+/ig, '')).length % 2 != 0 && (msg = '0' + msg);
                    for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
                } else for(var i = 0; i < msg.length; i++){
                    var c = msg.charCodeAt(i), hi = c >> 8, lo = 0xff & c;
                    hi ? res.push(hi, lo) : res.push(lo);
                }
                return res;
            }
            function zero2(word) {
                return 1 === word.length ? '0' + word : word;
            }
            function toHex(msg) {
                for(var res = '', i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
                return res;
            }
            utils.toArray = toArray, utils.zero2 = zero2, utils.toHex = toHex, utils.encode = function(arr, enc) {
                return 'hex' === enc ? toHex(arr) : arr;
            };
        },
        4473: function(module) {
            "use strict";
            module.exports = class extends Error {
                constructor(message, options){
                    super(message || ''), 'object' == typeof options && null !== options && (options.code && (this.code = String(options.code)), options.expected && (this.expected = !0), options.transient && (this.transient = !0), options.cause && (this.cause = options.cause)), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
                }
            };
        },
        3454: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var ref, ref1;
            module.exports = (null == (ref = __webpack_require__.g.process) ? void 0 : ref.env) && "object" == typeof (null == (ref1 = __webpack_require__.g.process) ? void 0 : ref1.env) ? __webpack_require__.g.process : __webpack_require__(7663);
        },
        7663: function(module) {
            var __dirname = "/";
            !function() {
                var e = {
                    308: function(e) {
                        var r, n, u, t = e.exports = {};
                        function defaultSetTimout() {
                            throw Error("setTimeout has not been defined");
                        }
                        function defaultClearTimeout() {
                            throw Error("clearTimeout has not been defined");
                        }
                        function runTimeout(e) {
                            if (r === setTimeout) return setTimeout(e, 0);
                            if ((r === defaultSetTimout || !r) && setTimeout) return r = setTimeout, setTimeout(e, 0);
                            try {
                                return r(e, 0);
                            } catch (t) {
                                try {
                                    return r.call(null, e, 0);
                                } catch (t1) {
                                    return r.call(this, e, 0);
                                }
                            }
                        }
                        function runClearTimeout(e) {
                            if (n === clearTimeout) return clearTimeout(e);
                            if ((n === defaultClearTimeout || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e);
                            try {
                                return n(e);
                            } catch (t) {
                                try {
                                    return n.call(null, e);
                                } catch (t1) {
                                    return n.call(this, e);
                                }
                            }
                        }
                        !function() {
                            try {
                                r = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
                            } catch (e) {
                                r = defaultSetTimout;
                            }
                            try {
                                n = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
                            } catch (e1) {
                                n = defaultClearTimeout;
                            }
                        }();
                        var i = [], o = !1, a = -1;
                        function cleanUpNextTick() {
                            o && u && (o = !1, u.length ? i = u.concat(i) : a = -1, i.length && drainQueue());
                        }
                        function drainQueue() {
                            if (!o) {
                                var e = runTimeout(cleanUpNextTick);
                                o = !0;
                                for(var t = i.length; t;){
                                    for(u = i, i = []; ++a < t;)u && u[a].run();
                                    a = -1, t = i.length;
                                }
                                u = null, o = !1, runClearTimeout(e);
                            }
                        }
                        function Item(e, t) {
                            this.fun = e, this.array = t;
                        }
                        function noop() {}
                        t.nextTick = function(e) {
                            var t = Array(arguments.length - 1);
                            if (arguments.length > 1) for(var r = 1; r < arguments.length; r++)t[r - 1] = arguments[r];
                            i.push(new Item(e, t)), 1 !== i.length || o || runTimeout(drainQueue);
                        }, Item.prototype.run = function() {
                            this.fun.apply(null, this.array);
                        }, t.title = "browser", t.browser = !0, t.env = {}, t.argv = [], t.version = "", t.versions = {}, t.on = noop, t.addListener = noop, t.once = noop, t.off = noop, t.removeListener = noop, t.removeAllListeners = noop, t.emit = noop, t.prependListener = noop, t.prependOnceListener = noop, t.listeners = function(e) {
                            return [];
                        }, t.binding = function(e) {
                            throw Error("process.binding is not supported");
                        }, t.cwd = function() {
                            return "/";
                        }, t.chdir = function(e) {
                            throw Error("process.chdir is not supported");
                        }, t.umask = function() {
                            return 0;
                        };
                    }
                }, t = {};
                function __nccwpck_require__1(r) {
                    var n = t[r];
                    if (void 0 !== n) return n.exports;
                    var i = t[r] = {
                        exports: {}
                    }, o = !0;
                    try {
                        e[r](i, i.exports, __nccwpck_require__1), o = !1;
                    } finally{
                        o && delete t[r];
                    }
                    return i.exports;
                }
                __nccwpck_require__1.ab = __dirname + "/";
                var r = __nccwpck_require__1(308);
                module.exports = r;
            }();
        },
        9681: function(module, __unused_webpack_exports, __webpack_require__) {
            var __dirname = "/", process = __webpack_require__(3454);
            !function() {
                var e = {
                    140: function(e) {
                        "function" == typeof Object.create ? e.exports = function(e, t) {
                            t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
                                constructor: {
                                    value: e,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }));
                        } : e.exports = function(e, t) {
                            if (t) {
                                e.super_ = t;
                                var TempCtor = function() {};
                                TempCtor.prototype = t.prototype, e.prototype = new TempCtor, e.prototype.constructor = e;
                            }
                        };
                    },
                    349: function(e) {
                        "use strict";
                        const t = {};
                        function createErrorType(e, r, n) {
                            function getMessage(e, t, n) {
                                return "string" == typeof r ? r : r(e, t, n);
                            }
                            n || (n = Error);
                            class NodeError extends n {
                                constructor(e, t, r){
                                    super(getMessage(e, t, r));
                                }
                            }
                            NodeError.prototype.name = n.name, NodeError.prototype.code = e, t[e] = NodeError;
                        }
                        function oneOf(e, t) {
                            if (!Array.isArray(e)) return `of ${t} ${String(e)}`;
                            {
                                const r = e.length;
                                return (e = e.map((e)=>String(e)), r > 2) ? `one of ${t} ${e.slice(0, r - 1).join(", ")}, or ` + e[r - 1] : 2 === r ? `one of ${t} ${e[0]} or ${e[1]}` : `of ${t} ${e[0]}`;
                            }
                        }
                        function startsWith(e, t, r) {
                            return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
                        }
                        function endsWith(e, t, r) {
                            return (void 0 === r || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
                        }
                        function includes(e, t, r) {
                            return "number" != typeof r && (r = 0), !(r + t.length > e.length) && -1 !== e.indexOf(t, r);
                        }
                        createErrorType("ERR_INVALID_OPT_VALUE", function(e, t) {
                            return 'The value "' + t + '" is invalid for option "' + e + '"';
                        }, TypeError), createErrorType("ERR_INVALID_ARG_TYPE", function(e, t, r) {
                            let n;
                            "string" == typeof t && startsWith(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
                            let i;
                            if (endsWith(e, " argument")) i = `The ${e} ${n} ${oneOf(t, "type")}`;
                            else {
                                const r1 = includes(e, ".") ? "property" : "argument";
                                i = `The "${e}" ${r1} ${n} ${oneOf(t, "type")}`;
                            }
                            return i + `. Received type ${typeof r}`;
                        }, TypeError), createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
                            return "The " + e + " method is not implemented";
                        }), createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), createErrorType("ERR_STREAM_DESTROYED", function(e) {
                            return "Cannot call " + e + " after a stream was destroyed";
                        }), createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end"), createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), createErrorType("ERR_UNKNOWN_ENCODING", function(e) {
                            return "Unknown encoding: " + e;
                        }, TypeError), createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e.exports.q = t;
                    },
                    716: function(e, t, r) {
                        "use strict";
                        var n = Object.keys || function(e) {
                            var t = [];
                            for(var r in e)t.push(r);
                            return t;
                        };
                        e.exports = Duplex;
                        var i = r(787), a = r(513);
                        r(140)(Duplex, i);
                        for(var o = n(a.prototype), s = 0; s < o.length; s++){
                            var f = o[s];
                            Duplex.prototype[f] || (Duplex.prototype[f] = a.prototype[f]);
                        }
                        function Duplex(e) {
                            if (!(this instanceof Duplex)) return new Duplex(e);
                            i.call(this, e), a.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", onend)));
                        }
                        function onend() {
                            this._writableState.ended || process.nextTick(onEndNT, this);
                        }
                        function onEndNT(e) {
                            e.end();
                        }
                        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.highWaterMark;
                            }
                        }), Object.defineProperty(Duplex.prototype, "writableBuffer", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState && this._writableState.getBuffer();
                            }
                        }), Object.defineProperty(Duplex.prototype, "writableLength", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.length;
                            }
                        }), Object.defineProperty(Duplex.prototype, "destroyed", {
                            enumerable: !1,
                            get: function() {
                                return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
                            },
                            set: function(e) {
                                void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
                            }
                        });
                    },
                    788: function(e, t, r) {
                        "use strict";
                        e.exports = PassThrough;
                        var n = r(551);
                        function PassThrough(e) {
                            if (!(this instanceof PassThrough)) return new PassThrough(e);
                            n.call(this, e);
                        }
                        r(140)(PassThrough, n), PassThrough.prototype._transform = function(e, t, r) {
                            r(null, e);
                        };
                    },
                    787: function(e, t, r) {
                        "use strict";
                        e.exports = Readable, Readable.ReadableState = ReadableState, r(361).EventEmitter;
                        var a = function(e, t) {
                            return e.listeners(t).length;
                        }, o = r(455), s = r(300).Buffer, f = __webpack_require__.g.Uint8Array || function() {};
                        function _uint8ArrayToBuffer(e) {
                            return s.from(e);
                        }
                        function _isUint8Array(e) {
                            return s.isBuffer(e) || e instanceof f;
                        }
                        var l = r(837);
                        u = l && l.debuglog ? l.debuglog("stream") : function() {};
                        var n, u, w, m, S, d = r(41), c = r(289), p = r(483).getHighWaterMark, b = r(349).q, g = b.ERR_INVALID_ARG_TYPE, y = b.ERR_STREAM_PUSH_AFTER_EOF, _ = b.ERR_METHOD_NOT_IMPLEMENTED, v = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
                        r(140)(Readable, o);
                        var R = c.errorOrDestroy, E = [
                            "error",
                            "close",
                            "destroy",
                            "pause",
                            "resume"
                        ];
                        function prependListener(e, t, r) {
                            if ("function" == typeof e.prependListener) return e.prependListener(t, r);
                            e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
                                r,
                                e._events[t]
                            ] : e.on(t, r);
                        }
                        function ReadableState(e, t, i) {
                            n = n || r(716), e = e || {}, "boolean" != typeof i && (i = t instanceof n), this.objectMode = !!e.objectMode, i && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = p(this, e, "readableHighWaterMark", i), this.buffer = new d, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (w || (w = r(862).s), this.decoder = new w(e.encoding), this.encoding = e.encoding);
                        }
                        function Readable(e) {
                            if (n = n || r(716), !(this instanceof Readable)) return new Readable(e);
                            var t = this instanceof n;
                            this._readableState = new ReadableState(e, this, t), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), o.call(this);
                        }
                        function readableAddChunk(e, t, r, n, i) {
                            u("readableAddChunk", t);
                            var o, a = e._readableState;
                            if (null === t) a.reading = !1, onEofChunk(e, a);
                            else if (i || (o = chunkInvalid(a, t)), o) R(e, o);
                            else if (a.objectMode || t && t.length > 0) {
                                if ("string" == typeof t || a.objectMode || Object.getPrototypeOf(t) === s.prototype || (t = _uint8ArrayToBuffer(t)), n) a.endEmitted ? R(e, new v) : addChunk(e, a, t, !0);
                                else if (a.ended) R(e, new y);
                                else {
                                    if (a.destroyed) return !1;
                                    a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || 0 !== t.length ? addChunk(e, a, t, !1) : maybeReadMore(e, a)) : addChunk(e, a, t, !1);
                                }
                            } else n || (a.reading = !1, maybeReadMore(e, a));
                            return !a.ended && (a.length < a.highWaterMark || 0 === a.length);
                        }
                        function addChunk(e, t, r, n) {
                            t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && emitReadable(e)), maybeReadMore(e, t);
                        }
                        function chunkInvalid(e, t) {
                            var r;
                            return _isUint8Array(t) || "string" == typeof t || void 0 === t || e.objectMode || (r = new g("chunk", [
                                "string",
                                "Buffer",
                                "Uint8Array"
                            ], t)), r;
                        }
                        Object.defineProperty(Readable.prototype, "destroyed", {
                            enumerable: !1,
                            get: function() {
                                return void 0 !== this._readableState && this._readableState.destroyed;
                            },
                            set: function(e) {
                                this._readableState && (this._readableState.destroyed = e);
                            }
                        }), Readable.prototype.destroy = c.destroy, Readable.prototype._undestroy = c.undestroy, Readable.prototype._destroy = function(e, t) {
                            t(e);
                        }, Readable.prototype.push = function(e, t) {
                            var n, r = this._readableState;
                            return r.objectMode ? n = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = s.from(e, t), t = ""), n = !0), readableAddChunk(this, e, t, !1, n);
                        }, Readable.prototype.unshift = function(e) {
                            return readableAddChunk(this, e, null, !0, !1);
                        }, Readable.prototype.isPaused = function() {
                            return !1 === this._readableState.flowing;
                        }, Readable.prototype.setEncoding = function(e) {
                            w || (w = r(862).s);
                            var t = new w(e);
                            this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
                            for(var n = this._readableState.buffer.head, i = ""; null !== n;)i += t.write(n.data), n = n.next;
                            return this._readableState.buffer.clear(), "" !== i && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
                        };
                        var T = 1073741824;
                        function computeNewHighWaterMark(e) {
                            return e >= T ? e = T : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
                        }
                        function howMuchToRead(e, t) {
                            return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = computeNewHighWaterMark(e)), e <= t.length) ? e : t.ended ? t.length : (t.needReadable = !0, 0);
                        }
                        function onEofChunk(e, t) {
                            if (u("onEofChunk"), !t.ended) {
                                if (t.decoder) {
                                    var r = t.decoder.end();
                                    r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
                                }
                                t.ended = !0, t.sync ? emitReadable(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, emitReadable_(e)));
                            }
                        }
                        function emitReadable(e) {
                            var t = e._readableState;
                            u("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (u("emitReadable", t.flowing), t.emittedReadable = !0, process.nextTick(emitReadable_, e));
                        }
                        function emitReadable_(e) {
                            var t = e._readableState;
                            u("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, flow(e);
                        }
                        function maybeReadMore(e, t) {
                            t.readingMore || (t.readingMore = !0, process.nextTick(maybeReadMore_, e, t));
                        }
                        function maybeReadMore_(e, t) {
                            for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);){
                                var r = t.length;
                                if (u("maybeReadMore read 0"), e.read(0), r === t.length) break;
                            }
                            t.readingMore = !1;
                        }
                        function pipeOnDrain(e) {
                            return function() {
                                var t = e._readableState;
                                u("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && a(e, "data") && (t.flowing = !0, flow(e));
                            };
                        }
                        function updateReadableListening(e) {
                            var t = e._readableState;
                            t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
                        }
                        function nReadingNextTick(e) {
                            u("readable nexttick read 0"), e.read(0);
                        }
                        function resume(e, t) {
                            t.resumeScheduled || (t.resumeScheduled = !0, process.nextTick(resume_, e, t));
                        }
                        function resume_(e, t) {
                            u("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), flow(e), t.flowing && !t.reading && e.read(0);
                        }
                        function flow(e) {
                            var t = e._readableState;
                            for(u("flow", t.flowing); t.flowing && null !== e.read(););
                        }
                        function fromList(e, t) {
                            var r;
                            return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r);
                        }
                        function endReadable(e) {
                            var t = e._readableState;
                            u("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, process.nextTick(endReadableNT, t, e));
                        }
                        function endReadableNT(e, t) {
                            if (u("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
                                var r = t._writableState;
                                (!r || r.autoDestroy && r.finished) && t.destroy();
                            }
                        }
                        function indexOf(e, t) {
                            for(var r = 0, n = e.length; r < n; r++)if (e[r] === t) return r;
                            return -1;
                        }
                        Readable.prototype.read = function(e) {
                            u("read", e), e = parseInt(e, 10);
                            var i, t = this._readableState, r = e;
                            if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return u("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? endReadable(this) : emitReadable(this), null;
                            if (0 === (e = howMuchToRead(e, t)) && t.ended) return 0 === t.length && endReadable(this), null;
                            var n = t.needReadable;
                            return u("need readable", n), (0 === t.length || t.length - e < t.highWaterMark) && u("length less than watermark", n = !0), t.ended || t.reading ? u("reading or ended", n = !1) : n && (u("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = howMuchToRead(r, t))), null === (i = e > 0 ? fromList(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && endReadable(this)), null !== i && this.emit("data", i), i;
                        }, Readable.prototype._read = function(e) {
                            R(this, new _("_read()"));
                        }, Readable.prototype.pipe = function(e, t) {
                            var r = this, n = this._readableState;
                            switch(n.pipesCount){
                                case 0:
                                    n.pipes = e;
                                    break;
                                case 1:
                                    n.pipes = [
                                        n.pipes,
                                        e
                                    ];
                                    break;
                                default:
                                    n.pipes.push(e);
                            }
                            n.pipesCount += 1, u("pipe count=%d opts=%j", n.pipesCount, t);
                            var o = t && !1 === t.end || e === process.stdout || e === process.stderr ? unpipe : onend;
                            function onunpipe(e, t) {
                                u("onunpipe"), e === r && t && !1 === t.hasUnpiped && (t.hasUnpiped = !0, cleanup());
                            }
                            function onend() {
                                u("onend"), e.end();
                            }
                            n.endEmitted ? process.nextTick(o) : r.once("end", o), e.on("unpipe", onunpipe);
                            var s = pipeOnDrain(r);
                            e.on("drain", s);
                            var f = !1;
                            function cleanup() {
                                u("cleanup"), e.removeListener("close", onclose), e.removeListener("finish", onfinish), e.removeListener("drain", s), e.removeListener("error", onerror), e.removeListener("unpipe", onunpipe), r.removeListener("end", onend), r.removeListener("end", unpipe), r.removeListener("data", ondata), f = !0, n.awaitDrain && (!e._writableState || e._writableState.needDrain) && s();
                            }
                            function ondata(t) {
                                u("ondata");
                                var i = e.write(t);
                                u("dest.write", i), !1 === i && ((1 === n.pipesCount && n.pipes === e || n.pipesCount > 1 && -1 !== indexOf(n.pipes, e)) && !f && (u("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
                            }
                            function onerror(t) {
                                u("onerror", t), unpipe(), e.removeListener("error", onerror), 0 === a(e, "error") && R(e, t);
                            }
                            function onclose() {
                                e.removeListener("finish", onfinish), unpipe();
                            }
                            function onfinish() {
                                u("onfinish"), e.removeListener("close", onclose), unpipe();
                            }
                            function unpipe() {
                                u("unpipe"), r.unpipe(e);
                            }
                            return r.on("data", ondata), prependListener(e, "error", onerror), e.once("close", onclose), e.once("finish", onfinish), e.emit("pipe", r), n.flowing || (u("pipe resume"), r.resume()), e;
                        }, Readable.prototype.unpipe = function(e) {
                            var t = this._readableState, r = {
                                hasUnpiped: !1
                            };
                            if (0 === t.pipesCount) return this;
                            if (1 === t.pipesCount) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r)), this;
                            if (!e) {
                                var n = t.pipes, i = t.pipesCount;
                                t.pipes = null, t.pipesCount = 0, t.flowing = !1;
                                for(var a = 0; a < i; a++)n[a].emit("unpipe", this, {
                                    hasUnpiped: !1
                                });
                                return this;
                            }
                            var o = indexOf(t.pipes, e);
                            return -1 === o || (t.pipes.splice(o, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r)), this;
                        }, Readable.prototype.on = function(e, t) {
                            var r = o.prototype.on.call(this, e, t), n = this._readableState;
                            return "data" === e ? (n.readableListening = this.listenerCount("readable") > 0, !1 !== n.flowing && this.resume()) : "readable" !== e || n.endEmitted || n.readableListening || (n.readableListening = n.needReadable = !0, n.flowing = !1, n.emittedReadable = !1, u("on readable", n.length, n.reading), n.length ? emitReadable(this) : n.reading || process.nextTick(nReadingNextTick, this)), r;
                        }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.removeListener = function(e, t) {
                            var r = o.prototype.removeListener.call(this, e, t);
                            return "readable" === e && process.nextTick(updateReadableListening, this), r;
                        }, Readable.prototype.removeAllListeners = function(e) {
                            var t = o.prototype.removeAllListeners.apply(this, arguments);
                            return ("readable" === e || void 0 === e) && process.nextTick(updateReadableListening, this), t;
                        }, Readable.prototype.resume = function() {
                            var e = this._readableState;
                            return e.flowing || (u("resume"), e.flowing = !e.readableListening, resume(this, e)), e.paused = !1, this;
                        }, Readable.prototype.pause = function() {
                            return u("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
                        }, Readable.prototype.wrap = function(e) {
                            var t = this, r = this._readableState, n = !1;
                            for(var i in e.on("end", function() {
                                if (u("wrapped end"), r.decoder && !r.ended) {
                                    var e = r.decoder.end();
                                    e && e.length && t.push(e);
                                }
                                t.push(null);
                            }), e.on("data", function(i) {
                                u("wrapped data"), r.decoder && (i = r.decoder.write(i)), (!r.objectMode || null != i) && (r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause()));
                            }), e)void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
                                return function() {
                                    return e[t].apply(e, arguments);
                                };
                            }(i));
                            for(var a = 0; a < E.length; a++)e.on(E[a], this.emit.bind(this, E[a]));
                            return this._read = function(t) {
                                u("wrapped _read", t), n && (n = !1, e.resume());
                            }, this;
                        }, "function" == typeof Symbol && (Readable.prototype[Symbol.asyncIterator] = function() {
                            return void 0 === m && (m = r(224)), m(this);
                        }), Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState.highWaterMark;
                            }
                        }), Object.defineProperty(Readable.prototype, "readableBuffer", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState && this._readableState.buffer;
                            }
                        }), Object.defineProperty(Readable.prototype, "readableFlowing", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState.flowing;
                            },
                            set: function(e) {
                                this._readableState && (this._readableState.flowing = e);
                            }
                        }), Readable._fromList = fromList, Object.defineProperty(Readable.prototype, "readableLength", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState.length;
                            }
                        }), "function" == typeof Symbol && (Readable.from = function(e, t) {
                            return void 0 === S && (S = r(720)), S(Readable, e, t);
                        });
                    },
                    551: function(e, t, r) {
                        "use strict";
                        e.exports = Transform;
                        var n = r(349).q, i = n.ERR_METHOD_NOT_IMPLEMENTED, a = n.ERR_MULTIPLE_CALLBACK, o = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = n.ERR_TRANSFORM_WITH_LENGTH_0, f = r(716);
                        function afterTransform(e, t) {
                            var r = this._transformState;
                            r.transforming = !1;
                            var n = r.writecb;
                            if (null === n) return this.emit("error", new a);
                            r.writechunk = null, r.writecb = null, null != t && this.push(t), n(e);
                            var i = this._readableState;
                            i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
                        }
                        function Transform(e) {
                            if (!(this instanceof Transform)) return new Transform(e);
                            f.call(this, e), this._transformState = {
                                afterTransform: afterTransform.bind(this),
                                needTransform: !1,
                                transforming: !1,
                                writecb: null,
                                writechunk: null,
                                writeencoding: null
                            }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", prefinish);
                        }
                        function prefinish() {
                            var e = this;
                            "function" != typeof this._flush || this._readableState.destroyed ? done(this, null, null) : this._flush(function(t, r) {
                                done(e, t, r);
                            });
                        }
                        function done(e, t, r) {
                            if (t) return e.emit("error", t);
                            if (null != r && e.push(r), e._writableState.length) throw new s;
                            if (e._transformState.transforming) throw new o;
                            return e.push(null);
                        }
                        r(140)(Transform, f), Transform.prototype.push = function(e, t) {
                            return this._transformState.needTransform = !1, f.prototype.push.call(this, e, t);
                        }, Transform.prototype._transform = function(e, t, r) {
                            r(new i("_transform()"));
                        }, Transform.prototype._write = function(e, t, r) {
                            var n = this._transformState;
                            if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
                                var i = this._readableState;
                                (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
                            }
                        }, Transform.prototype._read = function(e) {
                            var t = this._transformState;
                            null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform));
                        }, Transform.prototype._destroy = function(e, t) {
                            f.prototype._destroy.call(this, e, function(e) {
                                t(e);
                            });
                        };
                    },
                    513: function(e, t, r) {
                        "use strict";
                        function CorkedRequest(e) {
                            var t = this;
                            this.next = null, this.entry = null, this.finish = function() {
                                onCorkedFinish(t, e);
                            };
                        }
                        e.exports = Writable, Writable.WritableState = WritableState;
                        var n, m, i = {
                            deprecate: r(777)
                        }, a = r(455), o = r(300).Buffer, s = __webpack_require__.g.Uint8Array || function() {};
                        function _uint8ArrayToBuffer(e) {
                            return o.from(e);
                        }
                        function _isUint8Array(e) {
                            return o.isBuffer(e) || e instanceof s;
                        }
                        var f = r(289), u = r(483).getHighWaterMark, d = r(349).q, c = d.ERR_INVALID_ARG_TYPE, h = d.ERR_METHOD_NOT_IMPLEMENTED, p = d.ERR_MULTIPLE_CALLBACK, b = d.ERR_STREAM_CANNOT_PIPE, g = d.ERR_STREAM_DESTROYED, y = d.ERR_STREAM_NULL_VALUES, _ = d.ERR_STREAM_WRITE_AFTER_END, v = d.ERR_UNKNOWN_ENCODING, w = f.errorOrDestroy;
                        function nop() {}
                        function WritableState(e, t, i) {
                            n = n || r(716), e = e || {}, "boolean" != typeof i && (i = t instanceof n), this.objectMode = !!e.objectMode, i && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = u(this, e, "writableHighWaterMark", i), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
                            var a = !1 === e.decodeStrings;
                            this.decodeStrings = !a, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
                                onwrite(t, e);
                            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
                        }
                        function Writable(e) {
                            var t = this instanceof (n = n || r(716));
                            if (!t && !m.call(Writable, this)) return new Writable(e);
                            this._writableState = new WritableState(e, this, t), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), a.call(this);
                        }
                        function writeAfterEnd(e, t) {
                            var r = new _;
                            w(e, r), process.nextTick(t, r);
                        }
                        function validChunk(e, t, r, n) {
                            var i;
                            return null === r ? i = new y : "string" == typeof r || t.objectMode || (i = new c("chunk", [
                                "string",
                                "Buffer"
                            ], r)), !i || (w(e, i), process.nextTick(n, i), !1);
                        }
                        function decodeChunk(e, t, r) {
                            return e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = o.from(t, r)), t;
                        }
                        function writeOrBuffer(e, t, r, n, i, a) {
                            if (!r) {
                                var o = decodeChunk(t, n, i);
                                n !== o && (r = !0, i = "buffer", n = o);
                            }
                            var s = t.objectMode ? 1 : n.length;
                            t.length += s;
                            var f = t.length < t.highWaterMark;
                            if (f || (t.needDrain = !0), t.writing || t.corked) {
                                var l = t.lastBufferedRequest;
                                t.lastBufferedRequest = {
                                    chunk: n,
                                    encoding: i,
                                    isBuf: r,
                                    callback: a,
                                    next: null
                                }, l ? l.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
                            } else doWrite(e, t, !1, s, n, i, a);
                            return f;
                        }
                        function doWrite(e, t, r, n, i, a, o) {
                            t.writelen = n, t.writecb = o, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new g("write")) : r ? e._writev(i, t.onwrite) : e._write(i, a, t.onwrite), t.sync = !1;
                        }
                        function onwriteError(e, t, r, n, i) {
                            --t.pendingcb, r ? (process.nextTick(i, n), process.nextTick(finishMaybe, e, t), e._writableState.errorEmitted = !0, w(e, n)) : (i(n), e._writableState.errorEmitted = !0, w(e, n), finishMaybe(e, t));
                        }
                        function onwriteStateUpdate(e) {
                            e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
                        }
                        function onwrite(e, t) {
                            var r = e._writableState, n = r.sync, i = r.writecb;
                            if ("function" != typeof i) throw new p;
                            if (onwriteStateUpdate(r), t) onwriteError(e, r, n, t, i);
                            else {
                                var a = needFinish(r) || e.destroyed;
                                a || r.corked || r.bufferProcessing || !r.bufferedRequest || clearBuffer(e, r), n ? process.nextTick(afterWrite, e, r, a, i) : afterWrite(e, r, a, i);
                            }
                        }
                        function afterWrite(e, t, r, n) {
                            r || onwriteDrain(e, t), t.pendingcb--, n(), finishMaybe(e, t);
                        }
                        function onwriteDrain(e, t) {
                            0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"));
                        }
                        function clearBuffer(e, t) {
                            t.bufferProcessing = !0;
                            var r = t.bufferedRequest;
                            if (e._writev && r && r.next) {
                                var i = Array(t.bufferedRequestCount), a = t.corkedRequestsFree;
                                a.entry = r;
                                for(var o = 0, s = !0; r;)i[o] = r, r.isBuf || (s = !1), r = r.next, o += 1;
                                i.allBuffers = s, doWrite(e, t, !0, t.length, i, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new CorkedRequest(t), t.bufferedRequestCount = 0;
                            } else {
                                for(; r;){
                                    var f = r.chunk, l = r.encoding, u = r.callback, d = t.objectMode ? 1 : f.length;
                                    if (doWrite(e, t, !1, d, f, l, u), r = r.next, t.bufferedRequestCount--, t.writing) break;
                                }
                                null === r && (t.lastBufferedRequest = null);
                            }
                            t.bufferedRequest = r, t.bufferProcessing = !1;
                        }
                        function needFinish(e) {
                            return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
                        }
                        function callFinal(e, t) {
                            e._final(function(r) {
                                t.pendingcb--, r && w(e, r), t.prefinished = !0, e.emit("prefinish"), finishMaybe(e, t);
                            });
                        }
                        function prefinish(e, t) {
                            t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, process.nextTick(callFinal, e, t)));
                        }
                        function finishMaybe(e, t) {
                            var r = needFinish(t);
                            if (r && (prefinish(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
                                var n = e._readableState;
                                (!n || n.autoDestroy && n.endEmitted) && e.destroy();
                            }
                            return r;
                        }
                        function endWritable(e, t, r) {
                            t.ending = !0, finishMaybe(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
                        }
                        function onCorkedFinish(e, t, r) {
                            var n = e.entry;
                            for(e.entry = null; n;){
                                var i = n.callback;
                                t.pendingcb--, i(r), n = n.next;
                            }
                            t.corkedRequestsFree.next = e;
                        }
                        r(140)(Writable, a), WritableState.prototype.getBuffer = function() {
                            for(var e = this.bufferedRequest, t = []; e;)t.push(e), e = e.next;
                            return t;
                        }, function() {
                            try {
                                Object.defineProperty(WritableState.prototype, "buffer", {
                                    get: i.deprecate(function() {
                                        return this.getBuffer();
                                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                                });
                            } catch (e) {}
                        }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (m = Function.prototype[Symbol.hasInstance], Object.defineProperty(Writable, Symbol.hasInstance, {
                            value: function(e) {
                                return !!m.call(this, e) || this === Writable && e && e._writableState instanceof WritableState;
                            }
                        })) : m = function(e) {
                            return e instanceof this;
                        }, Writable.prototype.pipe = function() {
                            w(this, new b);
                        }, Writable.prototype.write = function(e, t, r) {
                            var n = this._writableState, i = !1, a = !n.objectMode && _isUint8Array(e);
                            return a && !o.isBuffer(e) && (e = _uint8ArrayToBuffer(e)), "function" == typeof t && (r = t, t = null), a ? t = "buffer" : t || (t = n.defaultEncoding), "function" != typeof r && (r = nop), n.ending ? writeAfterEnd(this, r) : (a || validChunk(this, n, e, r)) && (n.pendingcb++, i = writeOrBuffer(this, n, a, e, t, r)), i;
                        }, Writable.prototype.cork = function() {
                            this._writableState.corked++;
                        }, Writable.prototype.uncork = function() {
                            var e = this._writableState;
                            !e.corked || (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || clearBuffer(this, e));
                        }, Writable.prototype.setDefaultEncoding = function(e) {
                            if ("string" == typeof e && (e = e.toLowerCase()), !([
                                "hex",
                                "utf8",
                                "utf-8",
                                "ascii",
                                "binary",
                                "base64",
                                "ucs2",
                                "ucs-2",
                                "utf16le",
                                "utf-16le",
                                "raw"
                            ].indexOf((e + "").toLowerCase()) > -1)) throw new v(e);
                            return this._writableState.defaultEncoding = e, this;
                        }, Object.defineProperty(Writable.prototype, "writableBuffer", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState && this._writableState.getBuffer();
                            }
                        }), Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.highWaterMark;
                            }
                        }), Writable.prototype._write = function(e, t, r) {
                            r(new h("_write()"));
                        }, Writable.prototype._writev = null, Writable.prototype.end = function(e, t, r) {
                            var n = this._writableState;
                            return "function" == typeof e ? (r = e, e = null, t = null) : "function" == typeof t && (r = t, t = null), null != e && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || endWritable(this, n, r), this;
                        }, Object.defineProperty(Writable.prototype, "writableLength", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.length;
                            }
                        }), Object.defineProperty(Writable.prototype, "destroyed", {
                            enumerable: !1,
                            get: function() {
                                return void 0 !== this._writableState && this._writableState.destroyed;
                            },
                            set: function(e) {
                                this._writableState && (this._writableState.destroyed = e);
                            }
                        }), Writable.prototype.destroy = f.destroy, Writable.prototype._undestroy = f.undestroy, Writable.prototype._destroy = function(e, t) {
                            t(e);
                        };
                    },
                    224: function(e, t, r) {
                        "use strict";
                        function _defineProperty(e, t, r) {
                            return t in e ? Object.defineProperty(e, t, {
                                value: r,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : e[t] = r, e;
                        }
                        var n, i = r(7), a = Symbol("lastResolve"), o = Symbol("lastReject"), s = Symbol("error"), f = Symbol("ended"), l = Symbol("lastPromise"), u = Symbol("handlePromise"), d = Symbol("stream");
                        function createIterResult(e, t) {
                            return {
                                value: e,
                                done: t
                            };
                        }
                        function readAndResolve(e) {
                            var t = e[a];
                            if (null !== t) {
                                var r = e[d].read();
                                null !== r && (e[l] = null, e[a] = null, e[o] = null, t(createIterResult(r, !1)));
                            }
                        }
                        function onReadable(e) {
                            process.nextTick(readAndResolve, e);
                        }
                        function wrapForNext(e, t) {
                            return function(r, n) {
                                e.then(function() {
                                    if (t[f]) {
                                        r(createIterResult(void 0, !0));
                                        return;
                                    }
                                    t[u](r, n);
                                }, n);
                            };
                        }
                        var c = Object.getPrototypeOf(function() {}), h = Object.setPrototypeOf((n = {
                            get stream () {
                                return this[d];
                            },
                            next: function() {
                                var n, e = this, t = this[s];
                                if (null !== t) return Promise.reject(t);
                                if (this[f]) return Promise.resolve(createIterResult(void 0, !0));
                                if (this[d].destroyed) return new Promise(function(t, r) {
                                    process.nextTick(function() {
                                        e[s] ? r(e[s]) : t(createIterResult(void 0, !0));
                                    });
                                });
                                var r = this[l];
                                if (r) n = new Promise(wrapForNext(r, this));
                                else {
                                    var i = this[d].read();
                                    if (null !== i) return Promise.resolve(createIterResult(i, !1));
                                    n = new Promise(this[u]);
                                }
                                return this[l] = n, n;
                            }
                        }, _defineProperty(n, Symbol.asyncIterator, function() {
                            return this;
                        }), _defineProperty(n, "return", function() {
                            var e = this;
                            return new Promise(function(t, r) {
                                e[d].destroy(null, function(e) {
                                    if (e) {
                                        r(e);
                                        return;
                                    }
                                    t(createIterResult(void 0, !0));
                                });
                            });
                        }), n), c), p = function(e) {
                            var t, r = Object.create(h, (_defineProperty(t = {}, d, {
                                value: e,
                                writable: !0
                            }), _defineProperty(t, a, {
                                value: null,
                                writable: !0
                            }), _defineProperty(t, o, {
                                value: null,
                                writable: !0
                            }), _defineProperty(t, s, {
                                value: null,
                                writable: !0
                            }), _defineProperty(t, f, {
                                value: e._readableState.endEmitted,
                                writable: !0
                            }), _defineProperty(t, u, {
                                value: function(e, t) {
                                    var n = r[d].read();
                                    n ? (r[l] = null, r[a] = null, r[o] = null, e(createIterResult(n, !1))) : (r[a] = e, r[o] = t);
                                },
                                writable: !0
                            }), t));
                            return r[l] = null, i(e, function(e) {
                                if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
                                    var t = r[o];
                                    null !== t && (r[l] = null, r[a] = null, r[o] = null, t(e)), r[s] = e;
                                    return;
                                }
                                var n = r[a];
                                null !== n && (r[l] = null, r[a] = null, r[o] = null, n(createIterResult(void 0, !0))), r[f] = !0;
                            }), e.on("readable", onReadable.bind(null, r)), r;
                        };
                        e.exports = p;
                    },
                    41: function(e, t, r) {
                        "use strict";
                        function ownKeys(e, t) {
                            var r = Object.keys(e);
                            if (Object.getOwnPropertySymbols) {
                                var n = Object.getOwnPropertySymbols(e);
                                t && (n = n.filter(function(t) {
                                    return Object.getOwnPropertyDescriptor(e, t).enumerable;
                                })), r.push.apply(r, n);
                            }
                            return r;
                        }
                        function _objectSpread(e) {
                            for(var t = 1; t < arguments.length; t++){
                                var r = null != arguments[t] ? arguments[t] : {};
                                t % 2 ? ownKeys(Object(r), !0).forEach(function(t) {
                                    _defineProperty(e, t, r[t]);
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ownKeys(Object(r)).forEach(function(t) {
                                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                                });
                            }
                            return e;
                        }
                        function _defineProperty(e, t, r) {
                            return t in e ? Object.defineProperty(e, t, {
                                value: r,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : e[t] = r, e;
                        }
                        function _classCallCheck(e, t) {
                            if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
                        }
                        function _defineProperties(e, t) {
                            for(var r = 0; r < t.length; r++){
                                var n = t[r];
                                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                            }
                        }
                        function _createClass(e, t, r) {
                            return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
                        }
                        var i = r(300).Buffer, o = r(837).inspect, s = o && o.custom || "inspect";
                        function copyBuffer(e, t, r) {
                            i.prototype.copy.call(e, t, r);
                        }
                        e.exports = function() {
                            function BufferList() {
                                _classCallCheck(this, BufferList), this.head = null, this.tail = null, this.length = 0;
                            }
                            return _createClass(BufferList, [
                                {
                                    key: "push",
                                    value: function(e) {
                                        var t = {
                                            data: e,
                                            next: null
                                        };
                                        this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;
                                    }
                                },
                                {
                                    key: "unshift",
                                    value: function(e) {
                                        var t = {
                                            data: e,
                                            next: this.head
                                        };
                                        0 === this.length && (this.tail = t), this.head = t, ++this.length;
                                    }
                                },
                                {
                                    key: "shift",
                                    value: function() {
                                        if (0 !== this.length) {
                                            var e = this.head.data;
                                            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
                                        }
                                    }
                                },
                                {
                                    key: "clear",
                                    value: function() {
                                        this.head = this.tail = null, this.length = 0;
                                    }
                                },
                                {
                                    key: "join",
                                    value: function(e) {
                                        if (0 === this.length) return "";
                                        for(var t = this.head, r = "" + t.data; t = t.next;)r += e + t.data;
                                        return r;
                                    }
                                },
                                {
                                    key: "concat",
                                    value: function(e) {
                                        if (0 === this.length) return i.alloc(0);
                                        for(var t = i.allocUnsafe(e >>> 0), r = this.head, n = 0; r;)copyBuffer(r.data, t, n), n += r.data.length, r = r.next;
                                        return t;
                                    }
                                },
                                {
                                    key: "consume",
                                    value: function(e, t) {
                                        var r;
                                        return e < this.head.data.length ? (r = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : r = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), r;
                                    }
                                },
                                {
                                    key: "first",
                                    value: function() {
                                        return this.head.data;
                                    }
                                },
                                {
                                    key: "_getString",
                                    value: function(e) {
                                        var t = this.head, r = 1, n = t.data;
                                        for(e -= n.length; t = t.next;){
                                            var i = t.data, a = e > i.length ? i.length : e;
                                            if (a === i.length ? n += i : n += i.slice(0, e), 0 == (e -= a)) {
                                                a === i.length ? (++r, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(a));
                                                break;
                                            }
                                            ++r;
                                        }
                                        return this.length -= r, n;
                                    }
                                },
                                {
                                    key: "_getBuffer",
                                    value: function(e) {
                                        var t = i.allocUnsafe(e), r = this.head, n = 1;
                                        for(r.data.copy(t), e -= r.data.length; r = r.next;){
                                            var a = r.data, o = e > a.length ? a.length : e;
                                            if (a.copy(t, t.length - e, 0, o), 0 == (e -= o)) {
                                                o === a.length ? (++n, r.next ? this.head = r.next : this.head = this.tail = null) : (this.head = r, r.data = a.slice(o));
                                                break;
                                            }
                                            ++n;
                                        }
                                        return this.length -= n, t;
                                    }
                                },
                                {
                                    key: s,
                                    value: function(e, t) {
                                        return o(this, _objectSpread({}, t, {
                                            depth: 0,
                                            customInspect: !1
                                        }));
                                    }
                                }
                            ]), BufferList;
                        }();
                    },
                    289: function(e) {
                        "use strict";
                        function destroy(e, t) {
                            var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
                            return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(emitErrorNT, this, e)) : process.nextTick(emitErrorNT, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(e) {
                                !t && e ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(emitCloseNT, r) : (r._writableState.errorEmitted = !0, process.nextTick(emitErrorAndCloseNT, r, e)) : process.nextTick(emitErrorAndCloseNT, r, e) : t ? (process.nextTick(emitCloseNT, r), t(e)) : process.nextTick(emitCloseNT, r);
                            }), this);
                        }
                        function emitErrorAndCloseNT(e, t) {
                            emitErrorNT(e, t), emitCloseNT(e);
                        }
                        function emitCloseNT(e) {
                            (!e._writableState || e._writableState.emitClose) && (!e._readableState || e._readableState.emitClose) && e.emit("close");
                        }
                        function undestroy() {
                            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
                        }
                        function emitErrorNT(e, t) {
                            e.emit("error", t);
                        }
                        function errorOrDestroy(e, t) {
                            var r = e._readableState, n = e._writableState;
                            r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
                        }
                        e.exports = {
                            destroy: destroy,
                            undestroy: undestroy,
                            errorOrDestroy: errorOrDestroy
                        };
                    },
                    7: function(e, t, r) {
                        "use strict";
                        var n = r(349).q.ERR_STREAM_PREMATURE_CLOSE;
                        function once(e) {
                            var t = !1;
                            return function() {
                                if (!t) {
                                    t = !0;
                                    for(var r = arguments.length, n = Array(r), i = 0; i < r; i++)n[i] = arguments[i];
                                    e.apply(this, n);
                                }
                            };
                        }
                        function noop() {}
                        function isRequest(e) {
                            return e.setHeader && "function" == typeof e.abort;
                        }
                        function eos(e, t, r) {
                            if ("function" == typeof t) return eos(e, null, t);
                            t || (t = {}), r = once(r || noop);
                            var i = t.readable || !1 !== t.readable && e.readable, a = t.writable || !1 !== t.writable && e.writable, o = function() {
                                e.writable || f();
                            }, s = e._writableState && e._writableState.finished, f = function() {
                                a = !1, s = !0, i || r.call(e);
                            }, l = e._readableState && e._readableState.endEmitted, u = function() {
                                i = !1, l = !0, a || r.call(e);
                            }, d = function(t) {
                                r.call(e, t);
                            }, c = function() {
                                var t;
                                return i && !l ? (e._readableState && e._readableState.ended || (t = new n), r.call(e, t)) : a && !s ? (e._writableState && e._writableState.ended || (t = new n), r.call(e, t)) : void 0;
                            }, h = function() {
                                e.req.on("finish", f);
                            };
                            return isRequest(e) ? (e.on("complete", f), e.on("abort", c), e.req ? h() : e.on("request", h)) : a && !e._writableState && (e.on("end", o), e.on("close", o)), e.on("end", u), e.on("finish", f), !1 !== t.error && e.on("error", d), e.on("close", c), function() {
                                e.removeListener("complete", f), e.removeListener("abort", c), e.removeListener("request", h), e.req && e.req.removeListener("finish", f), e.removeListener("end", o), e.removeListener("close", o), e.removeListener("finish", f), e.removeListener("end", u), e.removeListener("error", d), e.removeListener("close", c);
                            };
                        }
                        e.exports = eos;
                    },
                    720: function(e, t, r) {
                        "use strict";
                        function asyncGeneratorStep(e, t, r, n, i, a, o) {
                            try {
                                var s = e[a](o), f = s.value;
                            } catch (e1) {
                                r(e1);
                                return;
                            }
                            s.done ? t(f) : Promise.resolve(f).then(n, i);
                        }
                        function _asyncToGenerator(e) {
                            return function() {
                                var t = this, r = arguments;
                                return new Promise(function(n, i) {
                                    var a = e.apply(t, r);
                                    function _next(e) {
                                        asyncGeneratorStep(a, n, i, _next, _throw, "next", e);
                                    }
                                    function _throw(e) {
                                        asyncGeneratorStep(a, n, i, _next, _throw, "throw", e);
                                    }
                                    _next(void 0);
                                });
                            };
                        }
                        function ownKeys(e, t) {
                            var r = Object.keys(e);
                            if (Object.getOwnPropertySymbols) {
                                var n = Object.getOwnPropertySymbols(e);
                                t && (n = n.filter(function(t) {
                                    return Object.getOwnPropertyDescriptor(e, t).enumerable;
                                })), r.push.apply(r, n);
                            }
                            return r;
                        }
                        function _objectSpread(e) {
                            for(var t = 1; t < arguments.length; t++){
                                var r = null != arguments[t] ? arguments[t] : {};
                                t % 2 ? ownKeys(Object(r), !0).forEach(function(t) {
                                    _defineProperty(e, t, r[t]);
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ownKeys(Object(r)).forEach(function(t) {
                                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                                });
                            }
                            return e;
                        }
                        function _defineProperty(e, t, r) {
                            return t in e ? Object.defineProperty(e, t, {
                                value: r,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : e[t] = r, e;
                        }
                        var n = r(349).q.ERR_INVALID_ARG_TYPE;
                        function from(e, t, r) {
                            if (t && "function" == typeof t.next) i = t;
                            else if (t && t[Symbol.asyncIterator]) i = t[Symbol.asyncIterator]();
                            else if (t && t[Symbol.iterator]) i = t[Symbol.iterator]();
                            else throw new n("iterable", [
                                "Iterable"
                            ], t);
                            var i, a = new e(_objectSpread({
                                objectMode: !0
                            }, r)), o = !1;
                            function next() {
                                return _next2.apply(this, arguments);
                            }
                            function _next2() {
                                return (_next2 = _asyncToGenerator(function*() {
                                    try {
                                        var e = yield i.next(), t = e.value;
                                        e.done ? a.push(null) : a.push((yield t)) ? next() : o = !1;
                                    } catch (e1) {
                                        a.destroy(e1);
                                    }
                                })).apply(this, arguments);
                            }
                            return a._read = function() {
                                o || (o = !0, next());
                            }, a;
                        }
                        e.exports = from;
                    },
                    522: function(e, t, r) {
                        "use strict";
                        function once(e) {
                            var t = !1;
                            return function() {
                                t || (t = !0, e.apply(void 0, arguments));
                            };
                        }
                        var n, i = r(349).q, a = i.ERR_MISSING_ARGS, o = i.ERR_STREAM_DESTROYED;
                        function noop(e) {
                            if (e) throw e;
                        }
                        function isRequest(e) {
                            return e.setHeader && "function" == typeof e.abort;
                        }
                        function destroyer(e, t, i, a) {
                            a = once(a);
                            var s = !1;
                            e.on("close", function() {
                                s = !0;
                            }), void 0 === n && (n = r(7)), n(e, {
                                readable: t,
                                writable: i
                            }, function(e) {
                                if (e) return a(e);
                                s = !0, a();
                            });
                            var f = !1;
                            return function(t) {
                                if (!s && !f) {
                                    if (f = !0, isRequest(e)) return e.abort();
                                    if ("function" == typeof e.destroy) return e.destroy();
                                    a(t || new o("pipe"));
                                }
                            };
                        }
                        function call(e) {
                            e();
                        }
                        function pipe(e, t) {
                            return e.pipe(t);
                        }
                        function popCallback(e) {
                            return e.length && "function" == typeof e[e.length - 1] ? e.pop() : noop;
                        }
                        function pipeline() {
                            for(var i, e = arguments.length, t = Array(e), r = 0; r < e; r++)t[r] = arguments[r];
                            var n = popCallback(t);
                            if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new a("streams");
                            var o = t.map(function(e, r) {
                                var a = r < t.length - 1;
                                return destroyer(e, a, r > 0, function(e) {
                                    i || (i = e), e && o.forEach(call), a || (o.forEach(call), n(i));
                                });
                            });
                            return t.reduce(pipe);
                        }
                        e.exports = pipeline;
                    },
                    483: function(e, t, r) {
                        "use strict";
                        var n = r(349).q.ERR_INVALID_OPT_VALUE;
                        function highWaterMarkFrom(e, t, r) {
                            return null != e.highWaterMark ? e.highWaterMark : t ? e[r] : null;
                        }
                        function getHighWaterMark(e, t, r, i) {
                            var a = highWaterMarkFrom(t, i, r);
                            if (null != a) {
                                if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
                                    var o = i ? r : "highWaterMark";
                                    throw new n(o, a);
                                }
                                return Math.floor(a);
                            }
                            return e.objectMode ? 16 : 16384;
                        }
                        e.exports = {
                            getHighWaterMark: getHighWaterMark
                        };
                    },
                    455: function(e, t, r) {
                        e.exports = r(781);
                    },
                    207: function(e, t, r) {
                        var n = r(300), i = n.Buffer;
                        function copyProps(e, t) {
                            for(var r in e)t[r] = e[r];
                        }
                        function SafeBuffer(e, t, r) {
                            return i(e, t, r);
                        }
                        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (copyProps(n, t), t.Buffer = SafeBuffer), SafeBuffer.prototype = Object.create(i.prototype), copyProps(i, SafeBuffer), SafeBuffer.from = function(e, t, r) {
                            if ("number" == typeof e) throw TypeError("Argument must not be a number");
                            return i(e, t, r);
                        }, SafeBuffer.alloc = function(e, t, r) {
                            if ("number" != typeof e) throw TypeError("Argument must be a number");
                            var n = i(e);
                            return void 0 !== t ? "string" == typeof r ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
                        }, SafeBuffer.allocUnsafe = function(e) {
                            if ("number" != typeof e) throw TypeError("Argument must be a number");
                            return i(e);
                        }, SafeBuffer.allocUnsafeSlow = function(e) {
                            if ("number" != typeof e) throw TypeError("Argument must be a number");
                            return n.SlowBuffer(e);
                        };
                    },
                    552: function(e, t, r) {
                        e.exports = Stream;
                        var n = r(361).EventEmitter;
                        function Stream() {
                            n.call(this);
                        }
                        r(140)(Stream, n), Stream.Readable = r(787), Stream.Writable = r(513), Stream.Duplex = r(716), Stream.Transform = r(551), Stream.PassThrough = r(788), Stream.finished = r(7), Stream.pipeline = r(522), Stream.Stream = Stream, Stream.prototype.pipe = function(e, t) {
                            var r = this;
                            function ondata(t) {
                                e.writable && !1 === e.write(t) && r.pause && r.pause();
                            }
                            function ondrain() {
                                r.readable && r.resume && r.resume();
                            }
                            r.on("data", ondata), e.on("drain", ondrain), e._isStdio || t && !1 === t.end || (r.on("end", onend), r.on("close", onclose));
                            var i = !1;
                            function onend() {
                                i || (i = !0, e.end());
                            }
                            function onclose() {
                                i || (i = !0, "function" == typeof e.destroy && e.destroy());
                            }
                            function onerror(e) {
                                if (cleanup(), 0 === n.listenerCount(this, "error")) throw e;
                            }
                            function cleanup() {
                                r.removeListener("data", ondata), e.removeListener("drain", ondrain), r.removeListener("end", onend), r.removeListener("close", onclose), r.removeListener("error", onerror), e.removeListener("error", onerror), r.removeListener("end", cleanup), r.removeListener("close", cleanup), e.removeListener("close", cleanup);
                            }
                            return r.on("error", onerror), e.on("error", onerror), r.on("end", cleanup), r.on("close", cleanup), e.on("close", cleanup), e.emit("pipe", r), e;
                        };
                    },
                    862: function(e, t, r) {
                        "use strict";
                        var n = r(207).Buffer, i = n.isEncoding || function(e) {
                            switch((e = "" + e) && e.toLowerCase()){
                                case "hex":
                                case "utf8":
                                case "utf-8":
                                case "ascii":
                                case "binary":
                                case "base64":
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                case "raw":
                                    return !0;
                                default:
                                    return !1;
                            }
                        };
                        function _normalizeEncoding(e) {
                            var t;
                            if (!e) return "utf8";
                            for(;;)switch(e){
                                case "utf8":
                                case "utf-8":
                                    return "utf8";
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    return "utf16le";
                                case "latin1":
                                case "binary":
                                    return "latin1";
                                case "base64":
                                case "ascii":
                                case "hex":
                                    return e;
                                default:
                                    if (t) return;
                                    e = ("" + e).toLowerCase(), t = !0;
                            }
                        }
                        function normalizeEncoding(e) {
                            var t = _normalizeEncoding(e);
                            if ("string" != typeof t && (n.isEncoding === i || !i(e))) throw Error("Unknown encoding: " + e);
                            return t || e;
                        }
                        function StringDecoder(e) {
                            var t;
                            switch(this.encoding = normalizeEncoding(e), this.encoding){
                                case "utf16le":
                                    this.text = utf16Text, this.end = utf16End, t = 4;
                                    break;
                                case "utf8":
                                    this.fillLast = utf8FillLast, t = 4;
                                    break;
                                case "base64":
                                    this.text = base64Text, this.end = base64End, t = 3;
                                    break;
                                default:
                                    this.write = simpleWrite, this.end = simpleEnd;
                                    return;
                            }
                            this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t);
                        }
                        function utf8CheckByte(e) {
                            return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2;
                        }
                        function utf8CheckIncomplete(e, t, r) {
                            var n = t.length - 1;
                            if (n < r) return 0;
                            var i = utf8CheckByte(t[n]);
                            return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || -2 === i ? 0 : (i = utf8CheckByte(t[n])) >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || -2 === i ? 0 : (i = utf8CheckByte(t[n])) >= 0 ? (i > 0 && (2 === i ? i = 0 : e.lastNeed = i - 3), i) : 0;
                        }
                        function utf8CheckExtraBytes(e, t, r) {
                            if ((192 & t[0]) != 128) return e.lastNeed = 0, "";
                            if (e.lastNeed > 1 && t.length > 1) {
                                if ((192 & t[1]) != 128) return e.lastNeed = 1, "";
                                if (e.lastNeed > 2 && t.length > 2 && (192 & t[2]) != 128) return e.lastNeed = 2, "";
                            }
                        }
                        function utf8FillLast(e) {
                            var t = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, e, t);
                            return void 0 !== r ? r : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length);
                        }
                        function utf8Text(e, t) {
                            var r = utf8CheckIncomplete(this, e, t);
                            if (!this.lastNeed) return e.toString("utf8", t);
                            this.lastTotal = r;
                            var n = e.length - (r - this.lastNeed);
                            return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
                        }
                        function utf8End(e) {
                            var t = e && e.length ? this.write(e) : "";
                            return this.lastNeed ? t + "" : t;
                        }
                        function utf16Text(e, t) {
                            if ((e.length - t) % 2 == 0) {
                                var r = e.toString("utf16le", t);
                                if (r) {
                                    var n = r.charCodeAt(r.length - 1);
                                    if (n >= 55296 && n <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
                                }
                                return r;
                            }
                            return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
                        }
                        function utf16End(e) {
                            var t = e && e.length ? this.write(e) : "";
                            if (this.lastNeed) {
                                var r = this.lastTotal - this.lastNeed;
                                return t + this.lastChar.toString("utf16le", 0, r);
                            }
                            return t;
                        }
                        function base64Text(e, t) {
                            var r = (e.length - t) % 3;
                            return 0 === r ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
                        }
                        function base64End(e) {
                            var t = e && e.length ? this.write(e) : "";
                            return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
                        }
                        function simpleWrite(e) {
                            return e.toString(this.encoding);
                        }
                        function simpleEnd(e) {
                            return e && e.length ? this.write(e) : "";
                        }
                        t.s = StringDecoder, StringDecoder.prototype.write = function(e) {
                            var t, r;
                            if (0 === e.length) return "";
                            if (this.lastNeed) {
                                if (void 0 === (t = this.fillLast(e))) return "";
                                r = this.lastNeed, this.lastNeed = 0;
                            } else r = 0;
                            return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
                        }, StringDecoder.prototype.end = utf8End, StringDecoder.prototype.text = utf8Text, StringDecoder.prototype.fillLast = function(e) {
                            if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
                            e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
                        };
                    },
                    777: function(e) {
                        function deprecate(e, t) {
                            if (config("noDeprecation")) return e;
                            var r = !1;
                            function deprecated() {
                                if (!r) {
                                    if (config("throwDeprecation")) throw Error(t);
                                    config("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
                                }
                                return e.apply(this, arguments);
                            }
                            return deprecated;
                        }
                        function config(e) {
                            try {
                                if (!__webpack_require__.g.localStorage) return !1;
                            } catch (e1) {
                                return !1;
                            }
                            var t = __webpack_require__.g.localStorage[e];
                            return null != t && "true" === String(t).toLowerCase();
                        }
                        e.exports = deprecate;
                    },
                    300: function(e) {
                        "use strict";
                        e.exports = __webpack_require__(8764);
                    },
                    361: function(e) {
                        "use strict";
                        e.exports = __webpack_require__(7187);
                    },
                    781: function(e) {
                        "use strict";
                        e.exports = __webpack_require__(7187).EventEmitter;
                    },
                    837: function(e) {
                        "use strict";
                        e.exports = __webpack_require__(9539);
                    }
                }, t = {};
                function __nccwpck_require__1(r) {
                    var n = t[r];
                    if (void 0 !== n) return n.exports;
                    var i = t[r] = {
                        exports: {}
                    }, a = !0;
                    try {
                        e[r](i, i.exports, __nccwpck_require__1), a = !1;
                    } finally{
                        a && delete t[r];
                    }
                    return i.exports;
                }
                __nccwpck_require__1.ab = __dirname + "/";
                var r = __nccwpck_require__1(552);
                module.exports = r;
            }();
        },
        1951: function(module) {
            var __webpack_modules__, __webpack_exports__, __dirname = "/";
            __webpack_modules__ = {
                965: function(__unused_webpack_module, exports) {
                    var indexOf = function(e, t) {
                        if (e.indexOf) return e.indexOf(t);
                        for(var r = 0; r < e.length; r++)if (e[r] === t) return r;
                        return -1;
                    }, Object_keys = function(e) {
                        if (Object.keys) return Object.keys(e);
                        var t = [];
                        for(var r in e)t.push(r);
                        return t;
                    }, forEach = function(e, t) {
                        if (e.forEach) return e.forEach(t);
                        for(var r = 0; r < e.length; r++)t(e[r], r, e);
                    }, defineProp = function() {
                        try {
                            return Object.defineProperty({}, "_", {}), function(e, t, r) {
                                Object.defineProperty(e, t, {
                                    writable: !0,
                                    enumerable: !1,
                                    configurable: !0,
                                    value: r
                                });
                            };
                        } catch (e) {
                            return function(e, t, r) {
                                e[t] = r;
                            };
                        }
                    }(), globals = [
                        "Array",
                        "Boolean",
                        "Date",
                        "Error",
                        "EvalError",
                        "Function",
                        "Infinity",
                        "JSON",
                        "Math",
                        "NaN",
                        "Number",
                        "Object",
                        "RangeError",
                        "ReferenceError",
                        "RegExp",
                        "String",
                        "SyntaxError",
                        "TypeError",
                        "URIError",
                        "decodeURI",
                        "decodeURIComponent",
                        "encodeURI",
                        "encodeURIComponent",
                        "escape",
                        "eval",
                        "isFinite",
                        "isNaN",
                        "parseFloat",
                        "parseInt",
                        "undefined",
                        "unescape"
                    ];
                    function Context() {}
                    Context.prototype = {};
                    var Script = exports.Script = function(e) {
                        if (!(this instanceof Script)) return new Script(e);
                        this.code = e;
                    };
                    Script.prototype.runInContext = function(e) {
                        if (!(e instanceof Context)) throw TypeError("needs a 'context' argument.");
                        var t = document.createElement("iframe");
                        t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
                        var r = t.contentWindow, n = r.eval, o = r.execScript;
                        !n && o && (o.call(r, "null"), n = r.eval), forEach(Object_keys(e), function(t) {
                            r[t] = e[t];
                        }), forEach(globals, function(t) {
                            e[t] && (r[t] = e[t]);
                        });
                        var c = Object_keys(r), i = n.call(r, this.code);
                        return forEach(Object_keys(r), function(t) {
                            (t in e || -1 === indexOf(c, t)) && (e[t] = r[t]);
                        }), forEach(globals, function(t) {
                            t in e || defineProp(e, t, r[t]);
                        }), document.body.removeChild(t), i;
                    }, Script.prototype.runInThisContext = function() {
                        return eval(this.code);
                    }, Script.prototype.runInNewContext = function(e) {
                        var t = Script.createContext(e), r = this.runInContext(t);
                        return e && forEach(Object_keys(t), function(r) {
                            e[r] = t[r];
                        }), r;
                    }, forEach(Object_keys(Script.prototype), function(e) {
                        exports[e] = Script[e] = function(t) {
                            var r = Script(t);
                            return r[e].apply(r, [].slice.call(arguments, 1));
                        };
                    }), exports.isContext = function(e) {
                        return e instanceof Context;
                    }, exports.createScript = function(e) {
                        return exports.Script(e);
                    }, exports.createContext = Script.createContext = function(e) {
                        var t = new Context;
                        return "object" == typeof e && forEach(Object_keys(e), function(r) {
                            t[r] = e[r];
                        }), t;
                    };
                }
            }, "undefined" != typeof __nccwpck_require__ && (__nccwpck_require__.ab = __dirname + "/"), __webpack_exports__ = {}, __webpack_modules__[965](0, __webpack_exports__), module.exports = __webpack_exports__;
        },
        4375: function(module, __unused_webpack_exports, __webpack_require__) {
            let promise;
            module.exports = 'function' == typeof queueMicrotask ? queueMicrotask.bind('undefined' != typeof window ? window : __webpack_require__.g) : (cb)=>(promise || (promise = Promise.resolve())).then(cb).catch((err)=>setTimeout(()=>{
                        throw err;
                    }, 0));
        },
        9180: function(module, __unused_webpack_exports, __webpack_require__) {
            window.global = window, __webpack_require__.g.fetch = window.fetch, module.exports.Buffer = __webpack_require__(8764).Buffer;
        },
        497: function(__unused_webpack_module, exports, __webpack_require__) {
            exports.wasm2json = __webpack_require__(3195), exports.json2wasm = __webpack_require__(4747), exports.text2json = __webpack_require__(9837), exports.Iterator = __webpack_require__(3804);
        },
        3804: function(module, __unused_webpack_exports, __webpack_require__) {
            const Buffer = __webpack_require__(1415).Buffer, leb128 = __webpack_require__(5548).unsigned, wasm2json = __webpack_require__(3195), Pipe = __webpack_require__(825), SECTIONS = [
                'custom',
                'type',
                'import',
                'function',
                'table',
                'memory',
                'global',
                'export',
                'start',
                'element',
                'code',
                'data', 
            ];
            module.exports = class {
                constructor(wasm){
                    this._wasm = wasm, this._sections = [], this._modified = !1;
                }
                get wasm() {
                    return this._modified && (this._wasm = Buffer.concat(this._sections.concat(this._pipe.buffer)), this._modified = !1), this._wasm;
                }
                *[Symbol.iterator]() {
                    for(this._pipe = new Pipe(this._wasm), this._sections = [
                        this._pipe.read(8)
                    ]; !this._pipe.end;){
                        const start = this._pipe.bytesRead, sectionType = this._pipe.read(1)[0], size = Number(leb128.read(this._pipe)), body = this._pipe.read(size), end = this._pipe.bytesRead, section = this._wasm.slice(start, end), index = this._sections.push(section) - 1;
                        yield new Section(sectionType, body, this, index);
                    }
                }
                _update(index, data) {
                    this._modified = !0, this._sections[index] = data;
                }
            };
            class Section {
                constructor(sectionType, section, it, index){
                    this._it = it, this._index = index, this.type = SECTIONS[sectionType], this._type = sectionType, this._section = section;
                    const pipe = new Pipe(section);
                    'custom' !== this.type && (this.count = Number(leb128.read(pipe))), this._body = pipe.buffer;
                }
                toJSON() {
                    return wasm2json.sectionParsers[this.type](new Pipe(this._section));
                }
                appendEntries(entries) {
                    this.count += entries.length, this._body = Buffer.concat([
                        this._body
                    ].concat(entries));
                    const bodyAndCount = Buffer.concat([
                        leb128.encode(this.count),
                        this._body
                    ]);
                    this._it._update(this._index, Buffer.concat([
                        Buffer.from([
                            this._type
                        ]),
                        leb128.encode(bodyAndCount.length),
                        bodyAndCount, 
                    ]));
                }
            }
        },
        4747: function(module, __unused_webpack_exports, __webpack_require__) {
            const Buffer = __webpack_require__(1415).Buffer, leb = __webpack_require__(5548), Stream = __webpack_require__(825), OP_IMMEDIATES = __webpack_require__(8575), _exports = module.exports = (json)=>_exports.generate(json).buffer, LANGUAGE_TYPES = _exports.LANGUAGE_TYPES = {
                i32: 0x7f,
                i64: 0x7e,
                f32: 0x7d,
                f64: 0x7c,
                anyFunc: 0x70,
                func: 0x60,
                block_type: 0x40
            }, EXTERNAL_KIND = _exports.EXTERNAL_KIND = {
                function: 0,
                table: 1,
                memory: 2,
                global: 3
            }, SECTION_IDS = _exports.SECTION_IDS = {
                custom: 0,
                type: 1,
                import: 2,
                function: 3,
                table: 4,
                memory: 5,
                global: 6,
                export: 7,
                start: 8,
                element: 9,
                code: 10,
                data: 11
            }, OPCODES = _exports.OPCODES = {
                unreachable: 0x0,
                nop: 0x1,
                block: 0x2,
                loop: 0x3,
                if: 0x4,
                else: 0x5,
                end: 0xb,
                br: 0xc,
                br_if: 0xd,
                br_table: 0xe,
                return: 0xf,
                call: 0x10,
                call_indirect: 0x11,
                drop: 0x1a,
                select: 0x1b,
                get_local: 0x20,
                set_local: 0x21,
                tee_local: 0x22,
                get_global: 0x23,
                set_global: 0x24,
                'i32.load': 0x28,
                'i64.load': 0x29,
                'f32.load': 0x2a,
                'f64.load': 0x2b,
                'i32.load8_s': 0x2c,
                'i32.load8_u': 0x2d,
                'i32.load16_s': 0x2e,
                'i32.load16_u': 0x2f,
                'i64.load8_s': 0x30,
                'i64.load8_u': 0x31,
                'i64.load16_s': 0x32,
                'i64.load16_u': 0x33,
                'i64.load32_s': 0x34,
                'i64.load32_u': 0x35,
                'i32.store': 0x36,
                'i64.store': 0x37,
                'f32.store': 0x38,
                'f64.store': 0x39,
                'i32.store8': 0x3a,
                'i32.store16': 0x3b,
                'i64.store8': 0x3c,
                'i64.store16': 0x3d,
                'i64.store32': 0x3e,
                current_memory: 0x3f,
                grow_memory: 0x40,
                'i32.const': 0x41,
                'i64.const': 0x42,
                'f32.const': 0x43,
                'f64.const': 0x44,
                'i32.eqz': 0x45,
                'i32.eq': 0x46,
                'i32.ne': 0x47,
                'i32.lt_s': 0x48,
                'i32.lt_u': 0x49,
                'i32.gt_s': 0x4a,
                'i32.gt_u': 0x4b,
                'i32.le_s': 0x4c,
                'i32.le_u': 0x4d,
                'i32.ge_s': 0x4e,
                'i32.ge_u': 0x4f,
                'i64.eqz': 0x50,
                'i64.eq': 0x51,
                'i64.ne': 0x52,
                'i64.lt_s': 0x53,
                'i64.lt_u': 0x54,
                'i64.gt_s': 0x55,
                'i64.gt_u': 0x56,
                'i64.le_s': 0x57,
                'i64.le_u': 0x58,
                'i64.ge_s': 0x59,
                'i64.ge_u': 0x5a,
                'f32.eq': 0x5b,
                'f32.ne': 0x5c,
                'f32.lt': 0x5d,
                'f32.gt': 0x5e,
                'f32.le': 0x5f,
                'f32.ge': 0x60,
                'f64.eq': 0x61,
                'f64.ne': 0x62,
                'f64.lt': 0x63,
                'f64.gt': 0x64,
                'f64.le': 0x65,
                'f64.ge': 0x66,
                'i32.clz': 0x67,
                'i32.ctz': 0x68,
                'i32.popcnt': 0x69,
                'i32.add': 0x6a,
                'i32.sub': 0x6b,
                'i32.mul': 0x6c,
                'i32.div_s': 0x6d,
                'i32.div_u': 0x6e,
                'i32.rem_s': 0x6f,
                'i32.rem_u': 0x70,
                'i32.and': 0x71,
                'i32.or': 0x72,
                'i32.xor': 0x73,
                'i32.shl': 0x74,
                'i32.shr_s': 0x75,
                'i32.shr_u': 0x76,
                'i32.rotl': 0x77,
                'i32.rotr': 0x78,
                'i64.clz': 0x79,
                'i64.ctz': 0x7a,
                'i64.popcnt': 0x7b,
                'i64.add': 0x7c,
                'i64.sub': 0x7d,
                'i64.mul': 0x7e,
                'i64.div_s': 0x7f,
                'i64.div_u': 0x80,
                'i64.rem_s': 0x81,
                'i64.rem_u': 0x82,
                'i64.and': 0x83,
                'i64.or': 0x84,
                'i64.xor': 0x85,
                'i64.shl': 0x86,
                'i64.shr_s': 0x87,
                'i64.shr_u': 0x88,
                'i64.rotl': 0x89,
                'i64.rotr': 0x8a,
                'f32.abs': 0x8b,
                'f32.neg': 0x8c,
                'f32.ceil': 0x8d,
                'f32.floor': 0x8e,
                'f32.trunc': 0x8f,
                'f32.nearest': 0x90,
                'f32.sqrt': 0x91,
                'f32.add': 0x92,
                'f32.sub': 0x93,
                'f32.mul': 0x94,
                'f32.div': 0x95,
                'f32.min': 0x96,
                'f32.max': 0x97,
                'f32.copysign': 0x98,
                'f64.abs': 0x99,
                'f64.neg': 0x9a,
                'f64.ceil': 0x9b,
                'f64.floor': 0x9c,
                'f64.trunc': 0x9d,
                'f64.nearest': 0x9e,
                'f64.sqrt': 0x9f,
                'f64.add': 0xa0,
                'f64.sub': 0xa1,
                'f64.mul': 0xa2,
                'f64.div': 0xa3,
                'f64.min': 0xa4,
                'f64.max': 0xa5,
                'f64.copysign': 0xa6,
                'i32.wrap/i64': 0xa7,
                'i32.trunc_s/f32': 0xa8,
                'i32.trunc_u/f32': 0xa9,
                'i32.trunc_s/f64': 0xaa,
                'i32.trunc_u/f64': 0xab,
                'i64.extend_s/i32': 0xac,
                'i64.extend_u/i32': 0xad,
                'i64.trunc_s/f32': 0xae,
                'i64.trunc_u/f32': 0xaf,
                'i64.trunc_s/f64': 0xb0,
                'i64.trunc_u/f64': 0xb1,
                'f32.convert_s/i32': 0xb2,
                'f32.convert_u/i32': 0xb3,
                'f32.convert_s/i64': 0xb4,
                'f32.convert_u/i64': 0xb5,
                'f32.demote/f64': 0xb6,
                'f64.convert_s/i32': 0xb7,
                'f64.convert_u/i32': 0xb8,
                'f64.convert_s/i64': 0xb9,
                'f64.convert_u/i64': 0xba,
                'f64.promote/f32': 0xbb,
                'i32.reinterpret/f32': 0xbc,
                'i64.reinterpret/f64': 0xbd,
                'f32.reinterpret/i32': 0xbe,
                'f64.reinterpret/i64': 0xbf
            };
            _exports.typeGenerators = {
                function: (json, stream)=>{
                    leb.unsigned.write(json, stream);
                },
                table: (json, stream)=>{
                    stream.write([
                        LANGUAGE_TYPES[json.elementType]
                    ]), _exports.typeGenerators.memory(json.limits, stream);
                },
                global: (json, stream)=>{
                    stream.write([
                        LANGUAGE_TYPES[json.contentType]
                    ]), stream.write([
                        json.mutability
                    ]);
                },
                memory: (json, stream)=>{
                    leb.unsigned.write(Number(void 0 !== json.maximum), stream), leb.unsigned.write(json.intial, stream), void 0 !== json.maximum && leb.unsigned.write(json.maximum, stream);
                },
                initExpr: (json, stream)=>{
                    _exports.generateOp(json, stream), _exports.generateOp({
                        name: 'end',
                        type: 'void'
                    }, stream);
                }
            }, _exports.immediataryGenerators = {
                varuint1: (json, stream)=>(stream.write([
                        json
                    ]), stream),
                varuint32: (json, stream)=>(leb.unsigned.write(json, stream), stream),
                varint32: (json, stream)=>(leb.signed.write(json, stream), stream),
                varint64: (json, stream)=>(leb.signed.write(json, stream), stream),
                uint32: (json, stream)=>(stream.write(json), stream),
                uint64: (json, stream)=>(stream.write(json), stream),
                block_type: (json, stream)=>(stream.write([
                        LANGUAGE_TYPES[json]
                    ]), stream),
                br_table: (json, stream)=>{
                    for (let target of (leb.unsigned.write(json.targets.length, stream), json.targets))leb.unsigned.write(target, stream);
                    return leb.unsigned.write(json.defaultTarget, stream), stream;
                },
                call_indirect: (json, stream)=>(leb.unsigned.write(json.index, stream), stream.write([
                        json.reserved
                    ]), stream),
                memory_immediate: (json, stream)=>(leb.unsigned.write(json.flags, stream), leb.unsigned.write(json.offset, stream), stream)
            };
            const entryGenerators = {
                type: (entry, stream = new Stream())=>{
                    stream.write([
                        LANGUAGE_TYPES[entry.form]
                    ]);
                    const len = entry.params.length;
                    return leb.unsigned.write(len, stream), 0 !== len && stream.write(entry.params.map((type)=>LANGUAGE_TYPES[type])), stream.write([
                        entry.return_type ? 1 : 0
                    ]), entry.return_type && stream.write([
                        LANGUAGE_TYPES[entry.return_type]
                    ]), stream.buffer;
                },
                import: (entry, stream = new Stream())=>{
                    leb.unsigned.write(entry.moduleStr.length, stream), stream.write(entry.moduleStr), leb.unsigned.write(entry.fieldStr.length, stream), stream.write(entry.fieldStr), stream.write([
                        EXTERNAL_KIND[entry.kind]
                    ]), _exports.typeGenerators[entry.kind](entry.type, stream);
                },
                function: (entry, stream = new Stream())=>(leb.unsigned.write(entry, stream), stream.buffer),
                table: _exports.typeGenerators.table,
                global: (entry, stream = new Stream())=>(_exports.typeGenerators.global(entry.type, stream), _exports.typeGenerators.initExpr(entry.init, stream), stream),
                memory: _exports.typeGenerators.memory,
                export: (entry, stream = new Stream())=>{
                    const fieldStr = Buffer.from(entry.field_str), strLen = fieldStr.length;
                    return leb.unsigned.write(strLen, stream), stream.write(fieldStr), stream.write([
                        EXTERNAL_KIND[entry.kind]
                    ]), leb.unsigned.write(entry.index, stream), stream;
                },
                element: (entry, stream = new Stream())=>{
                    for (let elem of (leb.unsigned.write(entry.index, stream), _exports.typeGenerators.initExpr(entry.offset, stream), leb.unsigned.write(entry.elements.length, stream), entry.elements))leb.unsigned.write(elem, stream);
                    return stream;
                },
                code: (entry, stream = new Stream())=>{
                    let codeStream = new Stream();
                    for (let local of (leb.unsigned.write(entry.locals.length, codeStream), entry.locals))leb.unsigned.write(local.count, codeStream), codeStream.write([
                        LANGUAGE_TYPES[local.type]
                    ]);
                    for (let op of entry.code)_exports.generateOp(op, codeStream);
                    return leb.unsigned.write(codeStream.bytesWrote, stream), stream.write(codeStream.buffer), stream;
                },
                data: (entry, stream = new Stream())=>(leb.unsigned.write(entry.index, stream), _exports.typeGenerators.initExpr(entry.offset, stream), leb.unsigned.write(entry.data.length, stream), stream.write(entry.data), stream)
            };
            _exports.entryGenerators = entryGenerators, _exports.generateSection = function(json, stream = new Stream()) {
                const name = json.name, payload = new Stream();
                if (stream.write([
                    SECTION_IDS[name]
                ]), 'custom' === name) leb.unsigned.write(json.sectionName.length, payload), payload.write(json.sectionName), payload.write(json.payload);
                else if ('start' === name) leb.unsigned.write(json.index, payload);
                else for (let entry of (leb.unsigned.write(json.entries.length, payload), json.entries))entryGenerators[name](entry, payload);
                return leb.unsigned.write(payload.bytesWrote, stream), stream.write(payload.buffer), stream;
            }, _exports.generate = (json, stream = new Stream())=>{
                const [preamble, ...rest] = json;
                for (let item of (_exports.generatePreramble(preamble, stream), rest))_exports.generateSection(item, stream);
                return stream;
            }, _exports.generatePreramble = (json, stream = new Stream())=>(stream.write(json.magic), stream.write(json.version), stream), _exports.generateOp = (json, stream = new Stream())=>{
                let name = json.name;
                void 0 !== json.return_type && (name = json.return_type + '.' + name), stream.write([
                    OPCODES[name]
                ]);
                const immediates = OP_IMMEDIATES['const' === json.name ? json.return_type : json.name];
                return immediates && _exports.immediataryGenerators[immediates](json.immediates, stream), stream;
            };
        },
        825: function(module, __unused_webpack_exports, __webpack_require__) {
            const Buffer = __webpack_require__(9509).Buffer;
            module.exports = class {
                constructor(buf = Buffer.from([])){
                    this.buffer = buf, this._bytesRead = 0, this._bytesWrote = 0;
                }
                read(num) {
                    this._bytesRead += num;
                    const data = this.buffer.slice(0, num);
                    return this.buffer = this.buffer.slice(num), data;
                }
                write(buf) {
                    buf = Buffer.from(buf), this._bytesWrote += buf.length, this.buffer = Buffer.concat([
                        this.buffer,
                        buf
                    ]);
                }
                get end() {
                    return !this.buffer.length;
                }
                get bytesRead() {
                    return this._bytesRead;
                }
                get bytesWrote() {
                    return this._bytesWrote;
                }
            };
        },
        1415: function(module, __unused_webpack_exports, __webpack_require__) {
            __webpack_require__.g.fetch = window.fetch, __webpack_require__(8764).Buffer;
        },
        9837: function(module, __unused_webpack_exports, __webpack_require__) {
            const immediates = __webpack_require__(8575);
            function immediataryParser(type, txt) {
                const json = {};
                switch(type){
                    case 'br_table':
                        const dests = [];
                        for(;;){
                            let dest = txt[0];
                            if (isNaN(dest)) break;
                            txt.shift(), dests.push(dest);
                        }
                        return dests;
                    case 'call_indirect':
                        return json.index = txt.shift(), json.reserved = 0, json;
                    case 'memory_immediate':
                        return json.flags = txt.shift(), json.offset = txt.shift(), json;
                    default:
                        return txt.shift();
                }
            }
            module.exports = (text)=>{
                const json = [], textArray = text.split(/\s|\n/);
                for(; textArray.length;){
                    const textOp = textArray.shift(), jsonOp = {};
                    let [type, name] = textOp.split('.');
                    void 0 === name ? name = type : jsonOp.return_type = type, jsonOp.name = name;
                    const immediate = immediates['const' === jsonOp.name ? jsonOp.return_type : jsonOp.name];
                    immediate && (jsonOp.immediates = immediataryParser(immediate, textArray)), json.push(jsonOp);
                }
                return json;
            };
        },
        3195: function(module, __unused_webpack_exports, __webpack_require__) {
            var Buffer = __webpack_require__(8764).Buffer;
            const leb = __webpack_require__(5548), Stream = __webpack_require__(825), OP_IMMEDIATES = __webpack_require__(8575), _exports = module.exports = (buf, filter)=>{
                const stream = new Stream(buf);
                return _exports.parse(stream, filter);
            }, LANGUAGE_TYPES = _exports.LANGUAGE_TYPES = {
                0x7f: 'i32',
                0x7e: 'i64',
                0x7d: 'f32',
                0x7c: 'f64',
                0x70: 'anyFunc',
                0x60: 'func',
                0x40: 'block_type'
            }, EXTERNAL_KIND = _exports.EXTERNAL_KIND = {
                0: 'function',
                1: 'table',
                2: 'memory',
                3: 'global'
            };
            _exports.parsePreramble = (stream)=>{
                const obj = {};
                return obj.name = 'preramble', obj.magic = [
                    ...stream.read(4)
                ], obj.version = [
                    ...stream.read(4)
                ], obj;
            }, _exports.parseSectionHeader = (stream)=>{
                const id = stream.read(1)[0], size = leb.unsigned.readBn(stream).toNumber();
                return {
                    id,
                    name: SECTION_IDS[id],
                    size
                };
            };
            const OPCODES = _exports.OPCODES = {
                0x0: 'unreachable',
                0x1: 'nop',
                0x2: 'block',
                0x3: 'loop',
                0x4: 'if',
                0x5: 'else',
                0xb: 'end',
                0xc: 'br',
                0xd: 'br_if',
                0xe: 'br_table',
                0xf: 'return',
                0x10: 'call',
                0x11: 'call_indirect',
                0x1a: 'drop',
                0x1b: 'select',
                0x20: 'get_local',
                0x21: 'set_local',
                0x22: 'tee_local',
                0x23: 'get_global',
                0x24: 'set_global',
                0x28: 'i32.load',
                0x29: 'i64.load',
                0x2a: 'f32.load',
                0x2b: 'f64.load',
                0x2c: 'i32.load8_s',
                0x2d: 'i32.load8_u',
                0x2e: 'i32.load16_s',
                0x2f: 'i32.load16_u',
                0x30: 'i64.load8_s',
                0x31: 'i64.load8_u',
                0x32: 'i64.load16_s',
                0x33: 'i64.load16_u',
                0x34: 'i64.load32_s',
                0x35: 'i64.load32_u',
                0x36: 'i32.store',
                0x37: 'i64.store',
                0x38: 'f32.store',
                0x39: 'f64.store',
                0x3a: 'i32.store8',
                0x3b: 'i32.store16',
                0x3c: 'i64.store8',
                0x3d: 'i64.store16',
                0x3e: 'i64.store32',
                0x3f: 'current_memory',
                0x40: 'grow_memory',
                0x41: 'i32.const',
                0x42: 'i64.const',
                0x43: 'f32.const',
                0x44: 'f64.const',
                0x45: 'i32.eqz',
                0x46: 'i32.eq',
                0x47: 'i32.ne',
                0x48: 'i32.lt_s',
                0x49: 'i32.lt_u',
                0x4a: 'i32.gt_s',
                0x4b: 'i32.gt_u',
                0x4c: 'i32.le_s',
                0x4d: 'i32.le_u',
                0x4e: 'i32.ge_s',
                0x4f: 'i32.ge_u',
                0x50: 'i64.eqz',
                0x51: 'i64.eq',
                0x52: 'i64.ne',
                0x53: 'i64.lt_s',
                0x54: 'i64.lt_u',
                0x55: 'i64.gt_s',
                0x56: 'i64.gt_u',
                0x57: 'i64.le_s',
                0x58: 'i64.le_u',
                0x59: 'i64.ge_s',
                0x5a: 'i64.ge_u',
                0x5b: 'f32.eq',
                0x5c: 'f32.ne',
                0x5d: 'f32.lt',
                0x5e: 'f32.gt',
                0x5f: 'f32.le',
                0x60: 'f32.ge',
                0x61: 'f64.eq',
                0x62: 'f64.ne',
                0x63: 'f64.lt',
                0x64: 'f64.gt',
                0x65: 'f64.le',
                0x66: 'f64.ge',
                0x67: 'i32.clz',
                0x68: 'i32.ctz',
                0x69: 'i32.popcnt',
                0x6a: 'i32.add',
                0x6b: 'i32.sub',
                0x6c: 'i32.mul',
                0x6d: 'i32.div_s',
                0x6e: 'i32.div_u',
                0x6f: 'i32.rem_s',
                0x70: 'i32.rem_u',
                0x71: 'i32.and',
                0x72: 'i32.or',
                0x73: 'i32.xor',
                0x74: 'i32.shl',
                0x75: 'i32.shr_s',
                0x76: 'i32.shr_u',
                0x77: 'i32.rotl',
                0x78: 'i32.rotr',
                0x79: 'i64.clz',
                0x7a: 'i64.ctz',
                0x7b: 'i64.popcnt',
                0x7c: 'i64.add',
                0x7d: 'i64.sub',
                0x7e: 'i64.mul',
                0x7f: 'i64.div_s',
                0x80: 'i64.div_u',
                0x81: 'i64.rem_s',
                0x82: 'i64.rem_u',
                0x83: 'i64.and',
                0x84: 'i64.or',
                0x85: 'i64.xor',
                0x86: 'i64.shl',
                0x87: 'i64.shr_s',
                0x88: 'i64.shr_u',
                0x89: 'i64.rotl',
                0x8a: 'i64.rotr',
                0x8b: 'f32.abs',
                0x8c: 'f32.neg',
                0x8d: 'f32.ceil',
                0x8e: 'f32.floor',
                0x8f: 'f32.trunc',
                0x90: 'f32.nearest',
                0x91: 'f32.sqrt',
                0x92: 'f32.add',
                0x93: 'f32.sub',
                0x94: 'f32.mul',
                0x95: 'f32.div',
                0x96: 'f32.min',
                0x97: 'f32.max',
                0x98: 'f32.copysign',
                0x99: 'f64.abs',
                0x9a: 'f64.neg',
                0x9b: 'f64.ceil',
                0x9c: 'f64.floor',
                0x9d: 'f64.trunc',
                0x9e: 'f64.nearest',
                0x9f: 'f64.sqrt',
                0xa0: 'f64.add',
                0xa1: 'f64.sub',
                0xa2: 'f64.mul',
                0xa3: 'f64.div',
                0xa4: 'f64.min',
                0xa5: 'f64.max',
                0xa6: 'f64.copysign',
                0xa7: 'i32.wrap/i64',
                0xa8: 'i32.trunc_s/f32',
                0xa9: 'i32.trunc_u/f32',
                0xaa: 'i32.trunc_s/f64',
                0xab: 'i32.trunc_u/f64',
                0xac: 'i64.extend_s/i32',
                0xad: 'i64.extend_u/i32',
                0xae: 'i64.trunc_s/f32',
                0xaf: 'i64.trunc_u/f32',
                0xb0: 'i64.trunc_s/f64',
                0xb1: 'i64.trunc_u/f64',
                0xb2: 'f32.convert_s/i32',
                0xb3: 'f32.convert_u/i32',
                0xb4: 'f32.convert_s/i64',
                0xb5: 'f32.convert_u/i64',
                0xb6: 'f32.demote/f64',
                0xb7: 'f64.convert_s/i32',
                0xb8: 'f64.convert_u/i32',
                0xb9: 'f64.convert_s/i64',
                0xba: 'f64.convert_u/i64',
                0xbb: 'f64.promote/f32',
                0xbc: 'i32.reinterpret/f32',
                0xbd: 'i64.reinterpret/f64',
                0xbe: 'f32.reinterpret/i32',
                0xbf: 'f64.reinterpret/i64'
            }, SECTION_IDS = _exports.SECTION_IDS = {
                0: 'custom',
                1: 'type',
                2: 'import',
                3: 'function',
                4: 'table',
                5: 'memory',
                6: 'global',
                7: 'export',
                8: 'start',
                9: 'element',
                10: 'code',
                11: 'data'
            };
            _exports.immediataryParsers = {
                varuint1: (stream)=>{
                    const int1 = stream.read(1)[0];
                    return int1;
                },
                varuint32: (stream)=>{
                    const int32 = leb.unsigned.read(stream);
                    return int32;
                },
                varint32: (stream)=>{
                    const int32 = leb.signed.read(stream);
                    return int32;
                },
                varint64: (stream)=>{
                    const int64 = leb.signed.read(stream);
                    return int64;
                },
                uint32: (stream)=>[
                        ...stream.read(4)
                    ],
                uint64: (stream)=>[
                        ...stream.read(8)
                    ],
                block_type: (stream)=>{
                    const type = stream.read(1)[0];
                    return LANGUAGE_TYPES[type];
                },
                br_table: (stream)=>{
                    const json = {
                        targets: []
                    }, num = leb.unsigned.readBn(stream).toNumber();
                    for(let i = 0; i < num; i++){
                        const target = leb.unsigned.readBn(stream).toNumber();
                        json.targets.push(target);
                    }
                    return json.defaultTarget = leb.unsigned.readBn(stream).toNumber(), json;
                },
                call_indirect: (stream)=>{
                    const json = {};
                    return json.index = leb.unsigned.readBn(stream).toNumber(), json.reserved = stream.read(1)[0], json;
                },
                memory_immediate: (stream)=>{
                    const json = {};
                    return json.flags = leb.unsigned.readBn(stream).toNumber(), json.offset = leb.unsigned.readBn(stream).toNumber(), json;
                }
            }, _exports.typeParsers = {
                function: (stream)=>leb.unsigned.readBn(stream).toNumber(),
                table: (stream)=>{
                    const entry = {}, type = stream.read(1)[0];
                    return entry.elementType = LANGUAGE_TYPES[type], entry.limits = _exports.typeParsers.memory(stream), entry;
                },
                global: (stream)=>{
                    const global = {};
                    let type = stream.read(1)[0];
                    return global.contentType = LANGUAGE_TYPES[type], global.mutability = stream.read(1)[0], global;
                },
                memory: (stream)=>{
                    const limits = {};
                    return limits.flags = leb.unsigned.readBn(stream).toNumber(), limits.intial = leb.unsigned.readBn(stream).toNumber(), 1 === limits.flags && (limits.maximum = leb.unsigned.readBn(stream).toNumber()), limits;
                },
                initExpr: (stream)=>{
                    const op = _exports.parseOp(stream);
                    return stream.read(1), op;
                }
            };
            const sectionParsers = _exports.sectionParsers = {
                custom: (stream, header)=>{
                    const json = {
                        name: 'custom'
                    }, section = new Stream(stream.read(header.size)), nameLen = leb.unsigned.readBn(section).toNumber(), name = section.read(nameLen);
                    return json.sectionName = Buffer.from(name).toString(), json.payload = [
                        ...section.buffer
                    ], json;
                },
                type: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'type',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        let type = stream.read(1)[0];
                        const entry = {
                            form: LANGUAGE_TYPES[type],
                            params: []
                        }, paramCount = leb.unsigned.readBn(stream).toNumber();
                        for(let q = 0; q < paramCount; q++){
                            const type1 = stream.read(1)[0];
                            entry.params.push(LANGUAGE_TYPES[type1]);
                        }
                        const numOfReturns = leb.unsigned.readBn(stream).toNumber();
                        numOfReturns && (type = stream.read(1)[0], entry.return_type = LANGUAGE_TYPES[type]), json.entries.push(entry);
                    }
                    return json;
                },
                import: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'import',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const entry = {}, moduleLen = leb.unsigned.readBn(stream).toNumber();
                        entry.moduleStr = Buffer.from(stream.read(moduleLen)).toString();
                        const fieldLen = leb.unsigned.readBn(stream).toNumber();
                        entry.fieldStr = Buffer.from(stream.read(fieldLen)).toString();
                        const kind = stream.read(1)[0];
                        entry.kind = EXTERNAL_KIND[kind], entry.type = _exports.typeParsers[entry.kind](stream), json.entries.push(entry);
                    }
                    return json;
                },
                function: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'function',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const entry = leb.unsigned.readBn(stream).toNumber();
                        json.entries.push(entry);
                    }
                    return json;
                },
                table: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'table',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const entry = _exports.typeParsers.table(stream);
                        json.entries.push(entry);
                    }
                    return json;
                },
                memory: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'memory',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const entry = _exports.typeParsers.memory(stream);
                        json.entries.push(entry);
                    }
                    return json;
                },
                global: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'global',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const entry = {};
                        entry.type = _exports.typeParsers.global(stream), entry.init = _exports.typeParsers.initExpr(stream), json.entries.push(entry);
                    }
                    return json;
                },
                export: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'export',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const strLength = leb.unsigned.readBn(stream).toNumber(), entry = {};
                        entry.field_str = Buffer.from(stream.read(strLength)).toString();
                        const kind = stream.read(1)[0];
                        entry.kind = EXTERNAL_KIND[kind], entry.index = leb.unsigned.readBn(stream).toNumber(), json.entries.push(entry);
                    }
                    return json;
                },
                start: (stream)=>{
                    const json = {
                        name: 'start'
                    };
                    return json.index = leb.unsigned.readBn(stream).toNumber(), json;
                },
                element: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'element',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const entry = {
                            elements: []
                        };
                        entry.index = leb.unsigned.readBn(stream).toNumber(), entry.offset = _exports.typeParsers.initExpr(stream);
                        const numElem = leb.unsigned.readBn(stream).toNumber();
                        for(let i1 = 0; i1 < numElem; i1++){
                            const elem = leb.unsigned.readBn(stream).toNumber();
                            entry.elements.push(elem);
                        }
                        json.entries.push(entry);
                    }
                    return json;
                },
                code: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'code',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const codeBody = {
                            locals: [],
                            code: []
                        };
                        let bodySize = leb.unsigned.readBn(stream).toNumber();
                        const endBytes = stream.bytesRead + bodySize, localCount = leb.unsigned.readBn(stream).toNumber();
                        for(let q = 0; q < localCount; q++){
                            const local = {};
                            local.count = leb.unsigned.readBn(stream).toNumber();
                            const type = stream.read(1)[0];
                            local.type = LANGUAGE_TYPES[type], codeBody.locals.push(local);
                        }
                        for(; stream.bytesRead < endBytes;){
                            const op = _exports.parseOp(stream);
                            codeBody.code.push(op);
                        }
                        json.entries.push(codeBody);
                    }
                    return json;
                },
                data: (stream)=>{
                    const numberOfEntries = leb.unsigned.readBn(stream).toNumber(), json = {
                        name: 'data',
                        entries: []
                    };
                    for(let i = 0; i < numberOfEntries; i++){
                        const entry = {};
                        entry.index = leb.unsigned.readBn(stream).toNumber(), entry.offset = _exports.typeParsers.initExpr(stream);
                        const segmentSize = leb.unsigned.readBn(stream).toNumber();
                        entry.data = [
                            ...stream.read(segmentSize)
                        ], json.entries.push(entry);
                    }
                    return json;
                }
            };
            _exports.parseOp = (stream)=>{
                const json = {}, op = stream.read(1)[0], fullName = OPCODES[op];
                let [type, name] = fullName.split('.');
                void 0 === name ? name = type : json.return_type = type, json.name = name;
                const immediates = OP_IMMEDIATES['const' === name ? type : name];
                return immediates && (json.immediates = _exports.immediataryParsers[immediates](stream)), json;
            }, _exports.parse = (stream, filter)=>{
                const preramble = _exports.parsePreramble(stream), json = [
                    preramble
                ];
                for(; !stream.end;){
                    const header = _exports.parseSectionHeader(stream);
                    json.push(sectionParsers[header.name](stream, header));
                }
                return json;
            };
        },
        8060: function(__unused_webpack_module, exports, __webpack_require__) {
            const toolkit = __webpack_require__(497), text2json = toolkit.text2json, SECTION_IDS = __webpack_require__(4747).SECTION_IDS, defaultCostTable = __webpack_require__(5936);
            function getCost(json, costTable = {}, defaultCost = 0) {
                let cost = 0;
                if (defaultCost = void 0 !== costTable.DEFAULT ? costTable.DEFAULT : 0, Array.isArray(json)) json.forEach((el)=>{
                    cost += getCost(el, costTable);
                });
                else if ('object' == typeof json) for(const propName in json){
                    const propCost = costTable[propName];
                    propCost && (cost += getCost(json[propName], propCost, defaultCost));
                }
                else cost = void 0 === costTable[json] ? defaultCost : costTable[json];
                return cost;
            }
            function meterCodeEntry(entry, costTable, meterFuncIndex, meterType, cost) {
                function meteringStatement(cost, meteringImportIndex) {
                    return text2json(`${meterType}.const ${cost} call ${meteringImportIndex}`);
                }
                function remapOp(op, funcIndex) {
                    'call' === op.name && op.immediates >= funcIndex && (op.immediates = (++op.immediates).toString());
                }
                function meterTheMeteringStatement() {
                    const code = meteringStatement(0, 0);
                    return code.reduce((sum, op)=>sum + getCost(op.name, costTable.code), 0);
                }
                const branchingOps = new Set([
                    'grow_memory',
                    'end',
                    'br',
                    'br_table',
                    'br_if',
                    'if',
                    'else',
                    'return',
                    'loop', 
                ]), meteringOverHead = meterTheMeteringStatement();
                let code = entry.code.slice(), meteredCode = [];
                for(cost += getCost(entry.locals, costTable.local); code.length;){
                    let i = 0;
                    for(;;){
                        const op = code[i++];
                        if (remapOp(op, meterFuncIndex), cost += getCost(op.name, costTable.code), branchingOps.has(op.name)) break;
                    }
                    0 !== cost && (cost += meteringOverHead, meteredCode = meteredCode.concat(meteringStatement(cost, meterFuncIndex))), meteredCode = meteredCode.concat(code.slice(0, i)), code = code.slice(i), cost = 0;
                }
                return entry.code = meteredCode, entry;
            }
            exports.meterJSON = (json, opts)=>{
                function findSection(module, sectionName) {
                    return module.find((section)=>section.name === sectionName);
                }
                function createSection(module, name) {
                    const newSectionId = SECTION_IDS[name];
                    for(let index in module){
                        const section = module[index], sectionId = SECTION_IDS[section.name];
                        if (sectionId && newSectionId < sectionId) {
                            module.splice(index, 0, {
                                name,
                                entries: []
                            });
                            return;
                        }
                    }
                }
                let funcIndex = 0, functionModule, typeModule, { costTable , moduleStr , fieldStr , meterType  } = opts;
                costTable || (costTable = defaultCostTable), moduleStr || (moduleStr = 'metering'), fieldStr || (fieldStr = 'usegas'), meterType || (meterType = 'i32'), findSection(json, 'type') || createSection(json, 'type'), findSection(json, 'import') || createSection(json, 'import');
                const importJson = {
                    moduleStr: moduleStr,
                    fieldStr: fieldStr,
                    kind: 'function'
                }, importType = {
                    form: 'func',
                    params: [
                        meterType
                    ]
                };
                for (let section of json = json.slice(0))switch((section = Object.assign(section)).name){
                    case 'type':
                        importJson.type = section.entries.push(importType) - 1, typeModule = section;
                        break;
                    case 'function':
                        functionModule = section;
                        break;
                    case 'import':
                        for (const entry of section.entries){
                            if (entry.moduleStr === moduleStr && entry.fieldStr === fieldStr) throw Error('importing metering function is not allowed');
                            'function' === entry.kind && funcIndex++;
                        }
                        section.entries.push(importJson);
                        break;
                    case 'export':
                        for (const entry1 of section.entries)'function' === entry1.kind && entry1.index >= funcIndex && entry1.index++;
                        break;
                    case 'element':
                        for (const entry2 of section.entries)entry2.elements = entry2.elements.map((el)=>el >= funcIndex ? ++el : el);
                        break;
                    case 'start':
                        section.index >= funcIndex && section.index++;
                        break;
                    case 'code':
                        for(const i in section.entries){
                            const entry3 = section.entries[i], typeIndex = functionModule.entries[i], type = typeModule.entries[typeIndex], cost = getCost(type, costTable.type);
                            meterCodeEntry(entry3, costTable.code, funcIndex, meterType, cost);
                        }
                }
                return json;
            }, exports.meterWASM = (wasm, opts = {})=>{
                let json = toolkit.wasm2json(wasm);
                return json = exports.meterJSON(json, opts), toolkit.json2wasm(json);
            };
        },
        9967: function(module, __unused_webpack_exports, __webpack_require__) {
            module.exports = runParallelLimit;
            const queueMicrotask1 = __webpack_require__(4375);
            function runParallelLimit(tasks, limit, cb) {
                if ('number' != typeof limit) throw Error('second argument must be a Number');
                let results, len, pending, keys, isErrored, isSync = !0, next;
                function done(err) {
                    function end() {
                        cb && cb(err, results), cb = null;
                    }
                    isSync ? queueMicrotask1(end) : end();
                }
                function each(i, err, result) {
                    if (results[i] = result, err && (isErrored = !0), 0 == --pending || err) done(err);
                    else if (!isErrored && next < len) {
                        let key;
                        keys ? (key = keys[next], next += 1, tasks[key](function(err, result) {
                            each(key, err, result);
                        })) : (key = next, next += 1, tasks[key](function(err, result) {
                            each(key, err, result);
                        }));
                    }
                }
                Array.isArray(tasks) ? (results = [], pending = len = tasks.length) : (keys = Object.keys(tasks), results = {}, pending = len = keys.length), next = limit, pending ? keys ? keys.some(function(key, i) {
                    return tasks[key](function(err, result) {
                        each(key, err, result);
                    }), i === limit - 1;
                }) : tasks.some(function(task, i) {
                    return task(function(err, result) {
                        each(i, err, result);
                    }), i === limit - 1;
                }) : done(null), isSync = !1;
            }
        },
        9509: function(module, exports, __webpack_require__) {
            var buffer = __webpack_require__(8764), Buffer = buffer.Buffer;
            function copyProps(src, dst) {
                for(var key in src)dst[key] = src[key];
            }
            function SafeBuffer(arg, encodingOrOffset, length) {
                return Buffer(arg, encodingOrOffset, length);
            }
            Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow ? module.exports = buffer : (copyProps(buffer, exports), exports.Buffer = SafeBuffer), SafeBuffer.prototype = Object.create(Buffer.prototype), copyProps(Buffer, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
                if ('number' == typeof arg) throw TypeError('Argument must not be a number');
                return Buffer(arg, encodingOrOffset, length);
            }, SafeBuffer.alloc = function(size, fill, encoding) {
                if ('number' != typeof size) throw TypeError('Argument must be a number');
                var buf = Buffer(size);
                return void 0 !== fill ? 'string' == typeof encoding ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), buf;
            }, SafeBuffer.allocUnsafe = function(size) {
                if ('number' != typeof size) throw TypeError('Argument must be a number');
                return Buffer(size);
            }, SafeBuffer.allocUnsafeSlow = function(size) {
                if ('number' != typeof size) throw TypeError('Argument must be a number');
                return buffer.SlowBuffer(size);
            };
        },
        7668: function(module, exports) {
            "use strict";
            const stringify = configure();
            stringify.configure = configure, stringify.stringify = stringify, stringify.default = stringify, exports.stringify = stringify, exports.configure = configure, module.exports = stringify;
            const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/, strEscapeSequencesReplacer = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g, meta = [
                '\\u0000',
                '\\u0001',
                '\\u0002',
                '\\u0003',
                '\\u0004',
                '\\u0005',
                '\\u0006',
                '\\u0007',
                '\\b',
                '\\t',
                '\\n',
                '\\u000b',
                '\\f',
                '\\r',
                '\\u000e',
                '\\u000f',
                '\\u0010',
                '\\u0011',
                '\\u0012',
                '\\u0013',
                '\\u0014',
                '\\u0015',
                '\\u0016',
                '\\u0017',
                '\\u0018',
                '\\u0019',
                '\\u001a',
                '\\u001b',
                '\\u001c',
                '\\u001d',
                '\\u001e',
                '\\u001f',
                '',
                '',
                '\\"',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '\\\\'
            ];
            function escapeFn(str) {
                if (2 === str.length) {
                    const charCode = str.charCodeAt(1);
                    return `${str[0]}\\u${charCode.toString(16)}`;
                }
                const charCode1 = str.charCodeAt(0);
                return meta.length > charCode1 ? meta[charCode1] : `\\u${charCode1.toString(16)}`;
            }
            function strEscape(str) {
                if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) return str;
                if (str.length > 100) return str.replace(strEscapeSequencesReplacer, escapeFn);
                let result = '', last = 0;
                for(let i = 0; i < str.length; i++){
                    const point = str.charCodeAt(i);
                    if (34 === point || 92 === point || point < 32) result += `${str.slice(last, i)}${meta[point]}`, last = i + 1;
                    else if (point >= 0xd800 && point <= 0xdfff) {
                        if (point <= 0xdbff && i + 1 < str.length) {
                            const point1 = str.charCodeAt(i + 1);
                            if (point1 >= 0xdc00 && point1 <= 0xdfff) {
                                i++;
                                continue;
                            }
                        }
                        result += `${str.slice(last, i)}${`\\u${point.toString(16)}`}`, last = i + 1;
                    }
                }
                return result + str.slice(last);
            }
            function insertSort(array) {
                if (array.length > 2e2) return array.sort();
                for(let i = 1; i < array.length; i++){
                    const currentValue = array[i];
                    let position = i;
                    for(; 0 !== position && array[position - 1] > currentValue;)array[position] = array[position - 1], position--;
                    array[position] = currentValue;
                }
                return array;
            }
            const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;
            function isTypedArrayWithEntries(value) {
                return void 0 !== typedArrayPrototypeGetSymbolToStringTag.call(value) && 0 !== value.length;
            }
            function stringifyTypedArray(array, separator, maximumBreadth) {
                array.length < maximumBreadth && (maximumBreadth = array.length);
                const whitespace = ',' === separator ? '' : ' ';
                let res = `"0":${whitespace}${array[0]}`;
                for(let i = 1; i < maximumBreadth; i++)res += `${separator}"${i}":${whitespace}${array[i]}`;
                return res;
            }
            function getCircularValueOption(options) {
                if (options && Object.prototype.hasOwnProperty.call(options, 'circularValue')) {
                    var circularValue = options.circularValue;
                    if ('string' == typeof circularValue) return `"${circularValue}"`;
                    if (null == circularValue) return circularValue;
                    if (circularValue === Error || circularValue === TypeError) return {
                        toString () {
                            throw TypeError('Converting circular structure to JSON');
                        }
                    };
                    throw TypeError('The "circularValue" argument must be of type string or the value null or undefined');
                }
                return '"[Circular]"';
            }
            function getBooleanOption(options, key) {
                if (options && Object.prototype.hasOwnProperty.call(options, key)) {
                    var value = options[key];
                    if ('boolean' != typeof value) throw TypeError(`The "${key}" argument must be of type boolean`);
                }
                return void 0 === value || value;
            }
            function getPositiveIntegerOption(options, key) {
                if (options && Object.prototype.hasOwnProperty.call(options, key)) {
                    var value = options[key];
                    if ('number' != typeof value) throw TypeError(`The "${key}" argument must be of type number`);
                    if (!Number.isInteger(value)) throw TypeError(`The "${key}" argument must be an integer`);
                    if (value < 1) throw RangeError(`The "${key}" argument must be >= 1`);
                }
                return void 0 === value ? 1 / 0 : value;
            }
            function getItemCount(number) {
                return 1 === number ? '1 item' : `${number} items`;
            }
            function getUniqueReplacerSet(replacerArray) {
                const replacerSet = new Set();
                for (const value of replacerArray)'string' == typeof value ? replacerSet.add(value) : 'number' == typeof value && replacerSet.add(String(value));
                return replacerSet;
            }
            function configure(options) {
                const circularValue = getCircularValueOption(options), bigint = getBooleanOption(options, 'bigint'), deterministic = getBooleanOption(options, 'deterministic'), maximumDepth = getPositiveIntegerOption(options, 'maximumDepth'), maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');
                function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
                    let value = parent[key];
                    switch('object' == typeof value && null !== value && 'function' == typeof value.toJSON && (value = value.toJSON(key)), typeof (value = replacer.call(parent, key, value))){
                        case 'string':
                            return `"${strEscape(value)}"`;
                        case 'object':
                            {
                                if (null === value) return 'null';
                                if (-1 !== stack.indexOf(value)) return circularValue;
                                let res = '', join = ',';
                                const originalIndentation = indentation;
                                if (Array.isArray(value)) {
                                    if (0 === value.length) return '[]';
                                    if (maximumDepth < stack.length + 1) return '"[Array]"';
                                    stack.push(value), '' !== spacer && (indentation += spacer, res += `\n${indentation}`, join = `,\n${indentation}`);
                                    const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                    let i = 0;
                                    for(; i < maximumValuesToStringify - 1; i++){
                                        const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                                        res += void 0 !== tmp ? tmp : 'null', res += join;
                                    }
                                    const tmp1 = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                                    if (res += void 0 !== tmp1 ? tmp1 : 'null', value.length - 1 > maximumBreadth) {
                                        const removedKeys = value.length - maximumBreadth - 1;
                                        res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                                    }
                                    return '' !== spacer && (res += `\n${originalIndentation}`), stack.pop(), `[${res}]`;
                                }
                                let keys = Object.keys(value);
                                const keyLength = keys.length;
                                if (0 === keyLength) return '{}';
                                if (maximumDepth < stack.length + 1) return '"[Object]"';
                                let whitespace = '', separator = '';
                                '' !== spacer && (indentation += spacer, join = `,\n${indentation}`, whitespace = ' ');
                                let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                                isTypedArrayWithEntries(value) && (res += stringifyTypedArray(value, join, maximumBreadth), keys = keys.slice(value.length), maximumPropertiesToStringify -= value.length, separator = join), deterministic && (keys = insertSort(keys)), stack.push(value);
                                for(let i1 = 0; i1 < maximumPropertiesToStringify; i1++){
                                    const key1 = keys[i1], tmp2 = stringifyFnReplacer(key1, value, stack, replacer, spacer, indentation);
                                    void 0 !== tmp2 && (res += `${separator}"${strEscape(key1)}":${whitespace}${tmp2}`, separator = join);
                                }
                                if (keyLength > maximumBreadth) {
                                    const removedKeys1 = keyLength - maximumBreadth;
                                    res += `${separator}"...":${whitespace}"${getItemCount(removedKeys1)} not stringified"`, separator = join;
                                }
                                return '' !== spacer && separator.length > 1 && (res = `\n${indentation}${res}\n${originalIndentation}`), stack.pop(), `{${res}}`;
                            }
                        case 'number':
                            return isFinite(value) ? String(value) : 'null';
                        case 'boolean':
                            return !0 === value ? 'true' : 'false';
                        case 'bigint':
                            return bigint ? String(value) : void 0;
                    }
                }
                function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
                    switch('object' == typeof value && null !== value && 'function' == typeof value.toJSON && (value = value.toJSON(key)), typeof value){
                        case 'string':
                            return `"${strEscape(value)}"`;
                        case 'object':
                            {
                                if (null === value) return 'null';
                                if (-1 !== stack.indexOf(value)) return circularValue;
                                const originalIndentation = indentation;
                                let res = '', join = ',';
                                if (Array.isArray(value)) {
                                    if (0 === value.length) return '[]';
                                    if (maximumDepth < stack.length + 1) return '"[Array]"';
                                    stack.push(value), '' !== spacer && (indentation += spacer, res += `\n${indentation}`, join = `,\n${indentation}`);
                                    const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                    let i = 0;
                                    for(; i < maximumValuesToStringify - 1; i++){
                                        const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                                        res += void 0 !== tmp ? tmp : 'null', res += join;
                                    }
                                    const tmp1 = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                                    if (res += void 0 !== tmp1 ? tmp1 : 'null', value.length - 1 > maximumBreadth) {
                                        const removedKeys = value.length - maximumBreadth - 1;
                                        res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                                    }
                                    return '' !== spacer && (res += `\n${originalIndentation}`), stack.pop(), `[${res}]`;
                                }
                                if (0 === replacer.size) return '{}';
                                stack.push(value);
                                let whitespace = '';
                                '' !== spacer && (indentation += spacer, join = `,\n${indentation}`, whitespace = ' ');
                                let separator = '';
                                for (const key1 of replacer){
                                    const tmp2 = stringifyArrayReplacer(key1, value[key1], stack, replacer, spacer, indentation);
                                    void 0 !== tmp2 && (res += `${separator}"${strEscape(key1)}":${whitespace}${tmp2}`, separator = join);
                                }
                                return '' !== spacer && separator.length > 1 && (res = `\n${indentation}${res}\n${originalIndentation}`), stack.pop(), `{${res}}`;
                            }
                        case 'number':
                            return isFinite(value) ? String(value) : 'null';
                        case 'boolean':
                            return !0 === value ? 'true' : 'false';
                        case 'bigint':
                            return bigint ? String(value) : void 0;
                    }
                }
                function stringifyIndent(key, value, stack, spacer, indentation) {
                    switch(typeof value){
                        case 'string':
                            return `"${strEscape(value)}"`;
                        case 'object':
                            {
                                if (null === value) return 'null';
                                if ('function' == typeof value.toJSON) {
                                    if ('object' != typeof (value = value.toJSON(key))) return stringifyIndent(key, value, stack, spacer, indentation);
                                    if (null === value) return 'null';
                                }
                                if (-1 !== stack.indexOf(value)) return circularValue;
                                const originalIndentation = indentation;
                                if (Array.isArray(value)) {
                                    if (0 === value.length) return '[]';
                                    if (maximumDepth < stack.length + 1) return '"[Array]"';
                                    stack.push(value);
                                    let res = `\n${indentation += spacer}`;
                                    const join = `,\n${indentation}`, maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                    let i = 0;
                                    for(; i < maximumValuesToStringify - 1; i++){
                                        const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
                                        res += void 0 !== tmp ? tmp : 'null', res += join;
                                    }
                                    const tmp1 = stringifyIndent(i, value[i], stack, spacer, indentation);
                                    if (res += void 0 !== tmp1 ? tmp1 : 'null', value.length - 1 > maximumBreadth) {
                                        const removedKeys = value.length - maximumBreadth - 1;
                                        res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                                    }
                                    return res += `\n${originalIndentation}`, stack.pop(), `[${res}]`;
                                }
                                let keys = Object.keys(value);
                                const keyLength = keys.length;
                                if (0 === keyLength) return '{}';
                                if (maximumDepth < stack.length + 1) return '"[Object]"';
                                indentation += spacer;
                                const join1 = `,\n${indentation}`;
                                let res1 = '', separator = '', maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                                isTypedArrayWithEntries(value) && (res1 += stringifyTypedArray(value, join1, maximumBreadth), keys = keys.slice(value.length), maximumPropertiesToStringify -= value.length, separator = join1), deterministic && (keys = insertSort(keys)), stack.push(value);
                                for(let i1 = 0; i1 < maximumPropertiesToStringify; i1++){
                                    const key1 = keys[i1], tmp2 = stringifyIndent(key1, value[key1], stack, spacer, indentation);
                                    void 0 !== tmp2 && (res1 += `${separator}"${strEscape(key1)}": ${tmp2}`, separator = join1);
                                }
                                if (keyLength > maximumBreadth) {
                                    const removedKeys1 = keyLength - maximumBreadth;
                                    res1 += `${separator}"...": "${getItemCount(removedKeys1)} not stringified"`, separator = join1;
                                }
                                return '' !== separator && (res1 = `\n${indentation}${res1}\n${originalIndentation}`), stack.pop(), `{${res1}}`;
                            }
                        case 'number':
                            return isFinite(value) ? String(value) : 'null';
                        case 'boolean':
                            return !0 === value ? 'true' : 'false';
                        case 'bigint':
                            return bigint ? String(value) : void 0;
                    }
                }
                function stringifySimple(key, value, stack) {
                    switch(typeof value){
                        case 'string':
                            return `"${strEscape(value)}"`;
                        case 'object':
                            {
                                if (null === value) return 'null';
                                if ('function' == typeof value.toJSON) {
                                    if ('object' != typeof (value = value.toJSON(key))) return stringifySimple(key, value, stack);
                                    if (null === value) return 'null';
                                }
                                if (-1 !== stack.indexOf(value)) return circularValue;
                                let res = '';
                                if (Array.isArray(value)) {
                                    if (0 === value.length) return '[]';
                                    if (maximumDepth < stack.length + 1) return '"[Array]"';
                                    stack.push(value);
                                    const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                    let i = 0;
                                    for(; i < maximumValuesToStringify - 1; i++){
                                        const tmp = stringifySimple(i, value[i], stack);
                                        res += void 0 !== tmp ? tmp : 'null', res += ',';
                                    }
                                    const tmp1 = stringifySimple(i, value[i], stack);
                                    if (res += void 0 !== tmp1 ? tmp1 : 'null', value.length - 1 > maximumBreadth) {
                                        const removedKeys = value.length - maximumBreadth - 1;
                                        res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                                    }
                                    return stack.pop(), `[${res}]`;
                                }
                                let keys = Object.keys(value);
                                const keyLength = keys.length;
                                if (0 === keyLength) return '{}';
                                if (maximumDepth < stack.length + 1) return '"[Object]"';
                                let separator = '', maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                                isTypedArrayWithEntries(value) && (res += stringifyTypedArray(value, ',', maximumBreadth), keys = keys.slice(value.length), maximumPropertiesToStringify -= value.length, separator = ','), deterministic && (keys = insertSort(keys)), stack.push(value);
                                for(let i1 = 0; i1 < maximumPropertiesToStringify; i1++){
                                    const key1 = keys[i1], tmp2 = stringifySimple(key1, value[key1], stack);
                                    void 0 !== tmp2 && (res += `${separator}"${strEscape(key1)}":${tmp2}`, separator = ',');
                                }
                                if (keyLength > maximumBreadth) {
                                    const removedKeys1 = keyLength - maximumBreadth;
                                    res += `${separator}"...":"${getItemCount(removedKeys1)} not stringified"`;
                                }
                                return stack.pop(), `{${res}}`;
                            }
                        case 'number':
                            return isFinite(value) ? String(value) : 'null';
                        case 'boolean':
                            return !0 === value ? 'true' : 'false';
                        case 'bigint':
                            return bigint ? String(value) : void 0;
                    }
                }
                function stringify(value, replacer, space) {
                    if (arguments.length > 1) {
                        let spacer = '';
                        if ('number' == typeof space ? spacer = ' '.repeat(Math.min(space, 10)) : 'string' == typeof space && (spacer = space.slice(0, 10)), null != replacer) {
                            if ('function' == typeof replacer) return stringifyFnReplacer('', {
                                '': value
                            }, [], replacer, spacer, '');
                            if (Array.isArray(replacer)) return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '');
                        }
                        if (0 !== spacer.length) return stringifyIndent('', value, [], spacer, '');
                    }
                    return stringifySimple('', value, []);
                }
                return stringify;
            }
        },
        2399: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var key, process = __webpack_require__(3454), buffer = __webpack_require__(8764), Buffer = buffer.Buffer, safer = {};
            for(key in buffer)buffer.hasOwnProperty(key) && 'SlowBuffer' !== key && 'Buffer' !== key && (safer[key] = buffer[key]);
            var Safer = safer.Buffer = {};
            for(key in Buffer)Buffer.hasOwnProperty(key) && 'allocUnsafe' !== key && 'allocUnsafeSlow' !== key && (Safer[key] = Buffer[key]);
            if (safer.Buffer.prototype = Buffer.prototype, Safer.from && Safer.from !== Uint8Array.from || (Safer.from = function(value, encodingOrOffset, length) {
                if ('number' == typeof value) throw TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
                if (value && void 0 === value.length) throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
                return Buffer(value, encodingOrOffset, length);
            }), Safer.alloc || (Safer.alloc = function(size, fill, encoding) {
                if ('number' != typeof size) throw TypeError('The "size" argument must be of type number. Received type ' + typeof size);
                if (size < 0 || size >= 2 * 1073741824) throw RangeError('The value "' + size + '" is invalid for option "size"');
                var buf = Buffer(size);
                return fill && 0 !== fill.length ? 'string' == typeof encoding ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), buf;
            }), !safer.kStringMaxLength) try {
                safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
            } catch (e) {}
            !safer.constants && (safer.constants = {
                MAX_LENGTH: safer.kMaxLength
            }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength)), module.exports = safer;
        },
        2553: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(9509).Buffer, isEncoding = Buffer.isEncoding || function(encoding) {
                switch((encoding = '' + encoding) && encoding.toLowerCase()){
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                    case 'raw':
                        return !0;
                    default:
                        return !1;
                }
            };
            function _normalizeEncoding(enc) {
                var retried;
                if (!enc) return 'utf8';
                for(;;)switch(enc){
                    case 'utf8':
                    case 'utf-8':
                        return 'utf8';
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return 'utf16le';
                    case 'latin1':
                    case 'binary':
                        return 'latin1';
                    case 'base64':
                    case 'ascii':
                    case 'hex':
                        return enc;
                    default:
                        if (retried) return;
                        enc = ('' + enc).toLowerCase(), retried = !0;
                }
            }
            function normalizeEncoding(enc) {
                var nenc = _normalizeEncoding(enc);
                if ('string' != typeof nenc && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw Error('Unknown encoding: ' + enc);
                return nenc || enc;
            }
            function StringDecoder(encoding) {
                var nb;
                switch(this.encoding = normalizeEncoding(encoding), this.encoding){
                    case 'utf16le':
                        this.text = utf16Text, this.end = utf16End, nb = 4;
                        break;
                    case 'utf8':
                        this.fillLast = utf8FillLast, nb = 4;
                        break;
                    case 'base64':
                        this.text = base64Text, this.end = base64End, nb = 3;
                        break;
                    default:
                        this.write = simpleWrite, this.end = simpleEnd;
                        return;
                }
                this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer.allocUnsafe(nb);
            }
            function utf8CheckByte(byte) {
                return byte <= 0x7F ? 0 : byte >> 5 == 0x06 ? 2 : byte >> 4 == 0x0E ? 3 : byte >> 3 == 0x1E ? 4 : byte >> 6 == 0x02 ? -1 : -2;
            }
            function utf8CheckIncomplete(self1, buf, i) {
                var j = buf.length - 1;
                if (j < i) return 0;
                var nb = utf8CheckByte(buf[j]);
                return nb >= 0 ? (nb > 0 && (self1.lastNeed = nb - 1), nb) : --j < i || -2 === nb ? 0 : (nb = utf8CheckByte(buf[j])) >= 0 ? (nb > 0 && (self1.lastNeed = nb - 2), nb) : --j < i || -2 === nb ? 0 : (nb = utf8CheckByte(buf[j])) >= 0 ? (nb > 0 && (2 === nb ? nb = 0 : self1.lastNeed = nb - 3), nb) : 0;
            }
            function utf8CheckExtraBytes(self1, buf, p) {
                if ((0xC0 & buf[0]) != 0x80) return self1.lastNeed = 0, '\ufffd';
                if (self1.lastNeed > 1 && buf.length > 1) {
                    if ((0xC0 & buf[1]) != 0x80) return self1.lastNeed = 1, '\ufffd';
                    if (self1.lastNeed > 2 && buf.length > 2 && (0xC0 & buf[2]) != 0x80) return self1.lastNeed = 2, '\ufffd';
                }
            }
            function utf8FillLast(buf) {
                var p = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, buf, p);
                return void 0 !== r ? r : this.lastNeed <= buf.length ? (buf.copy(this.lastChar, p, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (buf.copy(this.lastChar, p, 0, buf.length), this.lastNeed -= buf.length);
            }
            function utf8Text(buf, i) {
                var total = utf8CheckIncomplete(this, buf, i);
                if (!this.lastNeed) return buf.toString('utf8', i);
                this.lastTotal = total;
                var end = buf.length - (total - this.lastNeed);
                return buf.copy(this.lastChar, 0, end), buf.toString('utf8', i, end);
            }
            function utf8End(buf) {
                var r = buf && buf.length ? this.write(buf) : '';
                return this.lastNeed ? r + '\ufffd' : r;
            }
            function utf16Text(buf, i) {
                if ((buf.length - i) % 2 == 0) {
                    var r = buf.toString('utf16le', i);
                    if (r) {
                        var c = r.charCodeAt(r.length - 1);
                        if (c >= 0xD800 && c <= 0xDBFF) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
                    }
                    return r;
                }
                return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString('utf16le', i, buf.length - 1);
            }
            function utf16End(buf) {
                var r = buf && buf.length ? this.write(buf) : '';
                if (this.lastNeed) {
                    var end = this.lastTotal - this.lastNeed;
                    return r + this.lastChar.toString('utf16le', 0, end);
                }
                return r;
            }
            function base64Text(buf, i) {
                var n = (buf.length - i) % 3;
                return 0 === n ? buf.toString('base64', i) : (this.lastNeed = 3 - n, this.lastTotal = 3, 1 === n ? this.lastChar[0] = buf[buf.length - 1] : (this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1]), buf.toString('base64', i, buf.length - n));
            }
            function base64End(buf) {
                var r = buf && buf.length ? this.write(buf) : '';
                return this.lastNeed ? r + this.lastChar.toString('base64', 0, 3 - this.lastNeed) : r;
            }
            function simpleWrite(buf) {
                return buf.toString(this.encoding);
            }
            function simpleEnd(buf) {
                return buf && buf.length ? this.write(buf) : '';
            }
            exports.StringDecoder = StringDecoder, StringDecoder.prototype.write = function(buf) {
                var r, i;
                if (0 === buf.length) return '';
                if (this.lastNeed) {
                    if (void 0 === (r = this.fillLast(buf))) return '';
                    i = this.lastNeed, this.lastNeed = 0;
                } else i = 0;
                return i < buf.length ? r ? r + this.text(buf, i) : this.text(buf, i) : r || '';
            }, StringDecoder.prototype.end = utf8End, StringDecoder.prototype.text = utf8Text, StringDecoder.prototype.fillLast = function(buf) {
                if (this.lastNeed <= buf.length) return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
            };
        },
        3931: function(module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                HTTPRangeReader: function() {
                    return HTTPRangeReader;
                },
                cleanup: function() {
                    return cleanup$1;
                },
                setOptions: function() {
                    return setOptions$1;
                },
                unzip: function() {
                    return unzip;
                },
                unzipRaw: function() {
                    return unzipRaw;
                }
            }), module = __webpack_require__.hmd(module);
            var u16, u32, process = __webpack_require__(3454);
            function readBlobAsArrayBuffer(blob) {
                return blob.arrayBuffer ? blob.arrayBuffer() : new Promise((resolve, reject)=>{
                    const reader = new FileReader();
                    reader.addEventListener('loadend', ()=>{
                        resolve(reader.result);
                    }), reader.addEventListener('error', reject), reader.readAsArrayBuffer(blob);
                });
            }
            async function readBlobAsUint8Array(blob) {
                const arrayBuffer = await readBlobAsArrayBuffer(blob);
                return new Uint8Array(arrayBuffer);
            }
            function isBlob(v) {
                return 'undefined' != typeof Blob && v instanceof Blob;
            }
            function isSharedArrayBuffer(b) {
                return 'undefined' != typeof SharedArrayBuffer && b instanceof SharedArrayBuffer;
            }
            const isNode = void 0 !== process && process.versions && void 0 !== process.versions.node && void 0 === process.versions.electron;
            function isTypedArraySameAsArrayBuffer(typedArray) {
                return 0 === typedArray.byteOffset && typedArray.byteLength === typedArray.buffer.byteLength;
            }
            class ArrayBufferReader {
                constructor(arrayBufferOrView){
                    this.typedArray = arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView) ? new Uint8Array(arrayBufferOrView) : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);
                }
                async getLength() {
                    return this.typedArray.byteLength;
                }
                async read(offset, length) {
                    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);
                }
            }
            class BlobReader {
                constructor(blob){
                    this.blob = blob;
                }
                async getLength() {
                    return this.blob.size;
                }
                async read(offset, length) {
                    const blob = this.blob.slice(offset, offset + length), arrayBuffer = await readBlobAsArrayBuffer(blob);
                    return new Uint8Array(arrayBuffer);
                }
                async sliceAsBlob(offset, length, type = '') {
                    return this.blob.slice(offset, offset + length, type);
                }
            }
            class HTTPRangeReader {
                constructor(url){
                    this.url = url;
                }
                async getLength() {
                    if (void 0 === this.length) {
                        const req = await fetch(this.url, {
                            method: 'HEAD'
                        });
                        if (!req.ok) throw Error(`failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);
                        if (this.length = parseInt(req.headers.get('content-length')), Number.isNaN(this.length)) throw Error('could not get length');
                    }
                    return this.length;
                }
                async read(offset, size) {
                    if (0 === size) return new Uint8Array(0);
                    const req = await fetch(this.url, {
                        headers: {
                            Range: `bytes=${offset}-${offset + size - 1}`
                        }
                    });
                    if (!req.ok) throw Error(`failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);
                    const buffer = await req.arrayBuffer();
                    return new Uint8Array(buffer);
                }
            }
            function inflate(data, buf) {
                var lmap, dmap, u8 = Uint8Array;
                if (3 == data[0] && 0 == data[1]) return buf || new u8(0);
                var bitsF = _bitsF, bitsE = _bitsE, decodeTiny = _decodeTiny, get17 = _get17, noBuf = null == buf;
                noBuf && (buf = new u8(data.length >>> 2 << 3));
                for(var BFINAL = 0, BTYPE = 0, HLIT = 0, HDIST = 0, HCLEN = 0, ML = 0, MD = 0, off = 0, pos = 0; 0 == BFINAL;){
                    if (BFINAL = bitsF(data, pos, 1), BTYPE = bitsF(data, pos + 1, 2), pos += 3, 0 == BTYPE) {
                        (7 & pos) != 0 && (pos += 8 - (7 & pos));
                        var p8 = (pos >>> 3) + 4, len = data[p8 - 4] | data[p8 - 3] << 8;
                        noBuf && (buf = _check(buf, off + len)), buf.set(new u8(data.buffer, data.byteOffset + p8, len), off), pos = p8 + len << 3, off += len;
                        continue;
                    }
                    if (noBuf && (buf = _check(buf, off + 131072)), 1 == BTYPE && (lmap = U.flmap, dmap = U.fdmap, ML = 511, MD = 31), 2 == BTYPE) {
                        HLIT = bitsE(data, pos, 5) + 257, HDIST = bitsE(data, pos + 5, 5) + 1, HCLEN = bitsE(data, pos + 10, 4) + 4, pos += 14;
                        for(var i = 0; i < 38; i += 2)U.itree[i] = 0, U.itree[i + 1] = 0;
                        for(var tl = 1, i = 0; i < HCLEN; i++){
                            var l = bitsE(data, pos + 3 * i, 3);
                            U.itree[(U.ordr[i] << 1) + 1] = l, l > tl && (tl = l);
                        }
                        pos += 3 * HCLEN, makeCodes(U.itree, tl), codes2map(U.itree, tl, U.imap), lmap = U.lmap, dmap = U.dmap, pos = decodeTiny(U.imap, (1 << tl) - 1, HLIT + HDIST, data, pos, U.ttree);
                        var mx0 = _copyOut(U.ttree, 0, HLIT, U.ltree);
                        ML = (1 << mx0) - 1;
                        var mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);
                        MD = (1 << mx1) - 1, makeCodes(U.ltree, mx0), codes2map(U.ltree, mx0, lmap), makeCodes(U.dtree, mx1), codes2map(U.dtree, mx1, dmap);
                    }
                    for(;;){
                        var code = lmap[get17(data, pos) & ML];
                        pos += 15 & code;
                        var lit = code >>> 4;
                        if (lit >>> 8 == 0) buf[off++] = lit;
                        else if (256 == lit) break;
                        else {
                            var end = off + lit - 254;
                            if (lit > 264) {
                                var ebs = U.ldef[lit - 257];
                                end = off + (ebs >>> 3) + bitsE(data, pos, 7 & ebs), pos += 7 & ebs;
                            }
                            var dcode = dmap[get17(data, pos) & MD];
                            pos += 15 & dcode;
                            var dlit = dcode >>> 4, dbs = U.ddef[dlit], dst = (dbs >>> 4) + bitsF(data, pos, 15 & dbs);
                            for(pos += 15 & dbs, noBuf && (buf = _check(buf, off + 131072)); off < end;)buf[off] = buf[off++ - dst], buf[off] = buf[off++ - dst], buf[off] = buf[off++ - dst], buf[off] = buf[off++ - dst];
                            off = end;
                        }
                    }
                }
                return buf.length == off ? buf : buf.slice(0, off);
            }
            function _check(buf, len) {
                var bl = buf.length;
                if (len <= bl) return buf;
                var nbuf = new Uint8Array(Math.max(bl << 1, len));
                return nbuf.set(buf, 0), nbuf;
            }
            function _decodeTiny(lmap, LL, len, data, pos, tree) {
                for(var bitsE = _bitsE, get17 = _get17, i = 0; i < len;){
                    var code = lmap[get17(data, pos) & LL];
                    pos += 15 & code;
                    var lit = code >>> 4;
                    if (lit <= 15) tree[i] = lit, i++;
                    else {
                        var ll = 0, n = 0;
                        16 == lit ? (n = 3 + bitsE(data, pos, 2), pos += 2, ll = tree[i - 1]) : 17 == lit ? (n = 3 + bitsE(data, pos, 3), pos += 3) : 18 == lit && (n = 11 + bitsE(data, pos, 7), pos += 7);
                        for(var ni = i + n; i < ni;)tree[i] = ll, i++;
                    }
                }
                return pos;
            }
            function _copyOut(src, off, len, tree) {
                for(var mx = 0, i = 0, tl = tree.length >>> 1; i < len;){
                    var v = src[i + off];
                    tree[i << 1] = 0, tree[(i << 1) + 1] = v, v > mx && (mx = v), i++;
                }
                for(; i < tl;)tree[i << 1] = 0, tree[(i << 1) + 1] = 0, i++;
                return mx;
            }
            function makeCodes(tree, MAX_BITS) {
                for(var code, bits, n, i, len, max_code = tree.length, bl_count = U.bl_count, i = 0; i <= MAX_BITS; i++)bl_count[i] = 0;
                for(i = 1; i < max_code; i += 2)bl_count[tree[i]]++;
                var next_code = U.next_code;
                for(bits = 1, code = 0, bl_count[0] = 0; bits <= MAX_BITS; bits++)code = code + bl_count[bits - 1] << 1, next_code[bits] = code;
                for(n = 0; n < max_code; n += 2)0 != (len = tree[n + 1]) && (tree[n] = next_code[len], next_code[len]++);
            }
            function codes2map(tree, MAX_BITS, map) {
                for(var max_code = tree.length, r15 = U.rev15, i = 0; i < max_code; i += 2)if (0 != tree[i + 1]) for(var lit = i >> 1, cl = tree[i + 1], val = lit << 4 | cl, rest = MAX_BITS - cl, i0 = tree[i] << rest, i1 = i0 + (1 << rest); i0 != i1;)map[r15[i0] >>> 15 - MAX_BITS] = val, i0++;
            }
            function revCodes(tree, MAX_BITS) {
                for(var r15 = U.rev15, imb = 15 - MAX_BITS, i = 0; i < tree.length; i += 2){
                    var i0 = tree[i] << MAX_BITS - tree[i + 1];
                    tree[i] = r15[i0] >>> imb;
                }
            }
            function _bitsE(dt, pos, length) {
                return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8) >>> (7 & pos) & (1 << length) - 1;
            }
            function _bitsF(dt, pos, length) {
                return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (7 & pos) & (1 << length) - 1;
            }
            function _get17(dt, pos) {
                return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (7 & pos);
            }
            const U = (u16 = Uint16Array, u32 = Uint32Array, {
                next_code: new u16(16),
                bl_count: new u16(16),
                ordr: [
                    16,
                    17,
                    18,
                    0,
                    8,
                    7,
                    9,
                    6,
                    10,
                    5,
                    11,
                    4,
                    12,
                    3,
                    13,
                    2,
                    14,
                    1,
                    15
                ],
                of0: [
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    13,
                    15,
                    17,
                    19,
                    23,
                    27,
                    31,
                    35,
                    43,
                    51,
                    59,
                    67,
                    83,
                    99,
                    115,
                    131,
                    163,
                    195,
                    227,
                    258,
                    999,
                    999,
                    999
                ],
                exb: [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3,
                    3,
                    4,
                    4,
                    4,
                    4,
                    5,
                    5,
                    5,
                    5,
                    0,
                    0,
                    0,
                    0
                ],
                ldef: new u16(32),
                df0: [
                    1,
                    2,
                    3,
                    4,
                    5,
                    7,
                    9,
                    13,
                    17,
                    25,
                    33,
                    49,
                    65,
                    97,
                    129,
                    193,
                    257,
                    385,
                    513,
                    769,
                    1025,
                    1537,
                    2049,
                    3073,
                    4097,
                    6145,
                    8193,
                    12289,
                    16385,
                    24577,
                    65535,
                    65535
                ],
                dxb: [
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5,
                    6,
                    6,
                    7,
                    7,
                    8,
                    8,
                    9,
                    9,
                    10,
                    10,
                    11,
                    11,
                    12,
                    12,
                    13,
                    13,
                    0,
                    0
                ],
                ddef: new u32(32),
                flmap: new u16(512),
                fltree: [],
                fdmap: new u16(32),
                fdtree: [],
                lmap: new u16(32768),
                ltree: [],
                ttree: [],
                dmap: new u16(32768),
                dtree: [],
                imap: new u16(512),
                itree: [],
                rev15: new u16(32768),
                lhst: new u32(286),
                dhst: new u32(30),
                ihst: new u32(19),
                lits: new u32(15000),
                strt: new u16(65536),
                prev: new u16(32768)
            });
            !function() {
                for(var len = 32768, i = 0; i < len; i++){
                    var x = i;
                    x = (0xff00ff00 & (x = (0xf0f0f0f0 & (x = (0xcccccccc & (x = (0xaaaaaaaa & x) >>> 1 | (0x55555555 & x) << 1)) >>> 2 | (0x33333333 & x) << 2)) >>> 4 | (0x0f0f0f0f & x) << 4)) >>> 8 | (0x00ff00ff & x) << 8, U.rev15[i] = (x >>> 16 | x << 16) >>> 17;
                }
                function pushV(tgt, n, sv) {
                    for(; 0 != n--;)tgt.push(0, sv);
                }
                for(var i = 0; i < 32; i++)U.ldef[i] = U.of0[i] << 3 | U.exb[i], U.ddef[i] = U.df0[i] << 4 | U.dxb[i];
                pushV(U.fltree, 144, 8), pushV(U.fltree, 112, 9), pushV(U.fltree, 24, 7), pushV(U.fltree, 8, 8), makeCodes(U.fltree, 9), codes2map(U.fltree, 9, U.flmap), revCodes(U.fltree, 9), pushV(U.fdtree, 32, 5), makeCodes(U.fdtree, 5), codes2map(U.fdtree, 5, U.fdmap), revCodes(U.fdtree, 5), pushV(U.itree, 19, 0), pushV(U.ltree, 286, 0), pushV(U.dtree, 30, 0), pushV(U.ttree, 320, 0);
            }();
            const crc = {
                table: function() {
                    for(var tab = new Uint32Array(256), n = 0; n < 256; n++){
                        for(var c = n, k = 0; k < 8; k++)1 & c ? c = 0xedb88320 ^ c >>> 1 : c >>>= 1;
                        tab[n] = c;
                    }
                    return tab;
                }(),
                update: function(c, buf, off, len) {
                    for(var i = 0; i < len; i++)c = crc.table[(c ^ buf[off + i]) & 0xff] ^ c >>> 8;
                    return c;
                },
                crc: function(b, o, l) {
                    return 0xffffffff ^ crc.update(0xffffffff, b, o, l);
                }
            };
            function inflateRaw(file, buf) {
                return inflate(file, buf);
            }
            const config = {
                numWorkers: 1,
                workerURL: '',
                useWorkers: !1
            };
            let nextId = 0, numWorkers = 0, canUseWorkers = !0;
            const workers = [], availableWorkers = [], waitingForWorkerQueue = [], currentlyProcessingIdToRequestMap = new Map();
            function handleResult(e) {
                makeWorkerAvailable(e.target);
                const { id , error , data  } = e.data, request = currentlyProcessingIdToRequestMap.get(id);
                currentlyProcessingIdToRequestMap.delete(id), error ? request.reject(error) : request.resolve(data);
            }
            function startWorker(url) {
                return new Promise((resolve, reject)=>{
                    const worker = new Worker(url);
                    worker.onmessage = (e)=>{
                        'start' === e.data ? (worker.onerror = void 0, worker.onmessage = void 0, resolve(worker)) : reject(Error(`unexpected message: ${e.data}`));
                    }, worker.onerror = reject;
                });
            }
            function dynamicRequire(mod, request) {
                return mod.require(request);
            }
            const workerHelper = function() {
                if (!isNode) return {
                    async createWorker (url) {
                        try {
                            const worker = await startWorker(url);
                            return worker;
                        } catch (e) {
                            console.warn('could not load worker:', url);
                        }
                        let text;
                        try {
                            const req = await fetch(url, {
                                mode: 'cors'
                            });
                            if (!req.ok) throw Error(`could not load: ${url}`);
                            text = await req.text(), url = URL.createObjectURL(new Blob([
                                text
                            ], {
                                type: 'application/javascript'
                            }));
                            const worker1 = await startWorker(url);
                            return config.workerURL = url, worker1;
                        } catch (e1) {
                            console.warn('could not load worker via fetch:', url);
                        }
                        if (void 0 !== text) try {
                            url = `data:application/javascript;base64,${btoa(text)}`;
                            const worker2 = await startWorker(url);
                            return config.workerURL = url, worker2;
                        } catch (e2) {
                            console.warn('could not load worker via dataURI');
                        }
                        throw console.warn('workers will not be used'), Error('can not start workers');
                    },
                    addEventListener (worker, fn) {
                        worker.addEventListener('message', fn);
                    },
                    async terminate (worker) {
                        worker.terminate();
                    }
                };
                {
                    const { Worker: Worker1  } = dynamicRequire(module, 'worker_threads');
                    return {
                        async createWorker (url) {
                            return new Worker1(url);
                        },
                        addEventListener (worker, fn) {
                            worker.on('message', (data)=>{
                                fn({
                                    target: worker,
                                    data
                                });
                            });
                        },
                        async terminate (worker) {
                            await worker.terminate();
                        }
                    };
                }
            }();
            function makeWorkerAvailable(worker) {
                availableWorkers.push(worker), processWaitingForWorkerQueue();
            }
            async function getAvailableWorker() {
                if (0 === availableWorkers.length && numWorkers < config.numWorkers) {
                    ++numWorkers;
                    try {
                        const worker = await workerHelper.createWorker(config.workerURL);
                        workers.push(worker), availableWorkers.push(worker), workerHelper.addEventListener(worker, handleResult);
                    } catch (e) {
                        canUseWorkers = !1;
                    }
                }
                return availableWorkers.pop();
            }
            function inflateRawLocal(src, uncompressedSize, type, resolve) {
                const dst = new Uint8Array(uncompressedSize);
                inflateRaw(src, dst), resolve(type ? new Blob([
                    dst
                ], {
                    type
                }) : dst.buffer);
            }
            async function processWaitingForWorkerQueue() {
                if (0 !== waitingForWorkerQueue.length) {
                    if (config.useWorkers && canUseWorkers) {
                        const worker = await getAvailableWorker();
                        if (canUseWorkers) {
                            if (worker) {
                                if (0 === waitingForWorkerQueue.length) {
                                    makeWorkerAvailable(worker);
                                    return;
                                }
                                const { id , src , uncompressedSize , type , resolve , reject  } = waitingForWorkerQueue.shift();
                                currentlyProcessingIdToRequestMap.set(id, {
                                    id,
                                    resolve,
                                    reject
                                });
                                const transferables = [];
                                worker.postMessage({
                                    type: 'inflate',
                                    data: {
                                        id,
                                        type,
                                        src,
                                        uncompressedSize
                                    }
                                }, transferables);
                            }
                            return;
                        }
                    }
                    for(; waitingForWorkerQueue.length;){
                        const { src: src1 , uncompressedSize: uncompressedSize1 , type: type1 , resolve: resolve1  } = waitingForWorkerQueue.shift();
                        let data = src1;
                        isBlob(src1) && (data = await readBlobAsUint8Array(src1)), inflateRawLocal(data, uncompressedSize1, type1, resolve1);
                    }
                }
            }
            function setOptions(options) {
                config.workerURL = options.workerURL || config.workerURL, options.workerURL && (config.useWorkers = !0), config.useWorkers = void 0 !== options.useWorkers ? options.useWorkers : config.useWorkers, config.numWorkers = options.numWorkers || config.numWorkers;
            }
            function inflateRawAsync(src, uncompressedSize, type) {
                return new Promise((resolve, reject)=>{
                    waitingForWorkerQueue.push({
                        src,
                        uncompressedSize,
                        type,
                        resolve,
                        reject,
                        id: nextId++
                    }), processWaitingForWorkerQueue();
                });
            }
            function clearArray(arr) {
                arr.splice(0, arr.length);
            }
            async function cleanup() {
                for (const worker of workers)await workerHelper.terminate(worker);
                clearArray(workers), clearArray(availableWorkers), clearArray(waitingForWorkerQueue), currentlyProcessingIdToRequestMap.clear(), numWorkers = 0, canUseWorkers = !0;
            }
            function dosDateTimeToDate(date, time) {
                const day = 0x1f & date, month = (date >> 5 & 0xf) - 1, year = (date >> 9 & 0x7f) + 1980, millisecond = 0, second = (0x1f & time) * 2, minute = time >> 5 & 0x3f, hour = time >> 11 & 0x1f;
                return new Date(year, month, day, hour, minute, second, millisecond);
            }
            class ZipEntry {
                constructor(reader, rawEntry){
                    this._reader = reader, this._rawEntry = rawEntry, this.name = rawEntry.name, this.nameBytes = rawEntry.nameBytes, this.size = rawEntry.uncompressedSize, this.compressedSize = rawEntry.compressedSize, this.comment = rawEntry.comment, this.commentBytes = rawEntry.commentBytes, this.compressionMethod = rawEntry.compressionMethod, this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime), this.isDirectory = 0 === rawEntry.uncompressedSize && rawEntry.name.endsWith('/'), this.encrypted = !!(0x1 & rawEntry.generalPurposeBitFlag), this.externalFileAttributes = rawEntry.externalFileAttributes, this.versionMadeBy = rawEntry.versionMadeBy;
                }
                async blob(type = 'application/octet-stream') {
                    return await readEntryDataAsBlob(this._reader, this._rawEntry, type);
                }
                async arrayBuffer() {
                    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);
                }
                async text() {
                    const buffer = await this.arrayBuffer();
                    return decodeBuffer(new Uint8Array(buffer));
                }
                async json() {
                    const text = await this.text();
                    return JSON.parse(text);
                }
            }
            const EOCDR_WITHOUT_COMMENT_SIZE = 22, MAX_COMMENT_SIZE = 0xffff, EOCDR_SIGNATURE = 0x06054b50, ZIP64_EOCDR_SIGNATURE = 0x06064b50;
            async function readAs(reader, offset, length) {
                return await reader.read(offset, length);
            }
            async function readAsBlobOrTypedArray(reader, offset, length, type) {
                return reader.sliceAsBlob ? await reader.sliceAsBlob(offset, length, type) : await reader.read(offset, length);
            }
            const crc$1 = {
                unsigned () {
                    return 0;
                }
            };
            function getUint16LE(uint8View, offset) {
                return uint8View[offset] + 0x100 * uint8View[offset + 1];
            }
            function getUint32LE(uint8View, offset) {
                return uint8View[offset] + 0x100 * uint8View[offset + 1] + 0x10000 * uint8View[offset + 2] + 0x1000000 * uint8View[offset + 3];
            }
            function getUint64LE(uint8View, offset) {
                return getUint32LE(uint8View, offset) + 0x100000000 * getUint32LE(uint8View, offset + 4);
            }
            const utf8Decoder = new TextDecoder();
            function decodeBuffer(uint8View, isUTF8) {
                return isSharedArrayBuffer(uint8View.buffer) && (uint8View = new Uint8Array(uint8View)), utf8Decoder.decode(uint8View);
            }
            async function findEndOfCentralDirector(reader, totalLength) {
                const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength), readStart = totalLength - size, data = await readAs(reader, readStart, size);
                for(let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i){
                    if (getUint32LE(data, i) !== EOCDR_SIGNATURE) continue;
                    const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i), diskNumber = getUint16LE(eocdr, 4);
                    if (0 !== diskNumber) throw Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);
                    const entryCount = getUint16LE(eocdr, 10), centralDirectorySize = getUint32LE(eocdr, 12), centralDirectoryOffset = getUint32LE(eocdr, 16), commentLength = getUint16LE(eocdr, 20), expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;
                    if (commentLength !== expectedCommentLength) throw Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);
                    const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength), comment = decodeBuffer(commentBytes);
                    if (0xffff === entryCount || 0xffffffff === centralDirectoryOffset) return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);
                    return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);
                }
                throw Error('could not find end of central directory. maybe not zip file');
            }
            const END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;
            async function readZip64CentralDirectory(reader, offset, comment, commentBytes) {
                const zip64EocdlOffset = offset - 20, eocdl = await readAs(reader, zip64EocdlOffset, 20);
                if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) throw Error('invalid zip64 end of central directory locator signature');
                const zip64EocdrOffset = getUint64LE(eocdl, 8), zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56);
                if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) throw Error('invalid zip64 end of central directory record signature');
                const entryCount = getUint64LE(zip64Eocdr, 32), centralDirectorySize = getUint64LE(zip64Eocdr, 40), centralDirectoryOffset = getUint64LE(zip64Eocdr, 48);
                return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);
            }
            const CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;
            async function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {
                let readEntryCursor = 0;
                const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize), rawEntries = [];
                for(let e = 0; e < rawEntryCount; ++e){
                    const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46), signature = getUint32LE(buffer, 0);
                    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) throw Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);
                    const rawEntry = {
                        versionMadeBy: getUint16LE(buffer, 4),
                        versionNeededToExtract: getUint16LE(buffer, 6),
                        generalPurposeBitFlag: getUint16LE(buffer, 8),
                        compressionMethod: getUint16LE(buffer, 10),
                        lastModFileTime: getUint16LE(buffer, 12),
                        lastModFileDate: getUint16LE(buffer, 14),
                        crc32: getUint32LE(buffer, 16),
                        compressedSize: getUint32LE(buffer, 20),
                        uncompressedSize: getUint32LE(buffer, 24),
                        fileNameLength: getUint16LE(buffer, 28),
                        extraFieldLength: getUint16LE(buffer, 30),
                        fileCommentLength: getUint16LE(buffer, 32),
                        internalFileAttributes: getUint16LE(buffer, 36),
                        externalFileAttributes: getUint32LE(buffer, 38),
                        relativeOffsetOfLocalHeader: getUint32LE(buffer, 42)
                    };
                    if (0x40 & rawEntry.generalPurposeBitFlag) throw Error('strong encryption is not supported');
                    readEntryCursor += 46;
                    const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);
                    rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength), rawEntry.name = decodeBuffer(rawEntry.nameBytes);
                    const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength, extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);
                    rawEntry.extraFields = [];
                    let i = 0;
                    for(; i < extraFieldBuffer.length - 3;){
                        const headerId = getUint16LE(extraFieldBuffer, i + 0), dataSize = getUint16LE(extraFieldBuffer, i + 2), dataStart = i + 4, dataEnd = dataStart + dataSize;
                        if (dataEnd > extraFieldBuffer.length) throw Error('extra field length exceeds extra field buffer size');
                        rawEntry.extraFields.push({
                            id: headerId,
                            data: extraFieldBuffer.slice(dataStart, dataEnd)
                        }), i = dataEnd;
                    }
                    if (rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength), rawEntry.comment = decodeBuffer(rawEntry.commentBytes), readEntryCursor += data.length, 0xffffffff === rawEntry.uncompressedSize || 0xffffffff === rawEntry.compressedSize || 0xffffffff === rawEntry.relativeOffsetOfLocalHeader) {
                        const zip64ExtraField = rawEntry.extraFields.find((e)=>0x0001 === e.id);
                        if (!zip64ExtraField) throw Error('expected zip64 extended information extra field');
                        const zip64EiefBuffer = zip64ExtraField.data;
                        let index = 0;
                        if (0xffffffff === rawEntry.uncompressedSize) {
                            if (index + 8 > zip64EiefBuffer.length) throw Error('zip64 extended information extra field does not include uncompressed size');
                            rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index), index += 8;
                        }
                        if (0xffffffff === rawEntry.compressedSize) {
                            if (index + 8 > zip64EiefBuffer.length) throw Error('zip64 extended information extra field does not include compressed size');
                            rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index), index += 8;
                        }
                        if (0xffffffff === rawEntry.relativeOffsetOfLocalHeader) {
                            if (index + 8 > zip64EiefBuffer.length) throw Error('zip64 extended information extra field does not include relative header offset');
                            rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index), index += 8;
                        }
                    }
                    const nameField = rawEntry.extraFields.find((e)=>0x7075 === e.id && e.data.length >= 6 && 1 === e.data[0] && getUint32LE(e.data, 1), crc$1.unsigned(rawEntry.nameBytes));
                    if (nameField && (rawEntry.fileName = decodeBuffer(nameField.data.slice(5))), 0 === rawEntry.compressionMethod) {
                        let expectedCompressedSize = rawEntry.uncompressedSize;
                        if ((0x1 & rawEntry.generalPurposeBitFlag) != 0 && (expectedCompressedSize += 12), rawEntry.compressedSize !== expectedCompressedSize) throw Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);
                    }
                    rawEntries.push(rawEntry);
                }
                const zip = {
                    comment,
                    commentBytes
                };
                return {
                    zip,
                    entries: rawEntries.map((e)=>new ZipEntry(reader, e))
                };
            }
            async function readEntryDataHeader(reader, rawEntry) {
                if (0x1 & rawEntry.generalPurposeBitFlag) throw Error('encrypted entries not supported');
                const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30), totalLength = await reader.getLength(), signature = getUint32LE(buffer, 0);
                if (0x04034b50 !== signature) throw Error(`invalid local file header signature: 0x${signature.toString(16)}`);
                const fileNameLength = getUint16LE(buffer, 26), extraFieldLength = getUint16LE(buffer, 28), localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
                let decompress;
                if (0 === rawEntry.compressionMethod) decompress = !1;
                else if (8 === rawEntry.compressionMethod) decompress = !0;
                else throw Error(`unsupported compression method: ${rawEntry.compressionMethod}`);
                const fileDataStart = localFileHeaderEnd, fileDataEnd = fileDataStart + rawEntry.compressedSize;
                if (0 !== rawEntry.compressedSize && fileDataEnd > totalLength) throw Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);
                return {
                    decompress,
                    fileDataStart
                };
            }
            async function readEntryDataAsArrayBuffer(reader, rawEntry) {
                const { decompress , fileDataStart  } = await readEntryDataHeader(reader, rawEntry);
                if (!decompress) {
                    const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize);
                    return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;
                }
                const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize), result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);
                return result;
            }
            async function readEntryDataAsBlob(reader, rawEntry, type) {
                const { decompress , fileDataStart  } = await readEntryDataHeader(reader, rawEntry);
                if (!decompress) {
                    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);
                    return isBlob(typedArrayOrBlob) ? typedArrayOrBlob : new Blob([
                        isSharedArrayBuffer(typedArrayOrBlob.buffer) ? new Uint8Array(typedArrayOrBlob) : typedArrayOrBlob
                    ], {
                        type
                    });
                }
                const typedArrayOrBlob1 = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize), result = await inflateRawAsync(typedArrayOrBlob1, rawEntry.uncompressedSize, type);
                return result;
            }
            function setOptions$1(options) {
                setOptions(options);
            }
            async function unzipRaw(source) {
                let reader;
                if ('undefined' != typeof Blob && source instanceof Blob) reader = new BlobReader(source);
                else if (source instanceof ArrayBuffer || source && source.buffer && source.buffer instanceof ArrayBuffer) reader = new ArrayBufferReader(source);
                else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) reader = new ArrayBufferReader(source);
                else if ('string' == typeof source) {
                    const req = await fetch(source);
                    if (!req.ok) throw Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);
                    const blob = await req.blob();
                    reader = new BlobReader(blob);
                } else if ('function' == typeof source.getLength && 'function' == typeof source.read) reader = source;
                else throw Error('unsupported source type');
                const totalLength = await reader.getLength();
                if (totalLength > Number.MAX_SAFE_INTEGER) throw Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);
                return await findEndOfCentralDirector(reader, totalLength);
            }
            async function unzip(source) {
                const { zip , entries  } = await unzipRaw(source);
                return {
                    zip,
                    entries: Object.fromEntries(entries.map((v)=>[
                            v.name,
                            v
                        ]))
                };
            }
            function cleanup$1() {
                cleanup();
            }
        },
        384: function(module) {
            module.exports = function(arg) {
                return arg && 'object' == typeof arg && 'function' == typeof arg.copy && 'function' == typeof arg.fill && 'function' == typeof arg.readUInt8;
            };
        },
        5955: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var isArgumentsObject = __webpack_require__(2584), isGeneratorFunction = __webpack_require__(8662), whichTypedArray = __webpack_require__(6430), isTypedArray = __webpack_require__(5692);
            function uncurryThis(f) {
                return f.call.bind(f);
            }
            var BigIntSupported = 'undefined' != typeof BigInt, SymbolSupported = 'undefined' != typeof Symbol, ObjectToString = uncurryThis(Object.prototype.toString), numberValue = uncurryThis(Number.prototype.valueOf), stringValue = uncurryThis(String.prototype.valueOf), booleanValue = uncurryThis(Boolean.prototype.valueOf);
            if (BigIntSupported) var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
            if (SymbolSupported) var symbolValue = uncurryThis(Symbol.prototype.valueOf);
            function checkBoxedPrimitive(value, prototypeValueOf) {
                if ('object' != typeof value) return !1;
                try {
                    return prototypeValueOf(value), !0;
                } catch (e) {
                    return !1;
                }
            }
            function isPromise(input) {
                return 'undefined' != typeof Promise && input instanceof Promise || null !== input && 'object' == typeof input && 'function' == typeof input.then && 'function' == typeof input.catch;
            }
            function isArrayBufferView(value) {
                return 'undefined' != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(value) : isTypedArray(value) || isDataView(value);
            }
            function isUint8Array(value) {
                return 'Uint8Array' === whichTypedArray(value);
            }
            function isUint8ClampedArray(value) {
                return 'Uint8ClampedArray' === whichTypedArray(value);
            }
            function isUint16Array(value) {
                return 'Uint16Array' === whichTypedArray(value);
            }
            function isUint32Array(value) {
                return 'Uint32Array' === whichTypedArray(value);
            }
            function isInt8Array(value) {
                return 'Int8Array' === whichTypedArray(value);
            }
            function isInt16Array(value) {
                return 'Int16Array' === whichTypedArray(value);
            }
            function isInt32Array(value) {
                return 'Int32Array' === whichTypedArray(value);
            }
            function isFloat32Array(value) {
                return 'Float32Array' === whichTypedArray(value);
            }
            function isFloat64Array(value) {
                return 'Float64Array' === whichTypedArray(value);
            }
            function isBigInt64Array(value) {
                return 'BigInt64Array' === whichTypedArray(value);
            }
            function isBigUint64Array(value) {
                return 'BigUint64Array' === whichTypedArray(value);
            }
            function isMapToString(value) {
                return '[object Map]' === ObjectToString(value);
            }
            function isMap(value) {
                return 'undefined' != typeof Map && (isMapToString.working ? isMapToString(value) : value instanceof Map);
            }
            function isSetToString(value) {
                return '[object Set]' === ObjectToString(value);
            }
            function isSet(value) {
                return 'undefined' != typeof Set && (isSetToString.working ? isSetToString(value) : value instanceof Set);
            }
            function isWeakMapToString(value) {
                return '[object WeakMap]' === ObjectToString(value);
            }
            function isWeakMap(value) {
                return 'undefined' != typeof WeakMap && (isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap);
            }
            function isWeakSetToString(value) {
                return '[object WeakSet]' === ObjectToString(value);
            }
            function isWeakSet(value) {
                return isWeakSetToString(value);
            }
            function isArrayBufferToString(value) {
                return '[object ArrayBuffer]' === ObjectToString(value);
            }
            function isArrayBuffer(value) {
                return 'undefined' != typeof ArrayBuffer && (isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer);
            }
            function isDataViewToString(value) {
                return '[object DataView]' === ObjectToString(value);
            }
            function isDataView(value) {
                return 'undefined' != typeof DataView && (isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView);
            }
            exports.isArgumentsObject = isArgumentsObject, exports.isGeneratorFunction = isGeneratorFunction, exports.isTypedArray = isTypedArray, exports.isPromise = isPromise, exports.isArrayBufferView = isArrayBufferView, exports.isUint8Array = isUint8Array, exports.isUint8ClampedArray = isUint8ClampedArray, exports.isUint16Array = isUint16Array, exports.isUint32Array = isUint32Array, exports.isInt8Array = isInt8Array, exports.isInt16Array = isInt16Array, exports.isInt32Array = isInt32Array, exports.isFloat32Array = isFloat32Array, exports.isFloat64Array = isFloat64Array, exports.isBigInt64Array = isBigInt64Array, exports.isBigUint64Array = isBigUint64Array, isMapToString.working = 'undefined' != typeof Map && isMapToString(new Map()), exports.isMap = isMap, isSetToString.working = 'undefined' != typeof Set && isSetToString(new Set()), exports.isSet = isSet, isWeakMapToString.working = 'undefined' != typeof WeakMap && isWeakMapToString(new WeakMap()), exports.isWeakMap = isWeakMap, isWeakSetToString.working = 'undefined' != typeof WeakSet && isWeakSetToString(new WeakSet()), exports.isWeakSet = isWeakSet, isArrayBufferToString.working = 'undefined' != typeof ArrayBuffer && isArrayBufferToString(new ArrayBuffer()), exports.isArrayBuffer = isArrayBuffer, isDataViewToString.working = 'undefined' != typeof ArrayBuffer && 'undefined' != typeof DataView && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1)), exports.isDataView = isDataView;
            var SharedArrayBufferCopy = 'undefined' != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
            function isSharedArrayBufferToString(value) {
                return '[object SharedArrayBuffer]' === ObjectToString(value);
            }
            function isSharedArrayBuffer(value) {
                return void 0 !== SharedArrayBufferCopy && (void 0 === isSharedArrayBufferToString.working && (isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy())), isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy);
            }
            function isAsyncFunction(value) {
                return '[object AsyncFunction]' === ObjectToString(value);
            }
            function isMapIterator(value) {
                return '[object Map Iterator]' === ObjectToString(value);
            }
            function isSetIterator(value) {
                return '[object Set Iterator]' === ObjectToString(value);
            }
            function isGeneratorObject(value) {
                return '[object Generator]' === ObjectToString(value);
            }
            function isWebAssemblyCompiledModule(value) {
                return '[object WebAssembly.Module]' === ObjectToString(value);
            }
            function isNumberObject(value) {
                return checkBoxedPrimitive(value, numberValue);
            }
            function isStringObject(value) {
                return checkBoxedPrimitive(value, stringValue);
            }
            function isBooleanObject(value) {
                return checkBoxedPrimitive(value, booleanValue);
            }
            function isBigIntObject(value) {
                return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
            }
            function isSymbolObject(value) {
                return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
            }
            function isBoxedPrimitive(value) {
                return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
            }
            function isAnyArrayBuffer(value) {
                return 'undefined' != typeof Uint8Array && (isArrayBuffer(value) || isSharedArrayBuffer(value));
            }
            exports.isSharedArrayBuffer = isSharedArrayBuffer, exports.isAsyncFunction = isAsyncFunction, exports.isMapIterator = isMapIterator, exports.isSetIterator = isSetIterator, exports.isGeneratorObject = isGeneratorObject, exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule, exports.isNumberObject = isNumberObject, exports.isStringObject = isStringObject, exports.isBooleanObject = isBooleanObject, exports.isBigIntObject = isBigIntObject, exports.isSymbolObject = isSymbolObject, exports.isBoxedPrimitive = isBoxedPrimitive, exports.isAnyArrayBuffer = isAnyArrayBuffer, [
                'isProxy',
                'isExternal',
                'isModuleNamespaceObject'
            ].forEach(function(method) {
                Object.defineProperty(exports, method, {
                    enumerable: !1,
                    value: function() {
                        throw Error(method + ' is not supported in userland');
                    }
                });
            });
        },
        9539: function(__unused_webpack_module, exports, __webpack_require__) {
            var process = __webpack_require__(3454), getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function(obj) {
                for(var keys = Object.keys(obj), descriptors = {}, i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                return descriptors;
            }, formatRegExp = /%[sdj%]/g;
            exports.format = function(f) {
                if (!isString(f)) {
                    for(var objects = [], i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
                    return objects.join(' ');
                }
                for(var i = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x) {
                    if ('%%' === x) return '%';
                    if (i >= len) return x;
                    switch(x){
                        case '%s':
                            return String(args[i++]);
                        case '%d':
                            return Number(args[i++]);
                        case '%j':
                            try {
                                return JSON.stringify(args[i++]);
                            } catch (_) {
                                return '[Circular]';
                            }
                        default:
                            return x;
                    }
                }), x = args[i]; i < len; x = args[++i])isNull(x) || !isObject(x) ? str += ' ' + x : str += ' ' + inspect(x);
                return str;
            }, exports.deprecate = function(fn, msg) {
                if (void 0 !== process && !0 === process.noDeprecation) return fn;
                if (void 0 === process) return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
                var warned = !1;
                function deprecated() {
                    if (!warned) {
                        if (process.throwDeprecation) throw Error(msg);
                        process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;
                    }
                    return fn.apply(this, arguments);
                }
                return deprecated;
            };
            var debugs = {}, debugEnvRegex = /^$/;
            if (process.env.NODE_DEBUG) {
                var debugEnv = process.env.NODE_DEBUG;
                debugEnvRegex = RegExp('^' + (debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase()) + '$', 'i');
            }
            function inspect(obj, opts) {
                var ctx = {
                    seen: [],
                    stylize: stylizeNoColor
                };
                return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue(ctx, obj, ctx.depth);
            }
            function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                return style ? '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm' : str;
            }
            function stylizeNoColor(str, styleType) {
                return str;
            }
            function arrayToHash(array) {
                var hash = {};
                return array.forEach(function(val, idx) {
                    hash[val] = !0;
                }), hash;
            }
            function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                    var output, ret = value.inspect(recurseTimes, ctx);
                    return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) return primitive;
                var keys = Object.keys(value), visibleKeys = arrayToHash(keys);
                if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) return formatError(value);
                if (0 === keys.length) {
                    if (isFunction(value)) {
                        var name = value.name ? ': ' + value.name : '';
                        return ctx.stylize('[Function' + name + ']', 'special');
                    }
                    if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                    if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), 'date');
                    if (isError(value)) return formatError(value);
                }
                var base = '', array = !1, braces = [
                    '{',
                    '}'
                ];
                return (isArray(value) && (array = !0, braces = [
                    '[',
                    ']'
                ]), isFunction(value) && (base = ' [Function' + (value.name ? ': ' + value.name : '') + ']'), isRegExp(value) && (base = ' ' + RegExp.prototype.toString.call(value)), isDate(value) && (base = ' ' + Date.prototype.toUTCString.call(value)), isError(value) && (base = ' ' + formatError(value)), 0 !== keys.length || array && 0 != value.length) ? recurseTimes < 0 ? isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), 'regexp') : ctx.stylize('[Object]', 'special') : (ctx.seen.push(value), output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys) : keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                }), ctx.seen.pop(), reduceToSingleString(output, base, braces)) : braces[0] + base + braces[1];
            }
            function formatPrimitive(ctx, value) {
                if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                if (isString(value)) {
                    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                    return ctx.stylize(simple, 'string');
                }
                return isNumber(value) ? ctx.stylize('' + value, 'number') : isBoolean(value) ? ctx.stylize('' + value, 'boolean') : isNull(value) ? ctx.stylize('null', 'null') : void 0;
            }
            function formatError(value) {
                return '[' + Error.prototype.toString.call(value) + ']';
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                for(var output = [], i = 0, l = value.length; i < l; ++i)hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push('');
                return keys.forEach(function(key) {
                    key.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));
                }), output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                if ((desc = Object.getOwnPropertyDescriptor(value, key) || {
                    value: value[key]
                }).get ? str = desc.set ? ctx.stylize('[Getter/Setter]', 'special') : ctx.stylize('[Getter]', 'special') : desc.set && (str = ctx.stylize('[Setter]', 'special')), hasOwnProperty(visibleKeys, key) || (name = '[' + key + ']'), !str && (0 > ctx.seen.indexOf(desc.value) ? (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1)).indexOf('\n') > -1 && (str = array ? str.split('\n').map(function(line) {
                    return '  ' + line;
                }).join('\n').substr(2) : '\n' + str.split('\n').map(function(line) {
                    return '   ' + line;
                }).join('\n')) : str = ctx.stylize('[Circular]', 'special')), isUndefined(name)) {
                    if (array && key.match(/^\d+$/)) return str;
                    (name = JSON.stringify('' + key)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), name = ctx.stylize(name, 'name')) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, 'string'));
                }
                return name + ': ' + str;
            }
            function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                return output.reduce(function(prev, cur) {
                    return numLinesEst++, cur.indexOf('\n') >= 0 && numLinesEst++, prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                }, 0) > 60 ? braces[0] + ('' === base ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1] : braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
            }
            function isArray(ar) {
                return Array.isArray(ar);
            }
            function isBoolean(arg) {
                return 'boolean' == typeof arg;
            }
            function isNull(arg) {
                return null === arg;
            }
            function isNullOrUndefined(arg) {
                return null == arg;
            }
            function isNumber(arg) {
                return 'number' == typeof arg;
            }
            function isString(arg) {
                return 'string' == typeof arg;
            }
            function isSymbol(arg) {
                return 'symbol' == typeof arg;
            }
            function isUndefined(arg) {
                return void 0 === arg;
            }
            function isRegExp(re) {
                return isObject(re) && '[object RegExp]' === objectToString(re);
            }
            function isObject(arg) {
                return 'object' == typeof arg && null !== arg;
            }
            function isDate(d) {
                return isObject(d) && '[object Date]' === objectToString(d);
            }
            function isError(e) {
                return isObject(e) && ('[object Error]' === objectToString(e) || e instanceof Error);
            }
            function isFunction(arg) {
                return 'function' == typeof arg;
            }
            function isPrimitive(arg) {
                return null === arg || 'boolean' == typeof arg || 'number' == typeof arg || 'string' == typeof arg || 'symbol' == typeof arg || void 0 === arg;
            }
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
            function pad(n) {
                return n < 10 ? '0' + n.toString(10) : n.toString(10);
            }
            exports.debuglog = function(set) {
                if (!debugs[set = set.toUpperCase()]) {
                    if (debugEnvRegex.test(set)) {
                        var pid = process.pid;
                        debugs[set] = function() {
                            var msg = exports.format.apply(exports, arguments);
                            console.error('%s %d: %s', set, pid, msg);
                        };
                    } else debugs[set] = function() {};
                }
                return debugs[set];
            }, exports.inspect = inspect, inspect.colors = {
                bold: [
                    1,
                    22
                ],
                italic: [
                    3,
                    23
                ],
                underline: [
                    4,
                    24
                ],
                inverse: [
                    7,
                    27
                ],
                white: [
                    37,
                    39
                ],
                grey: [
                    90,
                    39
                ],
                black: [
                    30,
                    39
                ],
                blue: [
                    34,
                    39
                ],
                cyan: [
                    36,
                    39
                ],
                green: [
                    32,
                    39
                ],
                magenta: [
                    35,
                    39
                ],
                red: [
                    31,
                    39
                ],
                yellow: [
                    33,
                    39
                ]
            }, inspect.styles = {
                special: 'cyan',
                number: 'yellow',
                boolean: 'yellow',
                undefined: 'grey',
                null: 'bold',
                string: 'green',
                date: 'magenta',
                regexp: 'red'
            }, exports.types = __webpack_require__(5955), exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, exports.isNullOrUndefined = isNullOrUndefined, exports.isNumber = isNumber, exports.isString = isString, exports.isSymbol = isSymbol, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, exports.types.isRegExp = isRegExp, exports.isObject = isObject, exports.isDate = isDate, exports.types.isDate = isDate, exports.isError = isError, exports.types.isNativeError = isError, exports.isFunction = isFunction, exports.isPrimitive = isPrimitive, exports.isBuffer = __webpack_require__(384);
            var months = [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'
            ];
            function timestamp() {
                var d = new Date(), time = [
                    pad(d.getHours()),
                    pad(d.getMinutes()),
                    pad(d.getSeconds())
                ].join(':');
                return [
                    d.getDate(),
                    months[d.getMonth()],
                    time
                ].join(' ');
            }
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            exports.log = function() {
                console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
            }, exports.inherits = __webpack_require__(5717), exports._extend = function(origin, add) {
                if (!add || !isObject(add)) return origin;
                for(var keys = Object.keys(add), i = keys.length; i--;)origin[keys[i]] = add[keys[i]];
                return origin;
            };
            var kCustomPromisifiedSymbol = 'undefined' != typeof Symbol ? Symbol('util.promisify.custom') : void 0;
            function callbackifyOnRejected(reason, cb) {
                if (!reason) {
                    var newReason = Error('Promise was rejected with a falsy value');
                    newReason.reason = reason, reason = newReason;
                }
                return cb(reason);
            }
            function callbackify(original) {
                if ('function' != typeof original) throw TypeError('The "original" argument must be of type Function');
                function callbackified() {
                    for(var args = [], i = 0; i < arguments.length; i++)args.push(arguments[i]);
                    var maybeCb = args.pop();
                    if ('function' != typeof maybeCb) throw TypeError('The last argument must be of type Function');
                    var self1 = this, cb = function() {
                        return maybeCb.apply(self1, arguments);
                    };
                    original.apply(this, args).then(function(ret) {
                        process.nextTick(cb.bind(null, null, ret));
                    }, function(rej) {
                        process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                    });
                }
                return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, getOwnPropertyDescriptors(original)), callbackified;
            }
            exports.promisify = function(original) {
                if ('function' != typeof original) throw TypeError('The "original" argument must be of type Function');
                if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                    var fn = original[kCustomPromisifiedSymbol];
                    if ('function' != typeof fn) throw TypeError('The "util.promisify.custom" argument must be of type Function');
                    return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: !1,
                        writable: !1,
                        configurable: !0
                    }), fn;
                }
                function fn() {
                    for(var promiseResolve, promiseReject, promise = new Promise(function(resolve, reject) {
                        promiseResolve = resolve, promiseReject = reject;
                    }), args = [], i = 0; i < arguments.length; i++)args.push(arguments[i]);
                    args.push(function(err, value) {
                        err ? promiseReject(err) : promiseResolve(value);
                    });
                    try {
                        original.apply(this, args);
                    } catch (err) {
                        promiseReject(err);
                    }
                    return promise;
                }
                return Object.setPrototypeOf(fn, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol && Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                    value: fn,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }), Object.defineProperties(fn, getOwnPropertyDescriptors(original));
            }, exports.promisify.custom = kCustomPromisifiedSymbol, exports.callbackify = callbackify;
        },
        345: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SortKeyCacheResult = exports.CacheKey = void 0;
            class CacheKey {
                constructor(contractTxId, sortKey){
                    this.contractTxId = contractTxId, this.sortKey = sortKey;
                }
            }
            exports.CacheKey = CacheKey;
            class SortKeyCacheResult {
                constructor(sortKey, cachedValue){
                    this.sortKey = sortKey, this.cachedValue = cachedValue;
                }
            }
            exports.SortKeyCacheResult = SortKeyCacheResult;
        },
        7563: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.LevelDbCache = void 0;
            const level_1 = __webpack_require__(3145), memory_level_1 = __webpack_require__(1271), LoggerFactory_1 = __webpack_require__(5913);
            class LevelDbCache {
                constructor(cacheOptions){
                    if (this.logger = LoggerFactory_1.LoggerFactory.INST.create('LevelDbCache'), cacheOptions.inMemory) this.db = new memory_level_1.MemoryLevel({
                        valueEncoding: 'json'
                    });
                    else {
                        if (!cacheOptions.dbLocation) throw Error('LevelDb cache configuration error - no db location specified');
                        const dbLocation = cacheOptions.dbLocation;
                        this.logger.info(`Using location ${dbLocation}`), this.db = new level_1.Level(dbLocation, {
                            valueEncoding: 'json'
                        });
                    }
                }
                async get(contractTxId, sortKey, returnDeepCopy) {
                    const contractCache = this.db.sublevel(contractTxId, {
                        valueEncoding: 'json'
                    });
                    try {
                        const result = await contractCache.get(sortKey);
                        return {
                            sortKey: sortKey,
                            cachedValue: result
                        };
                    } catch (e) {
                        if ('LEVEL_NOT_FOUND' == e.code) return null;
                        throw e;
                    }
                }
                async getLast(contractTxId) {
                    const contractCache = this.db.sublevel(contractTxId, {
                        valueEncoding: 'json'
                    }), keys = await contractCache.keys({
                        reverse: !0,
                        limit: 1
                    }).all();
                    return keys.length ? {
                        sortKey: keys[0],
                        cachedValue: await contractCache.get(keys[0])
                    } : null;
                }
                async getLessOrEqual(contractTxId, sortKey) {
                    const contractCache = this.db.sublevel(contractTxId, {
                        valueEncoding: 'json'
                    }), keys = await contractCache.keys({
                        reverse: !0,
                        lte: sortKey,
                        limit: 1
                    }).all();
                    return keys.length ? {
                        sortKey: keys[0],
                        cachedValue: await contractCache.get(keys[0])
                    } : null;
                }
                async put(stateCacheKey, value) {
                    const contractCache = this.db.sublevel(stateCacheKey.contractTxId, {
                        valueEncoding: 'json'
                    });
                    await contractCache.open(), await contractCache.put(stateCacheKey.sortKey, value);
                }
                close() {
                    return this.db.close();
                }
                async dump() {
                    const result = await this.db.iterator().all();
                    return result;
                }
                async getLastSortKey() {
                    let lastSortKey = '';
                    const keys = await this.db.keys().all();
                    for (const key of keys){
                        const sortKey = key.substring(45);
                        sortKey.localeCompare(lastSortKey) > 0 && (lastSortKey = sortKey);
                    }
                    return '' == lastSortKey ? null : lastSortKey;
                }
                async allContracts() {
                    const keys = await this.db.keys().all(), result = new Set();
                    return keys.forEach((k)=>result.add(k.substring(1, 44))), Array.from(result);
                }
            }
            exports.LevelDbCache = LevelDbCache;
        },
        1200: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.MemCache = void 0;
            class MemCache {
                constructor(){
                    this.storage = {};
                }
                clearAll() {
                    Object.keys(this.storage).forEach((key)=>{
                        delete this.storage[key];
                    });
                }
                contains(key) {
                    return Object.prototype.hasOwnProperty.call(this.storage, key);
                }
                get(key) {
                    return this.storage[key];
                }
                put(key, value) {
                    this.storage[key] = value;
                }
                remove(key) {
                    delete this.storage[key];
                }
            }
            exports.MemCache = MemCache;
        },
        8469: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        9692: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            }, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.HandlerBasedContract = void 0;
            const safe_stable_stringify_1 = __importDefault(__webpack_require__(7668)), crypto1 = __importStar(__webpack_require__(1087)), ContractCallStack_1 = __webpack_require__(5614), LexicographicalInteractionsSorter_1 = __webpack_require__(1967), StateEvaluator_1 = __webpack_require__(7462), SmartWeaveTags_1 = __webpack_require__(7312), create_interaction_tx_1 = __webpack_require__(40), Benchmark_1 = __webpack_require__(9106), LoggerFactory_1 = __webpack_require__(5913), Evolve_1 = __webpack_require__(2491), ArweaveWrapper_1 = __webpack_require__(9360), utils_1 = __webpack_require__(5082), CreateContract_1 = __webpack_require__(3611), SourceImpl_1 = __webpack_require__(4217), InnerWritesEvaluator_1 = __webpack_require__(8102);
            class HandlerBasedContract {
                constructor(_contractTxId, warp, _parentContract = null, _callingInteraction = null){
                    if (this._contractTxId = _contractTxId, this.warp = warp, this._parentContract = _parentContract, this._callingInteraction = _callingInteraction, this.logger = LoggerFactory_1.LoggerFactory.INST.create('HandlerBasedContract'), this._evaluationOptions = new StateEvaluator_1.DefaultEvaluationOptions(), this._innerWritesEvaluator = new InnerWritesEvaluator_1.InnerWritesEvaluator(), this._benchmarkStats = null, this.waitForConfirmation = this.waitForConfirmation.bind(this), this._arweaveWrapper = new ArweaveWrapper_1.ArweaveWrapper(warp.arweave), this._sorter = new LexicographicalInteractionsSorter_1.LexicographicalInteractionsSorter(warp.arweave), null != _parentContract) {
                        this._evaluationOptions = _parentContract.evaluationOptions(), this._callDepth = _parentContract.callDepth() + 1;
                        const interaction = _parentContract.getCallStack().getInteraction(_callingInteraction.id);
                        if (this._callDepth > this._evaluationOptions.maxCallDepth) throw Error(`Max call depth of ${this._evaluationOptions.maxCallDepth} has been exceeded for interaction ${JSON.stringify(interaction.interactionInput)}`);
                        this.logger.debug('Calling interaction', {
                            id: _callingInteraction.id,
                            sortKey: _callingInteraction.sortKey
                        });
                        const callStack = new ContractCallStack_1.ContractCallStack(_contractTxId, this._callDepth);
                        interaction.interactionInput.foreignContractCalls.set(_contractTxId, callStack), this._callStack = callStack, this._rootSortKey = _parentContract.rootSortKey;
                    } else this._callDepth = 0, this._callStack = new ContractCallStack_1.ContractCallStack(_contractTxId, 0), this._rootSortKey = null;
                }
                async readState(sortKeyOrBlockHeight, currentTx, interactions) {
                    var _a, _b, _c;
                    this.logger.info('Read state for', {
                        contractTxId: this._contractTxId,
                        currentTx,
                        sortKeyOrBlockHeight
                    });
                    const initBenchmark = Benchmark_1.Benchmark.measure();
                    if (this.maybeResetRootContract(), null != this._parentContract && null == sortKeyOrBlockHeight) throw Error('SortKey MUST be always set for non-root contract calls');
                    const { stateEvaluator  } = this.warp, sortKey = 'number' == typeof sortKeyOrBlockHeight ? this._sorter.generateLastSortKey(sortKeyOrBlockHeight) : sortKeyOrBlockHeight, executionContext = await this.createExecutionContext(this._contractTxId, sortKey, !1, interactions);
                    this.logger.info('Execution Context', {
                        srcTxId: null === (_a = executionContext.contractDefinition) || void 0 === _a ? void 0 : _a.srcTxId,
                        missingInteractions: null === (_b = executionContext.sortedInteractions) || void 0 === _b ? void 0 : _b.length,
                        cachedSortKey: null === (_c = executionContext.cachedState) || void 0 === _c ? void 0 : _c.sortKey
                    }), initBenchmark.stop();
                    const stateBenchmark = Benchmark_1.Benchmark.measure(), result = await stateEvaluator.eval(executionContext, currentTx || []);
                    stateBenchmark.stop();
                    const total = initBenchmark.elapsed(!0) + stateBenchmark.elapsed(!0);
                    return this._benchmarkStats = {
                        gatewayCommunication: initBenchmark.elapsed(!0),
                        stateEvaluation: stateBenchmark.elapsed(!0),
                        total
                    }, this.logger.info('Benchmark', {
                        'Gateway communication  ': initBenchmark.elapsed(),
                        'Contract evaluation    ': stateBenchmark.elapsed(),
                        'Total:                 ': `${total.toFixed(0)}ms`
                    }), result;
                }
                async viewState(input, tags = [], transfer = CreateContract_1.emptyTransfer) {
                    return this.logger.info('View state for', this._contractTxId), await this.callContract(input, void 0, void 0, tags, transfer);
                }
                async viewStateForTx(input, interactionTx) {
                    return this.logger.info(`View state for ${this._contractTxId}`, interactionTx), await this.callContractForTx(input, interactionTx);
                }
                async dryWrite(input, caller, tags, transfer) {
                    return this.logger.info('Dry-write for', this._contractTxId), await this.callContract(input, caller, void 0, tags, transfer);
                }
                async dryWriteFromTx(input, transaction, currentTx) {
                    return this.logger.info(`Dry-write from transaction ${transaction.id} for ${this._contractTxId}`), await this.callContractForTx(input, transaction, currentTx || []);
                }
                async writeInteraction(input, options) {
                    if (this.logger.info('Write interaction', {
                        input,
                        options
                    }), !this.signer) throw Error("Wallet not connected. Use 'connect' method first.");
                    const { arweave , interactionsLoader  } = this.warp, effectiveTags = (null == options ? void 0 : options.tags) || [], effectiveTransfer = (null == options ? void 0 : options.transfer) || CreateContract_1.emptyTransfer, effectiveStrict = (null == options ? void 0 : options.strict) === !0, effectiveVrf = (null == options ? void 0 : options.vrf) === !0, effectiveDisableBundling = (null == options ? void 0 : options.disableBundling) === !0, effectiveReward = null == options ? void 0 : options.reward, bundleInteraction = 'warp' == interactionsLoader.type() && !effectiveDisableBundling;
                    if (bundleInteraction && effectiveTransfer.target != CreateContract_1.emptyTransfer.target && effectiveTransfer.winstonQty != CreateContract_1.emptyTransfer.winstonQty) throw Error('Ar Transfers are not allowed for bundled interactions');
                    if (effectiveVrf && !bundleInteraction) throw Error('Vrf generation is only available for bundle interaction');
                    if (bundleInteraction) return await this.bundleInteraction(input, {
                        tags: effectiveTags,
                        strict: effectiveStrict,
                        vrf: effectiveVrf
                    });
                    {
                        const interactionTx = await this.createInteraction(input, effectiveTags, effectiveTransfer, effectiveStrict, !1, !1, effectiveReward), response = await arweave.transactions.post(interactionTx);
                        if (200 !== response.status) return this.logger.error('Error while posting transaction', response), null;
                        if (this._evaluationOptions.waitForConfirmation) {
                            this.logger.info('Waiting for confirmation of', interactionTx.id);
                            const benchmark = Benchmark_1.Benchmark.measure();
                            await this.waitForConfirmation(interactionTx.id), this.logger.info('Transaction confirmed after', benchmark.elapsed());
                        }
                        return 'local' == this.warp.environment && this._evaluationOptions.mineArLocalBlocks && await this.warp.testing.mineBlock(), {
                            originalTxId: interactionTx.id
                        };
                    }
                }
                async bundleInteraction(input, options) {
                    this.logger.info('Bundle interaction input', input);
                    const interactionTx = await this.createInteraction(input, options.tags, CreateContract_1.emptyTransfer, options.strict, !0, options.vrf), response = await fetch(`${this._evaluationOptions.bundlerUrl}gateway/sequencer/register`, {
                        method: 'POST',
                        body: JSON.stringify(interactionTx),
                        headers: {
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Content-Type': 'application/json',
                            Accept: 'application/json'
                        }
                    }).then((res)=>(this.logger.debug(res), res.ok ? res.json() : Promise.reject(res))).catch((error)=>{
                        var _a;
                        throw this.logger.error(error), (null === (_a = error.body) || void 0 === _a ? void 0 : _a.message) && this.logger.error(error.body.message), Error(`Unable to bundle interaction: ${JSON.stringify(error)}`);
                    });
                    return {
                        bundlrResponse: response,
                        originalTxId: interactionTx.id
                    };
                }
                async createInteraction(input, tags, transfer, strict, bundle = !1, vrf = !1, reward) {
                    if (this._evaluationOptions.internalWrites) {
                        const handlerResult = await this.callContract(input, void 0, void 0, tags, transfer);
                        if (strict && 'ok' !== handlerResult.type) throw Error(`Cannot create interaction: ${handlerResult.errorMessage}`);
                        const callStack = this.getCallStack(), innerWrites = this._innerWritesEvaluator.eval(callStack);
                        this.logger.debug('Input', input), this.logger.debug('Callstack', callStack.print()), innerWrites.forEach((contractTxId)=>{
                            tags.push({
                                name: SmartWeaveTags_1.SmartWeaveTags.INTERACT_WRITE,
                                value: contractTxId
                            });
                        }), this.logger.debug('Tags with inner calls', tags);
                    } else if (strict) {
                        const handlerResult1 = await this.callContract(input, void 0, void 0, tags, transfer);
                        if ('ok' !== handlerResult1.type) throw Error(`Cannot create interaction: ${handlerResult1.errorMessage}`);
                    }
                    vrf && tags.push({
                        name: SmartWeaveTags_1.SmartWeaveTags.REQUEST_VRF,
                        value: 'true'
                    });
                    const interactionTx = await (0, create_interaction_tx_1.createInteractionTx)(this.warp.arweave, this.signer, this._contractTxId, input, tags, transfer.target, transfer.winstonQty, bundle, reward);
                    return interactionTx;
                }
                txId() {
                    return this._contractTxId;
                }
                getCallStack() {
                    return this._callStack;
                }
                connect(signer) {
                    return 'function' == typeof signer ? this.signer = signer : this.signer = async (tx)=>{
                        await this.warp.arweave.transactions.sign(tx, signer);
                    }, this;
                }
                setEvaluationOptions(options) {
                    return this._evaluationOptions = {
                        ...this._evaluationOptions,
                        ...options
                    }, this;
                }
                async waitForConfirmation(transactionId) {
                    const { arweave  } = this.warp, status = await arweave.transactions.getStatus(transactionId);
                    if (null !== status.confirmed) return this.logger.info(`Transaction ${transactionId} confirmed`, status), status;
                    this.logger.info(`Transaction ${transactionId} not yet confirmed. Waiting another 20 seconds before next check.`), await (0, utils_1.sleep)(20000), await this.waitForConfirmation(transactionId);
                }
                async createExecutionContext(contractTxId, upToSortKey, forceDefinitionLoad = !1, interactions) {
                    var _a;
                    const { definitionLoader , interactionsLoader , executorFactory , stateEvaluator  } = this.warp, benchmark = Benchmark_1.Benchmark.measure(), cachedState = await stateEvaluator.latestAvailableState(contractTxId, upToSortKey);
                    this.logger.debug('cache lookup', benchmark.elapsed()), benchmark.reset();
                    const evolvedSrcTxId = Evolve_1.Evolve.evolvedSrcTxId(null === (_a = null == cachedState ? void 0 : cachedState.cachedValue) || void 0 === _a ? void 0 : _a.state);
                    let handler, contractDefinition, sortedInteractions;
                    return this.logger.debug('Cached state', cachedState, upToSortKey), cachedState && cachedState.sortKey == upToSortKey ? (this.logger.debug('State fully cached, not loading interactions.'), (forceDefinitionLoad || evolvedSrcTxId) && (handler = await executorFactory.create(contractDefinition = await definitionLoader.load(contractTxId, evolvedSrcTxId), this._evaluationOptions))) : ([contractDefinition, sortedInteractions] = await Promise.all([
                        definitionLoader.load(contractTxId, evolvedSrcTxId),
                        interactions ? Promise.resolve(interactions) : await interactionsLoader.load(contractTxId, null == cachedState ? void 0 : cachedState.sortKey, this.getToSortKey(upToSortKey), this._evaluationOptions)
                    ]), (null == cachedState ? void 0 : cachedState.sortKey) && (sortedInteractions = sortedInteractions.filter((i)=>i.sortKey.localeCompare(null == cachedState ? void 0 : cachedState.sortKey) > 0)), upToSortKey && (sortedInteractions = sortedInteractions.filter((i)=>0 >= i.sortKey.localeCompare(upToSortKey))), this.logger.debug('contract and interactions load', benchmark.elapsed()), null == this._parentContract && sortedInteractions.length && (this._rootSortKey = sortedInteractions[sortedInteractions.length - 1].sortKey), handler = await executorFactory.create(contractDefinition, this._evaluationOptions)), {
                        warp: this.warp,
                        contract: this,
                        contractDefinition,
                        sortedInteractions,
                        evaluationOptions: this._evaluationOptions,
                        handler,
                        cachedState,
                        requestedSortKey: upToSortKey
                    };
                }
                getToSortKey(upToSortKey) {
                    var _a;
                    return null !== (_a = this._parentContract) && void 0 !== _a && _a.rootSortKey ? upToSortKey ? this._parentContract.rootSortKey.localeCompare(upToSortKey) > 0 ? this._parentContract.rootSortKey : upToSortKey : this._parentContract.rootSortKey : upToSortKey;
                }
                async createExecutionContextFromTx(contractTxId, transaction) {
                    const caller = transaction.owner.address, sortKey = transaction.sortKey, baseContext = await this.createExecutionContext(contractTxId, sortKey, !0);
                    return {
                        ...baseContext,
                        caller
                    };
                }
                maybeResetRootContract() {
                    null == this._parentContract && (this.logger.debug('Clearing call stack for the root contract'), this._callStack = new ContractCallStack_1.ContractCallStack(this.txId(), 0), this._rootSortKey = null, this.warp.interactionsLoader.clearCache());
                }
                async callContract(input, caller, sortKey, tags = [], transfer = CreateContract_1.emptyTransfer) {
                    this.logger.info('Call contract input', input), this.maybeResetRootContract(), this.signer || this.logger.warn('Wallet not set.');
                    const { arweave , stateEvaluator  } = this.warp;
                    let executionContext = await this.createExecutionContext(this._contractTxId, sortKey, !0);
                    const currentBlockData = 'mainnet' == this.warp.environment ? await this._arweaveWrapper.warpGwBlock() : await arweave.blocks.getCurrent();
                    let effectiveCaller;
                    if (caller) effectiveCaller = caller;
                    else if (this.signer) {
                        const dummyTx = await arweave.createTransaction({
                            data: Math.random().toString().slice(-4),
                            reward: '72600854',
                            last_tx: 'p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO'
                        });
                        await this.signer(dummyTx), effectiveCaller = await arweave.wallets.ownerToAddress(dummyTx.owner);
                    } else effectiveCaller = '';
                    this.logger.info('effectiveCaller', effectiveCaller), executionContext = {
                        ...executionContext,
                        caller: effectiveCaller
                    };
                    const evalStateResult = await stateEvaluator.eval(executionContext, []);
                    this.logger.info('Current state', evalStateResult.cachedValue.state);
                    const interaction = {
                        input,
                        caller: executionContext.caller
                    };
                    this.logger.debug('interaction', interaction);
                    const tx = await (0, create_interaction_tx_1.createInteractionTx)(arweave, this.signer, this._contractTxId, input, tags, transfer.target, transfer.winstonQty, !0), dummyTx1 = (0, create_interaction_tx_1.createDummyTx)(tx, executionContext.caller, currentBlockData);
                    this.logger.debug('Creating sortKey for', {
                        blockId: dummyTx1.block.id,
                        id: dummyTx1.id,
                        height: dummyTx1.block.height
                    }), dummyTx1.sortKey = await this._sorter.createSortKey(dummyTx1.block.id, dummyTx1.id, dummyTx1.block.height, !0);
                    const handleResult = await this.evalInteraction({
                        interaction,
                        interactionTx: dummyTx1,
                        currentTx: []
                    }, executionContext, evalStateResult.cachedValue);
                    return 'ok' !== handleResult.type && this.logger.fatal('Error while interacting with contract', {
                        type: handleResult.type,
                        error: handleResult.errorMessage
                    }), handleResult;
                }
                async callContractForTx(input, interactionTx, currentTx) {
                    this.maybeResetRootContract();
                    const executionContext = await this.createExecutionContextFromTx(this._contractTxId, interactionTx), evalStateResult = await this.warp.stateEvaluator.eval(executionContext, currentTx);
                    this.logger.debug('callContractForTx - evalStateResult', {
                        result: evalStateResult.cachedValue.state,
                        txId: this._contractTxId
                    });
                    const interaction = {
                        input,
                        caller: this._parentContract.txId()
                    }, interactionData = {
                        interaction,
                        interactionTx,
                        currentTx
                    }, result = await this.evalInteraction(interactionData, executionContext, evalStateResult.cachedValue);
                    return result.originalValidity = evalStateResult.cachedValue.validity, result.originalErrorMessages = evalStateResult.cachedValue.errorMessages, result;
                }
                async evalInteraction(interactionData, executionContext, evalStateResult) {
                    const interactionCall = this.getCallStack().addInteractionData(interactionData), benchmark = Benchmark_1.Benchmark.measure(), result = await executionContext.handler.handle(executionContext, evalStateResult, interactionData);
                    return interactionCall.update({
                        cacheHit: !1,
                        outputState: this._evaluationOptions.stackTrace.saveState ? result.state : void 0,
                        executionTime: benchmark.elapsed(!0),
                        valid: 'ok' === result.type,
                        errorMessage: result.errorMessage,
                        gasUsed: result.gasUsed
                    }), result;
                }
                parent() {
                    return this._parentContract;
                }
                callDepth() {
                    return this._callDepth;
                }
                evaluationOptions() {
                    return this._evaluationOptions;
                }
                lastReadStateStats() {
                    return this._benchmarkStats;
                }
                stateHash(state) {
                    const jsonState = (0, safe_stable_stringify_1.default)(state), hash = crypto1.createHash('sha256');
                    return hash.update(jsonState), hash.digest('hex');
                }
                async syncState(externalUrl, params) {
                    const { stateEvaluator  } = this.warp, response = await fetch(`${externalUrl}?${new URLSearchParams({
                        id: this._contractTxId,
                        ...params
                    })}`).then((res)=>res.ok ? res.json() : Promise.reject(res)).catch((error)=>{
                        var _a, _b;
                        throw (null === (_a = error.body) || void 0 === _a ? void 0 : _a.message) && this.logger.error(error.body.message), Error(`Unable to retrieve state. ${error.status}: ${null === (_b = error.body) || void 0 === _b ? void 0 : _b.message}`);
                    });
                    return await stateEvaluator.syncState(this._contractTxId, response.sortKey, response.state, response.validity), this;
                }
                async evolve(newSrcTxId, options) {
                    return await this.writeInteraction({
                        function: 'evolve',
                        value: newSrcTxId
                    }, options);
                }
                async save(sourceData) {
                    if (!this.signer) throw Error("Wallet not connected. Use 'connect' method first.");
                    const { arweave  } = this.warp, source = new SourceImpl_1.SourceImpl(arweave), srcTx = await source.save(sourceData, this.signer);
                    return srcTx.id;
                }
                get callingInteraction() {
                    return this._callingInteraction;
                }
                get rootSortKey() {
                    return this._rootSortKey;
                }
            }
            exports.HandlerBasedContract = HandlerBasedContract;
        },
        8102: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.InnerWritesEvaluator = void 0;
            class InnerWritesEvaluator {
                eval(callStack) {
                    const result = [];
                    return callStack.interactions.forEach((interaction)=>{
                        this.evalForeignCalls(callStack.contractTxId, interaction, result);
                    }), result;
                }
                evalForeignCalls(rootContractTxId, interaction, result) {
                    interaction.interactionInput.foreignContractCalls.forEach((foreignContractCall)=>{
                        foreignContractCall.interactions.forEach((foreignInteraction)=>{
                            foreignInteraction.interactionInput.dryWrite && !result.includes(foreignContractCall.contractTxId) && rootContractTxId !== foreignContractCall.contractTxId && result.push(foreignContractCall.contractTxId), this.evalForeignCalls(rootContractTxId, foreignInteraction, result);
                        });
                    });
                }
            }
            exports.InnerWritesEvaluator = InnerWritesEvaluator;
        },
        7665: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        7819: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.PstContractImpl = void 0;
            const HandlerBasedContract_1 = __webpack_require__(9692);
            class PstContractImpl extends HandlerBasedContract_1.HandlerBasedContract {
                async currentBalance(target) {
                    const interactionResult = await this.viewState({
                        function: 'balance',
                        target
                    });
                    if ('ok' !== interactionResult.type) throw Error(interactionResult.errorMessage);
                    return interactionResult.result;
                }
                async currentState() {
                    return (await super.readState()).cachedValue.state;
                }
                async transfer(transfer, options) {
                    return await this.writeInteraction({
                        function: 'transfer',
                        ...transfer
                    }, options);
                }
            }
            exports.PstContractImpl = PstContractImpl;
        },
        3611: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.emptyTransfer = void 0, exports.emptyTransfer = {
                target: '',
                winstonQty: '0'
            };
        },
        4722: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        5731: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.DefaultCreateContract = void 0;
            const SmartWeaveTags_1 = __webpack_require__(7312), WarpFactory_1 = __webpack_require__(8479), LoggerFactory_1 = __webpack_require__(5913), SourceImpl_1 = __webpack_require__(4217);
            class DefaultCreateContract {
                constructor(arweave, warp){
                    this.arweave = arweave, this.warp = warp, this.logger = LoggerFactory_1.LoggerFactory.INST.create('DefaultCreateContract'), this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
                }
                async deploy(contractData, disableBundling) {
                    const { wallet , initState , tags , transfer , data  } = contractData, effectiveUseBundler = void 0 == disableBundling ? 'warp' == this.warp.definitionLoader.type() : !disableBundling, source = new SourceImpl_1.SourceImpl(this.arweave), srcTx = await source.save(contractData, wallet, effectiveUseBundler);
                    return this.logger.debug('Creating new contract'), await this.deployFromSourceTx({
                        srcTxId: srcTx.id,
                        wallet,
                        initState,
                        tags,
                        transfer,
                        data
                    }, !effectiveUseBundler, srcTx);
                }
                async deployFromSourceTx(contractData, disableBundling, srcTx = null) {
                    this.logger.debug('Creating new contract from src tx');
                    const { wallet , srcTxId , initState , tags , transfer , data  } = contractData, effectiveUseBundler = void 0 == disableBundling ? 'warp' == this.warp.definitionLoader.type() : !disableBundling;
                    let contractTX = await this.arweave.createTransaction({
                        data: (null == data ? void 0 : data.body) || initState
                    }, wallet);
                    if (+(null == transfer ? void 0 : transfer.winstonQty) > 0 && transfer.target.length && (this.logger.debug('Creating additional transaction with AR transfer', transfer), contractTX = await this.arweave.createTransaction({
                        data: (null == data ? void 0 : data.body) || initState,
                        target: transfer.target,
                        quantity: transfer.winstonQty
                    }, wallet)), null == tags ? void 0 : tags.length) for (const tag of tags)contractTX.addTag(tag.name.toString(), tag.value.toString());
                    contractTX.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_NAME, 'SmartWeaveContract'), contractTX.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_VERSION, '0.3.0'), contractTX.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTRACT_SRC_TX_ID, srcTxId), contractTX.addTag(SmartWeaveTags_1.SmartWeaveTags.SDK, 'RedStone'), data ? (contractTX.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTENT_TYPE, data['Content-Type']), contractTX.addTag(SmartWeaveTags_1.SmartWeaveTags.INIT_STATE, initState)) : contractTX.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTENT_TYPE, 'application/json'), await this.arweave.transactions.sign(contractTX, wallet);
                    let responseOk, response;
                    if (effectiveUseBundler) {
                        const result = await this.post(contractTX, srcTx);
                        this.logger.debug(result), responseOk = !0;
                    } else responseOk = 200 === (response = await this.arweave.transactions.post(contractTX)).status || 208 === response.status;
                    if (responseOk) return {
                        contractTxId: contractTX.id,
                        srcTxId
                    };
                    throw Error(`Unable to write Contract. Arweave responded with status ${response.status}: ${response.statusText}`);
                }
                async post(contractTx, srcTx = null) {
                    let body = {
                        contractTx
                    };
                    srcTx && (body = {
                        ...body,
                        srcTx
                    });
                    const response = await fetch(`${WarpFactory_1.WARP_GW_URL}/gateway/contracts/deploy`, {
                        method: 'POST',
                        body: JSON.stringify(body),
                        headers: {
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Content-Type': 'application/json',
                            Accept: 'application/json'
                        }
                    });
                    if (response.ok) return response.json();
                    throw Error(`Error while posting contract. Sequencer responded with status ${response.status} ${response.statusText}`);
                }
            }
            exports.DefaultCreateContract = DefaultCreateContract;
        },
        4217: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(8764).Buffer, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SourceImpl = void 0;
            const redstone_wasm_metering_1 = __importDefault(__webpack_require__(8060)), go_wasm_imports_1 = __webpack_require__(7170), fs_1 = __importDefault(__webpack_require__(9827)), wasm_bindgen_tools_1 = __webpack_require__(4742), SmartWeaveTags_1 = __webpack_require__(7312), LoggerFactory_1 = __webpack_require__(5913), wasmTypeMapping = new Map([
                [
                    1,
                    'assemblyscript'
                ],
                [
                    2,
                    'rust'
                ],
                [
                    3,
                    'go'
                ]
            ]);
            class SourceImpl {
                constructor(arweave){
                    this.arweave = arweave, this.logger = LoggerFactory_1.LoggerFactory.INST.create('Source');
                }
                async save(contractData, signer, useBundler = !1) {
                    this.logger.debug('Creating new contract source');
                    const { src , wasmSrcCodeDir , wasmGlueCode  } = contractData, contractType = src instanceof Buffer ? 'wasm' : 'js';
                    let srcTx, wasmLang = null, wasmVersion = null;
                    const metadata = {}, data = [];
                    if ('wasm' == contractType) {
                        const meteredWasmBinary = redstone_wasm_metering_1.default.meterWASM(src, {
                            meterType: 'i32'
                        });
                        data.push(meteredWasmBinary);
                        const wasmModule = await WebAssembly.compile(src), moduleImports = WebAssembly.Module.imports(wasmModule);
                        let lang;
                        if (this.isGoModule(moduleImports)) {
                            const go = new go_wasm_imports_1.Go(null), module = new WebAssembly.Instance(wasmModule, go.importObject);
                            go.run(module), lang = go.exports.lang(), wasmVersion = go.exports.version();
                        } else {
                            const module1 = await WebAssembly.instantiate(src, dummyImports(moduleImports));
                            if (!module1.instance.exports.lang) throw Error('No info about source type in wasm binary. Did you forget to export "lang" function?');
                            if (lang = module1.instance.exports.lang(), wasmVersion = module1.instance.exports.version(), !wasmTypeMapping.has(lang)) throw Error(`Unknown wasm source type ${lang}`);
                        }
                        if (wasmLang = wasmTypeMapping.get(lang), null == wasmSrcCodeDir) throw Error('No path to original wasm contract source code');
                        const zippedSourceCode = await this.zipContents(wasmSrcCodeDir);
                        if (data.push(zippedSourceCode), 'rust' == wasmLang) {
                            if (!wasmGlueCode) throw Error('No path to generated wasm-bindgen js code');
                            const wasmBindgenSrc = fs_1.default.readFileSync(wasmGlueCode, 'utf-8'), dtor = (0, wasm_bindgen_tools_1.matchMutClosureDtor)(wasmBindgenSrc);
                            metadata.dtor = parseInt(dtor), data.push(Buffer.from(wasmBindgenSrc));
                        }
                    }
                    const allData = 'wasm' == contractType ? this.joinBuffers(data) : src;
                    (srcTx = 'function' == typeof signer ? await this.arweave.createTransaction({
                        data: allData
                    }) : await this.arweave.createTransaction({
                        data: allData
                    }, signer)).addTag(SmartWeaveTags_1.SmartWeaveTags.APP_NAME, 'SmartWeaveContractSource'), srcTx.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_VERSION, '0.3.0'), srcTx.addTag(SmartWeaveTags_1.SmartWeaveTags.SDK, 'Warp'), srcTx.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTENT_TYPE, 'js' == contractType ? 'application/javascript' : 'application/wasm'), 'wasm' == contractType && (srcTx.addTag(SmartWeaveTags_1.SmartWeaveTags.WASM_LANG, wasmLang), srcTx.addTag(SmartWeaveTags_1.SmartWeaveTags.WASM_LANG_VERSION, wasmVersion), srcTx.addTag(SmartWeaveTags_1.SmartWeaveTags.WASM_META, JSON.stringify(metadata))), 'function' == typeof signer ? await signer(srcTx) : await this.arweave.transactions.sign(srcTx, signer), this.logger.debug('Posting transaction with source');
                    let responseOk = !0, response;
                    if (useBundler || (responseOk = 200 === (response = await this.arweave.transactions.post(srcTx)).status || 208 === response.status), responseOk) return srcTx;
                    throw Error(`Unable to write Contract Source. Arweave responded with status ${response.status}: ${response.statusText}`);
                }
                isGoModule(moduleImports) {
                    return moduleImports.some((moduleImport)=>'env' == moduleImport.module && moduleImport.name.startsWith('syscall/js'));
                }
                joinBuffers(buffers) {
                    const length = buffers.length, result = [];
                    return result.push(Buffer.from(length.toString())), result.push(Buffer.from('|')), buffers.forEach((b)=>{
                        result.push(Buffer.from(b.length.toString())), result.push(Buffer.from('|'));
                    }), result.push(...buffers), result.reduce((prev, b)=>Buffer.concat([
                            prev,
                            b
                        ]));
                }
                async zipContents(source) {
                    const archiver = __webpack_require__(1445), streamBuffers = __webpack_require__(4034), outputStreamBuffer = new streamBuffers.WritableStreamBuffer({
                        initialSize: 1024000,
                        incrementAmount: 1024000
                    }), archive = archiver('zip', {
                        zlib: {
                            level: 9
                        }
                    });
                    return archive.on('error', function(err) {
                        throw err;
                    }), archive.pipe(outputStreamBuffer), archive.directory(source.toString(), source.toString()), await archive.finalize(), outputStreamBuffer.end(), outputStreamBuffer.getContents();
                }
            }
            function dummyImports(moduleImports) {
                const imports = {};
                return moduleImports.forEach((moduleImport)=>{
                    Object.prototype.hasOwnProperty.call(imports, moduleImport.module) || (imports[moduleImport.module] = {}), imports[moduleImport.module][moduleImport.name] = function() {};
                }), imports;
            }
            exports.SourceImpl = SourceImpl;
        },
        3667: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.MigrationTool = void 0;
            const LexicographicalInteractionsSorter_1 = __webpack_require__(1967), StateEvaluator_1 = __webpack_require__(7462), knex_1 = __importDefault(__webpack_require__(771)), LoggerFactory_1 = __webpack_require__(5913);
            class MigrationTool {
                constructor(arweave, levelDb){
                    this.arweave = arweave, this.levelDb = levelDb, this.logger = LoggerFactory_1.LoggerFactory.INST.create('MigrationTool'), this.sorter = new LexicographicalInteractionsSorter_1.LexicographicalInteractionsSorter(arweave);
                }
                async migrateSqlite(sqlitePath) {
                    this.logger.info(`Migrating from sqlite ${sqlitePath} to leveldb.`);
                    const knexDb = (0, knex_1.default)({
                        client: 'sqlite3',
                        connection: {
                            filename: sqlitePath
                        },
                        useNullAsDefault: !0
                    }), cache = await knexDb.select([
                        'contract_id',
                        'height',
                        'state'
                    ]).from('states').max('height').groupBy([
                        'contract_id'
                    ]);
                    this.logger.info(`Migrating ${null == cache ? void 0 : cache.length} contracts' state`);
                    const result = [];
                    for (const entry of cache){
                        const contractTxId = entry.contract_id, height = entry.height, state = JSON.parse(entry.state), sortKey = this.sorter.generateLastSortKey(parseInt(height));
                        this.logger.debug(`Migrating ${contractTxId} at height ${height}: ${sortKey}`), await this.levelDb.put({
                            contractTxId,
                            sortKey
                        }, new StateEvaluator_1.EvalStateResult(state.state, state.validity, {})), result.push({
                            contractTxId,
                            height,
                            sortKey
                        });
                    }
                    return this.logger.info("Migration done."), result;
                }
            }
            exports.MigrationTool = MigrationTool;
        },
        4464: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Testing = void 0;
            class Testing {
                constructor(arweave){
                    this.arweave = arweave;
                }
                async mineBlock() {
                    this.validateEnv(), await this.arweave.api.get('mine');
                }
                async generateWallet() {
                    this.validateEnv();
                    const wallet = await this.arweave.wallets.generate();
                    return await this.addFunds(wallet), wallet;
                }
                async addFunds(wallet) {
                    const walletAddress = await this.arweave.wallets.getAddress(wallet);
                    await this.arweave.api.get(`/mint/${walletAddress}/1000000000000000`);
                }
                validateEnv() {
                    if (this.arweave.api.getConfig().host.includes('arweave')) throw Error('Testing features are not available in a non testing environment');
                }
            }
            exports.Testing = Testing;
        },
        5614: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.InteractionOutput = exports.InteractionInput = exports.InteractionCall = exports.ContractCallStack = void 0;
            const utils_1 = __webpack_require__(5082);
            class ContractCallStack {
                constructor(contractTxId, depth, label = ''){
                    this.contractTxId = contractTxId, this.depth = depth, this.label = label, this.interactions = new Map();
                }
                addInteractionData(interactionData) {
                    const { interaction , interactionTx  } = interactionData, interactionCall = InteractionCall.create(new InteractionInput(interactionTx.id, interactionTx.sortKey, interactionTx.block.height, interactionTx.block.timestamp, null == interaction ? void 0 : interaction.caller, null == interaction ? void 0 : interaction.input.function, null == interaction ? void 0 : interaction.input, interactionTx.dry, new Map()));
                    return this.interactions.set(interactionTx.id, interactionCall), interactionCall;
                }
                getInteraction(txId) {
                    return this.interactions.get(txId);
                }
                print() {
                    return JSON.stringify(this, utils_1.mapReplacer);
                }
            }
            exports.ContractCallStack = ContractCallStack;
            class InteractionCall {
                constructor(interactionInput){
                    this.interactionInput = interactionInput;
                }
                static create(interactionInput) {
                    return new InteractionCall(interactionInput);
                }
                update(interactionOutput) {
                    this.interactionOutput = interactionOutput;
                }
            }
            exports.InteractionCall = InteractionCall;
            class InteractionInput {
                constructor(txId, sortKey, blockHeight, blockTimestamp, caller, functionName, functionArguments, dryWrite, foreignContractCalls = new Map()){
                    this.txId = txId, this.sortKey = sortKey, this.blockHeight = blockHeight, this.blockTimestamp = blockTimestamp, this.caller = caller, this.functionName = functionName, this.functionArguments = functionArguments, this.dryWrite = dryWrite, this.foreignContractCalls = foreignContractCalls;
                }
            }
            exports.InteractionInput = InteractionInput;
            class InteractionOutput {
                constructor(cacheHit, outputState, executionTime, valid, errorMessage = '', gasUsed){
                    this.cacheHit = cacheHit, this.outputState = outputState, this.executionTime = executionTime, this.valid = valid, this.errorMessage = errorMessage, this.gasUsed = gasUsed;
                }
            }
            exports.InteractionOutput = InteractionOutput;
        },
        9305: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.ContractMetadata = void 0;
            class ContractMetadata {
            }
            exports.ContractMetadata = ContractMetadata;
        },
        4805: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        8632: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        7312: function(__unused_webpack_module, exports) {
            "use strict";
            var SmartWeaveTags, SmartWeaveTags1;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SmartWeaveTags = void 0, (SmartWeaveTags1 = SmartWeaveTags = exports.SmartWeaveTags || (exports.SmartWeaveTags = {})).APP_NAME = "App-Name", SmartWeaveTags1.APP_VERSION = "App-Version", SmartWeaveTags1.CONTRACT_TX_ID = "Contract", SmartWeaveTags1.INPUT = "Input", SmartWeaveTags1.CONTENT_TYPE = "Content-Type", SmartWeaveTags1.CONTRACT_SRC_TX_ID = "Contract-Src", SmartWeaveTags1.SDK = "SDK", SmartWeaveTags1.MIN_FEE = "Min-Fee", SmartWeaveTags1.INIT_STATE = "Init-State", SmartWeaveTags1.INIT_STATE_TX = "Init-State-TX", SmartWeaveTags1.INTERACT_WRITE = "Interact-Write", SmartWeaveTags1.WASM_LANG = "Wasm-Lang", SmartWeaveTags1.WASM_LANG_VERSION = "Wasm-Lang-Version", SmartWeaveTags1.WASM_META = "Wasm-Meta", SmartWeaveTags1.REQUEST_VRF = "Request-Vrf";
        },
        2009: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Warp = void 0;
            const DefaultCreateContract_1 = __webpack_require__(5731), HandlerBasedContract_1 = __webpack_require__(9692), PstContractImpl_1 = __webpack_require__(7819), MigrationTool_1 = __webpack_require__(3667), Testing_1 = __webpack_require__(4464), WarpBuilder_1 = __webpack_require__(9689);
            class Warp {
                constructor(arweave, levelDb, definitionLoader, interactionsLoader, executorFactory, stateEvaluator, environment = 'custom'){
                    this.arweave = arweave, this.levelDb = levelDb, this.definitionLoader = definitionLoader, this.interactionsLoader = interactionsLoader, this.executorFactory = executorFactory, this.stateEvaluator = stateEvaluator, this.environment = environment, this.createContract = new DefaultCreateContract_1.DefaultCreateContract(arweave, this), this.migrationTool = new MigrationTool_1.MigrationTool(arweave, levelDb), this.testing = new Testing_1.Testing(arweave);
                }
                static builder(arweave, cache, environment) {
                    return new WarpBuilder_1.WarpBuilder(arweave, cache, environment);
                }
                contract(contractTxId, callingContract, callingInteraction) {
                    return new HandlerBasedContract_1.HandlerBasedContract(contractTxId, this, callingContract, callingInteraction);
                }
                pst(contractTxId) {
                    return new PstContractImpl_1.PstContractImpl(contractTxId, this);
                }
            }
            exports.Warp = Warp;
        },
        9689: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.WarpBuilder = void 0;
            const MemCache_1 = __webpack_require__(1200), DebuggableExecutorFactor_1 = __webpack_require__(4481), ArweaveGatewayInteractionsLoader_1 = __webpack_require__(9564), CacheableInteractionsLoader_1 = __webpack_require__(7346), ContractDefinitionLoader_1 = __webpack_require__(7089), WarpGatewayContractDefinitionLoader_1 = __webpack_require__(3187), WarpGatewayInteractionsLoader_1 = __webpack_require__(1533), Warp_1 = __webpack_require__(2009);
            class WarpBuilder {
                constructor(_arweave, _cache, _environment = 'custom'){
                    this._arweave = _arweave, this._cache = _cache, this._environment = _environment;
                }
                setDefinitionLoader(value) {
                    return this._definitionLoader = value, this;
                }
                setInteractionsLoader(value) {
                    return this._interactionsLoader = value, this;
                }
                setExecutorFactory(value) {
                    return this._executorFactory = value, this;
                }
                setStateEvaluator(value) {
                    return this._stateEvaluator = value, this;
                }
                overwriteSource(sourceCode) {
                    if (null == this._executorFactory) throw Error('Set base ExecutorFactory first');
                    return this._executorFactory = new DebuggableExecutorFactor_1.DebuggableExecutorFactory(this._executorFactory, sourceCode), this.build();
                }
                useWarpGateway(gatewayOptions) {
                    return this._interactionsLoader = new CacheableInteractionsLoader_1.CacheableInteractionsLoader(new WarpGatewayInteractionsLoader_1.WarpGatewayInteractionsLoader(gatewayOptions.address, gatewayOptions.confirmationStatus, gatewayOptions.source)), this._definitionLoader = new WarpGatewayContractDefinitionLoader_1.WarpGatewayContractDefinitionLoader(gatewayOptions.address, this._arweave, new MemCache_1.MemCache()), this;
                }
                useArweaveGateway() {
                    return this._definitionLoader = new ContractDefinitionLoader_1.ContractDefinitionLoader(this._arweave, new MemCache_1.MemCache()), this._interactionsLoader = new CacheableInteractionsLoader_1.CacheableInteractionsLoader(new ArweaveGatewayInteractionsLoader_1.ArweaveGatewayInteractionsLoader(this._arweave)), this;
                }
                build() {
                    return new Warp_1.Warp(this._arweave, this._cache, this._definitionLoader, this._interactionsLoader, this._executorFactory, this._stateEvaluator, this._environment);
                }
            }
            exports.WarpBuilder = WarpBuilder;
        },
        8479: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.WarpFactory = exports.defaultCacheOptions = exports.DEFAULT_LEVEL_DB_LOCATION = exports.defaultWarpGwOptions = exports.WARP_GW_URL = void 0;
            const arweave_1 = __importDefault(__webpack_require__(7386)), LevelDbCache_1 = __webpack_require__(7563), MemCache_1 = __webpack_require__(1200), CacheableExecutorFactory_1 = __webpack_require__(7794), Evolve_1 = __webpack_require__(2491), CacheableStateEvaluator_1 = __webpack_require__(4286), HandlerExecutorFactory_1 = __webpack_require__(9174), Warp_1 = __webpack_require__(2009);
            exports.WARP_GW_URL = 'https://d1o5nlqr4okus2.cloudfront.net', exports.defaultWarpGwOptions = {
                confirmationStatus: {
                    notCorrupted: !0
                },
                source: null,
                address: exports.WARP_GW_URL
            }, exports.DEFAULT_LEVEL_DB_LOCATION = './cache/warp', exports.defaultCacheOptions = {
                inMemory: !1,
                dbLocation: exports.DEFAULT_LEVEL_DB_LOCATION
            };
            class WarpFactory {
                static forLocal(port = 1984, arweave = arweave_1.default.init({
                    host: 'localhost',
                    port: port,
                    protocol: 'http'
                }), cacheOptions = {
                    ...exports.defaultCacheOptions,
                    inMemory: !0
                }) {
                    return this.customArweaveGw(arweave, cacheOptions, 'local');
                }
                static forTestnet(arweave = arweave_1.default.init({
                    host: 'testnet.redstone.tools',
                    port: 443,
                    protocol: 'https'
                }), cacheOptions = exports.defaultCacheOptions) {
                    return this.customArweaveGw(arweave, cacheOptions, 'testnet');
                }
                static forMainnet(cacheOptions = exports.defaultCacheOptions, useArweaveGw = !1, arweave = arweave_1.default.init({
                    host: 'arweave.net',
                    port: 443,
                    protocol: 'https'
                })) {
                    return useArweaveGw ? this.customArweaveGw(arweave, cacheOptions, 'mainnet') : (console.log(exports.defaultWarpGwOptions), this.customWarpGw(arweave, exports.defaultWarpGwOptions, cacheOptions, 'mainnet'));
                }
                static custom(arweave, cacheOptions, environment) {
                    const cache = new LevelDbCache_1.LevelDbCache({
                        ...cacheOptions,
                        dbLocation: `${cacheOptions.dbLocation}/state`
                    }), executorFactory = new CacheableExecutorFactory_1.CacheableExecutorFactory(arweave, new HandlerExecutorFactory_1.HandlerExecutorFactory(arweave), new MemCache_1.MemCache()), stateEvaluator = new CacheableStateEvaluator_1.CacheableStateEvaluator(arweave, cache, [
                        new Evolve_1.Evolve()
                    ]);
                    return Warp_1.Warp.builder(arweave, cache, environment).setExecutorFactory(executorFactory).setStateEvaluator(stateEvaluator);
                }
                static customArweaveGw(arweave, cacheOptions = exports.defaultCacheOptions, environment) {
                    return this.custom(arweave, cacheOptions, environment).useArweaveGateway().build();
                }
                static customWarpGw(arweave, gatewayOptions = exports.defaultWarpGwOptions, cacheOptions = exports.defaultCacheOptions, environment) {
                    return this.custom(arweave, cacheOptions, environment).useWarpGateway(gatewayOptions).build();
                }
            }
            exports.WarpFactory = WarpFactory;
        },
        2656: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        5368: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        5765: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        6769: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        7462: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.DefaultEvaluationOptions = exports.EvalStateResult = void 0;
            class EvalStateResult {
                constructor(state, validity, errorMessages){
                    this.state = state, this.validity = validity, this.errorMessages = errorMessages;
                }
            }
            exports.EvalStateResult = EvalStateResult;
            class DefaultEvaluationOptions {
                constructor(){
                    this.ignoreExceptions = !0, this.waitForConfirmation = !1, this.updateCacheForEachInteraction = !1, this.internalWrites = !1, this.maxCallDepth = 7, this.maxInteractionEvaluationTimeSeconds = 60, this.stackTrace = {
                        saveState: !1
                    }, this.bundlerUrl = "https://d1o5nlqr4okus2.cloudfront.net/", this.gasLimit = Number.MAX_SAFE_INTEGER, this.useFastCopy = !0, this.useVM2 = !1, this.allowUnsafeClient = !1, this.allowBigInt = !1, this.walletBalanceUrl = 'http://nyc-1.dev.arweave.net:1984/', this.mineArLocalBlocks = !0;
                }
            }
            exports.DefaultEvaluationOptions = DefaultEvaluationOptions;
        },
        9564: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.ArweaveGatewayInteractionsLoader = exports.bundledTxsFilter = void 0;
            const SmartWeaveTags_1 = __webpack_require__(7312), Benchmark_1 = __webpack_require__(9106), LoggerFactory_1 = __webpack_require__(5913), ArweaveWrapper_1 = __webpack_require__(9360), utils_1 = __webpack_require__(5082), LexicographicalInteractionsSorter_1 = __webpack_require__(1967), MAX_REQUEST = 100;
            function bundledTxsFilter(tx) {
                var _a, _b;
                return !(null === (_a = tx.node.parent) || void 0 === _a ? void 0 : _a.id) && !(null === (_b = tx.node.bundledIn) || void 0 === _b ? void 0 : _b.id);
            }
            exports.bundledTxsFilter = bundledTxsFilter;
            class ArweaveGatewayInteractionsLoader {
                constructor(arweave){
                    this.arweave = arweave, this.logger = LoggerFactory_1.LoggerFactory.INST.create('ArweaveGatewayInteractionsLoader'), this.arweaveWrapper = new ArweaveWrapper_1.ArweaveWrapper(arweave), this.sorter = new LexicographicalInteractionsSorter_1.LexicographicalInteractionsSorter(arweave);
                }
                async load(contractId, fromSortKey, toSortKey, evaluationOptions) {
                    this.logger.debug('Loading interactions for', {
                        contractId,
                        fromSortKey,
                        toSortKey
                    });
                    const fromBlockHeight = this.sorter.extractBlockHeight(fromSortKey), toBlockHeight = this.sorter.extractBlockHeight(toSortKey), mainTransactionsVariables = {
                        tags: [
                            {
                                name: SmartWeaveTags_1.SmartWeaveTags.APP_NAME,
                                values: [
                                    'SmartWeaveAction'
                                ]
                            },
                            {
                                name: SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID,
                                values: [
                                    contractId
                                ]
                            }
                        ],
                        blockFilter: {
                            min: fromBlockHeight,
                            max: toBlockHeight
                        },
                        first: MAX_REQUEST
                    }, loadingBenchmark = Benchmark_1.Benchmark.measure();
                    let interactions = await this.loadPages(mainTransactionsVariables);
                    if (loadingBenchmark.stop(), evaluationOptions.internalWrites) {
                        const innerWritesVariables = {
                            tags: [
                                {
                                    name: SmartWeaveTags_1.SmartWeaveTags.INTERACT_WRITE,
                                    values: [
                                        contractId
                                    ]
                                }
                            ],
                            blockFilter: {
                                min: fromBlockHeight,
                                max: toBlockHeight
                            },
                            first: MAX_REQUEST
                        }, innerWritesInteractions = await this.loadPages(innerWritesVariables);
                        this.logger.debug('Inner writes interactions length:', innerWritesInteractions.length), interactions = interactions.concat(innerWritesInteractions);
                    }
                    let sortedInteractions = await this.sorter.sort(interactions = interactions.filter((i)=>i.node.block && i.node.block.id && i.node.block.height));
                    return fromSortKey && toSortKey ? sortedInteractions = sortedInteractions.filter((i)=>i.node.sortKey.localeCompare(fromSortKey) > 0 && 0 >= i.node.sortKey.localeCompare(toSortKey)) : fromSortKey && !toSortKey ? sortedInteractions = sortedInteractions.filter((i)=>i.node.sortKey.localeCompare(fromSortKey) > 0) : !fromSortKey && toSortKey && (sortedInteractions = sortedInteractions.filter((i)=>0 >= i.node.sortKey.localeCompare(toSortKey))), this.logger.debug('All loaded interactions:', {
                        from: fromSortKey,
                        to: toSortKey,
                        loaded: sortedInteractions.length,
                        time: loadingBenchmark.elapsed()
                    }), sortedInteractions.map((i)=>i.node);
                }
                async loadPages(variables) {
                    let transactions = await this.getNextPage(variables);
                    const txInfos = transactions.edges.filter((tx)=>bundledTxsFilter(tx));
                    for(; transactions.pageInfo.hasNextPage;){
                        const cursor = transactions.edges[MAX_REQUEST - 1].cursor;
                        transactions = await this.getNextPage(variables = {
                            ...variables,
                            after: cursor
                        }), txInfos.push(...transactions.edges.filter((tx)=>bundledTxsFilter(tx)));
                    }
                    return txInfos;
                }
                async getNextPage(variables) {
                    const benchmark = Benchmark_1.Benchmark.measure();
                    let response = await this.arweaveWrapper.gql(ArweaveGatewayInteractionsLoader.query, variables);
                    for(this.logger.debug('GQL page load:', benchmark.elapsed()); 403 === response.status;)this.logger.warn(`GQL rate limiting, waiting ${ArweaveGatewayInteractionsLoader._30seconds}ms before next try.`), await (0, utils_1.sleep)(ArweaveGatewayInteractionsLoader._30seconds), response = await this.arweaveWrapper.gql(ArweaveGatewayInteractionsLoader.query, variables);
                    if (200 !== response.status) throw Error(`Unable to retrieve transactions. Arweave gateway responded with status ${response.status}.`);
                    if (response.data.errors) throw this.logger.error(response.data.errors), Error('Error while loading interaction transactions');
                    const data = response.data, txs = data.data.transactions;
                    return txs;
                }
                type() {
                    return 'arweave';
                }
                clearCache() {}
            }
            exports.ArweaveGatewayInteractionsLoader = ArweaveGatewayInteractionsLoader, ArweaveGatewayInteractionsLoader.query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {
    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {
      pageInfo {
        hasNextPage
      }
      edges {
        node {
          id
          owner { address }
          recipient
          tags {
            name
            value
          }
          block {
            height
            id
            timestamp
          }
          fee { winston }
          quantity { winston }
          parent { id }
          bundledIn { id }
        }
        cursor
      }
    }
  }`, ArweaveGatewayInteractionsLoader._30seconds = 30000;
        },
        7346: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.CacheableInteractionsLoader = void 0;
            const LoggerFactory_1 = __webpack_require__(5913);
            class CacheableInteractionsLoader {
                constructor(delegate){
                    this.delegate = delegate, this.logger = LoggerFactory_1.LoggerFactory.INST.create('CacheableInteractionsLoader'), this.interactionsCache = new Map();
                }
                async load(contractTxId, fromSortKey, toSortKey, evaluationOptions) {
                    if (this.logger.debug("Loading interactions for", {
                        contractTxId,
                        fromSortKey,
                        toSortKey
                    }), this.interactionsCache.has(contractTxId)) {
                        const cachedInteractions = this.interactionsCache.get(contractTxId);
                        if (null == cachedInteractions ? void 0 : cachedInteractions.length) {
                            const lastCachedKey = cachedInteractions[cachedInteractions.length - 1].sortKey;
                            if (0 > lastCachedKey.localeCompare(toSortKey)) {
                                const missingInteractions = await this.delegate.load(contractTxId, lastCachedKey, toSortKey, evaluationOptions), allInteractions = cachedInteractions.concat(missingInteractions);
                                return this.interactionsCache.set(contractTxId, allInteractions), allInteractions;
                            }
                        }
                        return cachedInteractions;
                    }
                    {
                        const interactions = await this.delegate.load(contractTxId, fromSortKey, toSortKey, evaluationOptions);
                        return interactions.length && this.interactionsCache.set(contractTxId, interactions), interactions;
                    }
                }
                type() {
                    return this.delegate.type();
                }
                clearCache() {
                    this.interactionsCache.clear();
                }
            }
            exports.CacheableInteractionsLoader = CacheableInteractionsLoader;
        },
        4286: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.CacheableStateEvaluator = void 0;
            const SortKeyCache_1 = __webpack_require__(345), LoggerFactory_1 = __webpack_require__(5913), utils_1 = __webpack_require__(5082), StateEvaluator_1 = __webpack_require__(7462), DefaultStateEvaluator_1 = __webpack_require__(4929), LexicographicalInteractionsSorter_1 = __webpack_require__(1967);
            class CacheableStateEvaluator extends DefaultStateEvaluator_1.DefaultStateEvaluator {
                constructor(arweave, cache, executionContextModifiers = []){
                    super(arweave, executionContextModifiers), this.cache = cache, this.cLogger = LoggerFactory_1.LoggerFactory.INST.create('CacheableStateEvaluator');
                }
                async eval(executionContext, currentTx) {
                    var _a, _b, _c, _d;
                    const cachedState = executionContext.cachedState;
                    if (cachedState && cachedState.sortKey == executionContext.requestedSortKey) return this.cLogger.info(`Exact cache hit for sortKey ${null === (_a = null == executionContext ? void 0 : executionContext.contractDefinition) || void 0 === _a ? void 0 : _a.txId}:${cachedState.sortKey}`), null === (_b = executionContext.handler) || void 0 === _b || _b.initState(cachedState.cachedValue.state), cachedState;
                    const missingInteractions = executionContext.sortedInteractions, contractTxId = executionContext.contractDefinition.txId;
                    if (!contractTxId) throw Error('Contract tx id not set in the execution context');
                    for (const entry of currentTx || [])if (entry.contractTxId === executionContext.contractDefinition.txId) {
                        const index = missingInteractions.findIndex((tx)=>tx.id === entry.interactionTxId);
                        -1 !== index && (this.cLogger.debug('Inf. Loop fix - removing interaction', {
                            height: missingInteractions[index].block.height,
                            contractTxId: entry.contractTxId,
                            interactionTxId: entry.interactionTxId,
                            sortKey: missingInteractions[index].sortKey
                        }), missingInteractions.splice(index));
                    }
                    if (0 == missingInteractions.length) {
                        if (this.cLogger.info(`No missing interactions ${contractTxId}`), cachedState) return null === (_c = executionContext.handler) || void 0 === _c || _c.initState(cachedState.cachedValue.state), cachedState;
                        {
                            null === (_d = executionContext.handler) || void 0 === _d || _d.initState(executionContext.contractDefinition.initState), this.cLogger.debug('Inserting initial state into cache');
                            const stateToCache = new StateEvaluator_1.EvalStateResult(executionContext.contractDefinition.initState, {}, {});
                            return await this.cache.put(new SortKeyCache_1.CacheKey(contractTxId, LexicographicalInteractionsSorter_1.genesisSortKey), stateToCache), new SortKeyCache_1.SortKeyCacheResult(LexicographicalInteractionsSorter_1.genesisSortKey, stateToCache);
                        }
                    }
                    const baseState = null == cachedState ? executionContext.contractDefinition.initState : cachedState.cachedValue.state, baseValidity = null == cachedState ? {} : cachedState.cachedValue.validity, baseErrorMessages = null == cachedState ? {} : cachedState.cachedValue.errorMessages;
                    return this.cLogger.debug('Base state', baseState), await this.doReadState(missingInteractions, new StateEvaluator_1.EvalStateResult(baseState, baseValidity, baseErrorMessages || {}), executionContext, currentTx);
                }
                async onStateEvaluated(transaction, executionContext, state) {
                    const contractTxId = executionContext.contractDefinition.txId;
                    this.cLogger.debug(`${(0, utils_1.indent)(executionContext.contract.callDepth())}onStateEvaluated: cache update for contract ${contractTxId} [${transaction.sortKey}]`), await this.putInCache(contractTxId, transaction, state);
                }
                async onStateUpdate(transaction, executionContext, state, force = !1) {
                    (executionContext.evaluationOptions.updateCacheForEachInteraction || force) && (this.cLogger.debug(`onStateUpdate: cache update for contract ${executionContext.contractDefinition.txId} [${transaction.sortKey}]`, {
                        contract: executionContext.contractDefinition.txId,
                        state: state.state,
                        sortKey: transaction.sortKey
                    }), await this.putInCache(executionContext.contractDefinition.txId, transaction, state));
                }
                async latestAvailableState(contractTxId, sortKey) {
                    if (this.cLogger.debug('Searching for', {
                        contractTxId,
                        sortKey
                    }), !sortKey) return await this.cache.getLast(contractTxId);
                    {
                        const stateCache = await this.cache.getLessOrEqual(contractTxId, sortKey);
                        return stateCache && this.cLogger.debug(`Latest available state at ${contractTxId}: ${stateCache.sortKey}`), stateCache;
                    }
                }
                async onInternalWriteStateUpdate(transaction, contractTxId, state) {
                    this.cLogger.debug('Internal write state update:', {
                        sortKey: transaction.sortKey,
                        dry: transaction.dry,
                        contractTxId,
                        state: state.state
                    }), await this.putInCache(contractTxId, transaction, state);
                }
                async onContractCall(transaction, executionContext, state) {
                    var _a;
                    if ((null === (_a = executionContext.sortedInteractions) || void 0 === _a ? void 0 : _a.length) == 0) return;
                    const txIndex = executionContext.sortedInteractions.indexOf(transaction);
                    txIndex < 1 || await this.putInCache(executionContext.contractDefinition.txId, executionContext.sortedInteractions[txIndex - 1], state);
                }
                async putInCache(contractTxId, transaction, state) {
                    if (transaction.dry || void 0 !== transaction.confirmationStatus && 'confirmed' !== transaction.confirmationStatus) return;
                    const stateToCache = new StateEvaluator_1.EvalStateResult(state.state, state.validity, state.errorMessages || {});
                    this.cLogger.debug('Putting into cache', {
                        contractTxId,
                        transaction: transaction.id,
                        sortKey: transaction.sortKey,
                        dry: transaction.dry,
                        state: stateToCache.state,
                        validity: stateToCache.validity
                    }), await this.cache.put(new SortKeyCache_1.CacheKey(contractTxId, transaction.sortKey), stateToCache);
                }
                async syncState(contractTxId, sortKey, state, validity) {
                    const stateToCache = new StateEvaluator_1.EvalStateResult(state, validity, {});
                    await this.cache.put(new SortKeyCache_1.CacheKey(contractTxId, sortKey), stateToCache);
                }
                async dumpCache() {
                    return await this.cache.dump();
                }
                async internalWriteState(contractTxId, sortKey) {
                    return await this.cache.get(contractTxId, sortKey);
                }
                async hasContractCached(contractTxId) {
                    return await this.cache.getLast(contractTxId) != null;
                }
                async lastCachedSortKey() {
                    return await this.cache.getLastSortKey();
                }
                async allCachedContracts() {
                    return await this.cache.allContracts();
                }
            }
            exports.CacheableStateEvaluator = CacheableStateEvaluator;
        },
        7089: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.ContractDefinitionLoader = void 0;
            const SmartWeaveTags_1 = __webpack_require__(7312), utils_1 = __webpack_require__(3633), Benchmark_1 = __webpack_require__(9106), LoggerFactory_1 = __webpack_require__(5913), ArweaveWrapper_1 = __webpack_require__(9360), WasmSrc_1 = __webpack_require__(6105), supportedSrcContentTypes = [
                'application/javascript',
                'application/wasm'
            ];
            class ContractDefinitionLoader {
                constructor(arweave, cache){
                    this.arweave = arweave, this.cache = cache, this.logger = LoggerFactory_1.LoggerFactory.INST.create('ContractDefinitionLoader'), this.arweaveWrapper = new ArweaveWrapper_1.ArweaveWrapper(arweave);
                }
                async load(contractTxId, evolvedSrcTxId) {
                    var _a, _b, _c;
                    if (!evolvedSrcTxId && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.contains(contractTxId))) return this.logger.debug('ContractDefinitionLoader: Hit from cache!'), Promise.resolve(null === (_b = this.cache) || void 0 === _b ? void 0 : _b.get(contractTxId));
                    const benchmark = Benchmark_1.Benchmark.measure(), contract = await this.doLoad(contractTxId, evolvedSrcTxId);
                    return this.logger.info(`Contract definition loaded in: ${benchmark.elapsed()}`), null === (_c = this.cache) || void 0 === _c || _c.put(contractTxId, contract), contract;
                }
                async doLoad(contractTxId, forcedSrcTxId) {
                    const benchmark = Benchmark_1.Benchmark.measure(), contractTx = await this.arweaveWrapper.tx(contractTxId), owner = await this.arweave.wallets.ownerToAddress(contractTx.owner);
                    this.logger.debug('Contract tx and owner', benchmark.elapsed()), benchmark.reset();
                    const contractSrcTxId = forcedSrcTxId || (0, utils_1.getTag)(contractTx, SmartWeaveTags_1.SmartWeaveTags.CONTRACT_SRC_TX_ID), minFee = (0, utils_1.getTag)(contractTx, SmartWeaveTags_1.SmartWeaveTags.MIN_FEE);
                    this.logger.debug('Tags decoding', benchmark.elapsed()), benchmark.reset();
                    const s = await this.evalInitialState(contractTx);
                    this.logger.debug('init state', s);
                    const initState = JSON.parse(await this.evalInitialState(contractTx));
                    this.logger.debug('Parsing src and init state', benchmark.elapsed());
                    const { src , srcBinary , srcWasmLang , contractType , metadata , srcTx  } = await this.loadContractSource(contractSrcTxId);
                    return {
                        txId: contractTxId,
                        srcTxId: contractSrcTxId,
                        src,
                        srcBinary,
                        srcWasmLang,
                        initState,
                        minFee,
                        owner,
                        contractType,
                        metadata,
                        contractTx: contractTx.toJSON(),
                        srcTx
                    };
                }
                async loadContractSource(contractSrcTxId) {
                    const benchmark = Benchmark_1.Benchmark.measure(), contractSrcTx = await this.arweaveWrapper.tx(contractSrcTxId), srcContentType = (0, utils_1.getTag)(contractSrcTx, SmartWeaveTags_1.SmartWeaveTags.CONTENT_TYPE);
                    if (!supportedSrcContentTypes.includes(srcContentType)) throw Error(`Contract source content type ${srcContentType} not supported`);
                    const contractType = 'application/javascript' == srcContentType ? 'js' : 'wasm', src = 'js' == contractType ? await this.arweaveWrapper.txDataString(contractSrcTxId) : await this.arweaveWrapper.txData(contractSrcTxId);
                    let srcWasmLang, wasmSrc, srcMetaData;
                    if ('wasm' == contractType) {
                        if (wasmSrc = new WasmSrc_1.WasmSrc(src), !(srcWasmLang = (0, utils_1.getTag)(contractSrcTx, SmartWeaveTags_1.SmartWeaveTags.WASM_LANG))) throw Error(`Wasm lang not set for wasm contract src ${contractSrcTxId}`);
                        srcMetaData = JSON.parse((0, utils_1.getTag)(contractSrcTx, SmartWeaveTags_1.SmartWeaveTags.WASM_META));
                    }
                    return this.logger.debug('Contract src tx load', benchmark.elapsed()), benchmark.reset(), {
                        src: 'js' == contractType ? src : null,
                        srcBinary: 'wasm' == contractType ? wasmSrc.wasmBinary() : null,
                        srcWasmLang,
                        contractType,
                        metadata: srcMetaData,
                        srcTx: contractSrcTx.toJSON()
                    };
                }
                async evalInitialState(contractTx) {
                    if ((0, utils_1.getTag)(contractTx, SmartWeaveTags_1.SmartWeaveTags.INIT_STATE)) return (0, utils_1.getTag)(contractTx, SmartWeaveTags_1.SmartWeaveTags.INIT_STATE);
                    if (!(0, utils_1.getTag)(contractTx, SmartWeaveTags_1.SmartWeaveTags.INIT_STATE_TX)) return this.arweaveWrapper.txDataString(contractTx.id);
                    {
                        const stateTX = (0, utils_1.getTag)(contractTx, SmartWeaveTags_1.SmartWeaveTags.INIT_STATE_TX);
                        return this.arweaveWrapper.txDataString(stateTX);
                    }
                }
                type() {
                    return 'arweave';
                }
            }
            exports.ContractDefinitionLoader = ContractDefinitionLoader;
        },
        4929: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.DefaultStateEvaluator = void 0;
            const vrf_js_1 = __webpack_require__(8161), elliptic_1 = __importDefault(__webpack_require__(6266)), SortKeyCache_1 = __webpack_require__(345), Benchmark_1 = __webpack_require__(9106), LoggerFactory_1 = __webpack_require__(5913), utils_1 = __webpack_require__(5082), StateEvaluator_1 = __webpack_require__(7462), StateCache_1 = __webpack_require__(2138), TagsParser_1 = __webpack_require__(8996), EC = new elliptic_1.default.ec('secp256k1');
            class DefaultStateEvaluator {
                constructor(arweave, executionContextModifiers = []){
                    this.arweave = arweave, this.executionContextModifiers = executionContextModifiers, this.logger = LoggerFactory_1.LoggerFactory.INST.create('DefaultStateEvaluator'), this.tagsParser = new TagsParser_1.TagsParser();
                }
                async eval(executionContext, currentTx) {
                    return this.doReadState(executionContext.sortedInteractions, new StateEvaluator_1.EvalStateResult(executionContext.contractDefinition.initState, {}, {}), executionContext, currentTx);
                }
                async doReadState(missingInteractions, baseState, executionContext, currentTx) {
                    var _a;
                    const { ignoreExceptions , stackTrace , internalWrites  } = executionContext.evaluationOptions, { contract , contractDefinition , sortedInteractions  } = executionContext;
                    let currentState = baseState.state, currentSortKey = null;
                    const validity = baseState.validity, errorMessages = baseState.errorMessages;
                    null == executionContext || executionContext.handler.initState(currentState);
                    const depth = executionContext.contract.callDepth();
                    this.logger.info(`${(0, utils_1.indent)(depth)}Evaluating state for ${contractDefinition.txId} [${missingInteractions.length} non-cached of ${sortedInteractions.length} all]`);
                    let errorMessage = null, lastConfirmedTxState = null;
                    const missingInteractionsLength = missingInteractions.length;
                    executionContext.handler.initState(currentState);
                    for(let i = 0; i < missingInteractionsLength; i++){
                        const missingInteraction = missingInteractions[i], singleInteractionBenchmark = Benchmark_1.Benchmark.measure();
                        if (currentSortKey = missingInteraction.sortKey, missingInteraction.vrf && !this.verifyVrf(missingInteraction.vrf, missingInteraction.sortKey, this.arweave)) throw Error('Vrf verification failed.');
                        this.logger.debug(`${(0, utils_1.indent)(depth)}[${contractDefinition.txId}][${missingInteraction.id}][${missingInteraction.block.height}]: ${missingInteractions.indexOf(missingInteraction) + 1}/${missingInteractions.length} [of all:${sortedInteractions.length}]`);
                        const isInteractWrite = this.tagsParser.isInteractWrite(missingInteraction, contractDefinition.txId);
                        if (isInteractWrite && internalWrites) {
                            const writingContractTxId = this.tagsParser.getContractTag(missingInteraction);
                            this.logger.debug(`${(0, utils_1.indent)(depth)}Internal Write - Loading writing contract`, writingContractTxId);
                            const interactionCall = contract.getCallStack().addInteractionData({
                                interaction: null,
                                interactionTx: missingInteraction,
                                currentTx
                            }), writingContract = executionContext.warp.contract(writingContractTxId, executionContext.contract, missingInteraction);
                            await this.onContractCall(missingInteraction, executionContext, new StateEvaluator_1.EvalStateResult(currentState, validity, errorMessages)), this.logger.debug(`${(0, utils_1.indent)(depth)}Reading state of the calling contract at`, missingInteraction.sortKey), await writingContract.readState(missingInteraction.sortKey, [
                                ...currentTx || [],
                                {
                                    contractTxId: contractDefinition.txId,
                                    interactionTxId: missingInteraction.id
                                }
                            ]);
                            const newState = await this.internalWriteState(contractDefinition.txId, missingInteraction.sortKey);
                            if (null !== newState) {
                                currentState = newState.cachedValue.state, null == executionContext || executionContext.handler.initState(currentState), validity[missingInteraction.id] = newState.cachedValue.validity[missingInteraction.id], (null === (_a = newState.cachedValue.errorMessages) || void 0 === _a ? void 0 : _a[missingInteraction.id]) && (errorMessages[missingInteraction.id] = newState.cachedValue.errorMessages[missingInteraction.id]);
                                const toCache = new StateEvaluator_1.EvalStateResult(currentState, validity, errorMessages);
                                await this.onStateUpdate(missingInteraction, executionContext, toCache), (0, StateCache_1.canBeCached)(missingInteraction) && (lastConfirmedTxState = {
                                    tx: missingInteraction,
                                    state: toCache
                                });
                            } else validity[missingInteraction.id] = !1;
                            interactionCall.update({
                                cacheHit: !1,
                                outputState: stackTrace.saveState ? currentState : void 0,
                                executionTime: singleInteractionBenchmark.elapsed(!0),
                                valid: validity[missingInteraction.id],
                                errorMessage: errorMessage,
                                gasUsed: 0
                            });
                        } else {
                            const inputTag = this.tagsParser.getInputTag(missingInteraction, executionContext.contractDefinition.txId);
                            if (!inputTag) {
                                this.logger.error(`${(0, utils_1.indent)(depth)}Skipping tx - Input tag not found for ${missingInteraction.id}`);
                                continue;
                            }
                            const input = this.parseInput(inputTag);
                            if (!input) {
                                this.logger.error(`${(0, utils_1.indent)(depth)}Skipping tx - invalid Input tag - ${missingInteraction.id}`);
                                continue;
                            }
                            const interaction = {
                                input,
                                caller: missingInteraction.owner.address
                            }, interactionData = {
                                interaction,
                                interactionTx: missingInteraction,
                                currentTx
                            };
                            this.logger.debug(`${(0, utils_1.indent)(depth)}Interaction:`, interaction);
                            const interactionCall1 = contract.getCallStack().addInteractionData(interactionData), result = await executionContext.handler.handle(executionContext, new StateEvaluator_1.EvalStateResult(currentState, validity, errorMessages), interactionData);
                            if (errorMessage = result.errorMessage, 'ok' !== result.type && (errorMessages[missingInteraction.id] = errorMessage), this.logResult(result, missingInteraction, executionContext), this.logger.debug(`${(0, utils_1.indent)(depth)}Interaction evaluation`, singleInteractionBenchmark.elapsed()), interactionCall1.update({
                                cacheHit: !1,
                                outputState: stackTrace.saveState ? currentState : void 0,
                                executionTime: singleInteractionBenchmark.elapsed(!0),
                                valid: validity[missingInteraction.id],
                                errorMessage: errorMessage,
                                gasUsed: result.gasUsed
                            }), 'exception' === result.type && !0 !== ignoreExceptions) throw Error(`Exception while processing ${JSON.stringify(interaction)}:\n${result.errorMessage}`);
                            validity[missingInteraction.id] = 'ok' === result.type, currentState = result.state;
                            const toCache1 = new StateEvaluator_1.EvalStateResult(currentState, validity, errorMessages);
                            (0, StateCache_1.canBeCached)(missingInteraction) && (lastConfirmedTxState = {
                                tx: missingInteraction,
                                state: toCache1
                            }), await this.onStateUpdate(missingInteraction, executionContext, toCache1);
                        }
                        for (const { modify  } of this.executionContextModifiers)executionContext = await modify(currentState, executionContext);
                    }
                    const evalStateResult = new StateEvaluator_1.EvalStateResult(currentState, validity, errorMessages);
                    return null !== lastConfirmedTxState && await this.onStateEvaluated(lastConfirmedTxState.tx, executionContext, lastConfirmedTxState.state), new SortKeyCache_1.SortKeyCacheResult(currentSortKey, evalStateResult);
                }
                verifyVrf(vrf, sortKey, arweave) {
                    const keys = EC.keyFromPublic(vrf.pubkey, 'hex');
                    let hash;
                    try {
                        hash = (0, vrf_js_1.ProofHoHash)(keys.getPublic(), arweave.utils.stringToBuffer(sortKey), arweave.utils.b64UrlToBuffer(vrf.proof));
                    } catch (e) {
                        return !1;
                    }
                    return arweave.utils.bufferTob64Url(hash) == vrf.index;
                }
                logResult(result, currentTx, executionContext) {
                    'exception' === result.type && this.logger.error(`Executing of interaction: [${executionContext.contractDefinition.txId} -> ${currentTx.id}] threw exception:`, `${result.errorMessage}`), 'error' === result.type && this.logger.warn(`Executing of interaction: [${executionContext.contractDefinition.txId} -> ${currentTx.id}] returned error:`, result.errorMessage);
                }
                parseInput(inputTag) {
                    try {
                        return JSON.parse(inputTag.value);
                    } catch (e) {
                        return this.logger.error(e), null;
                    }
                }
            }
            exports.DefaultStateEvaluator = DefaultStateEvaluator;
        },
        9174: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: v
                });
            } : function(o, v) {
                o.default = v;
            }), __importStar = this && this.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (null != mod) for(var k in mod)"default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
                return __setModuleDefault(result, mod), result;
            }, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.HandlerExecutorFactory = void 0;
            const loader_1 = __importDefault(__webpack_require__(7605)), as_wasm_imports_1 = __webpack_require__(1692), rust_wasm_imports_1 = __webpack_require__(6505), go_wasm_imports_1 = __webpack_require__(7170), bignumber_js_1 = __importDefault(__webpack_require__(4431)), vm2 = __importStar(__webpack_require__(7840)), smartweave_global_1 = __webpack_require__(8563), Benchmark_1 = __webpack_require__(9106), LoggerFactory_1 = __webpack_require__(5913), JsHandlerApi_1 = __webpack_require__(1515), WasmHandlerApi_1 = __webpack_require__(3425), normalize_source_1 = __webpack_require__(4965), MemCache_1 = __webpack_require__(1200);
            class ContractError extends Error {
                constructor(message){
                    super(message), this.name = 'ContractError';
                }
            }
            class HandlerExecutorFactory {
                constructor(arweave){
                    this.arweave = arweave, this.logger = LoggerFactory_1.LoggerFactory.INST.create('HandlerExecutorFactory'), this.cache = new MemCache_1.MemCache();
                }
                async create(contractDefinition, evaluationOptions) {
                    const swGlobal = new smartweave_global_1.SmartWeaveGlobal(this.arweave, {
                        id: contractDefinition.txId,
                        owner: contractDefinition.owner
                    }, evaluationOptions);
                    if ('wasm' == contractDefinition.contractType) {
                        this.logger.info('Creating handler for wasm contract', contractDefinition.txId);
                        const benchmark = Benchmark_1.Benchmark.measure();
                        let wasmInstance, jsExports = null;
                        const wasmResponse = generateResponse(contractDefinition.srcBinary);
                        switch(contractDefinition.srcWasmLang){
                            case 'assemblyscript':
                                {
                                    const wasmInstanceExports = {
                                        exports: null
                                    };
                                    wasmInstance = await loader_1.default.instantiateStreaming(wasmResponse, (0, as_wasm_imports_1.asWasmImports)(swGlobal, wasmInstanceExports)), wasmInstanceExports.exports = wasmInstance.exports;
                                    break;
                                }
                            case 'rust':
                                {
                                    const wasmInstanceExports1 = {
                                        exports: null,
                                        modifiedExports: {
                                            wasm_bindgen__convert__closures__invoke2_mut__: null,
                                            _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__: null
                                        }
                                    }, wasmModule = await getWasmModule(wasmResponse, contractDefinition.srcBinary), moduleImports = WebAssembly.Module.imports(wasmModule), wbindgenImports = moduleImports.filter((imp)=>'__wbindgen_placeholder__' === imp.module).map((imp)=>imp.name), { imports , exports  } = (0, rust_wasm_imports_1.rustWasmImports)(swGlobal, wbindgenImports, wasmInstanceExports1, contractDefinition.metadata.dtor);
                                    jsExports = exports, wasmInstance = await WebAssembly.instantiate(wasmModule, imports), wasmInstanceExports1.exports = wasmInstance.exports;
                                    const moduleExports = Object.keys(wasmInstance.exports);
                                    moduleExports.forEach((moduleExport)=>{
                                        moduleExport.startsWith('wasm_bindgen__convert__closures__invoke2_mut__') && (wasmInstanceExports1.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__ = wasmInstance.exports[moduleExport]), moduleExport.startsWith('_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__') && (wasmInstanceExports1.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ = wasmInstance.exports[moduleExport]);
                                    });
                                    break;
                                }
                            case 'go':
                                {
                                    const go = new go_wasm_imports_1.Go(swGlobal);
                                    go.importObject.metering = {
                                        usegas: function(value) {
                                            swGlobal.useGas(value);
                                        }
                                    };
                                    const wasmModule1 = await getWasmModule(wasmResponse, contractDefinition.srcBinary);
                                    wasmInstance = await WebAssembly.instantiate(wasmModule1, go.importObject), go.run(wasmInstance), jsExports = go.exports;
                                    break;
                                }
                            default:
                                throw Error(`Support for ${contractDefinition.srcWasmLang} not implemented yet.`);
                        }
                        return this.logger.info(`WASM ${contractDefinition.srcWasmLang} handler created in ${benchmark.elapsed()}`), new WasmHandlerApi_1.WasmHandlerApi(swGlobal, contractDefinition, jsExports || wasmInstance.exports);
                    }
                    {
                        this.logger.info('Creating handler for js contract', contractDefinition.txId);
                        const normalizedSource = (0, normalize_source_1.normalizeContractSource)(contractDefinition.src, evaluationOptions.useVM2);
                        if (!evaluationOptions.allowUnsafeClient && normalizedSource.includes('SmartWeave.unsafeClient')) throw Error('Using unsafeClient is not allowed by default. Use EvaluationOptions.allowUnsafeClient flag.');
                        if (!evaluationOptions.allowBigInt && normalizedSource.includes('BigInt')) throw Error('Using BigInt is not allowed by default. Use EvaluationOptions.allowBigInt flag.');
                        if (evaluationOptions.useVM2) {
                            const vmScript = new vm2.VMScript(normalizedSource), vm = new vm2.NodeVM({
                                console: 'off',
                                sandbox: {
                                    SmartWeave: swGlobal,
                                    BigNumber: bignumber_js_1.default,
                                    logger: this.logger,
                                    ContractError: ContractError,
                                    ContractAssert: function(cond, message) {
                                        if (!cond) throw new ContractError(message);
                                    }
                                },
                                compiler: 'javascript',
                                eval: !1,
                                wasm: !1,
                                allowAsync: !0,
                                wrapper: 'commonjs'
                            });
                            return new JsHandlerApi_1.JsHandlerApi(swGlobal, contractDefinition, vm.run(vmScript));
                        }
                        {
                            const contractFunction = Function(normalizedSource), handler = contractFunction(swGlobal, bignumber_js_1.default, LoggerFactory_1.LoggerFactory.INST.create(swGlobal.contract.id));
                            return new JsHandlerApi_1.JsHandlerApi(swGlobal, contractDefinition, handler);
                        }
                    }
                }
            }
            function generateResponse(wasmBinary) {
                const init = {
                    status: 200,
                    statusText: 'OK',
                    headers: {
                        'Content-Type': 'application/wasm'
                    }
                };
                return new Response(wasmBinary, init);
            }
            async function getWasmModule(wasmResponse, binary) {
                return WebAssembly.compileStreaming ? await WebAssembly.compileStreaming(wasmResponse) : await WebAssembly.compile(binary);
            }
            exports.HandlerExecutorFactory = HandlerExecutorFactory;
        },
        1967: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.LexicographicalInteractionsSorter = exports.genesisSortKey = exports.sortingLast = exports.sortingFirst = void 0;
            const utils_1 = __webpack_require__(3633), LoggerFactory_1 = __webpack_require__(5913), WarpGatewayInteractionsLoader_1 = __webpack_require__(1533), firstSortKeyMs = ''.padEnd(13, '0'), lastSortKeyMs = ''.padEnd(13, '9'), defaultArweaveMs = ''.padEnd(13, '0');
            exports.sortingFirst = ''.padEnd(64, '0'), exports.sortingLast = ''.padEnd(64, 'z'), exports.genesisSortKey = `${''.padStart(12, '0')},${firstSortKeyMs},${exports.sortingFirst}`;
            class LexicographicalInteractionsSorter {
                constructor(arweave){
                    this.arweave = arweave, this.logger = LoggerFactory_1.LoggerFactory.INST.create('LexicographicalInteractionsSorter');
                }
                async sort(transactions) {
                    const copy = [
                        ...transactions
                    ], addKeysFuncs = copy.map((tx)=>this.addSortKey(tx));
                    return await Promise.all(addKeysFuncs), copy.sort((a, b)=>a.node.sortKey.localeCompare(b.node.sortKey));
                }
                async createSortKey(blockId, transactionId, blockHeight, dummy = !1) {
                    const blockHashBytes = this.arweave.utils.b64UrlToBuffer(blockId), txIdBytes = this.arweave.utils.b64UrlToBuffer(transactionId), concatenated = this.arweave.utils.concatBuffers([
                        blockHashBytes,
                        txIdBytes
                    ]), hashed = (0, utils_1.arrayToHex)(await this.arweave.crypto.hash(concatenated)), blockHeightString = `${blockHeight}`.padStart(12, '0'), arweaveMs = dummy ? lastSortKeyMs : defaultArweaveMs;
                    return `${blockHeightString},${arweaveMs},${hashed}`;
                }
                extractBlockHeight(sortKey) {
                    return sortKey ? parseInt(sortKey.split(',')[0]) : null;
                }
                async addSortKey(txInfo) {
                    const { node  } = txInfo;
                    void 0 !== txInfo.node.sortKey && txInfo.node.source == WarpGatewayInteractionsLoader_1.SourceType.WARP_SEQUENCER ? this.logger.debug('Using sortKey from sequencer', txInfo.node.sortKey) : txInfo.node.sortKey = await this.createSortKey(node.block.id, node.id, node.block.height);
                }
                generateLastSortKey(blockHeight) {
                    const blockHeightString = `${blockHeight}`.padStart(12, '0');
                    return `${blockHeightString},${lastSortKeyMs},${exports.sortingLast}`;
                }
            }
            exports.LexicographicalInteractionsSorter = LexicographicalInteractionsSorter;
        },
        2138: function(__unused_webpack_module, exports) {
            "use strict";
            function canBeCached(tx) {
                return void 0 === tx.confirmationStatus || 'confirmed' === tx.confirmationStatus;
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.canBeCached = void 0, exports.canBeCached = canBeCached;
        },
        8996: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.TagsParser = void 0;
            const SmartWeaveTags_1 = __webpack_require__(7312), LoggerFactory_1 = __webpack_require__(5913);
            class TagsParser {
                constructor(){
                    this.logger = LoggerFactory_1.LoggerFactory.INST.create('TagsParser');
                }
                getInputTag(interactionTransaction, contractTxId) {
                    if (!TagsParser.hasMultipleInteractions(interactionTransaction)) return interactionTransaction.tags.find((tag)=>tag.name === SmartWeaveTags_1.SmartWeaveTags.INPUT);
                    {
                        this.logger.debug('Interaction transaction is using multiple input tx tag format.');
                        const contractTagIndex = interactionTransaction.tags.findIndex((tag)=>tag.name === SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID && tag.value === contractTxId);
                        if (interactionTransaction.tags.length - 1 === contractTagIndex) {
                            this.logger.warn("Wrong tags format: 'Contract' is the last tag");
                            return;
                        }
                        const inputTag = interactionTransaction.tags[contractTagIndex + 1];
                        if (inputTag.name !== SmartWeaveTags_1.SmartWeaveTags.INPUT) {
                            this.logger.warn(`No 'Input' tag found after 'Contract' tag. Instead ${inputTag.name} was found`);
                            return;
                        }
                        return inputTag;
                    }
                }
                isInteractWrite(interactionTransaction, contractTxId) {
                    return interactionTransaction.tags.some((tag)=>tag.name === SmartWeaveTags_1.SmartWeaveTags.INTERACT_WRITE && tag.value === contractTxId);
                }
                getInteractWritesContracts(interactionTransaction) {
                    return interactionTransaction.tags.filter((tag)=>tag.name === SmartWeaveTags_1.SmartWeaveTags.INTERACT_WRITE).map((t)=>t.value);
                }
                getContractTag(interactionTransaction) {
                    var _a;
                    return null === (_a = interactionTransaction.tags.find((tag)=>tag.name === SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID)) || void 0 === _a ? void 0 : _a.value;
                }
                getContractsWithInputs(interactionTransaction) {
                    const result = new Map(), contractTags = interactionTransaction.tags.filter((tag)=>tag.name === SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID);
                    return contractTags.forEach((contractTag)=>{
                        result.set(contractTag.value, this.getInputTag(interactionTransaction, contractTag.value));
                    }), result;
                }
                static hasMultipleInteractions(interactionTransaction) {
                    return interactionTransaction.tags.filter((tag)=>tag.name === SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID).length > 1;
                }
            }
            exports.TagsParser = TagsParser;
        },
        3187: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var Buffer = __webpack_require__(8764).Buffer, __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.WarpGatewayContractDefinitionLoader = void 0;
            const ContractDefinitionLoader_1 = __webpack_require__(7089);
            __webpack_require__(9180);
            const WasmSrc_1 = __webpack_require__(6105), transaction_1 = __importDefault(__webpack_require__(7241)), SmartWeaveTags_1 = __webpack_require__(7312), utils_1 = __webpack_require__(3633), Benchmark_1 = __webpack_require__(9106), LoggerFactory_1 = __webpack_require__(5913), ArweaveWrapper_1 = __webpack_require__(9360), utils_2 = __webpack_require__(5082);
            class WarpGatewayContractDefinitionLoader {
                constructor(baseUrl, arweave, cache){
                    this.baseUrl = baseUrl, this.cache = cache, this.rLogger = LoggerFactory_1.LoggerFactory.INST.create('WarpGatewayContractDefinitionLoader'), this.baseUrl = (0, utils_2.stripTrailingSlash)(baseUrl), this.contractDefinitionLoader = new ContractDefinitionLoader_1.ContractDefinitionLoader(arweave, cache), this.arweaveWrapper = new ArweaveWrapper_1.ArweaveWrapper(arweave);
                }
                async load(contractTxId, evolvedSrcTxId) {
                    var _a, _b, _c;
                    if (!evolvedSrcTxId && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.contains(contractTxId))) return this.rLogger.debug('WarpGatewayContractDefinitionLoader: Hit from cache!'), Promise.resolve(null === (_b = this.cache) || void 0 === _b ? void 0 : _b.get(contractTxId));
                    const benchmark = Benchmark_1.Benchmark.measure(), contract = await this.doLoad(contractTxId, evolvedSrcTxId);
                    return this.rLogger.info(`Contract definition loaded in: ${benchmark.elapsed()}`), null === (_c = this.cache) || void 0 === _c || _c.put(contractTxId, contract), contract;
                }
                async doLoad(contractTxId, forcedSrcTxId) {
                    try {
                        const result = await fetch(`${this.baseUrl}/gateway/contract?txId=${contractTxId}${forcedSrcTxId ? `&srcTxId=${forcedSrcTxId}` : ''}`).then((res)=>res.ok ? res.json() : Promise.reject(res)).catch((error)=>{
                            var _a, _b;
                            throw (null === (_a = error.body) || void 0 === _a ? void 0 : _a.message) && this.rLogger.error(error.body.message), Error(`Unable to retrieve contract data. Warp gateway responded with status ${error.status}:${null === (_b = error.body) || void 0 === _b ? void 0 : _b.message}`);
                        });
                        if (null == result.srcBinary || result.srcBinary instanceof Buffer || (result.srcBinary = Buffer.from(result.srcBinary.data)), result.srcBinary) {
                            const wasmSrc = new WasmSrc_1.WasmSrc(result.srcBinary);
                            result.srcBinary = wasmSrc.wasmBinary();
                            let sourceTx;
                            sourceTx = result.srcTx ? new transaction_1.default({
                                ...result.srcTx
                            }) : await this.arweaveWrapper.tx(result.srcTxId);
                            const srcMetaData = JSON.parse((0, utils_1.getTag)(sourceTx, SmartWeaveTags_1.SmartWeaveTags.WASM_META));
                            result.metadata = srcMetaData;
                        }
                        return result.contractType = result.src ? 'js' : 'wasm', result;
                    } catch (e) {
                        return this.rLogger.warn('Falling back to default contracts loader', e), await this.contractDefinitionLoader.doLoad(contractTxId, forcedSrcTxId);
                    }
                }
                async loadContractSource(contractSrcTxId) {
                    return await this.contractDefinitionLoader.loadContractSource(contractSrcTxId);
                }
                type() {
                    return 'warp';
                }
            }
            exports.WarpGatewayContractDefinitionLoader = WarpGatewayContractDefinitionLoader;
        },
        1533: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var SourceType, SourceType1;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.WarpGatewayInteractionsLoader = exports.SourceType = void 0;
            const Benchmark_1 = __webpack_require__(9106), LoggerFactory_1 = __webpack_require__(5913);
            __webpack_require__(9180);
            const utils_1 = __webpack_require__(5082);
            (SourceType1 = SourceType = exports.SourceType || (exports.SourceType = {})).ARWEAVE = "arweave", SourceType1.WARP_SEQUENCER = "redstone-sequencer";
            class WarpGatewayInteractionsLoader {
                constructor(baseUrl, confirmationStatus = null, source = null){
                    this.baseUrl = baseUrl, this.confirmationStatus = confirmationStatus, this.source = source, this.logger = LoggerFactory_1.LoggerFactory.INST.create('WarpGatewayInteractionsLoader'), this.baseUrl = (0, utils_1.stripTrailingSlash)(baseUrl), Object.assign(this, confirmationStatus), this.source = source;
                }
                async load(contractId, fromSortKey, toSortKey, evaluationOptions) {
                    this.logger.debug('Loading interactions: for ', {
                        contractId,
                        fromSortKey,
                        toSortKey
                    });
                    const interactions = [];
                    let page = 0, limit = 0, items = 0;
                    const benchmarkTotalTime = Benchmark_1.Benchmark.measure();
                    do {
                        const benchmarkRequestTime = Benchmark_1.Benchmark.measure(), url = `${this.baseUrl}/gateway/v2/interactions-sort-key`, response = await fetch(`${url}?${new URLSearchParams({
                            contractId: contractId,
                            ...fromSortKey ? {
                                from: fromSortKey
                            } : '',
                            ...toSortKey ? {
                                to: toSortKey
                            } : '',
                            page: (++page).toString(),
                            fromSdk: 'true',
                            ...this.confirmationStatus && this.confirmationStatus.confirmed ? {
                                confirmationStatus: 'confirmed'
                            } : '',
                            ...this.confirmationStatus && this.confirmationStatus.notCorrupted ? {
                                confirmationStatus: 'not_corrupted'
                            } : '',
                            ...this.source ? {
                                source: this.source
                            } : ''
                        })}`).then((res)=>res.ok ? res.json() : Promise.reject(res)).catch((error)=>{
                            var _a;
                            throw (null === (_a = error.body) || void 0 === _a ? void 0 : _a.message) && this.logger.error(error.body.message), Error(`Unable to retrieve transactions. Warp gateway responded with status ${error.status}.`);
                        });
                        this.logger.debug(`Loading interactions: page ${page} loaded in ${benchmarkRequestTime.elapsed()}`), interactions.push(...response.interactions), limit = response.paging.limit, items = response.paging.items, this.logger.debug(`Loaded interactions length: ${interactions.length}, from: ${fromSortKey}, to: ${toSortKey}`);
                    }while (items == limit)
                    return this.logger.debug('All loaded interactions:', {
                        from: fromSortKey,
                        to: toSortKey,
                        loaded: interactions.length,
                        time: benchmarkTotalTime.elapsed()
                    }), interactions;
                }
                type() {
                    return 'warp';
                }
                clearCache() {}
            }
            exports.WarpGatewayInteractionsLoader = WarpGatewayInteractionsLoader;
        },
        3233: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.AbstractContractHandler = void 0;
            const LoggerFactory_1 = __webpack_require__(5913), utils_1 = __webpack_require__(5082);
            class AbstractContractHandler {
                constructor(swGlobal, contractDefinition){
                    this.swGlobal = swGlobal, this.contractDefinition = contractDefinition, this.logger = LoggerFactory_1.LoggerFactory.INST.create('ContractHandler'), this.assignReadContractState = this.assignReadContractState.bind(this), this.assignViewContractState = this.assignViewContractState.bind(this), this.assignWrite = this.assignWrite.bind(this), this.assignRefreshState = this.assignRefreshState.bind(this);
                }
                async dispose() {}
                assignWrite(executionContext, currentTx) {
                    this.swGlobal.contracts.write = async (contractTxId, input)=>{
                        if (!executionContext.evaluationOptions.internalWrites) throw Error("Internal writes feature switched off. Change EvaluationOptions.internalWrites flag to 'true'");
                        this.logger.debug('swGlobal.write call:', {
                            from: this.contractDefinition.txId,
                            to: contractTxId,
                            input
                        });
                        const calleeContract = executionContext.warp.contract(contractTxId, executionContext.contract, this.swGlobal._activeTx), result = await calleeContract.dryWriteFromTx(input, this.swGlobal._activeTx, [
                            ...currentTx || [],
                            {
                                contractTxId: this.contractDefinition.txId,
                                interactionTxId: this.swGlobal.transaction.id
                            }
                        ]);
                        return this.logger.debug('Cache result?:', !this.swGlobal._activeTx.dry), await executionContext.warp.stateEvaluator.onInternalWriteStateUpdate(this.swGlobal._activeTx, contractTxId, {
                            state: result.state,
                            validity: {
                                ...result.originalValidity,
                                [this.swGlobal._activeTx.id]: 'ok' == result.type
                            },
                            errorMessages: {
                                ...result.originalErrorMessages,
                                [this.swGlobal._activeTx.id]: result.errorMessage
                            }
                        }), result;
                    };
                }
                assignViewContractState(executionContext) {
                    this.swGlobal.contracts.viewContractState = async (contractTxId, input)=>{
                        this.logger.debug('swGlobal.viewContractState call:', {
                            from: this.contractDefinition.txId,
                            to: contractTxId,
                            input
                        });
                        const childContract = executionContext.warp.contract(contractTxId, executionContext.contract, this.swGlobal._activeTx);
                        return await childContract.viewStateForTx(input, this.swGlobal._activeTx);
                    };
                }
                assignReadContractState(executionContext, currentTx, currentResult, interactionTx) {
                    this.swGlobal.contracts.readContractState = async (contractTxId, returnValidity)=>{
                        this.logger.debug('swGlobal.readContractState call:', {
                            from: this.contractDefinition.txId,
                            to: contractTxId,
                            sortKey: interactionTx.sortKey,
                            transaction: this.swGlobal.transaction.id
                        });
                        const { stateEvaluator  } = executionContext.warp, childContract = executionContext.warp.contract(contractTxId, executionContext.contract, interactionTx);
                        await stateEvaluator.onContractCall(interactionTx, executionContext, currentResult);
                        const stateWithValidity = await childContract.readState(interactionTx.sortKey, [
                            ...currentTx || [],
                            {
                                contractTxId: this.contractDefinition.txId,
                                interactionTxId: this.swGlobal.transaction.id
                            }
                        ]);
                        return returnValidity ? (0, utils_1.deepCopy)(stateWithValidity) : (0, utils_1.deepCopy)(stateWithValidity.cachedValue.state);
                    };
                }
                assignRefreshState(executionContext) {
                    this.swGlobal.contracts.refreshState = async ()=>{
                        const stateEvaluator = executionContext.warp.stateEvaluator, result = await stateEvaluator.latestAvailableState(this.swGlobal.contract.id, this.swGlobal._activeTx.sortKey);
                        return null == result ? void 0 : result.cachedValue.state;
                    };
                }
            }
            exports.AbstractContractHandler = AbstractContractHandler;
        },
        1515: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.JsHandlerApi = void 0;
            const utils_1 = __webpack_require__(5082), AbstractContractHandler_1 = __webpack_require__(3233);
            class JsHandlerApi extends AbstractContractHandler_1.AbstractContractHandler {
                constructor(swGlobal, contractDefinition, contractFunction){
                    super(swGlobal, contractDefinition), this.contractFunction = contractFunction;
                }
                async handle(executionContext, currentResult, interactionData) {
                    const { timeoutId , timeoutPromise  } = (0, utils_1.timeout)(executionContext.evaluationOptions.maxInteractionEvaluationTimeSeconds);
                    try {
                        const { interaction , interactionTx , currentTx  } = interactionData, stateCopy = (0, utils_1.deepCopy)(currentResult.state, executionContext.evaluationOptions.useFastCopy);
                        this.swGlobal._activeTx = interactionTx, this.swGlobal.caller = interaction.caller, this.assignReadContractState(executionContext, currentTx, currentResult, interactionTx), this.assignViewContractState(executionContext), this.assignWrite(executionContext, currentTx), this.assignRefreshState(executionContext);
                        const handlerResult = await Promise.race([
                            timeoutPromise,
                            this.contractFunction(stateCopy, interaction)
                        ]);
                        if (handlerResult && (void 0 !== handlerResult.state || void 0 !== handlerResult.result)) return {
                            type: 'ok',
                            result: handlerResult.result,
                            state: handlerResult.state || currentResult.state
                        };
                        throw Error(`Unexpected result from contract: ${JSON.stringify(handlerResult)}`);
                    } catch (err) {
                        if ('ContractError' === err.name) return {
                            type: 'error',
                            errorMessage: err.message,
                            state: currentResult.state,
                            result: null
                        };
                        return {
                            type: 'exception',
                            errorMessage: `${err && err.stack || err && err.message || err}`,
                            state: currentResult.state,
                            result: null
                        };
                    } finally{
                        null !== timeoutId && clearTimeout(timeoutId);
                    }
                }
                initState(state) {}
            }
            exports.JsHandlerApi = JsHandlerApi;
        },
        3425: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.WasmHandlerApi = void 0;
            const safe_stable_stringify_1 = __importDefault(__webpack_require__(7668)), AbstractContractHandler_1 = __webpack_require__(3233);
            class WasmHandlerApi extends AbstractContractHandler_1.AbstractContractHandler {
                constructor(swGlobal, contractDefinition, wasmExports){
                    super(swGlobal, contractDefinition), this.wasmExports = wasmExports;
                }
                async handle(executionContext, currentResult, interactionData) {
                    try {
                        const { interaction , interactionTx , currentTx  } = interactionData;
                        this.swGlobal._activeTx = interactionTx, this.swGlobal.caller = interaction.caller, this.swGlobal.gasLimit = executionContext.evaluationOptions.gasLimit, this.swGlobal.gasUsed = 0, this.assignReadContractState(executionContext, currentTx, currentResult, interactionTx), this.assignWrite(executionContext, currentTx);
                        const handlerResult = await this.doHandle(interaction);
                        return {
                            type: 'ok',
                            result: handlerResult,
                            state: this.doGetCurrentState(),
                            gasUsed: this.swGlobal.gasUsed
                        };
                    } catch (e) {
                        const result = {
                            errorMessage: e.message,
                            state: currentResult.state,
                            result: null
                        };
                        if (e.message.startsWith('[RE:')) return this.logger.fatal(e), {
                            ...result,
                            type: 'exception'
                        };
                        return {
                            ...result,
                            type: 'error'
                        };
                    }
                }
                initState(state) {
                    switch(this.contractDefinition.srcWasmLang){
                        case 'assemblyscript':
                            {
                                const statePtr = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(state));
                                this.wasmExports.initState(statePtr);
                                break;
                            }
                        case 'rust':
                            this.wasmExports.initState(state);
                            break;
                        case 'go':
                            this.wasmExports.initState((0, safe_stable_stringify_1.default)(state));
                            break;
                        default:
                            throw Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
                    }
                }
                async doHandle(action) {
                    switch(this.contractDefinition.srcWasmLang){
                        case 'assemblyscript':
                            {
                                const actionPtr = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(action.input)), resultPtr = this.wasmExports.handle(actionPtr), result = this.wasmExports.__getString(resultPtr);
                                return JSON.parse(result);
                            }
                        case 'rust':
                            {
                                let handleResult = await this.wasmExports.handle(action.input);
                                if (!handleResult) return;
                                if (Object.prototype.hasOwnProperty.call(handleResult, 'Ok')) return handleResult.Ok;
                                {
                                    this.logger.debug('Error from rust', handleResult.Err);
                                    let errorKey, errorArgs = '';
                                    if ('string' == typeof handleResult.Err || handleResult.Err instanceof String ? errorKey = handleResult.Err : (errorKey = Object.keys(handleResult.Err)[0], errorArgs = ' ' + handleResult.Err[errorKey]), 'RuntimeError' == errorKey) throw Error(`[RE:RE]${errorArgs}`);
                                    throw Error(`[CE:${errorKey}${errorArgs}]`);
                                }
                            }
                        case 'go':
                            {
                                const result1 = await this.wasmExports.handle((0, safe_stable_stringify_1.default)(action.input));
                                return JSON.parse(result1);
                            }
                        default:
                            throw Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
                    }
                }
                doGetCurrentState() {
                    switch(this.contractDefinition.srcWasmLang){
                        case 'assemblyscript':
                            {
                                const currentStatePtr = this.wasmExports.currentState();
                                return JSON.parse(this.wasmExports.__getString(currentStatePtr));
                            }
                        case 'rust':
                            return this.wasmExports.currentState();
                        case 'go':
                            {
                                const result = this.wasmExports.currentState();
                                return JSON.parse(result);
                            }
                        default:
                            throw Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
                    }
                }
            }
            exports.WasmHandlerApi = WasmHandlerApi;
        },
        4965: function(__unused_webpack_module, exports) {
            "use strict";
            function normalizeContractSource(contractSrc, useVM2) {
                const lines = contractSrc.trim().split('\n'), first = lines[0], last = lines[lines.length - 1];
                return ((/\(\s*\(\)\s*=>\s*{/g.test(first) || /\s*\(\s*function\s*\(\)\s*{/g.test(first)) && /}\s*\)\s*\(\)\s*;/g.test(last) && (lines.shift(), lines.pop(), contractSrc = lines.join('\n')), contractSrc = contractSrc.replace(/export\s+async\s+function\s+handle/gmu, 'async function handle').replace(/export\s+function\s+handle/gmu, 'function handle'), useVM2) ? `
    ${contractSrc}
    module.exports = handle;` : `
    const [SmartWeave, BigNumber, logger] = arguments;
    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };
    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };
    ${contractSrc};
    return handle;
  `;
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.normalizeContractSource = void 0, exports.normalizeContractSource = normalizeContractSource;
        },
        6105: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.WasmSrc = void 0;
            const unzipit_1 = __webpack_require__(3931), redstone_isomorphic_1 = __webpack_require__(9180), LoggerFactory_1 = __webpack_require__(5913);
            class WasmSrc {
                constructor(src){
                    this.src = src, this.logger = LoggerFactory_1.LoggerFactory.INST.create('WasmSrc'), this.splitted = this.splitBuffer(src), this.logger.debug(`Buffer splitted into ${this.splitted.length} parts`);
                }
                wasmBinary() {
                    return this.splitted[0];
                }
                async sourceCode() {
                    const { entries  } = await (0, unzipit_1.unzip)(this.splitted[1]), result = new Map();
                    for (const [name, entry] of Object.entries(entries)){
                        if (entry.isDirectory) continue;
                        const content = await entry.text();
                        result.set(name, content);
                    }
                    return result;
                }
                additionalCode() {
                    return 2 == this.splitted.length ? null : this.splitted[2].toString();
                }
                splitBuffer(inputBuffer) {
                    let header = '';
                    const elements = parseInt(inputBuffer.toString('utf8', 0, 1));
                    this.logger.debug(`Number of elements: ${elements}`);
                    const l = inputBuffer.length;
                    let delimiters = 0, dataStart = 0;
                    for(let i = 2; i < l; i++){
                        const element = inputBuffer.toString('utf8', i, i + 1);
                        if ('|' == element && delimiters++, delimiters == elements) {
                            dataStart = i + 1;
                            break;
                        }
                        header += element;
                    }
                    this.logger.debug("Parsed:", {
                        header,
                        dataStart
                    });
                    const lengths = header.split('|').map((l)=>parseInt(l));
                    this.logger.debug('Lengths', lengths);
                    const result = [];
                    for (const length of lengths){
                        const buffer = redstone_isomorphic_1.Buffer.alloc(length), end = dataStart + length;
                        inputBuffer.copy(buffer, 0, dataStart, end), dataStart = end, result.push(buffer);
                    }
                    return result;
                }
            }
            exports.WasmSrc = WasmSrc;
        },
        1692: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.asWasmImports = void 0;
            const LoggerFactory_1 = __webpack_require__(5913), asWasmImports = (swGlobal, wasmInstance)=>{
                const wasmLogger = LoggerFactory_1.LoggerFactory.INST.create('WASM:AS');
                return {
                    metering: {
                        usegas: swGlobal.useGas
                    },
                    console: {
                        'console.log': function(msgPtr) {
                            wasmLogger.debug(`${swGlobal.contract.id}: ${wasmInstance.exports.__getString(msgPtr)}`);
                        },
                        'console.logO': function(msgPtr, objPtr) {
                            wasmLogger.debug(`${swGlobal.contract.id}: ${wasmInstance.exports.__getString(msgPtr)}`, JSON.parse(wasmInstance.exports.__getString(objPtr)));
                        }
                    },
                    block: {
                        'Block.height': function() {
                            return swGlobal.block.height;
                        },
                        'Block.indep_hash': function() {
                            return wasmInstance.exports.__newString(swGlobal.block.indep_hash);
                        },
                        'Block.timestamp': function() {
                            return swGlobal.block.timestamp;
                        }
                    },
                    transaction: {
                        'Transaction.id': function() {
                            return wasmInstance.exports.__newString(swGlobal.transaction.id);
                        },
                        'Transaction.owner': function() {
                            return wasmInstance.exports.__newString(swGlobal.transaction.owner);
                        },
                        'Transaction.target': function() {
                            return wasmInstance.exports.__newString(swGlobal.transaction.target);
                        }
                    },
                    contract: {
                        'Contract.id': function() {
                            return wasmInstance.exports.__newString(swGlobal.contract.id);
                        },
                        'Contract.owner': function() {
                            return wasmInstance.exports.__newString(swGlobal.contract.owner);
                        }
                    },
                    api: {
                        _readContractState: (fnIndex, contractTxIdPtr)=>{
                            const contractTxId = wasmInstance.exports.__getString(contractTxIdPtr), callbackFn = getFn(fnIndex);
                            return console.log('Simulating read state of', contractTxId), setTimeout(()=>{
                                console.log('calling callback'), callbackFn(wasmInstance.exports.__newString(JSON.stringify({
                                    contractTxId
                                })));
                            }, 1000);
                        },
                        clearTimeout
                    },
                    env: {
                        abort (messagePtr, fileNamePtr, line, column) {
                            const message = wasmInstance.exports.__getString(messagePtr);
                            throw wasmLogger.error('--------------------- Error message from AssemblyScript ----------------------\n'), wasmLogger.error('  ' + message), wasmLogger.error('    In file "' + wasmInstance.exports.__getString(fileNamePtr) + '"'), wasmLogger.error(`    on line ${line}, column ${column}.`), wasmLogger.error('------------------------------------------------------------------------------\n'), Error(message);
                        }
                    }
                };
                function getFn(idx) {
                    return wasmInstance.exports.table.get(idx);
                }
            };
            exports.asWasmImports = asWasmImports;
        },
        7170: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var process = __webpack_require__(3957);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Go = void 0;
            const LoggerFactory_1 = __webpack_require__(5913), encoder = new TextEncoder(), decoder = new TextDecoder('utf-8');
            let logLine = [], globalJsModule;
            (function(global) {
                (globalJsModule = global).redstone = {
                    go: {}
                };
            }).call(this, void 0 !== __webpack_require__.g ? __webpack_require__.g : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : {});
            class Go {
                constructor(swGlobal){
                    this._callbackTimeouts = new Map(), this._nextCallbackTimeoutID = 1;
                    const wasmLogger = LoggerFactory_1.LoggerFactory.INST.create('WASM:Go');
                    let go = this;
                    globalJsModule.redstone.go = {
                        WasmModule: {
                            registerWasmModule: function(moduleId) {
                                go._id = moduleId, go.exports = globalJsModule[moduleId], delete globalJsModule[moduleId], globalJsModule.redstone.go[moduleId] = {}, globalJsModule.redstone.go[moduleId].imports = {
                                    console: {
                                        log: function(...args) {
                                            wasmLogger.debug(args[0], ...args.slice(1));
                                        }
                                    },
                                    Transaction: {
                                        id: function() {
                                            return swGlobal.transaction.id;
                                        },
                                        owner: function() {
                                            return swGlobal.transaction.owner;
                                        },
                                        target: function() {
                                            return swGlobal.transaction.target;
                                        }
                                    },
                                    Block: {
                                        indep_hash: function() {
                                            return swGlobal.block.indep_hash;
                                        },
                                        height: function() {
                                            return swGlobal.block.height;
                                        },
                                        timestamp: function() {
                                            return swGlobal.block.timestamp;
                                        }
                                    },
                                    Contract: {
                                        id: function() {
                                            return swGlobal.contract.id;
                                        },
                                        owner: function() {
                                            return swGlobal.contract.owner;
                                        }
                                    },
                                    SmartWeave: {
                                        readContractState: async function(contractTxId) {
                                            return await swGlobal.contracts.readContractState(contractTxId);
                                        }
                                    }
                                };
                            }
                        }
                    };
                    const mem = ()=>new DataView(this._inst.exports.memory.buffer), setInt64 = (addr, v)=>{
                        mem().setUint32(addr + 0, v, !0), mem().setUint32(addr + 4, Math.floor(v / 4294967296), !0);
                    }, loadValue = (addr)=>{
                        const f = mem().getFloat64(addr, !0);
                        if (0 === f) return;
                        if (!isNaN(f)) return f;
                        const id = mem().getUint32(addr, !0);
                        return this._values[id];
                    }, storeValue = (addr, v)=>{
                        const nanHead = 0x7ff80000;
                        if ('number' == typeof v) {
                            if (isNaN(v)) {
                                mem().setUint32(addr + 4, nanHead, !0), mem().setUint32(addr, 0, !0);
                                return;
                            }
                            if (0 === v) {
                                mem().setUint32(addr + 4, nanHead, !0), mem().setUint32(addr, 1, !0);
                                return;
                            }
                            mem().setFloat64(addr, v, !0);
                            return;
                        }
                        switch(v){
                            case void 0:
                                mem().setFloat64(addr, 0, !0);
                                return;
                            case null:
                                mem().setUint32(addr + 4, nanHead, !0), mem().setUint32(addr, 2, !0);
                                return;
                            case !0:
                                mem().setUint32(addr + 4, nanHead, !0), mem().setUint32(addr, 3, !0);
                                return;
                            case !1:
                                mem().setUint32(addr + 4, nanHead, !0), mem().setUint32(addr, 4, !0);
                                return;
                        }
                        let id = this._ids.get(v);
                        void 0 === id && (void 0 === (id = this._idPool.pop()) && (id = this._values.length), this._values[id] = v, this._goRefCounts[id] = 0, this._ids.set(v, id)), this._goRefCounts[id]++;
                        let typeFlag = 1;
                        switch(typeof v){
                            case 'string':
                                typeFlag = 2;
                                break;
                            case 'symbol':
                                typeFlag = 3;
                                break;
                            case 'function':
                                typeFlag = 4;
                        }
                        mem().setUint32(addr + 4, nanHead | typeFlag, !0), mem().setUint32(addr, id, !0);
                    }, loadSlice = (array, len, cap = null)=>new Uint8Array(this._inst.exports.memory.buffer, array, len), loadSliceOfValues = (array, len, cap)=>{
                        const a = Array(len);
                        for(let i = 0; i < len; i++)a[i] = loadValue(array + 8 * i);
                        return a;
                    }, loadString = (ptr, len)=>decoder.decode(new DataView(this._inst.exports.memory.buffer, ptr, len)), timeOrigin = Date.now() - performance.now();
                    this.importObject = {
                        wasi_snapshot_preview1: {
                            fd_write: function(fd, iovs_ptr, iovs_len, nwritten_ptr) {
                                let nwritten = 0;
                                if (1 == fd) for(let iovs_i = 0; iovs_i < iovs_len; iovs_i++){
                                    let iov_ptr = iovs_ptr + 8 * iovs_i, ptr = mem().getUint32(iov_ptr + 0, !0), len = mem().getUint32(iov_ptr + 4, !0);
                                    nwritten += len;
                                    for(let i = 0; i < len; i++){
                                        let c = mem().getUint8(ptr + i);
                                        if (13 == c) ;
                                        else if (10 == c) {
                                            let line = decoder.decode(new Uint8Array(logLine));
                                            logLine = [], console.log(line);
                                        } else logLine.push(c);
                                    }
                                }
                                else console.error('invalid file descriptor:', fd);
                                return mem().setUint32(nwritten_ptr, nwritten, !0), 0;
                            },
                            fd_close: ()=>0,
                            fd_fdstat_get: ()=>0,
                            fd_seek: ()=>0,
                            proc_exit: (code)=>{
                                if (__webpack_require__.g.process) process.exit(code);
                                else throw 'trying to exit with code ' + code;
                            },
                            random_get: (bufPtr, bufLen)=>(crypto.getRandomValues(loadSlice(bufPtr, bufLen, null)), 0)
                        },
                        env: {
                            'runtime.ticks': ()=>timeOrigin + performance.now(),
                            'runtime.sleepTicks': (timeout)=>{
                                setTimeout(this._inst.exports.go_scheduler, timeout);
                            },
                            'syscall/js.finalizeRef': (v_addr)=>{
                                const id = mem().getUint32(v_addr, !0);
                                if (this._goRefCounts[id]--, 0 === this._goRefCounts[id]) {
                                    const v = this._values[id];
                                    this._values[id] = null, this._ids.delete(v), this._idPool.push(id);
                                }
                            },
                            'syscall/js.stringVal': (ret_ptr, value_ptr, value_len)=>{
                                const s = loadString(value_ptr, value_len);
                                storeValue(ret_ptr, s);
                            },
                            'syscall/js.valueGet': (retval, v_addr, p_ptr, p_len)=>{
                                let prop = loadString(p_ptr, p_len), value = loadValue(v_addr), result = Reflect.get(value, prop);
                                storeValue(retval, result);
                            },
                            'syscall/js.valueSet': (v_addr, p_ptr, p_len, x_addr)=>{
                                const v = loadValue(v_addr), p = loadString(p_ptr, p_len), x = loadValue(x_addr);
                                Reflect.set(v, p, x);
                            },
                            'syscall/js.valueDelete': (v_addr, p_ptr, p_len)=>{
                                const v = loadValue(v_addr), p = loadString(p_ptr, p_len);
                                Reflect.deleteProperty(v, p);
                            },
                            'syscall/js.valueIndex': (ret_addr, v_addr, i)=>{
                                storeValue(ret_addr, Reflect.get(loadValue(v_addr), i));
                            },
                            'syscall/js.valueSetIndex': (v_addr, i, x_addr)=>{
                                Reflect.set(loadValue(v_addr), i, loadValue(x_addr));
                            },
                            'syscall/js.valueCall': (ret_addr, v_addr, m_ptr, m_len, args_ptr, args_len, args_cap)=>{
                                const v = loadValue(v_addr), name = loadString(m_ptr, m_len), args = loadSliceOfValues(args_ptr, args_len, args_cap);
                                try {
                                    const m = Reflect.get(v, name);
                                    storeValue(ret_addr, Reflect.apply(m, v, args)), mem().setUint8(ret_addr + 8, 1);
                                } catch (err) {
                                    storeValue(ret_addr, err), mem().setUint8(ret_addr + 8, 0);
                                }
                            },
                            'syscall/js.valueInvoke': (ret_addr, v_addr, args_ptr, args_len, args_cap)=>{
                                try {
                                    const v = loadValue(v_addr), args = loadSliceOfValues(args_ptr, args_len, args_cap);
                                    storeValue(ret_addr, Reflect.apply(v, void 0, args)), mem().setUint8(ret_addr + 8, 1);
                                } catch (err) {
                                    storeValue(ret_addr, err), mem().setUint8(ret_addr + 8, 0);
                                }
                            },
                            'syscall/js.valueNew': (ret_addr, v_addr, args_ptr, args_len, args_cap)=>{
                                const v = loadValue(v_addr), args = loadSliceOfValues(args_ptr, args_len, args_cap);
                                try {
                                    storeValue(ret_addr, Reflect.construct(v, args)), mem().setUint8(ret_addr + 8, 1);
                                } catch (err) {
                                    storeValue(ret_addr, err), mem().setUint8(ret_addr + 8, 0);
                                }
                            },
                            'syscall/js.valueLength': (v_addr)=>loadValue(v_addr).length,
                            'syscall/js.valuePrepareString': (ret_addr, v_addr)=>{
                                const s = String(loadValue(v_addr)), str = encoder.encode(s);
                                storeValue(ret_addr, str), setInt64(ret_addr + 8, str.length);
                            },
                            'syscall/js.valueLoadString': (v_addr, slice_ptr, slice_len, slice_cap)=>{
                                const str = loadValue(v_addr);
                                loadSlice(slice_ptr, slice_len, slice_cap).set(str);
                            },
                            'syscall/js.valueInstanceOf': (v_addr, t_addr)=>loadValue(v_addr) instanceof loadValue(t_addr),
                            'syscall/js.copyBytesToGo': (ret_addr, dest_addr, dest_len, dest_cap, source_addr)=>{
                                let num_bytes_copied_addr = ret_addr, returned_status_addr = ret_addr + 4;
                                const dst = loadSlice(dest_addr, dest_len), src = loadValue(source_addr);
                                if (!(src instanceof Uint8Array)) {
                                    mem().setUint8(returned_status_addr, 0);
                                    return;
                                }
                                const toCopy = src.subarray(0, dst.length);
                                dst.set(toCopy), setInt64(num_bytes_copied_addr, toCopy.length), mem().setUint8(returned_status_addr, 1);
                            },
                            'syscall/js.copyBytesToJS': (ret_addr, dest_addr, source_addr, source_len, source_cap)=>{
                                let num_bytes_copied_addr = ret_addr, returned_status_addr = ret_addr + 4;
                                const dst = loadValue(dest_addr), src = loadSlice(source_addr, source_len);
                                if (!(dst instanceof Uint8Array)) {
                                    mem().setUint8(returned_status_addr, 0);
                                    return;
                                }
                                const toCopy = src.subarray(0, dst.length);
                                dst.set(toCopy), setInt64(num_bytes_copied_addr, toCopy.length), mem().setUint8(returned_status_addr, 1);
                            }
                        }
                    };
                }
                async run(instance) {
                    for(this._inst = instance, this._values = [
                        NaN,
                        0,
                        null,
                        !0,
                        !1,
                        __webpack_require__.g,
                        this
                    ], this._goRefCounts = [], this._ids = new Map(), this._idPool = [], this.exited = !1, new DataView(this._inst.exports.memory.buffer);;){
                        const callbackPromise = new Promise((resolve)=>{
                            this._resolveCallbackPromise = ()=>{
                                if (this.exited) throw Error('bad callback: Go program has already exited');
                                setTimeout(resolve, 0);
                            };
                        });
                        if (this._inst.exports._start(), this.exited) break;
                        await callbackPromise;
                    }
                }
                _resume() {
                    if (this.exited) throw Error('Go program has already exited');
                    this._inst.exports.resume(), this.exited && this._resolveExitPromise();
                }
                _makeFuncWrapper(id) {
                    const go = this;
                    return function() {
                        const event = {
                            id: id,
                            this: this,
                            args: arguments
                        };
                        return go._pendingEvent = event, go._resume(), event.result;
                    };
                }
                _resolveExitPromise() {}
            }
            exports.Go = Go;
        },
        6505: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.rustWasmImports = void 0;
            const LoggerFactory_1 = __webpack_require__(5913), rustWasmImports = (swGlobal, wbindgenImports, wasmInstance, dtorValue)=>{
                const wasmLogger = LoggerFactory_1.LoggerFactory.INST.create('WASM:Rust'), rawImports = {
                    metering: {
                        usegas: swGlobal.useGas
                    },
                    console: {
                        log: function(value) {
                            wasmLogger.debug(`${swGlobal.contract.id}: ${value}`);
                        }
                    },
                    Block: {
                        height: function() {
                            return swGlobal.block.height;
                        },
                        indep_hash: function() {
                            return swGlobal.block.indep_hash;
                        },
                        timestamp: function() {
                            return swGlobal.block.timestamp;
                        }
                    },
                    Transaction: {
                        id: function() {
                            return swGlobal.transaction.id;
                        },
                        owner: function() {
                            return swGlobal.transaction.owner;
                        },
                        target: function() {
                            return swGlobal.transaction.target;
                        }
                    },
                    Contract: {
                        id: function() {
                            return swGlobal.contract.id;
                        },
                        owner: function() {
                            return swGlobal.contract.owner;
                        }
                    },
                    SmartWeave: {
                        caller: function() {
                            return swGlobal.caller;
                        },
                        readContractState: async function(contractTxId) {
                            return await swGlobal.contracts.readContractState(contractTxId);
                        },
                        write: async function(contractId, input) {
                            return await swGlobal.contracts.write(contractId, input);
                        }
                    },
                    Vrf: {
                        value: function() {
                            return swGlobal.vrf.value;
                        },
                        randomInt: function(maxValue) {
                            return swGlobal.vrf.randomInt(maxValue);
                        }
                    }
                }, baseImports = {
                    __wbg_log_: function(arg0, arg1) {
                        rawImports.console.log(getStringFromWasm0(arg0, arg1));
                    },
                    __wbindgen_json_parse: function(arg0, arg1) {
                        var ret = JSON.parse(getStringFromWasm0(arg0, arg1));
                        return addHeapObject(ret);
                    },
                    __wbindgen_json_serialize: function(arg0, arg1) {
                        const obj = getObject(arg1);
                        var ret = JSON.stringify(void 0 === obj ? null : obj), ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbindgen_object_drop_ref: function(arg0) {
                        takeObject(arg0);
                    },
                    __wbindgen_cb_drop: function(arg0) {
                        const obj = takeObject(arg0).original;
                        return 1 == obj.cnt-- && (obj.a = 0, !0);
                    },
                    __wbg_readContractState: function(arg0, arg1) {
                        var ret = rawImports.SmartWeave.readContractState(getStringFromWasm0(arg0, arg1));
                        return addHeapObject(ret);
                    },
                    __wbg_viewContractState: function(arg0, arg1) {},
                    __wbg_caller: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.SmartWeave.caller(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_write: function(arg0, arg1, arg2) {
                        var ret = rawImports.SmartWeave.write(getStringFromWasm0(arg0, arg1), takeObject(arg2));
                        return addHeapObject(ret);
                    },
                    __wbg_refreshState: function(arg0, arg1) {},
                    __wbg_indephash: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.Block.indep_hash(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_height: function() {
                        return rawImports.Block.height();
                    },
                    __wbg_timestamp: function() {
                        return rawImports.Block.timestamp();
                    },
                    __wbg_id: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.Transaction.id(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_contractOwner: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.Contract.owner(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_contractId: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.Contract.id(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_owner: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.Transaction.owner(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_target: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.Transaction.target(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_call: function() {
                        return handleError(function(arg0, arg1, arg2) {
                            var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
                            return addHeapObject(ret);
                        }, arguments);
                    },
                    __wbg_new: function(arg0, arg1) {
                        try {
                            var state0 = {
                                a: arg0,
                                b: arg1
                            }, cb0 = (arg0, arg1)=>{
                                const a = state0.a;
                                state0.a = 0;
                                try {
                                    return __wbg_adapter_42(a, state0.b, arg0, arg1);
                                } finally{
                                    state0.a = a;
                                }
                            }, ret = new Promise(cb0);
                            return addHeapObject(ret);
                        } finally{
                            state0.a = state0.b = 0;
                        }
                    },
                    __wbg_resolve: function(arg0) {
                        var ret = Promise.resolve(getObject(arg0));
                        return addHeapObject(ret);
                    },
                    __wbg_then_a: function(arg0, arg1) {
                        var ret = getObject(arg0).then(getObject(arg1));
                        return addHeapObject(ret);
                    },
                    __wbg_then_5: function(arg0, arg1, arg2) {
                        var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
                        return addHeapObject(ret);
                    },
                    __wbindgen_debug_string: function(arg0, arg1) {
                        var ret = debugString(getObject(arg1)), ptr0 = passStringToWasm0(ret, wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbindgen_throw: function(arg0, arg1) {
                        throw Error(getStringFromWasm0(arg0, arg1));
                    },
                    __wbindgen_closure_wrapper: function(arg0, arg1, arg2) {
                        var ret = makeMutClosure(arg0, arg1, dtorValue, __wbg_adapter_14);
                        return addHeapObject(ret);
                    },
                    __wbindgen_string_new: function(arg0, arg1) {
                        var ret = getStringFromWasm0(arg0, arg1);
                        return addHeapObject(ret);
                    },
                    __wbg_value: function(arg0) {
                        var ptr0 = passStringToWasm0(rawImports.Vrf.value(), wasmInstance.exports.__wbindgen_malloc, wasmInstance.exports.__wbindgen_realloc), len0 = WASM_VECTOR_LEN;
                        getInt32Memory0()[arg0 / 4 + 1] = len0, getInt32Memory0()[arg0 / 4 + 0] = ptr0;
                    },
                    __wbg_randomInt: function(arg0, arg1) {
                        return rawImports.Vrf.randomInt(arg1);
                    }
                }, baseImportsKeys = Object.keys(baseImports);
                let module = wbindgenImports.reduce((acc, wbindgenKey)=>{
                    const baseImportsKey = baseImportsKeys.find((key)=>wbindgenKey.startsWith(key));
                    if (void 0 === baseImportsKey) throw Error(`Cannot find import mapping for ${wbindgenKey}`);
                    return acc[wbindgenKey] = baseImports[baseImportsKey], acc;
                }, {}), imports = {};
                imports.__wbindgen_placeholder__ = module;
                let cachedTextDecoder = new TextDecoder('utf-8', {
                    ignoreBOM: !0,
                    fatal: !0
                });
                cachedTextDecoder.decode();
                let cachegetUint8Memory0 = null;
                function getUint8Memory0() {
                    return (null === cachegetUint8Memory0 || cachegetUint8Memory0.buffer !== wasmInstance.exports.memory.buffer) && (cachegetUint8Memory0 = new Uint8Array(wasmInstance.exports.memory.buffer)), cachegetUint8Memory0;
                }
                function getStringFromWasm0(ptr, len) {
                    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
                }
                const heap = Array(32).fill(void 0);
                heap.push(void 0, null, !0, !1);
                let heap_next = heap.length;
                function addHeapObject(obj) {
                    heap_next === heap.length && heap.push(heap.length + 1);
                    const idx = heap_next;
                    return heap_next = heap[idx], heap[idx] = obj, idx;
                }
                function getObject(idx) {
                    return heap[idx];
                }
                let WASM_VECTOR_LEN = 0, cachedTextEncoder = new TextEncoder('utf-8');
                const encodeString = 'function' == typeof cachedTextEncoder.encodeInto ? function(arg, view) {
                    return cachedTextEncoder.encodeInto(arg, view);
                } : function(arg, view) {
                    const buf = cachedTextEncoder.encode(arg);
                    return view.set(buf), {
                        read: arg.length,
                        written: buf.length
                    };
                };
                function passStringToWasm0(arg, malloc, realloc) {
                    if (void 0 === realloc) {
                        const buf = cachedTextEncoder.encode(arg), ptr = malloc(buf.length);
                        return getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf), WASM_VECTOR_LEN = buf.length, ptr;
                    }
                    let len = arg.length, ptr1 = malloc(len);
                    const mem = getUint8Memory0();
                    let offset = 0;
                    for(; offset < len; offset++){
                        const code = arg.charCodeAt(offset);
                        if (code > 0x7f) break;
                        mem[ptr1 + offset] = code;
                    }
                    if (offset !== len) {
                        0 !== offset && (arg = arg.slice(offset)), ptr1 = realloc(ptr1, len, len = offset + 3 * arg.length);
                        const view = getUint8Memory0().subarray(ptr1 + offset, ptr1 + len), ret = encodeString(arg, view);
                        offset += ret.written;
                    }
                    return WASM_VECTOR_LEN = offset, ptr1;
                }
                let cachegetInt32Memory0 = null;
                function getInt32Memory0() {
                    return (null === cachegetInt32Memory0 || cachegetInt32Memory0.buffer !== wasmInstance.exports.memory.buffer) && (cachegetInt32Memory0 = new Int32Array(wasmInstance.exports.memory.buffer)), cachegetInt32Memory0;
                }
                function dropObject(idx) {
                    idx < 36 || (heap[idx] = heap_next, heap_next = idx);
                }
                function takeObject(idx) {
                    const ret = getObject(idx);
                    return dropObject(idx), ret;
                }
                function debugString(val) {
                    const type = typeof val;
                    if ('number' == type || 'boolean' == type || null == val) return `${val}`;
                    if ('string' == type) return `"${val}"`;
                    if ('symbol' == type) {
                        const description = val.description;
                        return null == description ? 'Symbol' : `Symbol(${description})`;
                    }
                    if ('function' == type) {
                        const name = val.name;
                        return 'string' == typeof name && name.length > 0 ? `Function(${name})` : 'Function';
                    }
                    if (Array.isArray(val)) {
                        const length = val.length;
                        let debug = '[';
                        length > 0 && (debug += debugString(val[0]));
                        for(let i = 1; i < length; i++)debug += ', ' + debugString(val[i]);
                        return debug + ']';
                    }
                    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
                    let className;
                    if (!(builtInMatches.length > 1)) return toString.call(val);
                    if ('Object' == (className = builtInMatches[1])) try {
                        return 'Object(' + JSON.stringify(val) + ')';
                    } catch (_) {
                        return 'Object';
                    }
                    return val instanceof Error ? `${val.name}: ${val.message}\n${val.stack}` : className;
                }
                function makeMutClosure(arg0, arg1, dtor, f) {
                    const state = {
                        a: arg0,
                        b: arg1,
                        cnt: 1,
                        dtor
                    }, real = (...args)=>{
                        state.cnt++;
                        const a = state.a;
                        state.a = 0;
                        try {
                            return f(a, state.b, ...args);
                        } finally{
                            0 == --state.cnt ? wasmInstance.exports.__wbindgen_export_2.get(state.dtor)(a, state.b) : state.a = a;
                        }
                    };
                    return real.original = state, real;
                }
                function __wbg_adapter_14(arg0, arg1, arg2) {
                    wasmInstance.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__(arg0, arg1, addHeapObject(arg2));
                }
                module.handle = function(interaction) {
                    var ret = wasmInstance.exports.handle(addHeapObject(interaction));
                    return takeObject(ret);
                };
                let stack_pointer = 32;
                function addBorrowedObject(obj) {
                    if (1 == stack_pointer) throw Error('out of js stack');
                    return heap[--stack_pointer] = obj, stack_pointer;
                }
                function handleError(f, args) {
                    try {
                        return f.apply(this, args);
                    } catch (e) {
                        wasmInstance.exports.__wbindgen_exn_store(addHeapObject(e));
                    }
                }
                function __wbg_adapter_42(arg0, arg1, arg2, arg3) {
                    wasmInstance.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
                }
                module.initState = function(state) {
                    try {
                        wasmInstance.exports.initState(addBorrowedObject(state));
                    } finally{
                        heap[stack_pointer++] = void 0;
                    }
                }, module.currentState = function() {
                    return takeObject(wasmInstance.exports.currentState());
                }, module.lang = function() {
                    try {
                        const retptr = wasmInstance.exports.__wbindgen_add_to_stack_pointer(-16);
                        wasmInstance.exports.lang(retptr);
                        var r0 = getInt32Memory0()[retptr / 4 + 0], r1 = getInt32Memory0()[retptr / 4 + 1];
                        return getStringFromWasm0(r0, r1);
                    } finally{
                        wasmInstance.exports.__wbindgen_add_to_stack_pointer(16), wasmInstance.exports.__wbindgen_free(r0, r1);
                    }
                }, module.type = function() {
                    return wasmInstance.exports.type();
                };
                class StateWrapper {
                    __destroy_into_raw() {
                        const ptr = this.ptr;
                        return this.ptr = 0, ptr;
                    }
                    free() {
                        const ptr = this.__destroy_into_raw();
                        wasmInstance.exports.__wbg_statewrapper_free(ptr);
                    }
                }
                return module.StateWrapper = StateWrapper, imports.metering = rawImports.metering, {
                    imports,
                    exports: module
                };
            };
            exports.rustWasmImports = rustWasmImports;
        },
        4742: function(__unused_webpack_module, exports) {
            "use strict";
            function matchMutClosureDtor(source) {
                const regexp = /var ret = makeMutClosure\(arg0, arg1, (\d+?), __wbg_adapter/, match = source.match(regexp);
                return match[1];
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.matchMutClosureDtor = void 0, exports.matchMutClosureDtor = matchMutClosureDtor;
        },
        702: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k];
                    }
                }), Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k), o[k2] = m[k];
            }), __exportStar = this && this.__exportStar || function(m, exports) {
                for(var p in m)"default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), __exportStar(__webpack_require__(183), exports), __exportStar(__webpack_require__(4089), exports), __exportStar(__webpack_require__(2393), exports), __exportStar(__webpack_require__(5913), exports), __exportStar(__webpack_require__(5629), exports), __exportStar(__webpack_require__(9106), exports), __exportStar(__webpack_require__(2656), exports), __exportStar(__webpack_require__(5368), exports), __exportStar(__webpack_require__(5765), exports), __exportStar(__webpack_require__(6769), exports), __exportStar(__webpack_require__(7462), exports), __exportStar(__webpack_require__(7089), exports), __exportStar(__webpack_require__(3187), exports), __exportStar(__webpack_require__(9564), exports), __exportStar(__webpack_require__(1533), exports), __exportStar(__webpack_require__(7346), exports), __exportStar(__webpack_require__(4929), exports), __exportStar(__webpack_require__(4286), exports), __exportStar(__webpack_require__(9174), exports), __exportStar(__webpack_require__(1967), exports), __exportStar(__webpack_require__(8996), exports), __exportStar(__webpack_require__(4965), exports), __exportStar(__webpack_require__(2138), exports), __exportStar(__webpack_require__(6105), exports), __exportStar(__webpack_require__(3233), exports), __exportStar(__webpack_require__(1515), exports), __exportStar(__webpack_require__(3425), exports), __exportStar(__webpack_require__(8632), exports), __exportStar(__webpack_require__(7312), exports), __exportStar(__webpack_require__(4805), exports), __exportStar(__webpack_require__(9305), exports), __exportStar(__webpack_require__(5614), exports), __exportStar(__webpack_require__(8479), exports), __exportStar(__webpack_require__(2009), exports), __exportStar(__webpack_require__(9689), exports), __exportStar(__webpack_require__(8469), exports), __exportStar(__webpack_require__(9692), exports), __exportStar(__webpack_require__(7665), exports), __exportStar(__webpack_require__(7819), exports), __exportStar(__webpack_require__(8102), exports), __exportStar(__webpack_require__(4722), exports), __exportStar(__webpack_require__(4217), exports), __exportStar(__webpack_require__(5731), exports), __exportStar(__webpack_require__(3611), exports), __exportStar(__webpack_require__(4708), exports), __exportStar(__webpack_require__(8563), exports), __exportStar(__webpack_require__(9925), exports), __exportStar(__webpack_require__(3633), exports), __exportStar(__webpack_require__(40), exports), __exportStar(__webpack_require__(5082), exports), __exportStar(__webpack_require__(9360), exports);
        },
        40: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.unpackTags = exports.createDummyTx = exports.createInteractionTx = void 0;
            const SmartWeaveTags_1 = __webpack_require__(7312);
            async function createInteractionTx(arweave, signer, contractId, input, tags, target = '', winstonQty = '0', dummy = !1, reward) {
                const options = {
                    data: Math.random().toString().slice(-4)
                };
                target && target.length && (options.target = target.toString(), winstonQty && +winstonQty > 0 && (options.quantity = winstonQty.toString())), dummy && (options.reward = '72600854', options.last_tx = 'p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO'), reward && reward.length && (options.reward = reward);
                const interactionTx = await arweave.createTransaction(options);
                if (!input) throw Error(`Input should be a truthy value: ${JSON.stringify(input)}`);
                if (tags && tags.length) for (const tag of tags)interactionTx.addTag(tag.name.toString(), tag.value.toString());
                return interactionTx.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_NAME, 'SmartWeaveAction'), interactionTx.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_VERSION, '0.3.0'), interactionTx.addTag(SmartWeaveTags_1.SmartWeaveTags.SDK, 'Warp'), interactionTx.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID, contractId), interactionTx.addTag(SmartWeaveTags_1.SmartWeaveTags.INPUT, JSON.stringify(input)), signer && await signer(interactionTx), interactionTx;
            }
            function createDummyTx(tx, from, block) {
                const decodedTags = unpackTags(tx);
                return {
                    id: tx.id,
                    owner: {
                        address: from,
                        key: ''
                    },
                    recipient: tx.target,
                    tags: decodedTags,
                    fee: {
                        winston: tx.reward,
                        ar: ''
                    },
                    quantity: {
                        winston: tx.quantity,
                        ar: ''
                    },
                    block: {
                        id: block.indep_hash,
                        height: block.height,
                        timestamp: block.timestamp,
                        previous: null
                    },
                    dry: !0,
                    anchor: null,
                    signature: null,
                    data: null,
                    parent: null,
                    bundledIn: null
                };
            }
            function unpackTags(tx) {
                const tags = tx.get('tags'), result = [];
                for (const tag of tags)try {
                    const name = tag.get('name', {
                        decode: !0,
                        string: !0
                    }), value = tag.get('value', {
                        decode: !0,
                        string: !0
                    });
                    result.push({
                        name,
                        value
                    });
                } catch (e) {}
                return result;
            }
            exports.createInteractionTx = createInteractionTx, exports.createDummyTx = createDummyTx, exports.unpackTags = unpackTags;
        },
        9925: function(__unused_webpack_module, exports) {
            "use strict";
            var SmartWeaveErrorType, SmartWeaveErrorType1;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SmartWeaveError = exports.SmartWeaveErrorType = void 0, (SmartWeaveErrorType1 = SmartWeaveErrorType = exports.SmartWeaveErrorType || (exports.SmartWeaveErrorType = {})).CONTRACT_NOT_FOUND = "CONTRACT_NOT_FOUND";
            class SmartWeaveError extends Error {
                constructor(type, optional = {}){
                    optional.message ? super(optional.message) : super(), this.type = type, this.otherInfo = optional;
                }
                getType() {
                    return this.type;
                }
            }
            exports.SmartWeaveError = SmartWeaveError;
        },
        4708: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        8563: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SmartWeaveGlobal = void 0;
            class SmartWeaveGlobal {
                constructor(arweave, contract, evaluationOptions){
                    this.gasUsed = 0, this.gasLimit = Number.MAX_SAFE_INTEGER, this.unsafeClient = arweave, this.arweave = {
                        ar: arweave.ar,
                        utils: arweave.utils,
                        wallets: arweave.wallets,
                        crypto: arweave.crypto
                    }, this.evaluationOptions = evaluationOptions, this.contract = contract, this.transaction = new Transaction(this), this.block = new Block(this), this.contracts = {
                        readContractState: (contractId, height, returnValidity)=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        },
                        viewContractState: (contractId, input)=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        },
                        write: (contractId, input)=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        },
                        refreshState: ()=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        }
                    }, this.vrf = new Vrf(this), this.useGas = this.useGas.bind(this), this.getBalance = this.getBalance.bind(this);
                }
                useGas(gas) {
                    if (gas < 0) throw Error("[RE:GNE] Gas number exception - gas < 0.");
                    if (this.gasUsed += gas, this.gasUsed > this.gasLimit) throw Error(`[RE:OOG] Out of gas! Used: ${this.gasUsed}, limit: ${this.gasLimit}`);
                }
                async getBalance(address, height) {
                    if (!this._activeTx) throw Error('Cannot read balance - active tx is not set.');
                    if (!this.block.height) throw Error('Cannot read balance - block height not set.');
                    const effectiveHeight = height || this.block.height;
                    return await fetch(`${this.evaluationOptions.walletBalanceUrl}block/height/${effectiveHeight}/wallet/${address}/balance`).then((res)=>res.ok ? res.text() : Promise.reject(res)).catch((error)=>{
                        var _a;
                        throw Error(`Unable to read wallet balance. ${error.status}. ${null === (_a = error.body) || void 0 === _a ? void 0 : _a.message}`);
                    });
                }
            }
            exports.SmartWeaveGlobal = SmartWeaveGlobal;
            class Transaction {
                constructor(smartWeaveGlobal){
                    this.smartWeaveGlobal = smartWeaveGlobal;
                }
                get id() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.id;
                }
                get owner() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.owner.address;
                }
                get target() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.recipient;
                }
                get tags() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.tags;
                }
                get quantity() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.quantity.winston;
                }
                get reward() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.fee.winston;
                }
            }
            class Block {
                constructor(smartWeaveGlobal){
                    this.smartWeaveGlobal = smartWeaveGlobal;
                }
                get height() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.block.height;
                }
                get indep_hash() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.block.id;
                }
                get timestamp() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current tx');
                    return this.smartWeaveGlobal._activeTx.block.timestamp;
                }
            }
            class Vrf {
                constructor(smartWeaveGlobal){
                    this.smartWeaveGlobal = smartWeaveGlobal;
                }
                get data() {
                    return this.smartWeaveGlobal._activeTx.vrf;
                }
                get value() {
                    return this.smartWeaveGlobal._activeTx.vrf.bigint;
                }
                randomInt(maxValue) {
                    if (!Number.isInteger(maxValue)) throw Error('Integer max value required for random integer generation');
                    const result = BigInt(this.smartWeaveGlobal._activeTx.vrf.bigint) % BigInt(maxValue) + BigInt(1);
                    if (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER) throw Error('Random int cannot be cast to number');
                    return Number(result);
                }
            }
        },
        3633: function(__unused_webpack_module, exports) {
            "use strict";
            function getTag(tx, name) {
                const tags = tx.get('tags');
                for (const tag of tags)try {
                    if (tag.get('name', {
                        decode: !0,
                        string: !0
                    }) === name) return tag.get('value', {
                        decode: !0,
                        string: !0
                    });
                } catch (e) {}
                return !1;
            }
            function arrayToHex(arr) {
                let str = '';
                for (const a of arr)str += ('0' + a.toString(16)).slice(-2);
                return str;
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.arrayToHex = exports.getTag = void 0, exports.getTag = getTag, exports.arrayToHex = arrayToHex;
        },
        9106: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Benchmark = void 0;
            class Benchmark {
                constructor(){
                    this.start = Date.now(), this.end = null;
                }
                static measure() {
                    return new Benchmark();
                }
                reset() {
                    this.start = Date.now(), this.end = null;
                }
                stop() {
                    this.end = Date.now();
                }
                elapsed(rawValue = !1) {
                    null === this.end && (this.end = Date.now());
                    const result = this.end - this.start;
                    return rawValue ? result : `${(this.end - this.start).toFixed(0)}ms`;
                }
            }
            exports.Benchmark = Benchmark;
        },
        5913: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.LoggerFactory = void 0;
            const ConsoleLoggerFactory_1 = __webpack_require__(4089);
            class LoggerFactory {
                constructor(){}
                setOptions(newOptions, moduleName) {
                    LoggerFactory.INST.setOptions(newOptions, moduleName);
                }
                getOptions(moduleName) {
                    return LoggerFactory.INST.getOptions(moduleName);
                }
                logLevel(level, moduleName) {
                    LoggerFactory.INST.logLevel(level, moduleName);
                }
                create(moduleName) {
                    return LoggerFactory.INST.create(moduleName);
                }
                static use(logger) {
                    LoggerFactory.INST = logger;
                }
            }
            exports.LoggerFactory = LoggerFactory, LoggerFactory.INST = new ConsoleLoggerFactory_1.ConsoleLoggerFactory();
        },
        5629: function(__unused_webpack_module, exports) {
            "use strict";
            function lvlToOrder(logLevel) {
                return exports.LogLevelOrder[logLevel];
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.lvlToOrder = exports.LogLevelOrder = void 0, exports.LogLevelOrder = {
                silly: 0,
                trace: 1,
                debug: 2,
                info: 3,
                warn: 4,
                error: 5,
                fatal: 6
            }, exports.lvlToOrder = lvlToOrder;
        },
        2393: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        },
        183: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.ConsoleLogger = void 0;
            const LoggerSettings_1 = __webpack_require__(5629);
            class ConsoleLogger {
                constructor(moduleName, settings){
                    this.moduleName = moduleName, this.settings = settings;
                }
                trace(message, ...optionalParams) {
                    this.shouldLog('trace') && console.debug(this.message('trace', message), optionalParams);
                }
                error(message, ...optionalParams) {
                    this.shouldLog('error') && console.error(this.message('error', message), optionalParams);
                }
                info(message, ...optionalParams) {
                    this.shouldLog('info') && console.info(this.message('info', message), optionalParams);
                }
                silly(message, ...optionalParams) {
                    this.shouldLog('silly') && console.debug(this.message('silly', message), optionalParams);
                }
                debug(message, ...optionalParams) {
                    this.shouldLog('debug') && console.debug(this.message('debug', message), optionalParams);
                }
                warn(message, ...optionalParams) {
                    this.shouldLog('warn') && console.warn(this.message('warn', message), optionalParams);
                }
                log(message, ...optionalParams) {
                    this.shouldLog('info') && console.info(this.message('info', message), optionalParams);
                }
                fatal(message, ...optionalParams) {
                    this.shouldLog('fatal') && console.error(this.message('fatal', message), optionalParams);
                }
                shouldLog(logLevel) {
                    return (0, LoggerSettings_1.lvlToOrder)(logLevel) >= (0, LoggerSettings_1.lvlToOrder)(this.settings.minLevel);
                }
                setSettings(settings) {
                    this.settings = settings;
                }
                message(lvl, message) {
                    return `${new Date().toISOString()} ${lvl.toUpperCase()} [${this.moduleName}] ${message}`;
                }
            }
            exports.ConsoleLogger = ConsoleLogger;
        },
        4089: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.ConsoleLoggerFactory = void 0;
            const ConsoleLogger_1 = __webpack_require__(183);
            class ConsoleLoggerFactory {
                constructor(){
                    this.registeredLoggers = {}, this.registeredOptions = {}, this.defOptions = {
                        minLevel: 'info'
                    }, this.setOptions = this.setOptions.bind(this), this.getOptions = this.getOptions.bind(this), this.create = this.create.bind(this), this.logLevel = this.logLevel.bind(this);
                }
                setOptions(newOptions, moduleName) {
                    moduleName ? this.registeredLoggers[moduleName] ? this.registeredLoggers[moduleName].setSettings({
                        ...this.registeredLoggers[moduleName].settings,
                        ...newOptions
                    }) : this.registeredOptions[moduleName] = {
                        ...this.defOptions,
                        ...newOptions
                    } : (this.defOptions = newOptions, Object.keys(this.registeredLoggers).forEach((key)=>{
                        this.registeredLoggers[key].setSettings({
                            ...this.registeredLoggers[key].settings,
                            ...newOptions
                        });
                    }));
                }
                getOptions(moduleName) {
                    return moduleName ? this.registeredLoggers[moduleName] ? this.registeredLoggers[moduleName].settings : this.registeredOptions[moduleName] ? this.registeredOptions[moduleName] : this.defOptions : this.defOptions;
                }
                logLevel(level, moduleName) {
                    this.setOptions({
                        minLevel: level
                    }, moduleName);
                }
                create(moduleName = 'SWC') {
                    return Object.prototype.hasOwnProperty.call(this.registeredLoggers, moduleName) || (this.registeredLoggers[moduleName] = new ConsoleLogger_1.ConsoleLogger(moduleName, this.getOptions(moduleName))), this.registeredLoggers[moduleName];
                }
            }
            exports.ConsoleLoggerFactory = ConsoleLoggerFactory;
        },
        7794: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.CacheableExecutorFactory = void 0;
            const LoggerFactory_1 = __webpack_require__(5913);
            class CacheableExecutorFactory {
                constructor(arweave, baseImplementation, cache){
                    this.arweave = arweave, this.baseImplementation = baseImplementation, this.cache = cache, this.logger = LoggerFactory_1.LoggerFactory.INST.create('CacheableExecutorFactory');
                }
                async create(contractDefinition, evaluationOptions) {
                    return await this.baseImplementation.create(contractDefinition, evaluationOptions);
                }
            }
            exports.CacheableExecutorFactory = CacheableExecutorFactory;
        },
        4481: function(__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.DebuggableExecutorFactory = void 0;
            class DebuggableExecutorFactory {
                constructor(baseImplementation, sourceCode){
                    this.baseImplementation = baseImplementation, this.sourceCode = sourceCode;
                }
                async create(contractDefinition, evaluationOptions) {
                    return Object.prototype.hasOwnProperty.call(this.sourceCode, contractDefinition.txId) && (contractDefinition = {
                        ...contractDefinition,
                        src: this.sourceCode[contractDefinition.txId]
                    }), await this.baseImplementation.create(contractDefinition, evaluationOptions);
                }
            }
            exports.DebuggableExecutorFactory = DebuggableExecutorFactory;
        },
        2491: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.Evolve = void 0;
            const LoggerFactory_1 = __webpack_require__(5913), errors_1 = __webpack_require__(9925);
            function isEvolveCompatible(state) {
                if (!state) return !1;
                const settings = evalSettings(state);
                return void 0 !== state.evolve || settings.has('evolve');
            }
            class Evolve {
                constructor(){
                    this.logger = LoggerFactory_1.LoggerFactory.INST.create('Evolve'), this.modify = this.modify.bind(this);
                }
                async modify(state, executionContext) {
                    const { definitionLoader , executorFactory  } = executionContext.warp, contractTxId = executionContext.contractDefinition.txId, evolvedSrcTxId = Evolve.evolvedSrcTxId(state), currentSrcTxId = executionContext.contractDefinition.srcTxId;
                    if (evolvedSrcTxId && (this.logger.debug('Checking evolve:', {
                        current: currentSrcTxId,
                        evolvedSrcTxId
                    }), currentSrcTxId !== evolvedSrcTxId)) try {
                        this.logger.info('Evolving to: ', evolvedSrcTxId);
                        const newContractDefinition = await definitionLoader.load(contractTxId, evolvedSrcTxId), newHandler = await executorFactory.create(newContractDefinition, executionContext.evaluationOptions);
                        executionContext.contractDefinition = newContractDefinition, executionContext.handler = newHandler, executionContext.handler.initState(state), this.logger.debug('evolved to:', {
                            evolve: evolvedSrcTxId,
                            newSrcTxId: executionContext.contractDefinition.srcTxId,
                            current: currentSrcTxId,
                            txId: executionContext.contractDefinition.txId
                        });
                    } catch (e) {
                        throw new errors_1.SmartWeaveError(errors_1.SmartWeaveErrorType.CONTRACT_NOT_FOUND, {
                            message: `Contract having txId: ${contractTxId} not found`,
                            requestedTxId: contractTxId
                        });
                    }
                    return executionContext;
                }
                static evolvedSrcTxId(state) {
                    if (!isEvolveCompatible(state)) return;
                    const settings = evalSettings(state), evolve = state.evolve || settings.get('evolve');
                    let canEvolve = state.canEvolve || settings.get('canEvolve');
                    if (null == canEvolve && (canEvolve = !0), evolve && /[a-z0-9_-]{43}/i.test(evolve) && canEvolve) return evolve;
                }
            }
            function evalSettings(state) {
                let settings = new Map();
                return state.settings && (isIterable(state.settings) ? settings = new Map(state.settings) : isObject(state.settings) && (settings = new Map(Object.entries(state.settings)))), settings;
            }
            function isIterable(obj) {
                return null != obj && 'function' == typeof obj[Symbol.iterator];
            }
            function isObject(obj) {
                return 'object' == typeof obj && null !== obj && !Array.isArray(obj);
            }
            exports.Evolve = Evolve;
        },
        9360: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.ArweaveWrapper = void 0;
            const arweave_1 = __importDefault(__webpack_require__(7386)), transaction_1 = __importDefault(__webpack_require__(7241)), redstone_isomorphic_1 = __webpack_require__(9180), WarpFactory_1 = __webpack_require__(8479), LoggerFactory_1 = __webpack_require__(5913);
            class ArweaveWrapper {
                constructor(arweave){
                    this.arweave = arweave, this.logger = LoggerFactory_1.LoggerFactory.INST.create('ArweaveWrapper'), this.baseUrl = `${arweave.api.config.protocol}://${arweave.api.config.host}:${arweave.api.config.port}`, this.logger.debug('baseurl', this.baseUrl);
                }
                async warpGwInfo() {
                    return await this.doFetchInfo(`${WarpFactory_1.WARP_GW_URL}/gateway/arweave/info`);
                }
                async warpGwBlock() {
                    return this.logger.debug('Calling warp gw block info'), await this.doFetchInfo(`${WarpFactory_1.WARP_GW_URL}/gateway/arweave/block`);
                }
                async info() {
                    return await this.doFetchInfo(`${this.baseUrl}/info`);
                }
                async gql(query, variables) {
                    try {
                        const data = JSON.stringify({
                            query: query,
                            variables: variables
                        }), response = await fetch(`${this.baseUrl}/graphql`, {
                            method: 'POST',
                            body: data,
                            headers: {
                                'Accept-Encoding': 'gzip, deflate, br',
                                'Content-Type': 'application/json',
                                Accept: 'application/json'
                            }
                        }).then((res)=>res.ok ? res.json() : Promise.reject(res)).catch((error)=>{
                            var _a, _b;
                            throw (null === (_a = error.body) || void 0 === _a ? void 0 : _a.message) && this.logger.error(error.body.message), Error(`Unable to retrieve gql page. ${error.status}: ${null === (_b = error.body) || void 0 === _b ? void 0 : _b.message}`);
                        });
                        return {
                            data: response,
                            status: 200
                        };
                    } catch (e) {
                        throw this.logger.error('Error while loading gql', e), e;
                    }
                }
                async tx(id) {
                    const response = await fetch(`${this.baseUrl}/tx/${id}`).then((res)=>res.ok ? res.json() : Promise.reject(res)).catch((error)=>{
                        var _a, _b;
                        throw (null === (_a = error.body) || void 0 === _a ? void 0 : _a.message) && this.logger.error(error.body.message), Error(`Unable to retrieve tx ${id}. ${error.status}. ${null === (_b = error.body) || void 0 === _b ? void 0 : _b.message}`);
                    });
                    return new transaction_1.default({
                        ...response
                    });
                }
                async txData(id) {
                    const response = await fetch(`${this.baseUrl}/${id}`);
                    if (response.ok) {
                        const buffer = await response.arrayBuffer();
                        return redstone_isomorphic_1.Buffer.from(buffer);
                    }
                    {
                        this.logger.warn(`Unable to load data from arweave.net/${id} endpoint, falling back to arweave.js`);
                        const txData = await this.arweave.transactions.getData(id, {
                            decode: !0
                        });
                        return redstone_isomorphic_1.Buffer.from(txData);
                    }
                }
                async txDataString(id) {
                    const buffer = await this.txData(id);
                    return arweave_1.default.utils.bufferToString(buffer);
                }
                async doFetchInfo(url) {
                    try {
                        const response = await fetch(url).then((res)=>res.ok ? res.json() : Promise.reject(res)).catch((error)=>{
                            var _a, _b;
                            throw (null === (_a = error.body) || void 0 === _a ? void 0 : _a.message) && this.logger.error(error.body.message), Error(`Unable to retrieve info. ${error.status}: ${null === (_b = error.body) || void 0 === _b ? void 0 : _b.message}`);
                        });
                        return response;
                    } catch (e) {
                        throw this.logger.error('Error while loading info', e), e;
                    }
                }
            }
            exports.ArweaveWrapper = ArweaveWrapper;
        },
        5082: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.indent = exports.stripTrailingSlash = exports.timeout = exports.descS = exports.desc = exports.ascS = exports.asc = exports.mapReviver = exports.mapReplacer = exports.deepCopy = exports.sleep = void 0;
            const cloneDeep_1 = __importDefault(__webpack_require__(361)), fast_copy_1 = __importDefault(__webpack_require__(3346)), sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
            exports.sleep = sleep;
            const deepCopy = (input, useFastCopy = !1)=>useFastCopy ? (0, fast_copy_1.default)(input) : (0, cloneDeep_1.default)(input);
            exports.deepCopy = deepCopy;
            const mapReplacer = (key, value)=>value instanceof Map ? {
                    dataType: 'Map',
                    value: Array.from(value.entries())
                } : value;
            exports.mapReplacer = mapReplacer;
            const mapReviver = (key, value)=>'object' == typeof value && null !== value && 'Map' === value.dataType ? new Map(value.value) : value;
            exports.mapReviver = mapReviver;
            const asc = (a, b)=>a - b;
            exports.asc = asc;
            const ascS = (a, b)=>+a - +b;
            exports.ascS = ascS;
            const desc = (a, b)=>b - a;
            exports.desc = desc;
            const descS = (a, b)=>+b - +a;
            function timeout(s) {
                let timeoutId = null;
                const timeoutPromise = new Promise((resolve, reject)=>{
                    timeoutId = setTimeout(()=>{
                        clearTimeout(timeoutId), reject('timeout');
                    }, 1000 * s);
                });
                return {
                    timeoutId,
                    timeoutPromise
                };
            }
            function stripTrailingSlash(str) {
                return str.endsWith('/') ? str.slice(0, -1) : str;
            }
            function indent(callDepth) {
                return ''.padEnd(2 * callDepth, ' ');
            }
            exports.descS = descS, exports.timeout = timeout, exports.stripTrailingSlash = stripTrailingSlash, exports.indent = indent;
        },
        6430: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var forEach = __webpack_require__(4029), availableTypedArrays = __webpack_require__(3083), callBound = __webpack_require__(1924), $toString = callBound('Object.prototype.toString'), hasToStringTag = __webpack_require__(6410)(), g = 'undefined' == typeof globalThis ? __webpack_require__.g : globalThis, typedArrays = availableTypedArrays(), $slice = callBound('String.prototype.slice'), toStrTags = {}, gOPD = __webpack_require__(882), getPrototypeOf = Object.getPrototypeOf;
            hasToStringTag && gOPD && getPrototypeOf && forEach(typedArrays, function(typedArray) {
                if ('function' == typeof g[typedArray]) {
                    var arr = new g[typedArray]();
                    if (Symbol.toStringTag in arr) {
                        var proto = getPrototypeOf(arr), descriptor = gOPD(proto, Symbol.toStringTag);
                        if (!descriptor) {
                            var superProto = getPrototypeOf(proto);
                            descriptor = gOPD(superProto, Symbol.toStringTag);
                        }
                        toStrTags[typedArray] = descriptor.get;
                    }
                }
            });
            var tryTypedArrays = function(value) {
                var foundName = !1;
                return forEach(toStrTags, function(getter, typedArray) {
                    if (!foundName) try {
                        var name = getter.call(value);
                        name === typedArray && (foundName = name);
                    } catch (e) {}
                }), foundName;
            }, isTypedArray = __webpack_require__(5692);
            module.exports = function(value) {
                return !!isTypedArray(value) && (hasToStringTag && Symbol.toStringTag in value ? tryTypedArrays(value) : $slice($toString(value), 8, -1));
            };
        },
        7605: function(module, exports) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, loader = function(exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0, exports.demangle = demangle, exports.instantiate = instantiate, exports.instantiateStreaming = instantiateStreaming, exports.instantiateSync = instantiateSync;
                const ID_OFFSET = -8, SIZE_OFFSET = -4, ARRAYBUFFER_ID = 0, STRING_ID = 1, ARRAYBUFFERVIEW = 1, ARRAY = 2, STATICARRAY = 4, VAL_ALIGN_OFFSET = 6, VAL_SIGNED = 2048, VAL_FLOAT = 4096, VAL_MANAGED = 16384, ARRAYBUFFERVIEW_BUFFER_OFFSET = 0, ARRAYBUFFERVIEW_DATASTART_OFFSET = 4, ARRAYBUFFERVIEW_BYTELENGTH_OFFSET = 8, ARRAYBUFFERVIEW_SIZE = 12, ARRAY_LENGTH_OFFSET = 12, ARRAY_SIZE = 16, E_NO_EXPORT_TABLE = "Operation requires compiling with --exportTable", E_NO_EXPORT_RUNTIME = "Operation requires compiling with --exportRuntime", F_NO_EXPORT_RUNTIME = ()=>{
                    throw Error(E_NO_EXPORT_RUNTIME);
                }, BIGINT = "undefined" != typeof BigUint64Array, THIS = Symbol(), STRING_SMALLSIZE = 192, STRING_CHUNKSIZE = 1024, utf16 = new TextDecoder("utf-16le", {
                    fatal: !0
                });
                function getStringImpl(buffer, ptr) {
                    let len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;
                    const wtf16 = new Uint16Array(buffer, ptr, len);
                    if (len <= STRING_SMALLSIZE) return String.fromCharCode(...wtf16);
                    try {
                        return utf16.decode(wtf16);
                    } catch  {
                        let str = "", off = 0;
                        for(; len - off > STRING_CHUNKSIZE;)str += String.fromCharCode(...wtf16.subarray(off, off += STRING_CHUNKSIZE));
                        return str + String.fromCharCode(...wtf16.subarray(off));
                    }
                }
                function preInstantiate(imports) {
                    const extendedExports = {};
                    function getString(memory, ptr) {
                        return memory ? getStringImpl(memory.buffer, ptr) : "<yet unknown>";
                    }
                    const env = imports.env = imports.env || {};
                    return env.abort = env.abort || function(msg, file, line, colm) {
                        const memory = extendedExports.memory || env.memory;
                        throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);
                    }, env.trace = env.trace || function(msg, n, ...args) {
                        const memory = extendedExports.memory || env.memory;
                        console.log(`trace: ${getString(memory, msg)}${n ? " " : ""}${args.slice(0, n).join(", ")}`);
                    }, env.seed = env.seed || Date.now, imports.Math = imports.Math || Math, imports.Date = imports.Date || Date, extendedExports;
                }
                function postInstantiate(extendedExports, instance) {
                    const exports = instance.exports, memory = exports.memory, table = exports.table, __new = exports.__new || F_NO_EXPORT_RUNTIME, __pin = exports.__pin || F_NO_EXPORT_RUNTIME, __unpin = exports.__unpin || F_NO_EXPORT_RUNTIME, __collect = exports.__collect || F_NO_EXPORT_RUNTIME, __rtti_base = exports.__rtti_base, getRttiCount = __rtti_base ? (arr)=>arr[__rtti_base >>> 2] : F_NO_EXPORT_RUNTIME;
                    function getRttInfo(id) {
                        const U32 = new Uint32Array(memory.buffer);
                        if ((id >>>= 0) >= getRttiCount(U32)) throw Error(`invalid id: ${id}`);
                        return U32[(__rtti_base + 4 >>> 2) + (id << 1)];
                    }
                    function getRttBase(id) {
                        const U32 = new Uint32Array(memory.buffer);
                        if ((id >>>= 0) >= getRttiCount(U32)) throw Error(`invalid id: ${id}`);
                        return U32[(__rtti_base + 4 >>> 2) + (id << 1) + 1];
                    }
                    function getArrayInfo(id) {
                        const info = getRttInfo(id);
                        if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);
                        return info;
                    }
                    function getValueAlign(info) {
                        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
                    }
                    function __newString(str) {
                        if (null == str) return 0;
                        const length = str.length, ptr = __new(length << 1, STRING_ID), U16 = new Uint16Array(memory.buffer);
                        for(var i = 0, p = ptr >>> 1; i < length; ++i)U16[p + i] = str.charCodeAt(i);
                        return ptr;
                    }
                    function __newArrayBuffer(buf) {
                        if (null == buf) return 0;
                        const bufview = new Uint8Array(buf), ptr = __new(bufview.length, ARRAYBUFFER_ID), U8 = new Uint8Array(memory.buffer);
                        return U8.set(bufview, ptr), ptr;
                    }
                    function __getString(ptr) {
                        if (!ptr) return null;
                        const buffer = memory.buffer, id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];
                        if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);
                        return getStringImpl(buffer, ptr);
                    }
                    function getView(alignLog2, signed, float) {
                        const buffer = memory.buffer;
                        if (float) switch(alignLog2){
                            case 2:
                                return new Float32Array(buffer);
                            case 3:
                                return new Float64Array(buffer);
                        }
                        else switch(alignLog2){
                            case 0:
                                return new (signed ? Int8Array : Uint8Array)(buffer);
                            case 1:
                                return new (signed ? Int16Array : Uint16Array)(buffer);
                            case 2:
                                return new (signed ? Int32Array : Uint32Array)(buffer);
                            case 3:
                                return new (signed ? BigInt64Array : BigUint64Array)(buffer);
                        }
                        throw Error(`unsupported align: ${alignLog2}`);
                    }
                    function __newArray(id, valuesOrCapacity = 0) {
                        const input = valuesOrCapacity, info = getArrayInfo(id), align = getValueAlign(info), isArrayLike = "number" != typeof input, length = isArrayLike ? input.length : input, buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);
                        let result;
                        if (info & STATICARRAY) result = buf;
                        else {
                            __pin(buf);
                            const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
                            __unpin(buf);
                            const U32 = new Uint32Array(memory.buffer);
                            U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf, U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf, U32[arr + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET >>> 2] = length << align, info & ARRAY && (U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length), result = arr;
                        }
                        if (isArrayLike) {
                            const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT), start = buf >>> align;
                            if (info & VAL_MANAGED) for(let i = 0; i < length; ++i)view[start + i] = input[i];
                            else view.set(input, start);
                        }
                        return result;
                    }
                    function __getArrayView(arr) {
                        const U32 = new Uint32Array(memory.buffer), id = U32[arr + ID_OFFSET >>> 2], info = getArrayInfo(id), align = getValueAlign(info);
                        let buf = info & STATICARRAY ? arr : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
                        const length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;
                        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);
                    }
                    function __getArray(arr) {
                        const input = __getArrayView(arr), len = input.length, out = Array(len);
                        for(let i = 0; i < len; i++)out[i] = input[i];
                        return out;
                    }
                    function __getArrayBuffer(ptr) {
                        const buffer = memory.buffer, length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];
                        return buffer.slice(ptr, ptr + length);
                    }
                    function __getFunction(ptr) {
                        if (!table) throw Error(E_NO_EXPORT_TABLE);
                        const index = new Uint32Array(memory.buffer)[ptr >>> 2];
                        return table.get(index);
                    }
                    function getTypedArray(Type, alignLog2, ptr) {
                        return new Type(getTypedArrayView(Type, alignLog2, ptr));
                    }
                    function getTypedArrayView(Type, alignLog2, ptr) {
                        const buffer = memory.buffer, U32 = new Uint32Array(buffer);
                        return new Type(buffer, U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2], U32[ptr + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET >>> 2] >>> alignLog2);
                    }
                    function attachTypedArrayFunctions(ctor, name, align) {
                        extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align), extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);
                    }
                    function __instanceof(ptr, baseId) {
                        const U32 = new Uint32Array(memory.buffer);
                        let id = U32[ptr + ID_OFFSET >>> 2];
                        if (id <= getRttiCount(U32)) do {
                            if (id == baseId) return !0;
                            id = getRttBase(id);
                        }while (id)
                        return !1;
                    }
                    return extendedExports.__new = __new, extendedExports.__pin = __pin, extendedExports.__unpin = __unpin, extendedExports.__collect = __collect, extendedExports.__newString = __newString, extendedExports.__newArrayBuffer = __newArrayBuffer, extendedExports.__getString = __getString, extendedExports.__newArray = __newArray, extendedExports.__getArrayView = __getArrayView, extendedExports.__getArray = __getArray, extendedExports.__getArrayBuffer = __getArrayBuffer, extendedExports.__getFunction = __getFunction, [
                        Int8Array,
                        Uint8Array,
                        Uint8ClampedArray,
                        Int16Array,
                        Uint16Array,
                        Int32Array,
                        Uint32Array,
                        Float32Array,
                        Float64Array
                    ].forEach((ctor)=>{
                        attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));
                    }), BIGINT && [
                        BigUint64Array,
                        BigInt64Array
                    ].forEach((ctor)=>{
                        attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);
                    }), extendedExports.__instanceof = __instanceof, extendedExports.memory = extendedExports.memory || memory, extendedExports.table = extendedExports.table || table, demangle(exports, extendedExports);
                }
                function isResponse(src) {
                    return "undefined" != typeof Response && src instanceof Response;
                }
                function isModule(src) {
                    return src instanceof WebAssembly.Module;
                }
                async function instantiate(source, imports = {}) {
                    if (isResponse(source = await source)) return instantiateStreaming(source, imports);
                    const module = isModule(source) ? source : await WebAssembly.compile(source), extended = preInstantiate(imports), instance = await WebAssembly.instantiate(module, imports), exports = postInstantiate(extended, instance);
                    return {
                        module,
                        instance,
                        exports
                    };
                }
                function instantiateSync(source, imports = {}) {
                    const module = isModule(source) ? source : new WebAssembly.Module(source), extended = preInstantiate(imports), instance = new WebAssembly.Instance(module, imports), exports = postInstantiate(extended, instance);
                    return {
                        module,
                        instance,
                        exports
                    };
                }
                async function instantiateStreaming(source, imports = {}) {
                    if (!WebAssembly.instantiateStreaming) return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);
                    const extended = preInstantiate(imports), result = await WebAssembly.instantiateStreaming(source, imports), exports = postInstantiate(extended, result.instance);
                    return {
                        ...result,
                        exports
                    };
                }
                function demangle(exports, extendedExports = {}) {
                    const setArgumentsLength = exports.__argumentsLength ? (length)=>{
                        exports.__argumentsLength.value = length;
                    } : exports.__setArgumentsLength || exports.__setargc || (()=>{});
                    for (let internalName of Object.keys(exports)){
                        const elem = exports[internalName];
                        let parts = internalName.split("."), curr = extendedExports;
                        for(; parts.length > 1;){
                            let part = parts.shift();
                            Object.hasOwn(curr, part) || (curr[part] = {}), curr = curr[part];
                        }
                        let name = parts[0], hash = name.indexOf("#");
                        if (hash >= 0) {
                            const className = name.substring(0, hash), classElem = curr[className];
                            if (void 0 === classElem || !classElem.prototype) {
                                const ctor = function(...args) {
                                    return ctor.wrap(ctor.prototype.constructor(0, ...args));
                                };
                                ctor.prototype = {
                                    valueOf () {
                                        return this[THIS];
                                    }
                                }, ctor.wrap = function(thisValue) {
                                    return Object.create(ctor.prototype, {
                                        [THIS]: {
                                            value: thisValue,
                                            writable: !1
                                        }
                                    });
                                }, classElem && Object.getOwnPropertyNames(classElem).forEach((name)=>Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))), curr[className] = ctor;
                            }
                            if (name = name.substring(hash + 1), curr = curr[className].prototype, /^(get|set):/.test(name)) {
                                if (!Object.hasOwn(curr, name = name.substring(4))) {
                                    let getter = exports[internalName.replace("set:", "get:")], setter = exports[internalName.replace("get:", "set:")];
                                    Object.defineProperty(curr, name, {
                                        get () {
                                            return getter(this[THIS]);
                                        },
                                        set (value) {
                                            setter(this[THIS], value);
                                        },
                                        enumerable: !0
                                    });
                                }
                            } else 'constructor' === name ? (curr[name] = function(...args) {
                                return setArgumentsLength(args.length), elem(...args);
                            }).original = elem : (curr[name] = function(...args) {
                                return setArgumentsLength(args.length), elem(this[THIS], ...args);
                            }).original = elem;
                        } else /^(get|set):/.test(name) ? Object.hasOwn(curr, name = name.substring(4)) || Object.defineProperty(curr, name, {
                            get: exports[internalName.replace("set:", "get:")],
                            set: exports[internalName.replace("get:", "set:")],
                            enumerable: !0
                        }) : "function" == typeof elem && elem !== setArgumentsLength ? (curr[name] = (...args)=>(setArgumentsLength(args.length), elem(...args))).original = elem : curr[name] = elem;
                    }
                    return extendedExports;
                }
                Object.hasOwn = Object.hasOwn || function(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                };
                var _default = {
                    instantiate,
                    instantiateSync,
                    instantiateStreaming,
                    demangle
                };
                return exports.default = _default, "default" in exports ? exports.default : exports;
            }({});
            void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                return loader;
            }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__ = [])) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        },
        3083: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var possibleNames = [
                'BigInt64Array',
                'BigUint64Array',
                'Float32Array',
                'Float64Array',
                'Int16Array',
                'Int32Array',
                'Int8Array',
                'Uint16Array',
                'Uint32Array',
                'Uint8Array',
                'Uint8ClampedArray'
            ], g = 'undefined' == typeof globalThis ? __webpack_require__.g : globalThis;
            module.exports = function() {
                for(var out = [], i = 0; i < possibleNames.length; i++)'function' == typeof g[possibleNames[i]] && (out[out.length] = possibleNames[i]);
                return out;
            };
        },
        882: function(module, __unused_webpack_exports, __webpack_require__) {
            "use strict";
            var $gOPD = __webpack_require__(210)('%Object.getOwnPropertyDescriptor%', !0);
            if ($gOPD) try {
                $gOPD([], 'length');
            } catch (e) {
                $gOPD = null;
            }
            module.exports = $gOPD;
        },
        7568: function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
            "use strict";
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                    var info = gen[key](arg), value = info.value;
                } catch (error) {
                    reject(error);
                    return;
                }
                info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
            }
            function _asyncToGenerator(fn) {
                return function() {
                    var self1 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                        var gen = fn.apply(self1, args);
                        function _next(value) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                        }
                        function _throw(err) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                        }
                        _next(void 0);
                    });
                };
            }
            __webpack_require__.d(__webpack_exports__, {
                Z: function() {
                    return _asyncToGenerator;
                }
            });
        },
        9396: function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
            "use strict";
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    enumerableOnly && (symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    })), keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpreadProps(target, source) {
                return source = null != source ? source : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                }), target;
            }
            __webpack_require__.d(__webpack_exports__, {
                Z: function() {
                    return _objectSpreadProps;
                }
            });
        },
        8597: function(module) {
            "use strict";
            module.exports = {
                i8: "6.5.4"
            };
        },
        2454: function(module) {
            "use strict";
            module.exports = JSON.parse('{"O_RDONLY":0,"O_WRONLY":1,"O_RDWR":2,"S_IFMT":61440,"S_IFREG":32768,"S_IFDIR":16384,"S_IFCHR":8192,"S_IFBLK":24576,"S_IFIFO":4096,"S_IFLNK":40960,"S_IFSOCK":49152,"O_CREAT":512,"O_EXCL":2048,"O_NOCTTY":131072,"O_TRUNC":1024,"O_APPEND":8,"O_DIRECTORY":1048576,"O_NOFOLLOW":256,"O_SYNC":128,"O_SYMLINK":2097152,"O_NONBLOCK":4,"S_IRWXU":448,"S_IRUSR":256,"S_IWUSR":128,"S_IXUSR":64,"S_IRWXG":56,"S_IRGRP":32,"S_IWGRP":16,"S_IXGRP":8,"S_IRWXO":7,"S_IROTH":4,"S_IWOTH":2,"S_IXOTH":1,"E2BIG":7,"EACCES":13,"EADDRINUSE":48,"EADDRNOTAVAIL":49,"EAFNOSUPPORT":47,"EAGAIN":35,"EALREADY":37,"EBADF":9,"EBADMSG":94,"EBUSY":16,"ECANCELED":89,"ECHILD":10,"ECONNABORTED":53,"ECONNREFUSED":61,"ECONNRESET":54,"EDEADLK":11,"EDESTADDRREQ":39,"EDOM":33,"EDQUOT":69,"EEXIST":17,"EFAULT":14,"EFBIG":27,"EHOSTUNREACH":65,"EIDRM":90,"EILSEQ":92,"EINPROGRESS":36,"EINTR":4,"EINVAL":22,"EIO":5,"EISCONN":56,"EISDIR":21,"ELOOP":62,"EMFILE":24,"EMLINK":31,"EMSGSIZE":40,"EMULTIHOP":95,"ENAMETOOLONG":63,"ENETDOWN":50,"ENETRESET":52,"ENETUNREACH":51,"ENFILE":23,"ENOBUFS":55,"ENODATA":96,"ENODEV":19,"ENOENT":2,"ENOEXEC":8,"ENOLCK":77,"ENOLINK":97,"ENOMEM":12,"ENOMSG":91,"ENOPROTOOPT":42,"ENOSPC":28,"ENOSR":98,"ENOSTR":99,"ENOSYS":78,"ENOTCONN":57,"ENOTDIR":20,"ENOTEMPTY":66,"ENOTSOCK":38,"ENOTSUP":45,"ENOTTY":25,"ENXIO":6,"EOPNOTSUPP":102,"EOVERFLOW":84,"EPERM":1,"EPIPE":32,"EPROTO":100,"EPROTONOSUPPORT":43,"EPROTOTYPE":41,"ERANGE":34,"EROFS":30,"ESPIPE":29,"ESRCH":3,"ESTALE":70,"ETIME":101,"ETIMEDOUT":60,"ETXTBSY":26,"EWOULDBLOCK":35,"EXDEV":18,"SIGHUP":1,"SIGINT":2,"SIGQUIT":3,"SIGILL":4,"SIGTRAP":5,"SIGABRT":6,"SIGIOT":6,"SIGBUS":10,"SIGFPE":8,"SIGKILL":9,"SIGUSR1":30,"SIGSEGV":11,"SIGUSR2":31,"SIGPIPE":13,"SIGALRM":14,"SIGTERM":15,"SIGCHLD":20,"SIGCONT":19,"SIGSTOP":17,"SIGTSTP":18,"SIGTTIN":21,"SIGTTOU":22,"SIGURG":16,"SIGXCPU":24,"SIGXFSZ":25,"SIGVTALRM":26,"SIGPROF":27,"SIGWINCH":28,"SIGIO":23,"SIGSYS":12,"SSL_OP_ALL":2147486719,"SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION":262144,"SSL_OP_CIPHER_SERVER_PREFERENCE":4194304,"SSL_OP_CISCO_ANYCONNECT":32768,"SSL_OP_COOKIE_EXCHANGE":8192,"SSL_OP_CRYPTOPRO_TLSEXT_BUG":2147483648,"SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS":2048,"SSL_OP_EPHEMERAL_RSA":0,"SSL_OP_LEGACY_SERVER_CONNECT":4,"SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER":32,"SSL_OP_MICROSOFT_SESS_ID_BUG":1,"SSL_OP_MSIE_SSLV2_RSA_PADDING":0,"SSL_OP_NETSCAPE_CA_DN_BUG":536870912,"SSL_OP_NETSCAPE_CHALLENGE_BUG":2,"SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG":1073741824,"SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG":8,"SSL_OP_NO_COMPRESSION":131072,"SSL_OP_NO_QUERY_MTU":4096,"SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION":65536,"SSL_OP_NO_SSLv2":16777216,"SSL_OP_NO_SSLv3":33554432,"SSL_OP_NO_TICKET":16384,"SSL_OP_NO_TLSv1":67108864,"SSL_OP_NO_TLSv1_1":268435456,"SSL_OP_NO_TLSv1_2":134217728,"SSL_OP_PKCS1_CHECK_1":0,"SSL_OP_PKCS1_CHECK_2":0,"SSL_OP_SINGLE_DH_USE":1048576,"SSL_OP_SINGLE_ECDH_USE":524288,"SSL_OP_SSLEAY_080_CLIENT_DH_BUG":128,"SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG":0,"SSL_OP_TLS_BLOCK_PADDING_BUG":512,"SSL_OP_TLS_D5_BUG":256,"SSL_OP_TLS_ROLLBACK_BUG":8388608,"ENGINE_METHOD_DSA":2,"ENGINE_METHOD_DH":4,"ENGINE_METHOD_RAND":8,"ENGINE_METHOD_ECDH":16,"ENGINE_METHOD_ECDSA":32,"ENGINE_METHOD_CIPHERS":64,"ENGINE_METHOD_DIGESTS":128,"ENGINE_METHOD_STORE":256,"ENGINE_METHOD_PKEY_METHS":512,"ENGINE_METHOD_PKEY_ASN1_METHS":1024,"ENGINE_METHOD_ALL":65535,"ENGINE_METHOD_NONE":0,"DH_CHECK_P_NOT_SAFE_PRIME":2,"DH_CHECK_P_NOT_PRIME":1,"DH_UNABLE_TO_CHECK_GENERATOR":4,"DH_NOT_SUITABLE_GENERATOR":8,"NPN_ENABLED":1,"RSA_PKCS1_PADDING":1,"RSA_SSLV23_PADDING":2,"RSA_NO_PADDING":3,"RSA_PKCS1_OAEP_PADDING":4,"RSA_X931_PADDING":5,"RSA_PKCS1_PSS_PADDING":6,"POINT_CONVERSION_COMPRESSED":2,"POINT_CONVERSION_UNCOMPRESSED":4,"POINT_CONVERSION_HYBRID":6,"F_OK":0,"R_OK":4,"W_OK":2,"X_OK":1,"UV_UDP_REUSEADDR":4}');
        },
        8575: function(module) {
            "use strict";
            module.exports = JSON.parse('{"block":"block_type","loop":"block_type","if":"block_type","br":"varuint32","br_if":"varuint32","br_table":"br_table","call":"varuint32","call_indirect":"call_indirect","get_local":"varuint32","set_local":"varuint32","tee_local":"varuint32","get_global":"varuint32","set_global":"varuint32","load":"memory_immediate","load8_s":"memory_immediate","load8_u":"memory_immediate","load16_s":"memory_immediate","load16_u":"memory_immediate","load32_s":"memory_immediate","load32_u":"memory_immediate","store":"memory_immediate","store8":"memory_immediate","store16":"memory_immediate","store32":"memory_immediate","current_memory":"varuint1","grow_memory":"varuint1","i32":"varint32","i64":"varint64","f32":"uint32","f64":"uint64"}');
        },
        5936: function(module) {
            "use strict";
            module.exports = JSON.parse('{"start":0,"type":{"params":{"DEFAULT":0},"return_type":{"DEFAULT":0}},"import":0,"code":{"locals":{"DEFAULT":1},"code":{"get_local":120,"set_local":120,"tee_local":120,"get_global":120,"set_global":120,"load8_s":120,"load8_u":120,"load16_s":120,"load16_u":120,"load32_s":120,"load32_u":120,"load":120,"store8":120,"store16":120,"store32":120,"store":120,"grow_memory":10000,"current_memory":100,"nop":1,"block":1,"loop":1,"if":1,"then":90,"else":90,"br":90,"br_if":90,"br_table":120,"return":90,"call":90,"call_indirect":10000,"const":1,"add":45,"sub":45,"mul":45,"div_s":36000,"div_u":36000,"rem_s":36000,"rem_u":36000,"and":45,"or":45,"xor":45,"shl":67,"shr_u":67,"shr_s":67,"rotl":90,"rotr":90,"eq":45,"eqz":45,"ne":45,"lt_s":45,"lt_u":45,"le_s":45,"le_u":45,"gt_s":45,"gt_u":45,"ge_s":45,"ge_u":45,"clz":45,"ctz":45,"popcnt":45,"drop":120,"select":120,"unreachable":1}},"data":0}');
        }
    }
]);
