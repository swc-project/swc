(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [
        514
    ],
    {
        8161: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const elliptic1 = __webpack_require__1(6266), BN1 = __webpack_require__1(3783), { sha256: sha2561  } = __webpack_require__1(2023), { sha512: sha5121  } = __webpack_require__1(3434), EC1 = new elliptic1.ec('secp256k1');
            function toBytesInt321(num1) {
                return new Uint8Array([
                    (0xff000000 & num1) >> 24,
                    (0x00ff0000 & num1) >> 16,
                    (0x0000ff00 & num1) >> 8,
                    0x000000ff & num1
                ]);
            }
            const one1 = new BN1(1);
            function Unmarshal1(data1) {
                const byteLen1 = EC1.n.bitLength() + 7 >> 3;
                if (EC1.g.mul(10), (-2 & data1[0]) != 2 || data1.length != 1 + byteLen1) return [
                    null,
                    null
                ];
                const tx1 = new BN1(data1.slice(1, 1 + byteLen1));
                try {
                    const p3 = EC1.curve.pointFromX(tx1);
                    return [
                        p3.x,
                        p3.y
                    ];
                } catch (e1) {
                    return [
                        null,
                        null
                    ];
                }
            }
            function H11(m1) {
                let x3 = null, y3 = null;
                const byteLen1 = EC1.n.bitLength() + 7 >> 3;
                let i2 = 0;
                for(; null == x3 && i2 < 100;){
                    const res1 = sha5121.array(new Uint8Array([
                        ...toBytesInt321(i2),
                        ...m1
                    ])), r3 = [
                        2,
                        ...res1
                    ];
                    [x3, y3] = Unmarshal1(r3.slice(0, byteLen1 + 1)), i2++;
                }
                return EC1.curve.point(x3, y3);
            }
            function H21(m1) {
                const byteLen1 = EC1.n.bitLength() + 7 >> 3;
                let i2 = 0;
                for(;;){
                    const res1 = sha5121.array(new Uint8Array([
                        ...toBytesInt321(i2),
                        ...m1
                    ])), k3 = new BN1(res1.slice(0, byteLen1));
                    if (-1 == k3.cmp(EC1.curve.n.sub(one1))) return k3.add(one1);
                    i2++;
                }
            }
            function Evaluate1(privateKey1, m1) {
                const currentKey1 = EC1.keyFromPrivate(privateKey1), r3 = EC1.genKeyPair(), rBN1 = r3.getPrivate(), pointH1 = H11(m1), point1 = pointH1.mul(privateKey1), vrf1 = point1.encode(), rgPoint1 = EC1.curve.g.mul(rBN1), rhPoint1 = pointH1.mul(rBN1), b10 = [
                    ...EC1.curve.g.encode(),
                    ...pointH1.encode(),
                    ...currentKey1.getPublic().encode(),
                    ...vrf1,
                    ...rgPoint1.encode(),
                    ...rhPoint1.encode()
                ], s3 = H21(b10), t3 = rBN1.sub(s3.mul(currentKey1.getPrivate())).umod(EC1.curve.n), index1 = sha2561.array(new Uint8Array(vrf1)), buf1 = [
                    ...Array(32 - s3.byteLength()).fill(0),
                    ...s3.toArray(),
                    ...Array(32 - t3.byteLength()).fill(0),
                    ...t3.toArray(),
                    ...vrf1
                ];
                return [
                    index1,
                    buf1
                ];
            }
            function ProofHoHash1(publicKey1, data1, proof1) {
                const currentKey1 = EC1.keyFromPublic(publicKey1);
                if (129 !== proof1.length) throw Error('invalid vrf');
                const s3 = proof1.slice(0, 32), t3 = proof1.slice(32, 64), vrf1 = proof1.slice(64, 129), uhPoint1 = decodePoint1(vrf1);
                if (!uhPoint1) throw Error('invalid vrf');
                const tgPoint1 = EC1.curve.g.mul(t3), ksgPoint1 = currentKey1.getPublic().mul(s3), tksgPoint1 = tgPoint1.add(ksgPoint1), hPoint1 = H11(data1), thPoint1 = hPoint1.mul(t3), shPoint1 = uhPoint1.mul(s3), tkshPoint1 = thPoint1.add(shPoint1), b10 = [
                    ...EC1.curve.g.encode(),
                    ...hPoint1.encode(),
                    ...currentKey1.getPublic().encode(),
                    ...vrf1,
                    ...tksgPoint1.encode(),
                    ...tkshPoint1.encode()
                ], h21 = H21(b10), buf1 = [
                    ...Array(32 - h21.byteLength()).fill(0),
                    ...h21.toArray()
                ];
                let equal1 = !0;
                for(let i2 = 0; i2 < buf1.length; i2++)s3[i2] !== buf1[i2] && (equal1 = !1);
                if (!equal1) throw Error('invalid vrf');
                return sha2561.array(new Uint8Array(vrf1));
            }
            function decodePoint1(data1) {
                try {
                    return EC1.curve.decodePoint(data1);
                } catch  {
                    return null;
                }
            }
            module1.exports = {
                Evaluate: Evaluate1,
                ProofHoHash: ProofHoHash1
            };
        },
        3783: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            !function(module1, exports1) {
                'use strict';
                function assert1(val1, msg1) {
                    if (!val1) throw Error(msg1 || 'Assertion failed');
                }
                function inherits1(ctor1, superCtor1) {
                    ctor1.super_ = superCtor1;
                    var TempCtor1 = function() {};
                    TempCtor1.prototype = superCtor1.prototype, ctor1.prototype = new TempCtor1(), ctor1.prototype.constructor = ctor1;
                }
                function BN1(number1, base1, endian1) {
                    if (BN1.isBN(number1)) return number1;
                    this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== number1 && (('le' === base1 || 'be' === base1) && (endian1 = base1, base1 = 10), this._init(number1 || 0, base1 || 10, endian1 || 'be'));
                }
                'object' == typeof module1 ? module1.exports = BN1 : exports1.BN = BN1, BN1.BN = BN1, BN1.wordSize = 26;
                try {
                    Buffer1 = 'undefined' != typeof window && void 0 !== window.Buffer ? window.Buffer : __webpack_require__1(136).Buffer;
                } catch (e1) {}
                function parseHex4Bits1(string1, index1) {
                    var c5 = string1.charCodeAt(index1);
                    return c5 >= 48 && c5 <= 57 ? c5 - 48 : c5 >= 65 && c5 <= 70 ? c5 - 55 : c5 >= 97 && c5 <= 102 ? c5 - 87 : void assert1(!1, 'Invalid character in ' + string1);
                }
                function parseHexByte1(string1, lowerBound1, index1) {
                    var r3 = parseHex4Bits1(string1, index1);
                    return index1 - 1 >= lowerBound1 && (r3 |= parseHex4Bits1(string1, index1 - 1) << 4), r3;
                }
                function parseBase1(str1, start1, end1, mul1) {
                    for(var r3 = 0, b10 = 0, len3 = Math.min(str1.length, end1), i2 = start1; i2 < len3; i2++){
                        var c5 = str1.charCodeAt(i2) - 48;
                        r3 *= mul1, b10 = c5 >= 49 ? c5 - 49 + 0xa : c5 >= 17 ? c5 - 17 + 0xa : c5, assert1(c5 >= 0 && b10 < mul1, 'Invalid character'), r3 += b10;
                    }
                    return r3;
                }
                function move1(dest1, src1) {
                    dest1.words = src1.words, dest1.length = src1.length, dest1.negative = src1.negative, dest1.red = src1.red;
                }
                if (BN1.isBN = function(num1) {
                    return num1 instanceof BN1 || null !== num1 && 'object' == typeof num1 && num1.constructor.wordSize === BN1.wordSize && Array.isArray(num1.words);
                }, BN1.max = function(left1, right1) {
                    return left1.cmp(right1) > 0 ? left1 : right1;
                }, BN1.min = function(left1, right1) {
                    return 0 > left1.cmp(right1) ? left1 : right1;
                }, BN1.prototype._init = function(number1, base1, endian1) {
                    if ('number' == typeof number1) return this._initNumber(number1, base1, endian1);
                    if ('object' == typeof number1) return this._initArray(number1, base1, endian1);
                    'hex' === base1 && (base1 = 16), assert1(base1 === (0 | base1) && base1 >= 2 && base1 <= 36);
                    var start1 = 0;
                    '-' === (number1 = number1.toString().replace(/\s+/g, ''))[0] && (start1++, this.negative = 1), start1 < number1.length && (16 === base1 ? this._parseHex(number1, start1, endian1) : (this._parseBase(number1, base1, start1), 'le' === endian1 && this._initArray(this.toArray(), base1, endian1)));
                }, BN1.prototype._initNumber = function(number1, base1, endian1) {
                    number1 < 0 && (this.negative = 1, number1 = -number1), number1 < 0x4000000 ? (this.words = [
                        0x3ffffff & number1
                    ], this.length = 1) : number1 < 0x10000000000000 ? (this.words = [
                        0x3ffffff & number1,
                        number1 / 0x4000000 & 0x3ffffff
                    ], this.length = 2) : (assert1(number1 < 0x20000000000000), this.words = [
                        0x3ffffff & number1,
                        number1 / 0x4000000 & 0x3ffffff,
                        1
                    ], this.length = 3), 'le' === endian1 && this._initArray(this.toArray(), base1, endian1);
                }, BN1.prototype._initArray = function(number1, base1, endian1) {
                    if (assert1('number' == typeof number1.length), number1.length <= 0) return this.words = [
                        0
                    ], this.length = 1, this;
                    this.length = Math.ceil(number1.length / 3), this.words = Array(this.length);
                    for(var j1, w19, i2 = 0; i2 < this.length; i2++)this.words[i2] = 0;
                    var off1 = 0;
                    if ('be' === endian1) for(i2 = number1.length - 1, j1 = 0; i2 >= 0; i2 -= 3)w19 = number1[i2] | number1[i2 - 1] << 8 | number1[i2 - 2] << 16, this.words[j1] |= w19 << off1 & 0x3ffffff, this.words[j1 + 1] = w19 >>> 26 - off1 & 0x3ffffff, (off1 += 24) >= 26 && (off1 -= 26, j1++);
                    else if ('le' === endian1) for(i2 = 0, j1 = 0; i2 < number1.length; i2 += 3)w19 = number1[i2] | number1[i2 + 1] << 8 | number1[i2 + 2] << 16, this.words[j1] |= w19 << off1 & 0x3ffffff, this.words[j1 + 1] = w19 >>> 26 - off1 & 0x3ffffff, (off1 += 24) >= 26 && (off1 -= 26, j1++);
                    return this._strip();
                }, BN1.prototype._parseHex = function(number1, start1, endian1) {
                    this.length = Math.ceil((number1.length - start1) / 6), this.words = Array(this.length);
                    for(var w19, i2 = 0; i2 < this.length; i2++)this.words[i2] = 0;
                    var off1 = 0, j1 = 0;
                    if ('be' === endian1) for(i2 = number1.length - 1; i2 >= start1; i2 -= 2)w19 = parseHexByte1(number1, start1, i2) << off1, this.words[j1] |= 0x3ffffff & w19, off1 >= 18 ? (off1 -= 18, j1 += 1, this.words[j1] |= w19 >>> 26) : off1 += 8;
                    else for(i2 = (number1.length - start1) % 2 == 0 ? start1 + 1 : start1; i2 < number1.length; i2 += 2)w19 = parseHexByte1(number1, start1, i2) << off1, this.words[j1] |= 0x3ffffff & w19, off1 >= 18 ? (off1 -= 18, j1 += 1, this.words[j1] |= w19 >>> 26) : off1 += 8;
                    this._strip();
                }, BN1.prototype._parseBase = function(number1, base1, start1) {
                    this.words = [
                        0
                    ], this.length = 1;
                    for(var limbLen1 = 0, limbPow1 = 1; limbPow1 <= 0x3ffffff; limbPow1 *= base1)limbLen1++;
                    limbLen1--, limbPow1 = limbPow1 / base1 | 0;
                    for(var total1 = number1.length - start1, mod1 = total1 % limbLen1, end1 = Math.min(total1, total1 - mod1) + start1, word1 = 0, i2 = start1; i2 < end1; i2 += limbLen1)word1 = parseBase1(number1, i2, i2 + limbLen1, base1), this.imuln(limbPow1), this.words[0] + word1 < 0x4000000 ? this.words[0] += word1 : this._iaddn(word1);
                    if (0 !== mod1) {
                        var pow1 = 1;
                        for(word1 = parseBase1(number1, i2, number1.length, base1), i2 = 0; i2 < mod1; i2++)pow1 *= base1;
                        this.imuln(pow1), this.words[0] + word1 < 0x4000000 ? this.words[0] += word1 : this._iaddn(word1);
                    }
                    this._strip();
                }, BN1.prototype.copy = function(dest1) {
                    dest1.words = Array(this.length);
                    for(var i2 = 0; i2 < this.length; i2++)dest1.words[i2] = this.words[i2];
                    dest1.length = this.length, dest1.negative = this.negative, dest1.red = this.red;
                }, BN1.prototype._move = function(dest1) {
                    move1(dest1, this);
                }, BN1.prototype.clone = function() {
                    var r3 = new BN1(null);
                    return this.copy(r3), r3;
                }, BN1.prototype._expand = function(size1) {
                    for(; this.length < size1;)this.words[this.length++] = 0;
                    return this;
                }, BN1.prototype._strip = function() {
                    for(; this.length > 1 && 0 === this.words[this.length - 1];)this.length--;
                    return this._normSign();
                }, BN1.prototype._normSign = function() {
                    return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
                }, 'undefined' != typeof Symbol && 'function' == typeof Symbol.for) try {
                    BN1.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect1;
                } catch (e1) {
                    BN1.prototype.inspect = inspect1;
                }
                else BN1.prototype.inspect = inspect1;
                function inspect1() {
                    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
                }
                var Buffer1, zeros1 = [
                    '',
                    '0',
                    '00',
                    '000',
                    '0000',
                    '00000',
                    '000000',
                    '0000000',
                    '00000000',
                    '000000000',
                    '0000000000',
                    '00000000000',
                    '000000000000',
                    '0000000000000',
                    '00000000000000',
                    '000000000000000',
                    '0000000000000000',
                    '00000000000000000',
                    '000000000000000000',
                    '0000000000000000000',
                    '00000000000000000000',
                    '000000000000000000000',
                    '0000000000000000000000',
                    '00000000000000000000000',
                    '000000000000000000000000',
                    '0000000000000000000000000'
                ], groupSizes1 = [
                    0,
                    0,
                    25,
                    16,
                    12,
                    11,
                    10,
                    9,
                    8,
                    8,
                    7,
                    7,
                    7,
                    7,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ], groupBases1 = [
                    0,
                    0,
                    33554432,
                    43046721,
                    16777216,
                    48828125,
                    60466176,
                    40353607,
                    16777216,
                    43046721,
                    10000000,
                    19487171,
                    35831808,
                    62748517,
                    7529536,
                    11390625,
                    16777216,
                    24137569,
                    34012224,
                    47045881,
                    64000000,
                    4084101,
                    5153632,
                    6436343,
                    7962624,
                    9765625,
                    11881376,
                    14348907,
                    17210368,
                    20511149,
                    24300000,
                    28629151,
                    33554432,
                    39135393,
                    45435424,
                    52521875,
                    60466176
                ];
                BN1.prototype.toString = function(base1, padding1) {
                    if (padding1 = 0 | padding1 || 1, 16 === (base1 = base1 || 10) || 'hex' === base1) {
                        out1 = '';
                        for(var out1, off1 = 0, carry1 = 0, i2 = 0; i2 < this.length; i2++){
                            var w19 = this.words[i2], word1 = ((w19 << off1 | carry1) & 0xffffff).toString(16);
                            carry1 = w19 >>> 24 - off1 & 0xffffff, (off1 += 2) >= 26 && (off1 -= 26, i2--), out1 = 0 !== carry1 || i2 !== this.length - 1 ? zeros1[6 - word1.length] + word1 + out1 : word1 + out1;
                        }
                        for(0 !== carry1 && (out1 = carry1.toString(16) + out1); out1.length % padding1 != 0;)out1 = '0' + out1;
                        return 0 !== this.negative && (out1 = '-' + out1), out1;
                    }
                    if (base1 === (0 | base1) && base1 >= 2 && base1 <= 36) {
                        var groupSize1 = groupSizes1[base1], groupBase1 = groupBases1[base1];
                        out1 = '';
                        var c5 = this.clone();
                        for(c5.negative = 0; !c5.isZero();){
                            var r3 = c5.modrn(groupBase1).toString(base1);
                            out1 = (c5 = c5.idivn(groupBase1)).isZero() ? r3 + out1 : zeros1[groupSize1 - r3.length] + r3 + out1;
                        }
                        for(this.isZero() && (out1 = '0' + out1); out1.length % padding1 != 0;)out1 = '0' + out1;
                        return 0 !== this.negative && (out1 = '-' + out1), out1;
                    }
                    assert1(!1, 'Base should be between 2 and 36');
                }, BN1.prototype.toNumber = function() {
                    var ret1 = this.words[0];
                    return 2 === this.length ? ret1 += 0x4000000 * this.words[1] : 3 === this.length && 0x01 === this.words[2] ? ret1 += 0x10000000000000 + 0x4000000 * this.words[1] : this.length > 2 && assert1(!1, 'Number can only safely store up to 53 bits'), 0 !== this.negative ? -ret1 : ret1;
                }, BN1.prototype.toJSON = function() {
                    return this.toString(16, 2);
                }, Buffer1 && (BN1.prototype.toBuffer = function(endian1, length1) {
                    return this.toArrayLike(Buffer1, endian1, length1);
                }), BN1.prototype.toArray = function(endian1, length1) {
                    return this.toArrayLike(Array, endian1, length1);
                };
                var allocate1 = function(ArrayType1, size1) {
                    return ArrayType1.allocUnsafe ? ArrayType1.allocUnsafe(size1) : new ArrayType1(size1);
                };
                function toBitArray1(num1) {
                    for(var w19 = Array(num1.bitLength()), bit1 = 0; bit1 < w19.length; bit1++){
                        var off1 = bit1 / 26 | 0, wbit1 = bit1 % 26;
                        w19[bit1] = num1.words[off1] >>> wbit1 & 0x01;
                    }
                    return w19;
                }
                function smallMulTo1(self1, num1, out1) {
                    out1.negative = num1.negative ^ self1.negative;
                    var len3 = self1.length + num1.length | 0;
                    out1.length = len3, len3 = len3 - 1 | 0;
                    var a10 = 0 | self1.words[0], b10 = 0 | num1.words[0], r3 = a10 * b10, lo1 = 0x3ffffff & r3, carry1 = r3 / 0x4000000 | 0;
                    out1.words[0] = lo1;
                    for(var k3 = 1; k3 < len3; k3++){
                        for(var ncarry1 = carry1 >>> 26, rword1 = 0x3ffffff & carry1, maxJ1 = Math.min(k3, num1.length - 1), j1 = Math.max(0, k3 - self1.length + 1); j1 <= maxJ1; j1++){
                            var i2 = k3 - j1 | 0;
                            ncarry1 += (r3 = (a10 = 0 | self1.words[i2]) * (b10 = 0 | num1.words[j1]) + rword1) / 0x4000000 | 0, rword1 = 0x3ffffff & r3;
                        }
                        out1.words[k3] = 0 | rword1, carry1 = 0 | ncarry1;
                    }
                    return 0 !== carry1 ? out1.words[k3] = 0 | carry1 : out1.length--, out1._strip();
                }
                BN1.prototype.toArrayLike = function(ArrayType1, endian1, length1) {
                    this._strip();
                    var byteLength1 = this.byteLength(), reqLength1 = length1 || Math.max(1, byteLength1);
                    assert1(byteLength1 <= reqLength1, 'byte array longer than desired length'), assert1(reqLength1 > 0, 'Requested array length <= 0');
                    var res1 = allocate1(ArrayType1, reqLength1);
                    return this['_toArrayLike' + ('le' === endian1 ? 'LE' : 'BE')](res1, byteLength1), res1;
                }, BN1.prototype._toArrayLikeLE = function(res1, byteLength1) {
                    for(var position1 = 0, carry1 = 0, i2 = 0, shift1 = 0; i2 < this.length; i2++){
                        var word1 = this.words[i2] << shift1 | carry1;
                        res1[position1++] = 0xff & word1, position1 < res1.length && (res1[position1++] = word1 >> 8 & 0xff), position1 < res1.length && (res1[position1++] = word1 >> 16 & 0xff), 6 === shift1 ? (position1 < res1.length && (res1[position1++] = word1 >> 24 & 0xff), carry1 = 0, shift1 = 0) : (carry1 = word1 >>> 24, shift1 += 2);
                    }
                    if (position1 < res1.length) for(res1[position1++] = carry1; position1 < res1.length;)res1[position1++] = 0;
                }, BN1.prototype._toArrayLikeBE = function(res1, byteLength1) {
                    for(var position1 = res1.length - 1, carry1 = 0, i2 = 0, shift1 = 0; i2 < this.length; i2++){
                        var word1 = this.words[i2] << shift1 | carry1;
                        res1[position1--] = 0xff & word1, position1 >= 0 && (res1[position1--] = word1 >> 8 & 0xff), position1 >= 0 && (res1[position1--] = word1 >> 16 & 0xff), 6 === shift1 ? (position1 >= 0 && (res1[position1--] = word1 >> 24 & 0xff), carry1 = 0, shift1 = 0) : (carry1 = word1 >>> 24, shift1 += 2);
                    }
                    if (position1 >= 0) for(res1[position1--] = carry1; position1 >= 0;)res1[position1--] = 0;
                }, Math.clz32 ? BN1.prototype._countBits = function(w19) {
                    return 32 - Math.clz32(w19);
                } : BN1.prototype._countBits = function(w19) {
                    var t3 = w19, r3 = 0;
                    return t3 >= 0x1000 && (r3 += 13, t3 >>>= 13), t3 >= 0x40 && (r3 += 7, t3 >>>= 7), t3 >= 0x8 && (r3 += 4, t3 >>>= 4), t3 >= 0x02 && (r3 += 2, t3 >>>= 2), r3 + t3;
                }, BN1.prototype._zeroBits = function(w19) {
                    if (0 === w19) return 26;
                    var t3 = w19, r3 = 0;
                    return (0x1fff & t3) == 0 && (r3 += 13, t3 >>>= 13), (0x7f & t3) == 0 && (r3 += 7, t3 >>>= 7), (0xf & t3) == 0 && (r3 += 4, t3 >>>= 4), (0x3 & t3) == 0 && (r3 += 2, t3 >>>= 2), (0x1 & t3) == 0 && r3++, r3;
                }, BN1.prototype.bitLength = function() {
                    var w19 = this.words[this.length - 1], hi1 = this._countBits(w19);
                    return (this.length - 1) * 26 + hi1;
                }, BN1.prototype.zeroBits = function() {
                    if (this.isZero()) return 0;
                    for(var r3 = 0, i2 = 0; i2 < this.length; i2++){
                        var b10 = this._zeroBits(this.words[i2]);
                        if (r3 += b10, 26 !== b10) break;
                    }
                    return r3;
                }, BN1.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8);
                }, BN1.prototype.toTwos = function(width1) {
                    return 0 !== this.negative ? this.abs().inotn(width1).iaddn(1) : this.clone();
                }, BN1.prototype.fromTwos = function(width1) {
                    return this.testn(width1 - 1) ? this.notn(width1).iaddn(1).ineg() : this.clone();
                }, BN1.prototype.isNeg = function() {
                    return 0 !== this.negative;
                }, BN1.prototype.neg = function() {
                    return this.clone().ineg();
                }, BN1.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1), this;
                }, BN1.prototype.iuor = function(num1) {
                    for(; this.length < num1.length;)this.words[this.length++] = 0;
                    for(var i2 = 0; i2 < num1.length; i2++)this.words[i2] = this.words[i2] | num1.words[i2];
                    return this._strip();
                }, BN1.prototype.ior = function(num1) {
                    return assert1((this.negative | num1.negative) == 0), this.iuor(num1);
                }, BN1.prototype.or = function(num1) {
                    return this.length > num1.length ? this.clone().ior(num1) : num1.clone().ior(this);
                }, BN1.prototype.uor = function(num1) {
                    return this.length > num1.length ? this.clone().iuor(num1) : num1.clone().iuor(this);
                }, BN1.prototype.iuand = function(num1) {
                    var b10;
                    b10 = this.length > num1.length ? num1 : this;
                    for(var i2 = 0; i2 < b10.length; i2++)this.words[i2] = this.words[i2] & num1.words[i2];
                    return this.length = b10.length, this._strip();
                }, BN1.prototype.iand = function(num1) {
                    return assert1((this.negative | num1.negative) == 0), this.iuand(num1);
                }, BN1.prototype.and = function(num1) {
                    return this.length > num1.length ? this.clone().iand(num1) : num1.clone().iand(this);
                }, BN1.prototype.uand = function(num1) {
                    return this.length > num1.length ? this.clone().iuand(num1) : num1.clone().iuand(this);
                }, BN1.prototype.iuxor = function(num1) {
                    this.length > num1.length ? (a10 = this, b10 = num1) : (a10 = num1, b10 = this);
                    for(var a10, b10, i2 = 0; i2 < b10.length; i2++)this.words[i2] = a10.words[i2] ^ b10.words[i2];
                    if (this !== a10) for(; i2 < a10.length; i2++)this.words[i2] = a10.words[i2];
                    return this.length = a10.length, this._strip();
                }, BN1.prototype.ixor = function(num1) {
                    return assert1((this.negative | num1.negative) == 0), this.iuxor(num1);
                }, BN1.prototype.xor = function(num1) {
                    return this.length > num1.length ? this.clone().ixor(num1) : num1.clone().ixor(this);
                }, BN1.prototype.uxor = function(num1) {
                    return this.length > num1.length ? this.clone().iuxor(num1) : num1.clone().iuxor(this);
                }, BN1.prototype.inotn = function(width1) {
                    assert1('number' == typeof width1 && width1 >= 0);
                    var bytesNeeded1 = 0 | Math.ceil(width1 / 26), bitsLeft1 = width1 % 26;
                    this._expand(bytesNeeded1), bitsLeft1 > 0 && bytesNeeded1--;
                    for(var i2 = 0; i2 < bytesNeeded1; i2++)this.words[i2] = 0x3ffffff & ~this.words[i2];
                    return bitsLeft1 > 0 && (this.words[i2] = ~this.words[i2] & 0x3ffffff >> 26 - bitsLeft1), this._strip();
                }, BN1.prototype.notn = function(width1) {
                    return this.clone().inotn(width1);
                }, BN1.prototype.setn = function(bit1, val1) {
                    assert1('number' == typeof bit1 && bit1 >= 0);
                    var off1 = bit1 / 26 | 0, wbit1 = bit1 % 26;
                    return this._expand(off1 + 1), val1 ? this.words[off1] = this.words[off1] | 1 << wbit1 : this.words[off1] = this.words[off1] & ~(1 << wbit1), this._strip();
                }, BN1.prototype.iadd = function(num1) {
                    if (0 !== this.negative && 0 === num1.negative) return this.negative = 0, r3 = this.isub(num1), this.negative ^= 1, this._normSign();
                    if (0 === this.negative && 0 !== num1.negative) return num1.negative = 0, r3 = this.isub(num1), num1.negative = 1, r3._normSign();
                    this.length > num1.length ? (a10 = this, b10 = num1) : (a10 = num1, b10 = this);
                    for(var r3, a10, b10, carry1 = 0, i2 = 0; i2 < b10.length; i2++)r3 = (0 | a10.words[i2]) + (0 | b10.words[i2]) + carry1, this.words[i2] = 0x3ffffff & r3, carry1 = r3 >>> 26;
                    for(; 0 !== carry1 && i2 < a10.length; i2++)r3 = (0 | a10.words[i2]) + carry1, this.words[i2] = 0x3ffffff & r3, carry1 = r3 >>> 26;
                    if (this.length = a10.length, 0 !== carry1) this.words[this.length] = carry1, this.length++;
                    else if (a10 !== this) for(; i2 < a10.length; i2++)this.words[i2] = a10.words[i2];
                    return this;
                }, BN1.prototype.add = function(num1) {
                    var res1;
                    return 0 !== num1.negative && 0 === this.negative ? (num1.negative = 0, res1 = this.sub(num1), num1.negative ^= 1, res1) : 0 === num1.negative && 0 !== this.negative ? (this.negative = 0, res1 = num1.sub(this), this.negative = 1, res1) : this.length > num1.length ? this.clone().iadd(num1) : num1.clone().iadd(this);
                }, BN1.prototype.isub = function(num1) {
                    if (0 !== num1.negative) {
                        num1.negative = 0;
                        var a10, b10, r3 = this.iadd(num1);
                        return num1.negative = 1, r3._normSign();
                    }
                    if (0 !== this.negative) return this.negative = 0, this.iadd(num1), this.negative = 1, this._normSign();
                    var cmp1 = this.cmp(num1);
                    if (0 === cmp1) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                    cmp1 > 0 ? (a10 = this, b10 = num1) : (a10 = num1, b10 = this);
                    for(var carry1 = 0, i2 = 0; i2 < b10.length; i2++)carry1 = (r3 = (0 | a10.words[i2]) - (0 | b10.words[i2]) + carry1) >> 26, this.words[i2] = 0x3ffffff & r3;
                    for(; 0 !== carry1 && i2 < a10.length; i2++)carry1 = (r3 = (0 | a10.words[i2]) + carry1) >> 26, this.words[i2] = 0x3ffffff & r3;
                    if (0 === carry1 && i2 < a10.length && a10 !== this) for(; i2 < a10.length; i2++)this.words[i2] = a10.words[i2];
                    return this.length = Math.max(this.length, i2), a10 !== this && (this.negative = 1), this._strip();
                }, BN1.prototype.sub = function(num1) {
                    return this.clone().isub(num1);
                };
                var comb10MulTo1 = function(self1, num1, out1) {
                    var lo1, mid1, hi1, a10 = self1.words, b10 = num1.words, o1 = out1.words, c5 = 0, a01 = 0 | a10[0], al01 = 0x1fff & a01, ah01 = a01 >>> 13, a11 = 0 | a10[1], al11 = 0x1fff & a11, ah11 = a11 >>> 13, a21 = 0 | a10[2], al21 = 0x1fff & a21, ah21 = a21 >>> 13, a31 = 0 | a10[3], al31 = 0x1fff & a31, ah31 = a31 >>> 13, a41 = 0 | a10[4], al41 = 0x1fff & a41, ah41 = a41 >>> 13, a51 = 0 | a10[5], al51 = 0x1fff & a51, ah51 = a51 >>> 13, a61 = 0 | a10[6], al61 = 0x1fff & a61, ah61 = a61 >>> 13, a71 = 0 | a10[7], al71 = 0x1fff & a71, ah71 = a71 >>> 13, a81 = 0 | a10[8], al81 = 0x1fff & a81, ah81 = a81 >>> 13, a91 = 0 | a10[9], al91 = 0x1fff & a91, ah91 = a91 >>> 13, b01 = 0 | b10[0], bl01 = 0x1fff & b01, bh01 = b01 >>> 13, b11 = 0 | b10[1], bl11 = 0x1fff & b11, bh11 = b11 >>> 13, b21 = 0 | b10[2], bl21 = 0x1fff & b21, bh21 = b21 >>> 13, b31 = 0 | b10[3], bl31 = 0x1fff & b31, bh31 = b31 >>> 13, b41 = 0 | b10[4], bl41 = 0x1fff & b41, bh41 = b41 >>> 13, b51 = 0 | b10[5], bl51 = 0x1fff & b51, bh51 = b51 >>> 13, b61 = 0 | b10[6], bl61 = 0x1fff & b61, bh61 = b61 >>> 13, b71 = 0 | b10[7], bl71 = 0x1fff & b71, bh71 = b71 >>> 13, b81 = 0 | b10[8], bl81 = 0x1fff & b81, bh81 = b81 >>> 13, b91 = 0 | b10[9], bl91 = 0x1fff & b91, bh91 = b91 >>> 13;
                    out1.negative = self1.negative ^ num1.negative, out1.length = 19;
                    var w01 = (c5 + (lo1 = Math.imul(al01, bl01)) | 0) + ((0x1fff & (mid1 = (mid1 = Math.imul(al01, bh01)) + Math.imul(ah01, bl01) | 0)) << 13) | 0;
                    c5 = ((hi1 = Math.imul(ah01, bh01)) + (mid1 >>> 13) | 0) + (w01 >>> 26) | 0, w01 &= 0x3ffffff, lo1 = Math.imul(al11, bl01), mid1 = (mid1 = Math.imul(al11, bh01)) + Math.imul(ah11, bl01) | 0, hi1 = Math.imul(ah11, bh01);
                    var w19 = (c5 + (lo1 = lo1 + Math.imul(al01, bl11) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh11) | 0) + Math.imul(ah01, bl11) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh11) | 0) + (mid1 >>> 13) | 0) + (w19 >>> 26) | 0, w19 &= 0x3ffffff, lo1 = Math.imul(al21, bl01), mid1 = (mid1 = Math.imul(al21, bh01)) + Math.imul(ah21, bl01) | 0, hi1 = Math.imul(ah21, bh01), lo1 = lo1 + Math.imul(al11, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh11) | 0) + Math.imul(ah11, bl11) | 0, hi1 = hi1 + Math.imul(ah11, bh11) | 0;
                    var w21 = (c5 + (lo1 = lo1 + Math.imul(al01, bl21) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh21) | 0) + Math.imul(ah01, bl21) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh21) | 0) + (mid1 >>> 13) | 0) + (w21 >>> 26) | 0, w21 &= 0x3ffffff, lo1 = Math.imul(al31, bl01), mid1 = (mid1 = Math.imul(al31, bh01)) + Math.imul(ah31, bl01) | 0, hi1 = Math.imul(ah31, bh01), lo1 = lo1 + Math.imul(al21, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh11) | 0) + Math.imul(ah21, bl11) | 0, hi1 = hi1 + Math.imul(ah21, bh11) | 0, lo1 = lo1 + Math.imul(al11, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh21) | 0) + Math.imul(ah11, bl21) | 0, hi1 = hi1 + Math.imul(ah11, bh21) | 0;
                    var w31 = (c5 + (lo1 = lo1 + Math.imul(al01, bl31) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh31) | 0) + Math.imul(ah01, bl31) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh31) | 0) + (mid1 >>> 13) | 0) + (w31 >>> 26) | 0, w31 &= 0x3ffffff, lo1 = Math.imul(al41, bl01), mid1 = (mid1 = Math.imul(al41, bh01)) + Math.imul(ah41, bl01) | 0, hi1 = Math.imul(ah41, bh01), lo1 = lo1 + Math.imul(al31, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh11) | 0) + Math.imul(ah31, bl11) | 0, hi1 = hi1 + Math.imul(ah31, bh11) | 0, lo1 = lo1 + Math.imul(al21, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh21) | 0) + Math.imul(ah21, bl21) | 0, hi1 = hi1 + Math.imul(ah21, bh21) | 0, lo1 = lo1 + Math.imul(al11, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh31) | 0) + Math.imul(ah11, bl31) | 0, hi1 = hi1 + Math.imul(ah11, bh31) | 0;
                    var w41 = (c5 + (lo1 = lo1 + Math.imul(al01, bl41) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh41) | 0) + Math.imul(ah01, bl41) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh41) | 0) + (mid1 >>> 13) | 0) + (w41 >>> 26) | 0, w41 &= 0x3ffffff, lo1 = Math.imul(al51, bl01), mid1 = (mid1 = Math.imul(al51, bh01)) + Math.imul(ah51, bl01) | 0, hi1 = Math.imul(ah51, bh01), lo1 = lo1 + Math.imul(al41, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh11) | 0) + Math.imul(ah41, bl11) | 0, hi1 = hi1 + Math.imul(ah41, bh11) | 0, lo1 = lo1 + Math.imul(al31, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh21) | 0) + Math.imul(ah31, bl21) | 0, hi1 = hi1 + Math.imul(ah31, bh21) | 0, lo1 = lo1 + Math.imul(al21, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh31) | 0) + Math.imul(ah21, bl31) | 0, hi1 = hi1 + Math.imul(ah21, bh31) | 0, lo1 = lo1 + Math.imul(al11, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh41) | 0) + Math.imul(ah11, bl41) | 0, hi1 = hi1 + Math.imul(ah11, bh41) | 0;
                    var w51 = (c5 + (lo1 = lo1 + Math.imul(al01, bl51) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh51) | 0) + Math.imul(ah01, bl51) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh51) | 0) + (mid1 >>> 13) | 0) + (w51 >>> 26) | 0, w51 &= 0x3ffffff, lo1 = Math.imul(al61, bl01), mid1 = (mid1 = Math.imul(al61, bh01)) + Math.imul(ah61, bl01) | 0, hi1 = Math.imul(ah61, bh01), lo1 = lo1 + Math.imul(al51, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh11) | 0) + Math.imul(ah51, bl11) | 0, hi1 = hi1 + Math.imul(ah51, bh11) | 0, lo1 = lo1 + Math.imul(al41, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh21) | 0) + Math.imul(ah41, bl21) | 0, hi1 = hi1 + Math.imul(ah41, bh21) | 0, lo1 = lo1 + Math.imul(al31, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh31) | 0) + Math.imul(ah31, bl31) | 0, hi1 = hi1 + Math.imul(ah31, bh31) | 0, lo1 = lo1 + Math.imul(al21, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh41) | 0) + Math.imul(ah21, bl41) | 0, hi1 = hi1 + Math.imul(ah21, bh41) | 0, lo1 = lo1 + Math.imul(al11, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh51) | 0) + Math.imul(ah11, bl51) | 0, hi1 = hi1 + Math.imul(ah11, bh51) | 0;
                    var w61 = (c5 + (lo1 = lo1 + Math.imul(al01, bl61) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh61) | 0) + Math.imul(ah01, bl61) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh61) | 0) + (mid1 >>> 13) | 0) + (w61 >>> 26) | 0, w61 &= 0x3ffffff, lo1 = Math.imul(al71, bl01), mid1 = (mid1 = Math.imul(al71, bh01)) + Math.imul(ah71, bl01) | 0, hi1 = Math.imul(ah71, bh01), lo1 = lo1 + Math.imul(al61, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh11) | 0) + Math.imul(ah61, bl11) | 0, hi1 = hi1 + Math.imul(ah61, bh11) | 0, lo1 = lo1 + Math.imul(al51, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh21) | 0) + Math.imul(ah51, bl21) | 0, hi1 = hi1 + Math.imul(ah51, bh21) | 0, lo1 = lo1 + Math.imul(al41, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh31) | 0) + Math.imul(ah41, bl31) | 0, hi1 = hi1 + Math.imul(ah41, bh31) | 0, lo1 = lo1 + Math.imul(al31, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh41) | 0) + Math.imul(ah31, bl41) | 0, hi1 = hi1 + Math.imul(ah31, bh41) | 0, lo1 = lo1 + Math.imul(al21, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh51) | 0) + Math.imul(ah21, bl51) | 0, hi1 = hi1 + Math.imul(ah21, bh51) | 0, lo1 = lo1 + Math.imul(al11, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh61) | 0) + Math.imul(ah11, bl61) | 0, hi1 = hi1 + Math.imul(ah11, bh61) | 0;
                    var w71 = (c5 + (lo1 = lo1 + Math.imul(al01, bl71) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh71) | 0) + Math.imul(ah01, bl71) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh71) | 0) + (mid1 >>> 13) | 0) + (w71 >>> 26) | 0, w71 &= 0x3ffffff, lo1 = Math.imul(al81, bl01), mid1 = (mid1 = Math.imul(al81, bh01)) + Math.imul(ah81, bl01) | 0, hi1 = Math.imul(ah81, bh01), lo1 = lo1 + Math.imul(al71, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh11) | 0) + Math.imul(ah71, bl11) | 0, hi1 = hi1 + Math.imul(ah71, bh11) | 0, lo1 = lo1 + Math.imul(al61, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh21) | 0) + Math.imul(ah61, bl21) | 0, hi1 = hi1 + Math.imul(ah61, bh21) | 0, lo1 = lo1 + Math.imul(al51, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh31) | 0) + Math.imul(ah51, bl31) | 0, hi1 = hi1 + Math.imul(ah51, bh31) | 0, lo1 = lo1 + Math.imul(al41, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh41) | 0) + Math.imul(ah41, bl41) | 0, hi1 = hi1 + Math.imul(ah41, bh41) | 0, lo1 = lo1 + Math.imul(al31, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh51) | 0) + Math.imul(ah31, bl51) | 0, hi1 = hi1 + Math.imul(ah31, bh51) | 0, lo1 = lo1 + Math.imul(al21, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh61) | 0) + Math.imul(ah21, bl61) | 0, hi1 = hi1 + Math.imul(ah21, bh61) | 0, lo1 = lo1 + Math.imul(al11, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh71) | 0) + Math.imul(ah11, bl71) | 0, hi1 = hi1 + Math.imul(ah11, bh71) | 0;
                    var w81 = (c5 + (lo1 = lo1 + Math.imul(al01, bl81) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh81) | 0) + Math.imul(ah01, bl81) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh81) | 0) + (mid1 >>> 13) | 0) + (w81 >>> 26) | 0, w81 &= 0x3ffffff, lo1 = Math.imul(al91, bl01), mid1 = (mid1 = Math.imul(al91, bh01)) + Math.imul(ah91, bl01) | 0, hi1 = Math.imul(ah91, bh01), lo1 = lo1 + Math.imul(al81, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh11) | 0) + Math.imul(ah81, bl11) | 0, hi1 = hi1 + Math.imul(ah81, bh11) | 0, lo1 = lo1 + Math.imul(al71, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh21) | 0) + Math.imul(ah71, bl21) | 0, hi1 = hi1 + Math.imul(ah71, bh21) | 0, lo1 = lo1 + Math.imul(al61, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh31) | 0) + Math.imul(ah61, bl31) | 0, hi1 = hi1 + Math.imul(ah61, bh31) | 0, lo1 = lo1 + Math.imul(al51, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh41) | 0) + Math.imul(ah51, bl41) | 0, hi1 = hi1 + Math.imul(ah51, bh41) | 0, lo1 = lo1 + Math.imul(al41, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh51) | 0) + Math.imul(ah41, bl51) | 0, hi1 = hi1 + Math.imul(ah41, bh51) | 0, lo1 = lo1 + Math.imul(al31, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh61) | 0) + Math.imul(ah31, bl61) | 0, hi1 = hi1 + Math.imul(ah31, bh61) | 0, lo1 = lo1 + Math.imul(al21, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh71) | 0) + Math.imul(ah21, bl71) | 0, hi1 = hi1 + Math.imul(ah21, bh71) | 0, lo1 = lo1 + Math.imul(al11, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh81) | 0) + Math.imul(ah11, bl81) | 0, hi1 = hi1 + Math.imul(ah11, bh81) | 0;
                    var w91 = (c5 + (lo1 = lo1 + Math.imul(al01, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh91) | 0) + Math.imul(ah01, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh91) | 0) + (mid1 >>> 13) | 0) + (w91 >>> 26) | 0, w91 &= 0x3ffffff, lo1 = Math.imul(al91, bl11), mid1 = (mid1 = Math.imul(al91, bh11)) + Math.imul(ah91, bl11) | 0, hi1 = Math.imul(ah91, bh11), lo1 = lo1 + Math.imul(al81, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh21) | 0) + Math.imul(ah81, bl21) | 0, hi1 = hi1 + Math.imul(ah81, bh21) | 0, lo1 = lo1 + Math.imul(al71, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh31) | 0) + Math.imul(ah71, bl31) | 0, hi1 = hi1 + Math.imul(ah71, bh31) | 0, lo1 = lo1 + Math.imul(al61, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh41) | 0) + Math.imul(ah61, bl41) | 0, hi1 = hi1 + Math.imul(ah61, bh41) | 0, lo1 = lo1 + Math.imul(al51, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh51) | 0) + Math.imul(ah51, bl51) | 0, hi1 = hi1 + Math.imul(ah51, bh51) | 0, lo1 = lo1 + Math.imul(al41, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh61) | 0) + Math.imul(ah41, bl61) | 0, hi1 = hi1 + Math.imul(ah41, bh61) | 0, lo1 = lo1 + Math.imul(al31, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh71) | 0) + Math.imul(ah31, bl71) | 0, hi1 = hi1 + Math.imul(ah31, bh71) | 0, lo1 = lo1 + Math.imul(al21, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh81) | 0) + Math.imul(ah21, bl81) | 0, hi1 = hi1 + Math.imul(ah21, bh81) | 0;
                    var w101 = (c5 + (lo1 = lo1 + Math.imul(al11, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al11, bh91) | 0) + Math.imul(ah11, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah11, bh91) | 0) + (mid1 >>> 13) | 0) + (w101 >>> 26) | 0, w101 &= 0x3ffffff, lo1 = Math.imul(al91, bl21), mid1 = (mid1 = Math.imul(al91, bh21)) + Math.imul(ah91, bl21) | 0, hi1 = Math.imul(ah91, bh21), lo1 = lo1 + Math.imul(al81, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh31) | 0) + Math.imul(ah81, bl31) | 0, hi1 = hi1 + Math.imul(ah81, bh31) | 0, lo1 = lo1 + Math.imul(al71, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh41) | 0) + Math.imul(ah71, bl41) | 0, hi1 = hi1 + Math.imul(ah71, bh41) | 0, lo1 = lo1 + Math.imul(al61, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh51) | 0) + Math.imul(ah61, bl51) | 0, hi1 = hi1 + Math.imul(ah61, bh51) | 0, lo1 = lo1 + Math.imul(al51, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh61) | 0) + Math.imul(ah51, bl61) | 0, hi1 = hi1 + Math.imul(ah51, bh61) | 0, lo1 = lo1 + Math.imul(al41, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh71) | 0) + Math.imul(ah41, bl71) | 0, hi1 = hi1 + Math.imul(ah41, bh71) | 0, lo1 = lo1 + Math.imul(al31, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh81) | 0) + Math.imul(ah31, bl81) | 0, hi1 = hi1 + Math.imul(ah31, bh81) | 0;
                    var w111 = (c5 + (lo1 = lo1 + Math.imul(al21, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al21, bh91) | 0) + Math.imul(ah21, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah21, bh91) | 0) + (mid1 >>> 13) | 0) + (w111 >>> 26) | 0, w111 &= 0x3ffffff, lo1 = Math.imul(al91, bl31), mid1 = (mid1 = Math.imul(al91, bh31)) + Math.imul(ah91, bl31) | 0, hi1 = Math.imul(ah91, bh31), lo1 = lo1 + Math.imul(al81, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh41) | 0) + Math.imul(ah81, bl41) | 0, hi1 = hi1 + Math.imul(ah81, bh41) | 0, lo1 = lo1 + Math.imul(al71, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh51) | 0) + Math.imul(ah71, bl51) | 0, hi1 = hi1 + Math.imul(ah71, bh51) | 0, lo1 = lo1 + Math.imul(al61, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh61) | 0) + Math.imul(ah61, bl61) | 0, hi1 = hi1 + Math.imul(ah61, bh61) | 0, lo1 = lo1 + Math.imul(al51, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh71) | 0) + Math.imul(ah51, bl71) | 0, hi1 = hi1 + Math.imul(ah51, bh71) | 0, lo1 = lo1 + Math.imul(al41, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh81) | 0) + Math.imul(ah41, bl81) | 0, hi1 = hi1 + Math.imul(ah41, bh81) | 0;
                    var w121 = (c5 + (lo1 = lo1 + Math.imul(al31, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al31, bh91) | 0) + Math.imul(ah31, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah31, bh91) | 0) + (mid1 >>> 13) | 0) + (w121 >>> 26) | 0, w121 &= 0x3ffffff, lo1 = Math.imul(al91, bl41), mid1 = (mid1 = Math.imul(al91, bh41)) + Math.imul(ah91, bl41) | 0, hi1 = Math.imul(ah91, bh41), lo1 = lo1 + Math.imul(al81, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh51) | 0) + Math.imul(ah81, bl51) | 0, hi1 = hi1 + Math.imul(ah81, bh51) | 0, lo1 = lo1 + Math.imul(al71, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh61) | 0) + Math.imul(ah71, bl61) | 0, hi1 = hi1 + Math.imul(ah71, bh61) | 0, lo1 = lo1 + Math.imul(al61, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh71) | 0) + Math.imul(ah61, bl71) | 0, hi1 = hi1 + Math.imul(ah61, bh71) | 0, lo1 = lo1 + Math.imul(al51, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh81) | 0) + Math.imul(ah51, bl81) | 0, hi1 = hi1 + Math.imul(ah51, bh81) | 0;
                    var w131 = (c5 + (lo1 = lo1 + Math.imul(al41, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al41, bh91) | 0) + Math.imul(ah41, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah41, bh91) | 0) + (mid1 >>> 13) | 0) + (w131 >>> 26) | 0, w131 &= 0x3ffffff, lo1 = Math.imul(al91, bl51), mid1 = (mid1 = Math.imul(al91, bh51)) + Math.imul(ah91, bl51) | 0, hi1 = Math.imul(ah91, bh51), lo1 = lo1 + Math.imul(al81, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh61) | 0) + Math.imul(ah81, bl61) | 0, hi1 = hi1 + Math.imul(ah81, bh61) | 0, lo1 = lo1 + Math.imul(al71, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh71) | 0) + Math.imul(ah71, bl71) | 0, hi1 = hi1 + Math.imul(ah71, bh71) | 0, lo1 = lo1 + Math.imul(al61, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh81) | 0) + Math.imul(ah61, bl81) | 0, hi1 = hi1 + Math.imul(ah61, bh81) | 0;
                    var w141 = (c5 + (lo1 = lo1 + Math.imul(al51, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al51, bh91) | 0) + Math.imul(ah51, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah51, bh91) | 0) + (mid1 >>> 13) | 0) + (w141 >>> 26) | 0, w141 &= 0x3ffffff, lo1 = Math.imul(al91, bl61), mid1 = (mid1 = Math.imul(al91, bh61)) + Math.imul(ah91, bl61) | 0, hi1 = Math.imul(ah91, bh61), lo1 = lo1 + Math.imul(al81, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh71) | 0) + Math.imul(ah81, bl71) | 0, hi1 = hi1 + Math.imul(ah81, bh71) | 0, lo1 = lo1 + Math.imul(al71, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh81) | 0) + Math.imul(ah71, bl81) | 0, hi1 = hi1 + Math.imul(ah71, bh81) | 0;
                    var w151 = (c5 + (lo1 = lo1 + Math.imul(al61, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al61, bh91) | 0) + Math.imul(ah61, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah61, bh91) | 0) + (mid1 >>> 13) | 0) + (w151 >>> 26) | 0, w151 &= 0x3ffffff, lo1 = Math.imul(al91, bl71), mid1 = (mid1 = Math.imul(al91, bh71)) + Math.imul(ah91, bl71) | 0, hi1 = Math.imul(ah91, bh71), lo1 = lo1 + Math.imul(al81, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh81) | 0) + Math.imul(ah81, bl81) | 0, hi1 = hi1 + Math.imul(ah81, bh81) | 0;
                    var w161 = (c5 + (lo1 = lo1 + Math.imul(al71, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al71, bh91) | 0) + Math.imul(ah71, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah71, bh91) | 0) + (mid1 >>> 13) | 0) + (w161 >>> 26) | 0, w161 &= 0x3ffffff, lo1 = Math.imul(al91, bl81), mid1 = (mid1 = Math.imul(al91, bh81)) + Math.imul(ah91, bl81) | 0, hi1 = Math.imul(ah91, bh81);
                    var w171 = (c5 + (lo1 = lo1 + Math.imul(al81, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al81, bh91) | 0) + Math.imul(ah81, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah81, bh91) | 0) + (mid1 >>> 13) | 0) + (w171 >>> 26) | 0, w171 &= 0x3ffffff;
                    var w181 = (c5 + (lo1 = Math.imul(al91, bl91)) | 0) + ((0x1fff & (mid1 = (mid1 = Math.imul(al91, bh91)) + Math.imul(ah91, bl91) | 0)) << 13) | 0;
                    return c5 = ((hi1 = Math.imul(ah91, bh91)) + (mid1 >>> 13) | 0) + (w181 >>> 26) | 0, w181 &= 0x3ffffff, o1[0] = w01, o1[1] = w19, o1[2] = w21, o1[3] = w31, o1[4] = w41, o1[5] = w51, o1[6] = w61, o1[7] = w71, o1[8] = w81, o1[9] = w91, o1[10] = w101, o1[11] = w111, o1[12] = w121, o1[13] = w131, o1[14] = w141, o1[15] = w151, o1[16] = w161, o1[17] = w171, o1[18] = w181, 0 !== c5 && (o1[19] = c5, out1.length++), out1;
                };
                function bigMulTo1(self1, num1, out1) {
                    out1.negative = num1.negative ^ self1.negative, out1.length = self1.length + num1.length;
                    for(var carry1 = 0, hncarry1 = 0, k3 = 0; k3 < out1.length - 1; k3++){
                        var ncarry1 = hncarry1;
                        hncarry1 = 0;
                        for(var rword1 = 0x3ffffff & carry1, maxJ1 = Math.min(k3, num1.length - 1), j1 = Math.max(0, k3 - self1.length + 1); j1 <= maxJ1; j1++){
                            var i2 = k3 - j1, r3 = (0 | self1.words[i2]) * (0 | num1.words[j1]), lo1 = 0x3ffffff & r3;
                            ncarry1 = ncarry1 + (r3 / 0x4000000 | 0) | 0, rword1 = 0x3ffffff & (lo1 = lo1 + rword1 | 0), hncarry1 += (ncarry1 = ncarry1 + (lo1 >>> 26) | 0) >>> 26, ncarry1 &= 0x3ffffff;
                        }
                        out1.words[k3] = rword1, carry1 = ncarry1, ncarry1 = hncarry1;
                    }
                    return 0 !== carry1 ? out1.words[k3] = carry1 : out1.length--, out1._strip();
                }
                function jumboMulTo1(self1, num1, out1) {
                    return bigMulTo1(self1, num1, out1);
                }
                function FFTM1(x3, y3) {
                    this.x = x3, this.y = y3;
                }
                Math.imul || (comb10MulTo1 = smallMulTo1), BN1.prototype.mulTo = function(num1, out1) {
                    var len3 = this.length + num1.length;
                    return 10 === this.length && 10 === num1.length ? comb10MulTo1(this, num1, out1) : len3 < 63 ? smallMulTo1(this, num1, out1) : len3 < 1024 ? bigMulTo1(this, num1, out1) : jumboMulTo1(this, num1, out1);
                }, FFTM1.prototype.makeRBT = function(N1) {
                    for(var t3 = Array(N1), l1 = BN1.prototype._countBits(N1) - 1, i2 = 0; i2 < N1; i2++)t3[i2] = this.revBin(i2, l1, N1);
                    return t3;
                }, FFTM1.prototype.revBin = function(x3, l1, N1) {
                    if (0 === x3 || x3 === N1 - 1) return x3;
                    for(var rb1 = 0, i2 = 0; i2 < l1; i2++)rb1 |= (1 & x3) << l1 - i2 - 1, x3 >>= 1;
                    return rb1;
                }, FFTM1.prototype.permute = function(rbt1, rws1, iws1, rtws1, itws1, N1) {
                    for(var i2 = 0; i2 < N1; i2++)rtws1[i2] = rws1[rbt1[i2]], itws1[i2] = iws1[rbt1[i2]];
                }, FFTM1.prototype.transform = function(rws1, iws1, rtws1, itws1, N1, rbt1) {
                    this.permute(rbt1, rws1, iws1, rtws1, itws1, N1);
                    for(var s3 = 1; s3 < N1; s3 <<= 1)for(var l1 = s3 << 1, rtwdf1 = Math.cos(2 * Math.PI / l1), itwdf1 = Math.sin(2 * Math.PI / l1), p3 = 0; p3 < N1; p3 += l1)for(var rtwdf_1 = rtwdf1, itwdf_1 = itwdf1, j1 = 0; j1 < s3; j1++){
                        var re1 = rtws1[p3 + j1], ie1 = itws1[p3 + j1], ro1 = rtws1[p3 + j1 + s3], io1 = itws1[p3 + j1 + s3], rx1 = rtwdf_1 * ro1 - itwdf_1 * io1;
                        io1 = rtwdf_1 * io1 + itwdf_1 * ro1, ro1 = rx1, rtws1[p3 + j1] = re1 + ro1, itws1[p3 + j1] = ie1 + io1, rtws1[p3 + j1 + s3] = re1 - ro1, itws1[p3 + j1 + s3] = ie1 - io1, j1 !== l1 && (rx1 = rtwdf1 * rtwdf_1 - itwdf1 * itwdf_1, itwdf_1 = rtwdf1 * itwdf_1 + itwdf1 * rtwdf_1, rtwdf_1 = rx1);
                    }
                }, FFTM1.prototype.guessLen13b = function(n2, m1) {
                    var N1 = 1 | Math.max(m1, n2), odd1 = 1 & N1, i2 = 0;
                    for(N1 = N1 / 2 | 0; N1; N1 >>>= 1)i2++;
                    return 1 << i2 + 1 + odd1;
                }, FFTM1.prototype.conjugate = function(rws1, iws1, N1) {
                    if (!(N1 <= 1)) for(var i2 = 0; i2 < N1 / 2; i2++){
                        var t3 = rws1[i2];
                        rws1[i2] = rws1[N1 - i2 - 1], rws1[N1 - i2 - 1] = t3, t3 = iws1[i2], iws1[i2] = -iws1[N1 - i2 - 1], iws1[N1 - i2 - 1] = -t3;
                    }
                }, FFTM1.prototype.normalize13b = function(ws1, N1) {
                    for(var carry1 = 0, i2 = 0; i2 < N1 / 2; i2++){
                        var w19 = 0x2000 * Math.round(ws1[2 * i2 + 1] / N1) + Math.round(ws1[2 * i2] / N1) + carry1;
                        ws1[i2] = 0x3ffffff & w19, carry1 = w19 < 0x4000000 ? 0 : w19 / 0x4000000 | 0;
                    }
                    return ws1;
                }, FFTM1.prototype.convert13b = function(ws1, len3, rws1, N1) {
                    for(var carry1 = 0, i2 = 0; i2 < len3; i2++)carry1 += 0 | ws1[i2], rws1[2 * i2] = 0x1fff & carry1, carry1 >>>= 13, rws1[2 * i2 + 1] = 0x1fff & carry1, carry1 >>>= 13;
                    for(i2 = 2 * len3; i2 < N1; ++i2)rws1[i2] = 0;
                    assert1(0 === carry1), assert1((-8192 & carry1) == 0);
                }, FFTM1.prototype.stub = function(N1) {
                    for(var ph1 = Array(N1), i2 = 0; i2 < N1; i2++)ph1[i2] = 0;
                    return ph1;
                }, FFTM1.prototype.mulp = function(x3, y3, out1) {
                    var N1 = 2 * this.guessLen13b(x3.length, y3.length), rbt1 = this.makeRBT(N1), _1 = this.stub(N1), rws1 = Array(N1), rwst1 = Array(N1), iwst1 = Array(N1), nrws1 = Array(N1), nrwst1 = Array(N1), niwst1 = Array(N1), rmws1 = out1.words;
                    rmws1.length = N1, this.convert13b(x3.words, x3.length, rws1, N1), this.convert13b(y3.words, y3.length, nrws1, N1), this.transform(rws1, _1, rwst1, iwst1, N1, rbt1), this.transform(nrws1, _1, nrwst1, niwst1, N1, rbt1);
                    for(var i2 = 0; i2 < N1; i2++){
                        var rx1 = rwst1[i2] * nrwst1[i2] - iwst1[i2] * niwst1[i2];
                        iwst1[i2] = rwst1[i2] * niwst1[i2] + iwst1[i2] * nrwst1[i2], rwst1[i2] = rx1;
                    }
                    return this.conjugate(rwst1, iwst1, N1), this.transform(rwst1, iwst1, rmws1, _1, N1, rbt1), this.conjugate(rmws1, _1, N1), this.normalize13b(rmws1, N1), out1.negative = x3.negative ^ y3.negative, out1.length = x3.length + y3.length, out1._strip();
                }, BN1.prototype.mul = function(num1) {
                    var out1 = new BN1(null);
                    return out1.words = Array(this.length + num1.length), this.mulTo(num1, out1);
                }, BN1.prototype.mulf = function(num1) {
                    var out1 = new BN1(null);
                    return out1.words = Array(this.length + num1.length), jumboMulTo1(this, num1, out1);
                }, BN1.prototype.imul = function(num1) {
                    return this.clone().mulTo(num1, this);
                }, BN1.prototype.imuln = function(num1) {
                    var isNegNum1 = num1 < 0;
                    isNegNum1 && (num1 = -num1), assert1('number' == typeof num1), assert1(num1 < 0x4000000);
                    for(var carry1 = 0, i2 = 0; i2 < this.length; i2++){
                        var w19 = (0 | this.words[i2]) * num1, lo1 = (0x3ffffff & w19) + (0x3ffffff & carry1);
                        carry1 >>= 26, carry1 += (w19 / 0x4000000 | 0) + (lo1 >>> 26), this.words[i2] = 0x3ffffff & lo1;
                    }
                    return 0 !== carry1 && (this.words[i2] = carry1, this.length++), isNegNum1 ? this.ineg() : this;
                }, BN1.prototype.muln = function(num1) {
                    return this.clone().imuln(num1);
                }, BN1.prototype.sqr = function() {
                    return this.mul(this);
                }, BN1.prototype.isqr = function() {
                    return this.imul(this.clone());
                }, BN1.prototype.pow = function(num1) {
                    var w19 = toBitArray1(num1);
                    if (0 === w19.length) return new BN1(1);
                    for(var res1 = this, i2 = 0; i2 < w19.length && 0 === w19[i2]; i2++, res1 = res1.sqr());
                    if (++i2 < w19.length) for(var q3 = res1.sqr(); i2 < w19.length; i2++, q3 = q3.sqr())0 !== w19[i2] && (res1 = res1.mul(q3));
                    return res1;
                }, BN1.prototype.iushln = function(bits1) {
                    assert1('number' == typeof bits1 && bits1 >= 0);
                    var i2, r3 = bits1 % 26, s3 = (bits1 - r3) / 26, carryMask1 = 0x3ffffff >>> 26 - r3 << 26 - r3;
                    if (0 !== r3) {
                        var carry1 = 0;
                        for(i2 = 0; i2 < this.length; i2++){
                            var newCarry1 = this.words[i2] & carryMask1, c5 = (0 | this.words[i2]) - newCarry1 << r3;
                            this.words[i2] = c5 | carry1, carry1 = newCarry1 >>> 26 - r3;
                        }
                        carry1 && (this.words[i2] = carry1, this.length++);
                    }
                    if (0 !== s3) {
                        for(i2 = this.length - 1; i2 >= 0; i2--)this.words[i2 + s3] = this.words[i2];
                        for(i2 = 0; i2 < s3; i2++)this.words[i2] = 0;
                        this.length += s3;
                    }
                    return this._strip();
                }, BN1.prototype.ishln = function(bits1) {
                    return assert1(0 === this.negative), this.iushln(bits1);
                }, BN1.prototype.iushrn = function(bits1, hint1, extended1) {
                    assert1('number' == typeof bits1 && bits1 >= 0), h8 = hint1 ? (hint1 - hint1 % 26) / 26 : 0;
                    var h8, r3 = bits1 % 26, s3 = Math.min((bits1 - r3) / 26, this.length), mask1 = 0x3ffffff ^ 0x3ffffff >>> r3 << r3, maskedWords1 = extended1;
                    if (h8 -= s3, h8 = Math.max(0, h8), maskedWords1) {
                        for(var i2 = 0; i2 < s3; i2++)maskedWords1.words[i2] = this.words[i2];
                        maskedWords1.length = s3;
                    }
                    if (0 === s3) ;
                    else if (this.length > s3) for(this.length -= s3, i2 = 0; i2 < this.length; i2++)this.words[i2] = this.words[i2 + s3];
                    else this.words[0] = 0, this.length = 1;
                    var carry1 = 0;
                    for(i2 = this.length - 1; i2 >= 0 && (0 !== carry1 || i2 >= h8); i2--){
                        var word1 = 0 | this.words[i2];
                        this.words[i2] = carry1 << 26 - r3 | word1 >>> r3, carry1 = word1 & mask1;
                    }
                    return maskedWords1 && 0 !== carry1 && (maskedWords1.words[maskedWords1.length++] = carry1), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip();
                }, BN1.prototype.ishrn = function(bits1, hint1, extended1) {
                    return assert1(0 === this.negative), this.iushrn(bits1, hint1, extended1);
                }, BN1.prototype.shln = function(bits1) {
                    return this.clone().ishln(bits1);
                }, BN1.prototype.ushln = function(bits1) {
                    return this.clone().iushln(bits1);
                }, BN1.prototype.shrn = function(bits1) {
                    return this.clone().ishrn(bits1);
                }, BN1.prototype.ushrn = function(bits1) {
                    return this.clone().iushrn(bits1);
                }, BN1.prototype.testn = function(bit1) {
                    assert1('number' == typeof bit1 && bit1 >= 0);
                    var r3 = bit1 % 26, s3 = (bit1 - r3) / 26, q3 = 1 << r3;
                    return !(this.length <= s3) && !!(this.words[s3] & q3);
                }, BN1.prototype.imaskn = function(bits1) {
                    assert1('number' == typeof bits1 && bits1 >= 0);
                    var r3 = bits1 % 26, s3 = (bits1 - r3) / 26;
                    if (assert1(0 === this.negative, 'imaskn works only with positive numbers'), this.length <= s3) return this;
                    if (0 !== r3 && s3++, this.length = Math.min(s3, this.length), 0 !== r3) {
                        var mask1 = 0x3ffffff ^ 0x3ffffff >>> r3 << r3;
                        this.words[this.length - 1] &= mask1;
                    }
                    return this._strip();
                }, BN1.prototype.maskn = function(bits1) {
                    return this.clone().imaskn(bits1);
                }, BN1.prototype.iaddn = function(num1) {
                    return (assert1('number' == typeof num1), assert1(num1 < 0x4000000), num1 < 0) ? this.isubn(-num1) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= num1 ? (this.words[0] = num1 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(num1), this.negative = 1, this) : this._iaddn(num1);
                }, BN1.prototype._iaddn = function(num1) {
                    this.words[0] += num1;
                    for(var i2 = 0; i2 < this.length && this.words[i2] >= 0x4000000; i2++)this.words[i2] -= 0x4000000, i2 === this.length - 1 ? this.words[i2 + 1] = 1 : this.words[i2 + 1]++;
                    return this.length = Math.max(this.length, i2 + 1), this;
                }, BN1.prototype.isubn = function(num1) {
                    if (assert1('number' == typeof num1), assert1(num1 < 0x4000000), num1 < 0) return this.iaddn(-num1);
                    if (0 !== this.negative) return this.negative = 0, this.iaddn(num1), this.negative = 1, this;
                    if (this.words[0] -= num1, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                    else for(var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++)this.words[i2] += 0x4000000, this.words[i2 + 1] -= 1;
                    return this._strip();
                }, BN1.prototype.addn = function(num1) {
                    return this.clone().iaddn(num1);
                }, BN1.prototype.subn = function(num1) {
                    return this.clone().isubn(num1);
                }, BN1.prototype.iabs = function() {
                    return this.negative = 0, this;
                }, BN1.prototype.abs = function() {
                    return this.clone().iabs();
                }, BN1.prototype._ishlnsubmul = function(num1, mul1, shift1) {
                    var i2, w19, len3 = num1.length + shift1;
                    this._expand(len3);
                    var carry1 = 0;
                    for(i2 = 0; i2 < num1.length; i2++){
                        w19 = (0 | this.words[i2 + shift1]) + carry1;
                        var right1 = (0 | num1.words[i2]) * mul1;
                        w19 -= 0x3ffffff & right1, carry1 = (w19 >> 26) - (right1 / 0x4000000 | 0), this.words[i2 + shift1] = 0x3ffffff & w19;
                    }
                    for(; i2 < this.length - shift1; i2++)carry1 = (w19 = (0 | this.words[i2 + shift1]) + carry1) >> 26, this.words[i2 + shift1] = 0x3ffffff & w19;
                    if (0 === carry1) return this._strip();
                    for(assert1(-1 === carry1), carry1 = 0, i2 = 0; i2 < this.length; i2++)carry1 = (w19 = -(0 | this.words[i2]) + carry1) >> 26, this.words[i2] = 0x3ffffff & w19;
                    return this.negative = 1, this._strip();
                }, BN1.prototype._wordDiv = function(num1, mode1) {
                    var q3, shift1 = this.length - num1.length, a10 = this.clone(), b10 = num1, bhi1 = 0 | b10.words[b10.length - 1];
                    0 != (shift1 = 26 - this._countBits(bhi1)) && (b10 = b10.ushln(shift1), a10.iushln(shift1), bhi1 = 0 | b10.words[b10.length - 1]);
                    var m1 = a10.length - b10.length;
                    if ('mod' !== mode1) {
                        (q3 = new BN1(null)).length = m1 + 1, q3.words = Array(q3.length);
                        for(var i2 = 0; i2 < q3.length; i2++)q3.words[i2] = 0;
                    }
                    var diff1 = a10.clone()._ishlnsubmul(b10, 1, m1);
                    0 === diff1.negative && (a10 = diff1, q3 && (q3.words[m1] = 1));
                    for(var j1 = m1 - 1; j1 >= 0; j1--){
                        var qj1 = (0 | a10.words[b10.length + j1]) * 0x4000000 + (0 | a10.words[b10.length + j1 - 1]);
                        for(qj1 = Math.min(qj1 / bhi1 | 0, 0x3ffffff), a10._ishlnsubmul(b10, qj1, j1); 0 !== a10.negative;)qj1--, a10.negative = 0, a10._ishlnsubmul(b10, 1, j1), a10.isZero() || (a10.negative ^= 1);
                        q3 && (q3.words[j1] = qj1);
                    }
                    return q3 && q3._strip(), a10._strip(), 'div' !== mode1 && 0 !== shift1 && a10.iushrn(shift1), {
                        div: q3 || null,
                        mod: a10
                    };
                }, BN1.prototype.divmod = function(num1, mode1, positive1) {
                    var div1, mod1, res1;
                    return (assert1(!num1.isZero()), this.isZero()) ? {
                        div: new BN1(0),
                        mod: new BN1(0)
                    } : 0 !== this.negative && 0 === num1.negative ? (res1 = this.neg().divmod(num1, mode1), 'mod' !== mode1 && (div1 = res1.div.neg()), 'div' !== mode1 && (mod1 = res1.mod.neg(), positive1 && 0 !== mod1.negative && mod1.iadd(num1)), {
                        div: div1,
                        mod: mod1
                    }) : 0 === this.negative && 0 !== num1.negative ? (res1 = this.divmod(num1.neg(), mode1), 'mod' !== mode1 && (div1 = res1.div.neg()), {
                        div: div1,
                        mod: res1.mod
                    }) : (this.negative & num1.negative) != 0 ? (res1 = this.neg().divmod(num1.neg(), mode1), 'div' !== mode1 && (mod1 = res1.mod.neg(), positive1 && 0 !== mod1.negative && mod1.isub(num1)), {
                        div: res1.div,
                        mod: mod1
                    }) : num1.length > this.length || 0 > this.cmp(num1) ? {
                        div: new BN1(0),
                        mod: this
                    } : 1 === num1.length ? 'div' === mode1 ? {
                        div: this.divn(num1.words[0]),
                        mod: null
                    } : 'mod' === mode1 ? {
                        div: null,
                        mod: new BN1(this.modrn(num1.words[0]))
                    } : {
                        div: this.divn(num1.words[0]),
                        mod: new BN1(this.modrn(num1.words[0]))
                    } : this._wordDiv(num1, mode1);
                }, BN1.prototype.div = function(num1) {
                    return this.divmod(num1, 'div', !1).div;
                }, BN1.prototype.mod = function(num1) {
                    return this.divmod(num1, 'mod', !1).mod;
                }, BN1.prototype.umod = function(num1) {
                    return this.divmod(num1, 'mod', !0).mod;
                }, BN1.prototype.divRound = function(num1) {
                    var dm1 = this.divmod(num1);
                    if (dm1.mod.isZero()) return dm1.div;
                    var mod1 = 0 !== dm1.div.negative ? dm1.mod.isub(num1) : dm1.mod, half1 = num1.ushrn(1), r21 = num1.andln(1), cmp1 = mod1.cmp(half1);
                    return cmp1 < 0 || 1 === r21 && 0 === cmp1 ? dm1.div : 0 !== dm1.div.negative ? dm1.div.isubn(1) : dm1.div.iaddn(1);
                }, BN1.prototype.modrn = function(num1) {
                    var isNegNum1 = num1 < 0;
                    isNegNum1 && (num1 = -num1), assert1(num1 <= 0x3ffffff);
                    for(var p3 = 67108864 % num1, acc1 = 0, i2 = this.length - 1; i2 >= 0; i2--)acc1 = (p3 * acc1 + (0 | this.words[i2])) % num1;
                    return isNegNum1 ? -acc1 : acc1;
                }, BN1.prototype.modn = function(num1) {
                    return this.modrn(num1);
                }, BN1.prototype.idivn = function(num1) {
                    var isNegNum1 = num1 < 0;
                    isNegNum1 && (num1 = -num1), assert1(num1 <= 0x3ffffff);
                    for(var carry1 = 0, i2 = this.length - 1; i2 >= 0; i2--){
                        var w19 = (0 | this.words[i2]) + 0x4000000 * carry1;
                        this.words[i2] = w19 / num1 | 0, carry1 = w19 % num1;
                    }
                    return this._strip(), isNegNum1 ? this.ineg() : this;
                }, BN1.prototype.divn = function(num1) {
                    return this.clone().idivn(num1);
                }, BN1.prototype.egcd = function(p3) {
                    assert1(0 === p3.negative), assert1(!p3.isZero());
                    var x3 = this, y3 = p3.clone();
                    x3 = 0 !== x3.negative ? x3.umod(p3) : x3.clone();
                    for(var A1 = new BN1(1), B1 = new BN1(0), C1 = new BN1(0), D1 = new BN1(1), g3 = 0; x3.isEven() && y3.isEven();)x3.iushrn(1), y3.iushrn(1), ++g3;
                    for(var yp1 = y3.clone(), xp1 = x3.clone(); !x3.isZero();){
                        for(var i2 = 0, im1 = 1; (x3.words[0] & im1) == 0 && i2 < 26; ++i2, im1 <<= 1);
                        if (i2 > 0) for(x3.iushrn(i2); i2-- > 0;)(A1.isOdd() || B1.isOdd()) && (A1.iadd(yp1), B1.isub(xp1)), A1.iushrn(1), B1.iushrn(1);
                        for(var j1 = 0, jm1 = 1; (y3.words[0] & jm1) == 0 && j1 < 26; ++j1, jm1 <<= 1);
                        if (j1 > 0) for(y3.iushrn(j1); j1-- > 0;)(C1.isOdd() || D1.isOdd()) && (C1.iadd(yp1), D1.isub(xp1)), C1.iushrn(1), D1.iushrn(1);
                        x3.cmp(y3) >= 0 ? (x3.isub(y3), A1.isub(C1), B1.isub(D1)) : (y3.isub(x3), C1.isub(A1), D1.isub(B1));
                    }
                    return {
                        a: C1,
                        b: D1,
                        gcd: y3.iushln(g3)
                    };
                }, BN1.prototype._invmp = function(p3) {
                    assert1(0 === p3.negative), assert1(!p3.isZero());
                    var res1, a10 = this, b10 = p3.clone();
                    a10 = 0 !== a10.negative ? a10.umod(p3) : a10.clone();
                    for(var x11 = new BN1(1), x21 = new BN1(0), delta1 = b10.clone(); a10.cmpn(1) > 0 && b10.cmpn(1) > 0;){
                        for(var i2 = 0, im1 = 1; (a10.words[0] & im1) == 0 && i2 < 26; ++i2, im1 <<= 1);
                        if (i2 > 0) for(a10.iushrn(i2); i2-- > 0;)x11.isOdd() && x11.iadd(delta1), x11.iushrn(1);
                        for(var j1 = 0, jm1 = 1; (b10.words[0] & jm1) == 0 && j1 < 26; ++j1, jm1 <<= 1);
                        if (j1 > 0) for(b10.iushrn(j1); j1-- > 0;)x21.isOdd() && x21.iadd(delta1), x21.iushrn(1);
                        a10.cmp(b10) >= 0 ? (a10.isub(b10), x11.isub(x21)) : (b10.isub(a10), x21.isub(x11));
                    }
                    return 0 > (res1 = 0 === a10.cmpn(1) ? x11 : x21).cmpn(0) && res1.iadd(p3), res1;
                }, BN1.prototype.gcd = function(num1) {
                    if (this.isZero()) return num1.abs();
                    if (num1.isZero()) return this.abs();
                    var a10 = this.clone(), b10 = num1.clone();
                    a10.negative = 0, b10.negative = 0;
                    for(var shift1 = 0; a10.isEven() && b10.isEven(); shift1++)a10.iushrn(1), b10.iushrn(1);
                    for(;;){
                        for(; a10.isEven();)a10.iushrn(1);
                        for(; b10.isEven();)b10.iushrn(1);
                        var r3 = a10.cmp(b10);
                        if (r3 < 0) {
                            var t3 = a10;
                            a10 = b10, b10 = t3;
                        } else if (0 === r3 || 0 === b10.cmpn(1)) break;
                        a10.isub(b10);
                    }
                    return b10.iushln(shift1);
                }, BN1.prototype.invm = function(num1) {
                    return this.egcd(num1).a.umod(num1);
                }, BN1.prototype.isEven = function() {
                    return (1 & this.words[0]) == 0;
                }, BN1.prototype.isOdd = function() {
                    return (1 & this.words[0]) == 1;
                }, BN1.prototype.andln = function(num1) {
                    return this.words[0] & num1;
                }, BN1.prototype.bincn = function(bit1) {
                    assert1('number' == typeof bit1);
                    var r3 = bit1 % 26, s3 = (bit1 - r3) / 26, q3 = 1 << r3;
                    if (this.length <= s3) return this._expand(s3 + 1), this.words[s3] |= q3, this;
                    for(var carry1 = q3, i2 = s3; 0 !== carry1 && i2 < this.length; i2++){
                        var w19 = 0 | this.words[i2];
                        w19 += carry1, carry1 = w19 >>> 26, w19 &= 0x3ffffff, this.words[i2] = w19;
                    }
                    return 0 !== carry1 && (this.words[i2] = carry1, this.length++), this;
                }, BN1.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0];
                }, BN1.prototype.cmpn = function(num1) {
                    var res1, negative1 = num1 < 0;
                    if (0 !== this.negative && !negative1) return -1;
                    if (0 === this.negative && negative1) return 1;
                    if (this._strip(), this.length > 1) res1 = 1;
                    else {
                        negative1 && (num1 = -num1), assert1(num1 <= 0x3ffffff, 'Number is too big');
                        var w19 = 0 | this.words[0];
                        res1 = w19 === num1 ? 0 : w19 < num1 ? -1 : 1;
                    }
                    return 0 !== this.negative ? 0 | -res1 : res1;
                }, BN1.prototype.cmp = function(num1) {
                    if (0 !== this.negative && 0 === num1.negative) return -1;
                    if (0 === this.negative && 0 !== num1.negative) return 1;
                    var res1 = this.ucmp(num1);
                    return 0 !== this.negative ? 0 | -res1 : res1;
                }, BN1.prototype.ucmp = function(num1) {
                    if (this.length > num1.length) return 1;
                    if (this.length < num1.length) return -1;
                    for(var res1 = 0, i2 = this.length - 1; i2 >= 0; i2--){
                        var a10 = 0 | this.words[i2], b10 = 0 | num1.words[i2];
                        if (a10 !== b10) {
                            a10 < b10 ? res1 = -1 : a10 > b10 && (res1 = 1);
                            break;
                        }
                    }
                    return res1;
                }, BN1.prototype.gtn = function(num1) {
                    return 1 === this.cmpn(num1);
                }, BN1.prototype.gt = function(num1) {
                    return 1 === this.cmp(num1);
                }, BN1.prototype.gten = function(num1) {
                    return this.cmpn(num1) >= 0;
                }, BN1.prototype.gte = function(num1) {
                    return this.cmp(num1) >= 0;
                }, BN1.prototype.ltn = function(num1) {
                    return -1 === this.cmpn(num1);
                }, BN1.prototype.lt = function(num1) {
                    return -1 === this.cmp(num1);
                }, BN1.prototype.lten = function(num1) {
                    return 0 >= this.cmpn(num1);
                }, BN1.prototype.lte = function(num1) {
                    return 0 >= this.cmp(num1);
                }, BN1.prototype.eqn = function(num1) {
                    return 0 === this.cmpn(num1);
                }, BN1.prototype.eq = function(num1) {
                    return 0 === this.cmp(num1);
                }, BN1.red = function(num1) {
                    return new Red1(num1);
                }, BN1.prototype.toRed = function(ctx1) {
                    return assert1(!this.red, 'Already a number in reduction context'), assert1(0 === this.negative, 'red works only with positives'), ctx1.convertTo(this)._forceRed(ctx1);
                }, BN1.prototype.fromRed = function() {
                    return assert1(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this);
                }, BN1.prototype._forceRed = function(ctx1) {
                    return this.red = ctx1, this;
                }, BN1.prototype.forceRed = function(ctx1) {
                    return assert1(!this.red, 'Already a number in reduction context'), this._forceRed(ctx1);
                }, BN1.prototype.redAdd = function(num1) {
                    return assert1(this.red, 'redAdd works only with red numbers'), this.red.add(this, num1);
                }, BN1.prototype.redIAdd = function(num1) {
                    return assert1(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, num1);
                }, BN1.prototype.redSub = function(num1) {
                    return assert1(this.red, 'redSub works only with red numbers'), this.red.sub(this, num1);
                }, BN1.prototype.redISub = function(num1) {
                    return assert1(this.red, 'redISub works only with red numbers'), this.red.isub(this, num1);
                }, BN1.prototype.redShl = function(num1) {
                    return assert1(this.red, 'redShl works only with red numbers'), this.red.shl(this, num1);
                }, BN1.prototype.redMul = function(num1) {
                    return assert1(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num1), this.red.mul(this, num1);
                }, BN1.prototype.redIMul = function(num1) {
                    return assert1(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num1), this.red.imul(this, num1);
                }, BN1.prototype.redSqr = function() {
                    return assert1(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this);
                }, BN1.prototype.redISqr = function() {
                    return assert1(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this);
                }, BN1.prototype.redSqrt = function() {
                    return assert1(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this);
                }, BN1.prototype.redInvm = function() {
                    return assert1(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this);
                }, BN1.prototype.redNeg = function() {
                    return assert1(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this);
                }, BN1.prototype.redPow = function(num1) {
                    return assert1(this.red && !num1.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, num1);
                };
                var primes1 = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                function MPrime1(name1, p3) {
                    this.name = name1, this.p = new BN1(p3, 16), this.n = this.p.bitLength(), this.k = new BN1(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
                }
                function K2561() {
                    MPrime1.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
                }
                function P2241() {
                    MPrime1.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
                }
                function P1921() {
                    MPrime1.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
                }
                function P255191() {
                    MPrime1.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
                }
                function Red1(m1) {
                    if ('string' == typeof m1) {
                        var prime1 = BN1._prime(m1);
                        this.m = prime1.p, this.prime = prime1;
                    } else assert1(m1.gtn(1), 'modulus must be greater than 1'), this.m = m1, this.prime = null;
                }
                function Mont1(m1) {
                    Red1.call(this, m1), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new BN1(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
                }
                MPrime1.prototype._tmp = function() {
                    var tmp1 = new BN1(null);
                    return tmp1.words = Array(Math.ceil(this.n / 13)), tmp1;
                }, MPrime1.prototype.ireduce = function(num1) {
                    var rlen1, r3 = num1;
                    do this.split(r3, this.tmp), rlen1 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
                    while (rlen1 > this.n)
                    var cmp1 = rlen1 < this.n ? -1 : r3.ucmp(this.p);
                    return 0 === cmp1 ? (r3.words[0] = 0, r3.length = 1) : cmp1 > 0 ? r3.isub(this.p) : void 0 !== r3.strip ? r3.strip() : r3._strip(), r3;
                }, MPrime1.prototype.split = function(input1, out1) {
                    input1.iushrn(this.n, 0, out1);
                }, MPrime1.prototype.imulK = function(num1) {
                    return num1.imul(this.k);
                }, inherits1(K2561, MPrime1), K2561.prototype.split = function(input1, output1) {
                    for(var mask1 = 0x3fffff, outLen1 = Math.min(input1.length, 9), i2 = 0; i2 < outLen1; i2++)output1.words[i2] = input1.words[i2];
                    if (output1.length = outLen1, input1.length <= 9) {
                        input1.words[0] = 0, input1.length = 1;
                        return;
                    }
                    var prev1 = input1.words[9];
                    for(i2 = 10, output1.words[output1.length++] = prev1 & mask1; i2 < input1.length; i2++){
                        var next1 = 0 | input1.words[i2];
                        input1.words[i2 - 10] = (next1 & mask1) << 4 | prev1 >>> 22, prev1 = next1;
                    }
                    prev1 >>>= 22, input1.words[i2 - 10] = prev1, 0 === prev1 && input1.length > 10 ? input1.length -= 10 : input1.length -= 9;
                }, K2561.prototype.imulK = function(num1) {
                    num1.words[num1.length] = 0, num1.words[num1.length + 1] = 0, num1.length += 2;
                    for(var lo1 = 0, i2 = 0; i2 < num1.length; i2++){
                        var w19 = 0 | num1.words[i2];
                        lo1 += 0x3d1 * w19, num1.words[i2] = 0x3ffffff & lo1, lo1 = 0x40 * w19 + (lo1 / 0x4000000 | 0);
                    }
                    return 0 === num1.words[num1.length - 1] && (num1.length--, 0 === num1.words[num1.length - 1] && num1.length--), num1;
                }, inherits1(P2241, MPrime1), inherits1(P1921, MPrime1), inherits1(P255191, MPrime1), P255191.prototype.imulK = function(num1) {
                    for(var carry1 = 0, i2 = 0; i2 < num1.length; i2++){
                        var hi1 = (0 | num1.words[i2]) * 0x13 + carry1, lo1 = 0x3ffffff & hi1;
                        hi1 >>>= 26, num1.words[i2] = lo1, carry1 = hi1;
                    }
                    return 0 !== carry1 && (num1.words[num1.length++] = carry1), num1;
                }, BN1._prime = function(name1) {
                    var prime1;
                    if (primes1[name1]) return primes1[name1];
                    if ('k256' === name1) prime1 = new K2561();
                    else if ('p224' === name1) prime1 = new P2241();
                    else if ('p192' === name1) prime1 = new P1921();
                    else if ('p25519' === name1) prime1 = new P255191();
                    else throw Error('Unknown prime ' + name1);
                    return primes1[name1] = prime1, prime1;
                }, Red1.prototype._verify1 = function(a10) {
                    assert1(0 === a10.negative, 'red works only with positives'), assert1(a10.red, 'red works only with red numbers');
                }, Red1.prototype._verify2 = function(a10, b10) {
                    assert1((a10.negative | b10.negative) == 0, 'red works only with positives'), assert1(a10.red && a10.red === b10.red, 'red works only with red numbers');
                }, Red1.prototype.imod = function(a10) {
                    return this.prime ? this.prime.ireduce(a10)._forceRed(this) : (move1(a10, a10.umod(this.m)._forceRed(this)), a10);
                }, Red1.prototype.neg = function(a10) {
                    return a10.isZero() ? a10.clone() : this.m.sub(a10)._forceRed(this);
                }, Red1.prototype.add = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.add(b10);
                    return res1.cmp(this.m) >= 0 && res1.isub(this.m), res1._forceRed(this);
                }, Red1.prototype.iadd = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.iadd(b10);
                    return res1.cmp(this.m) >= 0 && res1.isub(this.m), res1;
                }, Red1.prototype.sub = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.sub(b10);
                    return 0 > res1.cmpn(0) && res1.iadd(this.m), res1._forceRed(this);
                }, Red1.prototype.isub = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.isub(b10);
                    return 0 > res1.cmpn(0) && res1.iadd(this.m), res1;
                }, Red1.prototype.shl = function(a10, num1) {
                    return this._verify1(a10), this.imod(a10.ushln(num1));
                }, Red1.prototype.imul = function(a10, b10) {
                    return this._verify2(a10, b10), this.imod(a10.imul(b10));
                }, Red1.prototype.mul = function(a10, b10) {
                    return this._verify2(a10, b10), this.imod(a10.mul(b10));
                }, Red1.prototype.isqr = function(a10) {
                    return this.imul(a10, a10.clone());
                }, Red1.prototype.sqr = function(a10) {
                    return this.mul(a10, a10);
                }, Red1.prototype.sqrt = function(a10) {
                    if (a10.isZero()) return a10.clone();
                    var mod31 = this.m.andln(3);
                    if (assert1(mod31 % 2 == 1), 3 === mod31) {
                        var pow1 = this.m.add(new BN1(1)).iushrn(2);
                        return this.pow(a10, pow1);
                    }
                    for(var q3 = this.m.subn(1), s3 = 0; !q3.isZero() && 0 === q3.andln(1);)s3++, q3.iushrn(1);
                    assert1(!q3.isZero());
                    var one1 = new BN1(1).toRed(this), nOne1 = one1.redNeg(), lpow1 = this.m.subn(1).iushrn(1), z1 = this.m.bitLength();
                    for(z1 = new BN1(2 * z1 * z1).toRed(this); 0 !== this.pow(z1, lpow1).cmp(nOne1);)z1.redIAdd(nOne1);
                    for(var c5 = this.pow(z1, q3), r3 = this.pow(a10, q3.addn(1).iushrn(1)), t3 = this.pow(a10, q3), m1 = s3; 0 !== t3.cmp(one1);){
                        for(var tmp1 = t3, i2 = 0; 0 !== tmp1.cmp(one1); i2++)tmp1 = tmp1.redSqr();
                        assert1(i2 < m1);
                        var b10 = this.pow(c5, new BN1(1).iushln(m1 - i2 - 1));
                        r3 = r3.redMul(b10), c5 = b10.redSqr(), t3 = t3.redMul(c5), m1 = i2;
                    }
                    return r3;
                }, Red1.prototype.invm = function(a10) {
                    var inv1 = a10._invmp(this.m);
                    return 0 !== inv1.negative ? (inv1.negative = 0, this.imod(inv1).redNeg()) : this.imod(inv1);
                }, Red1.prototype.pow = function(a10, num1) {
                    if (num1.isZero()) return new BN1(1).toRed(this);
                    if (0 === num1.cmpn(1)) return a10.clone();
                    var windowSize1 = 4, wnd1 = Array(16);
                    wnd1[0] = new BN1(1).toRed(this), wnd1[1] = a10;
                    for(var i2 = 2; i2 < wnd1.length; i2++)wnd1[i2] = this.mul(wnd1[i2 - 1], a10);
                    var res1 = wnd1[0], current1 = 0, currentLen1 = 0, start1 = num1.bitLength() % 26;
                    for(0 === start1 && (start1 = 26), i2 = num1.length - 1; i2 >= 0; i2--){
                        for(var word1 = num1.words[i2], j1 = start1 - 1; j1 >= 0; j1--){
                            var bit1 = word1 >> j1 & 1;
                            if (res1 !== wnd1[0] && (res1 = this.sqr(res1)), 0 === bit1 && 0 === current1) {
                                currentLen1 = 0;
                                continue;
                            }
                            current1 <<= 1, current1 |= bit1, (++currentLen1 === windowSize1 || 0 === i2 && 0 === j1) && (res1 = this.mul(res1, wnd1[current1]), currentLen1 = 0, current1 = 0);
                        }
                        start1 = 26;
                    }
                    return res1;
                }, Red1.prototype.convertTo = function(num1) {
                    var r3 = num1.umod(this.m);
                    return r3 === num1 ? r3.clone() : r3;
                }, Red1.prototype.convertFrom = function(num1) {
                    var res1 = num1.clone();
                    return res1.red = null, res1;
                }, BN1.mont = function(num1) {
                    return new Mont1(num1);
                }, inherits1(Mont1, Red1), Mont1.prototype.convertTo = function(num1) {
                    return this.imod(num1.ushln(this.shift));
                }, Mont1.prototype.convertFrom = function(num1) {
                    var r3 = this.imod(num1.mul(this.rinv));
                    return r3.red = null, r3;
                }, Mont1.prototype.imul = function(a10, b10) {
                    if (a10.isZero() || b10.isZero()) return a10.words[0] = 0, a10.length = 1, a10;
                    var t3 = a10.imul(b10), c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = t3.isub(c5).iushrn(this.shift), res1 = u3;
                    return u3.cmp(this.m) >= 0 ? res1 = u3.isub(this.m) : 0 > u3.cmpn(0) && (res1 = u3.iadd(this.m)), res1._forceRed(this);
                }, Mont1.prototype.mul = function(a10, b10) {
                    if (a10.isZero() || b10.isZero()) return new BN1(0)._forceRed(this);
                    var t3 = a10.mul(b10), c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = t3.isub(c5).iushrn(this.shift), res1 = u3;
                    return u3.cmp(this.m) >= 0 ? res1 = u3.isub(this.m) : 0 > u3.cmpn(0) && (res1 = u3.iadd(this.m)), res1._forceRed(this);
                }, Mont1.prototype.invm = function(a10) {
                    return this.imod(a10._invmp(this.m).mul(this.r2))._forceRed(this);
                };
            }(module1 = __webpack_require__1.nmd(module1), this);
        },
        9464: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { fromCallback: fromCallback1  } = __webpack_require__1(6957), ModuleError1 = __webpack_require__1(4473), { getCallback: getCallback1 , getOptions: getOptions1  } = __webpack_require__1(2520), kPromise1 = Symbol('promise'), kStatus1 = Symbol('status'), kOperations1 = Symbol('operations'), kFinishClose1 = Symbol('finishClose'), kCloseCallbacks1 = Symbol('closeCallbacks');
            class AbstractChainedBatch1 {
                constructor(db1){
                    if ('object' != typeof db1 || null === db1) {
                        const hint1 = null === db1 ? 'null' : typeof db1;
                        throw TypeError(`The first argument must be an abstract-level database, received ${hint1}`);
                    }
                    this[kOperations1] = [], this[kCloseCallbacks1] = [], this[kStatus1] = 'open', this[kFinishClose1] = this[kFinishClose1].bind(this), this.db = db1, this.db.attachResource(this), this.nextTick = db1.nextTick;
                }
                get length() {
                    return this[kOperations1].length;
                }
                put(key1, value1, options1) {
                    if ('open' !== this[kStatus1]) throw new ModuleError1('Batch is not open: cannot call put() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    });
                    const err1 = this.db._checkKey(key1) || this.db._checkValue(value1);
                    if (err1) throw err1;
                    const db1 = options1 && null != options1.sublevel ? options1.sublevel : this.db, original1 = options1, keyEncoding1 = db1.keyEncoding(options1 && options1.keyEncoding), valueEncoding1 = db1.valueEncoding(options1 && options1.valueEncoding), keyFormat1 = keyEncoding1.format;
                    options1 = {
                        ...options1,
                        keyEncoding: keyFormat1,
                        valueEncoding: valueEncoding1.format
                    }, db1 !== this.db && (options1.sublevel = null);
                    const mappedKey1 = db1.prefixKey(keyEncoding1.encode(key1), keyFormat1), mappedValue1 = valueEncoding1.encode(value1);
                    return this._put(mappedKey1, mappedValue1, options1), this[kOperations1].push({
                        ...original1,
                        type: 'put',
                        key: key1,
                        value: value1
                    }), this;
                }
                _put(key1, value1, options1) {}
                del(key1, options1) {
                    if ('open' !== this[kStatus1]) throw new ModuleError1('Batch is not open: cannot call del() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    });
                    const err1 = this.db._checkKey(key1);
                    if (err1) throw err1;
                    const db1 = options1 && null != options1.sublevel ? options1.sublevel : this.db, original1 = options1, keyEncoding1 = db1.keyEncoding(options1 && options1.keyEncoding), keyFormat1 = keyEncoding1.format;
                    return options1 = {
                        ...options1,
                        keyEncoding: keyFormat1
                    }, db1 !== this.db && (options1.sublevel = null), this._del(db1.prefixKey(keyEncoding1.encode(key1), keyFormat1), options1), this[kOperations1].push({
                        ...original1,
                        type: 'del',
                        key: key1
                    }), this;
                }
                _del(key1, options1) {}
                clear() {
                    if ('open' !== this[kStatus1]) throw new ModuleError1('Batch is not open: cannot call clear() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    });
                    return this._clear(), this[kOperations1] = [], this;
                }
                _clear() {}
                write(options1, callback1) {
                    return callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1), 'open' !== this[kStatus1] ? this.nextTick(callback1, new ModuleError1('Batch is not open: cannot call write() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    })) : 0 === this.length ? this.close(callback1) : (this[kStatus1] = 'writing', this._write(options1, (err1)=>{
                        this[kStatus1] = 'closing', this[kCloseCallbacks1].push(()=>callback1(err1)), err1 || this.db.emit('batch', this[kOperations1]), this._close(this[kFinishClose1]);
                    })), callback1[kPromise1];
                }
                _write(options1, callback1) {}
                close(callback1) {
                    return callback1 = fromCallback1(callback1, kPromise1), 'closing' === this[kStatus1] ? this[kCloseCallbacks1].push(callback1) : 'closed' === this[kStatus1] ? this.nextTick(callback1) : (this[kCloseCallbacks1].push(callback1), 'writing' !== this[kStatus1] && (this[kStatus1] = 'closing', this._close(this[kFinishClose1]))), callback1[kPromise1];
                }
                _close(callback1) {
                    this.nextTick(callback1);
                }
                [kFinishClose1]() {
                    this[kStatus1] = 'closed', this.db.detachResource(this);
                    const callbacks1 = this[kCloseCallbacks1];
                    for (const cb1 of (this[kCloseCallbacks1] = [], callbacks1))cb1();
                }
            }
            exports1.AbstractChainedBatch = AbstractChainedBatch1;
        },
        3961: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { fromCallback: fromCallback1  } = __webpack_require__1(6957), ModuleError1 = __webpack_require__1(4473), { getOptions: getOptions1 , getCallback: getCallback1  } = __webpack_require__1(2520), kPromise1 = Symbol('promise'), kCallback1 = Symbol('callback'), kWorking1 = Symbol('working'), kHandleOne1 = Symbol('handleOne'), kHandleMany1 = Symbol('handleMany'), kAutoClose1 = Symbol('autoClose'), kFinishWork1 = Symbol('finishWork'), kReturnMany1 = Symbol('returnMany'), kClosing1 = Symbol('closing'), kHandleClose1 = Symbol('handleClose'), kClosed1 = Symbol('closed'), kCloseCallbacks1 = Symbol('closeCallbacks'), kKeyEncoding1 = Symbol('keyEncoding'), kValueEncoding1 = Symbol('valueEncoding'), kAbortOnClose1 = Symbol('abortOnClose'), kLegacy1 = Symbol('legacy'), kKeys1 = Symbol('keys'), kValues1 = Symbol('values'), kLimit1 = Symbol('limit'), kCount1 = Symbol('count'), emptyOptions1 = Object.freeze({}), noop1 = ()=>{};
            let warnedEnd1 = !1;
            class CommonIterator1 {
                constructor(db1, options1, legacy1){
                    if ('object' != typeof db1 || null === db1) {
                        const hint1 = null === db1 ? 'null' : typeof db1;
                        throw TypeError(`The first argument must be an abstract-level database, received ${hint1}`);
                    }
                    if ('object' != typeof options1 || null === options1) throw TypeError('The second argument must be an options object');
                    this[kClosed1] = !1, this[kCloseCallbacks1] = [], this[kWorking1] = !1, this[kClosing1] = !1, this[kAutoClose1] = !1, this[kCallback1] = null, this[kHandleOne1] = this[kHandleOne1].bind(this), this[kHandleMany1] = this[kHandleMany1].bind(this), this[kHandleClose1] = this[kHandleClose1].bind(this), this[kKeyEncoding1] = options1[kKeyEncoding1], this[kValueEncoding1] = options1[kValueEncoding1], this[kLegacy1] = legacy1, this[kLimit1] = Number.isInteger(options1.limit) && options1.limit >= 0 ? options1.limit : 1 / 0, this[kCount1] = 0, this[kAbortOnClose1] = !!options1.abortOnClose, this.db = db1, this.db.attachResource(this), this.nextTick = db1.nextTick;
                }
                get count() {
                    return this[kCount1];
                }
                get limit() {
                    return this[kLimit1];
                }
                next(callback1) {
                    let promise1;
                    if (void 0 === callback1) promise1 = new Promise((resolve1, reject1)=>{
                        callback1 = (err1, key1, value1)=>{
                            err1 ? reject1(err1) : this[kLegacy1] ? void 0 === key1 && void 0 === value1 ? resolve1() : resolve1([
                                key1,
                                value1
                            ]) : resolve1(key1);
                        };
                    });
                    else if ('function' != typeof callback1) throw TypeError('Callback must be a function');
                    return this[kClosing1] ? this.nextTick(callback1, new ModuleError1('Iterator is not open: cannot call next() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    })) : this[kWorking1] ? this.nextTick(callback1, new ModuleError1('Iterator is busy: cannot call next() until previous call has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    })) : (this[kWorking1] = !0, this[kCallback1] = callback1, this[kCount1] >= this[kLimit1] ? this.nextTick(this[kHandleOne1], null) : this._next(this[kHandleOne1])), promise1;
                }
                _next(callback1) {
                    this.nextTick(callback1);
                }
                nextv(size1, options1, callback1) {
                    return (callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, emptyOptions1), Number.isInteger(size1)) ? (this[kClosing1] ? this.nextTick(callback1, new ModuleError1('Iterator is not open: cannot call nextv() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    })) : this[kWorking1] ? this.nextTick(callback1, new ModuleError1('Iterator is busy: cannot call nextv() until previous call has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    })) : (size1 < 1 && (size1 = 1), this[kLimit1] < 1 / 0 && (size1 = Math.min(size1, this[kLimit1] - this[kCount1])), this[kWorking1] = !0, this[kCallback1] = callback1, size1 <= 0 ? this.nextTick(this[kHandleMany1], null, []) : this._nextv(size1, options1, this[kHandleMany1])), callback1[kPromise1]) : (this.nextTick(callback1, TypeError("The first argument 'size' must be an integer")), callback1[kPromise1]);
                }
                _nextv(size1, options1, callback1) {
                    const acc1 = [], onnext1 = (err1, key1, value1)=>err1 ? callback1(err1) : (this[kLegacy1] ? void 0 === key1 && void 0 === value1 : void 0 === key1) ? callback1(null, acc1) : void (acc1.push(this[kLegacy1] ? [
                            key1,
                            value1
                        ] : key1), acc1.length === size1 ? callback1(null, acc1) : this._next(onnext1));
                    this._next(onnext1);
                }
                all(options1, callback1) {
                    return callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, emptyOptions1), this[kClosing1] ? this.nextTick(callback1, new ModuleError1('Iterator is not open: cannot call all() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    })) : this[kWorking1] ? this.nextTick(callback1, new ModuleError1('Iterator is busy: cannot call all() until previous call has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    })) : (this[kWorking1] = !0, this[kCallback1] = callback1, this[kAutoClose1] = !0, this[kCount1] >= this[kLimit1] ? this.nextTick(this[kHandleMany1], null, []) : this._all(options1, this[kHandleMany1])), callback1[kPromise1];
                }
                _all(options1, callback1) {
                    let count1 = this[kCount1];
                    const acc1 = [], nextv1 = ()=>{
                        const size1 = this[kLimit1] < 1 / 0 ? Math.min(1e3, this[kLimit1] - count1) : 1e3;
                        size1 <= 0 ? this.nextTick(callback1, null, acc1) : this._nextv(size1, emptyOptions1, onnextv1);
                    }, onnextv1 = (err1, items1)=>{
                        err1 ? callback1(err1) : 0 === items1.length ? callback1(null, acc1) : (acc1.push.apply(acc1, items1), count1 += items1.length, nextv1());
                    };
                    nextv1();
                }
                [kFinishWork1]() {
                    const cb1 = this[kCallback1];
                    return this[kAbortOnClose1] && null === cb1 ? noop1 : (this[kWorking1] = !1, this[kCallback1] = null, this[kClosing1] && this._close(this[kHandleClose1]), cb1);
                }
                [kReturnMany1](cb1, err1, items1) {
                    this[kAutoClose1] ? this.close(cb1.bind(null, err1, items1)) : cb1(err1, items1);
                }
                seek(target1, options1) {
                    if (options1 = getOptions1(options1, emptyOptions1), this[kClosing1]) ;
                    else if (this[kWorking1]) throw new ModuleError1('Iterator is busy: cannot call seek() until next() has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    });
                    else {
                        const keyEncoding1 = this.db.keyEncoding(options1.keyEncoding || this[kKeyEncoding1]), keyFormat1 = keyEncoding1.format;
                        options1.keyEncoding !== keyFormat1 && (options1 = {
                            ...options1,
                            keyEncoding: keyFormat1
                        });
                        const mapped1 = this.db.prefixKey(keyEncoding1.encode(target1), keyFormat1);
                        this._seek(mapped1, options1);
                    }
                }
                _seek(target1, options1) {
                    throw new ModuleError1('Iterator does not support seek()', {
                        code: 'LEVEL_NOT_SUPPORTED'
                    });
                }
                close(callback1) {
                    if (callback1 = fromCallback1(callback1, kPromise1), this[kClosed1]) this.nextTick(callback1);
                    else if (this[kClosing1]) this[kCloseCallbacks1].push(callback1);
                    else if (this[kClosing1] = !0, this[kCloseCallbacks1].push(callback1), this[kWorking1]) {
                        if (this[kAbortOnClose1]) {
                            const cb1 = this[kFinishWork1]();
                            cb1(new ModuleError1('Aborted on iterator close()', {
                                code: 'LEVEL_ITERATOR_NOT_OPEN'
                            }));
                        }
                    } else this._close(this[kHandleClose1]);
                    return callback1[kPromise1];
                }
                _close(callback1) {
                    this.nextTick(callback1);
                }
                [kHandleClose1]() {
                    this[kClosed1] = !0, this.db.detachResource(this);
                    const callbacks1 = this[kCloseCallbacks1];
                    for (const cb1 of (this[kCloseCallbacks1] = [], callbacks1))cb1();
                }
                async *[Symbol.asyncIterator]() {
                    try {
                        let item1;
                        for(; void 0 !== (item1 = await this.next());)yield item1;
                    } finally{
                        this[kClosed1] || await this.close();
                    }
                }
            }
            class AbstractIterator1 extends CommonIterator1 {
                constructor(db1, options1){
                    super(db1, options1, !0), this[kKeys1] = !1 !== options1.keys, this[kValues1] = !1 !== options1.values;
                }
                [kHandleOne1](err1, key1, value1) {
                    const cb1 = this[kFinishWork1]();
                    if (err1) return cb1(err1);
                    try {
                        key1 = this[kKeys1] && void 0 !== key1 ? this[kKeyEncoding1].decode(key1) : void 0, value1 = this[kValues1] && void 0 !== value1 ? this[kValueEncoding1].decode(value1) : void 0;
                    } catch (err1) {
                        return cb1(new IteratorDecodeError1('entry', err1));
                    }
                    !(void 0 === key1 && void 0 === value1) && this[kCount1]++, cb1(null, key1, value1);
                }
                [kHandleMany1](err1, entries1) {
                    const cb1 = this[kFinishWork1]();
                    if (err1) return this[kReturnMany1](cb1, err1);
                    try {
                        for (const entry1 of entries1){
                            const key1 = entry1[0], value1 = entry1[1];
                            entry1[0] = this[kKeys1] && void 0 !== key1 ? this[kKeyEncoding1].decode(key1) : void 0, entry1[1] = this[kValues1] && void 0 !== value1 ? this[kValueEncoding1].decode(value1) : void 0;
                        }
                    } catch (err1) {
                        return this[kReturnMany1](cb1, new IteratorDecodeError1('entries', err1));
                    }
                    this[kCount1] += entries1.length, this[kReturnMany1](cb1, null, entries1);
                }
                end(callback1) {
                    return warnedEnd1 || 'undefined' == typeof console || (warnedEnd1 = !0, console.warn(new ModuleError1('The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version', {
                        code: 'LEVEL_LEGACY'
                    }))), this.close(callback1);
                }
            }
            class AbstractKeyIterator1 extends CommonIterator1 {
                constructor(db1, options1){
                    super(db1, options1, !1);
                }
                [kHandleOne1](err1, key1) {
                    const cb1 = this[kFinishWork1]();
                    if (err1) return cb1(err1);
                    try {
                        key1 = void 0 !== key1 ? this[kKeyEncoding1].decode(key1) : void 0;
                    } catch (err1) {
                        return cb1(new IteratorDecodeError1('key', err1));
                    }
                    void 0 !== key1 && this[kCount1]++, cb1(null, key1);
                }
                [kHandleMany1](err1, keys1) {
                    const cb1 = this[kFinishWork1]();
                    if (err1) return this[kReturnMany1](cb1, err1);
                    try {
                        for(let i2 = 0; i2 < keys1.length; i2++){
                            const key1 = keys1[i2];
                            keys1[i2] = void 0 !== key1 ? this[kKeyEncoding1].decode(key1) : void 0;
                        }
                    } catch (err1) {
                        return this[kReturnMany1](cb1, new IteratorDecodeError1('keys', err1));
                    }
                    this[kCount1] += keys1.length, this[kReturnMany1](cb1, null, keys1);
                }
            }
            class AbstractValueIterator1 extends CommonIterator1 {
                constructor(db1, options1){
                    super(db1, options1, !1);
                }
                [kHandleOne1](err1, value1) {
                    const cb1 = this[kFinishWork1]();
                    if (err1) return cb1(err1);
                    try {
                        value1 = void 0 !== value1 ? this[kValueEncoding1].decode(value1) : void 0;
                    } catch (err1) {
                        return cb1(new IteratorDecodeError1('value', err1));
                    }
                    void 0 !== value1 && this[kCount1]++, cb1(null, value1);
                }
                [kHandleMany1](err1, values1) {
                    const cb1 = this[kFinishWork1]();
                    if (err1) return this[kReturnMany1](cb1, err1);
                    try {
                        for(let i2 = 0; i2 < values1.length; i2++){
                            const value1 = values1[i2];
                            values1[i2] = void 0 !== value1 ? this[kValueEncoding1].decode(value1) : void 0;
                        }
                    } catch (err1) {
                        return this[kReturnMany1](cb1, new IteratorDecodeError1('values', err1));
                    }
                    this[kCount1] += values1.length, this[kReturnMany1](cb1, null, values1);
                }
            }
            class IteratorDecodeError1 extends ModuleError1 {
                constructor(subject1, cause1){
                    super(`Iterator could not decode ${subject1}`, {
                        code: 'LEVEL_DECODE_ERROR',
                        cause: cause1
                    });
                }
            }
            for (const k3 of [
                '_ended property',
                '_nexting property',
                '_end method'
            ])Object.defineProperty(AbstractIterator1.prototype, k3.split(' ')[0], {
                get () {
                    throw new ModuleError1(`The ${k3} has been removed`, {
                        code: 'LEVEL_LEGACY'
                    });
                },
                set () {
                    throw new ModuleError1(`The ${k3} has been removed`, {
                        code: 'LEVEL_LEGACY'
                    });
                }
            });
            AbstractIterator1.keyEncoding = kKeyEncoding1, AbstractIterator1.valueEncoding = kValueEncoding1, exports1.AbstractIterator = AbstractIterator1, exports1.AbstractKeyIterator = AbstractKeyIterator1, exports1.AbstractValueIterator = AbstractValueIterator1;
        },
        9071: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { supports: supports1  } = __webpack_require__1(1675), { Transcoder: Transcoder1  } = __webpack_require__1(8499), { EventEmitter: EventEmitter1  } = __webpack_require__1(7187), { fromCallback: fromCallback1  } = __webpack_require__1(6957), ModuleError1 = __webpack_require__1(4473), { AbstractIterator: AbstractIterator1  } = __webpack_require__1(3961), { DefaultKeyIterator: DefaultKeyIterator1 , DefaultValueIterator: DefaultValueIterator1  } = __webpack_require__1(5429), { DeferredIterator: DeferredIterator1 , DeferredKeyIterator: DeferredKeyIterator1 , DeferredValueIterator: DeferredValueIterator1  } = __webpack_require__1(593), { DefaultChainedBatch: DefaultChainedBatch1  } = __webpack_require__1(4765), { getCallback: getCallback1 , getOptions: getOptions1  } = __webpack_require__1(2520), rangeOptions1 = __webpack_require__1(56), kPromise1 = Symbol('promise'), kLanded1 = Symbol('landed'), kResources1 = Symbol('resources'), kCloseResources1 = Symbol('closeResources'), kOperations1 = Symbol('operations'), kUndefer1 = Symbol('undefer'), kDeferOpen1 = Symbol('deferOpen'), kOptions1 = Symbol('options'), kStatus1 = Symbol('status'), kDefaultOptions1 = Symbol('defaultOptions'), kTranscoder1 = Symbol('transcoder'), kKeyEncoding1 = Symbol('keyEncoding'), kValueEncoding1 = Symbol('valueEncoding'), noop1 = ()=>{};
            class AbstractLevel1 extends EventEmitter1 {
                constructor(manifest1, options1){
                    if (super(), 'object' != typeof manifest1 || null === manifest1) throw TypeError("The first argument 'manifest' must be an object");
                    options1 = getOptions1(options1);
                    const { keyEncoding: keyEncoding1 , valueEncoding: valueEncoding1 , passive: passive1 , ...forward1 } = options1;
                    for (const encoding1 of (this[kResources1] = new Set(), this[kOperations1] = [], this[kDeferOpen1] = !0, this[kOptions1] = forward1, this[kStatus1] = 'opening', this.supports = supports1(manifest1, {
                        status: !0,
                        promises: !0,
                        clear: !0,
                        getMany: !0,
                        deferredOpen: !0,
                        snapshots: !1 !== manifest1.snapshots,
                        permanence: !1 !== manifest1.permanence,
                        keyIterator: !0,
                        valueIterator: !0,
                        iteratorNextv: !0,
                        iteratorAll: !0,
                        encodings: manifest1.encodings || {},
                        events: Object.assign({}, manifest1.events, {
                            opening: !0,
                            open: !0,
                            closing: !0,
                            closed: !0,
                            put: !0,
                            del: !0,
                            batch: !0,
                            clear: !0
                        })
                    }), this[kTranscoder1] = new Transcoder1(formats1(this)), this[kKeyEncoding1] = this[kTranscoder1].encoding(keyEncoding1 || 'utf8'), this[kValueEncoding1] = this[kTranscoder1].encoding(valueEncoding1 || 'utf8'), this[kTranscoder1].encodings()))this.supports.encodings[encoding1.commonName] || (this.supports.encodings[encoding1.commonName] = !0);
                    this[kDefaultOptions1] = {
                        empty: Object.freeze({}),
                        entry: Object.freeze({
                            keyEncoding: this[kKeyEncoding1].commonName,
                            valueEncoding: this[kValueEncoding1].commonName
                        }),
                        key: Object.freeze({
                            keyEncoding: this[kKeyEncoding1].commonName
                        })
                    }, this.nextTick(()=>{
                        this[kDeferOpen1] && this.open({
                            passive: !1
                        }, noop1);
                    });
                }
                get status() {
                    return this[kStatus1];
                }
                keyEncoding(encoding1) {
                    return this[kTranscoder1].encoding(null != encoding1 ? encoding1 : this[kKeyEncoding1]);
                }
                valueEncoding(encoding1) {
                    return this[kTranscoder1].encoding(null != encoding1 ? encoding1 : this[kValueEncoding1]);
                }
                open(options1, callback1) {
                    callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), (options1 = {
                        ...this[kOptions1],
                        ...getOptions1(options1)
                    }).createIfMissing = !1 !== options1.createIfMissing, options1.errorIfExists = !!options1.errorIfExists;
                    const maybeOpened1 = (err1)=>{
                        'closing' === this[kStatus1] || 'opening' === this[kStatus1] ? this.once(kLanded1, err1 ? ()=>maybeOpened1(err1) : maybeOpened1) : 'open' !== this[kStatus1] ? callback1(new ModuleError1('Database is not open', {
                            code: 'LEVEL_DATABASE_NOT_OPEN',
                            cause: err1
                        })) : callback1();
                    };
                    return options1.passive ? 'opening' === this[kStatus1] ? this.once(kLanded1, maybeOpened1) : this.nextTick(maybeOpened1) : 'closed' === this[kStatus1] || this[kDeferOpen1] ? (this[kDeferOpen1] = !1, this[kStatus1] = 'opening', this.emit('opening'), this._open(options1, (err1)=>{
                        if (err1) {
                            this[kStatus1] = 'closed', this[kCloseResources1](()=>{
                                this.emit(kLanded1), maybeOpened1(err1);
                            }), this[kUndefer1]();
                            return;
                        }
                        this[kStatus1] = 'open', this[kUndefer1](), this.emit(kLanded1), 'open' === this[kStatus1] && this.emit('open'), 'open' === this[kStatus1] && this.emit('ready'), maybeOpened1();
                    })) : 'open' === this[kStatus1] ? this.nextTick(maybeOpened1) : this.once(kLanded1, ()=>this.open(options1, callback1)), callback1[kPromise1];
                }
                _open(options1, callback1) {
                    this.nextTick(callback1);
                }
                close(callback1) {
                    callback1 = fromCallback1(callback1, kPromise1);
                    const maybeClosed1 = (err1)=>{
                        'opening' === this[kStatus1] || 'closing' === this[kStatus1] ? this.once(kLanded1, err1 ? maybeClosed1(err1) : maybeClosed1) : 'closed' !== this[kStatus1] ? callback1(new ModuleError1('Database is not closed', {
                            code: 'LEVEL_DATABASE_NOT_CLOSED',
                            cause: err1
                        })) : callback1();
                    };
                    if ('open' === this[kStatus1]) {
                        this[kStatus1] = 'closing', this.emit('closing');
                        const cancel1 = (err1)=>{
                            this[kStatus1] = 'open', this[kUndefer1](), this.emit(kLanded1), maybeClosed1(err1);
                        };
                        this[kCloseResources1](()=>{
                            this._close((err1)=>{
                                if (err1) return cancel1(err1);
                                this[kStatus1] = 'closed', this[kUndefer1](), this.emit(kLanded1), 'closed' === this[kStatus1] && this.emit('closed'), maybeClosed1();
                            });
                        });
                    } else 'closed' === this[kStatus1] ? this.nextTick(maybeClosed1) : this.once(kLanded1, ()=>this.close(callback1));
                    return callback1[kPromise1];
                }
                [kCloseResources1](callback1) {
                    if (0 === this[kResources1].size) return this.nextTick(callback1);
                    let pending1 = this[kResources1].size, sync1 = !0;
                    const next1 = ()=>{
                        0 == --pending1 && (sync1 ? this.nextTick(callback1) : callback1());
                    };
                    for (const resource1 of this[kResources1])resource1.close(next1);
                    sync1 = !1, this[kResources1].clear();
                }
                _close(callback1) {
                    this.nextTick(callback1);
                }
                get(key1, options1, callback1) {
                    if (callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, this[kDefaultOptions1].entry), 'opening' === this[kStatus1]) return this.defer(()=>this.get(key1, options1, callback1)), callback1[kPromise1];
                    if (maybeError1(this, callback1)) return callback1[kPromise1];
                    const err1 = this._checkKey(key1);
                    if (err1) return this.nextTick(callback1, err1), callback1[kPromise1];
                    const keyEncoding1 = this.keyEncoding(options1.keyEncoding), valueEncoding1 = this.valueEncoding(options1.valueEncoding), keyFormat1 = keyEncoding1.format, valueFormat1 = valueEncoding1.format;
                    return (options1.keyEncoding !== keyFormat1 || options1.valueEncoding !== valueFormat1) && (options1 = Object.assign({}, options1, {
                        keyEncoding: keyFormat1,
                        valueEncoding: valueFormat1
                    })), this._get(this.prefixKey(keyEncoding1.encode(key1), keyFormat1), options1, (err1, value1)=>{
                        if (err1) return ('LEVEL_NOT_FOUND' === err1.code || err1.notFound || /NotFound/i.test(err1)) && (err1.code || (err1.code = 'LEVEL_NOT_FOUND'), err1.notFound || (err1.notFound = !0), err1.status || (err1.status = 404)), callback1(err1);
                        try {
                            value1 = valueEncoding1.decode(value1);
                        } catch (err1) {
                            return callback1(new ModuleError1('Could not decode value', {
                                code: 'LEVEL_DECODE_ERROR',
                                cause: err1
                            }));
                        }
                        callback1(null, value1);
                    }), callback1[kPromise1];
                }
                _get(key1, options1, callback1) {
                    this.nextTick(callback1, Error('NotFound'));
                }
                getMany(keys1, options1, callback1) {
                    if (callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, this[kDefaultOptions1].entry), 'opening' === this[kStatus1]) return this.defer(()=>this.getMany(keys1, options1, callback1)), callback1[kPromise1];
                    if (maybeError1(this, callback1)) return callback1[kPromise1];
                    if (!Array.isArray(keys1)) return this.nextTick(callback1, TypeError("The first argument 'keys' must be an array")), callback1[kPromise1];
                    if (0 === keys1.length) return this.nextTick(callback1, null, []), callback1[kPromise1];
                    const keyEncoding1 = this.keyEncoding(options1.keyEncoding), valueEncoding1 = this.valueEncoding(options1.valueEncoding), keyFormat1 = keyEncoding1.format, valueFormat1 = valueEncoding1.format;
                    (options1.keyEncoding !== keyFormat1 || options1.valueEncoding !== valueFormat1) && (options1 = Object.assign({}, options1, {
                        keyEncoding: keyFormat1,
                        valueEncoding: valueFormat1
                    }));
                    const mappedKeys1 = Array(keys1.length);
                    for(let i2 = 0; i2 < keys1.length; i2++){
                        const key1 = keys1[i2], err1 = this._checkKey(key1);
                        if (err1) return this.nextTick(callback1, err1), callback1[kPromise1];
                        mappedKeys1[i2] = this.prefixKey(keyEncoding1.encode(key1), keyFormat1);
                    }
                    return this._getMany(mappedKeys1, options1, (err1, values1)=>{
                        if (err1) return callback1(err1);
                        try {
                            for(let i2 = 0; i2 < values1.length; i2++)void 0 !== values1[i2] && (values1[i2] = valueEncoding1.decode(values1[i2]));
                        } catch (err1) {
                            return callback1(new ModuleError1(`Could not decode one or more of ${values1.length} value(s)`, {
                                code: 'LEVEL_DECODE_ERROR',
                                cause: err1
                            }));
                        }
                        callback1(null, values1);
                    }), callback1[kPromise1];
                }
                _getMany(keys1, options1, callback1) {
                    this.nextTick(callback1, null, Array(keys1.length).fill(void 0));
                }
                put(key1, value1, options1, callback1) {
                    if (callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, this[kDefaultOptions1].entry), 'opening' === this[kStatus1]) return this.defer(()=>this.put(key1, value1, options1, callback1)), callback1[kPromise1];
                    if (maybeError1(this, callback1)) return callback1[kPromise1];
                    const err1 = this._checkKey(key1) || this._checkValue(value1);
                    if (err1) return this.nextTick(callback1, err1), callback1[kPromise1];
                    const keyEncoding1 = this.keyEncoding(options1.keyEncoding), valueEncoding1 = this.valueEncoding(options1.valueEncoding), keyFormat1 = keyEncoding1.format, valueFormat1 = valueEncoding1.format;
                    (options1.keyEncoding !== keyFormat1 || options1.valueEncoding !== valueFormat1) && (options1 = Object.assign({}, options1, {
                        keyEncoding: keyFormat1,
                        valueEncoding: valueFormat1
                    }));
                    const mappedKey1 = this.prefixKey(keyEncoding1.encode(key1), keyFormat1), mappedValue1 = valueEncoding1.encode(value1);
                    return this._put(mappedKey1, mappedValue1, options1, (err1)=>{
                        if (err1) return callback1(err1);
                        this.emit('put', key1, value1), callback1();
                    }), callback1[kPromise1];
                }
                _put(key1, value1, options1, callback1) {
                    this.nextTick(callback1);
                }
                del(key1, options1, callback1) {
                    if (callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, this[kDefaultOptions1].key), 'opening' === this[kStatus1]) return this.defer(()=>this.del(key1, options1, callback1)), callback1[kPromise1];
                    if (maybeError1(this, callback1)) return callback1[kPromise1];
                    const err1 = this._checkKey(key1);
                    if (err1) return this.nextTick(callback1, err1), callback1[kPromise1];
                    const keyEncoding1 = this.keyEncoding(options1.keyEncoding), keyFormat1 = keyEncoding1.format;
                    return options1.keyEncoding !== keyFormat1 && (options1 = Object.assign({}, options1, {
                        keyEncoding: keyFormat1
                    })), this._del(this.prefixKey(keyEncoding1.encode(key1), keyFormat1), options1, (err1)=>{
                        if (err1) return callback1(err1);
                        this.emit('del', key1), callback1();
                    }), callback1[kPromise1];
                }
                _del(key1, options1, callback1) {
                    this.nextTick(callback1);
                }
                batch(operations1, options1, callback1) {
                    if (!arguments.length) {
                        if ('opening' === this[kStatus1]) return new DefaultChainedBatch1(this);
                        if ('open' !== this[kStatus1]) throw new ModuleError1('Database is not open', {
                            code: 'LEVEL_DATABASE_NOT_OPEN'
                        });
                        return this._chainedBatch();
                    }
                    if (callback1 = fromCallback1(callback1 = 'function' == typeof operations1 ? operations1 : getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, this[kDefaultOptions1].empty), 'opening' === this[kStatus1]) return this.defer(()=>this.batch(operations1, options1, callback1)), callback1[kPromise1];
                    if (maybeError1(this, callback1)) return callback1[kPromise1];
                    if (!Array.isArray(operations1)) return this.nextTick(callback1, TypeError("The first argument 'operations' must be an array")), callback1[kPromise1];
                    if (0 === operations1.length) return this.nextTick(callback1), callback1[kPromise1];
                    const mapped1 = Array(operations1.length), { keyEncoding: ke1 , valueEncoding: ve1 , ...forward1 } = options1;
                    for(let i2 = 0; i2 < operations1.length; i2++){
                        if ('object' != typeof operations1[i2] || null === operations1[i2]) return this.nextTick(callback1, TypeError('A batch operation must be an object')), callback1[kPromise1];
                        const op1 = Object.assign({}, operations1[i2]);
                        if ('put' !== op1.type && 'del' !== op1.type) return this.nextTick(callback1, TypeError("A batch operation must have a type property that is 'put' or 'del'")), callback1[kPromise1];
                        const err1 = this._checkKey(op1.key);
                        if (err1) return this.nextTick(callback1, err1), callback1[kPromise1];
                        const db1 = null != op1.sublevel ? op1.sublevel : this, keyEncoding1 = db1.keyEncoding(op1.keyEncoding || ke1), keyFormat1 = keyEncoding1.format;
                        if (op1.key = db1.prefixKey(keyEncoding1.encode(op1.key), keyFormat1), op1.keyEncoding = keyFormat1, 'put' === op1.type) {
                            const valueErr1 = this._checkValue(op1.value);
                            if (valueErr1) return this.nextTick(callback1, valueErr1), callback1[kPromise1];
                            const valueEncoding1 = db1.valueEncoding(op1.valueEncoding || ve1);
                            op1.value = valueEncoding1.encode(op1.value), op1.valueEncoding = valueEncoding1.format;
                        }
                        db1 !== this && (op1.sublevel = null), mapped1[i2] = op1;
                    }
                    return this._batch(mapped1, forward1, (err1)=>{
                        if (err1) return callback1(err1);
                        this.emit('batch', operations1), callback1();
                    }), callback1[kPromise1];
                }
                _batch(operations1, options1, callback1) {
                    this.nextTick(callback1);
                }
                sublevel(name1, options1) {
                    return this._sublevel(name1, AbstractSublevel1.defaults(options1));
                }
                _sublevel(name1, options1) {
                    return new AbstractSublevel1(this, name1, options1);
                }
                prefixKey(key1, keyFormat1) {
                    return key1;
                }
                clear(options1, callback1) {
                    if (callback1 = fromCallback1(callback1 = getCallback1(options1, callback1), kPromise1), options1 = getOptions1(options1, this[kDefaultOptions1].empty), 'opening' === this[kStatus1]) return this.defer(()=>this.clear(options1, callback1)), callback1[kPromise1];
                    if (maybeError1(this, callback1)) return callback1[kPromise1];
                    const original1 = options1, keyEncoding1 = this.keyEncoding(options1.keyEncoding);
                    return (options1 = rangeOptions1(options1, keyEncoding1)).keyEncoding = keyEncoding1.format, 0 === options1.limit ? this.nextTick(callback1) : this._clear(options1, (err1)=>{
                        if (err1) return callback1(err1);
                        this.emit('clear', original1), callback1();
                    }), callback1[kPromise1];
                }
                _clear(options1, callback1) {
                    this.nextTick(callback1);
                }
                iterator(options1) {
                    const keyEncoding1 = this.keyEncoding(options1 && options1.keyEncoding), valueEncoding1 = this.valueEncoding(options1 && options1.valueEncoding);
                    if ((options1 = rangeOptions1(options1, keyEncoding1)).keys = !1 !== options1.keys, options1.values = !1 !== options1.values, options1[AbstractIterator1.keyEncoding] = keyEncoding1, options1[AbstractIterator1.valueEncoding] = valueEncoding1, options1.keyEncoding = keyEncoding1.format, options1.valueEncoding = valueEncoding1.format, 'opening' === this[kStatus1]) return new DeferredIterator1(this, options1);
                    if ('open' !== this[kStatus1]) throw new ModuleError1('Database is not open', {
                        code: 'LEVEL_DATABASE_NOT_OPEN'
                    });
                    return this._iterator(options1);
                }
                _iterator(options1) {
                    return new AbstractIterator1(this, options1);
                }
                keys(options1) {
                    const keyEncoding1 = this.keyEncoding(options1 && options1.keyEncoding), valueEncoding1 = this.valueEncoding(options1 && options1.valueEncoding);
                    if ((options1 = rangeOptions1(options1, keyEncoding1))[AbstractIterator1.keyEncoding] = keyEncoding1, options1[AbstractIterator1.valueEncoding] = valueEncoding1, options1.keyEncoding = keyEncoding1.format, options1.valueEncoding = valueEncoding1.format, 'opening' === this[kStatus1]) return new DeferredKeyIterator1(this, options1);
                    if ('open' !== this[kStatus1]) throw new ModuleError1('Database is not open', {
                        code: 'LEVEL_DATABASE_NOT_OPEN'
                    });
                    return this._keys(options1);
                }
                _keys(options1) {
                    return new DefaultKeyIterator1(this, options1);
                }
                values(options1) {
                    const keyEncoding1 = this.keyEncoding(options1 && options1.keyEncoding), valueEncoding1 = this.valueEncoding(options1 && options1.valueEncoding);
                    if ((options1 = rangeOptions1(options1, keyEncoding1))[AbstractIterator1.keyEncoding] = keyEncoding1, options1[AbstractIterator1.valueEncoding] = valueEncoding1, options1.keyEncoding = keyEncoding1.format, options1.valueEncoding = valueEncoding1.format, 'opening' === this[kStatus1]) return new DeferredValueIterator1(this, options1);
                    if ('open' !== this[kStatus1]) throw new ModuleError1('Database is not open', {
                        code: 'LEVEL_DATABASE_NOT_OPEN'
                    });
                    return this._values(options1);
                }
                _values(options1) {
                    return new DefaultValueIterator1(this, options1);
                }
                defer(fn1) {
                    if ('function' != typeof fn1) throw TypeError('The first argument must be a function');
                    this[kOperations1].push(fn1);
                }
                [kUndefer1]() {
                    if (0 === this[kOperations1].length) return;
                    const operations1 = this[kOperations1];
                    for (const op1 of (this[kOperations1] = [], operations1))op1();
                }
                attachResource(resource1) {
                    if ('object' != typeof resource1 || null === resource1 || 'function' != typeof resource1.close) throw TypeError('The first argument must be a resource object');
                    this[kResources1].add(resource1);
                }
                detachResource(resource1) {
                    this[kResources1].delete(resource1);
                }
                _chainedBatch() {
                    return new DefaultChainedBatch1(this);
                }
                _checkKey(key1) {
                    if (null == key1) return new ModuleError1('Key cannot be null or undefined', {
                        code: 'LEVEL_INVALID_KEY'
                    });
                }
                _checkValue(value1) {
                    if (null == value1) return new ModuleError1('Value cannot be null or undefined', {
                        code: 'LEVEL_INVALID_VALUE'
                    });
                }
            }
            AbstractLevel1.prototype.nextTick = __webpack_require__1(6909);
            const { AbstractSublevel: AbstractSublevel1  } = __webpack_require__1(9650)({
                AbstractLevel: AbstractLevel1
            });
            exports1.AbstractLevel = AbstractLevel1, exports1.AbstractSublevel = AbstractSublevel1;
            const maybeError1 = function(db1, callback1) {
                return 'open' !== db1[kStatus1] && (db1.nextTick(callback1, new ModuleError1('Database is not open', {
                    code: 'LEVEL_DATABASE_NOT_OPEN'
                })), !0);
            }, formats1 = function(db1) {
                return Object.keys(db1.supports.encodings).filter((k3)=>!!db1.supports.encodings[k3]);
            };
        },
        875: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            exports1.AbstractLevel = __webpack_require__1(9071).AbstractLevel, exports1.AbstractSublevel = __webpack_require__1(9071).AbstractSublevel, exports1.AbstractIterator = __webpack_require__1(3961).AbstractIterator, exports1.AbstractKeyIterator = __webpack_require__1(3961).AbstractKeyIterator, exports1.AbstractValueIterator = __webpack_require__1(3961).AbstractValueIterator, exports1.AbstractChainedBatch = __webpack_require__1(9464).AbstractChainedBatch;
        },
        2970: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { AbstractIterator: AbstractIterator1 , AbstractKeyIterator: AbstractKeyIterator1 , AbstractValueIterator: AbstractValueIterator1  } = __webpack_require__1(3961), kUnfix1 = Symbol('unfix'), kIterator1 = Symbol('iterator'), kHandleOne1 = Symbol('handleOne'), kHandleMany1 = Symbol('handleMany'), kCallback1 = Symbol('callback');
            class AbstractSublevelIterator1 extends AbstractIterator1 {
                constructor(db1, options1, iterator1, unfix1){
                    super(db1, options1), this[kIterator1] = iterator1, this[kUnfix1] = unfix1, this[kHandleOne1] = this[kHandleOne1].bind(this), this[kHandleMany1] = this[kHandleMany1].bind(this), this[kCallback1] = null;
                }
                [kHandleOne1](err1, key1, value1) {
                    const callback1 = this[kCallback1];
                    if (err1) return callback1(err1);
                    void 0 !== key1 && (key1 = this[kUnfix1](key1)), callback1(err1, key1, value1);
                }
                [kHandleMany1](err1, entries1) {
                    const callback1 = this[kCallback1];
                    if (err1) return callback1(err1);
                    for (const entry1 of entries1){
                        const key1 = entry1[0];
                        void 0 !== key1 && (entry1[0] = this[kUnfix1](key1));
                    }
                    callback1(err1, entries1);
                }
            }
            class AbstractSublevelKeyIterator1 extends AbstractKeyIterator1 {
                constructor(db1, options1, iterator1, unfix1){
                    super(db1, options1), this[kIterator1] = iterator1, this[kUnfix1] = unfix1, this[kHandleOne1] = this[kHandleOne1].bind(this), this[kHandleMany1] = this[kHandleMany1].bind(this), this[kCallback1] = null;
                }
                [kHandleOne1](err1, key1) {
                    const callback1 = this[kCallback1];
                    if (err1) return callback1(err1);
                    void 0 !== key1 && (key1 = this[kUnfix1](key1)), callback1(err1, key1);
                }
                [kHandleMany1](err1, keys1) {
                    const callback1 = this[kCallback1];
                    if (err1) return callback1(err1);
                    for(let i2 = 0; i2 < keys1.length; i2++){
                        const key1 = keys1[i2];
                        void 0 !== key1 && (keys1[i2] = this[kUnfix1](key1));
                    }
                    callback1(err1, keys1);
                }
            }
            class AbstractSublevelValueIterator1 extends AbstractValueIterator1 {
                constructor(db1, options1, iterator1){
                    super(db1, options1), this[kIterator1] = iterator1;
                }
            }
            for (const Iterator1 of [
                AbstractSublevelIterator1,
                AbstractSublevelKeyIterator1
            ])Iterator1.prototype._next = function(callback1) {
                this[kCallback1] = callback1, this[kIterator1].next(this[kHandleOne1]);
            }, Iterator1.prototype._nextv = function(size1, options1, callback1) {
                this[kCallback1] = callback1, this[kIterator1].nextv(size1, options1, this[kHandleMany1]);
            }, Iterator1.prototype._all = function(options1, callback1) {
                this[kCallback1] = callback1, this[kIterator1].all(options1, this[kHandleMany1]);
            };
            for (const Iterator1 of [
                AbstractSublevelValueIterator1
            ])Iterator1.prototype._next = function(callback1) {
                this[kIterator1].next(callback1);
            }, Iterator1.prototype._nextv = function(size1, options1, callback1) {
                this[kIterator1].nextv(size1, options1, callback1);
            }, Iterator1.prototype._all = function(options1, callback1) {
                this[kIterator1].all(options1, callback1);
            };
            for (const Iterator1 of [
                AbstractSublevelIterator1,
                AbstractSublevelKeyIterator1,
                AbstractSublevelValueIterator1
            ])Iterator1.prototype._seek = function(target1, options1) {
                this[kIterator1].seek(target1, options1);
            }, Iterator1.prototype._close = function(callback1) {
                this[kIterator1].close(callback1);
            };
            exports1.AbstractSublevelIterator = AbstractSublevelIterator1, exports1.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator1, exports1.AbstractSublevelValueIterator = AbstractSublevelValueIterator1;
        },
        9650: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const ModuleError1 = __webpack_require__1(4473), { Buffer: Buffer1  } = __webpack_require__1(8764) || {}, { AbstractSublevelIterator: AbstractSublevelIterator1 , AbstractSublevelKeyIterator: AbstractSublevelKeyIterator1 , AbstractSublevelValueIterator: AbstractSublevelValueIterator1  } = __webpack_require__1(2970), kPrefix1 = Symbol('prefix'), kUpperBound1 = Symbol('upperBound'), kPrefixRange1 = Symbol('prefixRange'), kParent1 = Symbol('parent'), kUnfix1 = Symbol('unfix'), textEncoder1 = new TextEncoder(), defaults1 = {
                separator: '!'
            };
            module1.exports = function({ AbstractLevel: AbstractLevel1  }) {
                class AbstractSublevel1 extends AbstractLevel1 {
                    static defaults(options1) {
                        if ('string' == typeof options1) throw new ModuleError1('The subleveldown string shorthand for { separator } has been removed', {
                            code: 'LEVEL_LEGACY'
                        });
                        if (options1 && options1.open) throw new ModuleError1('The subleveldown open option has been removed', {
                            code: 'LEVEL_LEGACY'
                        });
                        return null == options1 ? defaults1 : options1.separator ? options1 : {
                            ...options1,
                            separator: '!'
                        };
                    }
                    constructor(db1, name1, options1){
                        const { separator: separator1 , manifest: manifest1 , ...forward1 } = AbstractSublevel1.defaults(options1);
                        name1 = trim1(name1, separator1);
                        const reserved1 = separator1.charCodeAt(0) + 1, parent1 = db1[kParent1] || db1;
                        if (!textEncoder1.encode(name1).every((x3)=>x3 > reserved1 && x3 < 127)) throw new ModuleError1(`Prefix must use bytes > ${reserved1} < 127`, {
                            code: 'LEVEL_INVALID_PREFIX'
                        });
                        super(mergeManifests1(parent1, manifest1), forward1);
                        const prefix1 = (db1.prefix || '') + separator1 + name1 + separator1, upperBound1 = prefix1.slice(0, -1) + String.fromCharCode(reserved1);
                        this[kParent1] = parent1, this[kPrefix1] = new MultiFormat1(prefix1), this[kUpperBound1] = new MultiFormat1(upperBound1), this[kUnfix1] = new Unfixer1(), this.nextTick = parent1.nextTick;
                    }
                    prefixKey(key1, keyFormat1) {
                        if ('utf8' === keyFormat1) return this[kPrefix1].utf8 + key1;
                        if (0 === key1.byteLength) return this[kPrefix1][keyFormat1];
                        if ('view' === keyFormat1) {
                            const view1 = this[kPrefix1].view, result1 = new Uint8Array(view1.byteLength + key1.byteLength);
                            return result1.set(view1, 0), result1.set(key1, view1.byteLength), result1;
                        }
                        {
                            const buffer1 = this[kPrefix1].buffer;
                            return Buffer1.concat([
                                buffer1,
                                key1
                            ], buffer1.byteLength + key1.byteLength);
                        }
                    }
                    [kPrefixRange1](range1, keyFormat1) {
                        void 0 !== range1.gte ? range1.gte = this.prefixKey(range1.gte, keyFormat1) : void 0 !== range1.gt ? range1.gt = this.prefixKey(range1.gt, keyFormat1) : range1.gte = this[kPrefix1][keyFormat1], void 0 !== range1.lte ? range1.lte = this.prefixKey(range1.lte, keyFormat1) : void 0 !== range1.lt ? range1.lt = this.prefixKey(range1.lt, keyFormat1) : range1.lte = this[kUpperBound1][keyFormat1];
                    }
                    get prefix() {
                        return this[kPrefix1].utf8;
                    }
                    get db() {
                        return this[kParent1];
                    }
                    _open(options1, callback1) {
                        this[kParent1].open({
                            passive: !0
                        }, callback1);
                    }
                    _put(key1, value1, options1, callback1) {
                        this[kParent1].put(key1, value1, options1, callback1);
                    }
                    _get(key1, options1, callback1) {
                        this[kParent1].get(key1, options1, callback1);
                    }
                    _getMany(keys1, options1, callback1) {
                        this[kParent1].getMany(keys1, options1, callback1);
                    }
                    _del(key1, options1, callback1) {
                        this[kParent1].del(key1, options1, callback1);
                    }
                    _batch(operations1, options1, callback1) {
                        this[kParent1].batch(operations1, options1, callback1);
                    }
                    _clear(options1, callback1) {
                        this[kPrefixRange1](options1, options1.keyEncoding), this[kParent1].clear(options1, callback1);
                    }
                    _iterator(options1) {
                        this[kPrefixRange1](options1, options1.keyEncoding);
                        const iterator1 = this[kParent1].iterator(options1), unfix1 = this[kUnfix1].get(this[kPrefix1].utf8.length, options1.keyEncoding);
                        return new AbstractSublevelIterator1(this, options1, iterator1, unfix1);
                    }
                    _keys(options1) {
                        this[kPrefixRange1](options1, options1.keyEncoding);
                        const iterator1 = this[kParent1].keys(options1), unfix1 = this[kUnfix1].get(this[kPrefix1].utf8.length, options1.keyEncoding);
                        return new AbstractSublevelKeyIterator1(this, options1, iterator1, unfix1);
                    }
                    _values(options1) {
                        this[kPrefixRange1](options1, options1.keyEncoding);
                        const iterator1 = this[kParent1].values(options1);
                        return new AbstractSublevelValueIterator1(this, options1, iterator1);
                    }
                }
                return {
                    AbstractSublevel: AbstractSublevel1
                };
            };
            const mergeManifests1 = function(parent1, manifest1) {
                return {
                    ...parent1.supports,
                    createIfMissing: !1,
                    errorIfExists: !1,
                    events: {},
                    additionalMethods: {},
                    ...manifest1,
                    encodings: {
                        utf8: supportsEncoding1(parent1, 'utf8'),
                        buffer: supportsEncoding1(parent1, 'buffer'),
                        view: supportsEncoding1(parent1, 'view')
                    }
                };
            }, supportsEncoding1 = function(parent1, encoding1) {
                return !!parent1.supports.encodings[encoding1] && parent1.keyEncoding(encoding1).name === encoding1;
            };
            class MultiFormat1 {
                constructor(key1){
                    this.utf8 = key1, this.view = textEncoder1.encode(key1), this.buffer = Buffer1 ? Buffer1.from(this.view.buffer, 0, this.view.byteLength) : {};
                }
            }
            class Unfixer1 {
                constructor(){
                    this.cache = new Map();
                }
                get(prefixLength1, keyFormat1) {
                    let unfix1 = this.cache.get(keyFormat1);
                    return void 0 === unfix1 && (unfix1 = 'view' === keyFormat1 ? (function(prefixLength1, key1) {
                        return key1.subarray(prefixLength1);
                    }).bind(null, prefixLength1) : (function(prefixLength1, key1) {
                        return key1.slice(prefixLength1);
                    }).bind(null, prefixLength1), this.cache.set(keyFormat1, unfix1)), unfix1;
                }
            }
            const trim1 = function(str1, char1) {
                let start1 = 0, end1 = str1.length;
                for(; start1 < end1 && str1[start1] === char1;)start1++;
                for(; end1 > start1 && str1[end1 - 1] === char1;)end1--;
                return str1.slice(start1, end1);
            };
        },
        2520: function(__unused_webpack_module1, exports1) {
            "use strict";
            exports1.getCallback = function(options1, callback1) {
                return 'function' == typeof options1 ? options1 : callback1;
            }, exports1.getOptions = function(options1, def1) {
                return 'object' == typeof options1 && null !== options1 ? options1 : void 0 !== def1 ? def1 : {};
            };
        },
        4765: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { AbstractChainedBatch: AbstractChainedBatch1  } = __webpack_require__1(9464), ModuleError1 = __webpack_require__1(4473), kEncoded1 = Symbol('encoded');
            class DefaultChainedBatch1 extends AbstractChainedBatch1 {
                constructor(db1){
                    super(db1), this[kEncoded1] = [];
                }
                _put(key1, value1, options1) {
                    this[kEncoded1].push({
                        ...options1,
                        type: 'put',
                        key: key1,
                        value: value1
                    });
                }
                _del(key1, options1) {
                    this[kEncoded1].push({
                        ...options1,
                        type: 'del',
                        key: key1
                    });
                }
                _clear() {
                    this[kEncoded1] = [];
                }
                _write(options1, callback1) {
                    'opening' === this.db.status ? this.db.defer(()=>this._write(options1, callback1)) : 'open' === this.db.status ? 0 === this[kEncoded1].length ? this.nextTick(callback1) : this.db._batch(this[kEncoded1], options1, callback1) : this.nextTick(callback1, new ModuleError1('Batch is not open: cannot call write() after write() or close()', {
                        code: 'LEVEL_BATCH_NOT_OPEN'
                    }));
                }
            }
            exports1.DefaultChainedBatch = DefaultChainedBatch1;
        },
        5429: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { AbstractKeyIterator: AbstractKeyIterator1 , AbstractValueIterator: AbstractValueIterator1  } = __webpack_require__1(3961), kIterator1 = Symbol('iterator'), kCallback1 = Symbol('callback'), kHandleOne1 = Symbol('handleOne'), kHandleMany1 = Symbol('handleMany');
            class DefaultKeyIterator1 extends AbstractKeyIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kIterator1] = db1.iterator({
                        ...options1,
                        keys: !0,
                        values: !1
                    }), this[kHandleOne1] = this[kHandleOne1].bind(this), this[kHandleMany1] = this[kHandleMany1].bind(this);
                }
            }
            class DefaultValueIterator1 extends AbstractValueIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kIterator1] = db1.iterator({
                        ...options1,
                        keys: !1,
                        values: !0
                    }), this[kHandleOne1] = this[kHandleOne1].bind(this), this[kHandleMany1] = this[kHandleMany1].bind(this);
                }
            }
            for (const Iterator1 of [
                DefaultKeyIterator1,
                DefaultValueIterator1
            ]){
                const keys1 = Iterator1 === DefaultKeyIterator1, mapEntry1 = keys1 ? (entry1)=>entry1[0] : (entry1)=>entry1[1];
                Iterator1.prototype._next = function(callback1) {
                    this[kCallback1] = callback1, this[kIterator1].next(this[kHandleOne1]);
                }, Iterator1.prototype[kHandleOne1] = function(err1, key1, value1) {
                    const callback1 = this[kCallback1];
                    err1 ? callback1(err1) : callback1(null, keys1 ? key1 : value1);
                }, Iterator1.prototype._nextv = function(size1, options1, callback1) {
                    this[kCallback1] = callback1, this[kIterator1].nextv(size1, options1, this[kHandleMany1]);
                }, Iterator1.prototype._all = function(options1, callback1) {
                    this[kCallback1] = callback1, this[kIterator1].all(options1, this[kHandleMany1]);
                }, Iterator1.prototype[kHandleMany1] = function(err1, entries1) {
                    const callback1 = this[kCallback1];
                    err1 ? callback1(err1) : callback1(null, entries1.map(mapEntry1));
                }, Iterator1.prototype._seek = function(target1, options1) {
                    this[kIterator1].seek(target1, options1);
                }, Iterator1.prototype._close = function(callback1) {
                    this[kIterator1].close(callback1);
                };
            }
            exports1.DefaultKeyIterator = DefaultKeyIterator1, exports1.DefaultValueIterator = DefaultValueIterator1;
        },
        593: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { AbstractIterator: AbstractIterator1 , AbstractKeyIterator: AbstractKeyIterator1 , AbstractValueIterator: AbstractValueIterator1  } = __webpack_require__1(3961), ModuleError1 = __webpack_require__1(4473), kNut1 = Symbol('nut'), kUndefer1 = Symbol('undefer'), kFactory1 = Symbol('factory');
            class DeferredIterator1 extends AbstractIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kNut1] = null, this[kFactory1] = ()=>db1.iterator(options1), this.db.defer(()=>this[kUndefer1]());
                }
            }
            class DeferredKeyIterator1 extends AbstractKeyIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kNut1] = null, this[kFactory1] = ()=>db1.keys(options1), this.db.defer(()=>this[kUndefer1]());
                }
            }
            class DeferredValueIterator1 extends AbstractValueIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kNut1] = null, this[kFactory1] = ()=>db1.values(options1), this.db.defer(()=>this[kUndefer1]());
                }
            }
            for (const Iterator1 of [
                DeferredIterator1,
                DeferredKeyIterator1,
                DeferredValueIterator1
            ])Iterator1.prototype[kUndefer1] = function() {
                'open' === this.db.status && (this[kNut1] = this[kFactory1]());
            }, Iterator1.prototype._next = function(callback1) {
                null !== this[kNut1] ? this[kNut1].next(callback1) : 'opening' === this.db.status ? this.db.defer(()=>this._next(callback1)) : this.nextTick(callback1, new ModuleError1('Iterator is not open: cannot call next() after close()', {
                    code: 'LEVEL_ITERATOR_NOT_OPEN'
                }));
            }, Iterator1.prototype._nextv = function(size1, options1, callback1) {
                null !== this[kNut1] ? this[kNut1].nextv(size1, options1, callback1) : 'opening' === this.db.status ? this.db.defer(()=>this._nextv(size1, options1, callback1)) : this.nextTick(callback1, new ModuleError1('Iterator is not open: cannot call nextv() after close()', {
                    code: 'LEVEL_ITERATOR_NOT_OPEN'
                }));
            }, Iterator1.prototype._all = function(options1, callback1) {
                null !== this[kNut1] ? this[kNut1].all(callback1) : 'opening' === this.db.status ? this.db.defer(()=>this._all(options1, callback1)) : this.nextTick(callback1, new ModuleError1('Iterator is not open: cannot call all() after close()', {
                    code: 'LEVEL_ITERATOR_NOT_OPEN'
                }));
            }, Iterator1.prototype._seek = function(target1, options1) {
                null !== this[kNut1] ? this[kNut1]._seek(target1, options1) : 'opening' === this.db.status && this.db.defer(()=>this._seek(target1, options1));
            }, Iterator1.prototype._close = function(callback1) {
                null !== this[kNut1] ? this[kNut1].close(callback1) : 'opening' === this.db.status ? this.db.defer(()=>this._close(callback1)) : this.nextTick(callback1);
            };
            exports1.DeferredIterator = DeferredIterator1, exports1.DeferredKeyIterator = DeferredKeyIterator1, exports1.DeferredValueIterator = DeferredValueIterator1;
        },
        6909: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const queueMicrotask1 = __webpack_require__1(4375);
            module1.exports = function(fn1, ...args1) {
                0 === args1.length ? queueMicrotask1(fn1) : queueMicrotask1(()=>fn1(...args1));
            };
        },
        56: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const ModuleError1 = __webpack_require__1(4473), hasOwnProperty1 = Object.prototype.hasOwnProperty, rangeOptions1 = new Set([
                'lt',
                'lte',
                'gt',
                'gte'
            ]);
            module1.exports = function(options1, keyEncoding1) {
                const result1 = {};
                for(const k3 in options1)if (hasOwnProperty1.call(options1, k3) && 'keyEncoding' !== k3 && 'valueEncoding' !== k3) {
                    if ('start' === k3 || 'end' === k3) throw new ModuleError1(`The legacy range option '${k3}' has been removed`, {
                        code: 'LEVEL_LEGACY'
                    });
                    if ('encoding' === k3) throw new ModuleError1("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
                        code: 'LEVEL_LEGACY'
                    });
                    rangeOptions1.has(k3) ? result1[k3] = keyEncoding1.encode(options1[k3]) : result1[k3] = options1[k3];
                }
                return result1.reverse = !!result1.reverse, result1.limit = Number.isInteger(result1.limit) && result1.limit >= 0 ? result1.limit : -1, result1;
            };
        },
        1317: function(__unused_webpack_module1, __webpack_exports__1, __webpack_require__1) {
            "use strict";
            __webpack_require__1.r(__webpack_exports__1), __webpack_exports__1.default = {};
        },
        3883: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const bignumber_js_11 = __webpack_require__1(4431);
            class Ar1 {
                constructor(){
                    this.BigNum = (value1, decimals1)=>new (bignumber_js_11.BigNumber.clone({
                            DECIMAL_PLACES: decimals1
                        }))(value1);
                }
                winstonToAr(winstonString1, { formatted: formatted1 = !1 , decimals: decimals1 = 12 , trim: trim1 = !0  } = {}) {
                    let number1 = this.stringToBigNum(winstonString1, decimals1).shiftedBy(-12);
                    return formatted1 ? number1.toFormat(decimals1) : number1.toFixed(decimals1);
                }
                arToWinston(arString1, { formatted: formatted1 = !1  } = {}) {
                    let number1 = this.stringToBigNum(arString1).shiftedBy(12);
                    return formatted1 ? number1.toFormat() : number1.toFixed(0);
                }
                compare(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1), b10 = this.stringToBigNum(winstonStringB1);
                    return a10.comparedTo(b10);
                }
                isEqual(winstonStringA1, winstonStringB1) {
                    return 0 === this.compare(winstonStringA1, winstonStringB1);
                }
                isLessThan(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1), b10 = this.stringToBigNum(winstonStringB1);
                    return a10.isLessThan(b10);
                }
                isGreaterThan(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1), b10 = this.stringToBigNum(winstonStringB1);
                    return a10.isGreaterThan(b10);
                }
                add(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1);
                    return this.stringToBigNum(winstonStringB1), a10.plus(winstonStringB1).toFixed(0);
                }
                sub(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1);
                    return this.stringToBigNum(winstonStringB1), a10.minus(winstonStringB1).toFixed(0);
                }
                stringToBigNum(stringValue1, decimalPlaces1 = 12) {
                    return this.BigNum(stringValue1, decimalPlaces1);
                }
            }
            exports1.default = Ar1;
        },
        1286: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const error_11 = __importDefault1(__webpack_require__1(2990));
            __webpack_require__1(1317);
            class Blocks1 {
                constructor(api1, network1){
                    this.api = api1, this.network = network1;
                }
                async get(indepHash1) {
                    const response1 = await this.api.get(`${Blocks1.ENDPOINT}${indepHash1}`);
                    if (200 === response1.status) return response1.data;
                    if (404 === response1.status) throw new error_11.default("BLOCK_NOT_FOUND");
                    throw Error(`Error while loading block data: ${response1}`);
                }
                async getCurrent() {
                    const { current: current1  } = await this.network.getInfo();
                    return await this.get(current1);
                }
            }
            exports1.default = Blocks1, Blocks1.ENDPOINT = "block/hash/";
        },
        1070: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const error_11 = __webpack_require__1(2990), ArweaveUtils1 = __importStar1(__webpack_require__1(5160));
            class Chunks1 {
                constructor(api1){
                    this.api = api1;
                }
                async getTransactionOffset(id1) {
                    const resp1 = await this.api.get(`tx/${id1}/offset`);
                    if (200 === resp1.status) return resp1.data;
                    throw Error(`Unable to get transaction offset: ${(0, error_11.getError)(resp1)}`);
                }
                async getChunk(offset1) {
                    const resp1 = await this.api.get(`chunk/${offset1}`);
                    if (200 === resp1.status) return resp1.data;
                    throw Error(`Unable to get chunk: ${(0, error_11.getError)(resp1)}`);
                }
                async getChunkData(offset1) {
                    const chunk1 = await this.getChunk(offset1), buf1 = ArweaveUtils1.b64UrlToBuffer(chunk1.chunk);
                    return buf1;
                }
                firstChunkOffset(offsetResponse1) {
                    return parseInt(offsetResponse1.offset) - parseInt(offsetResponse1.size) + 1;
                }
                async downloadChunkedData(id1) {
                    const offsetResponse1 = await this.getTransactionOffset(id1), size1 = parseInt(offsetResponse1.size), endOffset1 = parseInt(offsetResponse1.offset), startOffset1 = endOffset1 - size1 + 1, data1 = new Uint8Array(size1);
                    let byte1 = 0;
                    for(; byte1 < size1;){
                        let chunkData1;
                        this.api.config.logging && console.log(`[chunk] ${byte1}/${size1}`);
                        try {
                            chunkData1 = await this.getChunkData(startOffset1 + byte1);
                        } catch (error1) {
                            console.error(`[chunk] Failed to fetch chunk at offset ${startOffset1 + byte1}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
                        }
                        if (chunkData1) data1.set(chunkData1, byte1), byte1 += chunkData1.length;
                        else throw Error(`Couldn't complete data download at ${byte1}/${size1}`);
                    }
                    return data1;
                }
            }
            exports1.default = Chunks1;
        },
        9499: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            }, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const ar_11 = __importDefault1(__webpack_require__1(3883)), api_11 = __importDefault1(__webpack_require__1(7468)), node_driver_11 = __importDefault1(__webpack_require__1(602)), network_11 = __importDefault1(__webpack_require__1(5764)), transactions_11 = __importDefault1(__webpack_require__1(5385)), wallets_11 = __importDefault1(__webpack_require__1(8379)), transaction_11 = __importDefault1(__webpack_require__1(7241)), ArweaveUtils1 = __importStar1(__webpack_require__1(5160)), silo_11 = __importDefault1(__webpack_require__1(4486)), chunks_11 = __importDefault1(__webpack_require__1(1070)), blocks_11 = __importDefault1(__webpack_require__1(1286));
            class Arweave1 {
                constructor(apiConfig1){
                    this.api = new api_11.default(apiConfig1), this.wallets = new wallets_11.default(this.api, Arweave1.crypto), this.chunks = new chunks_11.default(this.api), this.transactions = new transactions_11.default(this.api, Arweave1.crypto, this.chunks), this.silo = new silo_11.default(this.api, this.crypto, this.transactions), this.network = new network_11.default(this.api), this.blocks = new blocks_11.default(this.api, this.network), this.ar = new ar_11.default();
                }
                get crypto() {
                    return Arweave1.crypto;
                }
                get utils() {
                    return Arweave1.utils;
                }
                getConfig() {
                    return {
                        api: this.api.getConfig(),
                        crypto: null
                    };
                }
                async createTransaction(attributes1, jwk1) {
                    const transaction1 = {};
                    if (Object.assign(transaction1, attributes1), !attributes1.data && !(attributes1.target && attributes1.quantity)) throw Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
                    if (void 0 == attributes1.owner && jwk1 && "use_wallet" !== jwk1 && (transaction1.owner = jwk1.n), void 0 == attributes1.last_tx && (transaction1.last_tx = await this.transactions.getTransactionAnchor()), "string" == typeof attributes1.data && (attributes1.data = ArweaveUtils1.stringToBuffer(attributes1.data)), attributes1.data instanceof ArrayBuffer && (attributes1.data = new Uint8Array(attributes1.data)), attributes1.data && !(attributes1.data instanceof Uint8Array)) throw Error("Expected data to be a string, Uint8Array or ArrayBuffer");
                    if (void 0 == attributes1.reward) {
                        const length1 = attributes1.data ? attributes1.data.byteLength : 0;
                        transaction1.reward = await this.transactions.getPrice(length1, transaction1.target);
                    }
                    transaction1.data_root = "", transaction1.data_size = attributes1.data ? attributes1.data.byteLength.toString() : "0", transaction1.data = attributes1.data || new Uint8Array(0);
                    const createdTransaction1 = new transaction_11.default(transaction1);
                    return await createdTransaction1.getSignatureData(), createdTransaction1;
                }
                async createSiloTransaction(attributes1, jwk1, siloUri1) {
                    const transaction1 = {};
                    if (Object.assign(transaction1, attributes1), !attributes1.data) throw Error("Silo transactions must have a 'data' value");
                    if (!siloUri1) throw Error("No Silo URI specified.");
                    if (attributes1.target || attributes1.quantity) throw Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
                    if (void 0 == attributes1.owner) {
                        if (!jwk1 || !jwk1.n) throw Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
                        transaction1.owner = jwk1.n;
                    }
                    void 0 == attributes1.last_tx && (transaction1.last_tx = await this.transactions.getTransactionAnchor());
                    const siloResource1 = await this.silo.parseUri(siloUri1);
                    if ("string" == typeof attributes1.data) {
                        const encrypted1 = await this.crypto.encrypt(ArweaveUtils1.stringToBuffer(attributes1.data), siloResource1.getEncryptionKey());
                        transaction1.reward = await this.transactions.getPrice(encrypted1.byteLength), transaction1.data = ArweaveUtils1.bufferTob64Url(encrypted1);
                    }
                    if (attributes1.data instanceof Uint8Array) {
                        const encrypted1 = await this.crypto.encrypt(attributes1.data, siloResource1.getEncryptionKey());
                        transaction1.reward = await this.transactions.getPrice(encrypted1.byteLength), transaction1.data = ArweaveUtils1.bufferTob64Url(encrypted1);
                    }
                    const siloTransaction1 = new transaction_11.default(transaction1);
                    return siloTransaction1.addTag("Silo-Name", siloResource1.getAccessKey()), siloTransaction1.addTag("Silo-Version", "0.1.0"), siloTransaction1;
                }
                arql(query1) {
                    return this.api.post("/arql", query1).then((response1)=>response1.data || []);
                }
            }
            exports1.default = Arweave1, Arweave1.crypto = new node_driver_11.default(), Arweave1.utils = ArweaveUtils1;
        },
        7468: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const axios_11 = __importDefault1(__webpack_require__1(9669));
            class Api1 {
                constructor(config3){
                    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(config3);
                }
                applyConfig(config3) {
                    this.config = this.mergeDefaults(config3);
                }
                getConfig() {
                    return this.config;
                }
                mergeDefaults(config3) {
                    const protocol1 = config3.protocol || "http", port1 = config3.port || ("https" === protocol1 ? 443 : 80);
                    return {
                        host: config3.host || "127.0.0.1",
                        protocol: protocol1,
                        port: port1,
                        timeout: config3.timeout || 20000,
                        logging: config3.logging || !1,
                        logger: config3.logger || console.log,
                        network: config3.network
                    };
                }
                async get(endpoint1, config3) {
                    try {
                        return await this.request().get(endpoint1, config3);
                    } catch (error1) {
                        if (error1.response && error1.response.status) return error1.response;
                        throw error1;
                    }
                }
                async post(endpoint1, body1, config3) {
                    try {
                        return await this.request().post(endpoint1, body1, config3);
                    } catch (error1) {
                        if (error1.response && error1.response.status) return error1.response;
                        throw error1;
                    }
                }
                request() {
                    const headers1 = {};
                    this.config.network && (headers1["x-network"] = this.config.network);
                    let instance1 = axios_11.default.create({
                        baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`,
                        timeout: this.config.timeout,
                        maxContentLength: 536870912,
                        headers: headers1
                    });
                    return this.config.logging && (instance1.interceptors.request.use((request1)=>(this.config.logger(`Requesting: ${request1.baseURL}/${request1.url}`), request1)), instance1.interceptors.response.use((response1)=>(this.config.logger(`Response:   ${response1.config.url} - ${response1.status}`), response1))), instance1;
                }
            }
            exports1.default = Api1;
        },
        602: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(8764).Buffer, __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const pem_11 = __webpack_require__1(3068), crypto1 = __importStar1(__webpack_require__1(2474)), constants1 = __importStar1(__webpack_require__1(2454));
            class NodeCryptoDriver1 {
                constructor(){
                    this.keyLength = 4096, this.publicExponent = 0x10001, this.hashAlgorithm = "sha256", this.encryptionAlgorithm = "aes-256-cbc";
                }
                generateJWK() {
                    if ("function" != typeof crypto1.generateKeyPair) throw Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
                    return new Promise((resolve1, reject1)=>{
                        crypto1.generateKeyPair("rsa", {
                            modulusLength: this.keyLength,
                            publicExponent: this.publicExponent,
                            privateKeyEncoding: {
                                type: "pkcs1",
                                format: "pem"
                            },
                            publicKeyEncoding: {
                                type: "pkcs1",
                                format: "pem"
                            }
                        }, (err1, publicKey1, privateKey1)=>{
                            err1 && reject1(err1), resolve1(this.pemToJWK(privateKey1));
                        });
                    });
                }
                sign(jwk1, data1, { saltLength: saltLength1  } = {}) {
                    return new Promise((resolve1, reject1)=>{
                        resolve1(crypto1.createSign(this.hashAlgorithm).update(data1).sign({
                            key: this.jwkToPem(jwk1),
                            padding: constants1.RSA_PKCS1_PSS_PADDING,
                            saltLength: saltLength1
                        }));
                    });
                }
                verify(publicModulus1, data1, signature1) {
                    return new Promise((resolve1, reject1)=>{
                        const publicKey1 = {
                            kty: "RSA",
                            e: "AQAB",
                            n: publicModulus1
                        }, pem1 = this.jwkToPem(publicKey1);
                        resolve1(crypto1.createVerify(this.hashAlgorithm).update(data1).verify({
                            key: pem1,
                            padding: constants1.RSA_PKCS1_PSS_PADDING
                        }, signature1));
                    });
                }
                hash(data1, algorithm1 = "SHA-256") {
                    return new Promise((resolve1, reject1)=>{
                        resolve1(crypto1.createHash(this.parseHashAlgorithm(algorithm1)).update(data1).digest());
                    });
                }
                async encrypt(data1, key1, salt1) {
                    const derivedKey1 = crypto1.pbkdf2Sync(key1, salt1 = salt1 || "salt", 100000, 32, this.hashAlgorithm), iv1 = crypto1.randomBytes(16), cipher1 = crypto1.createCipheriv(this.encryptionAlgorithm, derivedKey1, iv1), encrypted1 = Buffer1.concat([
                        iv1,
                        cipher1.update(data1),
                        cipher1.final()
                    ]);
                    return encrypted1;
                }
                async decrypt(encrypted1, key1, salt1) {
                    try {
                        const derivedKey1 = crypto1.pbkdf2Sync(key1, salt1 = salt1 || "salt", 100000, 32, this.hashAlgorithm), iv1 = encrypted1.slice(0, 16), data1 = encrypted1.slice(16), decipher1 = crypto1.createDecipheriv(this.encryptionAlgorithm, derivedKey1, iv1), decrypted1 = Buffer1.concat([
                            decipher1.update(data1),
                            decipher1.final()
                        ]);
                        return decrypted1;
                    } catch (error1) {
                        throw Error("Failed to decrypt");
                    }
                }
                jwkToPem(jwk1) {
                    return (0, pem_11.jwkTopem)(jwk1);
                }
                pemToJWK(pem1) {
                    return (0, pem_11.pemTojwk)(pem1);
                }
                parseHashAlgorithm(algorithm1) {
                    switch(algorithm1){
                        case "SHA-256":
                            return "sha256";
                        case "SHA-384":
                            return "sha384";
                        default:
                            throw Error(`Algorithm not supported: ${algorithm1}`);
                    }
                }
            }
            exports1.default = NodeCryptoDriver1;
        },
        3068: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(8764).Buffer, __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.jwkTopem = exports1.pemTojwk = void 0;
            const asn2 = __importStar1(__webpack_require__1(9809));
            function urlize1(base641) {
                return base641.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
            }
            function hex2b64url1(str1) {
                return urlize1(Buffer1.from(str1, "hex").toString("base64"));
            }
            var RSAPublicKey1 = asn2.define("RSAPublicKey", function() {
                this.seq().obj(this.key("n").int(), this.key("e").int());
            }), AlgorithmIdentifier1 = asn2.define("AlgorithmIdentifier", function() {
                this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
            }), PublicKeyInfo1 = asn2.define("PublicKeyInfo", function() {
                this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("publicKey").bitstr());
            }), Version1 = asn2.define("Version", function() {
                this.int({
                    0: "two-prime",
                    1: "multi"
                });
            }), OtherPrimeInfos1 = asn2.define("OtherPrimeInfos", function() {
                this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
            }), RSAPrivateKey1 = asn2.define("RSAPrivateKey", function() {
                this.seq().obj(this.key("version").use(Version1), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos1));
            }), PrivateKeyInfo1 = asn2.define("PrivateKeyInfo", function() {
                this.seq().obj(this.key("version").use(Version1), this.key("algorithm").use(AlgorithmIdentifier1), this.key("privateKey").bitstr());
            });
            function addExtras1(obj1, extras1) {
                return Object.keys(extras1 = extras1 || {}).forEach(function(key1) {
                    obj1[key1] = extras1[key1];
                }), obj1;
            }
            function pad1(hex1) {
                return hex1.length % 2 == 1 ? "0" + hex1 : hex1;
            }
            function decodeRsaPublic1(buffer1, extras1) {
                var key1 = RSAPublicKey1.decode(buffer1, "der"), e1 = pad1(key1.e.toString(16));
                return addExtras1({
                    kty: "RSA",
                    n: bn2base64url1(key1.n),
                    e: hex2b64url1(e1)
                }, extras1);
            }
            function decodeRsaPrivate1(buffer1, extras1) {
                var key1 = RSAPrivateKey1.decode(buffer1, "der"), e1 = pad1(key1.e.toString(16));
                return addExtras1({
                    kty: "RSA",
                    n: bn2base64url1(key1.n),
                    e: hex2b64url1(e1),
                    d: bn2base64url1(key1.d),
                    p: bn2base64url1(key1.p),
                    q: bn2base64url1(key1.q),
                    dp: bn2base64url1(key1.dp),
                    dq: bn2base64url1(key1.dq),
                    qi: bn2base64url1(key1.qi)
                }, extras1);
            }
            function decodePublic1(buffer1, extras1) {
                return decodeRsaPublic1(PublicKeyInfo1.decode(buffer1, "der").publicKey.data, extras1);
            }
            function decodePrivate1(buffer1, extras1) {
                return decodeRsaPrivate1(PrivateKeyInfo1.decode(buffer1, "der").privateKey.data, extras1);
            }
            function getDecoder1(header1) {
                var match1 = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(header1);
                if (!match1) return null;
                var isRSA1 = !!match1[1];
                return "PRIVATE" === match1[2] ? isRSA1 ? decodeRsaPrivate1 : decodePrivate1 : isRSA1 ? decodeRsaPublic1 : decodePublic1;
            }
            function parse1(jwk1) {
                return {
                    n: string2bn1(jwk1.n),
                    e: string2bn1(jwk1.e),
                    d: jwk1.d && string2bn1(jwk1.d),
                    p: jwk1.p && string2bn1(jwk1.p),
                    q: jwk1.q && string2bn1(jwk1.q),
                    dp: jwk1.dp && string2bn1(jwk1.dp),
                    dq: jwk1.dq && string2bn1(jwk1.dq),
                    qi: jwk1.qi && string2bn1(jwk1.qi)
                };
            }
            function bn2base64url1(bn1) {
                return hex2b64url1(pad1(bn1.toString(16)));
            }
            function base64url2bn1(str1) {
                return new asn2.bignum(Buffer1.from(str1, "base64"));
            }
            function string2bn1(str1) {
                return /^[0-9]+$/.test(str1) ? new asn2.bignum(str1, 10) : base64url2bn1(str1);
            }
            function pemTojwk1(pem1, extras1) {
                var text1 = pem1.toString().split(/(\r\n|\r|\n)+/g), decoder1 = getDecoder1((text1 = text1.filter(function(line1) {
                    return 0 !== line1.trim().length;
                }))[0]);
                return text1 = text1.slice(1, -1).join(""), decoder1(Buffer1.from(text1.replace(/[^\w\d\+\/=]+/g, ""), "base64"), extras1);
            }
            function jwkTopem1(json1) {
                var jwk1 = parse1(json1), isPrivate1 = !!jwk1.d, t3 = isPrivate1 ? "PRIVATE" : "PUBLIC", header1 = "-----BEGIN RSA " + t3 + " KEY-----\n", footer1 = "\n-----END RSA " + t3 + " KEY-----\n", data1 = Buffer1.alloc(0);
                return isPrivate1 ? (jwk1.version = "two-prime", data1 = RSAPrivateKey1.encode(jwk1, "der")) : data1 = RSAPublicKey1.encode(jwk1, "der"), header1 + data1.toString("base64").match(/.{1,64}/g).join("\n") + footer1;
            }
            exports1.pemTojwk = pemTojwk1, exports1.jwkTopem = jwkTopem1;
        },
        7439: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const common_11 = __importDefault1(__webpack_require__1(9499));
            async function deepHash1(data1) {
                if (Array.isArray(data1)) {
                    const tag1 = common_11.default.utils.concatBuffers([
                        common_11.default.utils.stringToBuffer("list"),
                        common_11.default.utils.stringToBuffer(data1.length.toString())
                    ]);
                    return await deepHashChunks1(data1, await common_11.default.crypto.hash(tag1, "SHA-384"));
                }
                const tag1 = common_11.default.utils.concatBuffers([
                    common_11.default.utils.stringToBuffer("blob"),
                    common_11.default.utils.stringToBuffer(data1.byteLength.toString())
                ]), taggedHash1 = common_11.default.utils.concatBuffers([
                    await common_11.default.crypto.hash(tag1, "SHA-384"),
                    await common_11.default.crypto.hash(data1, "SHA-384")
                ]);
                return await common_11.default.crypto.hash(taggedHash1, "SHA-384");
            }
            async function deepHashChunks1(chunks1, acc1) {
                if (chunks1.length < 1) return acc1;
                const hashPair1 = common_11.default.utils.concatBuffers([
                    acc1,
                    await deepHash1(chunks1[0])
                ]), newAcc1 = await common_11.default.crypto.hash(hashPair1, "SHA-384");
                return await deepHashChunks1(chunks1.slice(1), newAcc1);
            }
            exports1.default = deepHash1;
        },
        2990: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.getError = void 0;
            class ArweaveError1 extends Error {
                constructor(type1, optional1 = {}){
                    optional1.message ? super(optional1.message) : super(), this.type = type1, this.response = optional1.response;
                }
                getType() {
                    return this.type;
                }
            }
            function getError1(resp1) {
                let data1 = resp1.data;
                if ("string" == typeof resp1.data) try {
                    data1 = JSON.parse(resp1.data);
                } catch (e1) {}
                if (resp1.data instanceof ArrayBuffer || resp1.data instanceof Uint8Array) try {
                    data1 = JSON.parse(data1.toString());
                } catch (e1) {}
                return data1 ? data1.error || data1 : resp1.statusText || "unknown";
            }
            exports1.default = ArweaveError1, exports1.getError = getError1;
        },
        1612: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(8764).Buffer, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.debug = exports1.validatePath = exports1.arrayCompare = exports1.bufferToInt = exports1.intToBuffer = exports1.arrayFlatten = exports1.generateProofs = exports1.buildLayers = exports1.generateTransactionChunks = exports1.generateTree = exports1.computeRootHash = exports1.generateLeaves = exports1.chunkData = exports1.MIN_CHUNK_SIZE = exports1.MAX_CHUNK_SIZE = void 0;
            const common_11 = __importDefault1(__webpack_require__1(9499)), utils_11 = __webpack_require__1(5160);
            exports1.MAX_CHUNK_SIZE = 262144, exports1.MIN_CHUNK_SIZE = 32768;
            const NOTE_SIZE1 = 32, HASH_SIZE1 = 32;
            async function chunkData1(data1) {
                let chunks1 = [], rest1 = data1, cursor1 = 0;
                for(; rest1.byteLength >= exports1.MAX_CHUNK_SIZE;){
                    let chunkSize1 = exports1.MAX_CHUNK_SIZE, nextChunkSize1 = rest1.byteLength - exports1.MAX_CHUNK_SIZE;
                    nextChunkSize1 > 0 && nextChunkSize1 < exports1.MIN_CHUNK_SIZE && (chunkSize1 = Math.ceil(rest1.byteLength / 2));
                    const chunk1 = rest1.slice(0, chunkSize1), dataHash1 = await common_11.default.crypto.hash(chunk1);
                    cursor1 += chunk1.byteLength, chunks1.push({
                        dataHash: dataHash1,
                        minByteRange: cursor1 - chunk1.byteLength,
                        maxByteRange: cursor1
                    }), rest1 = rest1.slice(chunkSize1);
                }
                return chunks1.push({
                    dataHash: await common_11.default.crypto.hash(rest1),
                    minByteRange: cursor1,
                    maxByteRange: cursor1 + rest1.byteLength
                }), chunks1;
            }
            async function generateLeaves1(chunks1) {
                return Promise.all(chunks1.map(async ({ dataHash: dataHash1 , minByteRange: minByteRange1 , maxByteRange: maxByteRange1  })=>({
                        type: "leaf",
                        id: await hash1(await Promise.all([
                            hash1(dataHash1),
                            hash1(intToBuffer1(maxByteRange1))
                        ])),
                        dataHash: dataHash1,
                        minByteRange: minByteRange1,
                        maxByteRange: maxByteRange1
                    })));
            }
            async function computeRootHash1(data1) {
                const rootNode1 = await generateTree1(data1);
                return rootNode1.id;
            }
            async function generateTree1(data1) {
                const rootNode1 = await buildLayers1(await generateLeaves1(await chunkData1(data1)));
                return rootNode1;
            }
            async function generateTransactionChunks1(data1) {
                const chunks1 = await chunkData1(data1), leaves1 = await generateLeaves1(chunks1), root1 = await buildLayers1(leaves1), proofs1 = await generateProofs1(root1), lastChunk1 = chunks1.slice(-1)[0];
                return lastChunk1.maxByteRange - lastChunk1.minByteRange == 0 && (chunks1.splice(chunks1.length - 1, 1), proofs1.splice(proofs1.length - 1, 1)), {
                    data_root: root1.id,
                    chunks: chunks1,
                    proofs: proofs1
                };
            }
            async function buildLayers1(nodes1, level1 = 0) {
                if (nodes1.length < 2) {
                    const root1 = nodes1[0];
                    return root1;
                }
                const nextLayer1 = [];
                for(let i2 = 0; i2 < nodes1.length; i2 += 2)nextLayer1.push(await hashBranch1(nodes1[i2], nodes1[i2 + 1]));
                return buildLayers1(nextLayer1, level1 + 1);
            }
            function generateProofs1(root1) {
                const proofs1 = resolveBranchProofs1(root1);
                return Array.isArray(proofs1) ? arrayFlatten1(proofs1) : [
                    proofs1
                ];
            }
            function resolveBranchProofs1(node1, proof1 = new Uint8Array(), depth1 = 0) {
                if ("leaf" == node1.type) return {
                    offset: node1.maxByteRange - 1,
                    proof: (0, utils_11.concatBuffers)([
                        proof1,
                        node1.dataHash,
                        intToBuffer1(node1.maxByteRange)
                    ])
                };
                if ("branch" == node1.type) {
                    const partialProof1 = (0, utils_11.concatBuffers)([
                        proof1,
                        node1.leftChild.id,
                        node1.rightChild.id,
                        intToBuffer1(node1.byteRange)
                    ]);
                    return [
                        resolveBranchProofs1(node1.leftChild, partialProof1, depth1 + 1),
                        resolveBranchProofs1(node1.rightChild, partialProof1, depth1 + 1)
                    ];
                }
                throw Error("Unexpected node type");
            }
            function arrayFlatten1(input1) {
                const flat1 = [];
                return input1.forEach((item1)=>{
                    Array.isArray(item1) ? flat1.push(...arrayFlatten1(item1)) : flat1.push(item1);
                }), flat1;
            }
            async function hashBranch1(left1, right1) {
                return right1 ? {
                    type: "branch",
                    id: await hash1([
                        await hash1(left1.id),
                        await hash1(right1.id),
                        await hash1(intToBuffer1(left1.maxByteRange))
                    ]),
                    byteRange: left1.maxByteRange,
                    maxByteRange: right1.maxByteRange,
                    leftChild: left1,
                    rightChild: right1
                } : left1;
            }
            async function hash1(data1) {
                return Array.isArray(data1) && (data1 = common_11.default.utils.concatBuffers(data1)), new Uint8Array(await common_11.default.crypto.hash(data1));
            }
            function intToBuffer1(note1) {
                const buffer1 = new Uint8Array(NOTE_SIZE1);
                for(var i2 = buffer1.length - 1; i2 >= 0; i2--){
                    var byte1 = note1 % 256;
                    buffer1[i2] = byte1, note1 = (note1 - byte1) / 256;
                }
                return buffer1;
            }
            function bufferToInt1(buffer1) {
                let value1 = 0;
                for(var i2 = 0; i2 < buffer1.length; i2++)value1 *= 256, value1 += buffer1[i2];
                return value1;
            }
            exports1.chunkData = chunkData1, exports1.generateLeaves = generateLeaves1, exports1.computeRootHash = computeRootHash1, exports1.generateTree = generateTree1, exports1.generateTransactionChunks = generateTransactionChunks1, exports1.buildLayers = buildLayers1, exports1.generateProofs = generateProofs1, exports1.arrayFlatten = arrayFlatten1, exports1.intToBuffer = intToBuffer1, exports1.bufferToInt = bufferToInt1;
            const arrayCompare1 = (a10, b10)=>a10.every((value1, index1)=>b10[index1] === value1);
            async function validatePath1(id1, dest1, leftBound1, rightBound1, path1) {
                if (rightBound1 <= 0) return !1;
                if (dest1 >= rightBound1) return validatePath1(id1, 0, rightBound1 - 1, rightBound1, path1);
                if (dest1 < 0) return validatePath1(id1, 0, 0, rightBound1, path1);
                if (path1.length == HASH_SIZE1 + NOTE_SIZE1) {
                    const pathData1 = path1.slice(0, HASH_SIZE1), endOffsetBuffer1 = path1.slice(pathData1.length, pathData1.length + NOTE_SIZE1), pathDataHash1 = await hash1([
                        await hash1(pathData1),
                        await hash1(endOffsetBuffer1)
                    ]);
                    return !!(0, exports1.arrayCompare)(id1, pathDataHash1) && {
                        offset: rightBound1 - 1,
                        leftBound: leftBound1,
                        rightBound: rightBound1,
                        chunkSize: rightBound1 - leftBound1
                    };
                }
                const left1 = path1.slice(0, HASH_SIZE1), right1 = path1.slice(left1.length, left1.length + HASH_SIZE1), offsetBuffer1 = path1.slice(left1.length + right1.length, left1.length + right1.length + NOTE_SIZE1), offset1 = bufferToInt1(offsetBuffer1), remainder1 = path1.slice(left1.length + right1.length + offsetBuffer1.length), pathHash1 = await hash1([
                    await hash1(left1),
                    await hash1(right1),
                    await hash1(offsetBuffer1)
                ]);
                return !!(0, exports1.arrayCompare)(id1, pathHash1) && (dest1 < offset1 ? await validatePath1(left1, dest1, leftBound1, Math.min(rightBound1, offset1), remainder1) : await validatePath1(right1, dest1, Math.max(leftBound1, offset1), rightBound1, remainder1));
            }
            async function debug1(proof1, output1 = "") {
                if (proof1.byteLength < 1) return output1;
                const left1 = proof1.slice(0, HASH_SIZE1), right1 = proof1.slice(left1.length, left1.length + HASH_SIZE1), offsetBuffer1 = proof1.slice(left1.length + right1.length, left1.length + right1.length + NOTE_SIZE1), offset1 = bufferToInt1(offsetBuffer1), remainder1 = proof1.slice(left1.length + right1.length + offsetBuffer1.length), pathHash1 = await hash1([
                    await hash1(left1),
                    await hash1(right1),
                    await hash1(offsetBuffer1)
                ]), updatedOutput1 = `${output1}\n${JSON.stringify(Buffer1.from(left1))},${JSON.stringify(Buffer1.from(right1))},${offset1} => ${JSON.stringify(pathHash1)}`;
                return debug1(remainder1, updatedOutput1);
            }
            exports1.arrayCompare = arrayCompare1, exports1.validatePath = validatePath1, exports1.debug = debug1;
        },
        4107: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            }, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.TransactionUploader = void 0;
            const transaction_11 = __importDefault1(__webpack_require__1(7241)), ArweaveUtils1 = __importStar1(__webpack_require__1(5160)), error_11 = __webpack_require__1(2990), merkle_11 = __webpack_require__1(1612), MAX_CHUNKS_IN_BODY1 = 1, FATAL_CHUNK_UPLOAD_ERRORS1 = [
                "invalid_json",
                "chunk_too_big",
                "data_path_too_big",
                "offset_too_big",
                "data_size_too_big",
                "chunk_proof_ratio_not_attractive",
                "invalid_proof"
            ], ERROR_DELAY1 = 40000;
            class TransactionUploader1 {
                constructor(api1, transaction1){
                    if (this.api = api1, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !transaction1.id) throw Error("Transaction is not signed");
                    if (!transaction1.chunks) throw Error("Transaction chunks not prepared");
                    this.data = transaction1.data, this.transaction = new transaction_11.default(Object.assign({}, transaction1, {
                        data: new Uint8Array(0)
                    }));
                }
                get isComplete() {
                    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
                }
                get totalChunks() {
                    return this.transaction.chunks.chunks.length;
                }
                get uploadedChunks() {
                    return this.chunkIndex;
                }
                get pctComplete() {
                    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
                }
                async uploadChunk(chunkIndex_1) {
                    if (this.isComplete) throw Error("Upload is already complete");
                    if ("" !== this.lastResponseError ? this.totalErrors++ : this.totalErrors = 0, 100 === this.totalErrors) throw Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
                    let delay1 = "" === this.lastResponseError ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY1 - Date.now(), ERROR_DELAY1);
                    if (delay1 > 0 && (delay1 -= delay1 * Math.random() * 0.3, await new Promise((res1)=>setTimeout(res1, delay1))), this.lastResponseError = "", !this.txPosted) {
                        await this.postTransaction();
                        return;
                    }
                    chunkIndex_1 && (this.chunkIndex = chunkIndex_1);
                    const chunk1 = this.transaction.getChunk(chunkIndex_1 || this.chunkIndex, this.data), chunkOk1 = await (0, merkle_11.validatePath)(this.transaction.chunks.data_root, parseInt(chunk1.offset), 0, parseInt(chunk1.data_size), ArweaveUtils1.b64UrlToBuffer(chunk1.data_path));
                    if (!chunkOk1) throw Error(`Unable to validate chunk ${this.chunkIndex}`);
                    const resp1 = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((e1)=>(console.error(e1.message), {
                            status: -1,
                            data: {
                                error: e1.message
                            }
                        }));
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, 200 == this.lastResponseStatus) this.chunkIndex++;
                    else if (this.lastResponseError = (0, error_11.getError)(resp1), FATAL_CHUNK_UPLOAD_ERRORS1.includes(this.lastResponseError)) throw Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
                }
                static async fromSerialized(api1, serialized1, data1) {
                    if (!serialized1 || "number" != typeof serialized1.chunkIndex || "object" != typeof serialized1.transaction) throw Error("Serialized object does not match expected format.");
                    var transaction1 = new transaction_11.default(serialized1.transaction);
                    transaction1.chunks || await transaction1.prepareChunks(data1);
                    const upload1 = new TransactionUploader1(api1, transaction1);
                    if (upload1.chunkIndex = serialized1.chunkIndex, upload1.lastRequestTimeEnd = serialized1.lastRequestTimeEnd, upload1.lastResponseError = serialized1.lastResponseError, upload1.lastResponseStatus = serialized1.lastResponseStatus, upload1.txPosted = serialized1.txPosted, upload1.data = data1, upload1.transaction.data_root !== serialized1.transaction.data_root) throw Error("Data mismatch: Uploader doesn't match provided data.");
                    return upload1;
                }
                static async fromTransactionId(api1, id1) {
                    const resp1 = await api1.get(`tx/${id1}`);
                    if (200 !== resp1.status) throw Error(`Tx ${id1} not found: ${resp1.status}`);
                    const transaction1 = resp1.data;
                    transaction1.data = new Uint8Array(0);
                    const serialized1 = {
                        txPosted: !0,
                        chunkIndex: 0,
                        lastResponseError: "",
                        lastRequestTimeEnd: 0,
                        lastResponseStatus: 0,
                        transaction: transaction1
                    };
                    return serialized1;
                }
                toJSON() {
                    return {
                        chunkIndex: this.chunkIndex,
                        transaction: this.transaction,
                        lastRequestTimeEnd: this.lastRequestTimeEnd,
                        lastResponseStatus: this.lastResponseStatus,
                        lastResponseError: this.lastResponseError,
                        txPosted: this.txPosted
                    };
                }
                async postTransaction() {
                    const uploadInBody1 = this.totalChunks <= MAX_CHUNKS_IN_BODY1;
                    if (uploadInBody1) {
                        this.transaction.data = this.data;
                        const resp1 = await this.api.post("tx", this.transaction).catch((e1)=>(console.error(e1), {
                                status: -1,
                                data: {
                                    error: e1.message
                                }
                            }));
                        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, this.transaction.data = new Uint8Array(0), resp1.status >= 200 && resp1.status < 300) {
                            this.txPosted = !0, this.chunkIndex = MAX_CHUNKS_IN_BODY1;
                            return;
                        }
                        throw this.lastResponseError = (0, error_11.getError)(resp1), Error(`Unable to upload transaction: ${resp1.status}, ${this.lastResponseError}`);
                    }
                    const resp1 = await this.api.post("tx", this.transaction);
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, !(resp1.status >= 200 && resp1.status < 300)) throw this.lastResponseError = (0, error_11.getError)(resp1), Error(`Unable to upload transaction: ${resp1.status}, ${this.lastResponseError}`);
                    this.txPosted = !0;
                }
            }
            exports1.TransactionUploader = TransactionUploader1;
        },
        7241: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            }, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.Tag = void 0;
            const ArweaveUtils1 = __importStar1(__webpack_require__1(5160)), deepHash_11 = __importDefault1(__webpack_require__1(7439)), merkle_11 = __webpack_require__1(1612);
            class BaseObject1 {
                get(field1, options1) {
                    if (!Object.getOwnPropertyNames(this).includes(field1)) throw Error(`Field "${field1}" is not a property of the Arweave Transaction class.`);
                    return this[field1] instanceof Uint8Array ? options1 && options1.decode && options1.string ? ArweaveUtils1.bufferToString(this[field1]) : options1 && options1.decode && !options1.string ? this[field1] : ArweaveUtils1.bufferTob64Url(this[field1]) : options1 && !0 == options1.decode ? options1 && options1.string ? ArweaveUtils1.b64UrlToString(this[field1]) : ArweaveUtils1.b64UrlToBuffer(this[field1]) : this[field1];
                }
            }
            class Tag1 extends BaseObject1 {
                constructor(name1, value1, decode1 = !1){
                    super(), this.name = name1, this.value = value1;
                }
            }
            exports1.Tag = Tag1;
            class Transaction1 extends BaseObject1 {
                constructor(attributes1 = {}){
                    super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, attributes1), "string" == typeof this.data && (this.data = ArweaveUtils1.b64UrlToBuffer(this.data)), attributes1.tags && (this.tags = attributes1.tags.map((tag1)=>new Tag1(tag1.name, tag1.value)));
                }
                addTag(name1, value1) {
                    this.tags.push(new Tag1(ArweaveUtils1.stringToB64Url(name1), ArweaveUtils1.stringToB64Url(value1)));
                }
                toJSON() {
                    return {
                        format: this.format,
                        id: this.id,
                        last_tx: this.last_tx,
                        owner: this.owner,
                        tags: this.tags,
                        target: this.target,
                        quantity: this.quantity,
                        data: ArweaveUtils1.bufferTob64Url(this.data),
                        data_size: this.data_size,
                        data_root: this.data_root,
                        data_tree: this.data_tree,
                        reward: this.reward,
                        signature: this.signature
                    };
                }
                setOwner(owner1) {
                    this.owner = owner1;
                }
                setSignature({ id: id1 , owner: owner1 , reward: reward1 , tags: tags1 , signature: signature1  }) {
                    this.id = id1, this.owner = owner1, reward1 && (this.reward = reward1), tags1 && (this.tags = tags1), this.signature = signature1;
                }
                async prepareChunks(data1) {
                    !this.chunks && data1.byteLength > 0 && (this.chunks = await (0, merkle_11.generateTransactionChunks)(data1), this.data_root = ArweaveUtils1.bufferTob64Url(this.chunks.data_root)), this.chunks || 0 !== data1.byteLength || (this.chunks = {
                        chunks: [],
                        data_root: new Uint8Array(),
                        proofs: []
                    }, this.data_root = "");
                }
                getChunk(idx1, data1) {
                    if (!this.chunks) throw Error("Chunks have not been prepared");
                    const proof1 = this.chunks.proofs[idx1], chunk1 = this.chunks.chunks[idx1];
                    return {
                        data_root: this.data_root,
                        data_size: this.data_size,
                        data_path: ArweaveUtils1.bufferTob64Url(proof1.proof),
                        offset: proof1.offset.toString(),
                        chunk: ArweaveUtils1.bufferTob64Url(data1.slice(chunk1.minByteRange, chunk1.maxByteRange))
                    };
                }
                async getSignatureData() {
                    switch(this.format){
                        case 1:
                            let tags1 = this.tags.reduce((accumulator1, tag1)=>ArweaveUtils1.concatBuffers([
                                    accumulator1,
                                    tag1.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag1.get("value", {
                                        decode: !0,
                                        string: !1
                                    })
                                ]), new Uint8Array());
                            return ArweaveUtils1.concatBuffers([
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("data", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils1.stringToBuffer(this.quantity),
                                ArweaveUtils1.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tags1
                            ]);
                        case 2:
                            this.data_root || await this.prepareChunks(this.data);
                            const tagList1 = this.tags.map((tag1)=>[
                                    tag1.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag1.get("value", {
                                        decode: !0,
                                        string: !1
                                    })
                                ]);
                            return await (0, deepHash_11.default)([
                                ArweaveUtils1.stringToBuffer(this.format.toString()),
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils1.stringToBuffer(this.quantity),
                                ArweaveUtils1.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tagList1,
                                ArweaveUtils1.stringToBuffer(this.data_size),
                                this.get("data_root", {
                                    decode: !0,
                                    string: !1
                                })
                            ]);
                        default:
                            throw Error(`Unexpected transaction format: ${this.format}`);
                    }
                }
            }
            exports1.default = Transaction1;
        },
        5160: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.b64UrlDecode = exports1.b64UrlEncode = exports1.bufferTob64Url = exports1.bufferTob64 = exports1.b64UrlToBuffer = exports1.stringToB64Url = exports1.stringToBuffer = exports1.bufferToString = exports1.b64UrlToString = exports1.concatBuffers = void 0;
            const B64js1 = __importStar1(__webpack_require__1(9742));
            function concatBuffers1(buffers1) {
                let total_length1 = 0;
                for(let i2 = 0; i2 < buffers1.length; i2++)total_length1 += buffers1[i2].byteLength;
                let temp1 = new Uint8Array(total_length1), offset1 = 0;
                temp1.set(new Uint8Array(buffers1[0]), offset1), offset1 += buffers1[0].byteLength;
                for(let i2 = 1; i2 < buffers1.length; i2++)temp1.set(new Uint8Array(buffers1[i2]), offset1), offset1 += buffers1[i2].byteLength;
                return temp1;
            }
            function b64UrlToString1(b64UrlString1) {
                let buffer1 = b64UrlToBuffer1(b64UrlString1);
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__1(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer1);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer1);
            }
            function bufferToString1(buffer1) {
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__1(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer1);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer1);
            }
            function stringToBuffer1(string1) {
                if ("undefined" == typeof TextEncoder) {
                    const TextEncoder1 = __webpack_require__1(9539).TextEncoder;
                    return new TextEncoder1().encode(string1);
                }
                return new TextEncoder().encode(string1);
            }
            function stringToB64Url1(string1) {
                return bufferTob64Url1(stringToBuffer1(string1));
            }
            function b64UrlToBuffer1(b64UrlString1) {
                return new Uint8Array(B64js1.toByteArray(b64UrlDecode1(b64UrlString1)));
            }
            function bufferTob641(buffer1) {
                return B64js1.fromByteArray(new Uint8Array(buffer1));
            }
            function bufferTob64Url1(buffer1) {
                return b64UrlEncode1(bufferTob641(buffer1));
            }
            function b64UrlEncode1(b64UrlString1) {
                return b64UrlString1.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
            }
            function b64UrlDecode1(b64UrlString1) {
                let padding1;
                return padding1 = (b64UrlString1 = b64UrlString1.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - b64UrlString1.length % 4, b64UrlString1.concat("=".repeat(padding1));
            }
            exports1.concatBuffers = concatBuffers1, exports1.b64UrlToString = b64UrlToString1, exports1.bufferToString = bufferToString1, exports1.stringToBuffer = stringToBuffer1, exports1.stringToB64Url = stringToB64Url1, exports1.b64UrlToBuffer = b64UrlToBuffer1, exports1.bufferTob64 = bufferTob641, exports1.bufferTob64Url = bufferTob64Url1, exports1.b64UrlEncode = b64UrlEncode1, exports1.b64UrlDecode = b64UrlDecode1;
        },
        5764: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            class Network1 {
                constructor(api1){
                    this.api = api1;
                }
                getInfo() {
                    return this.api.get("info").then((response1)=>response1.data);
                }
                getPeers() {
                    return this.api.get("peers").then((response1)=>response1.data);
                }
            }
            exports1.default = Network1;
        },
        4486: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.SiloResource = void 0;
            const ArweaveUtils1 = __importStar1(__webpack_require__1(5160));
            class Silo1 {
                constructor(api1, crypto1, transactions1){
                    this.api = api1, this.crypto = crypto1, this.transactions = transactions1;
                }
                async get(siloURI1) {
                    if (!siloURI1) throw Error("No Silo URI specified");
                    const resource1 = await this.parseUri(siloURI1), ids1 = await this.transactions.search("Silo-Name", resource1.getAccessKey());
                    if (0 == ids1.length) throw Error(`No data could be found for the Silo URI: ${siloURI1}`);
                    const transaction1 = await this.transactions.get(ids1[0]);
                    if (!transaction1) throw Error(`No data could be found for the Silo URI: ${siloURI1}`);
                    const encrypted1 = transaction1.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted1, resource1.getEncryptionKey());
                }
                async readTransactionData(transaction1, siloURI1) {
                    if (!siloURI1) throw Error("No Silo URI specified");
                    const resource1 = await this.parseUri(siloURI1), encrypted1 = transaction1.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted1, resource1.getEncryptionKey());
                }
                async parseUri(siloURI1) {
                    const parsed1 = siloURI1.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
                    if (!parsed1) throw Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
                    const siloName1 = parsed1[1], hashIterations1 = Math.pow(2, parseInt(parsed1[2])), digest1 = await this.hash(ArweaveUtils1.stringToBuffer(siloName1), hashIterations1), accessKey1 = ArweaveUtils1.bufferTob64(digest1.slice(0, 15)), encryptionkey1 = await this.hash(digest1.slice(16, 31), 1);
                    return new SiloResource1(siloURI1, accessKey1, encryptionkey1);
                }
                async hash(input1, iterations1) {
                    let digest1 = await this.crypto.hash(input1);
                    for(let count1 = 0; count1 < iterations1 - 1; count1++)digest1 = await this.crypto.hash(digest1);
                    return digest1;
                }
            }
            exports1.default = Silo1;
            class SiloResource1 {
                constructor(uri1, accessKey1, encryptionKey1){
                    this.uri = uri1, this.accessKey = accessKey1, this.encryptionKey = encryptionKey1;
                }
                getUri() {
                    return this.uri;
                }
                getAccessKey() {
                    return this.accessKey;
                }
                getEncryptionKey() {
                    return this.encryptionKey;
                }
            }
            exports1.SiloResource = SiloResource1;
        },
        5385: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            }, __await1 = this && this.__await || function(v3) {
                return this instanceof __await1 ? (this.v = v3, this) : new __await1(v3);
            }, __asyncGenerator1 = this && this.__asyncGenerator || function(thisArg1, _arguments1, generator1) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var i2, g3 = generator1.apply(thisArg1, _arguments1 || []), q3 = [];
                return i2 = {}, verb1("next"), verb1("throw"), verb1("return"), i2[Symbol.asyncIterator] = function() {
                    return this;
                }, i2;
                function verb1(n2) {
                    g3[n2] && (i2[n2] = function(v3) {
                        return new Promise(function(a10, b10) {
                            q3.push([
                                n2,
                                v3,
                                a10,
                                b10
                            ]) > 1 || resume1(n2, v3);
                        });
                    });
                }
                function resume1(n2, v3) {
                    try {
                        step1(g3[n2](v3));
                    } catch (e1) {
                        settle1(q3[0][3], e1);
                    }
                }
                function step1(r3) {
                    r3.value instanceof __await1 ? Promise.resolve(r3.value.v).then(fulfill1, reject1) : settle1(q3[0][2], r3);
                }
                function fulfill1(value1) {
                    resume1("next", value1);
                }
                function reject1(value1) {
                    resume1("throw", value1);
                }
                function settle1(f1, v3) {
                    f1(v3), q3.shift(), q3.length && resume1(q3[0][0], q3[0][1]);
                }
            }, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const error_11 = __importDefault1(__webpack_require__1(2990)), transaction_11 = __importDefault1(__webpack_require__1(7241)), ArweaveUtils1 = __importStar1(__webpack_require__1(5160)), transaction_uploader_11 = __webpack_require__1(4107);
            __webpack_require__1(1317);
            class Transactions1 {
                constructor(api1, crypto1, chunks1){
                    this.api = api1, this.crypto = crypto1, this.chunks = chunks1;
                }
                getTransactionAnchor() {
                    return this.api.get("tx_anchor", {
                        transformResponse: []
                    }).then((response1)=>response1.data);
                }
                getPrice(byteSize1, targetAddress1) {
                    let endpoint1 = targetAddress1 ? `price/${byteSize1}/${targetAddress1}` : `price/${byteSize1}`;
                    return this.api.get(endpoint1, {
                        transformResponse: [
                            function(data1) {
                                return data1;
                            }
                        ]
                    }).then((response1)=>response1.data);
                }
                async get(id1) {
                    const response1 = await this.api.get(`tx/${id1}`);
                    if (200 == response1.status) {
                        const data_size1 = parseInt(response1.data.data_size);
                        if (response1.data.format >= 2 && data_size1 > 0 && data_size1 <= 12582912) {
                            const data1 = await this.getData(id1);
                            return new transaction_11.default(Object.assign(Object.assign({}, response1.data), {
                                data: data1
                            }));
                        }
                        return new transaction_11.default(Object.assign(Object.assign({}, response1.data), {
                            format: response1.data.format || 1
                        }));
                    }
                    if (404 == response1.status) throw new error_11.default("TX_NOT_FOUND");
                    if (410 == response1.status) throw new error_11.default("TX_FAILED");
                    throw new error_11.default("TX_INVALID");
                }
                fromRaw(attributes1) {
                    return new transaction_11.default(attributes1);
                }
                async search(tagName1, tagValue1) {
                    return this.api.post("arql", {
                        op: "equals",
                        expr1: tagName1,
                        expr2: tagValue1
                    }).then((response1)=>response1.data ? response1.data : []);
                }
                getStatus(id1) {
                    return this.api.get(`tx/${id1}/status`).then((response1)=>200 == response1.status ? {
                            status: 200,
                            confirmed: response1.data
                        } : {
                            status: response1.status,
                            confirmed: null
                        });
                }
                async getData(id1, options1) {
                    let data1;
                    try {
                        data1 = await this.chunks.downloadChunkedData(id1);
                    } catch (error1) {
                        console.error(`Error while trying to download chunked data for ${id1}`), console.error(error1);
                    }
                    if (!data1) {
                        console.warn(`Falling back to gateway cache for ${id1}`);
                        try {
                            data1 = (await this.api.get(`/${id1}`)).data;
                        } catch (error1) {
                            console.error(`Error while trying to download contiguous data from gateway cache for ${id1}`), console.error(error1);
                        }
                    }
                    if (!data1) throw Error(`${id1} was not found!`);
                    return options1 && options1.decode && !options1.string ? data1 : options1 && options1.decode && options1.string ? ArweaveUtils1.bufferToString(data1) : ArweaveUtils1.bufferTob64Url(data1);
                }
                async sign(transaction1, jwk1, options1) {
                    if (jwk1 || "undefined" != typeof window && window.arweaveWallet) {
                        if (jwk1 && "use_wallet" !== jwk1) {
                            transaction1.setOwner(jwk1.n);
                            let dataToSign1 = await transaction1.getSignatureData(), rawSignature1 = await this.crypto.sign(jwk1, dataToSign1, options1), id1 = await this.crypto.hash(rawSignature1);
                            transaction1.setSignature({
                                id: ArweaveUtils1.bufferTob64Url(id1),
                                owner: jwk1.n,
                                signature: ArweaveUtils1.bufferTob64Url(rawSignature1)
                            });
                        } else {
                            try {
                                const existingPermissions1 = await window.arweaveWallet.getPermissions();
                                existingPermissions1.includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect([
                                    "SIGN_TRANSACTION"
                                ]);
                            } catch (_a1) {}
                            const signedTransaction1 = await window.arweaveWallet.sign(transaction1, options1);
                            transaction1.setSignature({
                                id: signedTransaction1.id,
                                owner: signedTransaction1.owner,
                                reward: signedTransaction1.reward,
                                tags: signedTransaction1.tags,
                                signature: signedTransaction1.signature
                            });
                        }
                    } else throw Error("A new Arweave transaction must provide the jwk parameter.");
                }
                async verify(transaction1) {
                    const signaturePayload1 = await transaction1.getSignatureData(), rawSignature1 = transaction1.get("signature", {
                        decode: !0,
                        string: !1
                    }), expectedId1 = ArweaveUtils1.bufferTob64Url(await this.crypto.hash(rawSignature1));
                    if (transaction1.id !== expectedId1) throw Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
                    return this.crypto.verify(transaction1.owner, signaturePayload1, rawSignature1);
                }
                async post(transaction1) {
                    if ("string" == typeof transaction1 ? transaction1 = new transaction_11.default(JSON.parse(transaction1)) : "function" == typeof transaction1.readInt32BE ? transaction1 = new transaction_11.default(JSON.parse(transaction1.toString())) : "object" != typeof transaction1 || transaction1 instanceof transaction_11.default || (transaction1 = new transaction_11.default(transaction1)), !(transaction1 instanceof transaction_11.default)) throw Error("Must be Transaction object");
                    transaction1.chunks || await transaction1.prepareChunks(transaction1.data);
                    const uploader1 = await this.getUploader(transaction1, transaction1.data);
                    try {
                        for(; !uploader1.isComplete;)await uploader1.uploadChunk();
                    } catch (e1) {
                        if (uploader1.lastResponseStatus > 0) return {
                            status: uploader1.lastResponseStatus,
                            statusText: uploader1.lastResponseError,
                            data: {
                                error: uploader1.lastResponseError
                            }
                        };
                        throw e1;
                    }
                    return {
                        status: 200,
                        statusText: "OK",
                        data: {}
                    };
                }
                async getUploader(upload1, data1) {
                    let uploader1;
                    if (data1 instanceof ArrayBuffer && (data1 = new Uint8Array(data1)), upload1 instanceof transaction_11.default) {
                        if (data1 || (data1 = upload1.data), !(data1 instanceof Uint8Array)) throw Error("Data format is invalid");
                        upload1.chunks || await upload1.prepareChunks(data1), (uploader1 = new transaction_uploader_11.TransactionUploader(this.api, upload1)).data && 0 !== uploader1.data.length || (uploader1.data = data1);
                    } else {
                        if ("string" == typeof upload1 && (upload1 = await transaction_uploader_11.TransactionUploader.fromTransactionId(this.api, upload1)), !data1 || !(data1 instanceof Uint8Array)) throw Error("Must provide data when resuming upload");
                        uploader1 = await transaction_uploader_11.TransactionUploader.fromSerialized(this.api, upload1, data1);
                    }
                    return uploader1;
                }
                upload(upload1, data1) {
                    return __asyncGenerator1(this, arguments, function*() {
                        const uploader1 = yield __await1(this.getUploader(upload1, data1));
                        for(; !uploader1.isComplete;)yield __await1(uploader1.uploadChunk()), yield yield __await1(uploader1);
                        return yield __await1(uploader1);
                    });
                }
            }
            exports1.default = Transactions1;
        },
        8379: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const ArweaveUtils1 = __importStar1(__webpack_require__1(5160));
            __webpack_require__1(1317);
            class Wallets1 {
                constructor(api1, crypto1){
                    this.api = api1, this.crypto = crypto1;
                }
                getBalance(address1) {
                    return this.api.get(`wallet/${address1}/balance`, {
                        transformResponse: [
                            function(data1) {
                                return data1;
                            }
                        ]
                    }).then((response1)=>response1.data);
                }
                getLastTransactionID(address1) {
                    return this.api.get(`wallet/${address1}/last_tx`).then((response1)=>response1.data);
                }
                generate() {
                    return this.crypto.generateJWK();
                }
                async jwkToAddress(jwk1) {
                    return jwk1 && "use_wallet" !== jwk1 ? this.getAddress(jwk1) : this.getAddress();
                }
                async getAddress(jwk1) {
                    if (jwk1 && "use_wallet" !== jwk1) return this.ownerToAddress(jwk1.n);
                    try {
                        await window.arweaveWallet.connect([
                            "ACCESS_ADDRESS"
                        ]);
                    } catch (_a1) {}
                    return window.arweaveWallet.getActiveAddress();
                }
                async ownerToAddress(owner1) {
                    return ArweaveUtils1.bufferTob64Url(await this.crypto.hash(ArweaveUtils1.b64UrlToBuffer(owner1)));
                }
            }
            exports1.default = Wallets1;
        },
        4586: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const bignumber_js_11 = __webpack_require__1(4431);
            class Ar1 {
                constructor(){
                    this.BigNum = (value1, decimals1)=>new (bignumber_js_11.BigNumber.clone({
                            DECIMAL_PLACES: decimals1
                        }))(value1);
                }
                winstonToAr(winstonString1, { formatted: formatted1 = !1 , decimals: decimals1 = 12 , trim: trim1 = !0  } = {}) {
                    let number1 = this.stringToBigNum(winstonString1, decimals1).shiftedBy(-12);
                    return formatted1 ? number1.toFormat(decimals1) : number1.toFixed(decimals1);
                }
                arToWinston(arString1, { formatted: formatted1 = !1  } = {}) {
                    let number1 = this.stringToBigNum(arString1).shiftedBy(12);
                    return formatted1 ? number1.toFormat() : number1.toFixed(0);
                }
                compare(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1), b10 = this.stringToBigNum(winstonStringB1);
                    return a10.comparedTo(b10);
                }
                isEqual(winstonStringA1, winstonStringB1) {
                    return 0 === this.compare(winstonStringA1, winstonStringB1);
                }
                isLessThan(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1), b10 = this.stringToBigNum(winstonStringB1);
                    return a10.isLessThan(b10);
                }
                isGreaterThan(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1), b10 = this.stringToBigNum(winstonStringB1);
                    return a10.isGreaterThan(b10);
                }
                add(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1);
                    return this.stringToBigNum(winstonStringB1), a10.plus(winstonStringB1).toFixed(0);
                }
                sub(winstonStringA1, winstonStringB1) {
                    let a10 = this.stringToBigNum(winstonStringA1);
                    return this.stringToBigNum(winstonStringB1), a10.minus(winstonStringB1).toFixed(0);
                }
                stringToBigNum(stringValue1, decimalPlaces1 = 12) {
                    return this.BigNum(stringValue1, decimalPlaces1);
                }
            }
            exports1.default = Ar1;
        },
        3759: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const error_11 = __webpack_require__1(5498);
            __webpack_require__1(1317);
            class Blocks1 {
                constructor(api1, network1){
                    this.api = api1, this.network = network1;
                }
                async get(indepHash1) {
                    const response1 = await this.api.get(`${Blocks1.ENDPOINT}${indepHash1}`);
                    if (200 === response1.status) return response1.data;
                    if (404 === response1.status) throw new error_11.default("BLOCK_NOT_FOUND");
                    throw Error(`Error while loading block data: ${response1}`);
                }
                async getCurrent() {
                    const { current: current1  } = await this.network.getInfo();
                    return await this.get(current1);
                }
            }
            exports1.default = Blocks1, Blocks1.ENDPOINT = "block/hash/";
        },
        6879: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const error_11 = __webpack_require__1(5498), ArweaveUtils1 = __webpack_require__1(8244);
            class Chunks1 {
                constructor(api1){
                    this.api = api1;
                }
                async getTransactionOffset(id1) {
                    const resp1 = await this.api.get(`tx/${id1}/offset`);
                    if (200 === resp1.status) return resp1.data;
                    throw Error(`Unable to get transaction offset: ${(0, error_11.getError)(resp1)}`);
                }
                async getChunk(offset1) {
                    const resp1 = await this.api.get(`chunk/${offset1}`);
                    if (200 === resp1.status) return resp1.data;
                    throw Error(`Unable to get chunk: ${(0, error_11.getError)(resp1)}`);
                }
                async getChunkData(offset1) {
                    const chunk1 = await this.getChunk(offset1), buf1 = ArweaveUtils1.b64UrlToBuffer(chunk1.chunk);
                    return buf1;
                }
                firstChunkOffset(offsetResponse1) {
                    return parseInt(offsetResponse1.offset) - parseInt(offsetResponse1.size) + 1;
                }
                async downloadChunkedData(id1) {
                    const offsetResponse1 = await this.getTransactionOffset(id1), size1 = parseInt(offsetResponse1.size), endOffset1 = parseInt(offsetResponse1.offset), startOffset1 = endOffset1 - size1 + 1, data1 = new Uint8Array(size1);
                    let byte1 = 0;
                    for(; byte1 < size1;){
                        let chunkData1;
                        this.api.config.logging && console.log(`[chunk] ${byte1}/${size1}`);
                        try {
                            chunkData1 = await this.getChunkData(startOffset1 + byte1);
                        } catch (error1) {
                            console.error(`[chunk] Failed to fetch chunk at offset ${startOffset1 + byte1}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
                        }
                        if (chunkData1) data1.set(chunkData1, byte1), byte1 += chunkData1.length;
                        else throw Error(`Couldn't complete data download at ${byte1}/${size1}`);
                    }
                    return data1;
                }
            }
            exports1.default = Chunks1;
        },
        536: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const ar_11 = __webpack_require__1(4586), api_11 = __webpack_require__1(6874), node_driver_11 = __webpack_require__1(9363), network_11 = __webpack_require__1(2248), transactions_11 = __webpack_require__1(6935), wallets_11 = __webpack_require__1(7927), transaction_11 = __webpack_require__1(7825), ArweaveUtils1 = __webpack_require__1(8244), silo_11 = __webpack_require__1(1243), chunks_11 = __webpack_require__1(6879), blocks_11 = __webpack_require__1(3759);
            class Arweave1 {
                constructor(apiConfig1){
                    this.api = new api_11.default(apiConfig1), this.wallets = new wallets_11.default(this.api, Arweave1.crypto), this.chunks = new chunks_11.default(this.api), this.transactions = new transactions_11.default(this.api, Arweave1.crypto, this.chunks), this.silo = new silo_11.default(this.api, this.crypto, this.transactions), this.network = new network_11.default(this.api), this.blocks = new blocks_11.default(this.api, this.network), this.ar = new ar_11.default();
                }
                get crypto() {
                    return Arweave1.crypto;
                }
                get utils() {
                    return Arweave1.utils;
                }
                getConfig() {
                    return {
                        api: this.api.getConfig(),
                        crypto: null
                    };
                }
                async createTransaction(attributes1, jwk1) {
                    const transaction1 = {};
                    if (Object.assign(transaction1, attributes1), !attributes1.data && !(attributes1.target && attributes1.quantity)) throw Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
                    if (void 0 == attributes1.owner && jwk1 && "use_wallet" !== jwk1 && (transaction1.owner = jwk1.n), void 0 == attributes1.last_tx && (transaction1.last_tx = await this.transactions.getTransactionAnchor()), "string" == typeof attributes1.data && (attributes1.data = ArweaveUtils1.stringToBuffer(attributes1.data)), attributes1.data instanceof ArrayBuffer && (attributes1.data = new Uint8Array(attributes1.data)), attributes1.data && !(attributes1.data instanceof Uint8Array)) throw Error("Expected data to be a string, Uint8Array or ArrayBuffer");
                    if (void 0 == attributes1.reward) {
                        const length1 = attributes1.data ? attributes1.data.byteLength : 0;
                        transaction1.reward = await this.transactions.getPrice(length1, transaction1.target);
                    }
                    transaction1.data_root = "", transaction1.data_size = attributes1.data ? attributes1.data.byteLength.toString() : "0", transaction1.data = attributes1.data || new Uint8Array(0);
                    const createdTransaction1 = new transaction_11.default(transaction1);
                    return await createdTransaction1.getSignatureData(), createdTransaction1;
                }
                async createSiloTransaction(attributes1, jwk1, siloUri1) {
                    const transaction1 = {};
                    if (Object.assign(transaction1, attributes1), !attributes1.data) throw Error("Silo transactions must have a 'data' value");
                    if (!siloUri1) throw Error("No Silo URI specified.");
                    if (attributes1.target || attributes1.quantity) throw Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
                    if (void 0 == attributes1.owner) {
                        if (!jwk1 || !jwk1.n) throw Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
                        transaction1.owner = jwk1.n;
                    }
                    void 0 == attributes1.last_tx && (transaction1.last_tx = await this.transactions.getTransactionAnchor());
                    const siloResource1 = await this.silo.parseUri(siloUri1);
                    if ("string" == typeof attributes1.data) {
                        const encrypted1 = await this.crypto.encrypt(ArweaveUtils1.stringToBuffer(attributes1.data), siloResource1.getEncryptionKey());
                        transaction1.reward = await this.transactions.getPrice(encrypted1.byteLength), transaction1.data = ArweaveUtils1.bufferTob64Url(encrypted1);
                    }
                    if (attributes1.data instanceof Uint8Array) {
                        const encrypted1 = await this.crypto.encrypt(attributes1.data, siloResource1.getEncryptionKey());
                        transaction1.reward = await this.transactions.getPrice(encrypted1.byteLength), transaction1.data = ArweaveUtils1.bufferTob64Url(encrypted1);
                    }
                    const siloTransaction1 = new transaction_11.default(transaction1);
                    return siloTransaction1.addTag("Silo-Name", siloResource1.getAccessKey()), siloTransaction1.addTag("Silo-Version", "0.1.0"), siloTransaction1;
                }
                arql(query1) {
                    return this.api.post("/arql", query1).then((response1)=>response1.data || []);
                }
            }
            exports1.default = Arweave1, Arweave1.crypto = new node_driver_11.default(), Arweave1.utils = ArweaveUtils1;
        },
        7386: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __exportStar1 = this && this.__exportStar || function(m1, exports1) {
                for(var p3 in m1)"default" === p3 || Object.prototype.hasOwnProperty.call(exports1, p3) || __createBinding1(exports1, m1, p3);
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const common_11 = __webpack_require__1(536);
            common_11.default.init = function(apiConfig1 = {}) {
                function getDefaultConfig1() {
                    const defaults1 = {
                        host: "arweave.net",
                        port: 443,
                        protocol: "https"
                    };
                    if (!window || !window.location || !window.location.protocol || !window.location.hostname) return defaults1;
                    const currentProtocol1 = window.location.protocol.replace(":", ""), currentHost1 = window.location.hostname, currentPort1 = window.location.port ? parseInt(window.location.port) : "https" == currentProtocol1 ? 443 : 80, isLocal1 = [
                        "localhost",
                        "127.0.0.1"
                    ].includes(currentHost1) || "file" == currentProtocol1;
                    return isLocal1 ? defaults1 : {
                        host: currentHost1,
                        port: currentPort1,
                        protocol: currentProtocol1
                    };
                }
                const defaultConfig1 = getDefaultConfig1(), protocol1 = apiConfig1.protocol || defaultConfig1.protocol, host1 = apiConfig1.host || defaultConfig1.host, port1 = apiConfig1.port || defaultConfig1.port;
                return new common_11.default(Object.assign(Object.assign({}, apiConfig1), {
                    host: host1,
                    protocol: protocol1,
                    port: port1
                }));
            }, window.Arweave = common_11.default, __exportStar1(__webpack_require__1(536), exports1), exports1.default = common_11.default;
        },
        6874: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const axios_11 = __webpack_require__1(9669);
            class Api1 {
                constructor(config3){
                    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(config3);
                }
                applyConfig(config3) {
                    this.config = this.mergeDefaults(config3);
                }
                getConfig() {
                    return this.config;
                }
                mergeDefaults(config3) {
                    const protocol1 = config3.protocol || "http", port1 = config3.port || ("https" === protocol1 ? 443 : 80);
                    return {
                        host: config3.host || "127.0.0.1",
                        protocol: protocol1,
                        port: port1,
                        timeout: config3.timeout || 20000,
                        logging: config3.logging || !1,
                        logger: config3.logger || console.log,
                        network: config3.network
                    };
                }
                async get(endpoint1, config3) {
                    try {
                        return await this.request().get(endpoint1, config3);
                    } catch (error1) {
                        if (error1.response && error1.response.status) return error1.response;
                        throw error1;
                    }
                }
                async post(endpoint1, body1, config3) {
                    try {
                        return await this.request().post(endpoint1, body1, config3);
                    } catch (error1) {
                        if (error1.response && error1.response.status) return error1.response;
                        throw error1;
                    }
                }
                request() {
                    const headers1 = {};
                    this.config.network && (headers1["x-network"] = this.config.network);
                    let instance1 = axios_11.default.create({
                        baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`,
                        timeout: this.config.timeout,
                        maxContentLength: 536870912,
                        headers: headers1
                    });
                    return this.config.logging && (instance1.interceptors.request.use((request1)=>(this.config.logger(`Requesting: ${request1.baseURL}/${request1.url}`), request1)), instance1.interceptors.response.use((response1)=>(this.config.logger(`Response:   ${response1.config.url} - ${response1.status}`), response1))), instance1;
                }
            }
            exports1.default = Api1;
        },
        9363: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const ArweaveUtils1 = __webpack_require__1(8244);
            class WebCryptoDriver1 {
                constructor(){
                    if (this.keyLength = 4096, this.publicExponent = 0x10001, this.hashAlgorithm = "sha256", !this.detectWebCrypto()) throw Error("SubtleCrypto not available!");
                    this.driver = crypto.subtle;
                }
                async generateJWK() {
                    let cryptoKey1 = await this.driver.generateKey({
                        name: "RSA-PSS",
                        modulusLength: 4096,
                        publicExponent: new Uint8Array([
                            0x01,
                            0x00,
                            0x01
                        ]),
                        hash: {
                            name: "SHA-256"
                        }
                    }, !0, [
                        "sign"
                    ]), jwk1 = await this.driver.exportKey("jwk", cryptoKey1.privateKey);
                    return {
                        kty: jwk1.kty,
                        e: jwk1.e,
                        n: jwk1.n,
                        d: jwk1.d,
                        p: jwk1.p,
                        q: jwk1.q,
                        dp: jwk1.dp,
                        dq: jwk1.dq,
                        qi: jwk1.qi
                    };
                }
                async sign(jwk1, data1, { saltLength: saltLength1  } = {}) {
                    let signature1 = await this.driver.sign({
                        name: "RSA-PSS",
                        saltLength: 32
                    }, await this.jwkToCryptoKey(jwk1), data1);
                    return new Uint8Array(signature1);
                }
                async hash(data1, algorithm1 = "SHA-256") {
                    let digest1 = await this.driver.digest(algorithm1, data1);
                    return new Uint8Array(digest1);
                }
                async verify(publicModulus1, data1, signature1) {
                    const publicKey1 = {
                        kty: "RSA",
                        e: "AQAB",
                        n: publicModulus1
                    }, key1 = await this.jwkToPublicCryptoKey(publicKey1), verifyWith321 = this.driver.verify({
                        name: "RSA-PSS",
                        saltLength: 32
                    }, key1, signature1, data1), verifyWith01 = this.driver.verify({
                        name: "RSA-PSS",
                        saltLength: 0
                    }, key1, signature1, data1);
                    return verifyWith321 || verifyWith01;
                }
                async jwkToCryptoKey(jwk1) {
                    return this.driver.importKey("jwk", jwk1, {
                        name: "RSA-PSS",
                        hash: {
                            name: "SHA-256"
                        }
                    }, !1, [
                        "sign"
                    ]);
                }
                async jwkToPublicCryptoKey(publicJwk1) {
                    return this.driver.importKey("jwk", publicJwk1, {
                        name: "RSA-PSS",
                        hash: {
                            name: "SHA-256"
                        }
                    }, !1, [
                        "verify"
                    ]);
                }
                detectWebCrypto() {
                    if ("undefined" == typeof crypto) return !1;
                    const subtle1 = null == crypto ? void 0 : crypto.subtle;
                    if (void 0 === subtle1) return !1;
                    const names1 = [
                        "generateKey",
                        "importKey",
                        "exportKey",
                        "digest",
                        "sign"
                    ];
                    return names1.every((name1)=>"function" == typeof subtle1[name1]);
                }
                async encrypt(data1, key1, salt1) {
                    const initialKey1 = await this.driver.importKey("raw", "string" == typeof key1 ? ArweaveUtils1.stringToBuffer(key1) : key1, {
                        name: "PBKDF2",
                        length: 32
                    }, !1, [
                        "deriveKey"
                    ]), derivedkey1 = await this.driver.deriveKey({
                        name: "PBKDF2",
                        salt: salt1 ? ArweaveUtils1.stringToBuffer(salt1) : ArweaveUtils1.stringToBuffer("salt"),
                        iterations: 100000,
                        hash: "SHA-256"
                    }, initialKey1, {
                        name: "AES-CBC",
                        length: 256
                    }, !1, [
                        "encrypt",
                        "decrypt"
                    ]), iv1 = new Uint8Array(16);
                    crypto.getRandomValues(iv1);
                    const encryptedData1 = await this.driver.encrypt({
                        name: "AES-CBC",
                        iv: iv1
                    }, derivedkey1, data1);
                    return ArweaveUtils1.concatBuffers([
                        iv1,
                        encryptedData1
                    ]);
                }
                async decrypt(encrypted1, key1, salt1) {
                    const initialKey1 = await this.driver.importKey("raw", "string" == typeof key1 ? ArweaveUtils1.stringToBuffer(key1) : key1, {
                        name: "PBKDF2",
                        length: 32
                    }, !1, [
                        "deriveKey"
                    ]), derivedkey1 = await this.driver.deriveKey({
                        name: "PBKDF2",
                        salt: salt1 ? ArweaveUtils1.stringToBuffer(salt1) : ArweaveUtils1.stringToBuffer("salt"),
                        iterations: 100000,
                        hash: "SHA-256"
                    }, initialKey1, {
                        name: "AES-CBC",
                        length: 256
                    }, !1, [
                        "encrypt",
                        "decrypt"
                    ]), iv1 = encrypted1.slice(0, 16), data1 = await this.driver.decrypt({
                        name: "AES-CBC",
                        iv: iv1
                    }, derivedkey1, encrypted1.slice(16));
                    return ArweaveUtils1.concatBuffers([
                        data1
                    ]);
                }
            }
            exports1.default = WebCryptoDriver1;
        },
        921: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const common_11 = __webpack_require__1(536);
            async function deepHash1(data1) {
                if (Array.isArray(data1)) {
                    const tag1 = common_11.default.utils.concatBuffers([
                        common_11.default.utils.stringToBuffer("list"),
                        common_11.default.utils.stringToBuffer(data1.length.toString())
                    ]);
                    return await deepHashChunks1(data1, await common_11.default.crypto.hash(tag1, "SHA-384"));
                }
                const tag1 = common_11.default.utils.concatBuffers([
                    common_11.default.utils.stringToBuffer("blob"),
                    common_11.default.utils.stringToBuffer(data1.byteLength.toString())
                ]), taggedHash1 = common_11.default.utils.concatBuffers([
                    await common_11.default.crypto.hash(tag1, "SHA-384"),
                    await common_11.default.crypto.hash(data1, "SHA-384")
                ]);
                return await common_11.default.crypto.hash(taggedHash1, "SHA-384");
            }
            async function deepHashChunks1(chunks1, acc1) {
                if (chunks1.length < 1) return acc1;
                const hashPair1 = common_11.default.utils.concatBuffers([
                    acc1,
                    await deepHash1(chunks1[0])
                ]), newAcc1 = await common_11.default.crypto.hash(hashPair1, "SHA-384");
                return await deepHashChunks1(chunks1.slice(1), newAcc1);
            }
            exports1.default = deepHash1;
        },
        5498: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.getError = void 0;
            class ArweaveError1 extends Error {
                constructor(type1, optional1 = {}){
                    optional1.message ? super(optional1.message) : super(), this.type = type1, this.response = optional1.response;
                }
                getType() {
                    return this.type;
                }
            }
            function getError1(resp1) {
                let data1 = resp1.data;
                if ("string" == typeof resp1.data) try {
                    data1 = JSON.parse(resp1.data);
                } catch (e1) {}
                if (resp1.data instanceof ArrayBuffer || resp1.data instanceof Uint8Array) try {
                    data1 = JSON.parse(data1.toString());
                } catch (e1) {}
                return data1 ? data1.error || data1 : resp1.statusText || "unknown";
            }
            exports1.default = ArweaveError1, exports1.getError = getError1;
        },
        8224: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(8764).Buffer;
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.debug = exports1.validatePath = exports1.arrayCompare = exports1.bufferToInt = exports1.intToBuffer = exports1.arrayFlatten = exports1.generateProofs = exports1.buildLayers = exports1.generateTransactionChunks = exports1.generateTree = exports1.computeRootHash = exports1.generateLeaves = exports1.chunkData = exports1.MIN_CHUNK_SIZE = exports1.MAX_CHUNK_SIZE = void 0;
            const common_11 = __webpack_require__1(536), utils_11 = __webpack_require__1(8244);
            exports1.MAX_CHUNK_SIZE = 262144, exports1.MIN_CHUNK_SIZE = 32768;
            const NOTE_SIZE1 = 32, HASH_SIZE1 = 32;
            async function chunkData1(data1) {
                let chunks1 = [], rest1 = data1, cursor1 = 0;
                for(; rest1.byteLength >= exports1.MAX_CHUNK_SIZE;){
                    let chunkSize1 = exports1.MAX_CHUNK_SIZE, nextChunkSize1 = rest1.byteLength - exports1.MAX_CHUNK_SIZE;
                    nextChunkSize1 > 0 && nextChunkSize1 < exports1.MIN_CHUNK_SIZE && (chunkSize1 = Math.ceil(rest1.byteLength / 2));
                    const chunk1 = rest1.slice(0, chunkSize1), dataHash1 = await common_11.default.crypto.hash(chunk1);
                    cursor1 += chunk1.byteLength, chunks1.push({
                        dataHash: dataHash1,
                        minByteRange: cursor1 - chunk1.byteLength,
                        maxByteRange: cursor1
                    }), rest1 = rest1.slice(chunkSize1);
                }
                return chunks1.push({
                    dataHash: await common_11.default.crypto.hash(rest1),
                    minByteRange: cursor1,
                    maxByteRange: cursor1 + rest1.byteLength
                }), chunks1;
            }
            async function generateLeaves1(chunks1) {
                return Promise.all(chunks1.map(async ({ dataHash: dataHash1 , minByteRange: minByteRange1 , maxByteRange: maxByteRange1  })=>({
                        type: "leaf",
                        id: await hash1(await Promise.all([
                            hash1(dataHash1),
                            hash1(intToBuffer1(maxByteRange1))
                        ])),
                        dataHash: dataHash1,
                        minByteRange: minByteRange1,
                        maxByteRange: maxByteRange1
                    })));
            }
            async function computeRootHash1(data1) {
                const rootNode1 = await generateTree1(data1);
                return rootNode1.id;
            }
            async function generateTree1(data1) {
                const rootNode1 = await buildLayers1(await generateLeaves1(await chunkData1(data1)));
                return rootNode1;
            }
            async function generateTransactionChunks1(data1) {
                const chunks1 = await chunkData1(data1), leaves1 = await generateLeaves1(chunks1), root1 = await buildLayers1(leaves1), proofs1 = await generateProofs1(root1), lastChunk1 = chunks1.slice(-1)[0];
                return lastChunk1.maxByteRange - lastChunk1.minByteRange == 0 && (chunks1.splice(chunks1.length - 1, 1), proofs1.splice(proofs1.length - 1, 1)), {
                    data_root: root1.id,
                    chunks: chunks1,
                    proofs: proofs1
                };
            }
            async function buildLayers1(nodes1, level1 = 0) {
                if (nodes1.length < 2) {
                    const root1 = nodes1[0];
                    return root1;
                }
                const nextLayer1 = [];
                for(let i2 = 0; i2 < nodes1.length; i2 += 2)nextLayer1.push(await hashBranch1(nodes1[i2], nodes1[i2 + 1]));
                return buildLayers1(nextLayer1, level1 + 1);
            }
            function generateProofs1(root1) {
                const proofs1 = resolveBranchProofs1(root1);
                return Array.isArray(proofs1) ? arrayFlatten1(proofs1) : [
                    proofs1
                ];
            }
            function resolveBranchProofs1(node1, proof1 = new Uint8Array(), depth1 = 0) {
                if ("leaf" == node1.type) return {
                    offset: node1.maxByteRange - 1,
                    proof: (0, utils_11.concatBuffers)([
                        proof1,
                        node1.dataHash,
                        intToBuffer1(node1.maxByteRange)
                    ])
                };
                if ("branch" == node1.type) {
                    const partialProof1 = (0, utils_11.concatBuffers)([
                        proof1,
                        node1.leftChild.id,
                        node1.rightChild.id,
                        intToBuffer1(node1.byteRange)
                    ]);
                    return [
                        resolveBranchProofs1(node1.leftChild, partialProof1, depth1 + 1),
                        resolveBranchProofs1(node1.rightChild, partialProof1, depth1 + 1)
                    ];
                }
                throw Error("Unexpected node type");
            }
            function arrayFlatten1(input1) {
                const flat1 = [];
                return input1.forEach((item1)=>{
                    Array.isArray(item1) ? flat1.push(...arrayFlatten1(item1)) : flat1.push(item1);
                }), flat1;
            }
            async function hashBranch1(left1, right1) {
                return right1 ? {
                    type: "branch",
                    id: await hash1([
                        await hash1(left1.id),
                        await hash1(right1.id),
                        await hash1(intToBuffer1(left1.maxByteRange))
                    ]),
                    byteRange: left1.maxByteRange,
                    maxByteRange: right1.maxByteRange,
                    leftChild: left1,
                    rightChild: right1
                } : left1;
            }
            async function hash1(data1) {
                return Array.isArray(data1) && (data1 = common_11.default.utils.concatBuffers(data1)), new Uint8Array(await common_11.default.crypto.hash(data1));
            }
            function intToBuffer1(note1) {
                const buffer1 = new Uint8Array(NOTE_SIZE1);
                for(var i2 = buffer1.length - 1; i2 >= 0; i2--){
                    var byte1 = note1 % 256;
                    buffer1[i2] = byte1, note1 = (note1 - byte1) / 256;
                }
                return buffer1;
            }
            function bufferToInt1(buffer1) {
                let value1 = 0;
                for(var i2 = 0; i2 < buffer1.length; i2++)value1 *= 256, value1 += buffer1[i2];
                return value1;
            }
            exports1.chunkData = chunkData1, exports1.generateLeaves = generateLeaves1, exports1.computeRootHash = computeRootHash1, exports1.generateTree = generateTree1, exports1.generateTransactionChunks = generateTransactionChunks1, exports1.buildLayers = buildLayers1, exports1.generateProofs = generateProofs1, exports1.arrayFlatten = arrayFlatten1, exports1.intToBuffer = intToBuffer1, exports1.bufferToInt = bufferToInt1;
            const arrayCompare1 = (a10, b10)=>a10.every((value1, index1)=>b10[index1] === value1);
            async function validatePath1(id1, dest1, leftBound1, rightBound1, path1) {
                if (rightBound1 <= 0) return !1;
                if (dest1 >= rightBound1) return validatePath1(id1, 0, rightBound1 - 1, rightBound1, path1);
                if (dest1 < 0) return validatePath1(id1, 0, 0, rightBound1, path1);
                if (path1.length == HASH_SIZE1 + NOTE_SIZE1) {
                    const pathData1 = path1.slice(0, HASH_SIZE1), endOffsetBuffer1 = path1.slice(pathData1.length, pathData1.length + NOTE_SIZE1), pathDataHash1 = await hash1([
                        await hash1(pathData1),
                        await hash1(endOffsetBuffer1)
                    ]);
                    return !!(0, exports1.arrayCompare)(id1, pathDataHash1) && {
                        offset: rightBound1 - 1,
                        leftBound: leftBound1,
                        rightBound: rightBound1,
                        chunkSize: rightBound1 - leftBound1
                    };
                }
                const left1 = path1.slice(0, HASH_SIZE1), right1 = path1.slice(left1.length, left1.length + HASH_SIZE1), offsetBuffer1 = path1.slice(left1.length + right1.length, left1.length + right1.length + NOTE_SIZE1), offset1 = bufferToInt1(offsetBuffer1), remainder1 = path1.slice(left1.length + right1.length + offsetBuffer1.length), pathHash1 = await hash1([
                    await hash1(left1),
                    await hash1(right1),
                    await hash1(offsetBuffer1)
                ]);
                return !!(0, exports1.arrayCompare)(id1, pathHash1) && (dest1 < offset1 ? await validatePath1(left1, dest1, leftBound1, Math.min(rightBound1, offset1), remainder1) : await validatePath1(right1, dest1, Math.max(leftBound1, offset1), rightBound1, remainder1));
            }
            async function debug1(proof1, output1 = "") {
                if (proof1.byteLength < 1) return output1;
                const left1 = proof1.slice(0, HASH_SIZE1), right1 = proof1.slice(left1.length, left1.length + HASH_SIZE1), offsetBuffer1 = proof1.slice(left1.length + right1.length, left1.length + right1.length + NOTE_SIZE1), offset1 = bufferToInt1(offsetBuffer1), remainder1 = proof1.slice(left1.length + right1.length + offsetBuffer1.length), pathHash1 = await hash1([
                    await hash1(left1),
                    await hash1(right1),
                    await hash1(offsetBuffer1)
                ]), updatedOutput1 = `${output1}\n${JSON.stringify(Buffer1.from(left1))},${JSON.stringify(Buffer1.from(right1))},${offset1} => ${JSON.stringify(pathHash1)}`;
                return debug1(remainder1, updatedOutput1);
            }
            exports1.arrayCompare = arrayCompare1, exports1.validatePath = validatePath1, exports1.debug = debug1;
        },
        1246: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.TransactionUploader = void 0;
            const transaction_11 = __webpack_require__1(7825), ArweaveUtils1 = __webpack_require__1(8244), error_11 = __webpack_require__1(5498), merkle_11 = __webpack_require__1(8224), MAX_CHUNKS_IN_BODY1 = 1, FATAL_CHUNK_UPLOAD_ERRORS1 = [
                "invalid_json",
                "chunk_too_big",
                "data_path_too_big",
                "offset_too_big",
                "data_size_too_big",
                "chunk_proof_ratio_not_attractive",
                "invalid_proof"
            ], ERROR_DELAY1 = 40000;
            class TransactionUploader1 {
                constructor(api1, transaction1){
                    if (this.api = api1, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !transaction1.id) throw Error("Transaction is not signed");
                    if (!transaction1.chunks) throw Error("Transaction chunks not prepared");
                    this.data = transaction1.data, this.transaction = new transaction_11.default(Object.assign({}, transaction1, {
                        data: new Uint8Array(0)
                    }));
                }
                get isComplete() {
                    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
                }
                get totalChunks() {
                    return this.transaction.chunks.chunks.length;
                }
                get uploadedChunks() {
                    return this.chunkIndex;
                }
                get pctComplete() {
                    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
                }
                async uploadChunk(chunkIndex_1) {
                    if (this.isComplete) throw Error("Upload is already complete");
                    if ("" !== this.lastResponseError ? this.totalErrors++ : this.totalErrors = 0, 100 === this.totalErrors) throw Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
                    let delay1 = "" === this.lastResponseError ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY1 - Date.now(), ERROR_DELAY1);
                    if (delay1 > 0 && (delay1 -= delay1 * Math.random() * 0.3, await new Promise((res1)=>setTimeout(res1, delay1))), this.lastResponseError = "", !this.txPosted) {
                        await this.postTransaction();
                        return;
                    }
                    chunkIndex_1 && (this.chunkIndex = chunkIndex_1);
                    const chunk1 = this.transaction.getChunk(chunkIndex_1 || this.chunkIndex, this.data), chunkOk1 = await (0, merkle_11.validatePath)(this.transaction.chunks.data_root, parseInt(chunk1.offset), 0, parseInt(chunk1.data_size), ArweaveUtils1.b64UrlToBuffer(chunk1.data_path));
                    if (!chunkOk1) throw Error(`Unable to validate chunk ${this.chunkIndex}`);
                    const resp1 = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((e1)=>(console.error(e1.message), {
                            status: -1,
                            data: {
                                error: e1.message
                            }
                        }));
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, 200 == this.lastResponseStatus) this.chunkIndex++;
                    else if (this.lastResponseError = (0, error_11.getError)(resp1), FATAL_CHUNK_UPLOAD_ERRORS1.includes(this.lastResponseError)) throw Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
                }
                static async fromSerialized(api1, serialized1, data1) {
                    if (!serialized1 || "number" != typeof serialized1.chunkIndex || "object" != typeof serialized1.transaction) throw Error("Serialized object does not match expected format.");
                    var transaction1 = new transaction_11.default(serialized1.transaction);
                    transaction1.chunks || await transaction1.prepareChunks(data1);
                    const upload1 = new TransactionUploader1(api1, transaction1);
                    if (upload1.chunkIndex = serialized1.chunkIndex, upload1.lastRequestTimeEnd = serialized1.lastRequestTimeEnd, upload1.lastResponseError = serialized1.lastResponseError, upload1.lastResponseStatus = serialized1.lastResponseStatus, upload1.txPosted = serialized1.txPosted, upload1.data = data1, upload1.transaction.data_root !== serialized1.transaction.data_root) throw Error("Data mismatch: Uploader doesn't match provided data.");
                    return upload1;
                }
                static async fromTransactionId(api1, id1) {
                    const resp1 = await api1.get(`tx/${id1}`);
                    if (200 !== resp1.status) throw Error(`Tx ${id1} not found: ${resp1.status}`);
                    const transaction1 = resp1.data;
                    transaction1.data = new Uint8Array(0);
                    const serialized1 = {
                        txPosted: !0,
                        chunkIndex: 0,
                        lastResponseError: "",
                        lastRequestTimeEnd: 0,
                        lastResponseStatus: 0,
                        transaction: transaction1
                    };
                    return serialized1;
                }
                toJSON() {
                    return {
                        chunkIndex: this.chunkIndex,
                        transaction: this.transaction,
                        lastRequestTimeEnd: this.lastRequestTimeEnd,
                        lastResponseStatus: this.lastResponseStatus,
                        lastResponseError: this.lastResponseError,
                        txPosted: this.txPosted
                    };
                }
                async postTransaction() {
                    const uploadInBody1 = this.totalChunks <= MAX_CHUNKS_IN_BODY1;
                    if (uploadInBody1) {
                        this.transaction.data = this.data;
                        const resp1 = await this.api.post("tx", this.transaction).catch((e1)=>(console.error(e1), {
                                status: -1,
                                data: {
                                    error: e1.message
                                }
                            }));
                        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, this.transaction.data = new Uint8Array(0), resp1.status >= 200 && resp1.status < 300) {
                            this.txPosted = !0, this.chunkIndex = MAX_CHUNKS_IN_BODY1;
                            return;
                        }
                        throw this.lastResponseError = (0, error_11.getError)(resp1), Error(`Unable to upload transaction: ${resp1.status}, ${this.lastResponseError}`);
                    }
                    const resp1 = await this.api.post("tx", this.transaction);
                    if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = resp1.status, !(resp1.status >= 200 && resp1.status < 300)) throw this.lastResponseError = (0, error_11.getError)(resp1), Error(`Unable to upload transaction: ${resp1.status}, ${this.lastResponseError}`);
                    this.txPosted = !0;
                }
            }
            exports1.TransactionUploader = TransactionUploader1;
        },
        7825: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.Tag = void 0;
            const ArweaveUtils1 = __webpack_require__1(8244), deepHash_11 = __webpack_require__1(921), merkle_11 = __webpack_require__1(8224);
            class BaseObject1 {
                get(field1, options1) {
                    if (!Object.getOwnPropertyNames(this).includes(field1)) throw Error(`Field "${field1}" is not a property of the Arweave Transaction class.`);
                    return this[field1] instanceof Uint8Array ? options1 && options1.decode && options1.string ? ArweaveUtils1.bufferToString(this[field1]) : options1 && options1.decode && !options1.string ? this[field1] : ArweaveUtils1.bufferTob64Url(this[field1]) : options1 && !0 == options1.decode ? options1 && options1.string ? ArweaveUtils1.b64UrlToString(this[field1]) : ArweaveUtils1.b64UrlToBuffer(this[field1]) : this[field1];
                }
            }
            class Tag1 extends BaseObject1 {
                constructor(name1, value1, decode1 = !1){
                    super(), this.name = name1, this.value = value1;
                }
            }
            exports1.Tag = Tag1;
            class Transaction1 extends BaseObject1 {
                constructor(attributes1 = {}){
                    super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, attributes1), "string" == typeof this.data && (this.data = ArweaveUtils1.b64UrlToBuffer(this.data)), attributes1.tags && (this.tags = attributes1.tags.map((tag1)=>new Tag1(tag1.name, tag1.value)));
                }
                addTag(name1, value1) {
                    this.tags.push(new Tag1(ArweaveUtils1.stringToB64Url(name1), ArweaveUtils1.stringToB64Url(value1)));
                }
                toJSON() {
                    return {
                        format: this.format,
                        id: this.id,
                        last_tx: this.last_tx,
                        owner: this.owner,
                        tags: this.tags,
                        target: this.target,
                        quantity: this.quantity,
                        data: ArweaveUtils1.bufferTob64Url(this.data),
                        data_size: this.data_size,
                        data_root: this.data_root,
                        data_tree: this.data_tree,
                        reward: this.reward,
                        signature: this.signature
                    };
                }
                setOwner(owner1) {
                    this.owner = owner1;
                }
                setSignature({ id: id1 , owner: owner1 , reward: reward1 , tags: tags1 , signature: signature1  }) {
                    this.id = id1, this.owner = owner1, reward1 && (this.reward = reward1), tags1 && (this.tags = tags1), this.signature = signature1;
                }
                async prepareChunks(data1) {
                    !this.chunks && data1.byteLength > 0 && (this.chunks = await (0, merkle_11.generateTransactionChunks)(data1), this.data_root = ArweaveUtils1.bufferTob64Url(this.chunks.data_root)), this.chunks || 0 !== data1.byteLength || (this.chunks = {
                        chunks: [],
                        data_root: new Uint8Array(),
                        proofs: []
                    }, this.data_root = "");
                }
                getChunk(idx1, data1) {
                    if (!this.chunks) throw Error("Chunks have not been prepared");
                    const proof1 = this.chunks.proofs[idx1], chunk1 = this.chunks.chunks[idx1];
                    return {
                        data_root: this.data_root,
                        data_size: this.data_size,
                        data_path: ArweaveUtils1.bufferTob64Url(proof1.proof),
                        offset: proof1.offset.toString(),
                        chunk: ArweaveUtils1.bufferTob64Url(data1.slice(chunk1.minByteRange, chunk1.maxByteRange))
                    };
                }
                async getSignatureData() {
                    switch(this.format){
                        case 1:
                            let tags1 = this.tags.reduce((accumulator1, tag1)=>ArweaveUtils1.concatBuffers([
                                    accumulator1,
                                    tag1.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag1.get("value", {
                                        decode: !0,
                                        string: !1
                                    })
                                ]), new Uint8Array());
                            return ArweaveUtils1.concatBuffers([
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("data", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils1.stringToBuffer(this.quantity),
                                ArweaveUtils1.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tags1
                            ]);
                        case 2:
                            this.data_root || await this.prepareChunks(this.data);
                            const tagList1 = this.tags.map((tag1)=>[
                                    tag1.get("name", {
                                        decode: !0,
                                        string: !1
                                    }),
                                    tag1.get("value", {
                                        decode: !0,
                                        string: !1
                                    })
                                ]);
                            return await (0, deepHash_11.default)([
                                ArweaveUtils1.stringToBuffer(this.format.toString()),
                                this.get("owner", {
                                    decode: !0,
                                    string: !1
                                }),
                                this.get("target", {
                                    decode: !0,
                                    string: !1
                                }),
                                ArweaveUtils1.stringToBuffer(this.quantity),
                                ArweaveUtils1.stringToBuffer(this.reward),
                                this.get("last_tx", {
                                    decode: !0,
                                    string: !1
                                }),
                                tagList1,
                                ArweaveUtils1.stringToBuffer(this.data_size),
                                this.get("data_root", {
                                    decode: !0,
                                    string: !1
                                })
                            ]);
                        default:
                            throw Error(`Unexpected transaction format: ${this.format}`);
                    }
                }
            }
            exports1.default = Transaction1;
        },
        8244: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.b64UrlDecode = exports1.b64UrlEncode = exports1.bufferTob64Url = exports1.bufferTob64 = exports1.b64UrlToBuffer = exports1.stringToB64Url = exports1.stringToBuffer = exports1.bufferToString = exports1.b64UrlToString = exports1.concatBuffers = void 0;
            const B64js1 = __webpack_require__1(9742);
            function concatBuffers1(buffers1) {
                let total_length1 = 0;
                for(let i2 = 0; i2 < buffers1.length; i2++)total_length1 += buffers1[i2].byteLength;
                let temp1 = new Uint8Array(total_length1), offset1 = 0;
                temp1.set(new Uint8Array(buffers1[0]), offset1), offset1 += buffers1[0].byteLength;
                for(let i2 = 1; i2 < buffers1.length; i2++)temp1.set(new Uint8Array(buffers1[i2]), offset1), offset1 += buffers1[i2].byteLength;
                return temp1;
            }
            function b64UrlToString1(b64UrlString1) {
                let buffer1 = b64UrlToBuffer1(b64UrlString1);
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__1(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer1);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer1);
            }
            function bufferToString1(buffer1) {
                if ("undefined" == typeof TextDecoder) {
                    const TextDecoder1 = __webpack_require__1(9539).TextDecoder;
                    return new TextDecoder1("utf-8", {
                        fatal: !0
                    }).decode(buffer1);
                }
                return new TextDecoder("utf-8", {
                    fatal: !0
                }).decode(buffer1);
            }
            function stringToBuffer1(string1) {
                if ("undefined" == typeof TextEncoder) {
                    const TextEncoder1 = __webpack_require__1(9539).TextEncoder;
                    return new TextEncoder1().encode(string1);
                }
                return new TextEncoder().encode(string1);
            }
            function stringToB64Url1(string1) {
                return bufferTob64Url1(stringToBuffer1(string1));
            }
            function b64UrlToBuffer1(b64UrlString1) {
                return new Uint8Array(B64js1.toByteArray(b64UrlDecode1(b64UrlString1)));
            }
            function bufferTob641(buffer1) {
                return B64js1.fromByteArray(new Uint8Array(buffer1));
            }
            function bufferTob64Url1(buffer1) {
                return b64UrlEncode1(bufferTob641(buffer1));
            }
            function b64UrlEncode1(b64UrlString1) {
                return b64UrlString1.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
            }
            function b64UrlDecode1(b64UrlString1) {
                let padding1;
                return padding1 = (b64UrlString1 = b64UrlString1.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - b64UrlString1.length % 4, b64UrlString1.concat("=".repeat(padding1));
            }
            exports1.concatBuffers = concatBuffers1, exports1.b64UrlToString = b64UrlToString1, exports1.bufferToString = bufferToString1, exports1.stringToBuffer = stringToBuffer1, exports1.stringToB64Url = stringToB64Url1, exports1.b64UrlToBuffer = b64UrlToBuffer1, exports1.bufferTob64 = bufferTob641, exports1.bufferTob64Url = bufferTob64Url1, exports1.b64UrlEncode = b64UrlEncode1, exports1.b64UrlDecode = b64UrlDecode1;
        },
        2248: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            class Network1 {
                constructor(api1){
                    this.api = api1;
                }
                getInfo() {
                    return this.api.get("info").then((response1)=>response1.data);
                }
                getPeers() {
                    return this.api.get("peers").then((response1)=>response1.data);
                }
            }
            exports1.default = Network1;
        },
        1243: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.SiloResource = void 0;
            const ArweaveUtils1 = __webpack_require__1(8244);
            class Silo1 {
                constructor(api1, crypto1, transactions1){
                    this.api = api1, this.crypto = crypto1, this.transactions = transactions1;
                }
                async get(siloURI1) {
                    if (!siloURI1) throw Error("No Silo URI specified");
                    const resource1 = await this.parseUri(siloURI1), ids1 = await this.transactions.search("Silo-Name", resource1.getAccessKey());
                    if (0 == ids1.length) throw Error(`No data could be found for the Silo URI: ${siloURI1}`);
                    const transaction1 = await this.transactions.get(ids1[0]);
                    if (!transaction1) throw Error(`No data could be found for the Silo URI: ${siloURI1}`);
                    const encrypted1 = transaction1.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted1, resource1.getEncryptionKey());
                }
                async readTransactionData(transaction1, siloURI1) {
                    if (!siloURI1) throw Error("No Silo URI specified");
                    const resource1 = await this.parseUri(siloURI1), encrypted1 = transaction1.get("data", {
                        decode: !0,
                        string: !1
                    });
                    return this.crypto.decrypt(encrypted1, resource1.getEncryptionKey());
                }
                async parseUri(siloURI1) {
                    const parsed1 = siloURI1.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
                    if (!parsed1) throw Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
                    const siloName1 = parsed1[1], hashIterations1 = Math.pow(2, parseInt(parsed1[2])), digest1 = await this.hash(ArweaveUtils1.stringToBuffer(siloName1), hashIterations1), accessKey1 = ArweaveUtils1.bufferTob64(digest1.slice(0, 15)), encryptionkey1 = await this.hash(digest1.slice(16, 31), 1);
                    return new SiloResource1(siloURI1, accessKey1, encryptionkey1);
                }
                async hash(input1, iterations1) {
                    let digest1 = await this.crypto.hash(input1);
                    for(let count1 = 0; count1 < iterations1 - 1; count1++)digest1 = await this.crypto.hash(digest1);
                    return digest1;
                }
            }
            exports1.default = Silo1;
            class SiloResource1 {
                constructor(uri1, accessKey1, encryptionKey1){
                    this.uri = uri1, this.accessKey = accessKey1, this.encryptionKey = encryptionKey1;
                }
                getUri() {
                    return this.uri;
                }
                getAccessKey() {
                    return this.accessKey;
                }
                getEncryptionKey() {
                    return this.encryptionKey;
                }
            }
            exports1.SiloResource = SiloResource1;
        },
        6935: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __await1 = this && this.__await || function(v3) {
                return this instanceof __await1 ? (this.v = v3, this) : new __await1(v3);
            }, __asyncGenerator1 = this && this.__asyncGenerator || function(thisArg1, _arguments1, generator1) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var i2, g3 = generator1.apply(thisArg1, _arguments1 || []), q3 = [];
                return i2 = {}, verb1("next"), verb1("throw"), verb1("return"), i2[Symbol.asyncIterator] = function() {
                    return this;
                }, i2;
                function verb1(n2) {
                    g3[n2] && (i2[n2] = function(v3) {
                        return new Promise(function(a10, b10) {
                            q3.push([
                                n2,
                                v3,
                                a10,
                                b10
                            ]) > 1 || resume1(n2, v3);
                        });
                    });
                }
                function resume1(n2, v3) {
                    try {
                        step1(g3[n2](v3));
                    } catch (e1) {
                        settle1(q3[0][3], e1);
                    }
                }
                function step1(r3) {
                    r3.value instanceof __await1 ? Promise.resolve(r3.value.v).then(fulfill1, reject1) : settle1(q3[0][2], r3);
                }
                function fulfill1(value1) {
                    resume1("next", value1);
                }
                function reject1(value1) {
                    resume1("throw", value1);
                }
                function settle1(f1, v3) {
                    f1(v3), q3.shift(), q3.length && resume1(q3[0][0], q3[0][1]);
                }
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const error_11 = __webpack_require__1(5498), transaction_11 = __webpack_require__1(7825), ArweaveUtils1 = __webpack_require__1(8244), transaction_uploader_11 = __webpack_require__1(1246);
            __webpack_require__1(1317);
            class Transactions1 {
                constructor(api1, crypto1, chunks1){
                    this.api = api1, this.crypto = crypto1, this.chunks = chunks1;
                }
                getTransactionAnchor() {
                    return this.api.get("tx_anchor", {
                        transformResponse: []
                    }).then((response1)=>response1.data);
                }
                getPrice(byteSize1, targetAddress1) {
                    let endpoint1 = targetAddress1 ? `price/${byteSize1}/${targetAddress1}` : `price/${byteSize1}`;
                    return this.api.get(endpoint1, {
                        transformResponse: [
                            function(data1) {
                                return data1;
                            }
                        ]
                    }).then((response1)=>response1.data);
                }
                async get(id1) {
                    const response1 = await this.api.get(`tx/${id1}`);
                    if (200 == response1.status) {
                        const data_size1 = parseInt(response1.data.data_size);
                        if (response1.data.format >= 2 && data_size1 > 0 && data_size1 <= 12582912) {
                            const data1 = await this.getData(id1);
                            return new transaction_11.default(Object.assign(Object.assign({}, response1.data), {
                                data: data1
                            }));
                        }
                        return new transaction_11.default(Object.assign(Object.assign({}, response1.data), {
                            format: response1.data.format || 1
                        }));
                    }
                    if (404 == response1.status) throw new error_11.default("TX_NOT_FOUND");
                    if (410 == response1.status) throw new error_11.default("TX_FAILED");
                    throw new error_11.default("TX_INVALID");
                }
                fromRaw(attributes1) {
                    return new transaction_11.default(attributes1);
                }
                async search(tagName1, tagValue1) {
                    return this.api.post("arql", {
                        op: "equals",
                        expr1: tagName1,
                        expr2: tagValue1
                    }).then((response1)=>response1.data ? response1.data : []);
                }
                getStatus(id1) {
                    return this.api.get(`tx/${id1}/status`).then((response1)=>200 == response1.status ? {
                            status: 200,
                            confirmed: response1.data
                        } : {
                            status: response1.status,
                            confirmed: null
                        });
                }
                async getData(id1, options1) {
                    let data1;
                    try {
                        data1 = await this.chunks.downloadChunkedData(id1);
                    } catch (error1) {
                        console.error(`Error while trying to download chunked data for ${id1}`), console.error(error1);
                    }
                    if (!data1) {
                        console.warn(`Falling back to gateway cache for ${id1}`);
                        try {
                            data1 = (await this.api.get(`/${id1}`)).data;
                        } catch (error1) {
                            console.error(`Error while trying to download contiguous data from gateway cache for ${id1}`), console.error(error1);
                        }
                    }
                    if (!data1) throw Error(`${id1} was not found!`);
                    return options1 && options1.decode && !options1.string ? data1 : options1 && options1.decode && options1.string ? ArweaveUtils1.bufferToString(data1) : ArweaveUtils1.bufferTob64Url(data1);
                }
                async sign(transaction1, jwk1, options1) {
                    if (jwk1 || "undefined" != typeof window && window.arweaveWallet) {
                        if (jwk1 && "use_wallet" !== jwk1) {
                            transaction1.setOwner(jwk1.n);
                            let dataToSign1 = await transaction1.getSignatureData(), rawSignature1 = await this.crypto.sign(jwk1, dataToSign1, options1), id1 = await this.crypto.hash(rawSignature1);
                            transaction1.setSignature({
                                id: ArweaveUtils1.bufferTob64Url(id1),
                                owner: jwk1.n,
                                signature: ArweaveUtils1.bufferTob64Url(rawSignature1)
                            });
                        } else {
                            try {
                                const existingPermissions1 = await window.arweaveWallet.getPermissions();
                                existingPermissions1.includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect([
                                    "SIGN_TRANSACTION"
                                ]);
                            } catch (_a1) {}
                            const signedTransaction1 = await window.arweaveWallet.sign(transaction1, options1);
                            transaction1.setSignature({
                                id: signedTransaction1.id,
                                owner: signedTransaction1.owner,
                                reward: signedTransaction1.reward,
                                tags: signedTransaction1.tags,
                                signature: signedTransaction1.signature
                            });
                        }
                    } else throw Error("A new Arweave transaction must provide the jwk parameter.");
                }
                async verify(transaction1) {
                    const signaturePayload1 = await transaction1.getSignatureData(), rawSignature1 = transaction1.get("signature", {
                        decode: !0,
                        string: !1
                    }), expectedId1 = ArweaveUtils1.bufferTob64Url(await this.crypto.hash(rawSignature1));
                    if (transaction1.id !== expectedId1) throw Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
                    return this.crypto.verify(transaction1.owner, signaturePayload1, rawSignature1);
                }
                async post(transaction1) {
                    if ("string" == typeof transaction1 ? transaction1 = new transaction_11.default(JSON.parse(transaction1)) : "function" == typeof transaction1.readInt32BE ? transaction1 = new transaction_11.default(JSON.parse(transaction1.toString())) : "object" != typeof transaction1 || transaction1 instanceof transaction_11.default || (transaction1 = new transaction_11.default(transaction1)), !(transaction1 instanceof transaction_11.default)) throw Error("Must be Transaction object");
                    transaction1.chunks || await transaction1.prepareChunks(transaction1.data);
                    const uploader1 = await this.getUploader(transaction1, transaction1.data);
                    try {
                        for(; !uploader1.isComplete;)await uploader1.uploadChunk();
                    } catch (e1) {
                        if (uploader1.lastResponseStatus > 0) return {
                            status: uploader1.lastResponseStatus,
                            statusText: uploader1.lastResponseError,
                            data: {
                                error: uploader1.lastResponseError
                            }
                        };
                        throw e1;
                    }
                    return {
                        status: 200,
                        statusText: "OK",
                        data: {}
                    };
                }
                async getUploader(upload1, data1) {
                    let uploader1;
                    if (data1 instanceof ArrayBuffer && (data1 = new Uint8Array(data1)), upload1 instanceof transaction_11.default) {
                        if (data1 || (data1 = upload1.data), !(data1 instanceof Uint8Array)) throw Error("Data format is invalid");
                        upload1.chunks || await upload1.prepareChunks(data1), (uploader1 = new transaction_uploader_11.TransactionUploader(this.api, upload1)).data && 0 !== uploader1.data.length || (uploader1.data = data1);
                    } else {
                        if ("string" == typeof upload1 && (upload1 = await transaction_uploader_11.TransactionUploader.fromTransactionId(this.api, upload1)), !data1 || !(data1 instanceof Uint8Array)) throw Error("Must provide data when resuming upload");
                        uploader1 = await transaction_uploader_11.TransactionUploader.fromSerialized(this.api, upload1, data1);
                    }
                    return uploader1;
                }
                upload(upload1, data1) {
                    return __asyncGenerator1(this, arguments, function*() {
                        const uploader1 = yield __await1(this.getUploader(upload1, data1));
                        for(; !uploader1.isComplete;)yield __await1(uploader1.uploadChunk()), yield yield __await1(uploader1);
                        return yield __await1(uploader1);
                    });
                }
            }
            exports1.default = Transactions1;
        },
        7927: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
            const ArweaveUtils1 = __webpack_require__1(8244);
            __webpack_require__1(1317);
            class Wallets1 {
                constructor(api1, crypto1){
                    this.api = api1, this.crypto = crypto1;
                }
                getBalance(address1) {
                    return this.api.get(`wallet/${address1}/balance`, {
                        transformResponse: [
                            function(data1) {
                                return data1;
                            }
                        ]
                    }).then((response1)=>response1.data);
                }
                getLastTransactionID(address1) {
                    return this.api.get(`wallet/${address1}/last_tx`).then((response1)=>response1.data);
                }
                generate() {
                    return this.crypto.generateJWK();
                }
                async jwkToAddress(jwk1) {
                    return jwk1 && "use_wallet" !== jwk1 ? this.getAddress(jwk1) : this.getAddress();
                }
                async getAddress(jwk1) {
                    if (jwk1 && "use_wallet" !== jwk1) return this.ownerToAddress(jwk1.n);
                    try {
                        await window.arweaveWallet.connect([
                            "ACCESS_ADDRESS"
                        ]);
                    } catch (_a1) {}
                    return window.arweaveWallet.getActiveAddress();
                }
                async ownerToAddress(owner1) {
                    return ArweaveUtils1.bufferTob64Url(await this.crypto.hash(ArweaveUtils1.b64UrlToBuffer(owner1)));
                }
            }
            exports1.default = Wallets1;
        },
        9809: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const asn11 = exports1;
            asn11.bignum = __webpack_require__1(3550), asn11.define = __webpack_require__1(2500).define, asn11.base = __webpack_require__1(1979), asn11.constants = __webpack_require__1(6826), asn11.decoders = __webpack_require__1(8307), asn11.encoders = __webpack_require__1(6579);
        },
        2500: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const encoders1 = __webpack_require__1(6579), decoders1 = __webpack_require__1(8307), inherits1 = __webpack_require__1(5717), api1 = exports1;
            function Entity1(name1, body1) {
                this.name = name1, this.body = body1, this.decoders = {}, this.encoders = {};
            }
            api1.define = function(name1, body1) {
                return new Entity1(name1, body1);
            }, Entity1.prototype._createNamed = function(Base1) {
                const name1 = this.name;
                function Generated1(entity1) {
                    this._initNamed(entity1, name1);
                }
                return inherits1(Generated1, Base1), Generated1.prototype._initNamed = function(entity1, name1) {
                    Base1.call(this, entity1, name1);
                }, new Generated1(this);
            }, Entity1.prototype._getDecoder = function(enc1) {
                return enc1 = enc1 || 'der', this.decoders.hasOwnProperty(enc1) || (this.decoders[enc1] = this._createNamed(decoders1[enc1])), this.decoders[enc1];
            }, Entity1.prototype.decode = function(data1, enc1, options1) {
                return this._getDecoder(enc1).decode(data1, options1);
            }, Entity1.prototype._getEncoder = function(enc1) {
                return enc1 = enc1 || 'der', this.encoders.hasOwnProperty(enc1) || (this.encoders[enc1] = this._createNamed(encoders1[enc1])), this.encoders[enc1];
            }, Entity1.prototype.encode = function(data1, enc1, reporter1) {
                return this._getEncoder(enc1).encode(data1, reporter1);
            };
        },
        6625: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const inherits1 = __webpack_require__1(5717), Reporter1 = __webpack_require__1(8465).b, Buffer1 = __webpack_require__1(2399).Buffer;
            function DecoderBuffer1(base1, options1) {
                if (Reporter1.call(this, options1), !Buffer1.isBuffer(base1)) {
                    this.error('Input not Buffer');
                    return;
                }
                this.base = base1, this.offset = 0, this.length = base1.length;
            }
            function EncoderBuffer1(value1, reporter1) {
                if (Array.isArray(value1)) this.length = 0, this.value = value1.map(function(item1) {
                    return EncoderBuffer1.isEncoderBuffer(item1) || (item1 = new EncoderBuffer1(item1, reporter1)), this.length += item1.length, item1;
                }, this);
                else if ('number' == typeof value1) {
                    if (!(0 <= value1 && value1 <= 0xff)) return reporter1.error('non-byte EncoderBuffer value');
                    this.value = value1, this.length = 1;
                } else if ('string' == typeof value1) this.value = value1, this.length = Buffer1.byteLength(value1);
                else {
                    if (!Buffer1.isBuffer(value1)) return reporter1.error('Unsupported type: ' + typeof value1);
                    this.value = value1, this.length = value1.length;
                }
            }
            inherits1(DecoderBuffer1, Reporter1), exports1.C = DecoderBuffer1, DecoderBuffer1.isDecoderBuffer = function(data1) {
                if (data1 instanceof DecoderBuffer1) return !0;
                const isCompatible1 = 'object' == typeof data1 && Buffer1.isBuffer(data1.base) && 'DecoderBuffer' === data1.constructor.name && 'number' == typeof data1.offset && 'number' == typeof data1.length && 'function' == typeof data1.save && 'function' == typeof data1.restore && 'function' == typeof data1.isEmpty && 'function' == typeof data1.readUInt8 && 'function' == typeof data1.skip && 'function' == typeof data1.raw;
                return isCompatible1;
            }, DecoderBuffer1.prototype.save = function() {
                return {
                    offset: this.offset,
                    reporter: Reporter1.prototype.save.call(this)
                };
            }, DecoderBuffer1.prototype.restore = function(save1) {
                const res1 = new DecoderBuffer1(this.base);
                return res1.offset = save1.offset, res1.length = this.offset, this.offset = save1.offset, Reporter1.prototype.restore.call(this, save1.reporter), res1;
            }, DecoderBuffer1.prototype.isEmpty = function() {
                return this.offset === this.length;
            }, DecoderBuffer1.prototype.readUInt8 = function(fail1) {
                return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(fail1 || 'DecoderBuffer overrun');
            }, DecoderBuffer1.prototype.skip = function(bytes1, fail1) {
                if (!(this.offset + bytes1 <= this.length)) return this.error(fail1 || 'DecoderBuffer overrun');
                const res1 = new DecoderBuffer1(this.base);
                return res1._reporterState = this._reporterState, res1.offset = this.offset, res1.length = this.offset + bytes1, this.offset += bytes1, res1;
            }, DecoderBuffer1.prototype.raw = function(save1) {
                return this.base.slice(save1 ? save1.offset : this.offset, this.length);
            }, exports1.R = EncoderBuffer1, EncoderBuffer1.isEncoderBuffer = function(data1) {
                if (data1 instanceof EncoderBuffer1) return !0;
                const isCompatible1 = 'object' == typeof data1 && 'EncoderBuffer' === data1.constructor.name && 'number' == typeof data1.length && 'function' == typeof data1.join;
                return isCompatible1;
            }, EncoderBuffer1.prototype.join = function(out1, offset1) {
                return out1 || (out1 = Buffer1.alloc(this.length)), offset1 || (offset1 = 0), 0 === this.length || (Array.isArray(this.value) ? this.value.forEach(function(item1) {
                    item1.join(out1, offset1), offset1 += item1.length;
                }) : ('number' == typeof this.value ? out1[offset1] = this.value : 'string' == typeof this.value ? out1.write(this.value, offset1) : Buffer1.isBuffer(this.value) && this.value.copy(out1, offset1), offset1 += this.length)), out1;
            };
        },
        1979: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const base1 = exports1;
            base1.Reporter = __webpack_require__1(8465).b, base1.DecoderBuffer = __webpack_require__1(6625).C, base1.EncoderBuffer = __webpack_require__1(6625).R, base1.Node = __webpack_require__1(1949);
        },
        1949: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const Reporter1 = __webpack_require__1(8465).b, EncoderBuffer1 = __webpack_require__1(6625).R, DecoderBuffer1 = __webpack_require__1(6625).C, assert1 = __webpack_require__1(9746), tags1 = [
                'seq',
                'seqof',
                'set',
                'setof',
                'objid',
                'bool',
                'gentime',
                'utctime',
                'null_',
                'enum',
                'int',
                'objDesc',
                'bitstr',
                'bmpstr',
                'charstr',
                'genstr',
                'graphstr',
                'ia5str',
                'iso646str',
                'numstr',
                'octstr',
                'printstr',
                't61str',
                'unistr',
                'utf8str',
                'videostr'
            ], methods1 = [
                'key',
                'obj',
                'use',
                'optional',
                'explicit',
                'implicit',
                'def',
                'choice',
                'any',
                'contains'
            ].concat(tags1), overrided1 = [
                '_peekTag',
                '_decodeTag',
                '_use',
                '_decodeStr',
                '_decodeObjid',
                '_decodeTime',
                '_decodeNull',
                '_decodeInt',
                '_decodeBool',
                '_decodeList',
                '_encodeComposite',
                '_encodeStr',
                '_encodeObjid',
                '_encodeTime',
                '_encodeNull',
                '_encodeInt',
                '_encodeBool'
            ];
            function Node1(enc1, parent1, name1) {
                const state1 = {};
                this._baseState = state1, state1.name = name1, state1.enc = enc1, state1.parent = parent1 || null, state1.children = null, state1.tag = null, state1.args = null, state1.reverseArgs = null, state1.choice = null, state1.optional = !1, state1.any = !1, state1.obj = !1, state1.use = null, state1.useDecoder = null, state1.key = null, state1.default = null, state1.explicit = null, state1.implicit = null, state1.contains = null, state1.parent || (state1.children = [], this._wrap());
            }
            module1.exports = Node1;
            const stateProps1 = [
                'enc',
                'parent',
                'children',
                'tag',
                'args',
                'reverseArgs',
                'choice',
                'optional',
                'any',
                'obj',
                'use',
                'alteredUse',
                'key',
                'default',
                'explicit',
                'implicit',
                'contains'
            ];
            Node1.prototype.clone = function() {
                const state1 = this._baseState, cstate1 = {};
                stateProps1.forEach(function(prop1) {
                    cstate1[prop1] = state1[prop1];
                });
                const res1 = new this.constructor(cstate1.parent);
                return res1._baseState = cstate1, res1;
            }, Node1.prototype._wrap = function() {
                const state1 = this._baseState;
                methods1.forEach(function(method1) {
                    this[method1] = function() {
                        const clone1 = new this.constructor(this);
                        return state1.children.push(clone1), clone1[method1].apply(clone1, arguments);
                    };
                }, this);
            }, Node1.prototype._init = function(body1) {
                const state1 = this._baseState;
                assert1(null === state1.parent), body1.call(this), state1.children = state1.children.filter(function(child1) {
                    return child1._baseState.parent === this;
                }, this), assert1.equal(state1.children.length, 1, 'Root node can have only one child');
            }, Node1.prototype._useArgs = function(args1) {
                const state1 = this._baseState, children1 = args1.filter(function(arg4) {
                    return arg4 instanceof this.constructor;
                }, this);
                args1 = args1.filter(function(arg4) {
                    return !(arg4 instanceof this.constructor);
                }, this), 0 !== children1.length && (assert1(null === state1.children), state1.children = children1, children1.forEach(function(child1) {
                    child1._baseState.parent = this;
                }, this)), 0 !== args1.length && (assert1(null === state1.args), state1.args = args1, state1.reverseArgs = args1.map(function(arg4) {
                    if ('object' != typeof arg4 || arg4.constructor !== Object) return arg4;
                    const res1 = {};
                    return Object.keys(arg4).forEach(function(key1) {
                        key1 == (0 | key1) && (key1 |= 0);
                        const value1 = arg4[key1];
                        res1[value1] = key1;
                    }), res1;
                }));
            }, overrided1.forEach(function(method1) {
                Node1.prototype[method1] = function() {
                    const state1 = this._baseState;
                    throw Error(method1 + ' not implemented for encoding: ' + state1.enc);
                };
            }), tags1.forEach(function(tag1) {
                Node1.prototype[tag1] = function() {
                    const state1 = this._baseState, args1 = Array.prototype.slice.call(arguments);
                    return assert1(null === state1.tag), state1.tag = tag1, this._useArgs(args1), this;
                };
            }), Node1.prototype.use = function(item1) {
                assert1(item1);
                const state1 = this._baseState;
                return assert1(null === state1.use), state1.use = item1, this;
            }, Node1.prototype.optional = function() {
                const state1 = this._baseState;
                return state1.optional = !0, this;
            }, Node1.prototype.def = function(val1) {
                const state1 = this._baseState;
                return assert1(null === state1.default), state1.default = val1, state1.optional = !0, this;
            }, Node1.prototype.explicit = function(num1) {
                const state1 = this._baseState;
                return assert1(null === state1.explicit && null === state1.implicit), state1.explicit = num1, this;
            }, Node1.prototype.implicit = function(num1) {
                const state1 = this._baseState;
                return assert1(null === state1.explicit && null === state1.implicit), state1.implicit = num1, this;
            }, Node1.prototype.obj = function() {
                const state1 = this._baseState, args1 = Array.prototype.slice.call(arguments);
                return state1.obj = !0, 0 !== args1.length && this._useArgs(args1), this;
            }, Node1.prototype.key = function(newKey1) {
                const state1 = this._baseState;
                return assert1(null === state1.key), state1.key = newKey1, this;
            }, Node1.prototype.any = function() {
                const state1 = this._baseState;
                return state1.any = !0, this;
            }, Node1.prototype.choice = function(obj1) {
                const state1 = this._baseState;
                return assert1(null === state1.choice), state1.choice = obj1, this._useArgs(Object.keys(obj1).map(function(key1) {
                    return obj1[key1];
                })), this;
            }, Node1.prototype.contains = function(item1) {
                const state1 = this._baseState;
                return assert1(null === state1.use), state1.contains = item1, this;
            }, Node1.prototype._decode = function(input1, options1) {
                let prevObj1;
                const state1 = this._baseState;
                if (null === state1.parent) return input1.wrapResult(state1.children[0]._decode(input1, options1));
                let result1 = state1.default, present1 = !0, prevKey1 = null;
                if (null !== state1.key && (prevKey1 = input1.enterKey(state1.key)), state1.optional) {
                    let tag1 = null;
                    if (null !== state1.explicit ? tag1 = state1.explicit : null !== state1.implicit ? tag1 = state1.implicit : null !== state1.tag && (tag1 = state1.tag), null !== tag1 || state1.any) {
                        if (present1 = this._peekTag(input1, tag1, state1.any), input1.isError(present1)) return present1;
                    } else {
                        const save1 = input1.save();
                        try {
                            null === state1.choice ? this._decodeGeneric(state1.tag, input1, options1) : this._decodeChoice(input1, options1), present1 = !0;
                        } catch (e1) {
                            present1 = !1;
                        }
                        input1.restore(save1);
                    }
                }
                if (state1.obj && present1 && (prevObj1 = input1.enterObject()), present1) {
                    if (null !== state1.explicit) {
                        const explicit1 = this._decodeTag(input1, state1.explicit);
                        if (input1.isError(explicit1)) return explicit1;
                        input1 = explicit1;
                    }
                    const start1 = input1.offset;
                    if (null === state1.use && null === state1.choice) {
                        let save1;
                        state1.any && (save1 = input1.save());
                        const body1 = this._decodeTag(input1, null !== state1.implicit ? state1.implicit : state1.tag, state1.any);
                        if (input1.isError(body1)) return body1;
                        state1.any ? result1 = input1.raw(save1) : input1 = body1;
                    }
                    if (options1 && options1.track && null !== state1.tag && options1.track(input1.path(), start1, input1.length, 'tagged'), options1 && options1.track && null !== state1.tag && options1.track(input1.path(), input1.offset, input1.length, 'content'), state1.any || (result1 = null === state1.choice ? this._decodeGeneric(state1.tag, input1, options1) : this._decodeChoice(input1, options1)), input1.isError(result1)) return result1;
                    if (state1.any || null !== state1.choice || null === state1.children || state1.children.forEach(function(child1) {
                        child1._decode(input1, options1);
                    }), state1.contains && ('octstr' === state1.tag || 'bitstr' === state1.tag)) {
                        const data1 = new DecoderBuffer1(result1);
                        result1 = this._getUse(state1.contains, input1._reporterState.obj)._decode(data1, options1);
                    }
                }
                return state1.obj && present1 && (result1 = input1.leaveObject(prevObj1)), null !== state1.key && (null !== result1 || !0 === present1) ? input1.leaveKey(prevKey1, state1.key, result1) : null !== prevKey1 && input1.exitKey(prevKey1), result1;
            }, Node1.prototype._decodeGeneric = function(tag1, input1, options1) {
                const state1 = this._baseState;
                return 'seq' === tag1 || 'set' === tag1 ? null : 'seqof' === tag1 || 'setof' === tag1 ? this._decodeList(input1, tag1, state1.args[0], options1) : /str$/.test(tag1) ? this._decodeStr(input1, tag1, options1) : 'objid' === tag1 && state1.args ? this._decodeObjid(input1, state1.args[0], state1.args[1], options1) : 'objid' === tag1 ? this._decodeObjid(input1, null, null, options1) : 'gentime' === tag1 || 'utctime' === tag1 ? this._decodeTime(input1, tag1, options1) : 'null_' === tag1 ? this._decodeNull(input1, options1) : 'bool' === tag1 ? this._decodeBool(input1, options1) : 'objDesc' === tag1 ? this._decodeStr(input1, tag1, options1) : 'int' === tag1 || 'enum' === tag1 ? this._decodeInt(input1, state1.args && state1.args[0], options1) : null !== state1.use ? this._getUse(state1.use, input1._reporterState.obj)._decode(input1, options1) : input1.error('unknown tag: ' + tag1);
            }, Node1.prototype._getUse = function(entity1, obj1) {
                const state1 = this._baseState;
                return state1.useDecoder = this._use(entity1, obj1), assert1(null === state1.useDecoder._baseState.parent), state1.useDecoder = state1.useDecoder._baseState.children[0], state1.implicit !== state1.useDecoder._baseState.implicit && (state1.useDecoder = state1.useDecoder.clone(), state1.useDecoder._baseState.implicit = state1.implicit), state1.useDecoder;
            }, Node1.prototype._decodeChoice = function(input1, options1) {
                const state1 = this._baseState;
                let result1 = null, match1 = !1;
                return (Object.keys(state1.choice).some(function(key1) {
                    const save1 = input1.save(), node1 = state1.choice[key1];
                    try {
                        const value1 = node1._decode(input1, options1);
                        if (input1.isError(value1)) return !1;
                        result1 = {
                            type: key1,
                            value: value1
                        }, match1 = !0;
                    } catch (e1) {
                        return input1.restore(save1), !1;
                    }
                    return !0;
                }, this), match1) ? result1 : input1.error('Choice not matched');
            }, Node1.prototype._createEncoderBuffer = function(data1) {
                return new EncoderBuffer1(data1, this.reporter);
            }, Node1.prototype._encode = function(data1, reporter1, parent1) {
                const state1 = this._baseState;
                if (null !== state1.default && state1.default === data1) return;
                const result1 = this._encodeValue(data1, reporter1, parent1);
                if (void 0 !== result1 && !this._skipDefault(result1, reporter1, parent1)) return result1;
            }, Node1.prototype._encodeValue = function(data1, reporter1, parent1) {
                const state1 = this._baseState;
                if (null === state1.parent) return state1.children[0]._encode(data1, reporter1 || new Reporter1());
                let result1 = null;
                if (this.reporter = reporter1, state1.optional && void 0 === data1) {
                    if (null === state1.default) return;
                    data1 = state1.default;
                }
                let content1 = null, primitive1 = !1;
                if (state1.any) result1 = this._createEncoderBuffer(data1);
                else if (state1.choice) result1 = this._encodeChoice(data1, reporter1);
                else if (state1.contains) content1 = this._getUse(state1.contains, parent1)._encode(data1, reporter1), primitive1 = !0;
                else if (state1.children) content1 = state1.children.map(function(child1) {
                    if ('null_' === child1._baseState.tag) return child1._encode(null, reporter1, data1);
                    if (null === child1._baseState.key) return reporter1.error('Child should have a key');
                    const prevKey1 = reporter1.enterKey(child1._baseState.key);
                    if ('object' != typeof data1) return reporter1.error('Child expected, but input is not object');
                    const res1 = child1._encode(data1[child1._baseState.key], reporter1, data1);
                    return reporter1.leaveKey(prevKey1), res1;
                }, this).filter(function(child1) {
                    return child1;
                }), content1 = this._createEncoderBuffer(content1);
                else if ('seqof' === state1.tag || 'setof' === state1.tag) {
                    if (!(state1.args && 1 === state1.args.length)) return reporter1.error('Too many args for : ' + state1.tag);
                    if (!Array.isArray(data1)) return reporter1.error('seqof/setof, but data is not Array');
                    const child1 = this.clone();
                    child1._baseState.implicit = null, content1 = this._createEncoderBuffer(data1.map(function(item1) {
                        const state1 = this._baseState;
                        return this._getUse(state1.args[0], data1)._encode(item1, reporter1);
                    }, child1));
                } else null !== state1.use ? result1 = this._getUse(state1.use, parent1)._encode(data1, reporter1) : (content1 = this._encodePrimitive(state1.tag, data1), primitive1 = !0);
                if (!state1.any && null === state1.choice) {
                    const tag1 = null !== state1.implicit ? state1.implicit : state1.tag, cls1 = null === state1.implicit ? 'universal' : 'context';
                    null === tag1 ? null === state1.use && reporter1.error('Tag could be omitted only for .use()') : null === state1.use && (result1 = this._encodeComposite(tag1, primitive1, cls1, content1));
                }
                return null !== state1.explicit && (result1 = this._encodeComposite(state1.explicit, !1, 'context', result1)), result1;
            }, Node1.prototype._encodeChoice = function(data1, reporter1) {
                const state1 = this._baseState, node1 = state1.choice[data1.type];
                return node1 || assert1(!1, data1.type + ' not found in ' + JSON.stringify(Object.keys(state1.choice))), node1._encode(data1.value, reporter1);
            }, Node1.prototype._encodePrimitive = function(tag1, data1) {
                const state1 = this._baseState;
                if (/str$/.test(tag1)) return this._encodeStr(data1, tag1);
                if ('objid' === tag1 && state1.args) return this._encodeObjid(data1, state1.reverseArgs[0], state1.args[1]);
                if ('objid' === tag1) return this._encodeObjid(data1, null, null);
                if ('gentime' === tag1 || 'utctime' === tag1) return this._encodeTime(data1, tag1);
                if ('null_' === tag1) return this._encodeNull();
                if ('int' === tag1 || 'enum' === tag1) return this._encodeInt(data1, state1.args && state1.reverseArgs[0]);
                if ('bool' === tag1) return this._encodeBool(data1);
                if ('objDesc' === tag1) return this._encodeStr(data1, tag1);
                throw Error('Unsupported tag: ' + tag1);
            }, Node1.prototype._isNumstr = function(str1) {
                return /^[0-9 ]*$/.test(str1);
            }, Node1.prototype._isPrintstr = function(str1) {
                return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str1);
            };
        },
        8465: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const inherits1 = __webpack_require__1(5717);
            function Reporter1(options1) {
                this._reporterState = {
                    obj: null,
                    path: [],
                    options: options1 || {},
                    errors: []
                };
            }
            function ReporterError1(path1, msg1) {
                this.path = path1, this.rethrow(msg1);
            }
            exports1.b = Reporter1, Reporter1.prototype.isError = function(obj1) {
                return obj1 instanceof ReporterError1;
            }, Reporter1.prototype.save = function() {
                const state1 = this._reporterState;
                return {
                    obj: state1.obj,
                    pathLen: state1.path.length
                };
            }, Reporter1.prototype.restore = function(data1) {
                const state1 = this._reporterState;
                state1.obj = data1.obj, state1.path = state1.path.slice(0, data1.pathLen);
            }, Reporter1.prototype.enterKey = function(key1) {
                return this._reporterState.path.push(key1);
            }, Reporter1.prototype.exitKey = function(index1) {
                const state1 = this._reporterState;
                state1.path = state1.path.slice(0, index1 - 1);
            }, Reporter1.prototype.leaveKey = function(index1, key1, value1) {
                const state1 = this._reporterState;
                this.exitKey(index1), null !== state1.obj && (state1.obj[key1] = value1);
            }, Reporter1.prototype.path = function() {
                return this._reporterState.path.join('/');
            }, Reporter1.prototype.enterObject = function() {
                const state1 = this._reporterState, prev1 = state1.obj;
                return state1.obj = {}, prev1;
            }, Reporter1.prototype.leaveObject = function(prev1) {
                const state1 = this._reporterState, now1 = state1.obj;
                return state1.obj = prev1, now1;
            }, Reporter1.prototype.error = function(msg1) {
                let err1;
                const state1 = this._reporterState, inherited1 = msg1 instanceof ReporterError1;
                if (err1 = inherited1 ? msg1 : new ReporterError1(state1.path.map(function(elem1) {
                    return '[' + JSON.stringify(elem1) + ']';
                }).join(''), msg1.message || msg1, msg1.stack), !state1.options.partial) throw err1;
                return inherited1 || state1.errors.push(err1), err1;
            }, Reporter1.prototype.wrapResult = function(result1) {
                const state1 = this._reporterState;
                return state1.options.partial ? {
                    result: this.isError(result1) ? null : result1,
                    errors: state1.errors
                } : result1;
            }, inherits1(ReporterError1, Error), ReporterError1.prototype.rethrow = function(msg1) {
                if (this.message = msg1 + ' at: ' + (this.path || '(shallow)'), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError1), !this.stack) try {
                    throw Error(this.message);
                } catch (e1) {
                    this.stack = e1.stack;
                }
                return this;
            };
        },
        160: function(__unused_webpack_module1, exports1) {
            "use strict";
            function reverse1(map1) {
                const res1 = {};
                return Object.keys(map1).forEach(function(key1) {
                    (0 | key1) == key1 && (key1 |= 0);
                    const value1 = map1[key1];
                    res1[value1] = key1;
                }), res1;
            }
            exports1.tagClass = {
                0: 'universal',
                1: 'application',
                2: 'context',
                3: 'private'
            }, exports1.tagClassByName = reverse1(exports1.tagClass), exports1.tag = {
                0x00: 'end',
                0x01: 'bool',
                0x02: 'int',
                0x03: 'bitstr',
                0x04: 'octstr',
                0x05: 'null_',
                0x06: 'objid',
                0x07: 'objDesc',
                0x08: 'external',
                0x09: 'real',
                0x0a: 'enum',
                0x0b: 'embed',
                0x0c: 'utf8str',
                0x0d: 'relativeOid',
                0x10: 'seq',
                0x11: 'set',
                0x12: 'numstr',
                0x13: 'printstr',
                0x14: 't61str',
                0x15: 'videostr',
                0x16: 'ia5str',
                0x17: 'utctime',
                0x18: 'gentime',
                0x19: 'graphstr',
                0x1a: 'iso646str',
                0x1b: 'genstr',
                0x1c: 'unistr',
                0x1d: 'charstr',
                0x1e: 'bmpstr'
            }, exports1.tagByName = reverse1(exports1.tag);
        },
        6826: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const constants1 = exports1;
            constants1._reverse = function(map1) {
                const res1 = {};
                return Object.keys(map1).forEach(function(key1) {
                    (0 | key1) == key1 && (key1 |= 0);
                    const value1 = map1[key1];
                    res1[value1] = key1;
                }), res1;
            }, constants1.der = __webpack_require__1(160);
        },
        1671: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const inherits1 = __webpack_require__1(5717), bignum1 = __webpack_require__1(3550), DecoderBuffer1 = __webpack_require__1(6625).C, Node1 = __webpack_require__1(1949), der1 = __webpack_require__1(160);
            function DERDecoder1(entity1) {
                this.enc = 'der', this.name = entity1.name, this.entity = entity1, this.tree = new DERNode1(), this.tree._init(entity1.body);
            }
            function DERNode1(parent1) {
                Node1.call(this, 'der', parent1);
            }
            function derDecodeTag1(buf1, fail1) {
                let tag1 = buf1.readUInt8(fail1);
                if (buf1.isError(tag1)) return tag1;
                const cls1 = der1.tagClass[tag1 >> 6], primitive1 = (0x20 & tag1) == 0;
                if ((0x1f & tag1) == 0x1f) {
                    let oct1 = tag1;
                    for(tag1 = 0; (0x80 & oct1) == 0x80;){
                        if (oct1 = buf1.readUInt8(fail1), buf1.isError(oct1)) return oct1;
                        tag1 <<= 7, tag1 |= 0x7f & oct1;
                    }
                } else tag1 &= 0x1f;
                const tagStr1 = der1.tag[tag1];
                return {
                    cls: cls1,
                    primitive: primitive1,
                    tag: tag1,
                    tagStr: tagStr1
                };
            }
            function derDecodeLen1(buf1, primitive1, fail1) {
                let len3 = buf1.readUInt8(fail1);
                if (buf1.isError(len3)) return len3;
                if (!primitive1 && 0x80 === len3) return null;
                if ((0x80 & len3) == 0) return len3;
                const num1 = 0x7f & len3;
                if (num1 > 4) return buf1.error('length octect is too long');
                len3 = 0;
                for(let i2 = 0; i2 < num1; i2++){
                    len3 <<= 8;
                    const j1 = buf1.readUInt8(fail1);
                    if (buf1.isError(j1)) return j1;
                    len3 |= j1;
                }
                return len3;
            }
            module1.exports = DERDecoder1, DERDecoder1.prototype.decode = function(data1, options1) {
                return DecoderBuffer1.isDecoderBuffer(data1) || (data1 = new DecoderBuffer1(data1, options1)), this.tree._decode(data1, options1);
            }, inherits1(DERNode1, Node1), DERNode1.prototype._peekTag = function(buffer1, tag1, any1) {
                if (buffer1.isEmpty()) return !1;
                const state1 = buffer1.save(), decodedTag1 = derDecodeTag1(buffer1, 'Failed to peek tag: "' + tag1 + '"');
                return buffer1.isError(decodedTag1) ? decodedTag1 : (buffer1.restore(state1), decodedTag1.tag === tag1 || decodedTag1.tagStr === tag1 || decodedTag1.tagStr + 'of' === tag1 || any1);
            }, DERNode1.prototype._decodeTag = function(buffer1, tag1, any1) {
                const decodedTag1 = derDecodeTag1(buffer1, 'Failed to decode tag of "' + tag1 + '"');
                if (buffer1.isError(decodedTag1)) return decodedTag1;
                let len3 = derDecodeLen1(buffer1, decodedTag1.primitive, 'Failed to get length of "' + tag1 + '"');
                if (buffer1.isError(len3)) return len3;
                if (!any1 && decodedTag1.tag !== tag1 && decodedTag1.tagStr !== tag1 && decodedTag1.tagStr + 'of' !== tag1) return buffer1.error('Failed to match tag: "' + tag1 + '"');
                if (decodedTag1.primitive || null !== len3) return buffer1.skip(len3, 'Failed to match body of: "' + tag1 + '"');
                const state1 = buffer1.save(), res1 = this._skipUntilEnd(buffer1, 'Failed to skip indefinite length body: "' + this.tag + '"');
                return buffer1.isError(res1) ? res1 : (len3 = buffer1.offset - state1.offset, buffer1.restore(state1), buffer1.skip(len3, 'Failed to match body of: "' + tag1 + '"'));
            }, DERNode1.prototype._skipUntilEnd = function(buffer1, fail1) {
                for(;;){
                    let res1;
                    const tag1 = derDecodeTag1(buffer1, fail1);
                    if (buffer1.isError(tag1)) return tag1;
                    const len3 = derDecodeLen1(buffer1, tag1.primitive, fail1);
                    if (buffer1.isError(len3)) return len3;
                    if (res1 = tag1.primitive || null !== len3 ? buffer1.skip(len3) : this._skipUntilEnd(buffer1, fail1), buffer1.isError(res1)) return res1;
                    if ('end' === tag1.tagStr) break;
                }
            }, DERNode1.prototype._decodeList = function(buffer1, tag1, decoder1, options1) {
                const result1 = [];
                for(; !buffer1.isEmpty();){
                    const possibleEnd1 = this._peekTag(buffer1, 'end');
                    if (buffer1.isError(possibleEnd1)) return possibleEnd1;
                    const res1 = decoder1.decode(buffer1, 'der', options1);
                    if (buffer1.isError(res1) && possibleEnd1) break;
                    result1.push(res1);
                }
                return result1;
            }, DERNode1.prototype._decodeStr = function(buffer1, tag1) {
                if ('bitstr' === tag1) {
                    const unused1 = buffer1.readUInt8();
                    return buffer1.isError(unused1) ? unused1 : {
                        unused: unused1,
                        data: buffer1.raw()
                    };
                }
                if ('bmpstr' === tag1) {
                    const raw1 = buffer1.raw();
                    if (raw1.length % 2 == 1) return buffer1.error('Decoding of string type: bmpstr length mismatch');
                    let str1 = '';
                    for(let i2 = 0; i2 < raw1.length / 2; i2++)str1 += String.fromCharCode(raw1.readUInt16BE(2 * i2));
                    return str1;
                }
                if ('numstr' === tag1) {
                    const numstr1 = buffer1.raw().toString('ascii');
                    return this._isNumstr(numstr1) ? numstr1 : buffer1.error("Decoding of string type: numstr unsupported characters");
                }
                if ('octstr' === tag1 || 'objDesc' === tag1) return buffer1.raw();
                if ('printstr' === tag1) {
                    const printstr1 = buffer1.raw().toString('ascii');
                    return this._isPrintstr(printstr1) ? printstr1 : buffer1.error("Decoding of string type: printstr unsupported characters");
                }
                return /str$/.test(tag1) ? buffer1.raw().toString() : buffer1.error('Decoding of string type: ' + tag1 + ' unsupported');
            }, DERNode1.prototype._decodeObjid = function(buffer1, values1, relative1) {
                let result1;
                const identifiers1 = [];
                let ident1 = 0, subident1 = 0;
                for(; !buffer1.isEmpty();)subident1 = buffer1.readUInt8(), ident1 <<= 7, ident1 |= 0x7f & subident1, (0x80 & subident1) == 0 && (identifiers1.push(ident1), ident1 = 0);
                0x80 & subident1 && identifiers1.push(ident1);
                const first1 = identifiers1[0] / 40 | 0, second1 = identifiers1[0] % 40;
                if (result1 = relative1 ? identifiers1 : [
                    first1,
                    second1
                ].concat(identifiers1.slice(1)), values1) {
                    let tmp1 = values1[result1.join(' ')];
                    void 0 === tmp1 && (tmp1 = values1[result1.join('.')]), void 0 !== tmp1 && (result1 = tmp1);
                }
                return result1;
            }, DERNode1.prototype._decodeTime = function(buffer1, tag1) {
                let year1, mon1, day1, hour1, min1, sec1;
                const str1 = buffer1.raw().toString();
                if ('gentime' === tag1) year1 = 0 | str1.slice(0, 4), mon1 = 0 | str1.slice(4, 6), day1 = 0 | str1.slice(6, 8), hour1 = 0 | str1.slice(8, 10), min1 = 0 | str1.slice(10, 12), sec1 = 0 | str1.slice(12, 14);
                else {
                    if ('utctime' !== tag1) return buffer1.error('Decoding ' + tag1 + ' time is not supported yet');
                    year1 = 0 | str1.slice(0, 2), mon1 = 0 | str1.slice(2, 4), day1 = 0 | str1.slice(4, 6), hour1 = 0 | str1.slice(6, 8), min1 = 0 | str1.slice(8, 10), sec1 = 0 | str1.slice(10, 12), year1 = year1 < 70 ? 2000 + year1 : 1900 + year1;
                }
                return Date.UTC(year1, mon1 - 1, day1, hour1, min1, sec1, 0);
            }, DERNode1.prototype._decodeNull = function() {
                return null;
            }, DERNode1.prototype._decodeBool = function(buffer1) {
                const res1 = buffer1.readUInt8();
                return buffer1.isError(res1) ? res1 : 0 !== res1;
            }, DERNode1.prototype._decodeInt = function(buffer1, values1) {
                const raw1 = buffer1.raw();
                let res1 = new bignum1(raw1);
                return values1 && (res1 = values1[res1.toString(10)] || res1), res1;
            }, DERNode1.prototype._use = function(entity1, obj1) {
                return 'function' == typeof entity1 && (entity1 = entity1(obj1)), entity1._getDecoder('der').tree;
            };
        },
        8307: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const decoders1 = exports1;
            decoders1.der = __webpack_require__1(1671), decoders1.pem = __webpack_require__1(9631);
        },
        9631: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const inherits1 = __webpack_require__1(5717), Buffer1 = __webpack_require__1(2399).Buffer, DERDecoder1 = __webpack_require__1(1671);
            function PEMDecoder1(entity1) {
                DERDecoder1.call(this, entity1), this.enc = 'pem';
            }
            inherits1(PEMDecoder1, DERDecoder1), module1.exports = PEMDecoder1, PEMDecoder1.prototype.decode = function(data1, options1) {
                const lines1 = data1.toString().split(/[\r\n]+/g), label1 = options1.label.toUpperCase(), re1 = /^-----(BEGIN|END) ([^-]+)-----$/;
                let start1 = -1, end1 = -1;
                for(let i2 = 0; i2 < lines1.length; i2++){
                    const match1 = lines1[i2].match(re1);
                    if (null !== match1 && match1[2] === label1) {
                        if (-1 === start1) {
                            if ('BEGIN' !== match1[1]) break;
                            start1 = i2;
                        } else {
                            if ('END' !== match1[1]) break;
                            end1 = i2;
                            break;
                        }
                    }
                }
                if (-1 === start1 || -1 === end1) throw Error('PEM section not found for: ' + label1);
                const base641 = lines1.slice(start1 + 1, end1).join('');
                base641.replace(/[^a-z0-9+/=]+/gi, '');
                const input1 = Buffer1.from(base641, 'base64');
                return DERDecoder1.prototype.decode.call(this, input1, options1);
            };
        },
        6984: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const inherits1 = __webpack_require__1(5717), Buffer1 = __webpack_require__1(2399).Buffer, Node1 = __webpack_require__1(1949), der1 = __webpack_require__1(160);
            function DEREncoder1(entity1) {
                this.enc = 'der', this.name = entity1.name, this.entity = entity1, this.tree = new DERNode1(), this.tree._init(entity1.body);
            }
            function DERNode1(parent1) {
                Node1.call(this, 'der', parent1);
            }
            function two1(num1) {
                return num1 < 10 ? '0' + num1 : num1;
            }
            function encodeTag1(tag1, primitive1, cls1, reporter1) {
                let res1;
                if ('seqof' === tag1 ? tag1 = 'seq' : 'setof' === tag1 && (tag1 = 'set'), der1.tagByName.hasOwnProperty(tag1)) res1 = der1.tagByName[tag1];
                else {
                    if ('number' != typeof tag1 || (0 | tag1) !== tag1) return reporter1.error('Unknown tag: ' + tag1);
                    res1 = tag1;
                }
                return res1 >= 0x1f ? reporter1.error('Multi-octet tag encoding unsupported') : (primitive1 || (res1 |= 0x20), res1 |= der1.tagClassByName[cls1 || 'universal'] << 6);
            }
            module1.exports = DEREncoder1, DEREncoder1.prototype.encode = function(data1, reporter1) {
                return this.tree._encode(data1, reporter1).join();
            }, inherits1(DERNode1, Node1), DERNode1.prototype._encodeComposite = function(tag1, primitive1, cls1, content1) {
                const encodedTag1 = encodeTag1(tag1, primitive1, cls1, this.reporter);
                if (content1.length < 0x80) {
                    const header1 = Buffer1.alloc(2);
                    return header1[0] = encodedTag1, header1[1] = content1.length, this._createEncoderBuffer([
                        header1,
                        content1
                    ]);
                }
                let lenOctets1 = 1;
                for(let i2 = content1.length; i2 >= 0x100; i2 >>= 8)lenOctets1++;
                const header1 = Buffer1.alloc(2 + lenOctets1);
                header1[0] = encodedTag1, header1[1] = 0x80 | lenOctets1;
                for(let i2 = 1 + lenOctets1, j1 = content1.length; j1 > 0; i2--, j1 >>= 8)header1[i2] = 0xff & j1;
                return this._createEncoderBuffer([
                    header1,
                    content1
                ]);
            }, DERNode1.prototype._encodeStr = function(str1, tag1) {
                if ('bitstr' === tag1) return this._createEncoderBuffer([
                    0 | str1.unused,
                    str1.data
                ]);
                if ('bmpstr' === tag1) {
                    const buf1 = Buffer1.alloc(2 * str1.length);
                    for(let i2 = 0; i2 < str1.length; i2++)buf1.writeUInt16BE(str1.charCodeAt(i2), 2 * i2);
                    return this._createEncoderBuffer(buf1);
                }
                return 'numstr' === tag1 ? this._isNumstr(str1) ? this._createEncoderBuffer(str1) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : 'printstr' === tag1 ? this._isPrintstr(str1) ? this._createEncoderBuffer(str1) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(tag1) ? this._createEncoderBuffer(str1) : 'objDesc' === tag1 ? this._createEncoderBuffer(str1) : this.reporter.error('Encoding of string type: ' + tag1 + ' unsupported');
            }, DERNode1.prototype._encodeObjid = function(id1, values1, relative1) {
                if ('string' == typeof id1) {
                    if (!values1) return this.reporter.error('string objid given, but no values map found');
                    if (!values1.hasOwnProperty(id1)) return this.reporter.error('objid not found in values map');
                    id1 = values1[id1].split(/[\s.]+/g);
                    for(let i2 = 0; i2 < id1.length; i2++)id1[i2] |= 0;
                } else if (Array.isArray(id1)) {
                    id1 = id1.slice();
                    for(let i2 = 0; i2 < id1.length; i2++)id1[i2] |= 0;
                }
                if (!Array.isArray(id1)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id1));
                if (!relative1) {
                    if (id1[1] >= 40) return this.reporter.error('Second objid identifier OOB');
                    id1.splice(0, 2, 40 * id1[0] + id1[1]);
                }
                let size1 = 0;
                for(let i2 = 0; i2 < id1.length; i2++){
                    let ident1 = id1[i2];
                    for(size1++; ident1 >= 0x80; ident1 >>= 7)size1++;
                }
                const objid1 = Buffer1.alloc(size1);
                let offset1 = objid1.length - 1;
                for(let i2 = id1.length - 1; i2 >= 0; i2--){
                    let ident1 = id1[i2];
                    for(objid1[offset1--] = 0x7f & ident1; (ident1 >>= 7) > 0;)objid1[offset1--] = 0x80 | 0x7f & ident1;
                }
                return this._createEncoderBuffer(objid1);
            }, DERNode1.prototype._encodeTime = function(time1, tag1) {
                let str1;
                const date1 = new Date(time1);
                return 'gentime' === tag1 ? str1 = [
                    two1(date1.getUTCFullYear()),
                    two1(date1.getUTCMonth() + 1),
                    two1(date1.getUTCDate()),
                    two1(date1.getUTCHours()),
                    two1(date1.getUTCMinutes()),
                    two1(date1.getUTCSeconds()),
                    'Z'
                ].join('') : 'utctime' === tag1 ? str1 = [
                    two1(date1.getUTCFullYear() % 100),
                    two1(date1.getUTCMonth() + 1),
                    two1(date1.getUTCDate()),
                    two1(date1.getUTCHours()),
                    two1(date1.getUTCMinutes()),
                    two1(date1.getUTCSeconds()),
                    'Z'
                ].join('') : this.reporter.error('Encoding ' + tag1 + ' time is not supported yet'), this._encodeStr(str1, 'octstr');
            }, DERNode1.prototype._encodeNull = function() {
                return this._createEncoderBuffer('');
            }, DERNode1.prototype._encodeInt = function(num1, values1) {
                if ('string' == typeof num1) {
                    if (!values1) return this.reporter.error('String int or enum given, but no values map');
                    if (!values1.hasOwnProperty(num1)) return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num1));
                    num1 = values1[num1];
                }
                if ('number' != typeof num1 && !Buffer1.isBuffer(num1)) {
                    const numArray1 = num1.toArray();
                    !num1.sign && 0x80 & numArray1[0] && numArray1.unshift(0), num1 = Buffer1.from(numArray1);
                }
                if (Buffer1.isBuffer(num1)) {
                    let size1 = num1.length;
                    0 === num1.length && size1++;
                    const out1 = Buffer1.alloc(size1);
                    return num1.copy(out1), 0 === num1.length && (out1[0] = 0), this._createEncoderBuffer(out1);
                }
                if (num1 < 0x80) return this._createEncoderBuffer(num1);
                if (num1 < 0x100) return this._createEncoderBuffer([
                    0,
                    num1
                ]);
                let size1 = 1;
                for(let i2 = num1; i2 >= 0x100; i2 >>= 8)size1++;
                const out1 = Array(size1);
                for(let i2 = out1.length - 1; i2 >= 0; i2--)out1[i2] = 0xff & num1, num1 >>= 8;
                return 0x80 & out1[0] && out1.unshift(0), this._createEncoderBuffer(Buffer1.from(out1));
            }, DERNode1.prototype._encodeBool = function(value1) {
                return this._createEncoderBuffer(value1 ? 0xff : 0);
            }, DERNode1.prototype._use = function(entity1, obj1) {
                return 'function' == typeof entity1 && (entity1 = entity1(obj1)), entity1._getEncoder('der').tree;
            }, DERNode1.prototype._skipDefault = function(dataBuffer1, reporter1, parent1) {
                let i2;
                const state1 = this._baseState;
                if (null === state1.default) return !1;
                const data1 = dataBuffer1.join();
                if (void 0 === state1.defaultBuffer && (state1.defaultBuffer = this._encodeValue(state1.default, reporter1, parent1).join()), data1.length !== state1.defaultBuffer.length) return !1;
                for(i2 = 0; i2 < data1.length; i2++)if (data1[i2] !== state1.defaultBuffer[i2]) return !1;
                return !0;
            };
        },
        6579: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const encoders1 = exports1;
            encoders1.der = __webpack_require__1(6984), encoders1.pem = __webpack_require__1(2883);
        },
        2883: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            const inherits1 = __webpack_require__1(5717), DEREncoder1 = __webpack_require__1(6984);
            function PEMEncoder1(entity1) {
                DEREncoder1.call(this, entity1), this.enc = 'pem';
            }
            inherits1(PEMEncoder1, DEREncoder1), module1.exports = PEMEncoder1, PEMEncoder1.prototype.encode = function(data1, options1) {
                const buf1 = DEREncoder1.prototype.encode.call(this, data1), p3 = buf1.toString('base64'), out1 = [
                    '-----BEGIN ' + options1.label + '-----'
                ];
                for(let i2 = 0; i2 < p3.length; i2 += 64)out1.push(p3.slice(i2, i2 + 64));
                return out1.push('-----END ' + options1.label + '-----'), out1.join('\n');
            };
        },
        9669: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            module1.exports = __webpack_require__1(1609);
        },
        5448: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867), settle1 = __webpack_require__1(6026), cookies1 = __webpack_require__1(4372), buildURL1 = __webpack_require__1(5327), buildFullPath1 = __webpack_require__1(4097), parseHeaders1 = __webpack_require__1(4109), isURLSameOrigin1 = __webpack_require__1(7985), transitionalDefaults1 = __webpack_require__1(7874), AxiosError1 = __webpack_require__1(723), CanceledError1 = __webpack_require__1(644), parseProtocol1 = __webpack_require__1(205);
            module1.exports = function(config3) {
                return new Promise(function(resolve1, reject1) {
                    var onCanceled1, requestData1 = config3.data, requestHeaders1 = config3.headers, responseType1 = config3.responseType;
                    function done1() {
                        config3.cancelToken && config3.cancelToken.unsubscribe(onCanceled1), config3.signal && config3.signal.removeEventListener('abort', onCanceled1);
                    }
                    utils1.isFormData(requestData1) && utils1.isStandardBrowserEnv() && delete requestHeaders1['Content-Type'];
                    var request1 = new XMLHttpRequest();
                    if (config3.auth) {
                        var username1 = config3.auth.username || '', password1 = config3.auth.password ? unescape(encodeURIComponent(config3.auth.password)) : '';
                        requestHeaders1.Authorization = 'Basic ' + btoa(username1 + ':' + password1);
                    }
                    var fullPath1 = buildFullPath1(config3.baseURL, config3.url);
                    function onloadend1() {
                        if (request1) {
                            var responseHeaders1 = 'getAllResponseHeaders' in request1 ? parseHeaders1(request1.getAllResponseHeaders()) : null;
                            settle1(function(value1) {
                                resolve1(value1), done1();
                            }, function(err1) {
                                reject1(err1), done1();
                            }, {
                                data: responseType1 && 'text' !== responseType1 && 'json' !== responseType1 ? request1.response : request1.responseText,
                                status: request1.status,
                                statusText: request1.statusText,
                                headers: responseHeaders1,
                                config: config3,
                                request: request1
                            }), request1 = null;
                        }
                    }
                    if (request1.open(config3.method.toUpperCase(), buildURL1(fullPath1, config3.params, config3.paramsSerializer), !0), request1.timeout = config3.timeout, 'onloadend' in request1 ? request1.onloadend = onloadend1 : request1.onreadystatechange = function() {
                        request1 && 4 === request1.readyState && (0 !== request1.status || request1.responseURL && 0 === request1.responseURL.indexOf('file:')) && setTimeout(onloadend1);
                    }, request1.onabort = function() {
                        request1 && (reject1(new AxiosError1('Request aborted', AxiosError1.ECONNABORTED, config3, request1)), request1 = null);
                    }, request1.onerror = function() {
                        reject1(new AxiosError1('Network Error', AxiosError1.ERR_NETWORK, config3, request1, request1)), request1 = null;
                    }, request1.ontimeout = function() {
                        var timeoutErrorMessage1 = config3.timeout ? 'timeout of ' + config3.timeout + 'ms exceeded' : 'timeout exceeded', transitional1 = config3.transitional || transitionalDefaults1;
                        config3.timeoutErrorMessage && (timeoutErrorMessage1 = config3.timeoutErrorMessage), reject1(new AxiosError1(timeoutErrorMessage1, transitional1.clarifyTimeoutError ? AxiosError1.ETIMEDOUT : AxiosError1.ECONNABORTED, config3, request1)), request1 = null;
                    }, utils1.isStandardBrowserEnv()) {
                        var xsrfValue1 = (config3.withCredentials || isURLSameOrigin1(fullPath1)) && config3.xsrfCookieName ? cookies1.read(config3.xsrfCookieName) : void 0;
                        xsrfValue1 && (requestHeaders1[config3.xsrfHeaderName] = xsrfValue1);
                    }
                    'setRequestHeader' in request1 && utils1.forEach(requestHeaders1, function(val1, key1) {
                        void 0 === requestData1 && 'content-type' === key1.toLowerCase() ? delete requestHeaders1[key1] : request1.setRequestHeader(key1, val1);
                    }), utils1.isUndefined(config3.withCredentials) || (request1.withCredentials = !!config3.withCredentials), responseType1 && 'json' !== responseType1 && (request1.responseType = config3.responseType), 'function' == typeof config3.onDownloadProgress && request1.addEventListener('progress', config3.onDownloadProgress), 'function' == typeof config3.onUploadProgress && request1.upload && request1.upload.addEventListener('progress', config3.onUploadProgress), (config3.cancelToken || config3.signal) && (onCanceled1 = function(cancel1) {
                        request1 && (reject1(!cancel1 || cancel1 && cancel1.type ? new CanceledError1() : cancel1), request1.abort(), request1 = null);
                    }, config3.cancelToken && config3.cancelToken.subscribe(onCanceled1), config3.signal && (config3.signal.aborted ? onCanceled1() : config3.signal.addEventListener('abort', onCanceled1))), requestData1 || (requestData1 = null);
                    var protocol1 = parseProtocol1(fullPath1);
                    if (protocol1 && -1 === [
                        'http',
                        'https',
                        'file'
                    ].indexOf(protocol1)) {
                        reject1(new AxiosError1('Unsupported protocol ' + protocol1 + ':', AxiosError1.ERR_BAD_REQUEST, config3));
                        return;
                    }
                    request1.send(requestData1);
                });
            };
        },
        1609: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867), bind1 = __webpack_require__1(1849), Axios1 = __webpack_require__1(321), mergeConfig1 = __webpack_require__1(7185);
            function createInstance1(defaultConfig1) {
                var context1 = new Axios1(defaultConfig1), instance1 = bind1(Axios1.prototype.request, context1);
                return utils1.extend(instance1, Axios1.prototype, context1), utils1.extend(instance1, context1), instance1.create = function(instanceConfig1) {
                    return createInstance1(mergeConfig1(defaultConfig1, instanceConfig1));
                }, instance1;
            }
            var axios1 = createInstance1(__webpack_require__1(5546));
            axios1.Axios = Axios1, axios1.CanceledError = __webpack_require__1(644), axios1.CancelToken = __webpack_require__1(4972), axios1.isCancel = __webpack_require__1(6502), axios1.VERSION = __webpack_require__1(7288).version, axios1.toFormData = __webpack_require__1(7675), axios1.AxiosError = __webpack_require__1(723), axios1.Cancel = axios1.CanceledError, axios1.all = function(promises1) {
                return Promise.all(promises1);
            }, axios1.spread = __webpack_require__1(8713), axios1.isAxiosError = __webpack_require__1(6268), module1.exports = axios1, module1.exports.default = axios1;
        },
        4972: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var CanceledError1 = __webpack_require__1(644);
            function CancelToken1(executor1) {
                if ('function' != typeof executor1) throw TypeError('executor must be a function.');
                this.promise = new Promise(function(resolve1) {
                    resolvePromise1 = resolve1;
                });
                var resolvePromise1, token1 = this;
                this.promise.then(function(cancel1) {
                    if (token1._listeners) {
                        var i2, l1 = token1._listeners.length;
                        for(i2 = 0; i2 < l1; i2++)token1._listeners[i2](cancel1);
                        token1._listeners = null;
                    }
                }), this.promise.then = function(onfulfilled1) {
                    var _resolve1, promise1 = new Promise(function(resolve1) {
                        token1.subscribe(resolve1), _resolve1 = resolve1;
                    }).then(onfulfilled1);
                    return promise1.cancel = function() {
                        token1.unsubscribe(_resolve1);
                    }, promise1;
                }, executor1(function(message1) {
                    token1.reason || (token1.reason = new CanceledError1(message1), resolvePromise1(token1.reason));
                });
            }
            CancelToken1.prototype.throwIfRequested = function() {
                if (this.reason) throw this.reason;
            }, CancelToken1.prototype.subscribe = function(listener1) {
                if (this.reason) {
                    listener1(this.reason);
                    return;
                }
                this._listeners ? this._listeners.push(listener1) : this._listeners = [
                    listener1
                ];
            }, CancelToken1.prototype.unsubscribe = function(listener1) {
                if (this._listeners) {
                    var index1 = this._listeners.indexOf(listener1);
                    -1 !== index1 && this._listeners.splice(index1, 1);
                }
            }, CancelToken1.source = function() {
                var cancel1;
                return {
                    token: new CancelToken1(function(c5) {
                        cancel1 = c5;
                    }),
                    cancel: cancel1
                };
            }, module1.exports = CancelToken1;
        },
        644: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var AxiosError1 = __webpack_require__1(723);
            function CanceledError1(message1) {
                AxiosError1.call(this, null == message1 ? 'canceled' : message1, AxiosError1.ERR_CANCELED), this.name = 'CanceledError';
            }
            __webpack_require__1(4867).inherits(CanceledError1, AxiosError1, {
                __CANCEL__: !0
            }), module1.exports = CanceledError1;
        },
        6502: function(module1) {
            "use strict";
            module1.exports = function(value1) {
                return !!(value1 && value1.__CANCEL__);
            };
        },
        321: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867), buildURL1 = __webpack_require__1(5327), InterceptorManager1 = __webpack_require__1(782), dispatchRequest1 = __webpack_require__1(3572), mergeConfig1 = __webpack_require__1(7185), buildFullPath1 = __webpack_require__1(4097), validator1 = __webpack_require__1(4875), validators1 = validator1.validators;
            function Axios1(instanceConfig1) {
                this.defaults = instanceConfig1, this.interceptors = {
                    request: new InterceptorManager1(),
                    response: new InterceptorManager1()
                };
            }
            Axios1.prototype.request = function(configOrUrl1, config3) {
                'string' == typeof configOrUrl1 ? (config3 = config3 || {}).url = configOrUrl1 : config3 = configOrUrl1 || {}, (config3 = mergeConfig1(this.defaults, config3)).method ? config3.method = config3.method.toLowerCase() : this.defaults.method ? config3.method = this.defaults.method.toLowerCase() : config3.method = 'get';
                var promise1, transitional1 = config3.transitional;
                void 0 !== transitional1 && validator1.assertOptions(transitional1, {
                    silentJSONParsing: validators1.transitional(validators1.boolean),
                    forcedJSONParsing: validators1.transitional(validators1.boolean),
                    clarifyTimeoutError: validators1.transitional(validators1.boolean)
                }, !1);
                var requestInterceptorChain1 = [], synchronousRequestInterceptors1 = !0;
                this.interceptors.request.forEach(function(interceptor1) {
                    ('function' != typeof interceptor1.runWhen || !1 !== interceptor1.runWhen(config3)) && (synchronousRequestInterceptors1 = synchronousRequestInterceptors1 && interceptor1.synchronous, requestInterceptorChain1.unshift(interceptor1.fulfilled, interceptor1.rejected));
                });
                var responseInterceptorChain1 = [];
                if (this.interceptors.response.forEach(function(interceptor1) {
                    responseInterceptorChain1.push(interceptor1.fulfilled, interceptor1.rejected);
                }), !synchronousRequestInterceptors1) {
                    var chain1 = [
                        dispatchRequest1,
                        void 0
                    ];
                    for(Array.prototype.unshift.apply(chain1, requestInterceptorChain1), chain1 = chain1.concat(responseInterceptorChain1), promise1 = Promise.resolve(config3); chain1.length;)promise1 = promise1.then(chain1.shift(), chain1.shift());
                    return promise1;
                }
                for(var newConfig1 = config3; requestInterceptorChain1.length;){
                    var onFulfilled1 = requestInterceptorChain1.shift(), onRejected1 = requestInterceptorChain1.shift();
                    try {
                        newConfig1 = onFulfilled1(newConfig1);
                    } catch (error1) {
                        onRejected1(error1);
                        break;
                    }
                }
                try {
                    promise1 = dispatchRequest1(newConfig1);
                } catch (error1) {
                    return Promise.reject(error1);
                }
                for(; responseInterceptorChain1.length;)promise1 = promise1.then(responseInterceptorChain1.shift(), responseInterceptorChain1.shift());
                return promise1;
            }, Axios1.prototype.getUri = function(config3) {
                return buildURL1(buildFullPath1((config3 = mergeConfig1(this.defaults, config3)).baseURL, config3.url), config3.params, config3.paramsSerializer);
            }, utils1.forEach([
                'delete',
                'get',
                'head',
                'options'
            ], function(method1) {
                Axios1.prototype[method1] = function(url1, config3) {
                    return this.request(mergeConfig1(config3 || {}, {
                        method: method1,
                        url: url1,
                        data: (config3 || {}).data
                    }));
                };
            }), utils1.forEach([
                'post',
                'put',
                'patch'
            ], function(method1) {
                function generateHTTPMethod1(isForm1) {
                    return function(url1, data1, config3) {
                        return this.request(mergeConfig1(config3 || {}, {
                            method: method1,
                            headers: isForm1 ? {
                                'Content-Type': 'multipart/form-data'
                            } : {},
                            url: url1,
                            data: data1
                        }));
                    };
                }
                Axios1.prototype[method1] = generateHTTPMethod1(), Axios1.prototype[method1 + 'Form'] = generateHTTPMethod1(!0);
            }), module1.exports = Axios1;
        },
        723: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            function AxiosError1(message1, code1, config3, request1, response1) {
                Error.call(this), this.message = message1, this.name = 'AxiosError', code1 && (this.code = code1), config3 && (this.config = config3), request1 && (this.request = request1), response1 && (this.response = response1);
            }
            utils1.inherits(AxiosError1, Error, {
                toJSON: function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: this.config,
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    };
                }
            });
            var prototype1 = AxiosError1.prototype, descriptors1 = {};
            [
                'ERR_BAD_OPTION_VALUE',
                'ERR_BAD_OPTION',
                'ECONNABORTED',
                'ETIMEDOUT',
                'ERR_NETWORK',
                'ERR_FR_TOO_MANY_REDIRECTS',
                'ERR_DEPRECATED',
                'ERR_BAD_RESPONSE',
                'ERR_BAD_REQUEST',
                'ERR_CANCELED'
            ].forEach(function(code1) {
                descriptors1[code1] = {
                    value: code1
                };
            }), Object.defineProperties(AxiosError1, descriptors1), Object.defineProperty(prototype1, 'isAxiosError', {
                value: !0
            }), AxiosError1.from = function(error1, code1, config3, request1, response1, customProps1) {
                var axiosError1 = Object.create(prototype1);
                return utils1.toFlatObject(error1, axiosError1, function(obj1) {
                    return obj1 !== Error.prototype;
                }), AxiosError1.call(axiosError1, error1.message, code1, config3, request1, response1), axiosError1.name = error1.name, customProps1 && Object.assign(axiosError1, customProps1), axiosError1;
            }, module1.exports = AxiosError1;
        },
        782: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            function InterceptorManager1() {
                this.handlers = [];
            }
            InterceptorManager1.prototype.use = function(fulfilled1, rejected1, options1) {
                return this.handlers.push({
                    fulfilled: fulfilled1,
                    rejected: rejected1,
                    synchronous: !!options1 && options1.synchronous,
                    runWhen: options1 ? options1.runWhen : null
                }), this.handlers.length - 1;
            }, InterceptorManager1.prototype.eject = function(id1) {
                this.handlers[id1] && (this.handlers[id1] = null);
            }, InterceptorManager1.prototype.forEach = function(fn1) {
                utils1.forEach(this.handlers, function(h8) {
                    null !== h8 && fn1(h8);
                });
            }, module1.exports = InterceptorManager1;
        },
        4097: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var isAbsoluteURL1 = __webpack_require__1(1793), combineURLs1 = __webpack_require__1(7303);
            module1.exports = function(baseURL1, requestedURL1) {
                return baseURL1 && !isAbsoluteURL1(requestedURL1) ? combineURLs1(baseURL1, requestedURL1) : requestedURL1;
            };
        },
        3572: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867), transformData1 = __webpack_require__1(8527), isCancel1 = __webpack_require__1(6502), defaults1 = __webpack_require__1(5546), CanceledError1 = __webpack_require__1(644);
            function throwIfCancellationRequested1(config3) {
                if (config3.cancelToken && config3.cancelToken.throwIfRequested(), config3.signal && config3.signal.aborted) throw new CanceledError1();
            }
            module1.exports = function(config3) {
                return throwIfCancellationRequested1(config3), config3.headers = config3.headers || {}, config3.data = transformData1.call(config3, config3.data, config3.headers, config3.transformRequest), config3.headers = utils1.merge(config3.headers.common || {}, config3.headers[config3.method] || {}, config3.headers), utils1.forEach([
                    'delete',
                    'get',
                    'head',
                    'post',
                    'put',
                    'patch',
                    'common'
                ], function(method1) {
                    delete config3.headers[method1];
                }), (config3.adapter || defaults1.adapter)(config3).then(function(response1) {
                    return throwIfCancellationRequested1(config3), response1.data = transformData1.call(config3, response1.data, response1.headers, config3.transformResponse), response1;
                }, function(reason1) {
                    return !isCancel1(reason1) && (throwIfCancellationRequested1(config3), reason1 && reason1.response && (reason1.response.data = transformData1.call(config3, reason1.response.data, reason1.response.headers, config3.transformResponse))), Promise.reject(reason1);
                });
            };
        },
        7185: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            module1.exports = function(config11, config21) {
                config21 = config21 || {};
                var config3 = {};
                function getMergedValue1(target1, source1) {
                    return utils1.isPlainObject(target1) && utils1.isPlainObject(source1) ? utils1.merge(target1, source1) : utils1.isPlainObject(source1) ? utils1.merge({}, source1) : utils1.isArray(source1) ? source1.slice() : source1;
                }
                function mergeDeepProperties1(prop1) {
                    return utils1.isUndefined(config21[prop1]) ? utils1.isUndefined(config11[prop1]) ? void 0 : getMergedValue1(void 0, config11[prop1]) : getMergedValue1(config11[prop1], config21[prop1]);
                }
                function valueFromConfig21(prop1) {
                    if (!utils1.isUndefined(config21[prop1])) return getMergedValue1(void 0, config21[prop1]);
                }
                function defaultToConfig21(prop1) {
                    return utils1.isUndefined(config21[prop1]) ? utils1.isUndefined(config11[prop1]) ? void 0 : getMergedValue1(void 0, config11[prop1]) : getMergedValue1(void 0, config21[prop1]);
                }
                function mergeDirectKeys1(prop1) {
                    return prop1 in config21 ? getMergedValue1(config11[prop1], config21[prop1]) : prop1 in config11 ? getMergedValue1(void 0, config11[prop1]) : void 0;
                }
                var mergeMap1 = {
                    url: valueFromConfig21,
                    method: valueFromConfig21,
                    data: valueFromConfig21,
                    baseURL: defaultToConfig21,
                    transformRequest: defaultToConfig21,
                    transformResponse: defaultToConfig21,
                    paramsSerializer: defaultToConfig21,
                    timeout: defaultToConfig21,
                    timeoutMessage: defaultToConfig21,
                    withCredentials: defaultToConfig21,
                    adapter: defaultToConfig21,
                    responseType: defaultToConfig21,
                    xsrfCookieName: defaultToConfig21,
                    xsrfHeaderName: defaultToConfig21,
                    onUploadProgress: defaultToConfig21,
                    onDownloadProgress: defaultToConfig21,
                    decompress: defaultToConfig21,
                    maxContentLength: defaultToConfig21,
                    maxBodyLength: defaultToConfig21,
                    beforeRedirect: defaultToConfig21,
                    transport: defaultToConfig21,
                    httpAgent: defaultToConfig21,
                    httpsAgent: defaultToConfig21,
                    cancelToken: defaultToConfig21,
                    socketPath: defaultToConfig21,
                    responseEncoding: defaultToConfig21,
                    validateStatus: mergeDirectKeys1
                };
                return utils1.forEach(Object.keys(config11).concat(Object.keys(config21)), function(prop1) {
                    var merge1 = mergeMap1[prop1] || mergeDeepProperties1, configValue1 = merge1(prop1);
                    utils1.isUndefined(configValue1) && merge1 !== mergeDirectKeys1 || (config3[prop1] = configValue1);
                }), config3;
            };
        },
        6026: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var AxiosError1 = __webpack_require__1(723);
            module1.exports = function(resolve1, reject1, response1) {
                var validateStatus1 = response1.config.validateStatus;
                !response1.status || !validateStatus1 || validateStatus1(response1.status) ? resolve1(response1) : reject1(new AxiosError1('Request failed with status code ' + response1.status, [
                    AxiosError1.ERR_BAD_REQUEST,
                    AxiosError1.ERR_BAD_RESPONSE
                ][Math.floor(response1.status / 100) - 4], response1.config, response1.request, response1));
            };
        },
        8527: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867), defaults1 = __webpack_require__1(5546);
            module1.exports = function(data1, headers1, fns1) {
                var context1 = this || defaults1;
                return utils1.forEach(fns1, function(fn1) {
                    data1 = fn1.call(context1, data1, headers1);
                }), data1;
            };
        },
        5546: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var process1 = __webpack_require__1(3454), utils1 = __webpack_require__1(4867), normalizeHeaderName1 = __webpack_require__1(6016), AxiosError1 = __webpack_require__1(723), transitionalDefaults1 = __webpack_require__1(7874), toFormData1 = __webpack_require__1(7675), DEFAULT_CONTENT_TYPE1 = {
                'Content-Type': 'application/x-www-form-urlencoded'
            };
            function setContentTypeIfUnset1(headers1, value1) {
                !utils1.isUndefined(headers1) && utils1.isUndefined(headers1['Content-Type']) && (headers1['Content-Type'] = value1);
            }
            function stringifySafely1(rawValue1, parser1, encoder1) {
                if (utils1.isString(rawValue1)) try {
                    return (parser1 || JSON.parse)(rawValue1), utils1.trim(rawValue1);
                } catch (e1) {
                    if ('SyntaxError' !== e1.name) throw e1;
                }
                return (encoder1 || JSON.stringify)(rawValue1);
            }
            var defaults1 = {
                transitional: transitionalDefaults1,
                adapter: function() {
                    var adapter1;
                    return 'undefined' != typeof XMLHttpRequest ? adapter1 = __webpack_require__1(5448) : void 0 !== process1 && '[object process]' === Object.prototype.toString.call(process1) && (adapter1 = __webpack_require__1(5448)), adapter1;
                }(),
                transformRequest: [
                    function(data1, headers1) {
                        if (normalizeHeaderName1(headers1, 'Accept'), normalizeHeaderName1(headers1, 'Content-Type'), utils1.isFormData(data1) || utils1.isArrayBuffer(data1) || utils1.isBuffer(data1) || utils1.isStream(data1) || utils1.isFile(data1) || utils1.isBlob(data1)) return data1;
                        if (utils1.isArrayBufferView(data1)) return data1.buffer;
                        if (utils1.isURLSearchParams(data1)) return setContentTypeIfUnset1(headers1, 'application/x-www-form-urlencoded;charset=utf-8'), data1.toString();
                        var isFileList1, isObjectPayload1 = utils1.isObject(data1), contentType1 = headers1 && headers1['Content-Type'];
                        if ((isFileList1 = utils1.isFileList(data1)) || isObjectPayload1 && 'multipart/form-data' === contentType1) {
                            var _FormData1 = this.env && this.env.FormData;
                            return toFormData1(isFileList1 ? {
                                'files[]': data1
                            } : data1, _FormData1 && new _FormData1());
                        }
                        return isObjectPayload1 || 'application/json' === contentType1 ? (setContentTypeIfUnset1(headers1, 'application/json'), stringifySafely1(data1)) : data1;
                    }
                ],
                transformResponse: [
                    function(data1) {
                        var transitional1 = this.transitional || defaults1.transitional, silentJSONParsing1 = transitional1 && transitional1.silentJSONParsing, forcedJSONParsing1 = transitional1 && transitional1.forcedJSONParsing, strictJSONParsing1 = !silentJSONParsing1 && 'json' === this.responseType;
                        if (strictJSONParsing1 || forcedJSONParsing1 && utils1.isString(data1) && data1.length) try {
                            return JSON.parse(data1);
                        } catch (e1) {
                            if (strictJSONParsing1) {
                                if ('SyntaxError' === e1.name) throw AxiosError1.from(e1, AxiosError1.ERR_BAD_RESPONSE, this, null, this.response);
                                throw e1;
                            }
                        }
                        return data1;
                    }
                ],
                timeout: 0,
                xsrfCookieName: 'XSRF-TOKEN',
                xsrfHeaderName: 'X-XSRF-TOKEN',
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: __webpack_require__1(1623)
                },
                validateStatus: function(status1) {
                    return status1 >= 200 && status1 < 300;
                },
                headers: {
                    common: {
                        Accept: 'application/json, text/plain, */*'
                    }
                }
            };
            utils1.forEach([
                'delete',
                'get',
                'head'
            ], function(method1) {
                defaults1.headers[method1] = {};
            }), utils1.forEach([
                'post',
                'put',
                'patch'
            ], function(method1) {
                defaults1.headers[method1] = utils1.merge(DEFAULT_CONTENT_TYPE1);
            }), module1.exports = defaults1;
        },
        7874: function(module1) {
            "use strict";
            module1.exports = {
                silentJSONParsing: !0,
                forcedJSONParsing: !0,
                clarifyTimeoutError: !1
            };
        },
        7288: function(module1) {
            module1.exports = {
                version: "0.27.2"
            };
        },
        1849: function(module1) {
            "use strict";
            module1.exports = function(fn1, thisArg1) {
                return function() {
                    for(var args1 = Array(arguments.length), i2 = 0; i2 < args1.length; i2++)args1[i2] = arguments[i2];
                    return fn1.apply(thisArg1, args1);
                };
            };
        },
        5327: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            function encode1(val1) {
                return encodeURIComponent(val1).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
            }
            module1.exports = function(url1, params1, paramsSerializer1) {
                if (!params1) return url1;
                if (paramsSerializer1) serializedParams1 = paramsSerializer1(params1);
                else if (utils1.isURLSearchParams(params1)) serializedParams1 = params1.toString();
                else {
                    var serializedParams1, parts1 = [];
                    utils1.forEach(params1, function(val1, key1) {
                        null != val1 && (utils1.isArray(val1) ? key1 += '[]' : val1 = [
                            val1
                        ], utils1.forEach(val1, function(v3) {
                            utils1.isDate(v3) ? v3 = v3.toISOString() : utils1.isObject(v3) && (v3 = JSON.stringify(v3)), parts1.push(encode1(key1) + '=' + encode1(v3));
                        }));
                    }), serializedParams1 = parts1.join('&');
                }
                if (serializedParams1) {
                    var hashmarkIndex1 = url1.indexOf('#');
                    -1 !== hashmarkIndex1 && (url1 = url1.slice(0, hashmarkIndex1)), url1 += (-1 === url1.indexOf('?') ? '?' : '&') + serializedParams1;
                }
                return url1;
            };
        },
        7303: function(module1) {
            "use strict";
            module1.exports = function(baseURL1, relativeURL1) {
                return relativeURL1 ? baseURL1.replace(/\/+$/, '') + '/' + relativeURL1.replace(/^\/+/, '') : baseURL1;
            };
        },
        4372: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            module1.exports = utils1.isStandardBrowserEnv() ? function() {
                return {
                    write: function(name1, value1, expires1, path1, domain1, secure1) {
                        var cookie1 = [];
                        cookie1.push(name1 + '=' + encodeURIComponent(value1)), utils1.isNumber(expires1) && cookie1.push('expires=' + new Date(expires1).toGMTString()), utils1.isString(path1) && cookie1.push('path=' + path1), utils1.isString(domain1) && cookie1.push('domain=' + domain1), !0 === secure1 && cookie1.push('secure'), document.cookie = cookie1.join('; ');
                    },
                    read: function(name1) {
                        var match1 = document.cookie.match(RegExp('(^|;\\s*)(' + name1 + ')=([^;]*)'));
                        return match1 ? decodeURIComponent(match1[3]) : null;
                    },
                    remove: function(name1) {
                        this.write(name1, '', Date.now() - 86400000);
                    }
                };
            }() : function() {
                return {
                    write: function() {},
                    read: function() {
                        return null;
                    },
                    remove: function() {}
                };
            }();
        },
        1793: function(module1) {
            "use strict";
            module1.exports = function(url1) {
                return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url1);
            };
        },
        6268: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            module1.exports = function(payload1) {
                return utils1.isObject(payload1) && !0 === payload1.isAxiosError;
            };
        },
        7985: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            module1.exports = utils1.isStandardBrowserEnv() ? function() {
                var originURL1, msie1 = /(msie|trident)/i.test(navigator.userAgent), urlParsingNode1 = document.createElement('a');
                function resolveURL1(url1) {
                    var href1 = url1;
                    return msie1 && (urlParsingNode1.setAttribute('href', href1), href1 = urlParsingNode1.href), urlParsingNode1.setAttribute('href', href1), {
                        href: urlParsingNode1.href,
                        protocol: urlParsingNode1.protocol ? urlParsingNode1.protocol.replace(/:$/, '') : '',
                        host: urlParsingNode1.host,
                        search: urlParsingNode1.search ? urlParsingNode1.search.replace(/^\?/, '') : '',
                        hash: urlParsingNode1.hash ? urlParsingNode1.hash.replace(/^#/, '') : '',
                        hostname: urlParsingNode1.hostname,
                        port: urlParsingNode1.port,
                        pathname: '/' === urlParsingNode1.pathname.charAt(0) ? urlParsingNode1.pathname : '/' + urlParsingNode1.pathname
                    };
                }
                return originURL1 = resolveURL1(window.location.href), function(requestURL1) {
                    var parsed1 = utils1.isString(requestURL1) ? resolveURL1(requestURL1) : requestURL1;
                    return parsed1.protocol === originURL1.protocol && parsed1.host === originURL1.host;
                };
            }() : function() {
                return function() {
                    return !0;
                };
            }();
        },
        6016: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867);
            module1.exports = function(headers1, normalizedName1) {
                utils1.forEach(headers1, function(value1, name1) {
                    name1 !== normalizedName1 && name1.toUpperCase() === normalizedName1.toUpperCase() && (headers1[normalizedName1] = value1, delete headers1[name1]);
                });
            };
        },
        1623: function(module1) {
            module1.exports = null;
        },
        4109: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(4867), ignoreDuplicateOf1 = [
                'age',
                'authorization',
                'content-length',
                'content-type',
                'etag',
                'expires',
                'from',
                'host',
                'if-modified-since',
                'if-unmodified-since',
                'last-modified',
                'location',
                'max-forwards',
                'proxy-authorization',
                'referer',
                'retry-after',
                'user-agent'
            ];
            module1.exports = function(headers1) {
                var key1, val1, i2, parsed1 = {};
                return headers1 && utils1.forEach(headers1.split('\n'), function(line1) {
                    i2 = line1.indexOf(':'), key1 = utils1.trim(line1.substr(0, i2)).toLowerCase(), val1 = utils1.trim(line1.substr(i2 + 1)), key1 && !(parsed1[key1] && ignoreDuplicateOf1.indexOf(key1) >= 0) && ('set-cookie' === key1 ? parsed1[key1] = (parsed1[key1] ? parsed1[key1] : []).concat([
                        val1
                    ]) : parsed1[key1] = parsed1[key1] ? parsed1[key1] + ', ' + val1 : val1);
                }), parsed1;
            };
        },
        205: function(module1) {
            "use strict";
            module1.exports = function(url1) {
                var match1 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url1);
                return match1 && match1[1] || '';
            };
        },
        8713: function(module1) {
            "use strict";
            module1.exports = function(callback1) {
                return function(arr1) {
                    return callback1.apply(null, arr1);
                };
            };
        },
        7675: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(8764).Buffer, utils1 = __webpack_require__1(4867);
            function toFormData1(obj1, formData1) {
                formData1 = formData1 || new FormData();
                var stack1 = [];
                function convertValue1(value1) {
                    return null === value1 ? '' : utils1.isDate(value1) ? value1.toISOString() : utils1.isArrayBuffer(value1) || utils1.isTypedArray(value1) ? 'function' == typeof Blob ? new Blob([
                        value1
                    ]) : Buffer1.from(value1) : value1;
                }
                function build1(data1, parentKey1) {
                    if (utils1.isPlainObject(data1) || utils1.isArray(data1)) {
                        if (-1 !== stack1.indexOf(data1)) throw Error('Circular reference detected in ' + parentKey1);
                        stack1.push(data1), utils1.forEach(data1, function(value1, key1) {
                            if (!utils1.isUndefined(value1)) {
                                var arr1, fullKey1 = parentKey1 ? parentKey1 + '.' + key1 : key1;
                                if (value1 && !parentKey1 && 'object' == typeof value1) {
                                    if (utils1.endsWith(key1, '{}')) value1 = JSON.stringify(value1);
                                    else if (utils1.endsWith(key1, '[]') && (arr1 = utils1.toArray(value1))) {
                                        arr1.forEach(function(el1) {
                                            utils1.isUndefined(el1) || formData1.append(fullKey1, convertValue1(el1));
                                        });
                                        return;
                                    }
                                }
                                build1(value1, fullKey1);
                            }
                        }), stack1.pop();
                    } else formData1.append(parentKey1, convertValue1(data1));
                }
                return build1(obj1), formData1;
            }
            module1.exports = toFormData1;
        },
        4875: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var VERSION1 = __webpack_require__1(7288).version, AxiosError1 = __webpack_require__1(723), validators1 = {};
            [
                'object',
                'boolean',
                'number',
                'function',
                'string',
                'symbol'
            ].forEach(function(type1, i2) {
                validators1[type1] = function(thing1) {
                    return typeof thing1 === type1 || 'a' + (i2 < 1 ? 'n ' : ' ') + type1;
                };
            });
            var deprecatedWarnings1 = {};
            function assertOptions1(options1, schema1, allowUnknown1) {
                if ('object' != typeof options1) throw new AxiosError1('options must be an object', AxiosError1.ERR_BAD_OPTION_VALUE);
                for(var keys1 = Object.keys(options1), i2 = keys1.length; i2-- > 0;){
                    var opt1 = keys1[i2], validator1 = schema1[opt1];
                    if (validator1) {
                        var value1 = options1[opt1], result1 = void 0 === value1 || validator1(value1, opt1, options1);
                        if (!0 !== result1) throw new AxiosError1('option ' + opt1 + ' must be ' + result1, AxiosError1.ERR_BAD_OPTION_VALUE);
                        continue;
                    }
                    if (!0 !== allowUnknown1) throw new AxiosError1('Unknown option ' + opt1, AxiosError1.ERR_BAD_OPTION);
                }
            }
            validators1.transitional = function(validator1, version1, message1) {
                function formatMessage1(opt1, desc1) {
                    return '[Axios v' + VERSION1 + '] Transitional option \'' + opt1 + '\'' + desc1 + (message1 ? '. ' + message1 : '');
                }
                return function(value1, opt1, opts1) {
                    if (!1 === validator1) throw new AxiosError1(formatMessage1(opt1, ' has been removed' + (version1 ? ' in ' + version1 : '')), AxiosError1.ERR_DEPRECATED);
                    return version1 && !deprecatedWarnings1[opt1] && (deprecatedWarnings1[opt1] = !0, console.warn(formatMessage1(opt1, ' has been deprecated since v' + version1 + ' and will be removed in the near future'))), !validator1 || validator1(value1, opt1, opts1);
                };
            }, module1.exports = {
                assertOptions: assertOptions1,
                validators: validators1
            };
        },
        4867: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var bind1 = __webpack_require__1(1849), toString1 = Object.prototype.toString, kindOf1 = function(cache1) {
                return function(thing1) {
                    var str1 = toString1.call(thing1);
                    return cache1[str1] || (cache1[str1] = str1.slice(8, -1).toLowerCase());
                };
            }(Object.create(null));
            function kindOfTest1(type1) {
                return type1 = type1.toLowerCase(), function(thing1) {
                    return kindOf1(thing1) === type1;
                };
            }
            function isArray1(val1) {
                return Array.isArray(val1);
            }
            function isUndefined1(val1) {
                return void 0 === val1;
            }
            function isBuffer1(val1) {
                return null !== val1 && !isUndefined1(val1) && null !== val1.constructor && !isUndefined1(val1.constructor) && 'function' == typeof val1.constructor.isBuffer && val1.constructor.isBuffer(val1);
            }
            var isArrayBuffer1 = kindOfTest1('ArrayBuffer');
            function isArrayBufferView1(val1) {
                return 'undefined' != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(val1) : val1 && val1.buffer && isArrayBuffer1(val1.buffer);
            }
            function isString1(val1) {
                return 'string' == typeof val1;
            }
            function isNumber1(val1) {
                return 'number' == typeof val1;
            }
            function isObject1(val1) {
                return null !== val1 && 'object' == typeof val1;
            }
            function isPlainObject1(val1) {
                if ('object' !== kindOf1(val1)) return !1;
                var prototype1 = Object.getPrototypeOf(val1);
                return null === prototype1 || prototype1 === Object.prototype;
            }
            var isDate1 = kindOfTest1('Date'), isFile1 = kindOfTest1('File'), isBlob1 = kindOfTest1('Blob'), isFileList1 = kindOfTest1('FileList');
            function isFunction1(val1) {
                return '[object Function]' === toString1.call(val1);
            }
            function isStream1(val1) {
                return isObject1(val1) && isFunction1(val1.pipe);
            }
            function isFormData1(thing1) {
                var pattern1 = '[object FormData]';
                return thing1 && ('function' == typeof FormData && thing1 instanceof FormData || toString1.call(thing1) === pattern1 || isFunction1(thing1.toString) && thing1.toString() === pattern1);
            }
            var isURLSearchParams1 = kindOfTest1('URLSearchParams');
            function trim1(str1) {
                return str1.trim ? str1.trim() : str1.replace(/^\s+|\s+$/g, '');
            }
            function isStandardBrowserEnv1() {
                return ('undefined' == typeof navigator || 'ReactNative' !== navigator.product && 'NativeScript' !== navigator.product && 'NS' !== navigator.product) && 'undefined' != typeof window && 'undefined' != typeof document;
            }
            function forEach1(obj1, fn1) {
                if (null != obj1) {
                    if ('object' != typeof obj1 && (obj1 = [
                        obj1
                    ]), isArray1(obj1)) for(var i2 = 0, l1 = obj1.length; i2 < l1; i2++)fn1.call(null, obj1[i2], i2, obj1);
                    else for(var key1 in obj1)Object.prototype.hasOwnProperty.call(obj1, key1) && fn1.call(null, obj1[key1], key1, obj1);
                }
            }
            function merge1() {
                var result1 = {};
                function assignValue1(val1, key1) {
                    isPlainObject1(result1[key1]) && isPlainObject1(val1) ? result1[key1] = merge1(result1[key1], val1) : isPlainObject1(val1) ? result1[key1] = merge1({}, val1) : isArray1(val1) ? result1[key1] = val1.slice() : result1[key1] = val1;
                }
                for(var i2 = 0, l1 = arguments.length; i2 < l1; i2++)forEach1(arguments[i2], assignValue1);
                return result1;
            }
            function extend1(a10, b10, thisArg1) {
                return forEach1(b10, function(val1, key1) {
                    thisArg1 && 'function' == typeof val1 ? a10[key1] = bind1(val1, thisArg1) : a10[key1] = val1;
                }), a10;
            }
            function stripBOM1(content1) {
                return 0xFEFF === content1.charCodeAt(0) && (content1 = content1.slice(1)), content1;
            }
            function inherits1(constructor1, superConstructor1, props1, descriptors1) {
                constructor1.prototype = Object.create(superConstructor1.prototype, descriptors1), constructor1.prototype.constructor = constructor1, props1 && Object.assign(constructor1.prototype, props1);
            }
            function toFlatObject1(sourceObj1, destObj1, filter1) {
                var props1, i2, prop1, merged1 = {};
                destObj1 = destObj1 || {};
                do {
                    for(i2 = (props1 = Object.getOwnPropertyNames(sourceObj1)).length; i2-- > 0;)merged1[prop1 = props1[i2]] || (destObj1[prop1] = sourceObj1[prop1], merged1[prop1] = !0);
                    sourceObj1 = Object.getPrototypeOf(sourceObj1);
                }while (sourceObj1 && (!filter1 || filter1(sourceObj1, destObj1)) && sourceObj1 !== Object.prototype)
                return destObj1;
            }
            function endsWith1(str1, searchString1, position1) {
                str1 = String(str1), (void 0 === position1 || position1 > str1.length) && (position1 = str1.length), position1 -= searchString1.length;
                var lastIndex1 = str1.indexOf(searchString1, position1);
                return -1 !== lastIndex1 && lastIndex1 === position1;
            }
            function toArray1(thing1) {
                if (!thing1) return null;
                var i2 = thing1.length;
                if (isUndefined1(i2)) return null;
                for(var arr1 = Array(i2); i2-- > 0;)arr1[i2] = thing1[i2];
                return arr1;
            }
            var isTypedArray1 = function(TypedArray1) {
                return function(thing1) {
                    return TypedArray1 && thing1 instanceof TypedArray1;
                };
            }('undefined' != typeof Uint8Array && Object.getPrototypeOf(Uint8Array));
            module1.exports = {
                isArray: isArray1,
                isArrayBuffer: isArrayBuffer1,
                isBuffer: isBuffer1,
                isFormData: isFormData1,
                isArrayBufferView: isArrayBufferView1,
                isString: isString1,
                isNumber: isNumber1,
                isObject: isObject1,
                isPlainObject: isPlainObject1,
                isUndefined: isUndefined1,
                isDate: isDate1,
                isFile: isFile1,
                isBlob: isBlob1,
                isFunction: isFunction1,
                isStream: isStream1,
                isURLSearchParams: isURLSearchParams1,
                isStandardBrowserEnv: isStandardBrowserEnv1,
                forEach: forEach1,
                merge: merge1,
                extend: extend1,
                trim: trim1,
                stripBOM: stripBOM1,
                inherits: inherits1,
                toFlatObject: toFlatObject1,
                kindOf: kindOf1,
                kindOfTest: kindOfTest1,
                endsWith: endsWith1,
                toArray: toArray1,
                isTypedArray: isTypedArray1,
                isFileList: isFileList1
            };
        },
        9742: function(__unused_webpack_module1, exports1) {
            "use strict";
            exports1.byteLength = byteLength1, exports1.toByteArray = toByteArray1, exports1.fromByteArray = fromByteArray1;
            for(var lookup1 = [], revLookup1 = [], Arr1 = 'undefined' != typeof Uint8Array ? Uint8Array : Array, code1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', i2 = 0, len3 = code1.length; i2 < len3; ++i2)lookup1[i2] = code1[i2], revLookup1[code1.charCodeAt(i2)] = i2;
            function getLens1(b641) {
                var len3 = b641.length;
                if (len3 % 4 > 0) throw Error('Invalid string. Length must be a multiple of 4');
                var validLen1 = b641.indexOf('=');
                -1 === validLen1 && (validLen1 = len3);
                var placeHoldersLen1 = validLen1 === len3 ? 0 : 4 - validLen1 % 4;
                return [
                    validLen1,
                    placeHoldersLen1
                ];
            }
            function byteLength1(b641) {
                var lens1 = getLens1(b641), validLen1 = lens1[0], placeHoldersLen1 = lens1[1];
                return (validLen1 + placeHoldersLen1) * 3 / 4 - placeHoldersLen1;
            }
            function _byteLength1(b641, validLen1, placeHoldersLen1) {
                return (validLen1 + placeHoldersLen1) * 3 / 4 - placeHoldersLen1;
            }
            function toByteArray1(b641) {
                var tmp1, i2, lens1 = getLens1(b641), validLen1 = lens1[0], placeHoldersLen1 = lens1[1], arr1 = new Arr1(_byteLength1(b641, validLen1, placeHoldersLen1)), curByte1 = 0, len3 = placeHoldersLen1 > 0 ? validLen1 - 4 : validLen1;
                for(i2 = 0; i2 < len3; i2 += 4)tmp1 = revLookup1[b641.charCodeAt(i2)] << 18 | revLookup1[b641.charCodeAt(i2 + 1)] << 12 | revLookup1[b641.charCodeAt(i2 + 2)] << 6 | revLookup1[b641.charCodeAt(i2 + 3)], arr1[curByte1++] = tmp1 >> 16 & 0xFF, arr1[curByte1++] = tmp1 >> 8 & 0xFF, arr1[curByte1++] = 0xFF & tmp1;
                return 2 === placeHoldersLen1 && (tmp1 = revLookup1[b641.charCodeAt(i2)] << 2 | revLookup1[b641.charCodeAt(i2 + 1)] >> 4, arr1[curByte1++] = 0xFF & tmp1), 1 === placeHoldersLen1 && (tmp1 = revLookup1[b641.charCodeAt(i2)] << 10 | revLookup1[b641.charCodeAt(i2 + 1)] << 4 | revLookup1[b641.charCodeAt(i2 + 2)] >> 2, arr1[curByte1++] = tmp1 >> 8 & 0xFF, arr1[curByte1++] = 0xFF & tmp1), arr1;
            }
            function tripletToBase641(num1) {
                return lookup1[num1 >> 18 & 0x3F] + lookup1[num1 >> 12 & 0x3F] + lookup1[num1 >> 6 & 0x3F] + lookup1[0x3F & num1];
            }
            function encodeChunk1(uint81, start1, end1) {
                for(var output1 = [], i2 = start1; i2 < end1; i2 += 3)output1.push(tripletToBase641((uint81[i2] << 16 & 0xFF0000) + (uint81[i2 + 1] << 8 & 0xFF00) + (0xFF & uint81[i2 + 2])));
                return output1.join('');
            }
            function fromByteArray1(uint81) {
                for(var tmp1, len3 = uint81.length, extraBytes1 = len3 % 3, parts1 = [], maxChunkLength1 = 16383, i2 = 0, len21 = len3 - extraBytes1; i2 < len21; i2 += maxChunkLength1)parts1.push(encodeChunk1(uint81, i2, i2 + maxChunkLength1 > len21 ? len21 : i2 + maxChunkLength1));
                return 1 === extraBytes1 ? parts1.push(lookup1[(tmp1 = uint81[len3 - 1]) >> 2] + lookup1[tmp1 << 4 & 0x3F] + '==') : 2 === extraBytes1 && parts1.push(lookup1[(tmp1 = (uint81[len3 - 2] << 8) + uint81[len3 - 1]) >> 10] + lookup1[tmp1 >> 4 & 0x3F] + lookup1[tmp1 << 2 & 0x3F] + '='), parts1.join('');
            }
            revLookup1['-'.charCodeAt(0)] = 62, revLookup1['_'.charCodeAt(0)] = 63;
        },
        4431: function(module1, exports1, __webpack_require__1) {
            var __WEBPACK_AMD_DEFINE_RESULT__1;
            !function(globalObject1) {
                'use strict';
                var BigNumber1, isNumeric1 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil1 = Math.ceil, mathfloor1 = Math.floor, bignumberError1 = '[BigNumber Error] ', tooManyDigits1 = bignumberError1 + 'Number primitive has more than 15 significant digits: ', BASE1 = 1e14, LOG_BASE1 = 14, MAX_SAFE_INTEGER1 = 0x1fffffffffffff, POWS_TEN1 = [
                    1,
                    10,
                    100,
                    1e3,
                    1e4,
                    1e5,
                    1e6,
                    1e7,
                    1e8,
                    1e9,
                    1e10,
                    1e11,
                    1e12,
                    1e13
                ], SQRT_BASE1 = 1e7, MAX1 = 1E9;
                function clone1(configObject1) {
                    var div1, convertBase1, parseNumeric1, P1 = BigNumber1.prototype = {
                        constructor: BigNumber1,
                        toString: null,
                        valueOf: null
                    }, ONE1 = new BigNumber1(1), DECIMAL_PLACES1 = 20, ROUNDING_MODE1 = 4, TO_EXP_NEG1 = -7, TO_EXP_POS1 = 21, MIN_EXP1 = -10000000, MAX_EXP1 = 1e7, CRYPTO1 = !1, MODULO_MODE1 = 1, POW_PRECISION1 = 0, FORMAT1 = {
                        prefix: '',
                        groupSize: 3,
                        secondaryGroupSize: 0,
                        groupSeparator: ',',
                        decimalSeparator: '.',
                        fractionGroupSize: 0,
                        fractionGroupSeparator: '\xA0',
                        suffix: ''
                    }, ALPHABET1 = '0123456789abcdefghijklmnopqrstuvwxyz', alphabetHasNormalDecimalDigits1 = !0;
                    function BigNumber1(v3, b10) {
                        var alphabet1, c5, caseChanged1, e1, i2, isNum1, len3, str1, x3 = this;
                        if (!(x3 instanceof BigNumber1)) return new BigNumber1(v3, b10);
                        if (null == b10) {
                            if (v3 && !0 === v3._isBigNumber) {
                                x3.s = v3.s, !v3.c || v3.e > MAX_EXP1 ? x3.c = x3.e = null : v3.e < MIN_EXP1 ? x3.c = [
                                    x3.e = 0
                                ] : (x3.e = v3.e, x3.c = v3.c.slice());
                                return;
                            }
                            if ((isNum1 = 'number' == typeof v3) && 0 * v3 == 0) {
                                if (x3.s = 1 / v3 < 0 ? (v3 = -v3, -1) : 1, v3 === ~~v3) {
                                    for(e1 = 0, i2 = v3; i2 >= 10; i2 /= 10, e1++);
                                    e1 > MAX_EXP1 ? x3.c = x3.e = null : (x3.e = e1, x3.c = [
                                        v3
                                    ]);
                                    return;
                                }
                                str1 = String(v3);
                            } else {
                                if (!isNumeric1.test(str1 = String(v3))) return parseNumeric1(x3, str1, isNum1);
                                x3.s = 45 == str1.charCodeAt(0) ? (str1 = str1.slice(1), -1) : 1;
                            }
                            (e1 = str1.indexOf('.')) > -1 && (str1 = str1.replace('.', '')), (i2 = str1.search(/e/i)) > 0 ? (e1 < 0 && (e1 = i2), e1 += +str1.slice(i2 + 1), str1 = str1.substring(0, i2)) : e1 < 0 && (e1 = str1.length);
                        } else {
                            if (intCheck1(b10, 2, ALPHABET1.length, 'Base'), 10 == b10 && alphabetHasNormalDecimalDigits1) return round1(x3 = new BigNumber1(v3), DECIMAL_PLACES1 + x3.e + 1, ROUNDING_MODE1);
                            if (str1 = String(v3), isNum1 = 'number' == typeof v3) {
                                if (0 * v3 != 0) return parseNumeric1(x3, str1, isNum1, b10);
                                if (x3.s = 1 / v3 < 0 ? (str1 = str1.slice(1), -1) : 1, BigNumber1.DEBUG && str1.replace(/^0\.0*|\./, '').length > 15) throw Error(tooManyDigits1 + v3);
                            } else x3.s = 45 === str1.charCodeAt(0) ? (str1 = str1.slice(1), -1) : 1;
                            for(alphabet1 = ALPHABET1.slice(0, b10), e1 = i2 = 0, len3 = str1.length; i2 < len3; i2++)if (0 > alphabet1.indexOf(c5 = str1.charAt(i2))) {
                                if ('.' == c5) {
                                    if (i2 > e1) {
                                        e1 = len3;
                                        continue;
                                    }
                                } else if (!caseChanged1 && (str1 == str1.toUpperCase() && (str1 = str1.toLowerCase()) || str1 == str1.toLowerCase() && (str1 = str1.toUpperCase()))) {
                                    caseChanged1 = !0, i2 = -1, e1 = 0;
                                    continue;
                                }
                                return parseNumeric1(x3, String(v3), isNum1, b10);
                            }
                            isNum1 = !1, (e1 = (str1 = convertBase1(str1, b10, 10, x3.s)).indexOf('.')) > -1 ? str1 = str1.replace('.', '') : e1 = str1.length;
                        }
                        for(i2 = 0; 48 === str1.charCodeAt(i2); i2++);
                        for(len3 = str1.length; 48 === str1.charCodeAt(--len3););
                        if (str1 = str1.slice(i2, ++len3)) {
                            if (len3 -= i2, isNum1 && BigNumber1.DEBUG && len3 > 15 && (v3 > MAX_SAFE_INTEGER1 || v3 !== mathfloor1(v3))) throw Error(tooManyDigits1 + x3.s * v3);
                            if ((e1 = e1 - i2 - 1) > MAX_EXP1) x3.c = x3.e = null;
                            else if (e1 < MIN_EXP1) x3.c = [
                                x3.e = 0
                            ];
                            else {
                                if (x3.e = e1, x3.c = [], i2 = (e1 + 1) % LOG_BASE1, e1 < 0 && (i2 += LOG_BASE1), i2 < len3) {
                                    for(i2 && x3.c.push(+str1.slice(0, i2)), len3 -= LOG_BASE1; i2 < len3;)x3.c.push(+str1.slice(i2, i2 += LOG_BASE1));
                                    i2 = LOG_BASE1 - (str1 = str1.slice(i2)).length;
                                } else i2 -= len3;
                                for(; i2--; str1 += '0');
                                x3.c.push(+str1);
                            }
                        } else x3.c = [
                            x3.e = 0
                        ];
                    }
                    function format1(n2, i2, rm1, id1) {
                        var c01, e1, ne1, len3, str1;
                        if (null == rm1 ? rm1 = ROUNDING_MODE1 : intCheck1(rm1, 0, 8), !n2.c) return n2.toString();
                        if (c01 = n2.c[0], ne1 = n2.e, null == i2) str1 = coeffToString1(n2.c), str1 = 1 == id1 || 2 == id1 && (ne1 <= TO_EXP_NEG1 || ne1 >= TO_EXP_POS1) ? toExponential1(str1, ne1) : toFixedPoint1(str1, ne1, '0');
                        else if (e1 = (n2 = round1(new BigNumber1(n2), i2, rm1)).e, len3 = (str1 = coeffToString1(n2.c)).length, 1 == id1 || 2 == id1 && (i2 <= e1 || e1 <= TO_EXP_NEG1)) {
                            for(; len3 < i2; str1 += '0', len3++);
                            str1 = toExponential1(str1, e1);
                        } else if (i2 -= ne1, str1 = toFixedPoint1(str1, e1, '0'), e1 + 1 > len3) {
                            if (--i2 > 0) for(str1 += '.'; i2--; str1 += '0');
                        } else if ((i2 += e1 - len3) > 0) for(e1 + 1 == len3 && (str1 += '.'); i2--; str1 += '0');
                        return n2.s < 0 && c01 ? '-' + str1 : str1;
                    }
                    function maxOrMin1(args1, method1) {
                        for(var n2, i2 = 1, m1 = new BigNumber1(args1[0]); i2 < args1.length; i2++)if ((n2 = new BigNumber1(args1[i2])).s) method1.call(m1, n2) && (m1 = n2);
                        else {
                            m1 = n2;
                            break;
                        }
                        return m1;
                    }
                    function normalise1(n2, c5, e1) {
                        for(var i2 = 1, j1 = c5.length; !c5[--j1]; c5.pop());
                        for(j1 = c5[0]; j1 >= 10; j1 /= 10, i2++);
                        return (e1 = i2 + e1 * LOG_BASE1 - 1) > MAX_EXP1 ? n2.c = n2.e = null : e1 < MIN_EXP1 ? n2.c = [
                            n2.e = 0
                        ] : (n2.e = e1, n2.c = c5), n2;
                    }
                    function round1(x3, sd1, rm1, r3) {
                        var d3, i2, j1, k3, n2, ni1, rd1, xc1 = x3.c, pows101 = POWS_TEN1;
                        if (xc1) {
                            out: {
                                for(d3 = 1, k3 = xc1[0]; k3 >= 10; k3 /= 10, d3++);
                                if ((i2 = sd1 - d3) < 0) i2 += LOG_BASE1, j1 = sd1, rd1 = (n2 = xc1[ni1 = 0]) / pows101[d3 - j1 - 1] % 10 | 0;
                                else if ((ni1 = mathceil1((i2 + 1) / LOG_BASE1)) >= xc1.length) {
                                    if (r3) {
                                        for(; xc1.length <= ni1; xc1.push(0));
                                        n2 = rd1 = 0, d3 = 1, i2 %= LOG_BASE1, j1 = i2 - LOG_BASE1 + 1;
                                    } else break out;
                                } else {
                                    for(d3 = 1, n2 = k3 = xc1[ni1]; k3 >= 10; k3 /= 10, d3++);
                                    i2 %= LOG_BASE1, rd1 = (j1 = i2 - LOG_BASE1 + d3) < 0 ? 0 : n2 / pows101[d3 - j1 - 1] % 10 | 0;
                                }
                                if (r3 = r3 || sd1 < 0 || null != xc1[ni1 + 1] || (j1 < 0 ? n2 : n2 % pows101[d3 - j1 - 1]), r3 = rm1 < 4 ? (rd1 || r3) && (0 == rm1 || rm1 == (x3.s < 0 ? 3 : 2)) : rd1 > 5 || 5 == rd1 && (4 == rm1 || r3 || 6 == rm1 && (i2 > 0 ? j1 > 0 ? n2 / pows101[d3 - j1] : 0 : xc1[ni1 - 1]) % 10 & 1 || rm1 == (x3.s < 0 ? 8 : 7)), sd1 < 1 || !xc1[0]) return xc1.length = 0, r3 ? (sd1 -= x3.e + 1, xc1[0] = pows101[(LOG_BASE1 - sd1 % LOG_BASE1) % LOG_BASE1], x3.e = -sd1 || 0) : xc1[0] = x3.e = 0, x3;
                                if (0 == i2 ? (xc1.length = ni1, k3 = 1, ni1--) : (xc1.length = ni1 + 1, k3 = pows101[LOG_BASE1 - i2], xc1[ni1] = j1 > 0 ? mathfloor1(n2 / pows101[d3 - j1] % pows101[j1]) * k3 : 0), r3) for(;;){
                                    if (0 == ni1) {
                                        for(i2 = 1, j1 = xc1[0]; j1 >= 10; j1 /= 10, i2++);
                                        for(j1 = xc1[0] += k3, k3 = 1; j1 >= 10; j1 /= 10, k3++);
                                        i2 != k3 && (x3.e++, xc1[0] == BASE1 && (xc1[0] = 1));
                                        break;
                                    }
                                    if (xc1[ni1] += k3, xc1[ni1] != BASE1) break;
                                    xc1[ni1--] = 0, k3 = 1;
                                }
                                for(i2 = xc1.length; 0 === xc1[--i2]; xc1.pop());
                            }
                            x3.e > MAX_EXP1 ? x3.c = x3.e = null : x3.e < MIN_EXP1 && (x3.c = [
                                x3.e = 0
                            ]);
                        }
                        return x3;
                    }
                    function valueOf1(n2) {
                        var str1, e1 = n2.e;
                        return null === e1 ? n2.toString() : (str1 = coeffToString1(n2.c), str1 = e1 <= TO_EXP_NEG1 || e1 >= TO_EXP_POS1 ? toExponential1(str1, e1) : toFixedPoint1(str1, e1, '0'), n2.s < 0 ? '-' + str1 : str1);
                    }
                    return BigNumber1.clone = clone1, BigNumber1.ROUND_UP = 0, BigNumber1.ROUND_DOWN = 1, BigNumber1.ROUND_CEIL = 2, BigNumber1.ROUND_FLOOR = 3, BigNumber1.ROUND_HALF_UP = 4, BigNumber1.ROUND_HALF_DOWN = 5, BigNumber1.ROUND_HALF_EVEN = 6, BigNumber1.ROUND_HALF_CEIL = 7, BigNumber1.ROUND_HALF_FLOOR = 8, BigNumber1.EUCLID = 9, BigNumber1.config = BigNumber1.set = function(obj1) {
                        var p3, v3;
                        if (null != obj1) {
                            if ('object' == typeof obj1) {
                                if (obj1.hasOwnProperty(p3 = 'DECIMAL_PLACES') && (intCheck1(v3 = obj1[p3], 0, MAX1, p3), DECIMAL_PLACES1 = v3), obj1.hasOwnProperty(p3 = 'ROUNDING_MODE') && (intCheck1(v3 = obj1[p3], 0, 8, p3), ROUNDING_MODE1 = v3), obj1.hasOwnProperty(p3 = 'EXPONENTIAL_AT') && ((v3 = obj1[p3]) && v3.pop ? (intCheck1(v3[0], -MAX1, 0, p3), intCheck1(v3[1], 0, MAX1, p3), TO_EXP_NEG1 = v3[0], TO_EXP_POS1 = v3[1]) : (intCheck1(v3, -MAX1, MAX1, p3), TO_EXP_NEG1 = -(TO_EXP_POS1 = v3 < 0 ? -v3 : v3))), obj1.hasOwnProperty(p3 = 'RANGE')) {
                                    if ((v3 = obj1[p3]) && v3.pop) intCheck1(v3[0], -MAX1, -1, p3), intCheck1(v3[1], 1, MAX1, p3), MIN_EXP1 = v3[0], MAX_EXP1 = v3[1];
                                    else if (intCheck1(v3, -MAX1, MAX1, p3), v3) MIN_EXP1 = -(MAX_EXP1 = v3 < 0 ? -v3 : v3);
                                    else throw Error(bignumberError1 + p3 + ' cannot be zero: ' + v3);
                                }
                                if (obj1.hasOwnProperty(p3 = 'CRYPTO')) {
                                    if (!!(v3 = obj1[p3]) === v3) {
                                        if (v3) {
                                            if ('undefined' != typeof crypto && crypto && (crypto.getRandomValues || crypto.randomBytes)) CRYPTO1 = v3;
                                            else throw CRYPTO1 = !v3, Error(bignumberError1 + 'crypto unavailable');
                                        } else CRYPTO1 = v3;
                                    } else throw Error(bignumberError1 + p3 + ' not true or false: ' + v3);
                                }
                                if (obj1.hasOwnProperty(p3 = 'MODULO_MODE') && (intCheck1(v3 = obj1[p3], 0, 9, p3), MODULO_MODE1 = v3), obj1.hasOwnProperty(p3 = 'POW_PRECISION') && (intCheck1(v3 = obj1[p3], 0, MAX1, p3), POW_PRECISION1 = v3), obj1.hasOwnProperty(p3 = 'FORMAT')) {
                                    if ('object' == typeof (v3 = obj1[p3])) FORMAT1 = v3;
                                    else throw Error(bignumberError1 + p3 + ' not an object: ' + v3);
                                }
                                if (obj1.hasOwnProperty(p3 = 'ALPHABET')) {
                                    if ('string' != typeof (v3 = obj1[p3]) || /^.?$|[+\-.\s]|(.).*\1/.test(v3)) throw Error(bignumberError1 + p3 + ' invalid: ' + v3);
                                    alphabetHasNormalDecimalDigits1 = '0123456789' == v3.slice(0, 10), ALPHABET1 = v3;
                                }
                            } else throw Error(bignumberError1 + 'Object expected: ' + obj1);
                        }
                        return {
                            DECIMAL_PLACES: DECIMAL_PLACES1,
                            ROUNDING_MODE: ROUNDING_MODE1,
                            EXPONENTIAL_AT: [
                                TO_EXP_NEG1,
                                TO_EXP_POS1
                            ],
                            RANGE: [
                                MIN_EXP1,
                                MAX_EXP1
                            ],
                            CRYPTO: CRYPTO1,
                            MODULO_MODE: MODULO_MODE1,
                            POW_PRECISION: POW_PRECISION1,
                            FORMAT: FORMAT1,
                            ALPHABET: ALPHABET1
                        };
                    }, BigNumber1.isBigNumber = function(v3) {
                        if (!v3 || !0 !== v3._isBigNumber) return !1;
                        if (!BigNumber1.DEBUG) return !0;
                        var i2, n2, c5 = v3.c, e1 = v3.e, s3 = v3.s;
                        out: if ('[object Array]' == ({}).toString.call(c5)) {
                            if ((1 === s3 || -1 === s3) && e1 >= -MAX1 && e1 <= MAX1 && e1 === mathfloor1(e1)) {
                                if (0 === c5[0]) {
                                    if (0 === e1 && 1 === c5.length) return !0;
                                    break out;
                                }
                                if ((i2 = (e1 + 1) % LOG_BASE1) < 1 && (i2 += LOG_BASE1), String(c5[0]).length == i2) {
                                    for(i2 = 0; i2 < c5.length; i2++)if ((n2 = c5[i2]) < 0 || n2 >= BASE1 || n2 !== mathfloor1(n2)) break out;
                                    if (0 !== n2) return !0;
                                }
                            }
                        } else if (null === c5 && null === e1 && (null === s3 || 1 === s3 || -1 === s3)) return !0;
                        throw Error(bignumberError1 + 'Invalid BigNumber: ' + v3);
                    }, BigNumber1.maximum = BigNumber1.max = function() {
                        return maxOrMin1(arguments, P1.lt);
                    }, BigNumber1.minimum = BigNumber1.min = function() {
                        return maxOrMin1(arguments, P1.gt);
                    }, BigNumber1.random = function() {
                        var pow2_531 = 0x20000000000000, random53bitInt1 = 0x20000000000000 * Math.random() & 0x1fffff ? function() {
                            return mathfloor1(Math.random() * pow2_531);
                        } : function() {
                            return (0x40000000 * Math.random() | 0) * 0x800000 + (0x800000 * Math.random() | 0);
                        };
                        return function(dp1) {
                            var a10, b10, e1, k3, v3, i2 = 0, c5 = [], rand1 = new BigNumber1(ONE1);
                            if (null == dp1 ? dp1 = DECIMAL_PLACES1 : intCheck1(dp1, 0, MAX1), k3 = mathceil1(dp1 / LOG_BASE1), CRYPTO1) {
                                if (crypto.getRandomValues) {
                                    for(a10 = crypto.getRandomValues(new Uint32Array(k3 *= 2)); i2 < k3;)(v3 = 0x20000 * a10[i2] + (a10[i2 + 1] >>> 11)) >= 9e15 ? (b10 = crypto.getRandomValues(new Uint32Array(2)), a10[i2] = b10[0], a10[i2 + 1] = b10[1]) : (c5.push(v3 % 1e14), i2 += 2);
                                    i2 = k3 / 2;
                                } else if (crypto.randomBytes) {
                                    for(a10 = crypto.randomBytes(k3 *= 7); i2 < k3;)(v3 = (31 & a10[i2]) * 0x1000000000000 + 0x10000000000 * a10[i2 + 1] + 0x100000000 * a10[i2 + 2] + 0x1000000 * a10[i2 + 3] + (a10[i2 + 4] << 16) + (a10[i2 + 5] << 8) + a10[i2 + 6]) >= 9e15 ? crypto.randomBytes(7).copy(a10, i2) : (c5.push(v3 % 1e14), i2 += 7);
                                    i2 = k3 / 7;
                                } else throw CRYPTO1 = !1, Error(bignumberError1 + 'crypto unavailable');
                            }
                            if (!CRYPTO1) for(; i2 < k3;)(v3 = random53bitInt1()) < 9e15 && (c5[i2++] = v3 % 1e14);
                            for(k3 = c5[--i2], dp1 %= LOG_BASE1, k3 && dp1 && (v3 = POWS_TEN1[LOG_BASE1 - dp1], c5[i2] = mathfloor1(k3 / v3) * v3); 0 === c5[i2]; c5.pop(), i2--);
                            if (i2 < 0) c5 = [
                                e1 = 0
                            ];
                            else {
                                for(e1 = -1; 0 === c5[0]; c5.splice(0, 1), e1 -= LOG_BASE1);
                                for(i2 = 1, v3 = c5[0]; v3 >= 10; v3 /= 10, i2++);
                                i2 < LOG_BASE1 && (e1 -= LOG_BASE1 - i2);
                            }
                            return rand1.e = e1, rand1.c = c5, rand1;
                        };
                    }(), BigNumber1.sum = function() {
                        for(var i2 = 1, args1 = arguments, sum1 = new BigNumber1(args1[0]); i2 < args1.length;)sum1 = sum1.plus(args1[i2++]);
                        return sum1;
                    }, convertBase1 = function() {
                        var decimal1 = '0123456789';
                        function toBaseOut1(str1, baseIn1, baseOut1, alphabet1) {
                            for(var j1, arrL1, arr1 = [
                                0
                            ], i2 = 0, len3 = str1.length; i2 < len3;){
                                for(arrL1 = arr1.length; arrL1--; arr1[arrL1] *= baseIn1);
                                for(arr1[0] += alphabet1.indexOf(str1.charAt(i2++)), j1 = 0; j1 < arr1.length; j1++)arr1[j1] > baseOut1 - 1 && (null == arr1[j1 + 1] && (arr1[j1 + 1] = 0), arr1[j1 + 1] += arr1[j1] / baseOut1 | 0, arr1[j1] %= baseOut1);
                            }
                            return arr1.reverse();
                        }
                        return function(str1, baseIn1, baseOut1, sign1, callerIsToString1) {
                            var alphabet1, d3, e1, k3, r3, x3, xc1, y3, i2 = str1.indexOf('.'), dp1 = DECIMAL_PLACES1, rm1 = ROUNDING_MODE1;
                            for(i2 >= 0 && (k3 = POW_PRECISION1, POW_PRECISION1 = 0, str1 = str1.replace('.', ''), x3 = (y3 = new BigNumber1(baseIn1)).pow(str1.length - i2), POW_PRECISION1 = k3, y3.c = toBaseOut1(toFixedPoint1(coeffToString1(x3.c), x3.e, '0'), 10, baseOut1, decimal1), y3.e = y3.c.length), e1 = k3 = (xc1 = toBaseOut1(str1, baseIn1, baseOut1, callerIsToString1 ? (alphabet1 = ALPHABET1, decimal1) : (alphabet1 = decimal1, ALPHABET1))).length; 0 == xc1[--k3]; xc1.pop());
                            if (!xc1[0]) return alphabet1.charAt(0);
                            if (i2 < 0 ? --e1 : (x3.c = xc1, x3.e = e1, x3.s = sign1, xc1 = (x3 = div1(x3, y3, dp1, rm1, baseOut1)).c, r3 = x3.r, e1 = x3.e), i2 = xc1[d3 = e1 + dp1 + 1], k3 = baseOut1 / 2, r3 = r3 || d3 < 0 || null != xc1[d3 + 1], r3 = rm1 < 4 ? (null != i2 || r3) && (0 == rm1 || rm1 == (x3.s < 0 ? 3 : 2)) : i2 > k3 || i2 == k3 && (4 == rm1 || r3 || 6 == rm1 && 1 & xc1[d3 - 1] || rm1 == (x3.s < 0 ? 8 : 7)), d3 < 1 || !xc1[0]) str1 = r3 ? toFixedPoint1(alphabet1.charAt(1), -dp1, alphabet1.charAt(0)) : alphabet1.charAt(0);
                            else {
                                if (xc1.length = d3, r3) for(--baseOut1; ++xc1[--d3] > baseOut1;)xc1[d3] = 0, d3 || (++e1, xc1 = [
                                    1
                                ].concat(xc1));
                                for(k3 = xc1.length; !xc1[--k3];);
                                for(i2 = 0, str1 = ''; i2 <= k3; str1 += alphabet1.charAt(xc1[i2++]));
                                str1 = toFixedPoint1(str1, e1, alphabet1.charAt(0));
                            }
                            return str1;
                        };
                    }(), div1 = function() {
                        function multiply1(x3, k3, base1) {
                            var m1, temp1, xlo1, xhi1, carry1 = 0, i2 = x3.length, klo1 = k3 % SQRT_BASE1, khi1 = k3 / SQRT_BASE1 | 0;
                            for(x3 = x3.slice(); i2--;)m1 = khi1 * (xlo1 = x3[i2] % SQRT_BASE1) + (xhi1 = x3[i2] / SQRT_BASE1 | 0) * klo1, carry1 = ((temp1 = klo1 * xlo1 + m1 % SQRT_BASE1 * SQRT_BASE1 + carry1) / base1 | 0) + (m1 / SQRT_BASE1 | 0) + khi1 * xhi1, x3[i2] = temp1 % base1;
                            return carry1 && (x3 = [
                                carry1
                            ].concat(x3)), x3;
                        }
                        function compare1(a10, b10, aL1, bL1) {
                            var i2, cmp1;
                            if (aL1 != bL1) cmp1 = aL1 > bL1 ? 1 : -1;
                            else for(i2 = cmp1 = 0; i2 < aL1; i2++)if (a10[i2] != b10[i2]) {
                                cmp1 = a10[i2] > b10[i2] ? 1 : -1;
                                break;
                            }
                            return cmp1;
                        }
                        function subtract1(a10, b10, aL1, base1) {
                            for(var i2 = 0; aL1--;)a10[aL1] -= i2, i2 = a10[aL1] < b10[aL1] ? 1 : 0, a10[aL1] = i2 * base1 + a10[aL1] - b10[aL1];
                            for(; !a10[0] && a10.length > 1; a10.splice(0, 1));
                        }
                        return function(x3, y3, dp1, rm1, base1) {
                            var cmp1, e1, i2, more1, n2, prod1, prodL1, q3, qc1, rem1, remL1, rem01, xi1, xL1, yc01, yL1, yz1, s3 = x3.s == y3.s ? 1 : -1, xc1 = x3.c, yc1 = y3.c;
                            if (!xc1 || !xc1[0] || !yc1 || !yc1[0]) return new BigNumber1(x3.s && y3.s && (xc1 ? !yc1 || xc1[0] != yc1[0] : yc1) ? xc1 && 0 == xc1[0] || !yc1 ? 0 * s3 : s3 / 0 : NaN);
                            for(qc1 = (q3 = new BigNumber1(s3)).c = [], s3 = dp1 + (e1 = x3.e - y3.e) + 1, base1 || (base1 = BASE1, e1 = bitFloor1(x3.e / LOG_BASE1) - bitFloor1(y3.e / LOG_BASE1), s3 = s3 / LOG_BASE1 | 0), i2 = 0; yc1[i2] == (xc1[i2] || 0); i2++);
                            if (yc1[i2] > (xc1[i2] || 0) && e1--, s3 < 0) qc1.push(1), more1 = !0;
                            else {
                                for(xL1 = xc1.length, yL1 = yc1.length, i2 = 0, s3 += 2, (n2 = mathfloor1(base1 / (yc1[0] + 1))) > 1 && (yc1 = multiply1(yc1, n2, base1), xc1 = multiply1(xc1, n2, base1), yL1 = yc1.length, xL1 = xc1.length), xi1 = yL1, remL1 = (rem1 = xc1.slice(0, yL1)).length; remL1 < yL1; rem1[remL1++] = 0);
                                yz1 = [
                                    0
                                ].concat(yz1 = yc1.slice()), yc01 = yc1[0], yc1[1] >= base1 / 2 && yc01++;
                                do {
                                    if (n2 = 0, (cmp1 = compare1(yc1, rem1, yL1, remL1)) < 0) {
                                        if (rem01 = rem1[0], yL1 != remL1 && (rem01 = rem01 * base1 + (rem1[1] || 0)), (n2 = mathfloor1(rem01 / yc01)) > 1) for(n2 >= base1 && (n2 = base1 - 1), prodL1 = (prod1 = multiply1(yc1, n2, base1)).length, remL1 = rem1.length; 1 == compare1(prod1, rem1, prodL1, remL1);)n2--, subtract1(prod1, yL1 < prodL1 ? yz1 : yc1, prodL1, base1), prodL1 = prod1.length, cmp1 = 1;
                                        else 0 == n2 && (cmp1 = n2 = 1), prodL1 = (prod1 = yc1.slice()).length;
                                        if (prodL1 < remL1 && (prod1 = [
                                            0
                                        ].concat(prod1)), subtract1(rem1, prod1, remL1, base1), remL1 = rem1.length, -1 == cmp1) for(; 1 > compare1(yc1, rem1, yL1, remL1);)n2++, subtract1(rem1, yL1 < remL1 ? yz1 : yc1, remL1, base1), remL1 = rem1.length;
                                    } else 0 === cmp1 && (n2++, rem1 = [
                                        0
                                    ]);
                                    qc1[i2++] = n2, rem1[0] ? rem1[remL1++] = xc1[xi1] || 0 : (rem1 = [
                                        xc1[xi1]
                                    ], remL1 = 1);
                                }while ((xi1++ < xL1 || null != rem1[0]) && s3--)
                                more1 = null != rem1[0], qc1[0] || qc1.splice(0, 1);
                            }
                            if (base1 == BASE1) {
                                for(i2 = 1, s3 = qc1[0]; s3 >= 10; s3 /= 10, i2++);
                                round1(q3, dp1 + (q3.e = i2 + e1 * LOG_BASE1 - 1) + 1, rm1, more1);
                            } else q3.e = e1, q3.r = +more1;
                            return q3;
                        };
                    }(), parseNumeric1 = function() {
                        var basePrefix1 = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter1 = /^([^.]+)\.$/, dotBefore1 = /^\.([^.]+)$/, isInfinityOrNaN1 = /^-?(Infinity|NaN)$/, whitespaceOrPlus1 = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
                        return function(x3, str1, isNum1, b10) {
                            var base1, s3 = isNum1 ? str1 : str1.replace(whitespaceOrPlus1, '');
                            if (isInfinityOrNaN1.test(s3)) x3.s = isNaN(s3) ? null : s3 < 0 ? -1 : 1;
                            else {
                                if (!isNum1 && (s3 = s3.replace(basePrefix1, function(m1, p11, p21) {
                                    return base1 = 'x' == (p21 = p21.toLowerCase()) ? 16 : 'b' == p21 ? 2 : 8, b10 && b10 != base1 ? m1 : p11;
                                }), b10 && (base1 = b10, s3 = s3.replace(dotAfter1, '$1').replace(dotBefore1, '0.$1')), str1 != s3)) return new BigNumber1(s3, base1);
                                if (BigNumber1.DEBUG) throw Error(bignumberError1 + 'Not a' + (b10 ? ' base ' + b10 : '') + ' number: ' + str1);
                                x3.s = null;
                            }
                            x3.c = x3.e = null;
                        };
                    }(), P1.absoluteValue = P1.abs = function() {
                        var x3 = new BigNumber1(this);
                        return x3.s < 0 && (x3.s = 1), x3;
                    }, P1.comparedTo = function(y3, b10) {
                        return compare1(this, new BigNumber1(y3, b10));
                    }, P1.decimalPlaces = P1.dp = function(dp1, rm1) {
                        var c5, n2, v3, x3 = this;
                        if (null != dp1) return intCheck1(dp1, 0, MAX1), null == rm1 ? rm1 = ROUNDING_MODE1 : intCheck1(rm1, 0, 8), round1(new BigNumber1(x3), dp1 + x3.e + 1, rm1);
                        if (!(c5 = x3.c)) return null;
                        if (n2 = ((v3 = c5.length - 1) - bitFloor1(this.e / LOG_BASE1)) * LOG_BASE1, v3 = c5[v3]) for(; v3 % 10 == 0; v3 /= 10, n2--);
                        return n2 < 0 && (n2 = 0), n2;
                    }, P1.dividedBy = P1.div = function(y3, b10) {
                        return div1(this, new BigNumber1(y3, b10), DECIMAL_PLACES1, ROUNDING_MODE1);
                    }, P1.dividedToIntegerBy = P1.idiv = function(y3, b10) {
                        return div1(this, new BigNumber1(y3, b10), 0, 1);
                    }, P1.exponentiatedBy = P1.pow = function(n2, m1) {
                        var half1, isModExp1, i2, k3, more1, nIsBig1, nIsNeg1, nIsOdd1, y3, x3 = this;
                        if ((n2 = new BigNumber1(n2)).c && !n2.isInteger()) throw Error(bignumberError1 + 'Exponent not an integer: ' + valueOf1(n2));
                        if (null != m1 && (m1 = new BigNumber1(m1)), nIsBig1 = n2.e > 14, !x3.c || !x3.c[0] || 1 == x3.c[0] && !x3.e && 1 == x3.c.length || !n2.c || !n2.c[0]) return y3 = new BigNumber1(Math.pow(+valueOf1(x3), nIsBig1 ? 2 - isOdd1(n2) : +valueOf1(n2))), m1 ? y3.mod(m1) : y3;
                        if (nIsNeg1 = n2.s < 0, m1) {
                            if (m1.c ? !m1.c[0] : !m1.s) return new BigNumber1(NaN);
                            (isModExp1 = !nIsNeg1 && x3.isInteger() && m1.isInteger()) && (x3 = x3.mod(m1));
                        } else {
                            if (n2.e > 9 && (x3.e > 0 || x3.e < -1 || (0 == x3.e ? x3.c[0] > 1 || nIsBig1 && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig1 && x3.c[0] <= 9999975e7))) return k3 = x3.s < 0 && isOdd1(n2) ? -0 : 0, x3.e > -1 && (k3 = 1 / k3), new BigNumber1(nIsNeg1 ? 1 / k3 : k3);
                            POW_PRECISION1 && (k3 = mathceil1(POW_PRECISION1 / LOG_BASE1 + 2));
                        }
                        for(nIsBig1 ? (half1 = new BigNumber1(0.5), nIsNeg1 && (n2.s = 1), nIsOdd1 = isOdd1(n2)) : nIsOdd1 = (i2 = Math.abs(+valueOf1(n2))) % 2, y3 = new BigNumber1(ONE1);;){
                            if (nIsOdd1) {
                                if (!(y3 = y3.times(x3)).c) break;
                                k3 ? y3.c.length > k3 && (y3.c.length = k3) : isModExp1 && (y3 = y3.mod(m1));
                            }
                            if (i2) {
                                if (0 === (i2 = mathfloor1(i2 / 2))) break;
                                nIsOdd1 = i2 % 2;
                            } else if (round1(n2 = n2.times(half1), n2.e + 1, 1), n2.e > 14) nIsOdd1 = isOdd1(n2);
                            else {
                                if (0 == (i2 = +valueOf1(n2))) break;
                                nIsOdd1 = i2 % 2;
                            }
                            x3 = x3.times(x3), k3 ? x3.c && x3.c.length > k3 && (x3.c.length = k3) : isModExp1 && (x3 = x3.mod(m1));
                        }
                        return isModExp1 ? y3 : (nIsNeg1 && (y3 = ONE1.div(y3)), m1 ? y3.mod(m1) : k3 ? round1(y3, POW_PRECISION1, ROUNDING_MODE1, more1) : y3);
                    }, P1.integerValue = function(rm1) {
                        var n2 = new BigNumber1(this);
                        return null == rm1 ? rm1 = ROUNDING_MODE1 : intCheck1(rm1, 0, 8), round1(n2, n2.e + 1, rm1);
                    }, P1.isEqualTo = P1.eq = function(y3, b10) {
                        return 0 === compare1(this, new BigNumber1(y3, b10));
                    }, P1.isFinite = function() {
                        return !!this.c;
                    }, P1.isGreaterThan = P1.gt = function(y3, b10) {
                        return compare1(this, new BigNumber1(y3, b10)) > 0;
                    }, P1.isGreaterThanOrEqualTo = P1.gte = function(y3, b10) {
                        return 1 === (b10 = compare1(this, new BigNumber1(y3, b10))) || 0 === b10;
                    }, P1.isInteger = function() {
                        return !!this.c && bitFloor1(this.e / LOG_BASE1) > this.c.length - 2;
                    }, P1.isLessThan = P1.lt = function(y3, b10) {
                        return 0 > compare1(this, new BigNumber1(y3, b10));
                    }, P1.isLessThanOrEqualTo = P1.lte = function(y3, b10) {
                        return -1 === (b10 = compare1(this, new BigNumber1(y3, b10))) || 0 === b10;
                    }, P1.isNaN = function() {
                        return !this.s;
                    }, P1.isNegative = function() {
                        return this.s < 0;
                    }, P1.isPositive = function() {
                        return this.s > 0;
                    }, P1.isZero = function() {
                        return !!this.c && 0 == this.c[0];
                    }, P1.minus = function(y3, b10) {
                        var i2, j1, t3, xLTy1, x3 = this, a10 = x3.s;
                        if (b10 = (y3 = new BigNumber1(y3, b10)).s, !a10 || !b10) return new BigNumber1(NaN);
                        if (a10 != b10) return y3.s = -b10, x3.plus(y3);
                        var xe1 = x3.e / LOG_BASE1, ye1 = y3.e / LOG_BASE1, xc1 = x3.c, yc1 = y3.c;
                        if (!xe1 || !ye1) {
                            if (!xc1 || !yc1) return xc1 ? (y3.s = -b10, y3) : new BigNumber1(yc1 ? x3 : NaN);
                            if (!xc1[0] || !yc1[0]) return yc1[0] ? (y3.s = -b10, y3) : new BigNumber1(xc1[0] ? x3 : 3 == ROUNDING_MODE1 ? -0 : 0);
                        }
                        if (xe1 = bitFloor1(xe1), ye1 = bitFloor1(ye1), xc1 = xc1.slice(), a10 = xe1 - ye1) {
                            for((xLTy1 = a10 < 0) ? (a10 = -a10, t3 = xc1) : (ye1 = xe1, t3 = yc1), t3.reverse(), b10 = a10; b10--; t3.push(0));
                            t3.reverse();
                        } else for(j1 = (xLTy1 = (a10 = xc1.length) < (b10 = yc1.length)) ? a10 : b10, a10 = b10 = 0; b10 < j1; b10++)if (xc1[b10] != yc1[b10]) {
                            xLTy1 = xc1[b10] < yc1[b10];
                            break;
                        }
                        if (xLTy1 && (t3 = xc1, xc1 = yc1, yc1 = t3, y3.s = -y3.s), (b10 = (j1 = yc1.length) - (i2 = xc1.length)) > 0) for(; b10--; xc1[i2++] = 0);
                        for(b10 = BASE1 - 1; j1 > a10;){
                            if (xc1[--j1] < yc1[j1]) {
                                for(i2 = j1; i2 && !xc1[--i2]; xc1[i2] = b10);
                                --xc1[i2], xc1[j1] += BASE1;
                            }
                            xc1[j1] -= yc1[j1];
                        }
                        for(; 0 == xc1[0]; xc1.splice(0, 1), --ye1);
                        return xc1[0] ? normalise1(y3, xc1, ye1) : (y3.s = 3 == ROUNDING_MODE1 ? -1 : 1, y3.c = [
                            y3.e = 0
                        ], y3);
                    }, P1.modulo = P1.mod = function(y3, b10) {
                        var q3, s3, x3 = this;
                        return (y3 = new BigNumber1(y3, b10), x3.c && y3.s && (!y3.c || y3.c[0])) ? y3.c && (!x3.c || x3.c[0]) ? (9 == MODULO_MODE1 ? (s3 = y3.s, y3.s = 1, q3 = div1(x3, y3, 0, 3), y3.s = s3, q3.s *= s3) : q3 = div1(x3, y3, 0, MODULO_MODE1), (y3 = x3.minus(q3.times(y3))).c[0] || 1 != MODULO_MODE1 || (y3.s = x3.s), y3) : new BigNumber1(x3) : new BigNumber1(NaN);
                    }, P1.multipliedBy = P1.times = function(y3, b10) {
                        var c5, e1, i2, j1, k3, m1, xcL1, xlo1, xhi1, ycL1, ylo1, yhi1, zc1, base1, sqrtBase1, x3 = this, xc1 = x3.c, yc1 = (y3 = new BigNumber1(y3, b10)).c;
                        if (!xc1 || !yc1 || !xc1[0] || !yc1[0]) return x3.s && y3.s && (!xc1 || xc1[0] || yc1) && (!yc1 || yc1[0] || xc1) ? (y3.s *= x3.s, xc1 && yc1 ? (y3.c = [
                            0
                        ], y3.e = 0) : y3.c = y3.e = null) : y3.c = y3.e = y3.s = null, y3;
                        for(e1 = bitFloor1(x3.e / LOG_BASE1) + bitFloor1(y3.e / LOG_BASE1), y3.s *= x3.s, (xcL1 = xc1.length) < (ycL1 = yc1.length) && (zc1 = xc1, xc1 = yc1, yc1 = zc1, i2 = xcL1, xcL1 = ycL1, ycL1 = i2), i2 = xcL1 + ycL1, zc1 = []; i2--; zc1.push(0));
                        for(base1 = BASE1, sqrtBase1 = SQRT_BASE1, i2 = ycL1; --i2 >= 0;){
                            for(c5 = 0, ylo1 = yc1[i2] % sqrtBase1, yhi1 = yc1[i2] / sqrtBase1 | 0, k3 = xcL1, j1 = i2 + k3; j1 > i2;)m1 = yhi1 * (xlo1 = xc1[--k3] % sqrtBase1) + (xhi1 = xc1[k3] / sqrtBase1 | 0) * ylo1, c5 = ((xlo1 = ylo1 * xlo1 + m1 % sqrtBase1 * sqrtBase1 + zc1[j1] + c5) / base1 | 0) + (m1 / sqrtBase1 | 0) + yhi1 * xhi1, zc1[j1--] = xlo1 % base1;
                            zc1[j1] = c5;
                        }
                        return c5 ? ++e1 : zc1.splice(0, 1), normalise1(y3, zc1, e1);
                    }, P1.negated = function() {
                        var x3 = new BigNumber1(this);
                        return x3.s = -x3.s || null, x3;
                    }, P1.plus = function(y3, b10) {
                        var t3, x3 = this, a10 = x3.s;
                        if (b10 = (y3 = new BigNumber1(y3, b10)).s, !a10 || !b10) return new BigNumber1(NaN);
                        if (a10 != b10) return y3.s = -b10, x3.minus(y3);
                        var xe1 = x3.e / LOG_BASE1, ye1 = y3.e / LOG_BASE1, xc1 = x3.c, yc1 = y3.c;
                        if (!xe1 || !ye1) {
                            if (!xc1 || !yc1) return new BigNumber1(a10 / 0);
                            if (!xc1[0] || !yc1[0]) return yc1[0] ? y3 : new BigNumber1(xc1[0] ? x3 : 0 * a10);
                        }
                        if (xe1 = bitFloor1(xe1), ye1 = bitFloor1(ye1), xc1 = xc1.slice(), a10 = xe1 - ye1) {
                            for(a10 > 0 ? (ye1 = xe1, t3 = yc1) : (a10 = -a10, t3 = xc1), t3.reverse(); a10--; t3.push(0));
                            t3.reverse();
                        }
                        for((a10 = xc1.length) - (b10 = yc1.length) < 0 && (t3 = yc1, yc1 = xc1, xc1 = t3, b10 = a10), a10 = 0; b10;)a10 = (xc1[--b10] = xc1[b10] + yc1[b10] + a10) / BASE1 | 0, xc1[b10] = BASE1 === xc1[b10] ? 0 : xc1[b10] % BASE1;
                        return a10 && (xc1 = [
                            a10
                        ].concat(xc1), ++ye1), normalise1(y3, xc1, ye1);
                    }, P1.precision = P1.sd = function(sd1, rm1) {
                        var c5, n2, v3, x3 = this;
                        if (null != sd1 && !!sd1 !== sd1) return intCheck1(sd1, 1, MAX1), null == rm1 ? rm1 = ROUNDING_MODE1 : intCheck1(rm1, 0, 8), round1(new BigNumber1(x3), sd1, rm1);
                        if (!(c5 = x3.c)) return null;
                        if (n2 = (v3 = c5.length - 1) * LOG_BASE1 + 1, v3 = c5[v3]) {
                            for(; v3 % 10 == 0; v3 /= 10, n2--);
                            for(v3 = c5[0]; v3 >= 10; v3 /= 10, n2++);
                        }
                        return sd1 && x3.e + 1 > n2 && (n2 = x3.e + 1), n2;
                    }, P1.shiftedBy = function(k3) {
                        return intCheck1(k3, -MAX_SAFE_INTEGER1, MAX_SAFE_INTEGER1), this.times('1e' + k3);
                    }, P1.squareRoot = P1.sqrt = function() {
                        var m1, n2, r3, rep1, t3, x3 = this, c5 = x3.c, s3 = x3.s, e1 = x3.e, dp1 = DECIMAL_PLACES1 + 4, half1 = new BigNumber1('0.5');
                        if (1 !== s3 || !c5 || !c5[0]) return new BigNumber1(!s3 || s3 < 0 && (!c5 || c5[0]) ? NaN : c5 ? x3 : 1 / 0);
                        if (0 == (s3 = Math.sqrt(+valueOf1(x3))) || s3 == 1 / 0 ? (((n2 = coeffToString1(c5)).length + e1) % 2 == 0 && (n2 += '0'), s3 = Math.sqrt(+n2), e1 = bitFloor1((e1 + 1) / 2) - (e1 < 0 || e1 % 2), n2 = s3 == 1 / 0 ? '5e' + e1 : (n2 = s3.toExponential()).slice(0, n2.indexOf('e') + 1) + e1, r3 = new BigNumber1(n2)) : r3 = new BigNumber1(s3 + ''), r3.c[0]) {
                            for((s3 = (e1 = r3.e) + dp1) < 3 && (s3 = 0);;)if (t3 = r3, r3 = half1.times(t3.plus(div1(x3, t3, dp1, 1))), coeffToString1(t3.c).slice(0, s3) === (n2 = coeffToString1(r3.c)).slice(0, s3)) {
                                if (r3.e < e1 && --s3, '9999' != (n2 = n2.slice(s3 - 3, s3 + 1)) && (rep1 || '4999' != n2)) {
                                    +n2 && (+n2.slice(1) || '5' != n2.charAt(0)) || (round1(r3, r3.e + DECIMAL_PLACES1 + 2, 1), m1 = !r3.times(r3).eq(x3));
                                    break;
                                }
                                if (!rep1 && (round1(t3, t3.e + DECIMAL_PLACES1 + 2, 0), t3.times(t3).eq(x3))) {
                                    r3 = t3;
                                    break;
                                }
                                dp1 += 4, s3 += 4, rep1 = 1;
                            }
                        }
                        return round1(r3, r3.e + DECIMAL_PLACES1 + 1, ROUNDING_MODE1, m1);
                    }, P1.toExponential = function(dp1, rm1) {
                        return null != dp1 && (intCheck1(dp1, 0, MAX1), dp1++), format1(this, dp1, rm1, 1);
                    }, P1.toFixed = function(dp1, rm1) {
                        return null != dp1 && (intCheck1(dp1, 0, MAX1), dp1 = dp1 + this.e + 1), format1(this, dp1, rm1);
                    }, P1.toFormat = function(dp1, rm1, format1) {
                        var str1, x3 = this;
                        if (null == format1) null != dp1 && rm1 && 'object' == typeof rm1 ? (format1 = rm1, rm1 = null) : dp1 && 'object' == typeof dp1 ? (format1 = dp1, dp1 = rm1 = null) : format1 = FORMAT1;
                        else if ('object' != typeof format1) throw Error(bignumberError1 + 'Argument not an object: ' + format1);
                        if (str1 = x3.toFixed(dp1, rm1), x3.c) {
                            var i2, arr1 = str1.split('.'), g11 = +format1.groupSize, g21 = +format1.secondaryGroupSize, groupSeparator1 = format1.groupSeparator || '', intPart1 = arr1[0], fractionPart1 = arr1[1], isNeg1 = x3.s < 0, intDigits1 = isNeg1 ? intPart1.slice(1) : intPart1, len3 = intDigits1.length;
                            if (g21 && (i2 = g11, g11 = g21, g21 = i2, len3 -= i2), g11 > 0 && len3 > 0) {
                                for(i2 = len3 % g11 || g11, intPart1 = intDigits1.substr(0, i2); i2 < len3; i2 += g11)intPart1 += groupSeparator1 + intDigits1.substr(i2, g11);
                                g21 > 0 && (intPart1 += groupSeparator1 + intDigits1.slice(i2)), isNeg1 && (intPart1 = '-' + intPart1);
                            }
                            str1 = fractionPart1 ? intPart1 + (format1.decimalSeparator || '') + ((g21 = +format1.fractionGroupSize) ? fractionPart1.replace(RegExp('\\d{' + g21 + '}\\B', 'g'), '$&' + (format1.fractionGroupSeparator || '')) : fractionPart1) : intPart1;
                        }
                        return (format1.prefix || '') + str1 + (format1.suffix || '');
                    }, P1.toFraction = function(md1) {
                        var d3, d01, d11, d21, e1, exp1, n2, n01, n11, q3, r3, s3, x3 = this, xc1 = x3.c;
                        if (null != md1 && (!(n2 = new BigNumber1(md1)).isInteger() && (n2.c || 1 !== n2.s) || n2.lt(ONE1))) throw Error(bignumberError1 + 'Argument ' + (n2.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf1(n2));
                        if (!xc1) return new BigNumber1(x3);
                        for(d3 = new BigNumber1(ONE1), n11 = d01 = new BigNumber1(ONE1), d11 = n01 = new BigNumber1(ONE1), s3 = coeffToString1(xc1), e1 = d3.e = s3.length - x3.e - 1, d3.c[0] = POWS_TEN1[(exp1 = e1 % LOG_BASE1) < 0 ? LOG_BASE1 + exp1 : exp1], md1 = !md1 || n2.comparedTo(d3) > 0 ? e1 > 0 ? d3 : n11 : n2, exp1 = MAX_EXP1, MAX_EXP1 = 1 / 0, n2 = new BigNumber1(s3), n01.c[0] = 0; q3 = div1(n2, d3, 0, 1), 1 != (d21 = d01.plus(q3.times(d11))).comparedTo(md1);)d01 = d11, d11 = d21, n11 = n01.plus(q3.times(d21 = n11)), n01 = d21, d3 = n2.minus(q3.times(d21 = d3)), n2 = d21;
                        return d21 = div1(md1.minus(d01), d11, 0, 1), n01 = n01.plus(d21.times(n11)), d01 = d01.plus(d21.times(d11)), n01.s = n11.s = x3.s, e1 *= 2, r3 = 1 > div1(n11, d11, e1, ROUNDING_MODE1).minus(x3).abs().comparedTo(div1(n01, d01, e1, ROUNDING_MODE1).minus(x3).abs()) ? [
                            n11,
                            d11
                        ] : [
                            n01,
                            d01
                        ], MAX_EXP1 = exp1, r3;
                    }, P1.toNumber = function() {
                        return +valueOf1(this);
                    }, P1.toPrecision = function(sd1, rm1) {
                        return null != sd1 && intCheck1(sd1, 1, MAX1), format1(this, sd1, rm1, 2);
                    }, P1.toString = function(b10) {
                        var str1, n2 = this, s3 = n2.s, e1 = n2.e;
                        return null === e1 ? s3 ? (str1 = 'Infinity', s3 < 0 && (str1 = '-' + str1)) : str1 = 'NaN' : (null == b10 ? str1 = e1 <= TO_EXP_NEG1 || e1 >= TO_EXP_POS1 ? toExponential1(coeffToString1(n2.c), e1) : toFixedPoint1(coeffToString1(n2.c), e1, '0') : 10 === b10 && alphabetHasNormalDecimalDigits1 ? str1 = toFixedPoint1(coeffToString1((n2 = round1(new BigNumber1(n2), DECIMAL_PLACES1 + e1 + 1, ROUNDING_MODE1)).c), n2.e, '0') : (intCheck1(b10, 2, ALPHABET1.length, 'Base'), str1 = convertBase1(toFixedPoint1(coeffToString1(n2.c), e1, '0'), 10, b10, s3, !0)), s3 < 0 && n2.c[0] && (str1 = '-' + str1)), str1;
                    }, P1.valueOf = P1.toJSON = function() {
                        return valueOf1(this);
                    }, P1._isBigNumber = !0, null != configObject1 && BigNumber1.set(configObject1), BigNumber1;
                }
                function bitFloor1(n2) {
                    var i2 = 0 | n2;
                    return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
                }
                function coeffToString1(a10) {
                    for(var s3, z1, i2 = 1, j1 = a10.length, r3 = a10[0] + ''; i2 < j1;){
                        for(z1 = LOG_BASE1 - (s3 = a10[i2++] + '').length; z1--; s3 = '0' + s3);
                        r3 += s3;
                    }
                    for(j1 = r3.length; 48 === r3.charCodeAt(--j1););
                    return r3.slice(0, j1 + 1 || 1);
                }
                function compare1(x3, y3) {
                    var a10, b10, xc1 = x3.c, yc1 = y3.c, i2 = x3.s, j1 = y3.s, k3 = x3.e, l1 = y3.e;
                    if (!i2 || !j1) return null;
                    if (a10 = xc1 && !xc1[0], b10 = yc1 && !yc1[0], a10 || b10) return a10 ? b10 ? 0 : -j1 : i2;
                    if (i2 != j1) return i2;
                    if (a10 = i2 < 0, b10 = k3 == l1, !xc1 || !yc1) return b10 ? 0 : !xc1 ^ a10 ? 1 : -1;
                    if (!b10) return k3 > l1 ^ a10 ? 1 : -1;
                    for(i2 = 0, j1 = (k3 = xc1.length) < (l1 = yc1.length) ? k3 : l1; i2 < j1; i2++)if (xc1[i2] != yc1[i2]) return xc1[i2] > yc1[i2] ^ a10 ? 1 : -1;
                    return k3 == l1 ? 0 : k3 > l1 ^ a10 ? 1 : -1;
                }
                function intCheck1(n2, min1, max1, name1) {
                    if (n2 < min1 || n2 > max1 || n2 !== mathfloor1(n2)) throw Error(bignumberError1 + (name1 || 'Argument') + ('number' == typeof n2 ? n2 < min1 || n2 > max1 ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n2));
                }
                function isOdd1(n2) {
                    var k3 = n2.c.length - 1;
                    return bitFloor1(n2.e / LOG_BASE1) == k3 && n2.c[k3] % 2 != 0;
                }
                function toExponential1(str1, e1) {
                    return (str1.length > 1 ? str1.charAt(0) + '.' + str1.slice(1) : str1) + (e1 < 0 ? 'e' : 'e+') + e1;
                }
                function toFixedPoint1(str1, e1, z1) {
                    var len3, zs1;
                    if (e1 < 0) {
                        for(zs1 = z1 + '.'; ++e1; zs1 += z1);
                        str1 = zs1 + str1;
                    } else if (len3 = str1.length, ++e1 > len3) {
                        for(zs1 = z1, e1 -= len3; --e1; zs1 += z1);
                        str1 += zs1;
                    } else e1 < len3 && (str1 = str1.slice(0, e1) + '.' + str1.slice(e1));
                    return str1;
                }
                (BigNumber1 = clone1()).default = BigNumber1.BigNumber = BigNumber1, void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__1 = (function() {
                    return BigNumber1;
                }).call(exports1, __webpack_require__1, exports1, module1)) && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__1);
            }(0);
        },
        3550: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            !function(module1, exports1) {
                'use strict';
                function assert1(val1, msg1) {
                    if (!val1) throw Error(msg1 || 'Assertion failed');
                }
                function inherits1(ctor1, superCtor1) {
                    ctor1.super_ = superCtor1;
                    var TempCtor1 = function() {};
                    TempCtor1.prototype = superCtor1.prototype, ctor1.prototype = new TempCtor1(), ctor1.prototype.constructor = ctor1;
                }
                function BN1(number1, base1, endian1) {
                    if (BN1.isBN(number1)) return number1;
                    this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== number1 && (('le' === base1 || 'be' === base1) && (endian1 = base1, base1 = 10), this._init(number1 || 0, base1 || 10, endian1 || 'be'));
                }
                'object' == typeof module1 ? module1.exports = BN1 : exports1.BN = BN1, BN1.BN = BN1, BN1.wordSize = 26;
                try {
                    Buffer1 = 'undefined' != typeof window && void 0 !== window.Buffer ? window.Buffer : __webpack_require__1(6601).Buffer;
                } catch (e1) {}
                function parseHex4Bits1(string1, index1) {
                    var c5 = string1.charCodeAt(index1);
                    return c5 >= 65 && c5 <= 70 ? c5 - 55 : c5 >= 97 && c5 <= 102 ? c5 - 87 : c5 - 48 & 0xf;
                }
                function parseHexByte1(string1, lowerBound1, index1) {
                    var r3 = parseHex4Bits1(string1, index1);
                    return index1 - 1 >= lowerBound1 && (r3 |= parseHex4Bits1(string1, index1 - 1) << 4), r3;
                }
                function parseBase1(str1, start1, end1, mul1) {
                    for(var r3 = 0, len3 = Math.min(str1.length, end1), i2 = start1; i2 < len3; i2++){
                        var c5 = str1.charCodeAt(i2) - 48;
                        r3 *= mul1, c5 >= 49 ? r3 += c5 - 49 + 0xa : c5 >= 17 ? r3 += c5 - 17 + 0xa : r3 += c5;
                    }
                    return r3;
                }
                BN1.isBN = function(num1) {
                    return num1 instanceof BN1 || null !== num1 && 'object' == typeof num1 && num1.constructor.wordSize === BN1.wordSize && Array.isArray(num1.words);
                }, BN1.max = function(left1, right1) {
                    return left1.cmp(right1) > 0 ? left1 : right1;
                }, BN1.min = function(left1, right1) {
                    return 0 > left1.cmp(right1) ? left1 : right1;
                }, BN1.prototype._init = function(number1, base1, endian1) {
                    if ('number' == typeof number1) return this._initNumber(number1, base1, endian1);
                    if ('object' == typeof number1) return this._initArray(number1, base1, endian1);
                    'hex' === base1 && (base1 = 16), assert1(base1 === (0 | base1) && base1 >= 2 && base1 <= 36);
                    var start1 = 0;
                    '-' === (number1 = number1.toString().replace(/\s+/g, ''))[0] && (start1++, this.negative = 1), start1 < number1.length && (16 === base1 ? this._parseHex(number1, start1, endian1) : (this._parseBase(number1, base1, start1), 'le' === endian1 && this._initArray(this.toArray(), base1, endian1)));
                }, BN1.prototype._initNumber = function(number1, base1, endian1) {
                    number1 < 0 && (this.negative = 1, number1 = -number1), number1 < 0x4000000 ? (this.words = [
                        0x3ffffff & number1
                    ], this.length = 1) : number1 < 0x10000000000000 ? (this.words = [
                        0x3ffffff & number1,
                        number1 / 0x4000000 & 0x3ffffff
                    ], this.length = 2) : (assert1(number1 < 0x20000000000000), this.words = [
                        0x3ffffff & number1,
                        number1 / 0x4000000 & 0x3ffffff,
                        1
                    ], this.length = 3), 'le' === endian1 && this._initArray(this.toArray(), base1, endian1);
                }, BN1.prototype._initArray = function(number1, base1, endian1) {
                    if (assert1('number' == typeof number1.length), number1.length <= 0) return this.words = [
                        0
                    ], this.length = 1, this;
                    this.length = Math.ceil(number1.length / 3), this.words = Array(this.length);
                    for(var j1, w19, i2 = 0; i2 < this.length; i2++)this.words[i2] = 0;
                    var off1 = 0;
                    if ('be' === endian1) for(i2 = number1.length - 1, j1 = 0; i2 >= 0; i2 -= 3)w19 = number1[i2] | number1[i2 - 1] << 8 | number1[i2 - 2] << 16, this.words[j1] |= w19 << off1 & 0x3ffffff, this.words[j1 + 1] = w19 >>> 26 - off1 & 0x3ffffff, (off1 += 24) >= 26 && (off1 -= 26, j1++);
                    else if ('le' === endian1) for(i2 = 0, j1 = 0; i2 < number1.length; i2 += 3)w19 = number1[i2] | number1[i2 + 1] << 8 | number1[i2 + 2] << 16, this.words[j1] |= w19 << off1 & 0x3ffffff, this.words[j1 + 1] = w19 >>> 26 - off1 & 0x3ffffff, (off1 += 24) >= 26 && (off1 -= 26, j1++);
                    return this.strip();
                }, BN1.prototype._parseHex = function(number1, start1, endian1) {
                    this.length = Math.ceil((number1.length - start1) / 6), this.words = Array(this.length);
                    for(var w19, i2 = 0; i2 < this.length; i2++)this.words[i2] = 0;
                    var off1 = 0, j1 = 0;
                    if ('be' === endian1) for(i2 = number1.length - 1; i2 >= start1; i2 -= 2)w19 = parseHexByte1(number1, start1, i2) << off1, this.words[j1] |= 0x3ffffff & w19, off1 >= 18 ? (off1 -= 18, j1 += 1, this.words[j1] |= w19 >>> 26) : off1 += 8;
                    else for(i2 = (number1.length - start1) % 2 == 0 ? start1 + 1 : start1; i2 < number1.length; i2 += 2)w19 = parseHexByte1(number1, start1, i2) << off1, this.words[j1] |= 0x3ffffff & w19, off1 >= 18 ? (off1 -= 18, j1 += 1, this.words[j1] |= w19 >>> 26) : off1 += 8;
                    this.strip();
                }, BN1.prototype._parseBase = function(number1, base1, start1) {
                    this.words = [
                        0
                    ], this.length = 1;
                    for(var limbLen1 = 0, limbPow1 = 1; limbPow1 <= 0x3ffffff; limbPow1 *= base1)limbLen1++;
                    limbLen1--, limbPow1 = limbPow1 / base1 | 0;
                    for(var total1 = number1.length - start1, mod1 = total1 % limbLen1, end1 = Math.min(total1, total1 - mod1) + start1, word1 = 0, i2 = start1; i2 < end1; i2 += limbLen1)word1 = parseBase1(number1, i2, i2 + limbLen1, base1), this.imuln(limbPow1), this.words[0] + word1 < 0x4000000 ? this.words[0] += word1 : this._iaddn(word1);
                    if (0 !== mod1) {
                        var pow1 = 1;
                        for(word1 = parseBase1(number1, i2, number1.length, base1), i2 = 0; i2 < mod1; i2++)pow1 *= base1;
                        this.imuln(pow1), this.words[0] + word1 < 0x4000000 ? this.words[0] += word1 : this._iaddn(word1);
                    }
                    this.strip();
                }, BN1.prototype.copy = function(dest1) {
                    dest1.words = Array(this.length);
                    for(var i2 = 0; i2 < this.length; i2++)dest1.words[i2] = this.words[i2];
                    dest1.length = this.length, dest1.negative = this.negative, dest1.red = this.red;
                }, BN1.prototype.clone = function() {
                    var r3 = new BN1(null);
                    return this.copy(r3), r3;
                }, BN1.prototype._expand = function(size1) {
                    for(; this.length < size1;)this.words[this.length++] = 0;
                    return this;
                }, BN1.prototype.strip = function() {
                    for(; this.length > 1 && 0 === this.words[this.length - 1];)this.length--;
                    return this._normSign();
                }, BN1.prototype._normSign = function() {
                    return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
                }, BN1.prototype.inspect = function() {
                    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
                };
                var Buffer1, zeros1 = [
                    '',
                    '0',
                    '00',
                    '000',
                    '0000',
                    '00000',
                    '000000',
                    '0000000',
                    '00000000',
                    '000000000',
                    '0000000000',
                    '00000000000',
                    '000000000000',
                    '0000000000000',
                    '00000000000000',
                    '000000000000000',
                    '0000000000000000',
                    '00000000000000000',
                    '000000000000000000',
                    '0000000000000000000',
                    '00000000000000000000',
                    '000000000000000000000',
                    '0000000000000000000000',
                    '00000000000000000000000',
                    '000000000000000000000000',
                    '0000000000000000000000000'
                ], groupSizes1 = [
                    0,
                    0,
                    25,
                    16,
                    12,
                    11,
                    10,
                    9,
                    8,
                    8,
                    7,
                    7,
                    7,
                    7,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ], groupBases1 = [
                    0,
                    0,
                    33554432,
                    43046721,
                    16777216,
                    48828125,
                    60466176,
                    40353607,
                    16777216,
                    43046721,
                    10000000,
                    19487171,
                    35831808,
                    62748517,
                    7529536,
                    11390625,
                    16777216,
                    24137569,
                    34012224,
                    47045881,
                    64000000,
                    4084101,
                    5153632,
                    6436343,
                    7962624,
                    9765625,
                    11881376,
                    14348907,
                    17210368,
                    20511149,
                    24300000,
                    28629151,
                    33554432,
                    39135393,
                    45435424,
                    52521875,
                    60466176
                ];
                function toBitArray1(num1) {
                    for(var w19 = Array(num1.bitLength()), bit1 = 0; bit1 < w19.length; bit1++){
                        var off1 = bit1 / 26 | 0, wbit1 = bit1 % 26;
                        w19[bit1] = (num1.words[off1] & 1 << wbit1) >>> wbit1;
                    }
                    return w19;
                }
                function smallMulTo1(self1, num1, out1) {
                    out1.negative = num1.negative ^ self1.negative;
                    var len3 = self1.length + num1.length | 0;
                    out1.length = len3, len3 = len3 - 1 | 0;
                    var a10 = 0 | self1.words[0], b10 = 0 | num1.words[0], r3 = a10 * b10, lo1 = 0x3ffffff & r3, carry1 = r3 / 0x4000000 | 0;
                    out1.words[0] = lo1;
                    for(var k3 = 1; k3 < len3; k3++){
                        for(var ncarry1 = carry1 >>> 26, rword1 = 0x3ffffff & carry1, maxJ1 = Math.min(k3, num1.length - 1), j1 = Math.max(0, k3 - self1.length + 1); j1 <= maxJ1; j1++){
                            var i2 = k3 - j1 | 0;
                            ncarry1 += (r3 = (a10 = 0 | self1.words[i2]) * (b10 = 0 | num1.words[j1]) + rword1) / 0x4000000 | 0, rword1 = 0x3ffffff & r3;
                        }
                        out1.words[k3] = 0 | rword1, carry1 = 0 | ncarry1;
                    }
                    return 0 !== carry1 ? out1.words[k3] = 0 | carry1 : out1.length--, out1.strip();
                }
                BN1.prototype.toString = function(base1, padding1) {
                    if (padding1 = 0 | padding1 || 1, 16 === (base1 = base1 || 10) || 'hex' === base1) {
                        out1 = '';
                        for(var out1, off1 = 0, carry1 = 0, i2 = 0; i2 < this.length; i2++){
                            var w19 = this.words[i2], word1 = ((w19 << off1 | carry1) & 0xffffff).toString(16);
                            out1 = 0 != (carry1 = w19 >>> 24 - off1 & 0xffffff) || i2 !== this.length - 1 ? zeros1[6 - word1.length] + word1 + out1 : word1 + out1, (off1 += 2) >= 26 && (off1 -= 26, i2--);
                        }
                        for(0 !== carry1 && (out1 = carry1.toString(16) + out1); out1.length % padding1 != 0;)out1 = '0' + out1;
                        return 0 !== this.negative && (out1 = '-' + out1), out1;
                    }
                    if (base1 === (0 | base1) && base1 >= 2 && base1 <= 36) {
                        var groupSize1 = groupSizes1[base1], groupBase1 = groupBases1[base1];
                        out1 = '';
                        var c5 = this.clone();
                        for(c5.negative = 0; !c5.isZero();){
                            var r3 = c5.modn(groupBase1).toString(base1);
                            out1 = (c5 = c5.idivn(groupBase1)).isZero() ? r3 + out1 : zeros1[groupSize1 - r3.length] + r3 + out1;
                        }
                        for(this.isZero() && (out1 = '0' + out1); out1.length % padding1 != 0;)out1 = '0' + out1;
                        return 0 !== this.negative && (out1 = '-' + out1), out1;
                    }
                    assert1(!1, 'Base should be between 2 and 36');
                }, BN1.prototype.toNumber = function() {
                    var ret1 = this.words[0];
                    return 2 === this.length ? ret1 += 0x4000000 * this.words[1] : 3 === this.length && 0x01 === this.words[2] ? ret1 += 0x10000000000000 + 0x4000000 * this.words[1] : this.length > 2 && assert1(!1, 'Number can only safely store up to 53 bits'), 0 !== this.negative ? -ret1 : ret1;
                }, BN1.prototype.toJSON = function() {
                    return this.toString(16);
                }, BN1.prototype.toBuffer = function(endian1, length1) {
                    return assert1(void 0 !== Buffer1), this.toArrayLike(Buffer1, endian1, length1);
                }, BN1.prototype.toArray = function(endian1, length1) {
                    return this.toArrayLike(Array, endian1, length1);
                }, BN1.prototype.toArrayLike = function(ArrayType1, endian1, length1) {
                    var b10, i2, byteLength1 = this.byteLength(), reqLength1 = length1 || Math.max(1, byteLength1);
                    assert1(byteLength1 <= reqLength1, 'byte array longer than desired length'), assert1(reqLength1 > 0, 'Requested array length <= 0'), this.strip();
                    var littleEndian1 = 'le' === endian1, res1 = new ArrayType1(reqLength1), q3 = this.clone();
                    if (littleEndian1) {
                        for(i2 = 0; !q3.isZero(); i2++)b10 = q3.andln(0xff), q3.iushrn(8), res1[i2] = b10;
                        for(; i2 < reqLength1; i2++)res1[i2] = 0;
                    } else {
                        for(i2 = 0; i2 < reqLength1 - byteLength1; i2++)res1[i2] = 0;
                        for(i2 = 0; !q3.isZero(); i2++)b10 = q3.andln(0xff), q3.iushrn(8), res1[reqLength1 - i2 - 1] = b10;
                    }
                    return res1;
                }, Math.clz32 ? BN1.prototype._countBits = function(w19) {
                    return 32 - Math.clz32(w19);
                } : BN1.prototype._countBits = function(w19) {
                    var t3 = w19, r3 = 0;
                    return t3 >= 0x1000 && (r3 += 13, t3 >>>= 13), t3 >= 0x40 && (r3 += 7, t3 >>>= 7), t3 >= 0x8 && (r3 += 4, t3 >>>= 4), t3 >= 0x02 && (r3 += 2, t3 >>>= 2), r3 + t3;
                }, BN1.prototype._zeroBits = function(w19) {
                    if (0 === w19) return 26;
                    var t3 = w19, r3 = 0;
                    return (0x1fff & t3) == 0 && (r3 += 13, t3 >>>= 13), (0x7f & t3) == 0 && (r3 += 7, t3 >>>= 7), (0xf & t3) == 0 && (r3 += 4, t3 >>>= 4), (0x3 & t3) == 0 && (r3 += 2, t3 >>>= 2), (0x1 & t3) == 0 && r3++, r3;
                }, BN1.prototype.bitLength = function() {
                    var w19 = this.words[this.length - 1], hi1 = this._countBits(w19);
                    return (this.length - 1) * 26 + hi1;
                }, BN1.prototype.zeroBits = function() {
                    if (this.isZero()) return 0;
                    for(var r3 = 0, i2 = 0; i2 < this.length; i2++){
                        var b10 = this._zeroBits(this.words[i2]);
                        if (r3 += b10, 26 !== b10) break;
                    }
                    return r3;
                }, BN1.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8);
                }, BN1.prototype.toTwos = function(width1) {
                    return 0 !== this.negative ? this.abs().inotn(width1).iaddn(1) : this.clone();
                }, BN1.prototype.fromTwos = function(width1) {
                    return this.testn(width1 - 1) ? this.notn(width1).iaddn(1).ineg() : this.clone();
                }, BN1.prototype.isNeg = function() {
                    return 0 !== this.negative;
                }, BN1.prototype.neg = function() {
                    return this.clone().ineg();
                }, BN1.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1), this;
                }, BN1.prototype.iuor = function(num1) {
                    for(; this.length < num1.length;)this.words[this.length++] = 0;
                    for(var i2 = 0; i2 < num1.length; i2++)this.words[i2] = this.words[i2] | num1.words[i2];
                    return this.strip();
                }, BN1.prototype.ior = function(num1) {
                    return assert1((this.negative | num1.negative) == 0), this.iuor(num1);
                }, BN1.prototype.or = function(num1) {
                    return this.length > num1.length ? this.clone().ior(num1) : num1.clone().ior(this);
                }, BN1.prototype.uor = function(num1) {
                    return this.length > num1.length ? this.clone().iuor(num1) : num1.clone().iuor(this);
                }, BN1.prototype.iuand = function(num1) {
                    var b10;
                    b10 = this.length > num1.length ? num1 : this;
                    for(var i2 = 0; i2 < b10.length; i2++)this.words[i2] = this.words[i2] & num1.words[i2];
                    return this.length = b10.length, this.strip();
                }, BN1.prototype.iand = function(num1) {
                    return assert1((this.negative | num1.negative) == 0), this.iuand(num1);
                }, BN1.prototype.and = function(num1) {
                    return this.length > num1.length ? this.clone().iand(num1) : num1.clone().iand(this);
                }, BN1.prototype.uand = function(num1) {
                    return this.length > num1.length ? this.clone().iuand(num1) : num1.clone().iuand(this);
                }, BN1.prototype.iuxor = function(num1) {
                    this.length > num1.length ? (a10 = this, b10 = num1) : (a10 = num1, b10 = this);
                    for(var a10, b10, i2 = 0; i2 < b10.length; i2++)this.words[i2] = a10.words[i2] ^ b10.words[i2];
                    if (this !== a10) for(; i2 < a10.length; i2++)this.words[i2] = a10.words[i2];
                    return this.length = a10.length, this.strip();
                }, BN1.prototype.ixor = function(num1) {
                    return assert1((this.negative | num1.negative) == 0), this.iuxor(num1);
                }, BN1.prototype.xor = function(num1) {
                    return this.length > num1.length ? this.clone().ixor(num1) : num1.clone().ixor(this);
                }, BN1.prototype.uxor = function(num1) {
                    return this.length > num1.length ? this.clone().iuxor(num1) : num1.clone().iuxor(this);
                }, BN1.prototype.inotn = function(width1) {
                    assert1('number' == typeof width1 && width1 >= 0);
                    var bytesNeeded1 = 0 | Math.ceil(width1 / 26), bitsLeft1 = width1 % 26;
                    this._expand(bytesNeeded1), bitsLeft1 > 0 && bytesNeeded1--;
                    for(var i2 = 0; i2 < bytesNeeded1; i2++)this.words[i2] = 0x3ffffff & ~this.words[i2];
                    return bitsLeft1 > 0 && (this.words[i2] = ~this.words[i2] & 0x3ffffff >> 26 - bitsLeft1), this.strip();
                }, BN1.prototype.notn = function(width1) {
                    return this.clone().inotn(width1);
                }, BN1.prototype.setn = function(bit1, val1) {
                    assert1('number' == typeof bit1 && bit1 >= 0);
                    var off1 = bit1 / 26 | 0, wbit1 = bit1 % 26;
                    return this._expand(off1 + 1), val1 ? this.words[off1] = this.words[off1] | 1 << wbit1 : this.words[off1] = this.words[off1] & ~(1 << wbit1), this.strip();
                }, BN1.prototype.iadd = function(num1) {
                    if (0 !== this.negative && 0 === num1.negative) return this.negative = 0, r3 = this.isub(num1), this.negative ^= 1, this._normSign();
                    if (0 === this.negative && 0 !== num1.negative) return num1.negative = 0, r3 = this.isub(num1), num1.negative = 1, r3._normSign();
                    this.length > num1.length ? (a10 = this, b10 = num1) : (a10 = num1, b10 = this);
                    for(var r3, a10, b10, carry1 = 0, i2 = 0; i2 < b10.length; i2++)r3 = (0 | a10.words[i2]) + (0 | b10.words[i2]) + carry1, this.words[i2] = 0x3ffffff & r3, carry1 = r3 >>> 26;
                    for(; 0 !== carry1 && i2 < a10.length; i2++)r3 = (0 | a10.words[i2]) + carry1, this.words[i2] = 0x3ffffff & r3, carry1 = r3 >>> 26;
                    if (this.length = a10.length, 0 !== carry1) this.words[this.length] = carry1, this.length++;
                    else if (a10 !== this) for(; i2 < a10.length; i2++)this.words[i2] = a10.words[i2];
                    return this;
                }, BN1.prototype.add = function(num1) {
                    var res1;
                    return 0 !== num1.negative && 0 === this.negative ? (num1.negative = 0, res1 = this.sub(num1), num1.negative ^= 1, res1) : 0 === num1.negative && 0 !== this.negative ? (this.negative = 0, res1 = num1.sub(this), this.negative = 1, res1) : this.length > num1.length ? this.clone().iadd(num1) : num1.clone().iadd(this);
                }, BN1.prototype.isub = function(num1) {
                    if (0 !== num1.negative) {
                        num1.negative = 0;
                        var a10, b10, r3 = this.iadd(num1);
                        return num1.negative = 1, r3._normSign();
                    }
                    if (0 !== this.negative) return this.negative = 0, this.iadd(num1), this.negative = 1, this._normSign();
                    var cmp1 = this.cmp(num1);
                    if (0 === cmp1) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                    cmp1 > 0 ? (a10 = this, b10 = num1) : (a10 = num1, b10 = this);
                    for(var carry1 = 0, i2 = 0; i2 < b10.length; i2++)carry1 = (r3 = (0 | a10.words[i2]) - (0 | b10.words[i2]) + carry1) >> 26, this.words[i2] = 0x3ffffff & r3;
                    for(; 0 !== carry1 && i2 < a10.length; i2++)carry1 = (r3 = (0 | a10.words[i2]) + carry1) >> 26, this.words[i2] = 0x3ffffff & r3;
                    if (0 === carry1 && i2 < a10.length && a10 !== this) for(; i2 < a10.length; i2++)this.words[i2] = a10.words[i2];
                    return this.length = Math.max(this.length, i2), a10 !== this && (this.negative = 1), this.strip();
                }, BN1.prototype.sub = function(num1) {
                    return this.clone().isub(num1);
                };
                var comb10MulTo1 = function(self1, num1, out1) {
                    var lo1, mid1, hi1, a10 = self1.words, b10 = num1.words, o1 = out1.words, c5 = 0, a01 = 0 | a10[0], al01 = 0x1fff & a01, ah01 = a01 >>> 13, a11 = 0 | a10[1], al11 = 0x1fff & a11, ah11 = a11 >>> 13, a21 = 0 | a10[2], al21 = 0x1fff & a21, ah21 = a21 >>> 13, a31 = 0 | a10[3], al31 = 0x1fff & a31, ah31 = a31 >>> 13, a41 = 0 | a10[4], al41 = 0x1fff & a41, ah41 = a41 >>> 13, a51 = 0 | a10[5], al51 = 0x1fff & a51, ah51 = a51 >>> 13, a61 = 0 | a10[6], al61 = 0x1fff & a61, ah61 = a61 >>> 13, a71 = 0 | a10[7], al71 = 0x1fff & a71, ah71 = a71 >>> 13, a81 = 0 | a10[8], al81 = 0x1fff & a81, ah81 = a81 >>> 13, a91 = 0 | a10[9], al91 = 0x1fff & a91, ah91 = a91 >>> 13, b01 = 0 | b10[0], bl01 = 0x1fff & b01, bh01 = b01 >>> 13, b11 = 0 | b10[1], bl11 = 0x1fff & b11, bh11 = b11 >>> 13, b21 = 0 | b10[2], bl21 = 0x1fff & b21, bh21 = b21 >>> 13, b31 = 0 | b10[3], bl31 = 0x1fff & b31, bh31 = b31 >>> 13, b41 = 0 | b10[4], bl41 = 0x1fff & b41, bh41 = b41 >>> 13, b51 = 0 | b10[5], bl51 = 0x1fff & b51, bh51 = b51 >>> 13, b61 = 0 | b10[6], bl61 = 0x1fff & b61, bh61 = b61 >>> 13, b71 = 0 | b10[7], bl71 = 0x1fff & b71, bh71 = b71 >>> 13, b81 = 0 | b10[8], bl81 = 0x1fff & b81, bh81 = b81 >>> 13, b91 = 0 | b10[9], bl91 = 0x1fff & b91, bh91 = b91 >>> 13;
                    out1.negative = self1.negative ^ num1.negative, out1.length = 19;
                    var w01 = (c5 + (lo1 = Math.imul(al01, bl01)) | 0) + ((0x1fff & (mid1 = (mid1 = Math.imul(al01, bh01)) + Math.imul(ah01, bl01) | 0)) << 13) | 0;
                    c5 = ((hi1 = Math.imul(ah01, bh01)) + (mid1 >>> 13) | 0) + (w01 >>> 26) | 0, w01 &= 0x3ffffff, lo1 = Math.imul(al11, bl01), mid1 = (mid1 = Math.imul(al11, bh01)) + Math.imul(ah11, bl01) | 0, hi1 = Math.imul(ah11, bh01);
                    var w19 = (c5 + (lo1 = lo1 + Math.imul(al01, bl11) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh11) | 0) + Math.imul(ah01, bl11) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh11) | 0) + (mid1 >>> 13) | 0) + (w19 >>> 26) | 0, w19 &= 0x3ffffff, lo1 = Math.imul(al21, bl01), mid1 = (mid1 = Math.imul(al21, bh01)) + Math.imul(ah21, bl01) | 0, hi1 = Math.imul(ah21, bh01), lo1 = lo1 + Math.imul(al11, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh11) | 0) + Math.imul(ah11, bl11) | 0, hi1 = hi1 + Math.imul(ah11, bh11) | 0;
                    var w21 = (c5 + (lo1 = lo1 + Math.imul(al01, bl21) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh21) | 0) + Math.imul(ah01, bl21) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh21) | 0) + (mid1 >>> 13) | 0) + (w21 >>> 26) | 0, w21 &= 0x3ffffff, lo1 = Math.imul(al31, bl01), mid1 = (mid1 = Math.imul(al31, bh01)) + Math.imul(ah31, bl01) | 0, hi1 = Math.imul(ah31, bh01), lo1 = lo1 + Math.imul(al21, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh11) | 0) + Math.imul(ah21, bl11) | 0, hi1 = hi1 + Math.imul(ah21, bh11) | 0, lo1 = lo1 + Math.imul(al11, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh21) | 0) + Math.imul(ah11, bl21) | 0, hi1 = hi1 + Math.imul(ah11, bh21) | 0;
                    var w31 = (c5 + (lo1 = lo1 + Math.imul(al01, bl31) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh31) | 0) + Math.imul(ah01, bl31) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh31) | 0) + (mid1 >>> 13) | 0) + (w31 >>> 26) | 0, w31 &= 0x3ffffff, lo1 = Math.imul(al41, bl01), mid1 = (mid1 = Math.imul(al41, bh01)) + Math.imul(ah41, bl01) | 0, hi1 = Math.imul(ah41, bh01), lo1 = lo1 + Math.imul(al31, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh11) | 0) + Math.imul(ah31, bl11) | 0, hi1 = hi1 + Math.imul(ah31, bh11) | 0, lo1 = lo1 + Math.imul(al21, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh21) | 0) + Math.imul(ah21, bl21) | 0, hi1 = hi1 + Math.imul(ah21, bh21) | 0, lo1 = lo1 + Math.imul(al11, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh31) | 0) + Math.imul(ah11, bl31) | 0, hi1 = hi1 + Math.imul(ah11, bh31) | 0;
                    var w41 = (c5 + (lo1 = lo1 + Math.imul(al01, bl41) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh41) | 0) + Math.imul(ah01, bl41) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh41) | 0) + (mid1 >>> 13) | 0) + (w41 >>> 26) | 0, w41 &= 0x3ffffff, lo1 = Math.imul(al51, bl01), mid1 = (mid1 = Math.imul(al51, bh01)) + Math.imul(ah51, bl01) | 0, hi1 = Math.imul(ah51, bh01), lo1 = lo1 + Math.imul(al41, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh11) | 0) + Math.imul(ah41, bl11) | 0, hi1 = hi1 + Math.imul(ah41, bh11) | 0, lo1 = lo1 + Math.imul(al31, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh21) | 0) + Math.imul(ah31, bl21) | 0, hi1 = hi1 + Math.imul(ah31, bh21) | 0, lo1 = lo1 + Math.imul(al21, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh31) | 0) + Math.imul(ah21, bl31) | 0, hi1 = hi1 + Math.imul(ah21, bh31) | 0, lo1 = lo1 + Math.imul(al11, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh41) | 0) + Math.imul(ah11, bl41) | 0, hi1 = hi1 + Math.imul(ah11, bh41) | 0;
                    var w51 = (c5 + (lo1 = lo1 + Math.imul(al01, bl51) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh51) | 0) + Math.imul(ah01, bl51) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh51) | 0) + (mid1 >>> 13) | 0) + (w51 >>> 26) | 0, w51 &= 0x3ffffff, lo1 = Math.imul(al61, bl01), mid1 = (mid1 = Math.imul(al61, bh01)) + Math.imul(ah61, bl01) | 0, hi1 = Math.imul(ah61, bh01), lo1 = lo1 + Math.imul(al51, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh11) | 0) + Math.imul(ah51, bl11) | 0, hi1 = hi1 + Math.imul(ah51, bh11) | 0, lo1 = lo1 + Math.imul(al41, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh21) | 0) + Math.imul(ah41, bl21) | 0, hi1 = hi1 + Math.imul(ah41, bh21) | 0, lo1 = lo1 + Math.imul(al31, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh31) | 0) + Math.imul(ah31, bl31) | 0, hi1 = hi1 + Math.imul(ah31, bh31) | 0, lo1 = lo1 + Math.imul(al21, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh41) | 0) + Math.imul(ah21, bl41) | 0, hi1 = hi1 + Math.imul(ah21, bh41) | 0, lo1 = lo1 + Math.imul(al11, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh51) | 0) + Math.imul(ah11, bl51) | 0, hi1 = hi1 + Math.imul(ah11, bh51) | 0;
                    var w61 = (c5 + (lo1 = lo1 + Math.imul(al01, bl61) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh61) | 0) + Math.imul(ah01, bl61) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh61) | 0) + (mid1 >>> 13) | 0) + (w61 >>> 26) | 0, w61 &= 0x3ffffff, lo1 = Math.imul(al71, bl01), mid1 = (mid1 = Math.imul(al71, bh01)) + Math.imul(ah71, bl01) | 0, hi1 = Math.imul(ah71, bh01), lo1 = lo1 + Math.imul(al61, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh11) | 0) + Math.imul(ah61, bl11) | 0, hi1 = hi1 + Math.imul(ah61, bh11) | 0, lo1 = lo1 + Math.imul(al51, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh21) | 0) + Math.imul(ah51, bl21) | 0, hi1 = hi1 + Math.imul(ah51, bh21) | 0, lo1 = lo1 + Math.imul(al41, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh31) | 0) + Math.imul(ah41, bl31) | 0, hi1 = hi1 + Math.imul(ah41, bh31) | 0, lo1 = lo1 + Math.imul(al31, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh41) | 0) + Math.imul(ah31, bl41) | 0, hi1 = hi1 + Math.imul(ah31, bh41) | 0, lo1 = lo1 + Math.imul(al21, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh51) | 0) + Math.imul(ah21, bl51) | 0, hi1 = hi1 + Math.imul(ah21, bh51) | 0, lo1 = lo1 + Math.imul(al11, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh61) | 0) + Math.imul(ah11, bl61) | 0, hi1 = hi1 + Math.imul(ah11, bh61) | 0;
                    var w71 = (c5 + (lo1 = lo1 + Math.imul(al01, bl71) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh71) | 0) + Math.imul(ah01, bl71) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh71) | 0) + (mid1 >>> 13) | 0) + (w71 >>> 26) | 0, w71 &= 0x3ffffff, lo1 = Math.imul(al81, bl01), mid1 = (mid1 = Math.imul(al81, bh01)) + Math.imul(ah81, bl01) | 0, hi1 = Math.imul(ah81, bh01), lo1 = lo1 + Math.imul(al71, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh11) | 0) + Math.imul(ah71, bl11) | 0, hi1 = hi1 + Math.imul(ah71, bh11) | 0, lo1 = lo1 + Math.imul(al61, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh21) | 0) + Math.imul(ah61, bl21) | 0, hi1 = hi1 + Math.imul(ah61, bh21) | 0, lo1 = lo1 + Math.imul(al51, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh31) | 0) + Math.imul(ah51, bl31) | 0, hi1 = hi1 + Math.imul(ah51, bh31) | 0, lo1 = lo1 + Math.imul(al41, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh41) | 0) + Math.imul(ah41, bl41) | 0, hi1 = hi1 + Math.imul(ah41, bh41) | 0, lo1 = lo1 + Math.imul(al31, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh51) | 0) + Math.imul(ah31, bl51) | 0, hi1 = hi1 + Math.imul(ah31, bh51) | 0, lo1 = lo1 + Math.imul(al21, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh61) | 0) + Math.imul(ah21, bl61) | 0, hi1 = hi1 + Math.imul(ah21, bh61) | 0, lo1 = lo1 + Math.imul(al11, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh71) | 0) + Math.imul(ah11, bl71) | 0, hi1 = hi1 + Math.imul(ah11, bh71) | 0;
                    var w81 = (c5 + (lo1 = lo1 + Math.imul(al01, bl81) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh81) | 0) + Math.imul(ah01, bl81) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh81) | 0) + (mid1 >>> 13) | 0) + (w81 >>> 26) | 0, w81 &= 0x3ffffff, lo1 = Math.imul(al91, bl01), mid1 = (mid1 = Math.imul(al91, bh01)) + Math.imul(ah91, bl01) | 0, hi1 = Math.imul(ah91, bh01), lo1 = lo1 + Math.imul(al81, bl11) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh11) | 0) + Math.imul(ah81, bl11) | 0, hi1 = hi1 + Math.imul(ah81, bh11) | 0, lo1 = lo1 + Math.imul(al71, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh21) | 0) + Math.imul(ah71, bl21) | 0, hi1 = hi1 + Math.imul(ah71, bh21) | 0, lo1 = lo1 + Math.imul(al61, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh31) | 0) + Math.imul(ah61, bl31) | 0, hi1 = hi1 + Math.imul(ah61, bh31) | 0, lo1 = lo1 + Math.imul(al51, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh41) | 0) + Math.imul(ah51, bl41) | 0, hi1 = hi1 + Math.imul(ah51, bh41) | 0, lo1 = lo1 + Math.imul(al41, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh51) | 0) + Math.imul(ah41, bl51) | 0, hi1 = hi1 + Math.imul(ah41, bh51) | 0, lo1 = lo1 + Math.imul(al31, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh61) | 0) + Math.imul(ah31, bl61) | 0, hi1 = hi1 + Math.imul(ah31, bh61) | 0, lo1 = lo1 + Math.imul(al21, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh71) | 0) + Math.imul(ah21, bl71) | 0, hi1 = hi1 + Math.imul(ah21, bh71) | 0, lo1 = lo1 + Math.imul(al11, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al11, bh81) | 0) + Math.imul(ah11, bl81) | 0, hi1 = hi1 + Math.imul(ah11, bh81) | 0;
                    var w91 = (c5 + (lo1 = lo1 + Math.imul(al01, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al01, bh91) | 0) + Math.imul(ah01, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah01, bh91) | 0) + (mid1 >>> 13) | 0) + (w91 >>> 26) | 0, w91 &= 0x3ffffff, lo1 = Math.imul(al91, bl11), mid1 = (mid1 = Math.imul(al91, bh11)) + Math.imul(ah91, bl11) | 0, hi1 = Math.imul(ah91, bh11), lo1 = lo1 + Math.imul(al81, bl21) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh21) | 0) + Math.imul(ah81, bl21) | 0, hi1 = hi1 + Math.imul(ah81, bh21) | 0, lo1 = lo1 + Math.imul(al71, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh31) | 0) + Math.imul(ah71, bl31) | 0, hi1 = hi1 + Math.imul(ah71, bh31) | 0, lo1 = lo1 + Math.imul(al61, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh41) | 0) + Math.imul(ah61, bl41) | 0, hi1 = hi1 + Math.imul(ah61, bh41) | 0, lo1 = lo1 + Math.imul(al51, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh51) | 0) + Math.imul(ah51, bl51) | 0, hi1 = hi1 + Math.imul(ah51, bh51) | 0, lo1 = lo1 + Math.imul(al41, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh61) | 0) + Math.imul(ah41, bl61) | 0, hi1 = hi1 + Math.imul(ah41, bh61) | 0, lo1 = lo1 + Math.imul(al31, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh71) | 0) + Math.imul(ah31, bl71) | 0, hi1 = hi1 + Math.imul(ah31, bh71) | 0, lo1 = lo1 + Math.imul(al21, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al21, bh81) | 0) + Math.imul(ah21, bl81) | 0, hi1 = hi1 + Math.imul(ah21, bh81) | 0;
                    var w101 = (c5 + (lo1 = lo1 + Math.imul(al11, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al11, bh91) | 0) + Math.imul(ah11, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah11, bh91) | 0) + (mid1 >>> 13) | 0) + (w101 >>> 26) | 0, w101 &= 0x3ffffff, lo1 = Math.imul(al91, bl21), mid1 = (mid1 = Math.imul(al91, bh21)) + Math.imul(ah91, bl21) | 0, hi1 = Math.imul(ah91, bh21), lo1 = lo1 + Math.imul(al81, bl31) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh31) | 0) + Math.imul(ah81, bl31) | 0, hi1 = hi1 + Math.imul(ah81, bh31) | 0, lo1 = lo1 + Math.imul(al71, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh41) | 0) + Math.imul(ah71, bl41) | 0, hi1 = hi1 + Math.imul(ah71, bh41) | 0, lo1 = lo1 + Math.imul(al61, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh51) | 0) + Math.imul(ah61, bl51) | 0, hi1 = hi1 + Math.imul(ah61, bh51) | 0, lo1 = lo1 + Math.imul(al51, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh61) | 0) + Math.imul(ah51, bl61) | 0, hi1 = hi1 + Math.imul(ah51, bh61) | 0, lo1 = lo1 + Math.imul(al41, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh71) | 0) + Math.imul(ah41, bl71) | 0, hi1 = hi1 + Math.imul(ah41, bh71) | 0, lo1 = lo1 + Math.imul(al31, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al31, bh81) | 0) + Math.imul(ah31, bl81) | 0, hi1 = hi1 + Math.imul(ah31, bh81) | 0;
                    var w111 = (c5 + (lo1 = lo1 + Math.imul(al21, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al21, bh91) | 0) + Math.imul(ah21, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah21, bh91) | 0) + (mid1 >>> 13) | 0) + (w111 >>> 26) | 0, w111 &= 0x3ffffff, lo1 = Math.imul(al91, bl31), mid1 = (mid1 = Math.imul(al91, bh31)) + Math.imul(ah91, bl31) | 0, hi1 = Math.imul(ah91, bh31), lo1 = lo1 + Math.imul(al81, bl41) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh41) | 0) + Math.imul(ah81, bl41) | 0, hi1 = hi1 + Math.imul(ah81, bh41) | 0, lo1 = lo1 + Math.imul(al71, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh51) | 0) + Math.imul(ah71, bl51) | 0, hi1 = hi1 + Math.imul(ah71, bh51) | 0, lo1 = lo1 + Math.imul(al61, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh61) | 0) + Math.imul(ah61, bl61) | 0, hi1 = hi1 + Math.imul(ah61, bh61) | 0, lo1 = lo1 + Math.imul(al51, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh71) | 0) + Math.imul(ah51, bl71) | 0, hi1 = hi1 + Math.imul(ah51, bh71) | 0, lo1 = lo1 + Math.imul(al41, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al41, bh81) | 0) + Math.imul(ah41, bl81) | 0, hi1 = hi1 + Math.imul(ah41, bh81) | 0;
                    var w121 = (c5 + (lo1 = lo1 + Math.imul(al31, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al31, bh91) | 0) + Math.imul(ah31, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah31, bh91) | 0) + (mid1 >>> 13) | 0) + (w121 >>> 26) | 0, w121 &= 0x3ffffff, lo1 = Math.imul(al91, bl41), mid1 = (mid1 = Math.imul(al91, bh41)) + Math.imul(ah91, bl41) | 0, hi1 = Math.imul(ah91, bh41), lo1 = lo1 + Math.imul(al81, bl51) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh51) | 0) + Math.imul(ah81, bl51) | 0, hi1 = hi1 + Math.imul(ah81, bh51) | 0, lo1 = lo1 + Math.imul(al71, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh61) | 0) + Math.imul(ah71, bl61) | 0, hi1 = hi1 + Math.imul(ah71, bh61) | 0, lo1 = lo1 + Math.imul(al61, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh71) | 0) + Math.imul(ah61, bl71) | 0, hi1 = hi1 + Math.imul(ah61, bh71) | 0, lo1 = lo1 + Math.imul(al51, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al51, bh81) | 0) + Math.imul(ah51, bl81) | 0, hi1 = hi1 + Math.imul(ah51, bh81) | 0;
                    var w131 = (c5 + (lo1 = lo1 + Math.imul(al41, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al41, bh91) | 0) + Math.imul(ah41, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah41, bh91) | 0) + (mid1 >>> 13) | 0) + (w131 >>> 26) | 0, w131 &= 0x3ffffff, lo1 = Math.imul(al91, bl51), mid1 = (mid1 = Math.imul(al91, bh51)) + Math.imul(ah91, bl51) | 0, hi1 = Math.imul(ah91, bh51), lo1 = lo1 + Math.imul(al81, bl61) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh61) | 0) + Math.imul(ah81, bl61) | 0, hi1 = hi1 + Math.imul(ah81, bh61) | 0, lo1 = lo1 + Math.imul(al71, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh71) | 0) + Math.imul(ah71, bl71) | 0, hi1 = hi1 + Math.imul(ah71, bh71) | 0, lo1 = lo1 + Math.imul(al61, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al61, bh81) | 0) + Math.imul(ah61, bl81) | 0, hi1 = hi1 + Math.imul(ah61, bh81) | 0;
                    var w141 = (c5 + (lo1 = lo1 + Math.imul(al51, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al51, bh91) | 0) + Math.imul(ah51, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah51, bh91) | 0) + (mid1 >>> 13) | 0) + (w141 >>> 26) | 0, w141 &= 0x3ffffff, lo1 = Math.imul(al91, bl61), mid1 = (mid1 = Math.imul(al91, bh61)) + Math.imul(ah91, bl61) | 0, hi1 = Math.imul(ah91, bh61), lo1 = lo1 + Math.imul(al81, bl71) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh71) | 0) + Math.imul(ah81, bl71) | 0, hi1 = hi1 + Math.imul(ah81, bh71) | 0, lo1 = lo1 + Math.imul(al71, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al71, bh81) | 0) + Math.imul(ah71, bl81) | 0, hi1 = hi1 + Math.imul(ah71, bh81) | 0;
                    var w151 = (c5 + (lo1 = lo1 + Math.imul(al61, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al61, bh91) | 0) + Math.imul(ah61, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah61, bh91) | 0) + (mid1 >>> 13) | 0) + (w151 >>> 26) | 0, w151 &= 0x3ffffff, lo1 = Math.imul(al91, bl71), mid1 = (mid1 = Math.imul(al91, bh71)) + Math.imul(ah91, bl71) | 0, hi1 = Math.imul(ah91, bh71), lo1 = lo1 + Math.imul(al81, bl81) | 0, mid1 = (mid1 = mid1 + Math.imul(al81, bh81) | 0) + Math.imul(ah81, bl81) | 0, hi1 = hi1 + Math.imul(ah81, bh81) | 0;
                    var w161 = (c5 + (lo1 = lo1 + Math.imul(al71, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al71, bh91) | 0) + Math.imul(ah71, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah71, bh91) | 0) + (mid1 >>> 13) | 0) + (w161 >>> 26) | 0, w161 &= 0x3ffffff, lo1 = Math.imul(al91, bl81), mid1 = (mid1 = Math.imul(al91, bh81)) + Math.imul(ah91, bl81) | 0, hi1 = Math.imul(ah91, bh81);
                    var w171 = (c5 + (lo1 = lo1 + Math.imul(al81, bl91) | 0) | 0) + ((0x1fff & (mid1 = (mid1 = mid1 + Math.imul(al81, bh91) | 0) + Math.imul(ah81, bl91) | 0)) << 13) | 0;
                    c5 = ((hi1 = hi1 + Math.imul(ah81, bh91) | 0) + (mid1 >>> 13) | 0) + (w171 >>> 26) | 0, w171 &= 0x3ffffff;
                    var w181 = (c5 + (lo1 = Math.imul(al91, bl91)) | 0) + ((0x1fff & (mid1 = (mid1 = Math.imul(al91, bh91)) + Math.imul(ah91, bl91) | 0)) << 13) | 0;
                    return c5 = ((hi1 = Math.imul(ah91, bh91)) + (mid1 >>> 13) | 0) + (w181 >>> 26) | 0, w181 &= 0x3ffffff, o1[0] = w01, o1[1] = w19, o1[2] = w21, o1[3] = w31, o1[4] = w41, o1[5] = w51, o1[6] = w61, o1[7] = w71, o1[8] = w81, o1[9] = w91, o1[10] = w101, o1[11] = w111, o1[12] = w121, o1[13] = w131, o1[14] = w141, o1[15] = w151, o1[16] = w161, o1[17] = w171, o1[18] = w181, 0 !== c5 && (o1[19] = c5, out1.length++), out1;
                };
                function bigMulTo1(self1, num1, out1) {
                    out1.negative = num1.negative ^ self1.negative, out1.length = self1.length + num1.length;
                    for(var carry1 = 0, hncarry1 = 0, k3 = 0; k3 < out1.length - 1; k3++){
                        var ncarry1 = hncarry1;
                        hncarry1 = 0;
                        for(var rword1 = 0x3ffffff & carry1, maxJ1 = Math.min(k3, num1.length - 1), j1 = Math.max(0, k3 - self1.length + 1); j1 <= maxJ1; j1++){
                            var i2 = k3 - j1, r3 = (0 | self1.words[i2]) * (0 | num1.words[j1]), lo1 = 0x3ffffff & r3;
                            ncarry1 = ncarry1 + (r3 / 0x4000000 | 0) | 0, rword1 = 0x3ffffff & (lo1 = lo1 + rword1 | 0), hncarry1 += (ncarry1 = ncarry1 + (lo1 >>> 26) | 0) >>> 26, ncarry1 &= 0x3ffffff;
                        }
                        out1.words[k3] = rword1, carry1 = ncarry1, ncarry1 = hncarry1;
                    }
                    return 0 !== carry1 ? out1.words[k3] = carry1 : out1.length--, out1.strip();
                }
                function jumboMulTo1(self1, num1, out1) {
                    return new FFTM1().mulp(self1, num1, out1);
                }
                function FFTM1(x3, y3) {
                    this.x = x3, this.y = y3;
                }
                Math.imul || (comb10MulTo1 = smallMulTo1), BN1.prototype.mulTo = function(num1, out1) {
                    var len3 = this.length + num1.length;
                    return 10 === this.length && 10 === num1.length ? comb10MulTo1(this, num1, out1) : len3 < 63 ? smallMulTo1(this, num1, out1) : len3 < 1024 ? bigMulTo1(this, num1, out1) : jumboMulTo1(this, num1, out1);
                }, FFTM1.prototype.makeRBT = function(N1) {
                    for(var t3 = Array(N1), l1 = BN1.prototype._countBits(N1) - 1, i2 = 0; i2 < N1; i2++)t3[i2] = this.revBin(i2, l1, N1);
                    return t3;
                }, FFTM1.prototype.revBin = function(x3, l1, N1) {
                    if (0 === x3 || x3 === N1 - 1) return x3;
                    for(var rb1 = 0, i2 = 0; i2 < l1; i2++)rb1 |= (1 & x3) << l1 - i2 - 1, x3 >>= 1;
                    return rb1;
                }, FFTM1.prototype.permute = function(rbt1, rws1, iws1, rtws1, itws1, N1) {
                    for(var i2 = 0; i2 < N1; i2++)rtws1[i2] = rws1[rbt1[i2]], itws1[i2] = iws1[rbt1[i2]];
                }, FFTM1.prototype.transform = function(rws1, iws1, rtws1, itws1, N1, rbt1) {
                    this.permute(rbt1, rws1, iws1, rtws1, itws1, N1);
                    for(var s3 = 1; s3 < N1; s3 <<= 1)for(var l1 = s3 << 1, rtwdf1 = Math.cos(2 * Math.PI / l1), itwdf1 = Math.sin(2 * Math.PI / l1), p3 = 0; p3 < N1; p3 += l1)for(var rtwdf_1 = rtwdf1, itwdf_1 = itwdf1, j1 = 0; j1 < s3; j1++){
                        var re1 = rtws1[p3 + j1], ie1 = itws1[p3 + j1], ro1 = rtws1[p3 + j1 + s3], io1 = itws1[p3 + j1 + s3], rx1 = rtwdf_1 * ro1 - itwdf_1 * io1;
                        io1 = rtwdf_1 * io1 + itwdf_1 * ro1, ro1 = rx1, rtws1[p3 + j1] = re1 + ro1, itws1[p3 + j1] = ie1 + io1, rtws1[p3 + j1 + s3] = re1 - ro1, itws1[p3 + j1 + s3] = ie1 - io1, j1 !== l1 && (rx1 = rtwdf1 * rtwdf_1 - itwdf1 * itwdf_1, itwdf_1 = rtwdf1 * itwdf_1 + itwdf1 * rtwdf_1, rtwdf_1 = rx1);
                    }
                }, FFTM1.prototype.guessLen13b = function(n2, m1) {
                    var N1 = 1 | Math.max(m1, n2), odd1 = 1 & N1, i2 = 0;
                    for(N1 = N1 / 2 | 0; N1; N1 >>>= 1)i2++;
                    return 1 << i2 + 1 + odd1;
                }, FFTM1.prototype.conjugate = function(rws1, iws1, N1) {
                    if (!(N1 <= 1)) for(var i2 = 0; i2 < N1 / 2; i2++){
                        var t3 = rws1[i2];
                        rws1[i2] = rws1[N1 - i2 - 1], rws1[N1 - i2 - 1] = t3, t3 = iws1[i2], iws1[i2] = -iws1[N1 - i2 - 1], iws1[N1 - i2 - 1] = -t3;
                    }
                }, FFTM1.prototype.normalize13b = function(ws1, N1) {
                    for(var carry1 = 0, i2 = 0; i2 < N1 / 2; i2++){
                        var w19 = 0x2000 * Math.round(ws1[2 * i2 + 1] / N1) + Math.round(ws1[2 * i2] / N1) + carry1;
                        ws1[i2] = 0x3ffffff & w19, carry1 = w19 < 0x4000000 ? 0 : w19 / 0x4000000 | 0;
                    }
                    return ws1;
                }, FFTM1.prototype.convert13b = function(ws1, len3, rws1, N1) {
                    for(var carry1 = 0, i2 = 0; i2 < len3; i2++)carry1 += 0 | ws1[i2], rws1[2 * i2] = 0x1fff & carry1, carry1 >>>= 13, rws1[2 * i2 + 1] = 0x1fff & carry1, carry1 >>>= 13;
                    for(i2 = 2 * len3; i2 < N1; ++i2)rws1[i2] = 0;
                    assert1(0 === carry1), assert1((-8192 & carry1) == 0);
                }, FFTM1.prototype.stub = function(N1) {
                    for(var ph1 = Array(N1), i2 = 0; i2 < N1; i2++)ph1[i2] = 0;
                    return ph1;
                }, FFTM1.prototype.mulp = function(x3, y3, out1) {
                    var N1 = 2 * this.guessLen13b(x3.length, y3.length), rbt1 = this.makeRBT(N1), _1 = this.stub(N1), rws1 = Array(N1), rwst1 = Array(N1), iwst1 = Array(N1), nrws1 = Array(N1), nrwst1 = Array(N1), niwst1 = Array(N1), rmws1 = out1.words;
                    rmws1.length = N1, this.convert13b(x3.words, x3.length, rws1, N1), this.convert13b(y3.words, y3.length, nrws1, N1), this.transform(rws1, _1, rwst1, iwst1, N1, rbt1), this.transform(nrws1, _1, nrwst1, niwst1, N1, rbt1);
                    for(var i2 = 0; i2 < N1; i2++){
                        var rx1 = rwst1[i2] * nrwst1[i2] - iwst1[i2] * niwst1[i2];
                        iwst1[i2] = rwst1[i2] * niwst1[i2] + iwst1[i2] * nrwst1[i2], rwst1[i2] = rx1;
                    }
                    return this.conjugate(rwst1, iwst1, N1), this.transform(rwst1, iwst1, rmws1, _1, N1, rbt1), this.conjugate(rmws1, _1, N1), this.normalize13b(rmws1, N1), out1.negative = x3.negative ^ y3.negative, out1.length = x3.length + y3.length, out1.strip();
                }, BN1.prototype.mul = function(num1) {
                    var out1 = new BN1(null);
                    return out1.words = Array(this.length + num1.length), this.mulTo(num1, out1);
                }, BN1.prototype.mulf = function(num1) {
                    var out1 = new BN1(null);
                    return out1.words = Array(this.length + num1.length), jumboMulTo1(this, num1, out1);
                }, BN1.prototype.imul = function(num1) {
                    return this.clone().mulTo(num1, this);
                }, BN1.prototype.imuln = function(num1) {
                    assert1('number' == typeof num1), assert1(num1 < 0x4000000);
                    for(var carry1 = 0, i2 = 0; i2 < this.length; i2++){
                        var w19 = (0 | this.words[i2]) * num1, lo1 = (0x3ffffff & w19) + (0x3ffffff & carry1);
                        carry1 >>= 26, carry1 += (w19 / 0x4000000 | 0) + (lo1 >>> 26), this.words[i2] = 0x3ffffff & lo1;
                    }
                    return 0 !== carry1 && (this.words[i2] = carry1, this.length++), this;
                }, BN1.prototype.muln = function(num1) {
                    return this.clone().imuln(num1);
                }, BN1.prototype.sqr = function() {
                    return this.mul(this);
                }, BN1.prototype.isqr = function() {
                    return this.imul(this.clone());
                }, BN1.prototype.pow = function(num1) {
                    var w19 = toBitArray1(num1);
                    if (0 === w19.length) return new BN1(1);
                    for(var res1 = this, i2 = 0; i2 < w19.length && 0 === w19[i2]; i2++, res1 = res1.sqr());
                    if (++i2 < w19.length) for(var q3 = res1.sqr(); i2 < w19.length; i2++, q3 = q3.sqr())0 !== w19[i2] && (res1 = res1.mul(q3));
                    return res1;
                }, BN1.prototype.iushln = function(bits1) {
                    assert1('number' == typeof bits1 && bits1 >= 0);
                    var i2, r3 = bits1 % 26, s3 = (bits1 - r3) / 26, carryMask1 = 0x3ffffff >>> 26 - r3 << 26 - r3;
                    if (0 !== r3) {
                        var carry1 = 0;
                        for(i2 = 0; i2 < this.length; i2++){
                            var newCarry1 = this.words[i2] & carryMask1, c5 = (0 | this.words[i2]) - newCarry1 << r3;
                            this.words[i2] = c5 | carry1, carry1 = newCarry1 >>> 26 - r3;
                        }
                        carry1 && (this.words[i2] = carry1, this.length++);
                    }
                    if (0 !== s3) {
                        for(i2 = this.length - 1; i2 >= 0; i2--)this.words[i2 + s3] = this.words[i2];
                        for(i2 = 0; i2 < s3; i2++)this.words[i2] = 0;
                        this.length += s3;
                    }
                    return this.strip();
                }, BN1.prototype.ishln = function(bits1) {
                    return assert1(0 === this.negative), this.iushln(bits1);
                }, BN1.prototype.iushrn = function(bits1, hint1, extended1) {
                    assert1('number' == typeof bits1 && bits1 >= 0), h8 = hint1 ? (hint1 - hint1 % 26) / 26 : 0;
                    var h8, r3 = bits1 % 26, s3 = Math.min((bits1 - r3) / 26, this.length), mask1 = 0x3ffffff ^ 0x3ffffff >>> r3 << r3, maskedWords1 = extended1;
                    if (h8 -= s3, h8 = Math.max(0, h8), maskedWords1) {
                        for(var i2 = 0; i2 < s3; i2++)maskedWords1.words[i2] = this.words[i2];
                        maskedWords1.length = s3;
                    }
                    if (0 === s3) ;
                    else if (this.length > s3) for(this.length -= s3, i2 = 0; i2 < this.length; i2++)this.words[i2] = this.words[i2 + s3];
                    else this.words[0] = 0, this.length = 1;
                    var carry1 = 0;
                    for(i2 = this.length - 1; i2 >= 0 && (0 !== carry1 || i2 >= h8); i2--){
                        var word1 = 0 | this.words[i2];
                        this.words[i2] = carry1 << 26 - r3 | word1 >>> r3, carry1 = word1 & mask1;
                    }
                    return maskedWords1 && 0 !== carry1 && (maskedWords1.words[maskedWords1.length++] = carry1), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
                }, BN1.prototype.ishrn = function(bits1, hint1, extended1) {
                    return assert1(0 === this.negative), this.iushrn(bits1, hint1, extended1);
                }, BN1.prototype.shln = function(bits1) {
                    return this.clone().ishln(bits1);
                }, BN1.prototype.ushln = function(bits1) {
                    return this.clone().iushln(bits1);
                }, BN1.prototype.shrn = function(bits1) {
                    return this.clone().ishrn(bits1);
                }, BN1.prototype.ushrn = function(bits1) {
                    return this.clone().iushrn(bits1);
                }, BN1.prototype.testn = function(bit1) {
                    assert1('number' == typeof bit1 && bit1 >= 0);
                    var r3 = bit1 % 26, s3 = (bit1 - r3) / 26, q3 = 1 << r3;
                    return !(this.length <= s3) && !!(this.words[s3] & q3);
                }, BN1.prototype.imaskn = function(bits1) {
                    assert1('number' == typeof bits1 && bits1 >= 0);
                    var r3 = bits1 % 26, s3 = (bits1 - r3) / 26;
                    if (assert1(0 === this.negative, 'imaskn works only with positive numbers'), this.length <= s3) return this;
                    if (0 !== r3 && s3++, this.length = Math.min(s3, this.length), 0 !== r3) {
                        var mask1 = 0x3ffffff ^ 0x3ffffff >>> r3 << r3;
                        this.words[this.length - 1] &= mask1;
                    }
                    return this.strip();
                }, BN1.prototype.maskn = function(bits1) {
                    return this.clone().imaskn(bits1);
                }, BN1.prototype.iaddn = function(num1) {
                    return (assert1('number' == typeof num1), assert1(num1 < 0x4000000), num1 < 0) ? this.isubn(-num1) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < num1 ? (this.words[0] = num1 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(num1), this.negative = 1, this) : this._iaddn(num1);
                }, BN1.prototype._iaddn = function(num1) {
                    this.words[0] += num1;
                    for(var i2 = 0; i2 < this.length && this.words[i2] >= 0x4000000; i2++)this.words[i2] -= 0x4000000, i2 === this.length - 1 ? this.words[i2 + 1] = 1 : this.words[i2 + 1]++;
                    return this.length = Math.max(this.length, i2 + 1), this;
                }, BN1.prototype.isubn = function(num1) {
                    if (assert1('number' == typeof num1), assert1(num1 < 0x4000000), num1 < 0) return this.iaddn(-num1);
                    if (0 !== this.negative) return this.negative = 0, this.iaddn(num1), this.negative = 1, this;
                    if (this.words[0] -= num1, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                    else for(var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++)this.words[i2] += 0x4000000, this.words[i2 + 1] -= 1;
                    return this.strip();
                }, BN1.prototype.addn = function(num1) {
                    return this.clone().iaddn(num1);
                }, BN1.prototype.subn = function(num1) {
                    return this.clone().isubn(num1);
                }, BN1.prototype.iabs = function() {
                    return this.negative = 0, this;
                }, BN1.prototype.abs = function() {
                    return this.clone().iabs();
                }, BN1.prototype._ishlnsubmul = function(num1, mul1, shift1) {
                    var i2, w19, len3 = num1.length + shift1;
                    this._expand(len3);
                    var carry1 = 0;
                    for(i2 = 0; i2 < num1.length; i2++){
                        w19 = (0 | this.words[i2 + shift1]) + carry1;
                        var right1 = (0 | num1.words[i2]) * mul1;
                        w19 -= 0x3ffffff & right1, carry1 = (w19 >> 26) - (right1 / 0x4000000 | 0), this.words[i2 + shift1] = 0x3ffffff & w19;
                    }
                    for(; i2 < this.length - shift1; i2++)carry1 = (w19 = (0 | this.words[i2 + shift1]) + carry1) >> 26, this.words[i2 + shift1] = 0x3ffffff & w19;
                    if (0 === carry1) return this.strip();
                    for(assert1(-1 === carry1), carry1 = 0, i2 = 0; i2 < this.length; i2++)carry1 = (w19 = -(0 | this.words[i2]) + carry1) >> 26, this.words[i2] = 0x3ffffff & w19;
                    return this.negative = 1, this.strip();
                }, BN1.prototype._wordDiv = function(num1, mode1) {
                    var q3, shift1 = this.length - num1.length, a10 = this.clone(), b10 = num1, bhi1 = 0 | b10.words[b10.length - 1];
                    0 != (shift1 = 26 - this._countBits(bhi1)) && (b10 = b10.ushln(shift1), a10.iushln(shift1), bhi1 = 0 | b10.words[b10.length - 1]);
                    var m1 = a10.length - b10.length;
                    if ('mod' !== mode1) {
                        (q3 = new BN1(null)).length = m1 + 1, q3.words = Array(q3.length);
                        for(var i2 = 0; i2 < q3.length; i2++)q3.words[i2] = 0;
                    }
                    var diff1 = a10.clone()._ishlnsubmul(b10, 1, m1);
                    0 === diff1.negative && (a10 = diff1, q3 && (q3.words[m1] = 1));
                    for(var j1 = m1 - 1; j1 >= 0; j1--){
                        var qj1 = (0 | a10.words[b10.length + j1]) * 0x4000000 + (0 | a10.words[b10.length + j1 - 1]);
                        for(qj1 = Math.min(qj1 / bhi1 | 0, 0x3ffffff), a10._ishlnsubmul(b10, qj1, j1); 0 !== a10.negative;)qj1--, a10.negative = 0, a10._ishlnsubmul(b10, 1, j1), a10.isZero() || (a10.negative ^= 1);
                        q3 && (q3.words[j1] = qj1);
                    }
                    return q3 && q3.strip(), a10.strip(), 'div' !== mode1 && 0 !== shift1 && a10.iushrn(shift1), {
                        div: q3 || null,
                        mod: a10
                    };
                }, BN1.prototype.divmod = function(num1, mode1, positive1) {
                    var div1, mod1, res1;
                    return (assert1(!num1.isZero()), this.isZero()) ? {
                        div: new BN1(0),
                        mod: new BN1(0)
                    } : 0 !== this.negative && 0 === num1.negative ? (res1 = this.neg().divmod(num1, mode1), 'mod' !== mode1 && (div1 = res1.div.neg()), 'div' !== mode1 && (mod1 = res1.mod.neg(), positive1 && 0 !== mod1.negative && mod1.iadd(num1)), {
                        div: div1,
                        mod: mod1
                    }) : 0 === this.negative && 0 !== num1.negative ? (res1 = this.divmod(num1.neg(), mode1), 'mod' !== mode1 && (div1 = res1.div.neg()), {
                        div: div1,
                        mod: res1.mod
                    }) : (this.negative & num1.negative) != 0 ? (res1 = this.neg().divmod(num1.neg(), mode1), 'div' !== mode1 && (mod1 = res1.mod.neg(), positive1 && 0 !== mod1.negative && mod1.isub(num1)), {
                        div: res1.div,
                        mod: mod1
                    }) : num1.length > this.length || 0 > this.cmp(num1) ? {
                        div: new BN1(0),
                        mod: this
                    } : 1 === num1.length ? 'div' === mode1 ? {
                        div: this.divn(num1.words[0]),
                        mod: null
                    } : 'mod' === mode1 ? {
                        div: null,
                        mod: new BN1(this.modn(num1.words[0]))
                    } : {
                        div: this.divn(num1.words[0]),
                        mod: new BN1(this.modn(num1.words[0]))
                    } : this._wordDiv(num1, mode1);
                }, BN1.prototype.div = function(num1) {
                    return this.divmod(num1, 'div', !1).div;
                }, BN1.prototype.mod = function(num1) {
                    return this.divmod(num1, 'mod', !1).mod;
                }, BN1.prototype.umod = function(num1) {
                    return this.divmod(num1, 'mod', !0).mod;
                }, BN1.prototype.divRound = function(num1) {
                    var dm1 = this.divmod(num1);
                    if (dm1.mod.isZero()) return dm1.div;
                    var mod1 = 0 !== dm1.div.negative ? dm1.mod.isub(num1) : dm1.mod, half1 = num1.ushrn(1), r21 = num1.andln(1), cmp1 = mod1.cmp(half1);
                    return cmp1 < 0 || 1 === r21 && 0 === cmp1 ? dm1.div : 0 !== dm1.div.negative ? dm1.div.isubn(1) : dm1.div.iaddn(1);
                }, BN1.prototype.modn = function(num1) {
                    assert1(num1 <= 0x3ffffff);
                    for(var p3 = 67108864 % num1, acc1 = 0, i2 = this.length - 1; i2 >= 0; i2--)acc1 = (p3 * acc1 + (0 | this.words[i2])) % num1;
                    return acc1;
                }, BN1.prototype.idivn = function(num1) {
                    assert1(num1 <= 0x3ffffff);
                    for(var carry1 = 0, i2 = this.length - 1; i2 >= 0; i2--){
                        var w19 = (0 | this.words[i2]) + 0x4000000 * carry1;
                        this.words[i2] = w19 / num1 | 0, carry1 = w19 % num1;
                    }
                    return this.strip();
                }, BN1.prototype.divn = function(num1) {
                    return this.clone().idivn(num1);
                }, BN1.prototype.egcd = function(p3) {
                    assert1(0 === p3.negative), assert1(!p3.isZero());
                    var x3 = this, y3 = p3.clone();
                    x3 = 0 !== x3.negative ? x3.umod(p3) : x3.clone();
                    for(var A1 = new BN1(1), B1 = new BN1(0), C1 = new BN1(0), D1 = new BN1(1), g3 = 0; x3.isEven() && y3.isEven();)x3.iushrn(1), y3.iushrn(1), ++g3;
                    for(var yp1 = y3.clone(), xp1 = x3.clone(); !x3.isZero();){
                        for(var i2 = 0, im1 = 1; (x3.words[0] & im1) == 0 && i2 < 26; ++i2, im1 <<= 1);
                        if (i2 > 0) for(x3.iushrn(i2); i2-- > 0;)(A1.isOdd() || B1.isOdd()) && (A1.iadd(yp1), B1.isub(xp1)), A1.iushrn(1), B1.iushrn(1);
                        for(var j1 = 0, jm1 = 1; (y3.words[0] & jm1) == 0 && j1 < 26; ++j1, jm1 <<= 1);
                        if (j1 > 0) for(y3.iushrn(j1); j1-- > 0;)(C1.isOdd() || D1.isOdd()) && (C1.iadd(yp1), D1.isub(xp1)), C1.iushrn(1), D1.iushrn(1);
                        x3.cmp(y3) >= 0 ? (x3.isub(y3), A1.isub(C1), B1.isub(D1)) : (y3.isub(x3), C1.isub(A1), D1.isub(B1));
                    }
                    return {
                        a: C1,
                        b: D1,
                        gcd: y3.iushln(g3)
                    };
                }, BN1.prototype._invmp = function(p3) {
                    assert1(0 === p3.negative), assert1(!p3.isZero());
                    var res1, a10 = this, b10 = p3.clone();
                    a10 = 0 !== a10.negative ? a10.umod(p3) : a10.clone();
                    for(var x11 = new BN1(1), x21 = new BN1(0), delta1 = b10.clone(); a10.cmpn(1) > 0 && b10.cmpn(1) > 0;){
                        for(var i2 = 0, im1 = 1; (a10.words[0] & im1) == 0 && i2 < 26; ++i2, im1 <<= 1);
                        if (i2 > 0) for(a10.iushrn(i2); i2-- > 0;)x11.isOdd() && x11.iadd(delta1), x11.iushrn(1);
                        for(var j1 = 0, jm1 = 1; (b10.words[0] & jm1) == 0 && j1 < 26; ++j1, jm1 <<= 1);
                        if (j1 > 0) for(b10.iushrn(j1); j1-- > 0;)x21.isOdd() && x21.iadd(delta1), x21.iushrn(1);
                        a10.cmp(b10) >= 0 ? (a10.isub(b10), x11.isub(x21)) : (b10.isub(a10), x21.isub(x11));
                    }
                    return 0 > (res1 = 0 === a10.cmpn(1) ? x11 : x21).cmpn(0) && res1.iadd(p3), res1;
                }, BN1.prototype.gcd = function(num1) {
                    if (this.isZero()) return num1.abs();
                    if (num1.isZero()) return this.abs();
                    var a10 = this.clone(), b10 = num1.clone();
                    a10.negative = 0, b10.negative = 0;
                    for(var shift1 = 0; a10.isEven() && b10.isEven(); shift1++)a10.iushrn(1), b10.iushrn(1);
                    for(;;){
                        for(; a10.isEven();)a10.iushrn(1);
                        for(; b10.isEven();)b10.iushrn(1);
                        var r3 = a10.cmp(b10);
                        if (r3 < 0) {
                            var t3 = a10;
                            a10 = b10, b10 = t3;
                        } else if (0 === r3 || 0 === b10.cmpn(1)) break;
                        a10.isub(b10);
                    }
                    return b10.iushln(shift1);
                }, BN1.prototype.invm = function(num1) {
                    return this.egcd(num1).a.umod(num1);
                }, BN1.prototype.isEven = function() {
                    return (1 & this.words[0]) == 0;
                }, BN1.prototype.isOdd = function() {
                    return (1 & this.words[0]) == 1;
                }, BN1.prototype.andln = function(num1) {
                    return this.words[0] & num1;
                }, BN1.prototype.bincn = function(bit1) {
                    assert1('number' == typeof bit1);
                    var r3 = bit1 % 26, s3 = (bit1 - r3) / 26, q3 = 1 << r3;
                    if (this.length <= s3) return this._expand(s3 + 1), this.words[s3] |= q3, this;
                    for(var carry1 = q3, i2 = s3; 0 !== carry1 && i2 < this.length; i2++){
                        var w19 = 0 | this.words[i2];
                        w19 += carry1, carry1 = w19 >>> 26, w19 &= 0x3ffffff, this.words[i2] = w19;
                    }
                    return 0 !== carry1 && (this.words[i2] = carry1, this.length++), this;
                }, BN1.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0];
                }, BN1.prototype.cmpn = function(num1) {
                    var res1, negative1 = num1 < 0;
                    if (0 !== this.negative && !negative1) return -1;
                    if (0 === this.negative && negative1) return 1;
                    if (this.strip(), this.length > 1) res1 = 1;
                    else {
                        negative1 && (num1 = -num1), assert1(num1 <= 0x3ffffff, 'Number is too big');
                        var w19 = 0 | this.words[0];
                        res1 = w19 === num1 ? 0 : w19 < num1 ? -1 : 1;
                    }
                    return 0 !== this.negative ? 0 | -res1 : res1;
                }, BN1.prototype.cmp = function(num1) {
                    if (0 !== this.negative && 0 === num1.negative) return -1;
                    if (0 === this.negative && 0 !== num1.negative) return 1;
                    var res1 = this.ucmp(num1);
                    return 0 !== this.negative ? 0 | -res1 : res1;
                }, BN1.prototype.ucmp = function(num1) {
                    if (this.length > num1.length) return 1;
                    if (this.length < num1.length) return -1;
                    for(var res1 = 0, i2 = this.length - 1; i2 >= 0; i2--){
                        var a10 = 0 | this.words[i2], b10 = 0 | num1.words[i2];
                        if (a10 !== b10) {
                            a10 < b10 ? res1 = -1 : a10 > b10 && (res1 = 1);
                            break;
                        }
                    }
                    return res1;
                }, BN1.prototype.gtn = function(num1) {
                    return 1 === this.cmpn(num1);
                }, BN1.prototype.gt = function(num1) {
                    return 1 === this.cmp(num1);
                }, BN1.prototype.gten = function(num1) {
                    return this.cmpn(num1) >= 0;
                }, BN1.prototype.gte = function(num1) {
                    return this.cmp(num1) >= 0;
                }, BN1.prototype.ltn = function(num1) {
                    return -1 === this.cmpn(num1);
                }, BN1.prototype.lt = function(num1) {
                    return -1 === this.cmp(num1);
                }, BN1.prototype.lten = function(num1) {
                    return 0 >= this.cmpn(num1);
                }, BN1.prototype.lte = function(num1) {
                    return 0 >= this.cmp(num1);
                }, BN1.prototype.eqn = function(num1) {
                    return 0 === this.cmpn(num1);
                }, BN1.prototype.eq = function(num1) {
                    return 0 === this.cmp(num1);
                }, BN1.red = function(num1) {
                    return new Red1(num1);
                }, BN1.prototype.toRed = function(ctx1) {
                    return assert1(!this.red, 'Already a number in reduction context'), assert1(0 === this.negative, 'red works only with positives'), ctx1.convertTo(this)._forceRed(ctx1);
                }, BN1.prototype.fromRed = function() {
                    return assert1(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this);
                }, BN1.prototype._forceRed = function(ctx1) {
                    return this.red = ctx1, this;
                }, BN1.prototype.forceRed = function(ctx1) {
                    return assert1(!this.red, 'Already a number in reduction context'), this._forceRed(ctx1);
                }, BN1.prototype.redAdd = function(num1) {
                    return assert1(this.red, 'redAdd works only with red numbers'), this.red.add(this, num1);
                }, BN1.prototype.redIAdd = function(num1) {
                    return assert1(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, num1);
                }, BN1.prototype.redSub = function(num1) {
                    return assert1(this.red, 'redSub works only with red numbers'), this.red.sub(this, num1);
                }, BN1.prototype.redISub = function(num1) {
                    return assert1(this.red, 'redISub works only with red numbers'), this.red.isub(this, num1);
                }, BN1.prototype.redShl = function(num1) {
                    return assert1(this.red, 'redShl works only with red numbers'), this.red.shl(this, num1);
                }, BN1.prototype.redMul = function(num1) {
                    return assert1(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num1), this.red.mul(this, num1);
                }, BN1.prototype.redIMul = function(num1) {
                    return assert1(this.red, 'redMul works only with red numbers'), this.red._verify2(this, num1), this.red.imul(this, num1);
                }, BN1.prototype.redSqr = function() {
                    return assert1(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this);
                }, BN1.prototype.redISqr = function() {
                    return assert1(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this);
                }, BN1.prototype.redSqrt = function() {
                    return assert1(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this);
                }, BN1.prototype.redInvm = function() {
                    return assert1(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this);
                }, BN1.prototype.redNeg = function() {
                    return assert1(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this);
                }, BN1.prototype.redPow = function(num1) {
                    return assert1(this.red && !num1.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, num1);
                };
                var primes1 = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                function MPrime1(name1, p3) {
                    this.name = name1, this.p = new BN1(p3, 16), this.n = this.p.bitLength(), this.k = new BN1(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
                }
                function K2561() {
                    MPrime1.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
                }
                function P2241() {
                    MPrime1.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
                }
                function P1921() {
                    MPrime1.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
                }
                function P255191() {
                    MPrime1.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
                }
                function Red1(m1) {
                    if ('string' == typeof m1) {
                        var prime1 = BN1._prime(m1);
                        this.m = prime1.p, this.prime = prime1;
                    } else assert1(m1.gtn(1), 'modulus must be greater than 1'), this.m = m1, this.prime = null;
                }
                function Mont1(m1) {
                    Red1.call(this, m1), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new BN1(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
                }
                MPrime1.prototype._tmp = function() {
                    var tmp1 = new BN1(null);
                    return tmp1.words = Array(Math.ceil(this.n / 13)), tmp1;
                }, MPrime1.prototype.ireduce = function(num1) {
                    var rlen1, r3 = num1;
                    do this.split(r3, this.tmp), rlen1 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
                    while (rlen1 > this.n)
                    var cmp1 = rlen1 < this.n ? -1 : r3.ucmp(this.p);
                    return 0 === cmp1 ? (r3.words[0] = 0, r3.length = 1) : cmp1 > 0 ? r3.isub(this.p) : void 0 !== r3.strip ? r3.strip() : r3._strip(), r3;
                }, MPrime1.prototype.split = function(input1, out1) {
                    input1.iushrn(this.n, 0, out1);
                }, MPrime1.prototype.imulK = function(num1) {
                    return num1.imul(this.k);
                }, inherits1(K2561, MPrime1), K2561.prototype.split = function(input1, output1) {
                    for(var mask1 = 0x3fffff, outLen1 = Math.min(input1.length, 9), i2 = 0; i2 < outLen1; i2++)output1.words[i2] = input1.words[i2];
                    if (output1.length = outLen1, input1.length <= 9) {
                        input1.words[0] = 0, input1.length = 1;
                        return;
                    }
                    var prev1 = input1.words[9];
                    for(i2 = 10, output1.words[output1.length++] = prev1 & mask1; i2 < input1.length; i2++){
                        var next1 = 0 | input1.words[i2];
                        input1.words[i2 - 10] = (next1 & mask1) << 4 | prev1 >>> 22, prev1 = next1;
                    }
                    prev1 >>>= 22, input1.words[i2 - 10] = prev1, 0 === prev1 && input1.length > 10 ? input1.length -= 10 : input1.length -= 9;
                }, K2561.prototype.imulK = function(num1) {
                    num1.words[num1.length] = 0, num1.words[num1.length + 1] = 0, num1.length += 2;
                    for(var lo1 = 0, i2 = 0; i2 < num1.length; i2++){
                        var w19 = 0 | num1.words[i2];
                        lo1 += 0x3d1 * w19, num1.words[i2] = 0x3ffffff & lo1, lo1 = 0x40 * w19 + (lo1 / 0x4000000 | 0);
                    }
                    return 0 === num1.words[num1.length - 1] && (num1.length--, 0 === num1.words[num1.length - 1] && num1.length--), num1;
                }, inherits1(P2241, MPrime1), inherits1(P1921, MPrime1), inherits1(P255191, MPrime1), P255191.prototype.imulK = function(num1) {
                    for(var carry1 = 0, i2 = 0; i2 < num1.length; i2++){
                        var hi1 = (0 | num1.words[i2]) * 0x13 + carry1, lo1 = 0x3ffffff & hi1;
                        hi1 >>>= 26, num1.words[i2] = lo1, carry1 = hi1;
                    }
                    return 0 !== carry1 && (num1.words[num1.length++] = carry1), num1;
                }, BN1._prime = function(name1) {
                    var prime1;
                    if (primes1[name1]) return primes1[name1];
                    if ('k256' === name1) prime1 = new K2561();
                    else if ('p224' === name1) prime1 = new P2241();
                    else if ('p192' === name1) prime1 = new P1921();
                    else if ('p25519' === name1) prime1 = new P255191();
                    else throw Error('Unknown prime ' + name1);
                    return primes1[name1] = prime1, prime1;
                }, Red1.prototype._verify1 = function(a10) {
                    assert1(0 === a10.negative, 'red works only with positives'), assert1(a10.red, 'red works only with red numbers');
                }, Red1.prototype._verify2 = function(a10, b10) {
                    assert1((a10.negative | b10.negative) == 0, 'red works only with positives'), assert1(a10.red && a10.red === b10.red, 'red works only with red numbers');
                }, Red1.prototype.imod = function(a10) {
                    return this.prime ? this.prime.ireduce(a10)._forceRed(this) : a10.umod(this.m)._forceRed(this);
                }, Red1.prototype.neg = function(a10) {
                    return a10.isZero() ? a10.clone() : this.m.sub(a10)._forceRed(this);
                }, Red1.prototype.add = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.add(b10);
                    return res1.cmp(this.m) >= 0 && res1.isub(this.m), res1._forceRed(this);
                }, Red1.prototype.iadd = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.iadd(b10);
                    return res1.cmp(this.m) >= 0 && res1.isub(this.m), res1;
                }, Red1.prototype.sub = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.sub(b10);
                    return 0 > res1.cmpn(0) && res1.iadd(this.m), res1._forceRed(this);
                }, Red1.prototype.isub = function(a10, b10) {
                    this._verify2(a10, b10);
                    var res1 = a10.isub(b10);
                    return 0 > res1.cmpn(0) && res1.iadd(this.m), res1;
                }, Red1.prototype.shl = function(a10, num1) {
                    return this._verify1(a10), this.imod(a10.ushln(num1));
                }, Red1.prototype.imul = function(a10, b10) {
                    return this._verify2(a10, b10), this.imod(a10.imul(b10));
                }, Red1.prototype.mul = function(a10, b10) {
                    return this._verify2(a10, b10), this.imod(a10.mul(b10));
                }, Red1.prototype.isqr = function(a10) {
                    return this.imul(a10, a10.clone());
                }, Red1.prototype.sqr = function(a10) {
                    return this.mul(a10, a10);
                }, Red1.prototype.sqrt = function(a10) {
                    if (a10.isZero()) return a10.clone();
                    var mod31 = this.m.andln(3);
                    if (assert1(mod31 % 2 == 1), 3 === mod31) {
                        var pow1 = this.m.add(new BN1(1)).iushrn(2);
                        return this.pow(a10, pow1);
                    }
                    for(var q3 = this.m.subn(1), s3 = 0; !q3.isZero() && 0 === q3.andln(1);)s3++, q3.iushrn(1);
                    assert1(!q3.isZero());
                    var one1 = new BN1(1).toRed(this), nOne1 = one1.redNeg(), lpow1 = this.m.subn(1).iushrn(1), z1 = this.m.bitLength();
                    for(z1 = new BN1(2 * z1 * z1).toRed(this); 0 !== this.pow(z1, lpow1).cmp(nOne1);)z1.redIAdd(nOne1);
                    for(var c5 = this.pow(z1, q3), r3 = this.pow(a10, q3.addn(1).iushrn(1)), t3 = this.pow(a10, q3), m1 = s3; 0 !== t3.cmp(one1);){
                        for(var tmp1 = t3, i2 = 0; 0 !== tmp1.cmp(one1); i2++)tmp1 = tmp1.redSqr();
                        assert1(i2 < m1);
                        var b10 = this.pow(c5, new BN1(1).iushln(m1 - i2 - 1));
                        r3 = r3.redMul(b10), c5 = b10.redSqr(), t3 = t3.redMul(c5), m1 = i2;
                    }
                    return r3;
                }, Red1.prototype.invm = function(a10) {
                    var inv1 = a10._invmp(this.m);
                    return 0 !== inv1.negative ? (inv1.negative = 0, this.imod(inv1).redNeg()) : this.imod(inv1);
                }, Red1.prototype.pow = function(a10, num1) {
                    if (num1.isZero()) return new BN1(1).toRed(this);
                    if (0 === num1.cmpn(1)) return a10.clone();
                    var windowSize1 = 4, wnd1 = Array(16);
                    wnd1[0] = new BN1(1).toRed(this), wnd1[1] = a10;
                    for(var i2 = 2; i2 < wnd1.length; i2++)wnd1[i2] = this.mul(wnd1[i2 - 1], a10);
                    var res1 = wnd1[0], current1 = 0, currentLen1 = 0, start1 = num1.bitLength() % 26;
                    for(0 === start1 && (start1 = 26), i2 = num1.length - 1; i2 >= 0; i2--){
                        for(var word1 = num1.words[i2], j1 = start1 - 1; j1 >= 0; j1--){
                            var bit1 = word1 >> j1 & 1;
                            if (res1 !== wnd1[0] && (res1 = this.sqr(res1)), 0 === bit1 && 0 === current1) {
                                currentLen1 = 0;
                                continue;
                            }
                            current1 <<= 1, current1 |= bit1, (++currentLen1 === windowSize1 || 0 === i2 && 0 === j1) && (res1 = this.mul(res1, wnd1[current1]), currentLen1 = 0, current1 = 0);
                        }
                        start1 = 26;
                    }
                    return res1;
                }, Red1.prototype.convertTo = function(num1) {
                    var r3 = num1.umod(this.m);
                    return r3 === num1 ? r3.clone() : r3;
                }, Red1.prototype.convertFrom = function(num1) {
                    var res1 = num1.clone();
                    return res1.red = null, res1;
                }, BN1.mont = function(num1) {
                    return new Mont1(num1);
                }, inherits1(Mont1, Red1), Mont1.prototype.convertTo = function(num1) {
                    return this.imod(num1.ushln(this.shift));
                }, Mont1.prototype.convertFrom = function(num1) {
                    var r3 = this.imod(num1.mul(this.rinv));
                    return r3.red = null, r3;
                }, Mont1.prototype.imul = function(a10, b10) {
                    if (a10.isZero() || b10.isZero()) return a10.words[0] = 0, a10.length = 1, a10;
                    var t3 = a10.imul(b10), c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = t3.isub(c5).iushrn(this.shift), res1 = u3;
                    return u3.cmp(this.m) >= 0 ? res1 = u3.isub(this.m) : 0 > u3.cmpn(0) && (res1 = u3.iadd(this.m)), res1._forceRed(this);
                }, Mont1.prototype.mul = function(a10, b10) {
                    if (a10.isZero() || b10.isZero()) return new BN1(0)._forceRed(this);
                    var t3 = a10.mul(b10), c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = t3.isub(c5).iushrn(this.shift), res1 = u3;
                    return u3.cmp(this.m) >= 0 ? res1 = u3.isub(this.m) : 0 > u3.cmpn(0) && (res1 = u3.iadd(this.m)), res1._forceRed(this);
                }, Mont1.prototype.invm = function(a10) {
                    return this.imod(a10._invmp(this.m).mul(this.r2))._forceRed(this);
                };
            }(module1 = __webpack_require__1.nmd(module1), this);
        },
        9931: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var r3;
            function Rand1(rand1) {
                this.rand = rand1;
            }
            if (module1.exports = function(len3) {
                return r3 || (r3 = new Rand1(null)), r3.generate(len3);
            }, module1.exports.Rand = Rand1, Rand1.prototype.generate = function(len3) {
                return this._rand(len3);
            }, Rand1.prototype._rand = function(n2) {
                if (this.rand.getBytes) return this.rand.getBytes(n2);
                for(var res1 = new Uint8Array(n2), i2 = 0; i2 < res1.length; i2++)res1[i2] = this.rand.getByte();
                return res1;
            }, 'object' == typeof self) self.crypto && self.crypto.getRandomValues ? Rand1.prototype._rand = function(n2) {
                var arr1 = new Uint8Array(n2);
                return self.crypto.getRandomValues(arr1), arr1;
            } : self.msCrypto && self.msCrypto.getRandomValues ? Rand1.prototype._rand = function(n2) {
                var arr1 = new Uint8Array(n2);
                return self.msCrypto.getRandomValues(arr1), arr1;
            } : 'object' == typeof window && (Rand1.prototype._rand = function() {
                throw Error('Not implemented yet');
            });
            else try {
                var crypto1 = __webpack_require__1(9214);
                if ('function' != typeof crypto1.randomBytes) throw Error('Not supported');
                Rand1.prototype._rand = function(n2) {
                    return crypto1.randomBytes(n2);
                };
            } catch (e1) {}
        },
        1708: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { AbstractLevel: AbstractLevel1  } = __webpack_require__1(875), ModuleError1 = __webpack_require__1(4473), parallel1 = __webpack_require__1(9967), { fromCallback: fromCallback1  } = __webpack_require__1(6957), { Iterator: Iterator1  } = __webpack_require__1(8212), deserialize1 = __webpack_require__1(9687), clear1 = __webpack_require__1(7753), createKeyRange1 = __webpack_require__1(1217), DEFAULT_PREFIX1 = 'level-js-', kIDB1 = Symbol('idb'), kNamePrefix1 = Symbol('namePrefix'), kLocation1 = Symbol('location'), kVersion1 = Symbol('version'), kStore1 = Symbol('store'), kOnComplete1 = Symbol('onComplete'), kPromise1 = Symbol('promise');
            class BrowserLevel1 extends AbstractLevel1 {
                constructor(location1, options1, _1){
                    if ('function' == typeof options1 || 'function' == typeof _1) throw new ModuleError1('The levelup-style callback argument has been removed', {
                        code: 'LEVEL_LEGACY'
                    });
                    const { prefix: prefix1 , version: version1 , ...forward1 } = options1 || {};
                    if (super({
                        encodings: {
                            view: !0
                        },
                        snapshots: !1,
                        createIfMissing: !1,
                        errorIfExists: !1,
                        seek: !0
                    }, forward1), 'string' != typeof location1) throw Error('constructor requires a location string argument');
                    this[kLocation1] = location1, this[kNamePrefix1] = null == prefix1 ? DEFAULT_PREFIX1 : prefix1, this[kVersion1] = parseInt(version1 || 1, 10), this[kIDB1] = null;
                }
                get location() {
                    return this[kLocation1];
                }
                get namePrefix() {
                    return this[kNamePrefix1];
                }
                get version() {
                    return this[kVersion1];
                }
                get db() {
                    return this[kIDB1];
                }
                get type() {
                    return 'browser-level';
                }
                _open(options1, callback1) {
                    const req1 = indexedDB.open(this[kNamePrefix1] + this[kLocation1], this[kVersion1]);
                    req1.onerror = function() {
                        callback1(req1.error || Error('unknown error'));
                    }, req1.onsuccess = ()=>{
                        this[kIDB1] = req1.result, callback1();
                    }, req1.onupgradeneeded = (ev1)=>{
                        const db1 = ev1.target.result;
                        db1.objectStoreNames.contains(this[kLocation1]) || db1.createObjectStore(this[kLocation1]);
                    };
                }
                [kStore1](mode1) {
                    const transaction1 = this[kIDB1].transaction([
                        this[kLocation1]
                    ], mode1);
                    return transaction1.objectStore(this[kLocation1]);
                }
                [kOnComplete1](request1, callback1) {
                    const transaction1 = request1.transaction;
                    transaction1.onabort = function() {
                        callback1(transaction1.error || Error('aborted by user'));
                    }, transaction1.oncomplete = function() {
                        callback1(null, request1.result);
                    };
                }
                _get(key1, options1, callback1) {
                    let req1;
                    const store1 = this[kStore1]('readonly');
                    try {
                        req1 = store1.get(key1);
                    } catch (err1) {
                        return this.nextTick(callback1, err1);
                    }
                    this[kOnComplete1](req1, function(err1, value1) {
                        return err1 ? callback1(err1) : void 0 === value1 ? callback1(new ModuleError1('Entry not found', {
                            code: 'LEVEL_NOT_FOUND'
                        })) : void callback1(null, deserialize1(value1));
                    });
                }
                _getMany(keys1, options1, callback1) {
                    const store1 = this[kStore1]('readonly'), tasks1 = keys1.map((key1)=>(next1)=>{
                            let request1;
                            try {
                                request1 = store1.get(key1);
                            } catch (err1) {
                                return next1(err1);
                            }
                            request1.onsuccess = ()=>{
                                const value1 = request1.result;
                                next1(null, void 0 === value1 ? value1 : deserialize1(value1));
                            }, request1.onerror = (ev1)=>{
                                ev1.stopPropagation(), next1(request1.error);
                            };
                        });
                    parallel1(tasks1, 16, callback1);
                }
                _del(key1, options1, callback1) {
                    let req1;
                    const store1 = this[kStore1]('readwrite');
                    try {
                        req1 = store1.delete(key1);
                    } catch (err1) {
                        return this.nextTick(callback1, err1);
                    }
                    this[kOnComplete1](req1, callback1);
                }
                _put(key1, value1, options1, callback1) {
                    let req1;
                    const store1 = this[kStore1]('readwrite');
                    try {
                        req1 = store1.put(value1, key1);
                    } catch (err1) {
                        return this.nextTick(callback1, err1);
                    }
                    this[kOnComplete1](req1, callback1);
                }
                _iterator(options1) {
                    return new Iterator1(this, this[kLocation1], options1);
                }
                _batch(operations1, options1, callback1) {
                    let error1;
                    const store1 = this[kStore1]('readwrite'), transaction1 = store1.transaction;
                    let index1 = 0;
                    function loop1() {
                        let req1;
                        const op1 = operations1[index1++], key1 = op1.key;
                        try {
                            req1 = 'del' === op1.type ? store1.delete(key1) : store1.put(op1.value, key1);
                        } catch (err1) {
                            error1 = err1, transaction1.abort();
                            return;
                        }
                        index1 < operations1.length ? req1.onsuccess = loop1 : 'function' == typeof transaction1.commit && transaction1.commit();
                    }
                    transaction1.onabort = function() {
                        callback1(error1 || transaction1.error || Error('aborted by user'));
                    }, transaction1.oncomplete = function() {
                        callback1();
                    }, loop1();
                }
                _clear(options1, callback1) {
                    let keyRange1, req1;
                    try {
                        keyRange1 = createKeyRange1(options1);
                    } catch (e1) {
                        return this.nextTick(callback1);
                    }
                    if (options1.limit >= 0) return clear1(this, this[kLocation1], keyRange1, options1, callback1);
                    try {
                        const store1 = this[kStore1]('readwrite');
                        req1 = keyRange1 ? store1.delete(keyRange1) : store1.clear();
                    } catch (err1) {
                        return this.nextTick(callback1, err1);
                    }
                    this[kOnComplete1](req1, callback1);
                }
                _close(callback1) {
                    this[kIDB1].close(), this.nextTick(callback1);
                }
            }
            BrowserLevel1.destroy = function(location1, prefix1, callback1) {
                'function' == typeof prefix1 && (callback1 = prefix1, prefix1 = DEFAULT_PREFIX1), callback1 = fromCallback1(callback1, kPromise1);
                const request1 = indexedDB.deleteDatabase(prefix1 + location1);
                return request1.onsuccess = function() {
                    callback1();
                }, request1.onerror = function(err1) {
                    callback1(err1);
                }, callback1[kPromise1];
            }, exports1.BrowserLevel = BrowserLevel1;
        },
        8212: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { AbstractIterator: AbstractIterator1  } = __webpack_require__1(875), createKeyRange1 = __webpack_require__1(1217), deserialize1 = __webpack_require__1(9687), kCache1 = Symbol('cache'), kFinished1 = Symbol('finished'), kOptions1 = Symbol('options'), kCurrentOptions1 = Symbol('currentOptions'), kPosition1 = Symbol('position'), kLocation1 = Symbol('location'), kFirst1 = Symbol('first'), emptyOptions1 = {};
            class Iterator1 extends AbstractIterator1 {
                constructor(db1, location1, options1){
                    super(db1, options1), this[kCache1] = [], this[kFinished1] = 0 === this.limit, this[kOptions1] = options1, this[kCurrentOptions1] = {
                        ...options1
                    }, this[kPosition1] = void 0, this[kLocation1] = location1, this[kFirst1] = !0;
                }
                _nextv(size1, options1, callback1) {
                    let keyRange1;
                    if (this[kFirst1] = !1, this[kFinished1]) return this.nextTick(callback1, null, []);
                    if (this[kCache1].length > 0) return size1 = Math.min(size1, this[kCache1].length), this.nextTick(callback1, null, this[kCache1].splice(0, size1));
                    void 0 !== this[kPosition1] && (this[kOptions1].reverse ? (this[kCurrentOptions1].lt = this[kPosition1], this[kCurrentOptions1].lte = void 0) : (this[kCurrentOptions1].gt = this[kPosition1], this[kCurrentOptions1].gte = void 0));
                    try {
                        keyRange1 = createKeyRange1(this[kCurrentOptions1]);
                    } catch (_1) {
                        return this[kFinished1] = !0, this.nextTick(callback1, null, []);
                    }
                    const transaction1 = this.db.db.transaction([
                        this[kLocation1]
                    ], 'readonly'), store1 = transaction1.objectStore(this[kLocation1]), entries1 = [];
                    if (this[kOptions1].reverse) {
                        const method1 = !this[kOptions1].values && store1.openKeyCursor ? 'openKeyCursor' : 'openCursor';
                        store1[method1](keyRange1, 'prev').onsuccess = (ev1)=>{
                            const cursor1 = ev1.target.result;
                            if (cursor1) {
                                const { key: key1 , value: value1  } = cursor1;
                                this[kPosition1] = key1, entries1.push([
                                    this[kOptions1].keys && void 0 !== key1 ? deserialize1(key1) : void 0,
                                    this[kOptions1].values && void 0 !== value1 ? deserialize1(value1) : void 0
                                ]), entries1.length < size1 ? cursor1.continue() : maybeCommit1(transaction1);
                            } else this[kFinished1] = !0;
                        };
                    } else {
                        let keys1, values1;
                        const complete1 = ()=>{
                            if (void 0 === keys1 || void 0 === values1) return;
                            const length1 = Math.max(keys1.length, values1.length);
                            0 === length1 || size1 === 1 / 0 ? this[kFinished1] = !0 : this[kPosition1] = keys1[length1 - 1], entries1.length = length1;
                            for(let i2 = 0; i2 < length1; i2++){
                                const key1 = keys1[i2], value1 = values1[i2];
                                entries1[i2] = [
                                    this[kOptions1].keys && void 0 !== key1 ? deserialize1(key1) : void 0,
                                    this[kOptions1].values && void 0 !== value1 ? deserialize1(value1) : void 0
                                ];
                            }
                            maybeCommit1(transaction1);
                        };
                        this[kOptions1].keys || size1 < 1 / 0 ? store1.getAllKeys(keyRange1, size1 < 1 / 0 ? size1 : void 0).onsuccess = (ev1)=>{
                            keys1 = ev1.target.result, complete1();
                        } : (keys1 = [], this.nextTick(complete1)), this[kOptions1].values ? store1.getAll(keyRange1, size1 < 1 / 0 ? size1 : void 0).onsuccess = (ev1)=>{
                            values1 = ev1.target.result, complete1();
                        } : (values1 = [], this.nextTick(complete1));
                    }
                    transaction1.onabort = ()=>{
                        callback1(transaction1.error || Error('aborted by user')), callback1 = null;
                    }, transaction1.oncomplete = ()=>{
                        callback1(null, entries1), callback1 = null;
                    };
                }
                _next(callback1) {
                    if (this[kCache1].length > 0) {
                        const [key1, value1] = this[kCache1].shift();
                        this.nextTick(callback1, null, key1, value1);
                    } else if (this[kFinished1]) this.nextTick(callback1);
                    else {
                        let size1 = Math.min(100, this.limit - this.count);
                        this[kFirst1] && (this[kFirst1] = !1, size1 = 1), this._nextv(size1, emptyOptions1, (err1, entries1)=>{
                            if (err1) return callback1(err1);
                            this[kCache1] = entries1, this._next(callback1);
                        });
                    }
                }
                _all(options1, callback1) {
                    this[kFirst1] = !1;
                    const cache1 = this[kCache1].splice(0, this[kCache1].length), size1 = this.limit - this.count - cache1.length;
                    if (size1 <= 0) return this.nextTick(callback1, null, cache1);
                    this._nextv(size1, emptyOptions1, (err1, entries1)=>{
                        if (err1) return callback1(err1);
                        cache1.length > 0 && (entries1 = cache1.concat(entries1)), callback1(null, entries1);
                    });
                }
                _seek(target1, options1) {
                    let keyRange1;
                    this[kFirst1] = !0, this[kCache1] = [], this[kFinished1] = !1, this[kPosition1] = void 0, this[kCurrentOptions1] = {
                        ...this[kOptions1]
                    };
                    try {
                        keyRange1 = createKeyRange1(this[kOptions1]);
                    } catch (_1) {
                        this[kFinished1] = !0;
                        return;
                    }
                    null === keyRange1 || keyRange1.includes(target1) ? this[kOptions1].reverse ? this[kCurrentOptions1].lte = target1 : this[kCurrentOptions1].gte = target1 : this[kFinished1] = !0;
                }
            }
            function maybeCommit1(transaction1) {
                'function' == typeof transaction1.commit && transaction1.commit();
            }
            exports1.Iterator = Iterator1;
        },
        7753: function(module1) {
            "use strict";
            module1.exports = function(db1, location1, keyRange1, options1, callback1) {
                if (0 === options1.limit) return db1.nextTick(callback1);
                const transaction1 = db1.db.transaction([
                    location1
                ], 'readwrite'), store1 = transaction1.objectStore(location1);
                let count1 = 0;
                transaction1.oncomplete = function() {
                    callback1();
                }, transaction1.onabort = function() {
                    callback1(transaction1.error || Error('aborted by user'));
                };
                const method1 = store1.openKeyCursor ? 'openKeyCursor' : 'openCursor', direction1 = options1.reverse ? 'prev' : 'next';
                store1[method1](keyRange1, direction1).onsuccess = function(ev1) {
                    const cursor1 = ev1.target.result;
                    cursor1 && (store1.delete(cursor1.key).onsuccess = function() {
                        (options1.limit <= 0 || ++count1 < options1.limit) && cursor1.continue();
                    });
                };
            };
        },
        9687: function(module1) {
            "use strict";
            const textEncoder1 = new TextEncoder();
            module1.exports = function(data1) {
                return data1 instanceof Uint8Array ? data1 : data1 instanceof ArrayBuffer ? new Uint8Array(data1) : textEncoder1.encode(data1);
            };
        },
        1217: function(module1) {
            "use strict";
            module1.exports = function(options1) {
                const lower1 = void 0 !== options1.gte ? options1.gte : void 0 !== options1.gt ? options1.gt : void 0, upper1 = void 0 !== options1.lte ? options1.lte : void 0 !== options1.lt ? options1.lt : void 0, lowerExclusive1 = void 0 === options1.gte, upperExclusive1 = void 0 === options1.lte;
                return void 0 !== lower1 && void 0 !== upper1 ? IDBKeyRange.bound(lower1, upper1, lowerExclusive1, upperExclusive1) : void 0 !== lower1 ? IDBKeyRange.lowerBound(lower1, lowerExclusive1) : void 0 !== upper1 ? IDBKeyRange.upperBound(upper1, upperExclusive1) : null;
            };
        },
        3533: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const Buffer1 = __webpack_require__1(9509).Buffer;
            module1.exports = class {
                constructor(buf1 = Buffer1.from([])){
                    this.buffer = buf1;
                }
                read(num1) {
                    const data1 = this.buffer.subarray(0, num1);
                    return this.buffer = this.buffer.subarray(num1), data1;
                }
                write(buf1) {
                    buf1 = Buffer1.from(buf1), this.buffer = Buffer1.concat([
                        this.buffer,
                        buf1
                    ]);
                }
            };
        },
        8764: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const base641 = __webpack_require__1(9742), ieee7541 = __webpack_require__1(645), customInspectSymbol1 = 'function' == typeof Symbol && 'function' == typeof Symbol.for ? Symbol.for('nodejs.util.inspect.custom') : null;
            exports1.Buffer = Buffer1, exports1.SlowBuffer = SlowBuffer1, exports1.INSPECT_MAX_BYTES = 50;
            const K_MAX_LENGTH1 = 0x7fffffff;
            function typedArraySupport1() {
                try {
                    const arr1 = new Uint8Array(1), proto1 = {
                        foo: function() {
                            return 42;
                        }
                    };
                    return Object.setPrototypeOf(proto1, Uint8Array.prototype), Object.setPrototypeOf(arr1, proto1), 42 === arr1.foo();
                } catch (e1) {
                    return !1;
                }
            }
            function createBuffer1(length1) {
                if (length1 > K_MAX_LENGTH1) throw RangeError('The value "' + length1 + '" is invalid for option "size"');
                const buf1 = new Uint8Array(length1);
                return Object.setPrototypeOf(buf1, Buffer1.prototype), buf1;
            }
            function Buffer1(arg4, encodingOrOffset1, length1) {
                if ('number' == typeof arg4) {
                    if ('string' == typeof encodingOrOffset1) throw TypeError('The "string" argument must be of type string. Received type number');
                    return allocUnsafe1(arg4);
                }
                return from1(arg4, encodingOrOffset1, length1);
            }
            function from1(value1, encodingOrOffset1, length1) {
                if ('string' == typeof value1) return fromString1(value1, encodingOrOffset1);
                if (ArrayBuffer.isView(value1)) return fromArrayView1(value1);
                if (null == value1) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value1);
                if (isInstance1(value1, ArrayBuffer) || value1 && isInstance1(value1.buffer, ArrayBuffer) || 'undefined' != typeof SharedArrayBuffer && (isInstance1(value1, SharedArrayBuffer) || value1 && isInstance1(value1.buffer, SharedArrayBuffer))) return fromArrayBuffer1(value1, encodingOrOffset1, length1);
                if ('number' == typeof value1) throw TypeError('The "value" argument must not be of type number. Received type number');
                const valueOf1 = value1.valueOf && value1.valueOf();
                if (null != valueOf1 && valueOf1 !== value1) return Buffer1.from(valueOf1, encodingOrOffset1, length1);
                const b10 = fromObject1(value1);
                if (b10) return b10;
                if ('undefined' != typeof Symbol && null != Symbol.toPrimitive && 'function' == typeof value1[Symbol.toPrimitive]) return Buffer1.from(value1[Symbol.toPrimitive]('string'), encodingOrOffset1, length1);
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value1);
            }
            function assertSize1(size1) {
                if ('number' != typeof size1) throw TypeError('"size" argument must be of type number');
                if (size1 < 0) throw RangeError('The value "' + size1 + '" is invalid for option "size"');
            }
            function alloc1(size1, fill1, encoding1) {
                return (assertSize1(size1), size1 <= 0) ? createBuffer1(size1) : void 0 !== fill1 ? 'string' == typeof encoding1 ? createBuffer1(size1).fill(fill1, encoding1) : createBuffer1(size1).fill(fill1) : createBuffer1(size1);
            }
            function allocUnsafe1(size1) {
                return assertSize1(size1), createBuffer1(size1 < 0 ? 0 : 0 | checked1(size1));
            }
            function fromString1(string1, encoding1) {
                if (('string' != typeof encoding1 || '' === encoding1) && (encoding1 = 'utf8'), !Buffer1.isEncoding(encoding1)) throw TypeError('Unknown encoding: ' + encoding1);
                const length1 = 0 | byteLength1(string1, encoding1);
                let buf1 = createBuffer1(length1);
                const actual1 = buf1.write(string1, encoding1);
                return actual1 !== length1 && (buf1 = buf1.slice(0, actual1)), buf1;
            }
            function fromArrayLike1(array1) {
                const length1 = array1.length < 0 ? 0 : 0 | checked1(array1.length), buf1 = createBuffer1(length1);
                for(let i2 = 0; i2 < length1; i2 += 1)buf1[i2] = 255 & array1[i2];
                return buf1;
            }
            function fromArrayView1(arrayView1) {
                if (isInstance1(arrayView1, Uint8Array)) {
                    const copy1 = new Uint8Array(arrayView1);
                    return fromArrayBuffer1(copy1.buffer, copy1.byteOffset, copy1.byteLength);
                }
                return fromArrayLike1(arrayView1);
            }
            function fromArrayBuffer1(array1, byteOffset1, length1) {
                let buf1;
                if (byteOffset1 < 0 || array1.byteLength < byteOffset1) throw RangeError('"offset" is outside of buffer bounds');
                if (array1.byteLength < byteOffset1 + (length1 || 0)) throw RangeError('"length" is outside of buffer bounds');
                return Object.setPrototypeOf(buf1 = void 0 === byteOffset1 && void 0 === length1 ? new Uint8Array(array1) : void 0 === length1 ? new Uint8Array(array1, byteOffset1) : new Uint8Array(array1, byteOffset1, length1), Buffer1.prototype), buf1;
            }
            function fromObject1(obj1) {
                if (Buffer1.isBuffer(obj1)) {
                    const len3 = 0 | checked1(obj1.length), buf1 = createBuffer1(len3);
                    return 0 === buf1.length || obj1.copy(buf1, 0, 0, len3), buf1;
                }
                return void 0 !== obj1.length ? 'number' != typeof obj1.length || numberIsNaN1(obj1.length) ? createBuffer1(0) : fromArrayLike1(obj1) : 'Buffer' === obj1.type && Array.isArray(obj1.data) ? fromArrayLike1(obj1.data) : void 0;
            }
            function checked1(length1) {
                if (length1 >= K_MAX_LENGTH1) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH1.toString(16) + ' bytes');
                return 0 | length1;
            }
            function SlowBuffer1(length1) {
                return +length1 != length1 && (length1 = 0), Buffer1.alloc(+length1);
            }
            function byteLength1(string1, encoding1) {
                if (Buffer1.isBuffer(string1)) return string1.length;
                if (ArrayBuffer.isView(string1) || isInstance1(string1, ArrayBuffer)) return string1.byteLength;
                if ('string' != typeof string1) throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string1);
                const len3 = string1.length, mustMatch1 = arguments.length > 2 && !0 === arguments[2];
                if (!mustMatch1 && 0 === len3) return 0;
                let loweredCase1 = !1;
                for(;;)switch(encoding1){
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                        return len3;
                    case 'utf8':
                    case 'utf-8':
                        return utf8ToBytes1(string1).length;
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return 2 * len3;
                    case 'hex':
                        return len3 >>> 1;
                    case 'base64':
                        return base64ToBytes1(string1).length;
                    default:
                        if (loweredCase1) return mustMatch1 ? -1 : utf8ToBytes1(string1).length;
                        encoding1 = ('' + encoding1).toLowerCase(), loweredCase1 = !0;
                }
            }
            function slowToString1(encoding1, start1, end1) {
                let loweredCase1 = !1;
                if ((void 0 === start1 || start1 < 0) && (start1 = 0), start1 > this.length || ((void 0 === end1 || end1 > this.length) && (end1 = this.length), end1 <= 0 || (end1 >>>= 0) <= (start1 >>>= 0))) return '';
                for(encoding1 || (encoding1 = 'utf8');;)switch(encoding1){
                    case 'hex':
                        return hexSlice1(this, start1, end1);
                    case 'utf8':
                    case 'utf-8':
                        return utf8Slice1(this, start1, end1);
                    case 'ascii':
                        return asciiSlice1(this, start1, end1);
                    case 'latin1':
                    case 'binary':
                        return latin1Slice1(this, start1, end1);
                    case 'base64':
                        return base64Slice1(this, start1, end1);
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return utf16leSlice1(this, start1, end1);
                    default:
                        if (loweredCase1) throw TypeError('Unknown encoding: ' + encoding1);
                        encoding1 = (encoding1 + '').toLowerCase(), loweredCase1 = !0;
                }
            }
            function swap1(b10, n2, m1) {
                const i2 = b10[n2];
                b10[n2] = b10[m1], b10[m1] = i2;
            }
            function bidirectionalIndexOf1(buffer1, val1, byteOffset1, encoding1, dir1) {
                if (0 === buffer1.length) return -1;
                if ('string' == typeof byteOffset1 ? (encoding1 = byteOffset1, byteOffset1 = 0) : byteOffset1 > 0x7fffffff ? byteOffset1 = 0x7fffffff : byteOffset1 < -2147483648 && (byteOffset1 = -2147483648), numberIsNaN1(byteOffset1 = +byteOffset1) && (byteOffset1 = dir1 ? 0 : buffer1.length - 1), byteOffset1 < 0 && (byteOffset1 = buffer1.length + byteOffset1), byteOffset1 >= buffer1.length) {
                    if (dir1) return -1;
                    byteOffset1 = buffer1.length - 1;
                } else if (byteOffset1 < 0) {
                    if (!dir1) return -1;
                    byteOffset1 = 0;
                }
                if ('string' == typeof val1 && (val1 = Buffer1.from(val1, encoding1)), Buffer1.isBuffer(val1)) return 0 === val1.length ? -1 : arrayIndexOf1(buffer1, val1, byteOffset1, encoding1, dir1);
                if ('number' == typeof val1) return (val1 &= 0xFF, 'function' == typeof Uint8Array.prototype.indexOf) ? dir1 ? Uint8Array.prototype.indexOf.call(buffer1, val1, byteOffset1) : Uint8Array.prototype.lastIndexOf.call(buffer1, val1, byteOffset1) : arrayIndexOf1(buffer1, [
                    val1
                ], byteOffset1, encoding1, dir1);
                throw TypeError('val must be string, number or Buffer');
            }
            function arrayIndexOf1(arr1, val1, byteOffset1, encoding1, dir1) {
                let i2, indexSize1 = 1, arrLength1 = arr1.length, valLength1 = val1.length;
                if (void 0 !== encoding1 && ('ucs2' === (encoding1 = String(encoding1).toLowerCase()) || 'ucs-2' === encoding1 || 'utf16le' === encoding1 || 'utf-16le' === encoding1)) {
                    if (arr1.length < 2 || val1.length < 2) return -1;
                    indexSize1 = 2, arrLength1 /= 2, valLength1 /= 2, byteOffset1 /= 2;
                }
                function read1(buf1, i2) {
                    return 1 === indexSize1 ? buf1[i2] : buf1.readUInt16BE(i2 * indexSize1);
                }
                if (dir1) {
                    let foundIndex1 = -1;
                    for(i2 = byteOffset1; i2 < arrLength1; i2++)if (read1(arr1, i2) === read1(val1, -1 === foundIndex1 ? 0 : i2 - foundIndex1)) {
                        if (-1 === foundIndex1 && (foundIndex1 = i2), i2 - foundIndex1 + 1 === valLength1) return foundIndex1 * indexSize1;
                    } else -1 !== foundIndex1 && (i2 -= i2 - foundIndex1), foundIndex1 = -1;
                } else for(byteOffset1 + valLength1 > arrLength1 && (byteOffset1 = arrLength1 - valLength1), i2 = byteOffset1; i2 >= 0; i2--){
                    let found1 = !0;
                    for(let j1 = 0; j1 < valLength1; j1++)if (read1(arr1, i2 + j1) !== read1(val1, j1)) {
                        found1 = !1;
                        break;
                    }
                    if (found1) return i2;
                }
                return -1;
            }
            function hexWrite1(buf1, string1, offset1, length1) {
                let i2;
                offset1 = Number(offset1) || 0;
                const remaining1 = buf1.length - offset1;
                length1 ? (length1 = Number(length1)) > remaining1 && (length1 = remaining1) : length1 = remaining1;
                const strLen1 = string1.length;
                for(length1 > strLen1 / 2 && (length1 = strLen1 / 2), i2 = 0; i2 < length1; ++i2){
                    const parsed1 = parseInt(string1.substr(2 * i2, 2), 16);
                    if (numberIsNaN1(parsed1)) break;
                    buf1[offset1 + i2] = parsed1;
                }
                return i2;
            }
            function utf8Write1(buf1, string1, offset1, length1) {
                return blitBuffer1(utf8ToBytes1(string1, buf1.length - offset1), buf1, offset1, length1);
            }
            function asciiWrite1(buf1, string1, offset1, length1) {
                return blitBuffer1(asciiToBytes1(string1), buf1, offset1, length1);
            }
            function base64Write1(buf1, string1, offset1, length1) {
                return blitBuffer1(base64ToBytes1(string1), buf1, offset1, length1);
            }
            function ucs2Write1(buf1, string1, offset1, length1) {
                return blitBuffer1(utf16leToBytes1(string1, buf1.length - offset1), buf1, offset1, length1);
            }
            function base64Slice1(buf1, start1, end1) {
                return 0 === start1 && end1 === buf1.length ? base641.fromByteArray(buf1) : base641.fromByteArray(buf1.slice(start1, end1));
            }
            function utf8Slice1(buf1, start1, end1) {
                end1 = Math.min(buf1.length, end1);
                const res1 = [];
                let i2 = start1;
                for(; i2 < end1;){
                    const firstByte1 = buf1[i2];
                    let codePoint1 = null, bytesPerSequence1 = firstByte1 > 0xEF ? 4 : firstByte1 > 0xDF ? 3 : firstByte1 > 0xBF ? 2 : 1;
                    if (i2 + bytesPerSequence1 <= end1) {
                        let secondByte1, thirdByte1, fourthByte1, tempCodePoint1;
                        switch(bytesPerSequence1){
                            case 1:
                                firstByte1 < 0x80 && (codePoint1 = firstByte1);
                                break;
                            case 2:
                                (0xC0 & (secondByte1 = buf1[i2 + 1])) == 0x80 && (tempCodePoint1 = (0x1F & firstByte1) << 0x6 | 0x3F & secondByte1) > 0x7F && (codePoint1 = tempCodePoint1);
                                break;
                            case 3:
                                secondByte1 = buf1[i2 + 1], thirdByte1 = buf1[i2 + 2], (0xC0 & secondByte1) == 0x80 && (0xC0 & thirdByte1) == 0x80 && (tempCodePoint1 = (0xF & firstByte1) << 0xC | (0x3F & secondByte1) << 0x6 | 0x3F & thirdByte1) > 0x7FF && (tempCodePoint1 < 0xD800 || tempCodePoint1 > 0xDFFF) && (codePoint1 = tempCodePoint1);
                                break;
                            case 4:
                                secondByte1 = buf1[i2 + 1], thirdByte1 = buf1[i2 + 2], fourthByte1 = buf1[i2 + 3], (0xC0 & secondByte1) == 0x80 && (0xC0 & thirdByte1) == 0x80 && (0xC0 & fourthByte1) == 0x80 && (tempCodePoint1 = (0xF & firstByte1) << 0x12 | (0x3F & secondByte1) << 0xC | (0x3F & thirdByte1) << 0x6 | 0x3F & fourthByte1) > 0xFFFF && tempCodePoint1 < 0x110000 && (codePoint1 = tempCodePoint1);
                        }
                    }
                    null === codePoint1 ? (codePoint1 = 0xFFFD, bytesPerSequence1 = 1) : codePoint1 > 0xFFFF && (codePoint1 -= 0x10000, res1.push(codePoint1 >>> 10 & 0x3FF | 0xD800), codePoint1 = 0xDC00 | 0x3FF & codePoint1), res1.push(codePoint1), i2 += bytesPerSequence1;
                }
                return decodeCodePointsArray1(res1);
            }
            exports1.kMaxLength = K_MAX_LENGTH1, Buffer1.TYPED_ARRAY_SUPPORT = typedArraySupport1(), Buffer1.TYPED_ARRAY_SUPPORT || 'undefined' == typeof console || 'function' != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer1.prototype, 'parent', {
                enumerable: !0,
                get: function() {
                    if (Buffer1.isBuffer(this)) return this.buffer;
                }
            }), Object.defineProperty(Buffer1.prototype, 'offset', {
                enumerable: !0,
                get: function() {
                    if (Buffer1.isBuffer(this)) return this.byteOffset;
                }
            }), Buffer1.poolSize = 8192, Buffer1.from = function(value1, encodingOrOffset1, length1) {
                return from1(value1, encodingOrOffset1, length1);
            }, Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer1, Uint8Array), Buffer1.alloc = function(size1, fill1, encoding1) {
                return alloc1(size1, fill1, encoding1);
            }, Buffer1.allocUnsafe = function(size1) {
                return allocUnsafe1(size1);
            }, Buffer1.allocUnsafeSlow = function(size1) {
                return allocUnsafe1(size1);
            }, Buffer1.isBuffer = function(b10) {
                return null != b10 && !0 === b10._isBuffer && b10 !== Buffer1.prototype;
            }, Buffer1.compare = function(a10, b10) {
                if (isInstance1(a10, Uint8Array) && (a10 = Buffer1.from(a10, a10.offset, a10.byteLength)), isInstance1(b10, Uint8Array) && (b10 = Buffer1.from(b10, b10.offset, b10.byteLength)), !Buffer1.isBuffer(a10) || !Buffer1.isBuffer(b10)) throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (a10 === b10) return 0;
                let x3 = a10.length, y3 = b10.length;
                for(let i2 = 0, len3 = Math.min(x3, y3); i2 < len3; ++i2)if (a10[i2] !== b10[i2]) {
                    x3 = a10[i2], y3 = b10[i2];
                    break;
                }
                return x3 < y3 ? -1 : y3 < x3 ? 1 : 0;
            }, Buffer1.isEncoding = function(encoding1) {
                switch(String(encoding1).toLowerCase()){
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return !0;
                    default:
                        return !1;
                }
            }, Buffer1.concat = function(list1, length1) {
                let i2;
                if (!Array.isArray(list1)) throw TypeError('"list" argument must be an Array of Buffers');
                if (0 === list1.length) return Buffer1.alloc(0);
                if (void 0 === length1) for(i2 = 0, length1 = 0; i2 < list1.length; ++i2)length1 += list1[i2].length;
                const buffer1 = Buffer1.allocUnsafe(length1);
                let pos1 = 0;
                for(i2 = 0; i2 < list1.length; ++i2){
                    let buf1 = list1[i2];
                    if (isInstance1(buf1, Uint8Array)) pos1 + buf1.length > buffer1.length ? (Buffer1.isBuffer(buf1) || (buf1 = Buffer1.from(buf1)), buf1.copy(buffer1, pos1)) : Uint8Array.prototype.set.call(buffer1, buf1, pos1);
                    else if (Buffer1.isBuffer(buf1)) buf1.copy(buffer1, pos1);
                    else throw TypeError('"list" argument must be an Array of Buffers');
                    pos1 += buf1.length;
                }
                return buffer1;
            }, Buffer1.byteLength = byteLength1, Buffer1.prototype._isBuffer = !0, Buffer1.prototype.swap16 = function() {
                const len3 = this.length;
                if (len3 % 2 != 0) throw RangeError('Buffer size must be a multiple of 16-bits');
                for(let i2 = 0; i2 < len3; i2 += 2)swap1(this, i2, i2 + 1);
                return this;
            }, Buffer1.prototype.swap32 = function() {
                const len3 = this.length;
                if (len3 % 4 != 0) throw RangeError('Buffer size must be a multiple of 32-bits');
                for(let i2 = 0; i2 < len3; i2 += 4)swap1(this, i2, i2 + 3), swap1(this, i2 + 1, i2 + 2);
                return this;
            }, Buffer1.prototype.swap64 = function() {
                const len3 = this.length;
                if (len3 % 8 != 0) throw RangeError('Buffer size must be a multiple of 64-bits');
                for(let i2 = 0; i2 < len3; i2 += 8)swap1(this, i2, i2 + 7), swap1(this, i2 + 1, i2 + 6), swap1(this, i2 + 2, i2 + 5), swap1(this, i2 + 3, i2 + 4);
                return this;
            }, Buffer1.prototype.toString = function() {
                const length1 = this.length;
                return 0 === length1 ? '' : 0 == arguments.length ? utf8Slice1(this, 0, length1) : slowToString1.apply(this, arguments);
            }, Buffer1.prototype.toLocaleString = Buffer1.prototype.toString, Buffer1.prototype.equals = function(b10) {
                if (!Buffer1.isBuffer(b10)) throw TypeError('Argument must be a Buffer');
                return this === b10 || 0 === Buffer1.compare(this, b10);
            }, Buffer1.prototype.inspect = function() {
                let str1 = '';
                const max1 = exports1.INSPECT_MAX_BYTES;
                return str1 = this.toString('hex', 0, max1).replace(/(.{2})/g, '$1 ').trim(), this.length > max1 && (str1 += ' ... '), '<Buffer ' + str1 + '>';
            }, customInspectSymbol1 && (Buffer1.prototype[customInspectSymbol1] = Buffer1.prototype.inspect), Buffer1.prototype.compare = function(target1, start1, end1, thisStart1, thisEnd1) {
                if (isInstance1(target1, Uint8Array) && (target1 = Buffer1.from(target1, target1.offset, target1.byteLength)), !Buffer1.isBuffer(target1)) throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target1);
                if (void 0 === start1 && (start1 = 0), void 0 === end1 && (end1 = target1 ? target1.length : 0), void 0 === thisStart1 && (thisStart1 = 0), void 0 === thisEnd1 && (thisEnd1 = this.length), start1 < 0 || end1 > target1.length || thisStart1 < 0 || thisEnd1 > this.length) throw RangeError('out of range index');
                if (thisStart1 >= thisEnd1 && start1 >= end1) return 0;
                if (thisStart1 >= thisEnd1) return -1;
                if (start1 >= end1) return 1;
                if (start1 >>>= 0, end1 >>>= 0, thisStart1 >>>= 0, thisEnd1 >>>= 0, this === target1) return 0;
                let x3 = thisEnd1 - thisStart1, y3 = end1 - start1;
                const len3 = Math.min(x3, y3), thisCopy1 = this.slice(thisStart1, thisEnd1), targetCopy1 = target1.slice(start1, end1);
                for(let i2 = 0; i2 < len3; ++i2)if (thisCopy1[i2] !== targetCopy1[i2]) {
                    x3 = thisCopy1[i2], y3 = targetCopy1[i2];
                    break;
                }
                return x3 < y3 ? -1 : y3 < x3 ? 1 : 0;
            }, Buffer1.prototype.includes = function(val1, byteOffset1, encoding1) {
                return -1 !== this.indexOf(val1, byteOffset1, encoding1);
            }, Buffer1.prototype.indexOf = function(val1, byteOffset1, encoding1) {
                return bidirectionalIndexOf1(this, val1, byteOffset1, encoding1, !0);
            }, Buffer1.prototype.lastIndexOf = function(val1, byteOffset1, encoding1) {
                return bidirectionalIndexOf1(this, val1, byteOffset1, encoding1, !1);
            }, Buffer1.prototype.write = function(string1, offset1, length1, encoding1) {
                if (void 0 === offset1) encoding1 = 'utf8', length1 = this.length, offset1 = 0;
                else if (void 0 === length1 && 'string' == typeof offset1) encoding1 = offset1, length1 = this.length, offset1 = 0;
                else if (isFinite(offset1)) offset1 >>>= 0, isFinite(length1) ? (length1 >>>= 0, void 0 === encoding1 && (encoding1 = 'utf8')) : (encoding1 = length1, length1 = void 0);
                else throw Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
                const remaining1 = this.length - offset1;
                if ((void 0 === length1 || length1 > remaining1) && (length1 = remaining1), string1.length > 0 && (length1 < 0 || offset1 < 0) || offset1 > this.length) throw RangeError('Attempt to write outside buffer bounds');
                encoding1 || (encoding1 = 'utf8');
                let loweredCase1 = !1;
                for(;;)switch(encoding1){
                    case 'hex':
                        return hexWrite1(this, string1, offset1, length1);
                    case 'utf8':
                    case 'utf-8':
                        return utf8Write1(this, string1, offset1, length1);
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                        return asciiWrite1(this, string1, offset1, length1);
                    case 'base64':
                        return base64Write1(this, string1, offset1, length1);
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return ucs2Write1(this, string1, offset1, length1);
                    default:
                        if (loweredCase1) throw TypeError('Unknown encoding: ' + encoding1);
                        encoding1 = ('' + encoding1).toLowerCase(), loweredCase1 = !0;
                }
            }, Buffer1.prototype.toJSON = function() {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            const MAX_ARGUMENTS_LENGTH1 = 0x1000;
            function decodeCodePointsArray1(codePoints1) {
                const len3 = codePoints1.length;
                if (len3 <= MAX_ARGUMENTS_LENGTH1) return String.fromCharCode.apply(String, codePoints1);
                let res1 = '', i2 = 0;
                for(; i2 < len3;)res1 += String.fromCharCode.apply(String, codePoints1.slice(i2, i2 += MAX_ARGUMENTS_LENGTH1));
                return res1;
            }
            function asciiSlice1(buf1, start1, end1) {
                let ret1 = '';
                end1 = Math.min(buf1.length, end1);
                for(let i2 = start1; i2 < end1; ++i2)ret1 += String.fromCharCode(0x7F & buf1[i2]);
                return ret1;
            }
            function latin1Slice1(buf1, start1, end1) {
                let ret1 = '';
                end1 = Math.min(buf1.length, end1);
                for(let i2 = start1; i2 < end1; ++i2)ret1 += String.fromCharCode(buf1[i2]);
                return ret1;
            }
            function hexSlice1(buf1, start1, end1) {
                const len3 = buf1.length;
                (!start1 || start1 < 0) && (start1 = 0), (!end1 || end1 < 0 || end1 > len3) && (end1 = len3);
                let out1 = '';
                for(let i2 = start1; i2 < end1; ++i2)out1 += hexSliceLookupTable1[buf1[i2]];
                return out1;
            }
            function utf16leSlice1(buf1, start1, end1) {
                const bytes1 = buf1.slice(start1, end1);
                let res1 = '';
                for(let i2 = 0; i2 < bytes1.length - 1; i2 += 2)res1 += String.fromCharCode(bytes1[i2] + 256 * bytes1[i2 + 1]);
                return res1;
            }
            function checkOffset1(offset1, ext1, length1) {
                if (offset1 % 1 != 0 || offset1 < 0) throw RangeError('offset is not uint');
                if (offset1 + ext1 > length1) throw RangeError('Trying to access beyond buffer length');
            }
            function checkInt1(buf1, value1, offset1, ext1, max1, min1) {
                if (!Buffer1.isBuffer(buf1)) throw TypeError('"buffer" argument must be a Buffer instance');
                if (value1 > max1 || value1 < min1) throw RangeError('"value" argument is out of bounds');
                if (offset1 + ext1 > buf1.length) throw RangeError('Index out of range');
            }
            function wrtBigUInt64LE1(buf1, value1, offset1, min1, max1) {
                checkIntBI1(value1, min1, max1, buf1, offset1, 7);
                let lo1 = Number(value1 & BigInt(0xffffffff));
                buf1[offset1++] = lo1, lo1 >>= 8, buf1[offset1++] = lo1, lo1 >>= 8, buf1[offset1++] = lo1, lo1 >>= 8, buf1[offset1++] = lo1;
                let hi1 = Number(value1 >> BigInt(32) & BigInt(0xffffffff));
                return buf1[offset1++] = hi1, hi1 >>= 8, buf1[offset1++] = hi1, hi1 >>= 8, buf1[offset1++] = hi1, hi1 >>= 8, buf1[offset1++] = hi1, offset1;
            }
            function wrtBigUInt64BE1(buf1, value1, offset1, min1, max1) {
                checkIntBI1(value1, min1, max1, buf1, offset1, 7);
                let lo1 = Number(value1 & BigInt(0xffffffff));
                buf1[offset1 + 7] = lo1, lo1 >>= 8, buf1[offset1 + 6] = lo1, lo1 >>= 8, buf1[offset1 + 5] = lo1, lo1 >>= 8, buf1[offset1 + 4] = lo1;
                let hi1 = Number(value1 >> BigInt(32) & BigInt(0xffffffff));
                return buf1[offset1 + 3] = hi1, hi1 >>= 8, buf1[offset1 + 2] = hi1, hi1 >>= 8, buf1[offset1 + 1] = hi1, hi1 >>= 8, buf1[offset1] = hi1, offset1 + 8;
            }
            function checkIEEE7541(buf1, value1, offset1, ext1, max1, min1) {
                if (offset1 + ext1 > buf1.length || offset1 < 0) throw RangeError('Index out of range');
            }
            function writeFloat1(buf1, value1, offset1, littleEndian1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkIEEE7541(buf1, value1, offset1, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000), ieee7541.write(buf1, value1, offset1, littleEndian1, 23, 4), offset1 + 4;
            }
            function writeDouble1(buf1, value1, offset1, littleEndian1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkIEEE7541(buf1, value1, offset1, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), ieee7541.write(buf1, value1, offset1, littleEndian1, 52, 8), offset1 + 8;
            }
            Buffer1.prototype.slice = function(start1, end1) {
                const len3 = this.length;
                start1 = ~~start1, end1 = void 0 === end1 ? len3 : ~~end1, start1 < 0 ? (start1 += len3) < 0 && (start1 = 0) : start1 > len3 && (start1 = len3), end1 < 0 ? (end1 += len3) < 0 && (end1 = 0) : end1 > len3 && (end1 = len3), end1 < start1 && (end1 = start1);
                const newBuf1 = this.subarray(start1, end1);
                return Object.setPrototypeOf(newBuf1, Buffer1.prototype), newBuf1;
            }, Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function(offset1, byteLength1, noAssert1) {
                offset1 >>>= 0, byteLength1 >>>= 0, noAssert1 || checkOffset1(offset1, byteLength1, this.length);
                let val1 = this[offset1], mul1 = 1, i2 = 0;
                for(; ++i2 < byteLength1 && (mul1 *= 0x100);)val1 += this[offset1 + i2] * mul1;
                return val1;
            }, Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function(offset1, byteLength1, noAssert1) {
                offset1 >>>= 0, byteLength1 >>>= 0, noAssert1 || checkOffset1(offset1, byteLength1, this.length);
                let val1 = this[offset1 + --byteLength1], mul1 = 1;
                for(; byteLength1 > 0 && (mul1 *= 0x100);)val1 += this[offset1 + --byteLength1] * mul1;
                return val1;
            }, Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 1, this.length), this[offset1];
            }, Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 2, this.length), this[offset1] | this[offset1 + 1] << 8;
            }, Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 2, this.length), this[offset1] << 8 | this[offset1 + 1];
            }, Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 4, this.length), (this[offset1] | this[offset1 + 1] << 8 | this[offset1 + 2] << 16) + 0x1000000 * this[offset1 + 3];
            }, Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 4, this.length), 0x1000000 * this[offset1] + (this[offset1 + 1] << 16 | this[offset1 + 2] << 8 | this[offset1 + 3]);
            }, Buffer1.prototype.readBigUInt64LE = defineBigIntMethod1(function(offset1) {
                validateNumber1(offset1 >>>= 0, 'offset');
                const first1 = this[offset1], last1 = this[offset1 + 7];
                (void 0 === first1 || void 0 === last1) && boundsError1(offset1, this.length - 8);
                const lo1 = first1 + 256 * this[++offset1] + 65536 * this[++offset1] + 16777216 * this[++offset1], hi1 = this[++offset1] + 256 * this[++offset1] + 65536 * this[++offset1] + 16777216 * last1;
                return BigInt(lo1) + (BigInt(hi1) << BigInt(32));
            }), Buffer1.prototype.readBigUInt64BE = defineBigIntMethod1(function(offset1) {
                validateNumber1(offset1 >>>= 0, 'offset');
                const first1 = this[offset1], last1 = this[offset1 + 7];
                (void 0 === first1 || void 0 === last1) && boundsError1(offset1, this.length - 8);
                const hi1 = 16777216 * first1 + 65536 * this[++offset1] + 256 * this[++offset1] + this[++offset1], lo1 = 16777216 * this[++offset1] + 65536 * this[++offset1] + 256 * this[++offset1] + last1;
                return (BigInt(hi1) << BigInt(32)) + BigInt(lo1);
            }), Buffer1.prototype.readIntLE = function(offset1, byteLength1, noAssert1) {
                offset1 >>>= 0, byteLength1 >>>= 0, noAssert1 || checkOffset1(offset1, byteLength1, this.length);
                let val1 = this[offset1], mul1 = 1, i2 = 0;
                for(; ++i2 < byteLength1 && (mul1 *= 0x100);)val1 += this[offset1 + i2] * mul1;
                return val1 >= (mul1 *= 0x80) && (val1 -= Math.pow(2, 8 * byteLength1)), val1;
            }, Buffer1.prototype.readIntBE = function(offset1, byteLength1, noAssert1) {
                offset1 >>>= 0, byteLength1 >>>= 0, noAssert1 || checkOffset1(offset1, byteLength1, this.length);
                let i2 = byteLength1, mul1 = 1, val1 = this[offset1 + --i2];
                for(; i2 > 0 && (mul1 *= 0x100);)val1 += this[offset1 + --i2] * mul1;
                return val1 >= (mul1 *= 0x80) && (val1 -= Math.pow(2, 8 * byteLength1)), val1;
            }, Buffer1.prototype.readInt8 = function(offset1, noAssert1) {
                return (offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 1, this.length), 0x80 & this[offset1]) ? -((0xff - this[offset1] + 1) * 1) : this[offset1];
            }, Buffer1.prototype.readInt16LE = function(offset1, noAssert1) {
                offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 2, this.length);
                const val1 = this[offset1] | this[offset1 + 1] << 8;
                return 0x8000 & val1 ? 0xFFFF0000 | val1 : val1;
            }, Buffer1.prototype.readInt16BE = function(offset1, noAssert1) {
                offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 2, this.length);
                const val1 = this[offset1 + 1] | this[offset1] << 8;
                return 0x8000 & val1 ? 0xFFFF0000 | val1 : val1;
            }, Buffer1.prototype.readInt32LE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 4, this.length), this[offset1] | this[offset1 + 1] << 8 | this[offset1 + 2] << 16 | this[offset1 + 3] << 24;
            }, Buffer1.prototype.readInt32BE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 4, this.length), this[offset1] << 24 | this[offset1 + 1] << 16 | this[offset1 + 2] << 8 | this[offset1 + 3];
            }, Buffer1.prototype.readBigInt64LE = defineBigIntMethod1(function(offset1) {
                validateNumber1(offset1 >>>= 0, 'offset');
                const first1 = this[offset1], last1 = this[offset1 + 7];
                (void 0 === first1 || void 0 === last1) && boundsError1(offset1, this.length - 8);
                const val1 = this[offset1 + 4] + 256 * this[offset1 + 5] + 65536 * this[offset1 + 6] + (last1 << 24);
                return (BigInt(val1) << BigInt(32)) + BigInt(first1 + 256 * this[++offset1] + 65536 * this[++offset1] + 16777216 * this[++offset1]);
            }), Buffer1.prototype.readBigInt64BE = defineBigIntMethod1(function(offset1) {
                validateNumber1(offset1 >>>= 0, 'offset');
                const first1 = this[offset1], last1 = this[offset1 + 7];
                (void 0 === first1 || void 0 === last1) && boundsError1(offset1, this.length - 8);
                const val1 = (first1 << 24) + 65536 * this[++offset1] + 256 * this[++offset1] + this[++offset1];
                return (BigInt(val1) << BigInt(32)) + BigInt(16777216 * this[++offset1] + 65536 * this[++offset1] + 256 * this[++offset1] + last1);
            }), Buffer1.prototype.readFloatLE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 4, this.length), ieee7541.read(this, offset1, !0, 23, 4);
            }, Buffer1.prototype.readFloatBE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 4, this.length), ieee7541.read(this, offset1, !1, 23, 4);
            }, Buffer1.prototype.readDoubleLE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 8, this.length), ieee7541.read(this, offset1, !0, 52, 8);
            }, Buffer1.prototype.readDoubleBE = function(offset1, noAssert1) {
                return offset1 >>>= 0, noAssert1 || checkOffset1(offset1, 8, this.length), ieee7541.read(this, offset1, !1, 52, 8);
            }, Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function(value1, offset1, byteLength1, noAssert1) {
                if (value1 = +value1, offset1 >>>= 0, byteLength1 >>>= 0, !noAssert1) {
                    const maxBytes1 = Math.pow(2, 8 * byteLength1) - 1;
                    checkInt1(this, value1, offset1, byteLength1, maxBytes1, 0);
                }
                let mul1 = 1, i2 = 0;
                for(this[offset1] = 0xFF & value1; ++i2 < byteLength1 && (mul1 *= 0x100);)this[offset1 + i2] = value1 / mul1 & 0xFF;
                return offset1 + byteLength1;
            }, Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function(value1, offset1, byteLength1, noAssert1) {
                if (value1 = +value1, offset1 >>>= 0, byteLength1 >>>= 0, !noAssert1) {
                    const maxBytes1 = Math.pow(2, 8 * byteLength1) - 1;
                    checkInt1(this, value1, offset1, byteLength1, maxBytes1, 0);
                }
                let i2 = byteLength1 - 1, mul1 = 1;
                for(this[offset1 + i2] = 0xFF & value1; --i2 >= 0 && (mul1 *= 0x100);)this[offset1 + i2] = value1 / mul1 & 0xFF;
                return offset1 + byteLength1;
            }, Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 1, 0xff, 0), this[offset1] = 0xff & value1, offset1 + 1;
            }, Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 2, 0xffff, 0), this[offset1] = 0xff & value1, this[offset1 + 1] = value1 >>> 8, offset1 + 2;
            }, Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 2, 0xffff, 0), this[offset1] = value1 >>> 8, this[offset1 + 1] = 0xff & value1, offset1 + 2;
            }, Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 4, 0xffffffff, 0), this[offset1 + 3] = value1 >>> 24, this[offset1 + 2] = value1 >>> 16, this[offset1 + 1] = value1 >>> 8, this[offset1] = 0xff & value1, offset1 + 4;
            }, Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 4, 0xffffffff, 0), this[offset1] = value1 >>> 24, this[offset1 + 1] = value1 >>> 16, this[offset1 + 2] = value1 >>> 8, this[offset1 + 3] = 0xff & value1, offset1 + 4;
            }, Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod1(function(value1, offset1 = 0) {
                return wrtBigUInt64LE1(this, value1, offset1, BigInt(0), BigInt('0xffffffffffffffff'));
            }), Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod1(function(value1, offset1 = 0) {
                return wrtBigUInt64BE1(this, value1, offset1, BigInt(0), BigInt('0xffffffffffffffff'));
            }), Buffer1.prototype.writeIntLE = function(value1, offset1, byteLength1, noAssert1) {
                if (value1 = +value1, offset1 >>>= 0, !noAssert1) {
                    const limit1 = Math.pow(2, 8 * byteLength1 - 1);
                    checkInt1(this, value1, offset1, byteLength1, limit1 - 1, -limit1);
                }
                let i2 = 0, mul1 = 1, sub1 = 0;
                for(this[offset1] = 0xFF & value1; ++i2 < byteLength1 && (mul1 *= 0x100);)value1 < 0 && 0 === sub1 && 0 !== this[offset1 + i2 - 1] && (sub1 = 1), this[offset1 + i2] = (value1 / mul1 >> 0) - sub1 & 0xFF;
                return offset1 + byteLength1;
            }, Buffer1.prototype.writeIntBE = function(value1, offset1, byteLength1, noAssert1) {
                if (value1 = +value1, offset1 >>>= 0, !noAssert1) {
                    const limit1 = Math.pow(2, 8 * byteLength1 - 1);
                    checkInt1(this, value1, offset1, byteLength1, limit1 - 1, -limit1);
                }
                let i2 = byteLength1 - 1, mul1 = 1, sub1 = 0;
                for(this[offset1 + i2] = 0xFF & value1; --i2 >= 0 && (mul1 *= 0x100);)value1 < 0 && 0 === sub1 && 0 !== this[offset1 + i2 + 1] && (sub1 = 1), this[offset1 + i2] = (value1 / mul1 >> 0) - sub1 & 0xFF;
                return offset1 + byteLength1;
            }, Buffer1.prototype.writeInt8 = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 1, 0x7f, -128), value1 < 0 && (value1 = 0xff + value1 + 1), this[offset1] = 0xff & value1, offset1 + 1;
            }, Buffer1.prototype.writeInt16LE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 2, 0x7fff, -32768), this[offset1] = 0xff & value1, this[offset1 + 1] = value1 >>> 8, offset1 + 2;
            }, Buffer1.prototype.writeInt16BE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 2, 0x7fff, -32768), this[offset1] = value1 >>> 8, this[offset1 + 1] = 0xff & value1, offset1 + 2;
            }, Buffer1.prototype.writeInt32LE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 4, 0x7fffffff, -2147483648), this[offset1] = 0xff & value1, this[offset1 + 1] = value1 >>> 8, this[offset1 + 2] = value1 >>> 16, this[offset1 + 3] = value1 >>> 24, offset1 + 4;
            }, Buffer1.prototype.writeInt32BE = function(value1, offset1, noAssert1) {
                return value1 = +value1, offset1 >>>= 0, noAssert1 || checkInt1(this, value1, offset1, 4, 0x7fffffff, -2147483648), value1 < 0 && (value1 = 0xffffffff + value1 + 1), this[offset1] = value1 >>> 24, this[offset1 + 1] = value1 >>> 16, this[offset1 + 2] = value1 >>> 8, this[offset1 + 3] = 0xff & value1, offset1 + 4;
            }, Buffer1.prototype.writeBigInt64LE = defineBigIntMethod1(function(value1, offset1 = 0) {
                return wrtBigUInt64LE1(this, value1, offset1, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
            }), Buffer1.prototype.writeBigInt64BE = defineBigIntMethod1(function(value1, offset1 = 0) {
                return wrtBigUInt64BE1(this, value1, offset1, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
            }), Buffer1.prototype.writeFloatLE = function(value1, offset1, noAssert1) {
                return writeFloat1(this, value1, offset1, !0, noAssert1);
            }, Buffer1.prototype.writeFloatBE = function(value1, offset1, noAssert1) {
                return writeFloat1(this, value1, offset1, !1, noAssert1);
            }, Buffer1.prototype.writeDoubleLE = function(value1, offset1, noAssert1) {
                return writeDouble1(this, value1, offset1, !0, noAssert1);
            }, Buffer1.prototype.writeDoubleBE = function(value1, offset1, noAssert1) {
                return writeDouble1(this, value1, offset1, !1, noAssert1);
            }, Buffer1.prototype.copy = function(target1, targetStart1, start1, end1) {
                if (!Buffer1.isBuffer(target1)) throw TypeError('argument should be a Buffer');
                if (start1 || (start1 = 0), end1 || 0 === end1 || (end1 = this.length), targetStart1 >= target1.length && (targetStart1 = target1.length), targetStart1 || (targetStart1 = 0), end1 > 0 && end1 < start1 && (end1 = start1), end1 === start1 || 0 === target1.length || 0 === this.length) return 0;
                if (targetStart1 < 0) throw RangeError('targetStart out of bounds');
                if (start1 < 0 || start1 >= this.length) throw RangeError('Index out of range');
                if (end1 < 0) throw RangeError('sourceEnd out of bounds');
                end1 > this.length && (end1 = this.length), target1.length - targetStart1 < end1 - start1 && (end1 = target1.length - targetStart1 + start1);
                const len3 = end1 - start1;
                return this === target1 && 'function' == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(targetStart1, start1, end1) : Uint8Array.prototype.set.call(target1, this.subarray(start1, end1), targetStart1), len3;
            }, Buffer1.prototype.fill = function(val1, start1, end1, encoding1) {
                let i2;
                if ('string' == typeof val1) {
                    if ('string' == typeof start1 ? (encoding1 = start1, start1 = 0, end1 = this.length) : 'string' == typeof end1 && (encoding1 = end1, end1 = this.length), void 0 !== encoding1 && 'string' != typeof encoding1) throw TypeError('encoding must be a string');
                    if ('string' == typeof encoding1 && !Buffer1.isEncoding(encoding1)) throw TypeError('Unknown encoding: ' + encoding1);
                    if (1 === val1.length) {
                        const code1 = val1.charCodeAt(0);
                        ('utf8' === encoding1 && code1 < 128 || 'latin1' === encoding1) && (val1 = code1);
                    }
                } else 'number' == typeof val1 ? val1 &= 255 : 'boolean' == typeof val1 && (val1 = Number(val1));
                if (start1 < 0 || this.length < start1 || this.length < end1) throw RangeError('Out of range index');
                if (end1 <= start1) return this;
                if (start1 >>>= 0, end1 = void 0 === end1 ? this.length : end1 >>> 0, val1 || (val1 = 0), 'number' == typeof val1) for(i2 = start1; i2 < end1; ++i2)this[i2] = val1;
                else {
                    const bytes1 = Buffer1.isBuffer(val1) ? val1 : Buffer1.from(val1, encoding1), len3 = bytes1.length;
                    if (0 === len3) throw TypeError('The value "' + val1 + '" is invalid for argument "value"');
                    for(i2 = 0; i2 < end1 - start1; ++i2)this[i2 + start1] = bytes1[i2 % len3];
                }
                return this;
            };
            const errors1 = {};
            function E1(sym1, getMessage1, Base1) {
                errors1[sym1] = class extends Base1 {
                    constructor(){
                        super(), Object.defineProperty(this, 'message', {
                            value: getMessage1.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }), this.name = `${this.name} [${sym1}]`, this.stack, delete this.name;
                    }
                    get code() {
                        return sym1;
                    }
                    set code(value1) {
                        Object.defineProperty(this, 'code', {
                            configurable: !0,
                            enumerable: !0,
                            value: value1,
                            writable: !0
                        });
                    }
                    toString() {
                        return `${this.name} [${sym1}]: ${this.message}`;
                    }
                };
            }
            function addNumericalSeparator1(val1) {
                let res1 = '', i2 = val1.length;
                const start1 = '-' === val1[0] ? 1 : 0;
                for(; i2 >= start1 + 4; i2 -= 3)res1 = `_${val1.slice(i2 - 3, i2)}${res1}`;
                return `${val1.slice(0, i2)}${res1}`;
            }
            function checkBounds1(buf1, offset1, byteLength1) {
                validateNumber1(offset1, 'offset'), (void 0 === buf1[offset1] || void 0 === buf1[offset1 + byteLength1]) && boundsError1(offset1, buf1.length - (byteLength1 + 1));
            }
            function checkIntBI1(value1, min1, max1, buf1, offset1, byteLength1) {
                if (value1 > max1 || value1 < min1) {
                    let range1;
                    const n2 = 'bigint' == typeof min1 ? 'n' : '';
                    throw range1 = byteLength1 > 3 ? 0 === min1 || min1 === BigInt(0) ? `>= 0${n2} and < 2${n2} ** ${(byteLength1 + 1) * 8}${n2}` : `>= -(2${n2} ** ${(byteLength1 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength1 + 1) * 8 - 1}${n2}` : `>= ${min1}${n2} and <= ${max1}${n2}`, new errors1.ERR_OUT_OF_RANGE('value', range1, value1);
                }
                checkBounds1(buf1, offset1, byteLength1);
            }
            function validateNumber1(value1, name1) {
                if ('number' != typeof value1) throw new errors1.ERR_INVALID_ARG_TYPE(name1, 'number', value1);
            }
            function boundsError1(value1, length1, type1) {
                if (Math.floor(value1) !== value1) throw validateNumber1(value1, type1), new errors1.ERR_OUT_OF_RANGE(type1 || 'offset', 'an integer', value1);
                if (length1 < 0) throw new errors1.ERR_BUFFER_OUT_OF_BOUNDS();
                throw new errors1.ERR_OUT_OF_RANGE(type1 || 'offset', `>= ${type1 ? 1 : 0} and <= ${length1}`, value1);
            }
            E1('ERR_BUFFER_OUT_OF_BOUNDS', function(name1) {
                return name1 ? `${name1} is outside of buffer bounds` : 'Attempt to access memory outside buffer bounds';
            }, RangeError), E1('ERR_INVALID_ARG_TYPE', function(name1, actual1) {
                return `The "${name1}" argument must be of type number. Received type ${typeof actual1}`;
            }, TypeError), E1('ERR_OUT_OF_RANGE', function(str1, range1, input1) {
                let msg1 = `The value of "${str1}" is out of range.`, received1 = input1;
                return Number.isInteger(input1) && Math.abs(input1) > 4294967296 ? received1 = addNumericalSeparator1(String(input1)) : 'bigint' == typeof input1 && (received1 = String(input1), (input1 > BigInt(2) ** BigInt(32) || input1 < -(BigInt(2) ** BigInt(32))) && (received1 = addNumericalSeparator1(received1)), received1 += 'n'), msg1 += ` It must be ${range1}. Received ${received1}`;
            }, RangeError);
            const INVALID_BASE64_RE1 = /[^+/0-9A-Za-z-_]/g;
            function base64clean1(str1) {
                if ((str1 = (str1 = str1.split('=')[0]).trim().replace(INVALID_BASE64_RE1, '')).length < 2) return '';
                for(; str1.length % 4 != 0;)str1 += '=';
                return str1;
            }
            function utf8ToBytes1(string1, units1) {
                let codePoint1;
                units1 = units1 || 1 / 0;
                const length1 = string1.length;
                let leadSurrogate1 = null;
                const bytes1 = [];
                for(let i2 = 0; i2 < length1; ++i2){
                    if ((codePoint1 = string1.charCodeAt(i2)) > 0xD7FF && codePoint1 < 0xE000) {
                        if (!leadSurrogate1) {
                            if (codePoint1 > 0xDBFF || i2 + 1 === length1) {
                                (units1 -= 3) > -1 && bytes1.push(0xEF, 0xBF, 0xBD);
                                continue;
                            }
                            leadSurrogate1 = codePoint1;
                            continue;
                        }
                        if (codePoint1 < 0xDC00) {
                            (units1 -= 3) > -1 && bytes1.push(0xEF, 0xBF, 0xBD), leadSurrogate1 = codePoint1;
                            continue;
                        }
                        codePoint1 = (leadSurrogate1 - 0xD800 << 10 | codePoint1 - 0xDC00) + 0x10000;
                    } else leadSurrogate1 && (units1 -= 3) > -1 && bytes1.push(0xEF, 0xBF, 0xBD);
                    if (leadSurrogate1 = null, codePoint1 < 0x80) {
                        if ((units1 -= 1) < 0) break;
                        bytes1.push(codePoint1);
                    } else if (codePoint1 < 0x800) {
                        if ((units1 -= 2) < 0) break;
                        bytes1.push(codePoint1 >> 0x6 | 0xC0, 0x3F & codePoint1 | 0x80);
                    } else if (codePoint1 < 0x10000) {
                        if ((units1 -= 3) < 0) break;
                        bytes1.push(codePoint1 >> 0xC | 0xE0, codePoint1 >> 0x6 & 0x3F | 0x80, 0x3F & codePoint1 | 0x80);
                    } else if (codePoint1 < 0x110000) {
                        if ((units1 -= 4) < 0) break;
                        bytes1.push(codePoint1 >> 0x12 | 0xF0, codePoint1 >> 0xC & 0x3F | 0x80, codePoint1 >> 0x6 & 0x3F | 0x80, 0x3F & codePoint1 | 0x80);
                    } else throw Error('Invalid code point');
                }
                return bytes1;
            }
            function asciiToBytes1(str1) {
                const byteArray1 = [];
                for(let i2 = 0; i2 < str1.length; ++i2)byteArray1.push(0xFF & str1.charCodeAt(i2));
                return byteArray1;
            }
            function utf16leToBytes1(str1, units1) {
                let c5, hi1;
                const byteArray1 = [];
                for(let i2 = 0; i2 < str1.length && !((units1 -= 2) < 0); ++i2)hi1 = (c5 = str1.charCodeAt(i2)) >> 8, byteArray1.push(c5 % 256), byteArray1.push(hi1);
                return byteArray1;
            }
            function base64ToBytes1(str1) {
                return base641.toByteArray(base64clean1(str1));
            }
            function blitBuffer1(src1, dst1, offset1, length1) {
                let i2;
                for(i2 = 0; i2 < length1 && !(i2 + offset1 >= dst1.length) && !(i2 >= src1.length); ++i2)dst1[i2 + offset1] = src1[i2];
                return i2;
            }
            function isInstance1(obj1, type1) {
                return obj1 instanceof type1 || null != obj1 && null != obj1.constructor && null != obj1.constructor.name && obj1.constructor.name === type1.name;
            }
            function numberIsNaN1(obj1) {
                return obj1 != obj1;
            }
            const hexSliceLookupTable1 = function() {
                const alphabet1 = '0123456789abcdef', table1 = Array(256);
                for(let i2 = 0; i2 < 16; ++i2){
                    const i161 = 16 * i2;
                    for(let j1 = 0; j1 < 16; ++j1)table1[i161 + j1] = alphabet1[i2] + alphabet1[j1];
                }
                return table1;
            }();
            function defineBigIntMethod1(fn1) {
                return 'undefined' == typeof BigInt ? BufferBigIntNotDefined1 : fn1;
            }
            function BufferBigIntNotDefined1() {
                throw Error('BigInt not supported');
            }
        },
        1924: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var GetIntrinsic1 = __webpack_require__1(210), callBind1 = __webpack_require__1(5559), $indexOf1 = callBind1(GetIntrinsic1('String.prototype.indexOf'));
            module1.exports = function(name1, allowMissing1) {
                var intrinsic1 = GetIntrinsic1(name1, !!allowMissing1);
                return 'function' == typeof intrinsic1 && $indexOf1(name1, '.prototype.') > -1 ? callBind1(intrinsic1) : intrinsic1;
            };
        },
        5559: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var bind1 = __webpack_require__1(8612), GetIntrinsic1 = __webpack_require__1(210), $apply1 = GetIntrinsic1('%Function.prototype.apply%'), $call1 = GetIntrinsic1('%Function.prototype.call%'), $reflectApply1 = GetIntrinsic1('%Reflect.apply%', !0) || bind1.call($call1, $apply1), $gOPD1 = GetIntrinsic1('%Object.getOwnPropertyDescriptor%', !0), $defineProperty1 = GetIntrinsic1('%Object.defineProperty%', !0), $max1 = GetIntrinsic1('%Math.max%');
            if ($defineProperty1) try {
                $defineProperty1({}, 'a', {
                    value: 1
                });
            } catch (e1) {
                $defineProperty1 = null;
            }
            module1.exports = function(originalFunction1) {
                var func1 = $reflectApply1(bind1, $call1, arguments);
                return $gOPD1 && $defineProperty1 && $gOPD1(func1, 'length').configurable && $defineProperty1(func1, 'length', {
                    value: 1 + $max1(0, originalFunction1.length - (arguments.length - 1))
                }), func1;
            };
            var applyBind1 = function() {
                return $reflectApply1(bind1, $apply1, arguments);
            };
            $defineProperty1 ? $defineProperty1(module1.exports, 'apply', {
                value: applyBind1
            }) : module1.exports.apply = applyBind1;
        },
        6957: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var nextTick1 = __webpack_require__1(886);
            exports1.fromCallback = function(callback1, symbol1) {
                if (void 0 === callback1) {
                    var promise1 = new Promise(function(resolve1, reject1) {
                        callback1 = function(err1, res1) {
                            err1 ? reject1(err1) : resolve1(res1);
                        };
                    });
                    callback1[void 0 !== symbol1 ? symbol1 : 'promise'] = promise1;
                } else if ('function' != typeof callback1) throw TypeError('Callback must be a function');
                return callback1;
            }, exports1.fromPromise = function(promise1, callback1) {
                if (void 0 === callback1) return promise1;
                promise1.then(function(res1) {
                    nextTick1(()=>callback1(null, res1));
                }).catch(function(err1) {
                    nextTick1(()=>callback1(err1));
                });
            };
        },
        886: function(module1) {
            module1.exports = 'function' == typeof queueMicrotask ? queueMicrotask : (fn1)=>Promise.resolve().then(fn1);
        },
        6266: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var elliptic1 = exports1;
            elliptic1.version = __webpack_require__1(8597).i8, elliptic1.utils = __webpack_require__1(953), elliptic1.rand = __webpack_require__1(9931), elliptic1.curve = __webpack_require__1(8254), elliptic1.curves = __webpack_require__1(5427), elliptic1.ec = __webpack_require__1(7954), elliptic1.eddsa = __webpack_require__1(5980);
        },
        4918: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var BN1 = __webpack_require__1(3550), utils1 = __webpack_require__1(953), getNAF1 = utils1.getNAF, getJSF1 = utils1.getJSF, assert1 = utils1.assert;
            function BaseCurve1(type1, conf1) {
                this.type = type1, this.p = new BN1(conf1.p, 16), this.red = conf1.prime ? BN1.red(conf1.prime) : BN1.mont(this.p), this.zero = new BN1(0).toRed(this.red), this.one = new BN1(1).toRed(this.red), this.two = new BN1(2).toRed(this.red), this.n = conf1.n && new BN1(conf1.n, 16), this.g = conf1.g && this.pointFromJSON(conf1.g, conf1.gRed), this._wnafT1 = [
                    ,
                    ,
                    ,
                    , 
                ], this._wnafT2 = [
                    ,
                    ,
                    ,
                    , 
                ], this._wnafT3 = [
                    ,
                    ,
                    ,
                    , 
                ], this._wnafT4 = [
                    ,
                    ,
                    ,
                    , 
                ], this._bitLength = this.n ? this.n.bitLength() : 0;
                var adjustCount1 = this.n && this.p.div(this.n);
                !adjustCount1 || adjustCount1.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
            }
            function BasePoint1(curve1, type1) {
                this.curve = curve1, this.type = type1, this.precomputed = null;
            }
            module1.exports = BaseCurve1, BaseCurve1.prototype.point = function() {
                throw Error('Not implemented');
            }, BaseCurve1.prototype.validate = function() {
                throw Error('Not implemented');
            }, BaseCurve1.prototype._fixedNafMul = function(p3, k3) {
                assert1(p3.precomputed);
                var j1, nafW1, doubles1 = p3._getDoubles(), naf1 = getNAF1(k3, 1, this._bitLength), I1 = (1 << doubles1.step + 1) - (doubles1.step % 2 == 0 ? 2 : 1);
                I1 /= 3;
                var repr1 = [];
                for(j1 = 0; j1 < naf1.length; j1 += doubles1.step){
                    nafW1 = 0;
                    for(var l1 = j1 + doubles1.step - 1; l1 >= j1; l1--)nafW1 = (nafW1 << 1) + naf1[l1];
                    repr1.push(nafW1);
                }
                for(var a10 = this.jpoint(null, null, null), b10 = this.jpoint(null, null, null), i2 = I1; i2 > 0; i2--){
                    for(j1 = 0; j1 < repr1.length; j1++)(nafW1 = repr1[j1]) === i2 ? b10 = b10.mixedAdd(doubles1.points[j1]) : nafW1 === -i2 && (b10 = b10.mixedAdd(doubles1.points[j1].neg()));
                    a10 = a10.add(b10);
                }
                return a10.toP();
            }, BaseCurve1.prototype._wnafMul = function(p3, k3) {
                var w19 = 4, nafPoints1 = p3._getNAFPoints(w19);
                w19 = nafPoints1.wnd;
                for(var wnd1 = nafPoints1.points, naf1 = getNAF1(k3, w19, this._bitLength), acc1 = this.jpoint(null, null, null), i2 = naf1.length - 1; i2 >= 0; i2--){
                    for(var l1 = 0; i2 >= 0 && 0 === naf1[i2]; i2--)l1++;
                    if (i2 >= 0 && l1++, acc1 = acc1.dblp(l1), i2 < 0) break;
                    var z1 = naf1[i2];
                    assert1(0 !== z1), acc1 = 'affine' === p3.type ? z1 > 0 ? acc1.mixedAdd(wnd1[z1 - 1 >> 1]) : acc1.mixedAdd(wnd1[-z1 - 1 >> 1].neg()) : z1 > 0 ? acc1.add(wnd1[z1 - 1 >> 1]) : acc1.add(wnd1[-z1 - 1 >> 1].neg());
                }
                return 'affine' === p3.type ? acc1.toP() : acc1;
            }, BaseCurve1.prototype._wnafMulAdd = function(defW1, points1, coeffs1, len3, jacobianResult1) {
                var i2, j1, p3, wndWidth1 = this._wnafT1, wnd1 = this._wnafT2, naf1 = this._wnafT3, max1 = 0;
                for(i2 = 0; i2 < len3; i2++){
                    var nafPoints1 = (p3 = points1[i2])._getNAFPoints(defW1);
                    wndWidth1[i2] = nafPoints1.wnd, wnd1[i2] = nafPoints1.points;
                }
                for(i2 = len3 - 1; i2 >= 1; i2 -= 2){
                    var a10 = i2 - 1, b10 = i2;
                    if (1 !== wndWidth1[a10] || 1 !== wndWidth1[b10]) {
                        naf1[a10] = getNAF1(coeffs1[a10], wndWidth1[a10], this._bitLength), naf1[b10] = getNAF1(coeffs1[b10], wndWidth1[b10], this._bitLength), max1 = Math.max(naf1[a10].length, max1), max1 = Math.max(naf1[b10].length, max1);
                        continue;
                    }
                    var comb1 = [
                        points1[a10],
                        null,
                        null,
                        points1[b10]
                    ];
                    0 === points1[a10].y.cmp(points1[b10].y) ? (comb1[1] = points1[a10].add(points1[b10]), comb1[2] = points1[a10].toJ().mixedAdd(points1[b10].neg())) : 0 === points1[a10].y.cmp(points1[b10].y.redNeg()) ? (comb1[1] = points1[a10].toJ().mixedAdd(points1[b10]), comb1[2] = points1[a10].add(points1[b10].neg())) : (comb1[1] = points1[a10].toJ().mixedAdd(points1[b10]), comb1[2] = points1[a10].toJ().mixedAdd(points1[b10].neg()));
                    var index1 = [
                        -3,
                        -1,
                        -5,
                        -7,
                        0,
                        7,
                        5,
                        1,
                        3
                    ], jsf1 = getJSF1(coeffs1[a10], coeffs1[b10]);
                    for(j1 = 0, max1 = Math.max(jsf1[0].length, max1), naf1[a10] = Array(max1), naf1[b10] = Array(max1); j1 < max1; j1++){
                        var ja1 = 0 | jsf1[0][j1], jb1 = 0 | jsf1[1][j1];
                        naf1[a10][j1] = index1[(ja1 + 1) * 3 + (jb1 + 1)], naf1[b10][j1] = 0, wnd1[a10] = comb1;
                    }
                }
                var acc1 = this.jpoint(null, null, null), tmp1 = this._wnafT4;
                for(i2 = max1; i2 >= 0; i2--){
                    for(var k3 = 0; i2 >= 0;){
                        var zero1 = !0;
                        for(j1 = 0; j1 < len3; j1++)tmp1[j1] = 0 | naf1[j1][i2], 0 !== tmp1[j1] && (zero1 = !1);
                        if (!zero1) break;
                        k3++, i2--;
                    }
                    if (i2 >= 0 && k3++, acc1 = acc1.dblp(k3), i2 < 0) break;
                    for(j1 = 0; j1 < len3; j1++){
                        var z1 = tmp1[j1];
                        0 !== z1 && (z1 > 0 ? p3 = wnd1[j1][z1 - 1 >> 1] : z1 < 0 && (p3 = wnd1[j1][-z1 - 1 >> 1].neg()), acc1 = 'affine' === p3.type ? acc1.mixedAdd(p3) : acc1.add(p3));
                    }
                }
                for(i2 = 0; i2 < len3; i2++)wnd1[i2] = null;
                return jacobianResult1 ? acc1 : acc1.toP();
            }, BaseCurve1.BasePoint = BasePoint1, BasePoint1.prototype.eq = function() {
                throw Error('Not implemented');
            }, BasePoint1.prototype.validate = function() {
                return this.curve.validate(this);
            }, BaseCurve1.prototype.decodePoint = function(bytes1, enc1) {
                bytes1 = utils1.toArray(bytes1, enc1);
                var len3 = this.p.byteLength();
                if ((0x04 === bytes1[0] || 0x06 === bytes1[0] || 0x07 === bytes1[0]) && bytes1.length - 1 == 2 * len3) return 0x06 === bytes1[0] ? assert1(bytes1[bytes1.length - 1] % 2 == 0) : 0x07 === bytes1[0] && assert1(bytes1[bytes1.length - 1] % 2 == 1), this.point(bytes1.slice(1, 1 + len3), bytes1.slice(1 + len3, 1 + 2 * len3));
                if ((0x02 === bytes1[0] || 0x03 === bytes1[0]) && bytes1.length - 1 === len3) return this.pointFromX(bytes1.slice(1, 1 + len3), 0x03 === bytes1[0]);
                throw Error('Unknown point format');
            }, BasePoint1.prototype.encodeCompressed = function(enc1) {
                return this.encode(enc1, !0);
            }, BasePoint1.prototype._encode = function(compact1) {
                var len3 = this.curve.p.byteLength(), x3 = this.getX().toArray('be', len3);
                return compact1 ? [
                    this.getY().isEven() ? 0x02 : 0x03
                ].concat(x3) : [
                    0x04
                ].concat(x3, this.getY().toArray('be', len3));
            }, BasePoint1.prototype.encode = function(enc1, compact1) {
                return utils1.encode(this._encode(compact1), enc1);
            }, BasePoint1.prototype.precompute = function(power1) {
                if (this.precomputed) return this;
                var precomputed1 = {
                    doubles: null,
                    naf: null,
                    beta: null
                };
                return precomputed1.naf = this._getNAFPoints(8), precomputed1.doubles = this._getDoubles(4, power1), precomputed1.beta = this._getBeta(), this.precomputed = precomputed1, this;
            }, BasePoint1.prototype._hasDoubles = function(k3) {
                if (!this.precomputed) return !1;
                var doubles1 = this.precomputed.doubles;
                return !!doubles1 && doubles1.points.length >= Math.ceil((k3.bitLength() + 1) / doubles1.step);
            }, BasePoint1.prototype._getDoubles = function(step1, power1) {
                if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
                for(var doubles1 = [
                    this
                ], acc1 = this, i2 = 0; i2 < power1; i2 += step1){
                    for(var j1 = 0; j1 < step1; j1++)acc1 = acc1.dbl();
                    doubles1.push(acc1);
                }
                return {
                    step: step1,
                    points: doubles1
                };
            }, BasePoint1.prototype._getNAFPoints = function(wnd1) {
                if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
                for(var res1 = [
                    this
                ], max1 = (1 << wnd1) - 1, dbl1 = 1 === max1 ? null : this.dbl(), i2 = 1; i2 < max1; i2++)res1[i2] = res1[i2 - 1].add(dbl1);
                return {
                    wnd: wnd1,
                    points: res1
                };
            }, BasePoint1.prototype._getBeta = function() {
                return null;
            }, BasePoint1.prototype.dblp = function(k3) {
                for(var r3 = this, i2 = 0; i2 < k3; i2++)r3 = r3.dbl();
                return r3;
            };
        },
        1138: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(953), BN1 = __webpack_require__1(3550), inherits1 = __webpack_require__1(5717), Base1 = __webpack_require__1(4918), assert1 = utils1.assert;
            function EdwardsCurve1(conf1) {
                this.twisted = (0 | conf1.a) != 1, this.mOneA = this.twisted && (0 | conf1.a) == -1, this.extended = this.mOneA, Base1.call(this, 'edwards', conf1), this.a = new BN1(conf1.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN1(conf1.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN1(conf1.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert1(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = (0 | conf1.c) == 1;
            }
            function Point1(curve1, x3, y3, z1, t3) {
                Base1.BasePoint.call(this, curve1, 'projective'), null === x3 && null === y3 && null === z1 ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN1(x3, 16), this.y = new BN1(y3, 16), this.z = z1 ? new BN1(z1, 16) : this.curve.one, this.t = t3 && new BN1(t3, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, !this.curve.extended || this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
            }
            inherits1(EdwardsCurve1, Base1), module1.exports = EdwardsCurve1, EdwardsCurve1.prototype._mulA = function(num1) {
                return this.mOneA ? num1.redNeg() : this.a.redMul(num1);
            }, EdwardsCurve1.prototype._mulC = function(num1) {
                return this.oneC ? num1 : this.c.redMul(num1);
            }, EdwardsCurve1.prototype.jpoint = function(x3, y3, z1, t3) {
                return this.point(x3, y3, z1, t3);
            }, EdwardsCurve1.prototype.pointFromX = function(x3, odd1) {
                (x3 = new BN1(x3, 16)).red || (x3 = x3.toRed(this.red));
                var x21 = x3.redSqr(), rhs1 = this.c2.redSub(this.a.redMul(x21)), lhs1 = this.one.redSub(this.c2.redMul(this.d).redMul(x21)), y21 = rhs1.redMul(lhs1.redInvm()), y3 = y21.redSqrt();
                if (0 !== y3.redSqr().redSub(y21).cmp(this.zero)) throw Error('invalid point');
                var isOdd1 = y3.fromRed().isOdd();
                return (odd1 && !isOdd1 || !odd1 && isOdd1) && (y3 = y3.redNeg()), this.point(x3, y3);
            }, EdwardsCurve1.prototype.pointFromY = function(y3, odd1) {
                (y3 = new BN1(y3, 16)).red || (y3 = y3.toRed(this.red));
                var y21 = y3.redSqr(), lhs1 = y21.redSub(this.c2), rhs1 = y21.redMul(this.d).redMul(this.c2).redSub(this.a), x21 = lhs1.redMul(rhs1.redInvm());
                if (0 === x21.cmp(this.zero)) {
                    if (!odd1) return this.point(this.zero, y3);
                    throw Error('invalid point');
                }
                var x3 = x21.redSqrt();
                if (0 !== x3.redSqr().redSub(x21).cmp(this.zero)) throw Error('invalid point');
                return x3.fromRed().isOdd() !== odd1 && (x3 = x3.redNeg()), this.point(x3, y3);
            }, EdwardsCurve1.prototype.validate = function(point1) {
                if (point1.isInfinity()) return !0;
                point1.normalize();
                var x21 = point1.x.redSqr(), y21 = point1.y.redSqr(), lhs1 = x21.redMul(this.a).redAdd(y21), rhs1 = this.c2.redMul(this.one.redAdd(this.d.redMul(x21).redMul(y21)));
                return 0 === lhs1.cmp(rhs1);
            }, inherits1(Point1, Base1.BasePoint), EdwardsCurve1.prototype.pointFromJSON = function(obj1) {
                return Point1.fromJSON(this, obj1);
            }, EdwardsCurve1.prototype.point = function(x3, y3, z1, t3) {
                return new Point1(this, x3, y3, z1, t3);
            }, Point1.fromJSON = function(curve1, obj1) {
                return new Point1(curve1, obj1[0], obj1[1], obj1[2]);
            }, Point1.prototype.inspect = function() {
                return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            }, Point1.prototype.isInfinity = function() {
                return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
            }, Point1.prototype._extDbl = function() {
                var a10 = this.x.redSqr(), b10 = this.y.redSqr(), c5 = this.z.redSqr();
                c5 = c5.redIAdd(c5);
                var d3 = this.curve._mulA(a10), e1 = this.x.redAdd(this.y).redSqr().redISub(a10).redISub(b10), g3 = d3.redAdd(b10), f1 = g3.redSub(c5), h8 = d3.redSub(b10), nx1 = e1.redMul(f1), ny1 = g3.redMul(h8), nt1 = e1.redMul(h8), nz1 = f1.redMul(g3);
                return this.curve.point(nx1, ny1, nz1, nt1);
            }, Point1.prototype._projDbl = function() {
                var nx1, ny1, nz1, e1, h8, j1, b10 = this.x.redAdd(this.y).redSqr(), c5 = this.x.redSqr(), d3 = this.y.redSqr();
                if (this.curve.twisted) {
                    var f1 = (e1 = this.curve._mulA(c5)).redAdd(d3);
                    this.zOne ? (nx1 = b10.redSub(c5).redSub(d3).redMul(f1.redSub(this.curve.two)), ny1 = f1.redMul(e1.redSub(d3)), nz1 = f1.redSqr().redSub(f1).redSub(f1)) : (h8 = this.z.redSqr(), j1 = f1.redSub(h8).redISub(h8), nx1 = b10.redSub(c5).redISub(d3).redMul(j1), ny1 = f1.redMul(e1.redSub(d3)), nz1 = f1.redMul(j1));
                } else e1 = c5.redAdd(d3), h8 = this.curve._mulC(this.z).redSqr(), j1 = e1.redSub(h8).redSub(h8), nx1 = this.curve._mulC(b10.redISub(e1)).redMul(j1), ny1 = this.curve._mulC(e1).redMul(c5.redISub(d3)), nz1 = e1.redMul(j1);
                return this.curve.point(nx1, ny1, nz1);
            }, Point1.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
            }, Point1.prototype._extAdd = function(p3) {
                var a10 = this.y.redSub(this.x).redMul(p3.y.redSub(p3.x)), b10 = this.y.redAdd(this.x).redMul(p3.y.redAdd(p3.x)), c5 = this.t.redMul(this.curve.dd).redMul(p3.t), d3 = this.z.redMul(p3.z.redAdd(p3.z)), e1 = b10.redSub(a10), f1 = d3.redSub(c5), g3 = d3.redAdd(c5), h8 = b10.redAdd(a10), nx1 = e1.redMul(f1), ny1 = g3.redMul(h8), nt1 = e1.redMul(h8), nz1 = f1.redMul(g3);
                return this.curve.point(nx1, ny1, nz1, nt1);
            }, Point1.prototype._projAdd = function(p3) {
                var ny1, nz1, a10 = this.z.redMul(p3.z), b10 = a10.redSqr(), c5 = this.x.redMul(p3.x), d3 = this.y.redMul(p3.y), e1 = this.curve.d.redMul(c5).redMul(d3), f1 = b10.redSub(e1), g3 = b10.redAdd(e1), tmp1 = this.x.redAdd(this.y).redMul(p3.x.redAdd(p3.y)).redISub(c5).redISub(d3), nx1 = a10.redMul(f1).redMul(tmp1);
                return this.curve.twisted ? (ny1 = a10.redMul(g3).redMul(d3.redSub(this.curve._mulA(c5))), nz1 = f1.redMul(g3)) : (ny1 = a10.redMul(g3).redMul(d3.redSub(c5)), nz1 = this.curve._mulC(f1).redMul(g3)), this.curve.point(nx1, ny1, nz1);
            }, Point1.prototype.add = function(p3) {
                return this.isInfinity() ? p3 : p3.isInfinity() ? this : this.curve.extended ? this._extAdd(p3) : this._projAdd(p3);
            }, Point1.prototype.mul = function(k3) {
                return this._hasDoubles(k3) ? this.curve._fixedNafMul(this, k3) : this.curve._wnafMul(this, k3);
            }, Point1.prototype.mulAdd = function(k11, p3, k21) {
                return this.curve._wnafMulAdd(1, [
                    this,
                    p3
                ], [
                    k11,
                    k21
                ], 2, !1);
            }, Point1.prototype.jmulAdd = function(k11, p3, k21) {
                return this.curve._wnafMulAdd(1, [
                    this,
                    p3
                ], [
                    k11,
                    k21
                ], 2, !0);
            }, Point1.prototype.normalize = function() {
                if (this.zOne) return this;
                var zi1 = this.z.redInvm();
                return this.x = this.x.redMul(zi1), this.y = this.y.redMul(zi1), this.t && (this.t = this.t.redMul(zi1)), this.z = this.curve.one, this.zOne = !0, this;
            }, Point1.prototype.neg = function() {
                return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
            }, Point1.prototype.getX = function() {
                return this.normalize(), this.x.fromRed();
            }, Point1.prototype.getY = function() {
                return this.normalize(), this.y.fromRed();
            }, Point1.prototype.eq = function(other1) {
                return this === other1 || 0 === this.getX().cmp(other1.getX()) && 0 === this.getY().cmp(other1.getY());
            }, Point1.prototype.eqXToP = function(x3) {
                var rx1 = x3.toRed(this.curve.red).redMul(this.z);
                if (0 === this.x.cmp(rx1)) return !0;
                for(var xc1 = x3.clone(), t3 = this.curve.redN.redMul(this.z);;){
                    if (xc1.iadd(this.curve.n), xc1.cmp(this.curve.p) >= 0) return !1;
                    if (rx1.redIAdd(t3), 0 === this.x.cmp(rx1)) return !0;
                }
            }, Point1.prototype.toP = Point1.prototype.normalize, Point1.prototype.mixedAdd = Point1.prototype.add;
        },
        8254: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var curve1 = exports1;
            curve1.base = __webpack_require__1(4918), curve1.short = __webpack_require__1(6673), curve1.mont = __webpack_require__1(2881), curve1.edwards = __webpack_require__1(1138);
        },
        2881: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var BN1 = __webpack_require__1(3550), inherits1 = __webpack_require__1(5717), Base1 = __webpack_require__1(4918), utils1 = __webpack_require__1(953);
            function MontCurve1(conf1) {
                Base1.call(this, 'mont', conf1), this.a = new BN1(conf1.a, 16).toRed(this.red), this.b = new BN1(conf1.b, 16).toRed(this.red), this.i4 = new BN1(4).toRed(this.red).redInvm(), this.two = new BN1(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
            }
            function Point1(curve1, x3, z1) {
                Base1.BasePoint.call(this, curve1, 'projective'), null === x3 && null === z1 ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN1(x3, 16), this.z = new BN1(z1, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
            }
            inherits1(MontCurve1, Base1), module1.exports = MontCurve1, MontCurve1.prototype.validate = function(point1) {
                var x3 = point1.normalize().x, x21 = x3.redSqr(), rhs1 = x21.redMul(x3).redAdd(x21.redMul(this.a)).redAdd(x3);
                return 0 === rhs1.redSqrt().redSqr().cmp(rhs1);
            }, inherits1(Point1, Base1.BasePoint), MontCurve1.prototype.decodePoint = function(bytes1, enc1) {
                return this.point(utils1.toArray(bytes1, enc1), 1);
            }, MontCurve1.prototype.point = function(x3, z1) {
                return new Point1(this, x3, z1);
            }, MontCurve1.prototype.pointFromJSON = function(obj1) {
                return Point1.fromJSON(this, obj1);
            }, Point1.prototype.precompute = function() {}, Point1.prototype._encode = function() {
                return this.getX().toArray('be', this.curve.p.byteLength());
            }, Point1.fromJSON = function(curve1, obj1) {
                return new Point1(curve1, obj1[0], obj1[1] || curve1.one);
            }, Point1.prototype.inspect = function() {
                return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            }, Point1.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0);
            }, Point1.prototype.dbl = function() {
                var aa1 = this.x.redAdd(this.z).redSqr(), bb1 = this.x.redSub(this.z).redSqr(), c5 = aa1.redSub(bb1), nx1 = aa1.redMul(bb1), nz1 = c5.redMul(bb1.redAdd(this.curve.a24.redMul(c5)));
                return this.curve.point(nx1, nz1);
            }, Point1.prototype.add = function() {
                throw Error('Not supported on Montgomery curve');
            }, Point1.prototype.diffAdd = function(p3, diff1) {
                var a10 = this.x.redAdd(this.z), b10 = this.x.redSub(this.z), c5 = p3.x.redAdd(p3.z), da1 = p3.x.redSub(p3.z).redMul(a10), cb1 = c5.redMul(b10), nx1 = diff1.z.redMul(da1.redAdd(cb1).redSqr()), nz1 = diff1.x.redMul(da1.redISub(cb1).redSqr());
                return this.curve.point(nx1, nz1);
            }, Point1.prototype.mul = function(k3) {
                for(var t3 = k3.clone(), a10 = this, b10 = this.curve.point(null, null), c5 = this, bits1 = []; 0 !== t3.cmpn(0); t3.iushrn(1))bits1.push(t3.andln(1));
                for(var i2 = bits1.length - 1; i2 >= 0; i2--)0 === bits1[i2] ? (a10 = a10.diffAdd(b10, c5), b10 = b10.dbl()) : (b10 = a10.diffAdd(b10, c5), a10 = a10.dbl());
                return b10;
            }, Point1.prototype.mulAdd = function() {
                throw Error('Not supported on Montgomery curve');
            }, Point1.prototype.jumlAdd = function() {
                throw Error('Not supported on Montgomery curve');
            }, Point1.prototype.eq = function(other1) {
                return 0 === this.getX().cmp(other1.getX());
            }, Point1.prototype.normalize = function() {
                return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
            }, Point1.prototype.getX = function() {
                return this.normalize(), this.x.fromRed();
            };
        },
        6673: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(953), BN1 = __webpack_require__1(3550), inherits1 = __webpack_require__1(5717), Base1 = __webpack_require__1(4918), assert1 = utils1.assert;
            function ShortCurve1(conf1) {
                Base1.call(this, 'short', conf1), this.a = new BN1(conf1.a, 16).toRed(this.red), this.b = new BN1(conf1.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(conf1), this._endoWnafT1 = [
                    ,
                    ,
                    ,
                    , 
                ], this._endoWnafT2 = [
                    ,
                    ,
                    ,
                    , 
                ];
            }
            function Point1(curve1, x3, y3, isRed1) {
                Base1.BasePoint.call(this, curve1, 'affine'), null === x3 && null === y3 ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN1(x3, 16), this.y = new BN1(y3, 16), isRed1 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
            }
            function JPoint1(curve1, x3, y3, z1) {
                Base1.BasePoint.call(this, curve1, 'jacobian'), null === x3 && null === y3 && null === z1 ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN1(0)) : (this.x = new BN1(x3, 16), this.y = new BN1(y3, 16), this.z = new BN1(z1, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
            }
            inherits1(ShortCurve1, Base1), module1.exports = ShortCurve1, ShortCurve1.prototype._getEndomorphism = function(conf1) {
                if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                    if (conf1.beta) beta1 = new BN1(conf1.beta, 16).toRed(this.red);
                    else {
                        var beta1, lambda1, basis1, betas1 = this._getEndoRoots(this.p);
                        beta1 = (beta1 = 0 > betas1[0].cmp(betas1[1]) ? betas1[0] : betas1[1]).toRed(this.red);
                    }
                    if (conf1.lambda) lambda1 = new BN1(conf1.lambda, 16);
                    else {
                        var lambdas1 = this._getEndoRoots(this.n);
                        0 === this.g.mul(lambdas1[0]).x.cmp(this.g.x.redMul(beta1)) ? lambda1 = lambdas1[0] : (lambda1 = lambdas1[1], assert1(0 === this.g.mul(lambda1).x.cmp(this.g.x.redMul(beta1))));
                    }
                    return basis1 = conf1.basis ? conf1.basis.map(function(vec1) {
                        return {
                            a: new BN1(vec1.a, 16),
                            b: new BN1(vec1.b, 16)
                        };
                    }) : this._getEndoBasis(lambda1), {
                        beta: beta1,
                        lambda: lambda1,
                        basis: basis1
                    };
                }
            }, ShortCurve1.prototype._getEndoRoots = function(num1) {
                var red1 = num1 === this.p ? this.red : BN1.mont(num1), tinv1 = new BN1(2).toRed(red1).redInvm(), ntinv1 = tinv1.redNeg(), s3 = new BN1(3).toRed(red1).redNeg().redSqrt().redMul(tinv1);
                return [
                    ntinv1.redAdd(s3).fromRed(),
                    ntinv1.redSub(s3).fromRed()
                ];
            }, ShortCurve1.prototype._getEndoBasis = function(lambda1) {
                for(var a01, b01, a11, b11, a21, b21, prevR1, r3, x3, aprxSqrt1 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u3 = lambda1, v3 = this.n.clone(), x11 = new BN1(1), y11 = new BN1(0), x21 = new BN1(0), y21 = new BN1(1), i2 = 0; 0 !== u3.cmpn(0);){
                    var q3 = v3.div(u3);
                    r3 = v3.sub(q3.mul(u3)), x3 = x21.sub(q3.mul(x11));
                    var y3 = y21.sub(q3.mul(y11));
                    if (!a11 && 0 > r3.cmp(aprxSqrt1)) a01 = prevR1.neg(), b01 = x11, a11 = r3.neg(), b11 = x3;
                    else if (a11 && 2 == ++i2) break;
                    prevR1 = r3, v3 = u3, u3 = r3, x21 = x11, x11 = x3, y21 = y11, y11 = y3;
                }
                a21 = r3.neg(), b21 = x3;
                var len11 = a11.sqr().add(b11.sqr());
                return a21.sqr().add(b21.sqr()).cmp(len11) >= 0 && (a21 = a01, b21 = b01), a11.negative && (a11 = a11.neg(), b11 = b11.neg()), a21.negative && (a21 = a21.neg(), b21 = b21.neg()), [
                    {
                        a: a11,
                        b: b11
                    },
                    {
                        a: a21,
                        b: b21
                    }
                ];
            }, ShortCurve1.prototype._endoSplit = function(k3) {
                var basis1 = this.endo.basis, v11 = basis1[0], v21 = basis1[1], c11 = v21.b.mul(k3).divRound(this.n), c21 = v11.b.neg().mul(k3).divRound(this.n), p11 = c11.mul(v11.a), p21 = c21.mul(v21.a), q11 = c11.mul(v11.b), q21 = c21.mul(v21.b);
                return {
                    k1: k3.sub(p11).sub(p21),
                    k2: q11.add(q21).neg()
                };
            }, ShortCurve1.prototype.pointFromX = function(x3, odd1) {
                (x3 = new BN1(x3, 16)).red || (x3 = x3.toRed(this.red));
                var y21 = x3.redSqr().redMul(x3).redIAdd(x3.redMul(this.a)).redIAdd(this.b), y3 = y21.redSqrt();
                if (0 !== y3.redSqr().redSub(y21).cmp(this.zero)) throw Error('invalid point');
                var isOdd1 = y3.fromRed().isOdd();
                return (odd1 && !isOdd1 || !odd1 && isOdd1) && (y3 = y3.redNeg()), this.point(x3, y3);
            }, ShortCurve1.prototype.validate = function(point1) {
                if (point1.inf) return !0;
                var x3 = point1.x, y3 = point1.y, ax1 = this.a.redMul(x3), rhs1 = x3.redSqr().redMul(x3).redIAdd(ax1).redIAdd(this.b);
                return 0 === y3.redSqr().redISub(rhs1).cmpn(0);
            }, ShortCurve1.prototype._endoWnafMulAdd = function(points1, coeffs1, jacobianResult1) {
                for(var npoints1 = this._endoWnafT1, ncoeffs1 = this._endoWnafT2, i2 = 0; i2 < points1.length; i2++){
                    var split1 = this._endoSplit(coeffs1[i2]), p3 = points1[i2], beta1 = p3._getBeta();
                    split1.k1.negative && (split1.k1.ineg(), p3 = p3.neg(!0)), split1.k2.negative && (split1.k2.ineg(), beta1 = beta1.neg(!0)), npoints1[2 * i2] = p3, npoints1[2 * i2 + 1] = beta1, ncoeffs1[2 * i2] = split1.k1, ncoeffs1[2 * i2 + 1] = split1.k2;
                }
                for(var res1 = this._wnafMulAdd(1, npoints1, ncoeffs1, 2 * i2, jacobianResult1), j1 = 0; j1 < 2 * i2; j1++)npoints1[j1] = null, ncoeffs1[j1] = null;
                return res1;
            }, inherits1(Point1, Base1.BasePoint), ShortCurve1.prototype.point = function(x3, y3, isRed1) {
                return new Point1(this, x3, y3, isRed1);
            }, ShortCurve1.prototype.pointFromJSON = function(obj1, red1) {
                return Point1.fromJSON(this, obj1, red1);
            }, Point1.prototype._getBeta = function() {
                if (this.curve.endo) {
                    var pre1 = this.precomputed;
                    if (pre1 && pre1.beta) return pre1.beta;
                    var beta1 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                    if (pre1) {
                        var curve1 = this.curve, endoMul1 = function(p3) {
                            return curve1.point(p3.x.redMul(curve1.endo.beta), p3.y);
                        };
                        pre1.beta = beta1, beta1.precomputed = {
                            beta: null,
                            naf: pre1.naf && {
                                wnd: pre1.naf.wnd,
                                points: pre1.naf.points.map(endoMul1)
                            },
                            doubles: pre1.doubles && {
                                step: pre1.doubles.step,
                                points: pre1.doubles.points.map(endoMul1)
                            }
                        };
                    }
                    return beta1;
                }
            }, Point1.prototype.toJSON = function() {
                return this.precomputed ? [
                    this.x,
                    this.y,
                    this.precomputed && {
                        doubles: this.precomputed.doubles && {
                            step: this.precomputed.doubles.step,
                            points: this.precomputed.doubles.points.slice(1)
                        },
                        naf: this.precomputed.naf && {
                            wnd: this.precomputed.naf.wnd,
                            points: this.precomputed.naf.points.slice(1)
                        }
                    }
                ] : [
                    this.x,
                    this.y
                ];
            }, Point1.fromJSON = function(curve1, obj1, red1) {
                'string' == typeof obj1 && (obj1 = JSON.parse(obj1));
                var res1 = curve1.point(obj1[0], obj1[1], red1);
                if (!obj1[2]) return res1;
                function obj2point1(obj1) {
                    return curve1.point(obj1[0], obj1[1], red1);
                }
                var pre1 = obj1[2];
                return res1.precomputed = {
                    beta: null,
                    doubles: pre1.doubles && {
                        step: pre1.doubles.step,
                        points: [
                            res1
                        ].concat(pre1.doubles.points.map(obj2point1))
                    },
                    naf: pre1.naf && {
                        wnd: pre1.naf.wnd,
                        points: [
                            res1
                        ].concat(pre1.naf.points.map(obj2point1))
                    }
                }, res1;
            }, Point1.prototype.inspect = function() {
                return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
            }, Point1.prototype.isInfinity = function() {
                return this.inf;
            }, Point1.prototype.add = function(p3) {
                if (this.inf) return p3;
                if (p3.inf) return this;
                if (this.eq(p3)) return this.dbl();
                if (this.neg().eq(p3) || 0 === this.x.cmp(p3.x)) return this.curve.point(null, null);
                var c5 = this.y.redSub(p3.y);
                0 !== c5.cmpn(0) && (c5 = c5.redMul(this.x.redSub(p3.x).redInvm()));
                var nx1 = c5.redSqr().redISub(this.x).redISub(p3.x), ny1 = c5.redMul(this.x.redSub(nx1)).redISub(this.y);
                return this.curve.point(nx1, ny1);
            }, Point1.prototype.dbl = function() {
                if (this.inf) return this;
                var ys11 = this.y.redAdd(this.y);
                if (0 === ys11.cmpn(0)) return this.curve.point(null, null);
                var a10 = this.curve.a, x21 = this.x.redSqr(), dyinv1 = ys11.redInvm(), c5 = x21.redAdd(x21).redIAdd(x21).redIAdd(a10).redMul(dyinv1), nx1 = c5.redSqr().redISub(this.x.redAdd(this.x)), ny1 = c5.redMul(this.x.redSub(nx1)).redISub(this.y);
                return this.curve.point(nx1, ny1);
            }, Point1.prototype.getX = function() {
                return this.x.fromRed();
            }, Point1.prototype.getY = function() {
                return this.y.fromRed();
            }, Point1.prototype.mul = function(k3) {
                return (k3 = new BN1(k3, 16), this.isInfinity()) ? this : this._hasDoubles(k3) ? this.curve._fixedNafMul(this, k3) : this.curve.endo ? this.curve._endoWnafMulAdd([
                    this
                ], [
                    k3
                ]) : this.curve._wnafMul(this, k3);
            }, Point1.prototype.mulAdd = function(k11, p21, k21) {
                var points1 = [
                    this,
                    p21
                ], coeffs1 = [
                    k11,
                    k21
                ];
                return this.curve.endo ? this.curve._endoWnafMulAdd(points1, coeffs1) : this.curve._wnafMulAdd(1, points1, coeffs1, 2);
            }, Point1.prototype.jmulAdd = function(k11, p21, k21) {
                var points1 = [
                    this,
                    p21
                ], coeffs1 = [
                    k11,
                    k21
                ];
                return this.curve.endo ? this.curve._endoWnafMulAdd(points1, coeffs1, !0) : this.curve._wnafMulAdd(1, points1, coeffs1, 2, !0);
            }, Point1.prototype.eq = function(p3) {
                return this === p3 || this.inf === p3.inf && (this.inf || 0 === this.x.cmp(p3.x) && 0 === this.y.cmp(p3.y));
            }, Point1.prototype.neg = function(_precompute1) {
                if (this.inf) return this;
                var res1 = this.curve.point(this.x, this.y.redNeg());
                if (_precompute1 && this.precomputed) {
                    var pre1 = this.precomputed, negate1 = function(p3) {
                        return p3.neg();
                    };
                    res1.precomputed = {
                        naf: pre1.naf && {
                            wnd: pre1.naf.wnd,
                            points: pre1.naf.points.map(negate1)
                        },
                        doubles: pre1.doubles && {
                            step: pre1.doubles.step,
                            points: pre1.doubles.points.map(negate1)
                        }
                    };
                }
                return res1;
            }, Point1.prototype.toJ = function() {
                return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
            }, inherits1(JPoint1, Base1.BasePoint), ShortCurve1.prototype.jpoint = function(x3, y3, z1) {
                return new JPoint1(this, x3, y3, z1);
            }, JPoint1.prototype.toP = function() {
                if (this.isInfinity()) return this.curve.point(null, null);
                var zinv1 = this.z.redInvm(), zinv21 = zinv1.redSqr(), ax1 = this.x.redMul(zinv21), ay1 = this.y.redMul(zinv21).redMul(zinv1);
                return this.curve.point(ax1, ay1);
            }, JPoint1.prototype.neg = function() {
                return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
            }, JPoint1.prototype.add = function(p3) {
                if (this.isInfinity()) return p3;
                if (p3.isInfinity()) return this;
                var pz21 = p3.z.redSqr(), z21 = this.z.redSqr(), u11 = this.x.redMul(pz21), u21 = p3.x.redMul(z21), s11 = this.y.redMul(pz21.redMul(p3.z)), s21 = p3.y.redMul(z21.redMul(this.z)), h8 = u11.redSub(u21), r3 = s11.redSub(s21);
                if (0 === h8.cmpn(0)) return 0 !== r3.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var h21 = h8.redSqr(), h31 = h21.redMul(h8), v3 = u11.redMul(h21), nx1 = r3.redSqr().redIAdd(h31).redISub(v3).redISub(v3), ny1 = r3.redMul(v3.redISub(nx1)).redISub(s11.redMul(h31)), nz1 = this.z.redMul(p3.z).redMul(h8);
                return this.curve.jpoint(nx1, ny1, nz1);
            }, JPoint1.prototype.mixedAdd = function(p3) {
                if (this.isInfinity()) return p3.toJ();
                if (p3.isInfinity()) return this;
                var z21 = this.z.redSqr(), u11 = this.x, u21 = p3.x.redMul(z21), s11 = this.y, s21 = p3.y.redMul(z21).redMul(this.z), h8 = u11.redSub(u21), r3 = s11.redSub(s21);
                if (0 === h8.cmpn(0)) return 0 !== r3.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var h21 = h8.redSqr(), h31 = h21.redMul(h8), v3 = u11.redMul(h21), nx1 = r3.redSqr().redIAdd(h31).redISub(v3).redISub(v3), ny1 = r3.redMul(v3.redISub(nx1)).redISub(s11.redMul(h31)), nz1 = this.z.redMul(h8);
                return this.curve.jpoint(nx1, ny1, nz1);
            }, JPoint1.prototype.dblp = function(pow1) {
                if (0 === pow1 || this.isInfinity()) return this;
                if (!pow1) return this.dbl();
                if (this.curve.zeroA || this.curve.threeA) {
                    var i2, r3 = this;
                    for(i2 = 0; i2 < pow1; i2++)r3 = r3.dbl();
                    return r3;
                }
                var a10 = this.curve.a, tinv1 = this.curve.tinv, jx1 = this.x, jy1 = this.y, jz1 = this.z, jz41 = jz1.redSqr().redSqr(), jyd1 = jy1.redAdd(jy1);
                for(i2 = 0; i2 < pow1; i2++){
                    var jx21 = jx1.redSqr(), jyd21 = jyd1.redSqr(), jyd41 = jyd21.redSqr(), c5 = jx21.redAdd(jx21).redIAdd(jx21).redIAdd(a10.redMul(jz41)), t11 = jx1.redMul(jyd21), nx1 = c5.redSqr().redISub(t11.redAdd(t11)), t21 = t11.redISub(nx1), dny1 = c5.redMul(t21);
                    dny1 = dny1.redIAdd(dny1).redISub(jyd41);
                    var nz1 = jyd1.redMul(jz1);
                    i2 + 1 < pow1 && (jz41 = jz41.redMul(jyd41)), jx1 = nx1, jz1 = nz1, jyd1 = dny1;
                }
                return this.curve.jpoint(jx1, jyd1.redMul(tinv1), jz1);
            }, JPoint1.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
            }, JPoint1.prototype._zeroDbl = function() {
                if (this.zOne) {
                    var nx1, ny1, nz1, xx1 = this.x.redSqr(), yy1 = this.y.redSqr(), yyyy1 = yy1.redSqr(), s3 = this.x.redAdd(yy1).redSqr().redISub(xx1).redISub(yyyy1);
                    s3 = s3.redIAdd(s3);
                    var m1 = xx1.redAdd(xx1).redIAdd(xx1), t3 = m1.redSqr().redISub(s3).redISub(s3), yyyy81 = yyyy1.redIAdd(yyyy1);
                    yyyy81 = (yyyy81 = yyyy81.redIAdd(yyyy81)).redIAdd(yyyy81), nx1 = t3, ny1 = m1.redMul(s3.redISub(t3)).redISub(yyyy81), nz1 = this.y.redAdd(this.y);
                } else {
                    var a10 = this.x.redSqr(), b10 = this.y.redSqr(), c5 = b10.redSqr(), d3 = this.x.redAdd(b10).redSqr().redISub(a10).redISub(c5);
                    d3 = d3.redIAdd(d3);
                    var e1 = a10.redAdd(a10).redIAdd(a10), f1 = e1.redSqr(), c81 = c5.redIAdd(c5);
                    c81 = (c81 = c81.redIAdd(c81)).redIAdd(c81), nx1 = f1.redISub(d3).redISub(d3), ny1 = e1.redMul(d3.redISub(nx1)).redISub(c81), nz1 = (nz1 = this.y.redMul(this.z)).redIAdd(nz1);
                }
                return this.curve.jpoint(nx1, ny1, nz1);
            }, JPoint1.prototype._threeDbl = function() {
                if (this.zOne) {
                    var nx1, ny1, nz1, xx1 = this.x.redSqr(), yy1 = this.y.redSqr(), yyyy1 = yy1.redSqr(), s3 = this.x.redAdd(yy1).redSqr().redISub(xx1).redISub(yyyy1);
                    s3 = s3.redIAdd(s3);
                    var m1 = xx1.redAdd(xx1).redIAdd(xx1).redIAdd(this.curve.a), t3 = m1.redSqr().redISub(s3).redISub(s3);
                    nx1 = t3;
                    var yyyy81 = yyyy1.redIAdd(yyyy1);
                    yyyy81 = (yyyy81 = yyyy81.redIAdd(yyyy81)).redIAdd(yyyy81), ny1 = m1.redMul(s3.redISub(t3)).redISub(yyyy81), nz1 = this.y.redAdd(this.y);
                } else {
                    var delta1 = this.z.redSqr(), gamma1 = this.y.redSqr(), beta1 = this.x.redMul(gamma1), alpha1 = this.x.redSub(delta1).redMul(this.x.redAdd(delta1));
                    alpha1 = alpha1.redAdd(alpha1).redIAdd(alpha1);
                    var beta41 = beta1.redIAdd(beta1), beta81 = (beta41 = beta41.redIAdd(beta41)).redAdd(beta41);
                    nx1 = alpha1.redSqr().redISub(beta81), nz1 = this.y.redAdd(this.z).redSqr().redISub(gamma1).redISub(delta1);
                    var ggamma81 = gamma1.redSqr();
                    ggamma81 = (ggamma81 = (ggamma81 = ggamma81.redIAdd(ggamma81)).redIAdd(ggamma81)).redIAdd(ggamma81), ny1 = alpha1.redMul(beta41.redISub(nx1)).redISub(ggamma81);
                }
                return this.curve.jpoint(nx1, ny1, nz1);
            }, JPoint1.prototype._dbl = function() {
                var a10 = this.curve.a, jx1 = this.x, jy1 = this.y, jz1 = this.z, jz41 = jz1.redSqr().redSqr(), jx21 = jx1.redSqr(), jy21 = jy1.redSqr(), c5 = jx21.redAdd(jx21).redIAdd(jx21).redIAdd(a10.redMul(jz41)), jxd41 = jx1.redAdd(jx1), t11 = (jxd41 = jxd41.redIAdd(jxd41)).redMul(jy21), nx1 = c5.redSqr().redISub(t11.redAdd(t11)), t21 = t11.redISub(nx1), jyd81 = jy21.redSqr();
                jyd81 = (jyd81 = (jyd81 = jyd81.redIAdd(jyd81)).redIAdd(jyd81)).redIAdd(jyd81);
                var ny1 = c5.redMul(t21).redISub(jyd81), nz1 = jy1.redAdd(jy1).redMul(jz1);
                return this.curve.jpoint(nx1, ny1, nz1);
            }, JPoint1.prototype.trpl = function() {
                if (!this.curve.zeroA) return this.dbl().add(this);
                var xx1 = this.x.redSqr(), yy1 = this.y.redSqr(), zz1 = this.z.redSqr(), yyyy1 = yy1.redSqr(), m1 = xx1.redAdd(xx1).redIAdd(xx1), mm1 = m1.redSqr(), e1 = this.x.redAdd(yy1).redSqr().redISub(xx1).redISub(yyyy1), ee1 = (e1 = (e1 = (e1 = e1.redIAdd(e1)).redAdd(e1).redIAdd(e1)).redISub(mm1)).redSqr(), t3 = yyyy1.redIAdd(yyyy1);
                t3 = (t3 = (t3 = t3.redIAdd(t3)).redIAdd(t3)).redIAdd(t3);
                var u3 = m1.redIAdd(e1).redSqr().redISub(mm1).redISub(ee1).redISub(t3), yyu41 = yy1.redMul(u3);
                yyu41 = (yyu41 = yyu41.redIAdd(yyu41)).redIAdd(yyu41);
                var nx1 = this.x.redMul(ee1).redISub(yyu41);
                nx1 = (nx1 = nx1.redIAdd(nx1)).redIAdd(nx1);
                var ny1 = this.y.redMul(u3.redMul(t3.redISub(u3)).redISub(e1.redMul(ee1)));
                ny1 = (ny1 = (ny1 = ny1.redIAdd(ny1)).redIAdd(ny1)).redIAdd(ny1);
                var nz1 = this.z.redAdd(e1).redSqr().redISub(zz1).redISub(ee1);
                return this.curve.jpoint(nx1, ny1, nz1);
            }, JPoint1.prototype.mul = function(k3, kbase1) {
                return k3 = new BN1(k3, kbase1), this.curve._wnafMul(this, k3);
            }, JPoint1.prototype.eq = function(p3) {
                if ('affine' === p3.type) return this.eq(p3.toJ());
                if (this === p3) return !0;
                var z21 = this.z.redSqr(), pz21 = p3.z.redSqr();
                if (0 !== this.x.redMul(pz21).redISub(p3.x.redMul(z21)).cmpn(0)) return !1;
                var z31 = z21.redMul(this.z), pz31 = pz21.redMul(p3.z);
                return 0 === this.y.redMul(pz31).redISub(p3.y.redMul(z31)).cmpn(0);
            }, JPoint1.prototype.eqXToP = function(x3) {
                var zs1 = this.z.redSqr(), rx1 = x3.toRed(this.curve.red).redMul(zs1);
                if (0 === this.x.cmp(rx1)) return !0;
                for(var xc1 = x3.clone(), t3 = this.curve.redN.redMul(zs1);;){
                    if (xc1.iadd(this.curve.n), xc1.cmp(this.curve.p) >= 0) return !1;
                    if (rx1.redIAdd(t3), 0 === this.x.cmp(rx1)) return !0;
                }
            }, JPoint1.prototype.inspect = function() {
                return this.isInfinity() ? '<EC JPoint Infinity>' : '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
            }, JPoint1.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0);
            };
        },
        5427: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var pre1, curves1 = exports1, hash1 = __webpack_require__1(3715), curve1 = __webpack_require__1(8254), assert1 = __webpack_require__1(953).assert;
            function PresetCurve1(options1) {
                'short' === options1.type ? this.curve = new curve1.short(options1) : 'edwards' === options1.type ? this.curve = new curve1.edwards(options1) : this.curve = new curve1.mont(options1), this.g = this.curve.g, this.n = this.curve.n, this.hash = options1.hash, assert1(this.g.validate(), 'Invalid curve'), assert1(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
            }
            function defineCurve1(name1, options1) {
                Object.defineProperty(curves1, name1, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        var curve1 = new PresetCurve1(options1);
                        return Object.defineProperty(curves1, name1, {
                            configurable: !0,
                            enumerable: !0,
                            value: curve1
                        }), curve1;
                    }
                });
            }
            curves1.PresetCurve = PresetCurve1, defineCurve1('p192', {
                type: 'short',
                prime: 'p192',
                p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
                b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
                n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
                hash: hash1.sha256,
                gRed: !1,
                g: [
                    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
                    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
                ]
            }), defineCurve1('p224', {
                type: 'short',
                prime: 'p224',
                p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
                b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
                n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
                hash: hash1.sha256,
                gRed: !1,
                g: [
                    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
                    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
                ]
            }), defineCurve1('p256', {
                type: 'short',
                prime: null,
                p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
                a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
                b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
                n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
                hash: hash1.sha256,
                gRed: !1,
                g: [
                    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
                    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
                ]
            }), defineCurve1('p384', {
                type: 'short',
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: hash1.sha384,
                gRed: !1,
                g: [
                    "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                    "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
                ]
            }), defineCurve1('p521', {
                type: 'short',
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: hash1.sha512,
                gRed: !1,
                g: [
                    "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                    "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
                ]
            }), defineCurve1('curve25519', {
                type: 'mont',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '76d06',
                b: '1',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash1.sha256,
                gRed: !1,
                g: [
                    '9'
                ]
            }), defineCurve1('ed25519', {
                type: 'edwards',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '-1',
                c: '1',
                d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash1.sha256,
                gRed: !1,
                g: [
                    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
                    '6666666666666666666666666666666666666666666666666666666666666658'
                ]
            });
            try {
                pre1 = __webpack_require__1(1037);
            } catch (e1) {
                pre1 = void 0;
            }
            defineCurve1('secp256k1', {
                type: 'short',
                prime: 'k256',
                p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
                a: '0',
                b: '7',
                n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
                h: '1',
                hash: hash1.sha256,
                beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
                lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
                basis: [
                    {
                        a: '3086d221a7d46bcde86c90e49284eb15',
                        b: '-e4437ed6010e88286f547fa90abfe4c3'
                    },
                    {
                        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                        b: '3086d221a7d46bcde86c90e49284eb15'
                    }
                ],
                gRed: !1,
                g: [
                    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
                    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                    pre1
                ]
            });
        },
        7954: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var BN1 = __webpack_require__1(3550), HmacDRBG1 = __webpack_require__1(2156), utils1 = __webpack_require__1(953), curves1 = __webpack_require__1(5427), rand1 = __webpack_require__1(9931), assert1 = utils1.assert, KeyPair1 = __webpack_require__1(1251), Signature1 = __webpack_require__1(611);
            function EC1(options1) {
                if (!(this instanceof EC1)) return new EC1(options1);
                'string' == typeof options1 && (assert1(Object.prototype.hasOwnProperty.call(curves1, options1), 'Unknown curve ' + options1), options1 = curves1[options1]), options1 instanceof curves1.PresetCurve && (options1 = {
                    curve: options1
                }), this.curve = options1.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options1.curve.g, this.g.precompute(options1.curve.n.bitLength() + 1), this.hash = options1.hash || options1.curve.hash;
            }
            module1.exports = EC1, EC1.prototype.keyPair = function(options1) {
                return new KeyPair1(this, options1);
            }, EC1.prototype.keyFromPrivate = function(priv1, enc1) {
                return KeyPair1.fromPrivate(this, priv1, enc1);
            }, EC1.prototype.keyFromPublic = function(pub1, enc1) {
                return KeyPair1.fromPublic(this, pub1, enc1);
            }, EC1.prototype.genKeyPair = function(options1) {
                options1 || (options1 = {});
                for(var drbg1 = new HmacDRBG1({
                    hash: this.hash,
                    pers: options1.pers,
                    persEnc: options1.persEnc || 'utf8',
                    entropy: options1.entropy || rand1(this.hash.hmacStrength),
                    entropyEnc: options1.entropy && options1.entropyEnc || 'utf8',
                    nonce: this.n.toArray()
                }), bytes1 = this.n.byteLength(), ns21 = this.n.sub(new BN1(2));;){
                    var priv1 = new BN1(drbg1.generate(bytes1));
                    if (!(priv1.cmp(ns21) > 0)) return priv1.iaddn(1), this.keyFromPrivate(priv1);
                }
            }, EC1.prototype._truncateToN = function(msg1, truncOnly1) {
                var delta1 = 8 * msg1.byteLength() - this.n.bitLength();
                return (delta1 > 0 && (msg1 = msg1.ushrn(delta1)), !truncOnly1 && msg1.cmp(this.n) >= 0) ? msg1.sub(this.n) : msg1;
            }, EC1.prototype.sign = function(msg1, key1, enc1, options1) {
                'object' == typeof enc1 && (options1 = enc1, enc1 = null), options1 || (options1 = {}), key1 = this.keyFromPrivate(key1, enc1), msg1 = this._truncateToN(new BN1(msg1, 16));
                for(var bytes1 = this.n.byteLength(), bkey1 = key1.getPrivate().toArray('be', bytes1), nonce1 = msg1.toArray('be', bytes1), drbg1 = new HmacDRBG1({
                    hash: this.hash,
                    entropy: bkey1,
                    nonce: nonce1,
                    pers: options1.pers,
                    persEnc: options1.persEnc || 'utf8'
                }), ns11 = this.n.sub(new BN1(1)), iter1 = 0;; iter1++){
                    var k3 = options1.k ? options1.k(iter1) : new BN1(drbg1.generate(this.n.byteLength()));
                    if (!(0 >= (k3 = this._truncateToN(k3, !0)).cmpn(1) || k3.cmp(ns11) >= 0)) {
                        var kp1 = this.g.mul(k3);
                        if (!kp1.isInfinity()) {
                            var kpX1 = kp1.getX(), r3 = kpX1.umod(this.n);
                            if (0 !== r3.cmpn(0)) {
                                var s3 = k3.invm(this.n).mul(r3.mul(key1.getPrivate()).iadd(msg1));
                                if (0 !== (s3 = s3.umod(this.n)).cmpn(0)) {
                                    var recoveryParam1 = (kp1.getY().isOdd() ? 1 : 0) | (0 !== kpX1.cmp(r3) ? 2 : 0);
                                    return options1.canonical && s3.cmp(this.nh) > 0 && (s3 = this.n.sub(s3), recoveryParam1 ^= 1), new Signature1({
                                        r: r3,
                                        s: s3,
                                        recoveryParam: recoveryParam1
                                    });
                                }
                            }
                        }
                    }
                }
            }, EC1.prototype.verify = function(msg1, signature1, key1, enc1) {
                msg1 = this._truncateToN(new BN1(msg1, 16)), key1 = this.keyFromPublic(key1, enc1);
                var p3, r3 = (signature1 = new Signature1(signature1, 'hex')).r, s3 = signature1.s;
                if (0 > r3.cmpn(1) || r3.cmp(this.n) >= 0 || 0 > s3.cmpn(1) || s3.cmp(this.n) >= 0) return !1;
                var sinv1 = s3.invm(this.n), u11 = sinv1.mul(msg1).umod(this.n), u21 = sinv1.mul(r3).umod(this.n);
                return this.curve._maxwellTrick ? !(p3 = this.g.jmulAdd(u11, key1.getPublic(), u21)).isInfinity() && p3.eqXToP(r3) : !(p3 = this.g.mulAdd(u11, key1.getPublic(), u21)).isInfinity() && 0 === p3.getX().umod(this.n).cmp(r3);
            }, EC1.prototype.recoverPubKey = function(msg1, signature1, j1, enc1) {
                assert1((3 & j1) === j1, 'The recovery param is more than two bits'), signature1 = new Signature1(signature1, enc1);
                var n2 = this.n, e1 = new BN1(msg1), r3 = signature1.r, s3 = signature1.s, isYOdd1 = 1 & j1, isSecondKey1 = j1 >> 1;
                if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey1) throw Error('Unable to find sencond key candinate');
                r3 = isSecondKey1 ? this.curve.pointFromX(r3.add(this.curve.n), isYOdd1) : this.curve.pointFromX(r3, isYOdd1);
                var rInv1 = signature1.r.invm(n2), s11 = n2.sub(e1).mul(rInv1).umod(n2), s21 = s3.mul(rInv1).umod(n2);
                return this.g.mulAdd(s11, r3, s21);
            }, EC1.prototype.getKeyRecoveryParam = function(e1, signature1, Q1, enc1) {
                if (null !== (signature1 = new Signature1(signature1, enc1)).recoveryParam) return signature1.recoveryParam;
                for(var Qprime1, i2 = 0; i2 < 4; i2++){
                    try {
                        Qprime1 = this.recoverPubKey(e1, signature1, i2);
                    } catch (e1) {
                        continue;
                    }
                    if (Qprime1.eq(Q1)) return i2;
                }
                throw Error('Unable to find valid recovery factor');
            };
        },
        1251: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var BN1 = __webpack_require__1(3550), assert1 = __webpack_require__1(953).assert;
            function KeyPair1(ec1, options1) {
                this.ec = ec1, this.priv = null, this.pub = null, options1.priv && this._importPrivate(options1.priv, options1.privEnc), options1.pub && this._importPublic(options1.pub, options1.pubEnc);
            }
            module1.exports = KeyPair1, KeyPair1.fromPublic = function(ec1, pub1, enc1) {
                return pub1 instanceof KeyPair1 ? pub1 : new KeyPair1(ec1, {
                    pub: pub1,
                    pubEnc: enc1
                });
            }, KeyPair1.fromPrivate = function(ec1, priv1, enc1) {
                return priv1 instanceof KeyPair1 ? priv1 : new KeyPair1(ec1, {
                    priv: priv1,
                    privEnc: enc1
                });
            }, KeyPair1.prototype.validate = function() {
                var pub1 = this.getPublic();
                return pub1.isInfinity() ? {
                    result: !1,
                    reason: 'Invalid public key'
                } : pub1.validate() ? pub1.mul(this.ec.curve.n).isInfinity() ? {
                    result: !0,
                    reason: null
                } : {
                    result: !1,
                    reason: 'Public key * N != O'
                } : {
                    result: !1,
                    reason: 'Public key is not a point'
                };
            }, KeyPair1.prototype.getPublic = function(compact1, enc1) {
                return ('string' == typeof compact1 && (enc1 = compact1, compact1 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), enc1) ? this.pub.encode(enc1, compact1) : this.pub;
            }, KeyPair1.prototype.getPrivate = function(enc1) {
                return 'hex' === enc1 ? this.priv.toString(16, 2) : this.priv;
            }, KeyPair1.prototype._importPrivate = function(key1, enc1) {
                this.priv = new BN1(key1, enc1 || 16), this.priv = this.priv.umod(this.ec.curve.n);
            }, KeyPair1.prototype._importPublic = function(key1, enc1) {
                if (key1.x || key1.y) {
                    'mont' === this.ec.curve.type ? assert1(key1.x, 'Need x coordinate') : ('short' === this.ec.curve.type || 'edwards' === this.ec.curve.type) && assert1(key1.x && key1.y, 'Need both x and y coordinate'), this.pub = this.ec.curve.point(key1.x, key1.y);
                    return;
                }
                this.pub = this.ec.curve.decodePoint(key1, enc1);
            }, KeyPair1.prototype.derive = function(pub1) {
                return pub1.validate() || assert1(pub1.validate(), 'public point not validated'), pub1.mul(this.priv).getX();
            }, KeyPair1.prototype.sign = function(msg1, enc1, options1) {
                return this.ec.sign(msg1, this, enc1, options1);
            }, KeyPair1.prototype.verify = function(msg1, signature1) {
                return this.ec.verify(msg1, signature1, this);
            }, KeyPair1.prototype.inspect = function() {
                return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
            };
        },
        611: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var BN1 = __webpack_require__1(3550), utils1 = __webpack_require__1(953), assert1 = utils1.assert;
            function Signature1(options1, enc1) {
                if (options1 instanceof Signature1) return options1;
                this._importDER(options1, enc1) || (assert1(options1.r && options1.s, 'Signature without r or s'), this.r = new BN1(options1.r, 16), this.s = new BN1(options1.s, 16), void 0 === options1.recoveryParam ? this.recoveryParam = null : this.recoveryParam = options1.recoveryParam);
            }
            function Position1() {
                this.place = 0;
            }
            function getLength1(buf1, p3) {
                var initial1 = buf1[p3.place++];
                if (!(0x80 & initial1)) return initial1;
                var octetLen1 = 0xf & initial1;
                if (0 === octetLen1 || octetLen1 > 4) return !1;
                for(var val1 = 0, i2 = 0, off1 = p3.place; i2 < octetLen1; i2++, off1++)val1 <<= 8, val1 |= buf1[off1], val1 >>>= 0;
                return !(val1 <= 0x7f) && (p3.place = off1, val1);
            }
            function rmPadding1(buf1) {
                for(var i2 = 0, len3 = buf1.length - 1; !buf1[i2] && !(0x80 & buf1[i2 + 1]) && i2 < len3;)i2++;
                return 0 === i2 ? buf1 : buf1.slice(i2);
            }
            function constructLength1(arr1, len3) {
                if (len3 < 0x80) {
                    arr1.push(len3);
                    return;
                }
                var octets1 = 1 + (Math.log(len3) / Math.LN2 >>> 3);
                for(arr1.push(0x80 | octets1); --octets1;)arr1.push(len3 >>> (octets1 << 3) & 0xff);
                arr1.push(len3);
            }
            module1.exports = Signature1, Signature1.prototype._importDER = function(data1, enc1) {
                data1 = utils1.toArray(data1, enc1);
                var p3 = new Position1();
                if (0x30 !== data1[p3.place++]) return !1;
                var len3 = getLength1(data1, p3);
                if (!1 === len3 || len3 + p3.place !== data1.length || 0x02 !== data1[p3.place++]) return !1;
                var rlen1 = getLength1(data1, p3);
                if (!1 === rlen1) return !1;
                var r3 = data1.slice(p3.place, rlen1 + p3.place);
                if (p3.place += rlen1, 0x02 !== data1[p3.place++]) return !1;
                var slen1 = getLength1(data1, p3);
                if (!1 === slen1 || data1.length !== slen1 + p3.place) return !1;
                var s3 = data1.slice(p3.place, slen1 + p3.place);
                if (0 === r3[0]) {
                    if (!(0x80 & r3[1])) return !1;
                    r3 = r3.slice(1);
                }
                if (0 === s3[0]) {
                    if (!(0x80 & s3[1])) return !1;
                    s3 = s3.slice(1);
                }
                return this.r = new BN1(r3), this.s = new BN1(s3), this.recoveryParam = null, !0;
            }, Signature1.prototype.toDER = function(enc1) {
                var r3 = this.r.toArray(), s3 = this.s.toArray();
                for(0x80 & r3[0] && (r3 = [
                    0
                ].concat(r3)), 0x80 & s3[0] && (s3 = [
                    0
                ].concat(s3)), r3 = rmPadding1(r3), s3 = rmPadding1(s3); !s3[0] && !(0x80 & s3[1]);)s3 = s3.slice(1);
                var arr1 = [
                    0x02
                ];
                constructLength1(arr1, r3.length), (arr1 = arr1.concat(r3)).push(0x02), constructLength1(arr1, s3.length);
                var backHalf1 = arr1.concat(s3), res1 = [
                    0x30
                ];
                return constructLength1(res1, backHalf1.length), res1 = res1.concat(backHalf1), utils1.encode(res1, enc1);
            };
        },
        5980: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var hash1 = __webpack_require__1(3715), curves1 = __webpack_require__1(5427), utils1 = __webpack_require__1(953), assert1 = utils1.assert, parseBytes1 = utils1.parseBytes, KeyPair1 = __webpack_require__1(9087), Signature1 = __webpack_require__1(3622);
            function EDDSA1(curve1) {
                if (assert1('ed25519' === curve1, 'only tested with ed25519 so far'), !(this instanceof EDDSA1)) return new EDDSA1(curve1);
                curve1 = curves1[curve1].curve, this.curve = curve1, this.g = curve1.g, this.g.precompute(curve1.n.bitLength() + 1), this.pointClass = curve1.point().constructor, this.encodingLength = Math.ceil(curve1.n.bitLength() / 8), this.hash = hash1.sha512;
            }
            module1.exports = EDDSA1, EDDSA1.prototype.sign = function(message1, secret1) {
                message1 = parseBytes1(message1);
                var key1 = this.keyFromSecret(secret1), r3 = this.hashInt(key1.messagePrefix(), message1), R1 = this.g.mul(r3), Rencoded1 = this.encodePoint(R1), s_1 = this.hashInt(Rencoded1, key1.pubBytes(), message1).mul(key1.priv()), S1 = r3.add(s_1).umod(this.curve.n);
                return this.makeSignature({
                    R: R1,
                    S: S1,
                    Rencoded: Rencoded1
                });
            }, EDDSA1.prototype.verify = function(message1, sig1, pub1) {
                message1 = parseBytes1(message1), sig1 = this.makeSignature(sig1);
                var key1 = this.keyFromPublic(pub1), h8 = this.hashInt(sig1.Rencoded(), key1.pubBytes(), message1), SG1 = this.g.mul(sig1.S());
                return sig1.R().add(key1.pub().mul(h8)).eq(SG1);
            }, EDDSA1.prototype.hashInt = function() {
                for(var hash1 = this.hash(), i2 = 0; i2 < arguments.length; i2++)hash1.update(arguments[i2]);
                return utils1.intFromLE(hash1.digest()).umod(this.curve.n);
            }, EDDSA1.prototype.keyFromPublic = function(pub1) {
                return KeyPair1.fromPublic(this, pub1);
            }, EDDSA1.prototype.keyFromSecret = function(secret1) {
                return KeyPair1.fromSecret(this, secret1);
            }, EDDSA1.prototype.makeSignature = function(sig1) {
                return sig1 instanceof Signature1 ? sig1 : new Signature1(this, sig1);
            }, EDDSA1.prototype.encodePoint = function(point1) {
                var enc1 = point1.getY().toArray('le', this.encodingLength);
                return enc1[this.encodingLength - 1] |= point1.getX().isOdd() ? 0x80 : 0, enc1;
            }, EDDSA1.prototype.decodePoint = function(bytes1) {
                var lastIx1 = (bytes1 = utils1.parseBytes(bytes1)).length - 1, normed1 = bytes1.slice(0, lastIx1).concat(-129 & bytes1[lastIx1]), xIsOdd1 = (0x80 & bytes1[lastIx1]) != 0, y3 = utils1.intFromLE(normed1);
                return this.curve.pointFromY(y3, xIsOdd1);
            }, EDDSA1.prototype.encodeInt = function(num1) {
                return num1.toArray('le', this.encodingLength);
            }, EDDSA1.prototype.decodeInt = function(bytes1) {
                return utils1.intFromLE(bytes1);
            }, EDDSA1.prototype.isPoint = function(val1) {
                return val1 instanceof this.pointClass;
            };
        },
        9087: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(953), assert1 = utils1.assert, parseBytes1 = utils1.parseBytes, cachedProperty1 = utils1.cachedProperty;
            function KeyPair1(eddsa1, params1) {
                this.eddsa = eddsa1, this._secret = parseBytes1(params1.secret), eddsa1.isPoint(params1.pub) ? this._pub = params1.pub : this._pubBytes = parseBytes1(params1.pub);
            }
            KeyPair1.fromPublic = function(eddsa1, pub1) {
                return pub1 instanceof KeyPair1 ? pub1 : new KeyPair1(eddsa1, {
                    pub: pub1
                });
            }, KeyPair1.fromSecret = function(eddsa1, secret1) {
                return secret1 instanceof KeyPair1 ? secret1 : new KeyPair1(eddsa1, {
                    secret: secret1
                });
            }, KeyPair1.prototype.secret = function() {
                return this._secret;
            }, cachedProperty1(KeyPair1, 'pubBytes', function() {
                return this.eddsa.encodePoint(this.pub());
            }), cachedProperty1(KeyPair1, 'pub', function() {
                return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
            }), cachedProperty1(KeyPair1, 'privBytes', function() {
                var eddsa1 = this.eddsa, hash1 = this.hash(), lastIx1 = eddsa1.encodingLength - 1, a10 = hash1.slice(0, eddsa1.encodingLength);
                return a10[0] &= 248, a10[lastIx1] &= 127, a10[lastIx1] |= 64, a10;
            }), cachedProperty1(KeyPair1, 'priv', function() {
                return this.eddsa.decodeInt(this.privBytes());
            }), cachedProperty1(KeyPair1, 'hash', function() {
                return this.eddsa.hash().update(this.secret()).digest();
            }), cachedProperty1(KeyPair1, 'messagePrefix', function() {
                return this.hash().slice(this.eddsa.encodingLength);
            }), KeyPair1.prototype.sign = function(message1) {
                return assert1(this._secret, 'KeyPair can only verify'), this.eddsa.sign(message1, this);
            }, KeyPair1.prototype.verify = function(message1, sig1) {
                return this.eddsa.verify(message1, sig1, this);
            }, KeyPair1.prototype.getSecret = function(enc1) {
                return assert1(this._secret, 'KeyPair is public only'), utils1.encode(this.secret(), enc1);
            }, KeyPair1.prototype.getPublic = function(enc1) {
                return utils1.encode(this.pubBytes(), enc1);
            }, module1.exports = KeyPair1;
        },
        3622: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var BN1 = __webpack_require__1(3550), utils1 = __webpack_require__1(953), assert1 = utils1.assert, cachedProperty1 = utils1.cachedProperty, parseBytes1 = utils1.parseBytes;
            function Signature1(eddsa1, sig1) {
                this.eddsa = eddsa1, 'object' != typeof sig1 && (sig1 = parseBytes1(sig1)), Array.isArray(sig1) && (sig1 = {
                    R: sig1.slice(0, eddsa1.encodingLength),
                    S: sig1.slice(eddsa1.encodingLength)
                }), assert1(sig1.R && sig1.S, 'Signature without R or S'), eddsa1.isPoint(sig1.R) && (this._R = sig1.R), sig1.S instanceof BN1 && (this._S = sig1.S), this._Rencoded = Array.isArray(sig1.R) ? sig1.R : sig1.Rencoded, this._Sencoded = Array.isArray(sig1.S) ? sig1.S : sig1.Sencoded;
            }
            cachedProperty1(Signature1, 'S', function() {
                return this.eddsa.decodeInt(this.Sencoded());
            }), cachedProperty1(Signature1, 'R', function() {
                return this.eddsa.decodePoint(this.Rencoded());
            }), cachedProperty1(Signature1, 'Rencoded', function() {
                return this.eddsa.encodePoint(this.R());
            }), cachedProperty1(Signature1, 'Sencoded', function() {
                return this.eddsa.encodeInt(this.S());
            }), Signature1.prototype.toBytes = function() {
                return this.Rencoded().concat(this.Sencoded());
            }, Signature1.prototype.toHex = function() {
                return utils1.encode(this.toBytes(), 'hex').toUpperCase();
            }, module1.exports = Signature1;
        },
        1037: function(module1) {
            module1.exports = {
                doubles: {
                    step: 4,
                    points: [
                        [
                            'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                            'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
                        ],
                        [
                            '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                            '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
                        ],
                        [
                            '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                            'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
                        ],
                        [
                            '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                            '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
                        ],
                        [
                            '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                            '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
                        ],
                        [
                            '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                            '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
                        ],
                        [
                            'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                            '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
                        ],
                        [
                            '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                            'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
                        ],
                        [
                            'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                            '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
                        ],
                        [
                            'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                            'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
                        ],
                        [
                            'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                            '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
                        ],
                        [
                            '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                            '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
                        ],
                        [
                            '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                            '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
                        ],
                        [
                            '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                            '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
                        ],
                        [
                            '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                            '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
                        ],
                        [
                            '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                            '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
                        ],
                        [
                            '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                            '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
                        ],
                        [
                            '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                            '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
                        ],
                        [
                            '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                            'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
                        ],
                        [
                            'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                            '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
                        ],
                        [
                            'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                            '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
                        ],
                        [
                            '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                            '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
                        ],
                        [
                            '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                            '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
                        ],
                        [
                            'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                            '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
                        ],
                        [
                            '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                            'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
                        ],
                        [
                            'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                            '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
                        ],
                        [
                            'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                            'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
                        ],
                        [
                            'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                            '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
                        ],
                        [
                            'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                            'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
                        ],
                        [
                            'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                            '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
                        ],
                        [
                            '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                            'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
                        ],
                        [
                            '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                            '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
                        ],
                        [
                            'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                            '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
                        ],
                        [
                            '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                            'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
                        ],
                        [
                            'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                            '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
                        ],
                        [
                            'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                            '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
                        ],
                        [
                            'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                            'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
                        ],
                        [
                            '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                            '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
                        ],
                        [
                            '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                            '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
                        ],
                        [
                            '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                            'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
                        ],
                        [
                            '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                            '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
                        ],
                        [
                            'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                            '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
                        ],
                        [
                            '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                            '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
                        ],
                        [
                            '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                            'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
                        ],
                        [
                            '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                            '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
                        ],
                        [
                            'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                            '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
                        ],
                        [
                            '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                            'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
                        ],
                        [
                            'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                            'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
                        ],
                        [
                            'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                            '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
                        ],
                        [
                            '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                            'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
                        ],
                        [
                            '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                            'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
                        ],
                        [
                            'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                            '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
                        ],
                        [
                            'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                            '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
                        ],
                        [
                            'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                            '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
                        ],
                        [
                            '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                            'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
                        ],
                        [
                            '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                            '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
                        ],
                        [
                            'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                            'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
                        ],
                        [
                            '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                            'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
                        ],
                        [
                            '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                            '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
                        ],
                        [
                            '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                            '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
                        ],
                        [
                            'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                            'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
                        ],
                        [
                            '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                            '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
                        ],
                        [
                            '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                            '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
                        ],
                        [
                            'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                            '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
                        ],
                        [
                            'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                            'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
                        ]
                    ]
                },
                naf: {
                    wnd: 7,
                    points: [
                        [
                            'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                            '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
                        ],
                        [
                            '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                            'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
                        ],
                        [
                            '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                            '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
                        ],
                        [
                            'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                            'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
                        ],
                        [
                            '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                            'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
                        ],
                        [
                            'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                            'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
                        ],
                        [
                            'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                            '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
                        ],
                        [
                            'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                            '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
                        ],
                        [
                            '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                            '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
                        ],
                        [
                            '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                            '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
                        ],
                        [
                            '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                            '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
                        ],
                        [
                            '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                            '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
                        ],
                        [
                            'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                            'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
                        ],
                        [
                            'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                            '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
                        ],
                        [
                            '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                            'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
                        ],
                        [
                            '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                            'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
                        ],
                        [
                            '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                            '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
                        ],
                        [
                            '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                            '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
                        ],
                        [
                            '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                            '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
                        ],
                        [
                            '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                            'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
                        ],
                        [
                            'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                            'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
                        ],
                        [
                            '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                            '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
                        ],
                        [
                            '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                            '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
                        ],
                        [
                            'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                            'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
                        ],
                        [
                            '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                            '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
                        ],
                        [
                            'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                            'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
                        ],
                        [
                            'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                            'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
                        ],
                        [
                            '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                            '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
                        ],
                        [
                            '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                            '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
                        ],
                        [
                            '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                            '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
                        ],
                        [
                            'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                            '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
                        ],
                        [
                            '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                            '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
                        ],
                        [
                            'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                            '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
                        ],
                        [
                            '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                            'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
                        ],
                        [
                            '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                            'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
                        ],
                        [
                            'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                            'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
                        ],
                        [
                            '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                            '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
                        ],
                        [
                            '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                            'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
                        ],
                        [
                            'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                            'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
                        ],
                        [
                            '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                            '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
                        ],
                        [
                            '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                            'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
                        ],
                        [
                            '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                            '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
                        ],
                        [
                            '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                            'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
                        ],
                        [
                            'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                            '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
                        ],
                        [
                            '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                            '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
                        ],
                        [
                            '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                            'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
                        ],
                        [
                            '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                            'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
                        ],
                        [
                            'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                            'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
                        ],
                        [
                            'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                            'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
                        ],
                        [
                            '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                            '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
                        ],
                        [
                            '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                            '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
                        ],
                        [
                            'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                            '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
                        ],
                        [
                            'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                            'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
                        ],
                        [
                            '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                            '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
                        ],
                        [
                            '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                            '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
                        ],
                        [
                            'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                            '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
                        ],
                        [
                            '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                            '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
                        ],
                        [
                            'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                            'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
                        ],
                        [
                            '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                            'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
                        ],
                        [
                            '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                            '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
                        ],
                        [
                            'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                            '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
                        ],
                        [
                            'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                            '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
                        ],
                        [
                            '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                            '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
                        ],
                        [
                            '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                            '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
                        ],
                        [
                            '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                            'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
                        ],
                        [
                            '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                            'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
                        ],
                        [
                            '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                            '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
                        ],
                        [
                            '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                            '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
                        ],
                        [
                            '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                            '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
                        ],
                        [
                            '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                            'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
                        ],
                        [
                            'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                            'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
                        ],
                        [
                            '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                            'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
                        ],
                        [
                            'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                            '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
                        ],
                        [
                            'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                            '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
                        ],
                        [
                            'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                            '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
                        ],
                        [
                            'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                            '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
                        ],
                        [
                            '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                            'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
                        ],
                        [
                            '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                            '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
                        ],
                        [
                            '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                            'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
                        ],
                        [
                            'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                            'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
                        ],
                        [
                            'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                            '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
                        ],
                        [
                            'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                            'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
                        ],
                        [
                            'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                            '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
                        ],
                        [
                            '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                            '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
                        ],
                        [
                            'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                            '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
                        ],
                        [
                            'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                            '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
                        ],
                        [
                            '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                            '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
                        ],
                        [
                            '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                            'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
                        ],
                        [
                            'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                            '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
                        ],
                        [
                            'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                            '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
                        ],
                        [
                            'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                            '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
                        ],
                        [
                            '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                            '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
                        ],
                        [
                            'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                            'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
                        ],
                        [
                            '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                            'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
                        ],
                        [
                            'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                            'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
                        ],
                        [
                            'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                            '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
                        ],
                        [
                            '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                            'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
                        ],
                        [
                            'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                            '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
                        ],
                        [
                            'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                            '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
                        ],
                        [
                            'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                            '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
                        ],
                        [
                            '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                            'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
                        ],
                        [
                            '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                            'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
                        ],
                        [
                            'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                            '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
                        ],
                        [
                            '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                            'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
                        ],
                        [
                            '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                            '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
                        ],
                        [
                            '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                            'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
                        ],
                        [
                            'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                            'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
                        ],
                        [
                            '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                            'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
                        ],
                        [
                            '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                            '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
                        ],
                        [
                            '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                            'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
                        ],
                        [
                            '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                            '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
                        ],
                        [
                            'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                            'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
                        ],
                        [
                            '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                            '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
                        ],
                        [
                            'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                            '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
                        ],
                        [
                            '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                            '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
                        ],
                        [
                            'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                            'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
                        ],
                        [
                            'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                            '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
                        ],
                        [
                            'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                            'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
                        ],
                        [
                            '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                            'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
                        ],
                        [
                            '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                            '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
                        ],
                        [
                            '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                            'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
                        ],
                        [
                            '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                            '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
                        ],
                        [
                            '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                            '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
                        ],
                        [
                            '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                            'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
                        ],
                        [
                            '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                            '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
                        ],
                        [
                            '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                            '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
                        ],
                        [
                            '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                            '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
                        ]
                    ]
                }
            };
        },
        953: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var utils1 = exports1, BN1 = __webpack_require__1(3550), minAssert1 = __webpack_require__1(9746), minUtils1 = __webpack_require__1(4504);
            function getNAF1(num1, w19, bits1) {
                var naf1 = Array(Math.max(num1.bitLength(), bits1) + 1);
                naf1.fill(0);
                for(var ws1 = 1 << w19 + 1, k3 = num1.clone(), i2 = 0; i2 < naf1.length; i2++){
                    var z1, mod1 = k3.andln(ws1 - 1);
                    k3.isOdd() ? (z1 = mod1 > (ws1 >> 1) - 1 ? (ws1 >> 1) - mod1 : mod1, k3.isubn(z1)) : z1 = 0, naf1[i2] = z1, k3.iushrn(1);
                }
                return naf1;
            }
            function getJSF1(k11, k21) {
                var jsf1 = [
                    [],
                    []
                ];
                k11 = k11.clone(), k21 = k21.clone();
                for(var d11 = 0, d21 = 0; k11.cmpn(-d11) > 0 || k21.cmpn(-d21) > 0;){
                    var m81, u11, u21, m141 = k11.andln(3) + d11 & 3, m241 = k21.andln(3) + d21 & 3;
                    3 === m141 && (m141 = -1), 3 === m241 && (m241 = -1), u11 = (1 & m141) == 0 ? 0 : (3 == (m81 = k11.andln(7) + d11 & 7) || 5 === m81) && 2 === m241 ? -m141 : m141, jsf1[0].push(u11), u21 = (1 & m241) == 0 ? 0 : (3 == (m81 = k21.andln(7) + d21 & 7) || 5 === m81) && 2 === m141 ? -m241 : m241, jsf1[1].push(u21), 2 * d11 === u11 + 1 && (d11 = 1 - d11), 2 * d21 === u21 + 1 && (d21 = 1 - d21), k11.iushrn(1), k21.iushrn(1);
                }
                return jsf1;
            }
            function cachedProperty1(obj1, name1, computer1) {
                var key1 = '_' + name1;
                obj1.prototype[name1] = function() {
                    return void 0 !== this[key1] ? this[key1] : this[key1] = computer1.call(this);
                };
            }
            function parseBytes1(bytes1) {
                return 'string' == typeof bytes1 ? utils1.toArray(bytes1, 'hex') : bytes1;
            }
            function intFromLE1(bytes1) {
                return new BN1(bytes1, 'hex', 'le');
            }
            utils1.assert = minAssert1, utils1.toArray = minUtils1.toArray, utils1.zero2 = minUtils1.zero2, utils1.toHex = minUtils1.toHex, utils1.encode = minUtils1.encode, utils1.getNAF = getNAF1, utils1.getJSF = getJSF1, utils1.cachedProperty = cachedProperty1, utils1.parseBytes = parseBytes1, utils1.intFromLE = intFromLE1;
        },
        7187: function(module1) {
            "use strict";
            var ReflectOwnKeys1, R1 = 'object' == typeof Reflect ? Reflect : null, ReflectApply1 = R1 && 'function' == typeof R1.apply ? R1.apply : function(target1, receiver1, args1) {
                return Function.prototype.apply.call(target1, receiver1, args1);
            };
            function ProcessEmitWarning1(warning1) {
                console && console.warn && console.warn(warning1);
            }
            ReflectOwnKeys1 = R1 && 'function' == typeof R1.ownKeys ? R1.ownKeys : Object.getOwnPropertySymbols ? function(target1) {
                return Object.getOwnPropertyNames(target1).concat(Object.getOwnPropertySymbols(target1));
            } : function(target1) {
                return Object.getOwnPropertyNames(target1);
            };
            var NumberIsNaN1 = Number.isNaN || function(value1) {
                return value1 != value1;
            };
            function EventEmitter1() {
                EventEmitter1.init.call(this);
            }
            module1.exports = EventEmitter1, module1.exports.once = once1, EventEmitter1.EventEmitter = EventEmitter1, EventEmitter1.prototype._events = void 0, EventEmitter1.prototype._eventsCount = 0, EventEmitter1.prototype._maxListeners = void 0;
            var defaultMaxListeners1 = 10;
            function checkListener1(listener1) {
                if ('function' != typeof listener1) throw TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener1);
            }
            function _getMaxListeners1(that1) {
                return void 0 === that1._maxListeners ? EventEmitter1.defaultMaxListeners : that1._maxListeners;
            }
            function _addListener1(target1, type1, listener1, prepend1) {
                if (checkListener1(listener1), void 0 === (events1 = target1._events) ? (events1 = target1._events = Object.create(null), target1._eventsCount = 0) : (void 0 !== events1.newListener && (target1.emit('newListener', type1, listener1.listener ? listener1.listener : listener1), events1 = target1._events), existing1 = events1[type1]), void 0 === existing1) existing1 = events1[type1] = listener1, ++target1._eventsCount;
                else if ('function' == typeof existing1 ? existing1 = events1[type1] = prepend1 ? [
                    listener1,
                    existing1
                ] : [
                    existing1,
                    listener1
                ] : prepend1 ? existing1.unshift(listener1) : existing1.push(listener1), (m1 = _getMaxListeners1(target1)) > 0 && existing1.length > m1 && !existing1.warned) {
                    existing1.warned = !0;
                    var m1, events1, existing1, w19 = Error('Possible EventEmitter memory leak detected. ' + existing1.length + ' ' + String(type1) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    w19.name = 'MaxListenersExceededWarning', w19.emitter = target1, w19.type = type1, w19.count = existing1.length, ProcessEmitWarning1(w19);
                }
                return target1;
            }
            function onceWrapper1() {
                if (!this.fired) return (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 == arguments.length) ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
            }
            function _onceWrap1(target1, type1, listener1) {
                var state1 = {
                    fired: !1,
                    wrapFn: void 0,
                    target: target1,
                    type: type1,
                    listener: listener1
                }, wrapped1 = onceWrapper1.bind(state1);
                return wrapped1.listener = listener1, state1.wrapFn = wrapped1, wrapped1;
            }
            function _listeners1(target1, type1, unwrap1) {
                var events1 = target1._events;
                if (void 0 === events1) return [];
                var evlistener1 = events1[type1];
                return void 0 === evlistener1 ? [] : 'function' == typeof evlistener1 ? unwrap1 ? [
                    evlistener1.listener || evlistener1
                ] : [
                    evlistener1
                ] : unwrap1 ? unwrapListeners1(evlistener1) : arrayClone1(evlistener1, evlistener1.length);
            }
            function listenerCount1(type1) {
                var events1 = this._events;
                if (void 0 !== events1) {
                    var evlistener1 = events1[type1];
                    if ('function' == typeof evlistener1) return 1;
                    if (void 0 !== evlistener1) return evlistener1.length;
                }
                return 0;
            }
            function arrayClone1(arr1, n2) {
                for(var copy1 = Array(n2), i2 = 0; i2 < n2; ++i2)copy1[i2] = arr1[i2];
                return copy1;
            }
            function spliceOne1(list1, index1) {
                for(; index1 + 1 < list1.length; index1++)list1[index1] = list1[index1 + 1];
                list1.pop();
            }
            function unwrapListeners1(arr1) {
                for(var ret1 = Array(arr1.length), i2 = 0; i2 < ret1.length; ++i2)ret1[i2] = arr1[i2].listener || arr1[i2];
                return ret1;
            }
            function once1(emitter1, name1) {
                return new Promise(function(resolve1, reject1) {
                    function errorListener1(err1) {
                        emitter1.removeListener(name1, resolver1), reject1(err1);
                    }
                    function resolver1() {
                        'function' == typeof emitter1.removeListener && emitter1.removeListener('error', errorListener1), resolve1([].slice.call(arguments));
                    }
                    eventTargetAgnosticAddListener1(emitter1, name1, resolver1, {
                        once: !0
                    }), 'error' !== name1 && addErrorHandlerIfEventEmitter1(emitter1, errorListener1, {
                        once: !0
                    });
                });
            }
            function addErrorHandlerIfEventEmitter1(emitter1, handler1, flags1) {
                'function' == typeof emitter1.on && eventTargetAgnosticAddListener1(emitter1, 'error', handler1, flags1);
            }
            function eventTargetAgnosticAddListener1(emitter1, name1, listener1, flags1) {
                if ('function' == typeof emitter1.on) flags1.once ? emitter1.once(name1, listener1) : emitter1.on(name1, listener1);
                else if ('function' == typeof emitter1.addEventListener) emitter1.addEventListener(name1, function wrapListener1(arg4) {
                    flags1.once && emitter1.removeEventListener(name1, wrapListener1), listener1(arg4);
                });
                else throw TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter1);
            }
            Object.defineProperty(EventEmitter1, 'defaultMaxListeners', {
                enumerable: !0,
                get: function() {
                    return defaultMaxListeners1;
                },
                set: function(arg4) {
                    if ('number' != typeof arg4 || arg4 < 0 || NumberIsNaN1(arg4)) throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg4 + '.');
                    defaultMaxListeners1 = arg4;
                }
            }), EventEmitter1.init = function() {
                (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
            }, EventEmitter1.prototype.setMaxListeners = function(n2) {
                if ('number' != typeof n2 || n2 < 0 || NumberIsNaN1(n2)) throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + '.');
                return this._maxListeners = n2, this;
            }, EventEmitter1.prototype.getMaxListeners = function() {
                return _getMaxListeners1(this);
            }, EventEmitter1.prototype.emit = function(type1) {
                for(var args1 = [], i2 = 1; i2 < arguments.length; i2++)args1.push(arguments[i2]);
                var doError1 = 'error' === type1, events1 = this._events;
                if (void 0 !== events1) doError1 = doError1 && void 0 === events1.error;
                else if (!doError1) return !1;
                if (doError1) {
                    if (args1.length > 0 && (er1 = args1[0]), er1 instanceof Error) throw er1;
                    var er1, err1 = Error('Unhandled error.' + (er1 ? ' (' + er1.message + ')' : ''));
                    throw err1.context = er1, err1;
                }
                var handler1 = events1[type1];
                if (void 0 === handler1) return !1;
                if ('function' == typeof handler1) ReflectApply1(handler1, this, args1);
                else for(var len3 = handler1.length, listeners1 = arrayClone1(handler1, len3), i2 = 0; i2 < len3; ++i2)ReflectApply1(listeners1[i2], this, args1);
                return !0;
            }, EventEmitter1.prototype.addListener = function(type1, listener1) {
                return _addListener1(this, type1, listener1, !1);
            }, EventEmitter1.prototype.on = EventEmitter1.prototype.addListener, EventEmitter1.prototype.prependListener = function(type1, listener1) {
                return _addListener1(this, type1, listener1, !0);
            }, EventEmitter1.prototype.once = function(type1, listener1) {
                return checkListener1(listener1), this.on(type1, _onceWrap1(this, type1, listener1)), this;
            }, EventEmitter1.prototype.prependOnceListener = function(type1, listener1) {
                return checkListener1(listener1), this.prependListener(type1, _onceWrap1(this, type1, listener1)), this;
            }, EventEmitter1.prototype.removeListener = function(type1, listener1) {
                var list1, events1, position1, i2, originalListener1;
                if (checkListener1(listener1), void 0 === (events1 = this._events) || void 0 === (list1 = events1[type1])) return this;
                if (list1 === listener1 || list1.listener === listener1) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete events1[type1], events1.removeListener && this.emit('removeListener', type1, list1.listener || listener1));
                else if ('function' != typeof list1) {
                    for(position1 = -1, i2 = list1.length - 1; i2 >= 0; i2--)if (list1[i2] === listener1 || list1[i2].listener === listener1) {
                        originalListener1 = list1[i2].listener, position1 = i2;
                        break;
                    }
                    if (position1 < 0) return this;
                    0 === position1 ? list1.shift() : spliceOne1(list1, position1), 1 === list1.length && (events1[type1] = list1[0]), void 0 !== events1.removeListener && this.emit('removeListener', type1, originalListener1 || listener1);
                }
                return this;
            }, EventEmitter1.prototype.off = EventEmitter1.prototype.removeListener, EventEmitter1.prototype.removeAllListeners = function(type1) {
                var listeners1, events1, i2;
                if (void 0 === (events1 = this._events)) return this;
                if (void 0 === events1.removeListener) return 0 == arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== events1[type1] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete events1[type1]), this;
                if (0 == arguments.length) {
                    var key1, keys1 = Object.keys(events1);
                    for(i2 = 0; i2 < keys1.length; ++i2)'removeListener' !== (key1 = keys1[i2]) && this.removeAllListeners(key1);
                    return this.removeAllListeners('removeListener'), this._events = Object.create(null), this._eventsCount = 0, this;
                }
                if ('function' == typeof (listeners1 = events1[type1])) this.removeListener(type1, listeners1);
                else if (void 0 !== listeners1) for(i2 = listeners1.length - 1; i2 >= 0; i2--)this.removeListener(type1, listeners1[i2]);
                return this;
            }, EventEmitter1.prototype.listeners = function(type1) {
                return _listeners1(this, type1, !0);
            }, EventEmitter1.prototype.rawListeners = function(type1) {
                return _listeners1(this, type1, !1);
            }, EventEmitter1.listenerCount = function(emitter1, type1) {
                return 'function' == typeof emitter1.listenerCount ? emitter1.listenerCount(type1) : listenerCount1.call(emitter1, type1);
            }, EventEmitter1.prototype.listenerCount = listenerCount1, EventEmitter1.prototype.eventNames = function() {
                return this._eventsCount > 0 ? ReflectOwnKeys1(this._events) : [];
            };
        },
        3346: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            !function(global1, factory1) {
                module1.exports = factory1();
            }(0, function() {
                'use strict';
                var toStringFunction1 = Function.prototype.toString, create1 = Object.create, defineProperty1 = Object.defineProperty, getOwnPropertyDescriptor1 = Object.getOwnPropertyDescriptor, getOwnPropertyNames1 = Object.getOwnPropertyNames, getOwnPropertySymbols1 = Object.getOwnPropertySymbols, getPrototypeOf$11 = Object.getPrototypeOf, _a1 = Object.prototype, hasOwnProperty1 = _a1.hasOwnProperty, propertyIsEnumerable1 = _a1.propertyIsEnumerable, SYMBOL_PROPERTIES1 = 'function' == typeof getOwnPropertySymbols1, WEAK_MAP1 = 'function' == typeof WeakMap, createCache1 = function() {
                    if (WEAK_MAP1) return function() {
                        return new WeakMap();
                    };
                    var Cache1 = function() {
                        function Cache1() {
                            this._keys = [], this._values = [];
                        }
                        return Cache1.prototype.has = function(key1) {
                            return !!~this._keys.indexOf(key1);
                        }, Cache1.prototype.get = function(key1) {
                            return this._values[this._keys.indexOf(key1)];
                        }, Cache1.prototype.set = function(key1, value1) {
                            this._keys.push(key1), this._values.push(value1);
                        }, Cache1;
                    }();
                    return function() {
                        return new Cache1();
                    };
                }(), getCleanClone1 = function(object1, realm1) {
                    var prototype1 = object1.__proto__ || getPrototypeOf$11(object1);
                    if (!prototype1) return create1(null);
                    var Constructor1 = prototype1.constructor;
                    if (Constructor1 === realm1.Object) return prototype1 === realm1.Object.prototype ? {} : create1(prototype1);
                    if (~toStringFunction1.call(Constructor1).indexOf('[native code]')) try {
                        return new Constructor1();
                    } catch (_a1) {}
                    return create1(prototype1);
                }, getObjectCloneLoose1 = function(object1, realm1, handleCopy1, cache1) {
                    var clone1 = getCleanClone1(object1, realm1);
                    for(var key1 in cache1.set(object1, clone1), object1)hasOwnProperty1.call(object1, key1) && (clone1[key1] = handleCopy1(object1[key1], cache1));
                    if (SYMBOL_PROPERTIES1) for(var symbols1 = getOwnPropertySymbols1(object1), index1 = 0, length_11 = symbols1.length, symbol1 = void 0; index1 < length_11; ++index1)symbol1 = symbols1[index1], propertyIsEnumerable1.call(object1, symbol1) && (clone1[symbol1] = handleCopy1(object1[symbol1], cache1));
                    return clone1;
                }, getObjectCloneStrict1 = function(object1, realm1, handleCopy1, cache1) {
                    var clone1 = getCleanClone1(object1, realm1);
                    cache1.set(object1, clone1);
                    for(var properties1 = SYMBOL_PROPERTIES1 ? getOwnPropertyNames1(object1).concat(getOwnPropertySymbols1(object1)) : getOwnPropertyNames1(object1), index1 = 0, length_21 = properties1.length, property1 = void 0, descriptor1 = void 0; index1 < length_21; ++index1)if ('callee' !== (property1 = properties1[index1]) && 'caller' !== property1) {
                        if (descriptor1 = getOwnPropertyDescriptor1(object1, property1)) {
                            descriptor1.get || descriptor1.set || (descriptor1.value = handleCopy1(object1[property1], cache1));
                            try {
                                defineProperty1(clone1, property1, descriptor1);
                            } catch (error1) {
                                clone1[property1] = descriptor1.value;
                            }
                        } else clone1[property1] = handleCopy1(object1[property1], cache1);
                    }
                    return clone1;
                }, getRegExpFlags1 = function(regExp1) {
                    var flags1 = '';
                    return regExp1.global && (flags1 += 'g'), regExp1.ignoreCase && (flags1 += 'i'), regExp1.multiline && (flags1 += 'm'), regExp1.unicode && (flags1 += 'u'), regExp1.sticky && (flags1 += 'y'), flags1;
                }, isArray1 = Array.isArray, getPrototypeOf1 = Object.getPrototypeOf, GLOBAL_THIS1 = function() {
                    return 'undefined' != typeof globalThis ? globalThis : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : void 0 !== __webpack_require__1.g ? __webpack_require__1.g : (console && console.error && console.error('Unable to locate global object, returning "this".'), this);
                }();
                function copy1(value1, options1) {
                    var isStrict1 = !!(options1 && options1.isStrict), realm1 = options1 && options1.realm || GLOBAL_THIS1, getObjectClone1 = isStrict1 ? getObjectCloneStrict1 : getObjectCloneLoose1, handleCopy1 = function(value1, cache1) {
                        if (!value1 || 'object' != typeof value1) return value1;
                        if (cache1.has(value1)) return cache1.get(value1);
                        var clone1, prototype1 = value1.__proto__ || getPrototypeOf1(value1), Constructor1 = prototype1 && prototype1.constructor;
                        if (!Constructor1 || Constructor1 === realm1.Object) return getObjectClone1(value1, realm1, handleCopy1, cache1);
                        if (isArray1(value1)) {
                            if (isStrict1) return getObjectCloneStrict1(value1, realm1, handleCopy1, cache1);
                            clone1 = new Constructor1(), cache1.set(value1, clone1);
                            for(var index1 = 0, length_11 = value1.length; index1 < length_11; ++index1)clone1[index1] = handleCopy1(value1[index1], cache1);
                            return clone1;
                        }
                        if (value1 instanceof realm1.Date) return new Constructor1(value1.getTime());
                        if (value1 instanceof realm1.RegExp) return (clone1 = new Constructor1(value1.source, value1.flags || getRegExpFlags1(value1))).lastIndex = value1.lastIndex, clone1;
                        if (realm1.Map && value1 instanceof realm1.Map) return clone1 = new Constructor1(), cache1.set(value1, clone1), value1.forEach(function(value1, key1) {
                            clone1.set(key1, handleCopy1(value1, cache1));
                        }), clone1;
                        if (realm1.Set && value1 instanceof realm1.Set) return clone1 = new Constructor1(), cache1.set(value1, clone1), value1.forEach(function(value1) {
                            clone1.add(handleCopy1(value1, cache1));
                        }), clone1;
                        if (realm1.Blob && value1 instanceof realm1.Blob) return value1.slice(0, value1.size, value1.type);
                        if (realm1.Buffer && realm1.Buffer.isBuffer(value1)) return clone1 = realm1.Buffer.allocUnsafe ? realm1.Buffer.allocUnsafe(value1.length) : new Constructor1(value1.length), cache1.set(value1, clone1), value1.copy(clone1), clone1;
                        if (realm1.ArrayBuffer) {
                            if (realm1.ArrayBuffer.isView(value1)) return clone1 = new Constructor1(value1.buffer.slice(0)), cache1.set(value1, clone1), clone1;
                            if (value1 instanceof realm1.ArrayBuffer) return clone1 = value1.slice(0), cache1.set(value1, clone1), clone1;
                        }
                        return 'function' == typeof value1.then || value1 instanceof Error || realm1.WeakMap && value1 instanceof realm1.WeakMap || realm1.WeakSet && value1 instanceof realm1.WeakSet ? value1 : getObjectClone1(value1, realm1, handleCopy1, cache1);
                    };
                    return handleCopy1(value1, createCache1());
                }
                return copy1.default = copy1, copy1.strict = function(value1, options1) {
                    return copy1(value1, {
                        isStrict: !0,
                        realm: options1 ? options1.realm : void 0
                    });
                }, copy1;
            });
        },
        4029: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var isCallable1 = __webpack_require__1(5320), toStr1 = Object.prototype.toString, hasOwnProperty1 = Object.prototype.hasOwnProperty, forEachArray1 = function(array1, iterator1, receiver1) {
                for(var i2 = 0, len3 = array1.length; i2 < len3; i2++)hasOwnProperty1.call(array1, i2) && (null == receiver1 ? iterator1(array1[i2], i2, array1) : iterator1.call(receiver1, array1[i2], i2, array1));
            }, forEachString1 = function(string1, iterator1, receiver1) {
                for(var i2 = 0, len3 = string1.length; i2 < len3; i2++)null == receiver1 ? iterator1(string1.charAt(i2), i2, string1) : iterator1.call(receiver1, string1.charAt(i2), i2, string1);
            }, forEachObject1 = function(object1, iterator1, receiver1) {
                for(var k3 in object1)hasOwnProperty1.call(object1, k3) && (null == receiver1 ? iterator1(object1[k3], k3, object1) : iterator1.call(receiver1, object1[k3], k3, object1));
            }, forEach1 = function(list1, iterator1, thisArg1) {
                var receiver1;
                if (!isCallable1(iterator1)) throw TypeError('iterator must be a function');
                arguments.length >= 3 && (receiver1 = thisArg1), '[object Array]' === toStr1.call(list1) ? forEachArray1(list1, iterator1, receiver1) : 'string' == typeof list1 ? forEachString1(list1, iterator1, receiver1) : forEachObject1(list1, iterator1, receiver1);
            };
            module1.exports = forEach1;
        },
        7648: function(module1) {
            "use strict";
            var ERROR_MESSAGE1 = 'Function.prototype.bind called on incompatible ', slice1 = Array.prototype.slice, toStr1 = Object.prototype.toString, funcType1 = '[object Function]';
            module1.exports = function(that1) {
                var bound1, target1 = this;
                if ('function' != typeof target1 || toStr1.call(target1) !== funcType1) throw TypeError(ERROR_MESSAGE1 + target1);
                for(var args1 = slice1.call(arguments, 1), binder1 = function() {
                    if (!(this instanceof bound1)) return target1.apply(that1, args1.concat(slice1.call(arguments)));
                    var result1 = target1.apply(this, args1.concat(slice1.call(arguments)));
                    return Object(result1) === result1 ? result1 : this;
                }, boundLength1 = Math.max(0, target1.length - args1.length), boundArgs1 = [], i2 = 0; i2 < boundLength1; i2++)boundArgs1.push('$' + i2);
                if (bound1 = Function('binder', 'return function (' + boundArgs1.join(',') + '){ return binder.apply(this,arguments); }')(binder1), target1.prototype) {
                    var Empty1 = function() {};
                    Empty1.prototype = target1.prototype, bound1.prototype = new Empty1(), Empty1.prototype = null;
                }
                return bound1;
            };
        },
        8612: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var implementation1 = __webpack_require__1(7648);
            module1.exports = Function.prototype.bind || implementation1;
        },
        4977: function(module1) {
            "use strict";
            module1.exports = createRBTree1;
            var RED1 = 0, BLACK1 = 1;
            function RBNode1(color1, key1, value1, left1, right1, count1) {
                this._color = color1, this.key = key1, this.value = value1, this.left = left1, this.right = right1, this._count = count1;
            }
            function cloneNode1(node1) {
                return new RBNode1(node1._color, node1.key, node1.value, node1.left, node1.right, node1._count);
            }
            function repaint1(color1, node1) {
                return new RBNode1(color1, node1.key, node1.value, node1.left, node1.right, node1._count);
            }
            function recount1(node1) {
                node1._count = 1 + (node1.left ? node1.left._count : 0) + (node1.right ? node1.right._count : 0);
            }
            function RedBlackTree1(compare1, root1) {
                this._compare = compare1, this.root = root1;
            }
            var proto1 = RedBlackTree1.prototype;
            function doVisitFull1(visit1, node1) {
                if (node1.left) {
                    var v3 = doVisitFull1(visit1, node1.left);
                    if (v3) return v3;
                }
                var v3 = visit1(node1.key, node1.value);
                return v3 || (node1.right ? doVisitFull1(visit1, node1.right) : void 0);
            }
            function doVisitHalf1(lo1, compare1, visit1, node1) {
                if (0 >= compare1(lo1, node1.key)) {
                    if (node1.left) {
                        var v3 = doVisitHalf1(lo1, compare1, visit1, node1.left);
                        if (v3) return v3;
                    }
                    var v3 = visit1(node1.key, node1.value);
                    if (v3) return v3;
                }
                if (node1.right) return doVisitHalf1(lo1, compare1, visit1, node1.right);
            }
            function doVisit1(lo1, hi1, compare1, visit1, node1) {
                var v3, l1 = compare1(lo1, node1.key), h8 = compare1(hi1, node1.key);
                return l1 <= 0 && (node1.left && (v3 = doVisit1(lo1, hi1, compare1, visit1, node1.left)) || h8 > 0 && (v3 = visit1(node1.key, node1.value))) ? v3 : h8 > 0 && node1.right ? doVisit1(lo1, hi1, compare1, visit1, node1.right) : void 0;
            }
            function RedBlackTreeIterator1(tree1, stack1) {
                this.tree = tree1, this._stack = stack1;
            }
            Object.defineProperty(proto1, "keys", {
                get: function() {
                    var result1 = [];
                    return this.forEach(function(k3, v3) {
                        result1.push(k3);
                    }), result1;
                }
            }), Object.defineProperty(proto1, "values", {
                get: function() {
                    var result1 = [];
                    return this.forEach(function(k3, v3) {
                        result1.push(v3);
                    }), result1;
                }
            }), Object.defineProperty(proto1, "length", {
                get: function() {
                    return this.root ? this.root._count : 0;
                }
            }), proto1.insert = function(key1, value1) {
                for(var cmp1 = this._compare, n2 = this.root, n_stack1 = [], d_stack1 = []; n2;){
                    var d3 = cmp1(key1, n2.key);
                    n_stack1.push(n2), d_stack1.push(d3), n2 = d3 <= 0 ? n2.left : n2.right;
                }
                n_stack1.push(new RBNode1(RED1, key1, value1, null, null, 1));
                for(var s3 = n_stack1.length - 2; s3 >= 0; --s3){
                    var n2 = n_stack1[s3];
                    d_stack1[s3] <= 0 ? n_stack1[s3] = new RBNode1(n2._color, n2.key, n2.value, n_stack1[s3 + 1], n2.right, n2._count + 1) : n_stack1[s3] = new RBNode1(n2._color, n2.key, n2.value, n2.left, n_stack1[s3 + 1], n2._count + 1);
                }
                for(var s3 = n_stack1.length - 1; s3 > 1; --s3){
                    var p3 = n_stack1[s3 - 1], n2 = n_stack1[s3];
                    if (p3._color === BLACK1 || n2._color === BLACK1) break;
                    var pp1 = n_stack1[s3 - 2];
                    if (pp1.left === p3) {
                        if (p3.left === n2) {
                            var y3 = pp1.right;
                            if (y3 && y3._color === RED1) p3._color = BLACK1, pp1.right = repaint1(BLACK1, y3), pp1._color = RED1, s3 -= 1;
                            else {
                                if (pp1._color = RED1, pp1.left = p3.right, p3._color = BLACK1, p3.right = pp1, n_stack1[s3 - 2] = p3, n_stack1[s3 - 1] = n2, recount1(pp1), recount1(p3), s3 >= 3) {
                                    var ppp1 = n_stack1[s3 - 3];
                                    ppp1.left === pp1 ? ppp1.left = p3 : ppp1.right = p3;
                                }
                                break;
                            }
                        } else {
                            var y3 = pp1.right;
                            if (y3 && y3._color === RED1) p3._color = BLACK1, pp1.right = repaint1(BLACK1, y3), pp1._color = RED1, s3 -= 1;
                            else {
                                if (p3.right = n2.left, pp1._color = RED1, pp1.left = n2.right, n2._color = BLACK1, n2.left = p3, n2.right = pp1, n_stack1[s3 - 2] = n2, n_stack1[s3 - 1] = p3, recount1(pp1), recount1(p3), recount1(n2), s3 >= 3) {
                                    var ppp1 = n_stack1[s3 - 3];
                                    ppp1.left === pp1 ? ppp1.left = n2 : ppp1.right = n2;
                                }
                                break;
                            }
                        }
                    } else if (p3.right === n2) {
                        var y3 = pp1.left;
                        if (y3 && y3._color === RED1) p3._color = BLACK1, pp1.left = repaint1(BLACK1, y3), pp1._color = RED1, s3 -= 1;
                        else {
                            if (pp1._color = RED1, pp1.right = p3.left, p3._color = BLACK1, p3.left = pp1, n_stack1[s3 - 2] = p3, n_stack1[s3 - 1] = n2, recount1(pp1), recount1(p3), s3 >= 3) {
                                var ppp1 = n_stack1[s3 - 3];
                                ppp1.right === pp1 ? ppp1.right = p3 : ppp1.left = p3;
                            }
                            break;
                        }
                    } else {
                        var y3 = pp1.left;
                        if (y3 && y3._color === RED1) p3._color = BLACK1, pp1.left = repaint1(BLACK1, y3), pp1._color = RED1, s3 -= 1;
                        else {
                            if (p3.left = n2.right, pp1._color = RED1, pp1.right = n2.left, n2._color = BLACK1, n2.right = p3, n2.left = pp1, n_stack1[s3 - 2] = n2, n_stack1[s3 - 1] = p3, recount1(pp1), recount1(p3), recount1(n2), s3 >= 3) {
                                var ppp1 = n_stack1[s3 - 3];
                                ppp1.right === pp1 ? ppp1.right = n2 : ppp1.left = n2;
                            }
                            break;
                        }
                    }
                }
                return n_stack1[0]._color = BLACK1, new RedBlackTree1(cmp1, n_stack1[0]);
            }, proto1.forEach = function(visit1, lo1, hi1) {
                if (this.root) switch(arguments.length){
                    case 1:
                        return doVisitFull1(visit1, this.root);
                    case 2:
                        return doVisitHalf1(lo1, this._compare, visit1, this.root);
                    case 3:
                        if (this._compare(lo1, hi1) >= 0) return;
                        return doVisit1(lo1, hi1, this._compare, visit1, this.root);
                }
            }, Object.defineProperty(proto1, "begin", {
                get: function() {
                    for(var stack1 = [], n2 = this.root; n2;)stack1.push(n2), n2 = n2.left;
                    return new RedBlackTreeIterator1(this, stack1);
                }
            }), Object.defineProperty(proto1, "end", {
                get: function() {
                    for(var stack1 = [], n2 = this.root; n2;)stack1.push(n2), n2 = n2.right;
                    return new RedBlackTreeIterator1(this, stack1);
                }
            }), proto1.at = function(idx1) {
                if (idx1 < 0) return new RedBlackTreeIterator1(this, []);
                for(var n2 = this.root, stack1 = [];;){
                    if (stack1.push(n2), n2.left) {
                        if (idx1 < n2.left._count) {
                            n2 = n2.left;
                            continue;
                        }
                        idx1 -= n2.left._count;
                    }
                    if (!idx1) return new RedBlackTreeIterator1(this, stack1);
                    if (idx1 -= 1, n2.right) {
                        if (idx1 >= n2.right._count) break;
                        n2 = n2.right;
                    } else break;
                }
                return new RedBlackTreeIterator1(this, []);
            }, proto1.ge = function(key1) {
                for(var cmp1 = this._compare, n2 = this.root, stack1 = [], last_ptr1 = 0; n2;){
                    var d3 = cmp1(key1, n2.key);
                    stack1.push(n2), d3 <= 0 && (last_ptr1 = stack1.length), n2 = d3 <= 0 ? n2.left : n2.right;
                }
                return stack1.length = last_ptr1, new RedBlackTreeIterator1(this, stack1);
            }, proto1.gt = function(key1) {
                for(var cmp1 = this._compare, n2 = this.root, stack1 = [], last_ptr1 = 0; n2;){
                    var d3 = cmp1(key1, n2.key);
                    stack1.push(n2), d3 < 0 && (last_ptr1 = stack1.length), n2 = d3 < 0 ? n2.left : n2.right;
                }
                return stack1.length = last_ptr1, new RedBlackTreeIterator1(this, stack1);
            }, proto1.lt = function(key1) {
                for(var cmp1 = this._compare, n2 = this.root, stack1 = [], last_ptr1 = 0; n2;){
                    var d3 = cmp1(key1, n2.key);
                    stack1.push(n2), d3 > 0 && (last_ptr1 = stack1.length), n2 = d3 <= 0 ? n2.left : n2.right;
                }
                return stack1.length = last_ptr1, new RedBlackTreeIterator1(this, stack1);
            }, proto1.le = function(key1) {
                for(var cmp1 = this._compare, n2 = this.root, stack1 = [], last_ptr1 = 0; n2;){
                    var d3 = cmp1(key1, n2.key);
                    stack1.push(n2), d3 >= 0 && (last_ptr1 = stack1.length), n2 = d3 < 0 ? n2.left : n2.right;
                }
                return stack1.length = last_ptr1, new RedBlackTreeIterator1(this, stack1);
            }, proto1.find = function(key1) {
                for(var cmp1 = this._compare, n2 = this.root, stack1 = []; n2;){
                    var d3 = cmp1(key1, n2.key);
                    if (stack1.push(n2), 0 === d3) return new RedBlackTreeIterator1(this, stack1);
                    n2 = d3 <= 0 ? n2.left : n2.right;
                }
                return new RedBlackTreeIterator1(this, []);
            }, proto1.remove = function(key1) {
                var iter1 = this.find(key1);
                return iter1 ? iter1.remove() : this;
            }, proto1.get = function(key1) {
                for(var cmp1 = this._compare, n2 = this.root; n2;){
                    var d3 = cmp1(key1, n2.key);
                    if (0 === d3) return n2.value;
                    n2 = d3 <= 0 ? n2.left : n2.right;
                }
            };
            var iproto1 = RedBlackTreeIterator1.prototype;
            function swapNode1(n2, v3) {
                n2.key = v3.key, n2.value = v3.value, n2.left = v3.left, n2.right = v3.right, n2._color = v3._color, n2._count = v3._count;
            }
            function fixDoubleBlack1(stack1) {
                for(var n2, p3, s3, z1, i2 = stack1.length - 1; i2 >= 0; --i2){
                    if (n2 = stack1[i2], 0 === i2) {
                        n2._color = BLACK1;
                        return;
                    }
                    if ((p3 = stack1[i2 - 1]).left === n2) {
                        if ((s3 = p3.right).right && s3.right._color === RED1) {
                            if (z1 = (s3 = p3.right = cloneNode1(s3)).right = cloneNode1(s3.right), p3.right = s3.left, s3.left = p3, s3.right = z1, s3._color = p3._color, n2._color = BLACK1, p3._color = BLACK1, z1._color = BLACK1, recount1(p3), recount1(s3), i2 > 1) {
                                var pp1 = stack1[i2 - 2];
                                pp1.left === p3 ? pp1.left = s3 : pp1.right = s3;
                            }
                            stack1[i2 - 1] = s3;
                            return;
                        }
                        if (s3.left && s3.left._color === RED1) {
                            if (z1 = (s3 = p3.right = cloneNode1(s3)).left = cloneNode1(s3.left), p3.right = z1.left, s3.left = z1.right, z1.left = p3, z1.right = s3, z1._color = p3._color, p3._color = BLACK1, s3._color = BLACK1, n2._color = BLACK1, recount1(p3), recount1(s3), recount1(z1), i2 > 1) {
                                var pp1 = stack1[i2 - 2];
                                pp1.left === p3 ? pp1.left = z1 : pp1.right = z1;
                            }
                            stack1[i2 - 1] = z1;
                            return;
                        }
                        if (s3._color === BLACK1) {
                            if (p3._color === RED1) {
                                p3._color = BLACK1, p3.right = repaint1(RED1, s3);
                                return;
                            }
                            p3.right = repaint1(RED1, s3);
                            continue;
                        }
                        if (s3 = cloneNode1(s3), p3.right = s3.left, s3.left = p3, s3._color = p3._color, p3._color = RED1, recount1(p3), recount1(s3), i2 > 1) {
                            var pp1 = stack1[i2 - 2];
                            pp1.left === p3 ? pp1.left = s3 : pp1.right = s3;
                        }
                        stack1[i2 - 1] = s3, stack1[i2] = p3, i2 + 1 < stack1.length ? stack1[i2 + 1] = n2 : stack1.push(n2), i2 += 2;
                    } else {
                        if ((s3 = p3.left).left && s3.left._color === RED1) {
                            if (z1 = (s3 = p3.left = cloneNode1(s3)).left = cloneNode1(s3.left), p3.left = s3.right, s3.right = p3, s3.left = z1, s3._color = p3._color, n2._color = BLACK1, p3._color = BLACK1, z1._color = BLACK1, recount1(p3), recount1(s3), i2 > 1) {
                                var pp1 = stack1[i2 - 2];
                                pp1.right === p3 ? pp1.right = s3 : pp1.left = s3;
                            }
                            stack1[i2 - 1] = s3;
                            return;
                        }
                        if (s3.right && s3.right._color === RED1) {
                            if (z1 = (s3 = p3.left = cloneNode1(s3)).right = cloneNode1(s3.right), p3.left = z1.right, s3.right = z1.left, z1.right = p3, z1.left = s3, z1._color = p3._color, p3._color = BLACK1, s3._color = BLACK1, n2._color = BLACK1, recount1(p3), recount1(s3), recount1(z1), i2 > 1) {
                                var pp1 = stack1[i2 - 2];
                                pp1.right === p3 ? pp1.right = z1 : pp1.left = z1;
                            }
                            stack1[i2 - 1] = z1;
                            return;
                        }
                        if (s3._color === BLACK1) {
                            if (p3._color === RED1) {
                                p3._color = BLACK1, p3.left = repaint1(RED1, s3);
                                return;
                            }
                            p3.left = repaint1(RED1, s3);
                            continue;
                        }
                        if (s3 = cloneNode1(s3), p3.left = s3.right, s3.right = p3, s3._color = p3._color, p3._color = RED1, recount1(p3), recount1(s3), i2 > 1) {
                            var pp1 = stack1[i2 - 2];
                            pp1.right === p3 ? pp1.right = s3 : pp1.left = s3;
                        }
                        stack1[i2 - 1] = s3, stack1[i2] = p3, i2 + 1 < stack1.length ? stack1[i2 + 1] = n2 : stack1.push(n2), i2 += 2;
                    }
                }
            }
            function defaultCompare1(a10, b10) {
                return a10 < b10 ? -1 : a10 > b10 ? 1 : 0;
            }
            function createRBTree1(compare1) {
                return new RedBlackTree1(compare1 || defaultCompare1, null);
            }
            Object.defineProperty(iproto1, "valid", {
                get: function() {
                    return this._stack.length > 0;
                }
            }), Object.defineProperty(iproto1, "node", {
                get: function() {
                    return this._stack.length > 0 ? this._stack[this._stack.length - 1] : null;
                },
                enumerable: !0
            }), iproto1.clone = function() {
                return new RedBlackTreeIterator1(this.tree, this._stack.slice());
            }, iproto1.remove = function() {
                var stack1 = this._stack;
                if (0 === stack1.length) return this.tree;
                var cstack1 = Array(stack1.length), n2 = stack1[stack1.length - 1];
                cstack1[cstack1.length - 1] = new RBNode1(n2._color, n2.key, n2.value, n2.left, n2.right, n2._count);
                for(var i2 = stack1.length - 2; i2 >= 0; --i2){
                    var n2 = stack1[i2];
                    n2.left === stack1[i2 + 1] ? cstack1[i2] = new RBNode1(n2._color, n2.key, n2.value, cstack1[i2 + 1], n2.right, n2._count) : cstack1[i2] = new RBNode1(n2._color, n2.key, n2.value, n2.left, cstack1[i2 + 1], n2._count);
                }
                if ((n2 = cstack1[cstack1.length - 1]).left && n2.right) {
                    var split1 = cstack1.length;
                    for(n2 = n2.left; n2.right;)cstack1.push(n2), n2 = n2.right;
                    var v3 = cstack1[split1 - 1];
                    cstack1.push(new RBNode1(n2._color, v3.key, v3.value, n2.left, n2.right, n2._count)), cstack1[split1 - 1].key = n2.key, cstack1[split1 - 1].value = n2.value;
                    for(var i2 = cstack1.length - 2; i2 >= split1; --i2)n2 = cstack1[i2], cstack1[i2] = new RBNode1(n2._color, n2.key, n2.value, n2.left, cstack1[i2 + 1], n2._count);
                    cstack1[split1 - 1].left = cstack1[split1];
                }
                if ((n2 = cstack1[cstack1.length - 1])._color === RED1) {
                    var p3 = cstack1[cstack1.length - 2];
                    p3.left === n2 ? p3.left = null : p3.right === n2 && (p3.right = null), cstack1.pop();
                    for(var i2 = 0; i2 < cstack1.length; ++i2)cstack1[i2]._count--;
                } else if (n2.left || n2.right) {
                    n2.left ? swapNode1(n2, n2.left) : n2.right && swapNode1(n2, n2.right), n2._color = BLACK1;
                    for(var i2 = 0; i2 < cstack1.length - 1; ++i2)cstack1[i2]._count--;
                } else {
                    if (1 === cstack1.length) return new RedBlackTree1(this.tree._compare, null);
                    for(var i2 = 0; i2 < cstack1.length; ++i2)cstack1[i2]._count--;
                    var parent1 = cstack1[cstack1.length - 2];
                    fixDoubleBlack1(cstack1), parent1.left === n2 ? parent1.left = null : parent1.right = null;
                }
                return new RedBlackTree1(this.tree._compare, cstack1[0]);
            }, Object.defineProperty(iproto1, "key", {
                get: function() {
                    if (this._stack.length > 0) return this._stack[this._stack.length - 1].key;
                },
                enumerable: !0
            }), Object.defineProperty(iproto1, "value", {
                get: function() {
                    if (this._stack.length > 0) return this._stack[this._stack.length - 1].value;
                },
                enumerable: !0
            }), Object.defineProperty(iproto1, "index", {
                get: function() {
                    var idx1 = 0, stack1 = this._stack;
                    if (0 === stack1.length) {
                        var r3 = this.tree.root;
                        return r3 ? r3._count : 0;
                    }
                    stack1[stack1.length - 1].left && (idx1 = stack1[stack1.length - 1].left._count);
                    for(var s3 = stack1.length - 2; s3 >= 0; --s3)stack1[s3 + 1] === stack1[s3].right && (++idx1, stack1[s3].left && (idx1 += stack1[s3].left._count));
                    return idx1;
                },
                enumerable: !0
            }), iproto1.next = function() {
                var stack1 = this._stack;
                if (0 !== stack1.length) {
                    var n2 = stack1[stack1.length - 1];
                    if (n2.right) for(n2 = n2.right; n2;)stack1.push(n2), n2 = n2.left;
                    else for(stack1.pop(); stack1.length > 0 && stack1[stack1.length - 1].right === n2;)n2 = stack1[stack1.length - 1], stack1.pop();
                }
            }, Object.defineProperty(iproto1, "hasNext", {
                get: function() {
                    var stack1 = this._stack;
                    if (0 === stack1.length) return !1;
                    if (stack1[stack1.length - 1].right) return !0;
                    for(var s3 = stack1.length - 1; s3 > 0; --s3)if (stack1[s3 - 1].left === stack1[s3]) return !0;
                    return !1;
                }
            }), iproto1.update = function(value1) {
                var stack1 = this._stack;
                if (0 === stack1.length) throw Error("Can't update empty node!");
                var cstack1 = Array(stack1.length), n2 = stack1[stack1.length - 1];
                cstack1[cstack1.length - 1] = new RBNode1(n2._color, n2.key, value1, n2.left, n2.right, n2._count);
                for(var i2 = stack1.length - 2; i2 >= 0; --i2)(n2 = stack1[i2]).left === stack1[i2 + 1] ? cstack1[i2] = new RBNode1(n2._color, n2.key, n2.value, cstack1[i2 + 1], n2.right, n2._count) : cstack1[i2] = new RBNode1(n2._color, n2.key, n2.value, n2.left, cstack1[i2 + 1], n2._count);
                return new RedBlackTree1(this.tree._compare, cstack1[0]);
            }, iproto1.prev = function() {
                var stack1 = this._stack;
                if (0 !== stack1.length) {
                    var n2 = stack1[stack1.length - 1];
                    if (n2.left) for(n2 = n2.left; n2;)stack1.push(n2), n2 = n2.right;
                    else for(stack1.pop(); stack1.length > 0 && stack1[stack1.length - 1].left === n2;)n2 = stack1[stack1.length - 1], stack1.pop();
                }
            }, Object.defineProperty(iproto1, "hasPrev", {
                get: function() {
                    var stack1 = this._stack;
                    if (0 === stack1.length) return !1;
                    if (stack1[stack1.length - 1].left) return !0;
                    for(var s3 = stack1.length - 1; s3 > 0; --s3)if (stack1[s3 - 1].right === stack1[s3]) return !0;
                    return !1;
                }
            });
        },
        210: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var undefined1, $SyntaxError1 = SyntaxError, $Function1 = Function, $TypeError1 = TypeError, getEvalledConstructor1 = function(expressionSyntax1) {
                try {
                    return $Function1('"use strict"; return (' + expressionSyntax1 + ').constructor;')();
                } catch (e1) {}
            }, $gOPD1 = Object.getOwnPropertyDescriptor;
            if ($gOPD1) try {
                $gOPD1({}, '');
            } catch (e1) {
                $gOPD1 = null;
            }
            var throwTypeError1 = function() {
                throw new $TypeError1();
            }, ThrowTypeError1 = $gOPD1 ? function() {
                try {
                    return arguments.callee, throwTypeError1;
                } catch (calleeThrows1) {
                    try {
                        return $gOPD1(arguments, 'callee').get;
                    } catch (gOPDthrows1) {
                        return throwTypeError1;
                    }
                }
            }() : throwTypeError1, hasSymbols1 = __webpack_require__1(1405)(), getProto1 = Object.getPrototypeOf || function(x3) {
                return x3.__proto__;
            }, needsEval1 = {}, TypedArray1 = 'undefined' == typeof Uint8Array ? undefined1 : getProto1(Uint8Array), INTRINSICS1 = {
                '%AggregateError%': 'undefined' == typeof AggregateError ? undefined1 : AggregateError,
                '%Array%': Array,
                '%ArrayBuffer%': 'undefined' == typeof ArrayBuffer ? undefined1 : ArrayBuffer,
                '%ArrayIteratorPrototype%': hasSymbols1 ? getProto1([][Symbol.iterator]()) : undefined1,
                '%AsyncFromSyncIteratorPrototype%': undefined1,
                '%AsyncFunction%': needsEval1,
                '%AsyncGenerator%': needsEval1,
                '%AsyncGeneratorFunction%': needsEval1,
                '%AsyncIteratorPrototype%': needsEval1,
                '%Atomics%': 'undefined' == typeof Atomics ? undefined1 : Atomics,
                '%BigInt%': 'undefined' == typeof BigInt ? undefined1 : BigInt,
                '%Boolean%': Boolean,
                '%DataView%': 'undefined' == typeof DataView ? undefined1 : DataView,
                '%Date%': Date,
                '%decodeURI%': decodeURI,
                '%decodeURIComponent%': decodeURIComponent,
                '%encodeURI%': encodeURI,
                '%encodeURIComponent%': encodeURIComponent,
                '%Error%': Error,
                '%eval%': eval,
                '%EvalError%': EvalError,
                '%Float32Array%': 'undefined' == typeof Float32Array ? undefined1 : Float32Array,
                '%Float64Array%': 'undefined' == typeof Float64Array ? undefined1 : Float64Array,
                '%FinalizationRegistry%': 'undefined' == typeof FinalizationRegistry ? undefined1 : FinalizationRegistry,
                '%Function%': $Function1,
                '%GeneratorFunction%': needsEval1,
                '%Int8Array%': 'undefined' == typeof Int8Array ? undefined1 : Int8Array,
                '%Int16Array%': 'undefined' == typeof Int16Array ? undefined1 : Int16Array,
                '%Int32Array%': 'undefined' == typeof Int32Array ? undefined1 : Int32Array,
                '%isFinite%': isFinite,
                '%isNaN%': isNaN,
                '%IteratorPrototype%': hasSymbols1 ? getProto1(getProto1([][Symbol.iterator]())) : undefined1,
                '%JSON%': 'object' == typeof JSON ? JSON : undefined1,
                '%Map%': 'undefined' == typeof Map ? undefined1 : Map,
                '%MapIteratorPrototype%': 'undefined' != typeof Map && hasSymbols1 ? getProto1(new Map()[Symbol.iterator]()) : undefined1,
                '%Math%': Math,
                '%Number%': Number,
                '%Object%': Object,
                '%parseFloat%': parseFloat,
                '%parseInt%': parseInt,
                '%Promise%': 'undefined' == typeof Promise ? undefined1 : Promise,
                '%Proxy%': 'undefined' == typeof Proxy ? undefined1 : Proxy,
                '%RangeError%': RangeError,
                '%ReferenceError%': ReferenceError,
                '%Reflect%': 'undefined' == typeof Reflect ? undefined1 : Reflect,
                '%RegExp%': RegExp,
                '%Set%': 'undefined' == typeof Set ? undefined1 : Set,
                '%SetIteratorPrototype%': 'undefined' != typeof Set && hasSymbols1 ? getProto1(new Set()[Symbol.iterator]()) : undefined1,
                '%SharedArrayBuffer%': 'undefined' == typeof SharedArrayBuffer ? undefined1 : SharedArrayBuffer,
                '%String%': String,
                '%StringIteratorPrototype%': hasSymbols1 ? getProto1(''[Symbol.iterator]()) : undefined1,
                '%Symbol%': hasSymbols1 ? Symbol : undefined1,
                '%SyntaxError%': $SyntaxError1,
                '%ThrowTypeError%': ThrowTypeError1,
                '%TypedArray%': TypedArray1,
                '%TypeError%': $TypeError1,
                '%Uint8Array%': 'undefined' == typeof Uint8Array ? undefined1 : Uint8Array,
                '%Uint8ClampedArray%': 'undefined' == typeof Uint8ClampedArray ? undefined1 : Uint8ClampedArray,
                '%Uint16Array%': 'undefined' == typeof Uint16Array ? undefined1 : Uint16Array,
                '%Uint32Array%': 'undefined' == typeof Uint32Array ? undefined1 : Uint32Array,
                '%URIError%': URIError,
                '%WeakMap%': 'undefined' == typeof WeakMap ? undefined1 : WeakMap,
                '%WeakRef%': 'undefined' == typeof WeakRef ? undefined1 : WeakRef,
                '%WeakSet%': 'undefined' == typeof WeakSet ? undefined1 : WeakSet
            }, doEval1 = function doEval1(name1) {
                var value1;
                if ('%AsyncFunction%' === name1) value1 = getEvalledConstructor1('async function () {}');
                else if ('%GeneratorFunction%' === name1) value1 = getEvalledConstructor1('function* () {}');
                else if ('%AsyncGeneratorFunction%' === name1) value1 = getEvalledConstructor1('async function* () {}');
                else if ('%AsyncGenerator%' === name1) {
                    var fn1 = doEval1('%AsyncGeneratorFunction%');
                    fn1 && (value1 = fn1.prototype);
                } else if ('%AsyncIteratorPrototype%' === name1) {
                    var gen1 = doEval1('%AsyncGenerator%');
                    gen1 && (value1 = getProto1(gen1.prototype));
                }
                return INTRINSICS1[name1] = value1, value1;
            }, LEGACY_ALIASES1 = {
                '%ArrayBufferPrototype%': [
                    'ArrayBuffer',
                    'prototype'
                ],
                '%ArrayPrototype%': [
                    'Array',
                    'prototype'
                ],
                '%ArrayProto_entries%': [
                    'Array',
                    'prototype',
                    'entries'
                ],
                '%ArrayProto_forEach%': [
                    'Array',
                    'prototype',
                    'forEach'
                ],
                '%ArrayProto_keys%': [
                    'Array',
                    'prototype',
                    'keys'
                ],
                '%ArrayProto_values%': [
                    'Array',
                    'prototype',
                    'values'
                ],
                '%AsyncFunctionPrototype%': [
                    'AsyncFunction',
                    'prototype'
                ],
                '%AsyncGenerator%': [
                    'AsyncGeneratorFunction',
                    'prototype'
                ],
                '%AsyncGeneratorPrototype%': [
                    'AsyncGeneratorFunction',
                    'prototype',
                    'prototype'
                ],
                '%BooleanPrototype%': [
                    'Boolean',
                    'prototype'
                ],
                '%DataViewPrototype%': [
                    'DataView',
                    'prototype'
                ],
                '%DatePrototype%': [
                    'Date',
                    'prototype'
                ],
                '%ErrorPrototype%': [
                    'Error',
                    'prototype'
                ],
                '%EvalErrorPrototype%': [
                    'EvalError',
                    'prototype'
                ],
                '%Float32ArrayPrototype%': [
                    'Float32Array',
                    'prototype'
                ],
                '%Float64ArrayPrototype%': [
                    'Float64Array',
                    'prototype'
                ],
                '%FunctionPrototype%': [
                    'Function',
                    'prototype'
                ],
                '%Generator%': [
                    'GeneratorFunction',
                    'prototype'
                ],
                '%GeneratorPrototype%': [
                    'GeneratorFunction',
                    'prototype',
                    'prototype'
                ],
                '%Int8ArrayPrototype%': [
                    'Int8Array',
                    'prototype'
                ],
                '%Int16ArrayPrototype%': [
                    'Int16Array',
                    'prototype'
                ],
                '%Int32ArrayPrototype%': [
                    'Int32Array',
                    'prototype'
                ],
                '%JSONParse%': [
                    'JSON',
                    'parse'
                ],
                '%JSONStringify%': [
                    'JSON',
                    'stringify'
                ],
                '%MapPrototype%': [
                    'Map',
                    'prototype'
                ],
                '%NumberPrototype%': [
                    'Number',
                    'prototype'
                ],
                '%ObjectPrototype%': [
                    'Object',
                    'prototype'
                ],
                '%ObjProto_toString%': [
                    'Object',
                    'prototype',
                    'toString'
                ],
                '%ObjProto_valueOf%': [
                    'Object',
                    'prototype',
                    'valueOf'
                ],
                '%PromisePrototype%': [
                    'Promise',
                    'prototype'
                ],
                '%PromiseProto_then%': [
                    'Promise',
                    'prototype',
                    'then'
                ],
                '%Promise_all%': [
                    'Promise',
                    'all'
                ],
                '%Promise_reject%': [
                    'Promise',
                    'reject'
                ],
                '%Promise_resolve%': [
                    'Promise',
                    'resolve'
                ],
                '%RangeErrorPrototype%': [
                    'RangeError',
                    'prototype'
                ],
                '%ReferenceErrorPrototype%': [
                    'ReferenceError',
                    'prototype'
                ],
                '%RegExpPrototype%': [
                    'RegExp',
                    'prototype'
                ],
                '%SetPrototype%': [
                    'Set',
                    'prototype'
                ],
                '%SharedArrayBufferPrototype%': [
                    'SharedArrayBuffer',
                    'prototype'
                ],
                '%StringPrototype%': [
                    'String',
                    'prototype'
                ],
                '%SymbolPrototype%': [
                    'Symbol',
                    'prototype'
                ],
                '%SyntaxErrorPrototype%': [
                    'SyntaxError',
                    'prototype'
                ],
                '%TypedArrayPrototype%': [
                    'TypedArray',
                    'prototype'
                ],
                '%TypeErrorPrototype%': [
                    'TypeError',
                    'prototype'
                ],
                '%Uint8ArrayPrototype%': [
                    'Uint8Array',
                    'prototype'
                ],
                '%Uint8ClampedArrayPrototype%': [
                    'Uint8ClampedArray',
                    'prototype'
                ],
                '%Uint16ArrayPrototype%': [
                    'Uint16Array',
                    'prototype'
                ],
                '%Uint32ArrayPrototype%': [
                    'Uint32Array',
                    'prototype'
                ],
                '%URIErrorPrototype%': [
                    'URIError',
                    'prototype'
                ],
                '%WeakMapPrototype%': [
                    'WeakMap',
                    'prototype'
                ],
                '%WeakSetPrototype%': [
                    'WeakSet',
                    'prototype'
                ]
            }, bind1 = __webpack_require__1(8612), hasOwn1 = __webpack_require__1(7642), $concat1 = bind1.call(Function.call, Array.prototype.concat), $spliceApply1 = bind1.call(Function.apply, Array.prototype.splice), $replace1 = bind1.call(Function.call, String.prototype.replace), $strSlice1 = bind1.call(Function.call, String.prototype.slice), $exec1 = bind1.call(Function.call, RegExp.prototype.exec), rePropName1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar1 = /\\(\\)?/g, stringToPath1 = function(string1) {
                var first1 = $strSlice1(string1, 0, 1), last1 = $strSlice1(string1, -1);
                if ('%' === first1 && '%' !== last1) throw new $SyntaxError1('invalid intrinsic syntax, expected closing `%`');
                if ('%' === last1 && '%' !== first1) throw new $SyntaxError1('invalid intrinsic syntax, expected opening `%`');
                var result1 = [];
                return $replace1(string1, rePropName1, function(match1, number1, quote1, subString1) {
                    result1[result1.length] = quote1 ? $replace1(subString1, reEscapeChar1, '$1') : number1 || match1;
                }), result1;
            }, getBaseIntrinsic1 = function(name1, allowMissing1) {
                var alias1, intrinsicName1 = name1;
                if (hasOwn1(LEGACY_ALIASES1, intrinsicName1) && (intrinsicName1 = '%' + (alias1 = LEGACY_ALIASES1[intrinsicName1])[0] + '%'), hasOwn1(INTRINSICS1, intrinsicName1)) {
                    var value1 = INTRINSICS1[intrinsicName1];
                    if (value1 === needsEval1 && (value1 = doEval1(intrinsicName1)), void 0 === value1 && !allowMissing1) throw new $TypeError1('intrinsic ' + name1 + ' exists, but is not available. Please file an issue!');
                    return {
                        alias: alias1,
                        name: intrinsicName1,
                        value: value1
                    };
                }
                throw new $SyntaxError1('intrinsic ' + name1 + ' does not exist!');
            };
            module1.exports = function(name1, allowMissing1) {
                if ('string' != typeof name1 || 0 === name1.length) throw new $TypeError1('intrinsic name must be a non-empty string');
                if (arguments.length > 1 && 'boolean' != typeof allowMissing1) throw new $TypeError1('"allowMissing" argument must be a boolean');
                if (null === $exec1(/^%?[^%]*%?$/g, name1)) throw new $SyntaxError1('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                var parts1 = stringToPath1(name1), intrinsicBaseName1 = parts1.length > 0 ? parts1[0] : '', intrinsic1 = getBaseIntrinsic1('%' + intrinsicBaseName1 + '%', allowMissing1), intrinsicRealName1 = intrinsic1.name, value1 = intrinsic1.value, skipFurtherCaching1 = !1, alias1 = intrinsic1.alias;
                alias1 && (intrinsicBaseName1 = alias1[0], $spliceApply1(parts1, $concat1([
                    0,
                    1
                ], alias1)));
                for(var i2 = 1, isOwn1 = !0; i2 < parts1.length; i2 += 1){
                    var part1 = parts1[i2], first1 = $strSlice1(part1, 0, 1), last1 = $strSlice1(part1, -1);
                    if (('"' === first1 || "'" === first1 || '`' === first1 || '"' === last1 || "'" === last1 || '`' === last1) && first1 !== last1) throw new $SyntaxError1('property names with quotes must have matching quotes');
                    if ('constructor' !== part1 && isOwn1 || (skipFurtherCaching1 = !0), intrinsicBaseName1 += '.' + part1, hasOwn1(INTRINSICS1, intrinsicRealName1 = '%' + intrinsicBaseName1 + '%')) value1 = INTRINSICS1[intrinsicRealName1];
                    else if (null != value1) {
                        if (!(part1 in value1)) {
                            if (!allowMissing1) throw new $TypeError1('base intrinsic for ' + name1 + ' exists, but the property is not available.');
                            return;
                        }
                        if ($gOPD1 && i2 + 1 >= parts1.length) {
                            var desc1 = $gOPD1(value1, part1);
                            value1 = (isOwn1 = !!desc1) && 'get' in desc1 && !('originalValue' in desc1.get) ? desc1.get : value1[part1];
                        } else isOwn1 = hasOwn1(value1, part1), value1 = value1[part1];
                        isOwn1 && !skipFurtherCaching1 && (INTRINSICS1[intrinsicRealName1] = value1);
                    }
                }
                return value1;
            };
        },
        1405: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var origSymbol1 = 'undefined' != typeof Symbol && Symbol, hasSymbolSham1 = __webpack_require__1(5419);
            module1.exports = function() {
                return 'function' == typeof origSymbol1 && 'function' == typeof Symbol && 'symbol' == typeof origSymbol1('foo') && 'symbol' == typeof Symbol('bar') && hasSymbolSham1();
            };
        },
        5419: function(module1) {
            "use strict";
            module1.exports = function() {
                if ('function' != typeof Symbol || 'function' != typeof Object.getOwnPropertySymbols) return !1;
                if ('symbol' == typeof Symbol.iterator) return !0;
                var obj1 = {}, sym1 = Symbol('test'), symObj1 = Object(sym1);
                if ('string' == typeof sym1 || '[object Symbol]' !== Object.prototype.toString.call(sym1) || '[object Symbol]' !== Object.prototype.toString.call(symObj1)) return !1;
                var symVal1 = 42;
                for(sym1 in obj1[sym1] = symVal1, obj1)return !1;
                if ('function' == typeof Object.keys && 0 !== Object.keys(obj1).length || 'function' == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(obj1).length) return !1;
                var syms1 = Object.getOwnPropertySymbols(obj1);
                if (1 !== syms1.length || syms1[0] !== sym1 || !Object.prototype.propertyIsEnumerable.call(obj1, sym1)) return !1;
                if ('function' == typeof Object.getOwnPropertyDescriptor) {
                    var descriptor1 = Object.getOwnPropertyDescriptor(obj1, sym1);
                    if (descriptor1.value !== symVal1 || !0 !== descriptor1.enumerable) return !1;
                }
                return !0;
            };
        },
        6410: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var hasSymbols1 = __webpack_require__1(5419);
            module1.exports = function() {
                return hasSymbols1() && !!Symbol.toStringTag;
            };
        },
        7642: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var bind1 = __webpack_require__1(8612);
            module1.exports = bind1.call(Function.call, Object.prototype.hasOwnProperty);
        },
        3715: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            var hash1 = exports1;
            hash1.utils = __webpack_require__1(6436), hash1.common = __webpack_require__1(5772), hash1.sha = __webpack_require__1(9041), hash1.ripemd = __webpack_require__1(2949), hash1.hmac = __webpack_require__1(2344), hash1.sha1 = hash1.sha.sha1, hash1.sha256 = hash1.sha.sha256, hash1.sha224 = hash1.sha.sha224, hash1.sha384 = hash1.sha.sha384, hash1.sha512 = hash1.sha.sha512, hash1.ripemd160 = hash1.ripemd.ripemd160;
        },
        5772: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), assert1 = __webpack_require__1(9746);
            function BlockHash1() {
                this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = 'big', this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
            }
            exports1.BlockHash = BlockHash1, BlockHash1.prototype.update = function(msg1, enc1) {
                if (msg1 = utils1.toArray(msg1, enc1), this.pending ? this.pending = this.pending.concat(msg1) : this.pending = msg1, this.pendingTotal += msg1.length, this.pending.length >= this._delta8) {
                    var r3 = (msg1 = this.pending).length % this._delta8;
                    this.pending = msg1.slice(msg1.length - r3, msg1.length), 0 === this.pending.length && (this.pending = null), msg1 = utils1.join32(msg1, 0, msg1.length - r3, this.endian);
                    for(var i2 = 0; i2 < msg1.length; i2 += this._delta32)this._update(msg1, i2, i2 + this._delta32);
                }
                return this;
            }, BlockHash1.prototype.digest = function(enc1) {
                return this.update(this._pad()), assert1(null === this.pending), this._digest(enc1);
            }, BlockHash1.prototype._pad = function() {
                var len3 = this.pendingTotal, bytes1 = this._delta8, k3 = bytes1 - (len3 + this.padLength) % bytes1, res1 = Array(k3 + this.padLength);
                res1[0] = 0x80;
                for(var i2 = 1; i2 < k3; i2++)res1[i2] = 0;
                if (len3 <<= 3, 'big' === this.endian) {
                    for(var t3 = 8; t3 < this.padLength; t3++)res1[i2++] = 0;
                    res1[i2++] = 0, res1[i2++] = 0, res1[i2++] = 0, res1[i2++] = 0, res1[i2++] = len3 >>> 24 & 0xff, res1[i2++] = len3 >>> 16 & 0xff, res1[i2++] = len3 >>> 8 & 0xff, res1[i2++] = 0xff & len3;
                } else for(t3 = 8, res1[i2++] = 0xff & len3, res1[i2++] = len3 >>> 8 & 0xff, res1[i2++] = len3 >>> 16 & 0xff, res1[i2++] = len3 >>> 24 & 0xff, res1[i2++] = 0, res1[i2++] = 0, res1[i2++] = 0, res1[i2++] = 0; t3 < this.padLength; t3++)res1[i2++] = 0;
                return res1;
            };
        },
        2344: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), assert1 = __webpack_require__1(9746);
            function Hmac1(hash1, key1, enc1) {
                if (!(this instanceof Hmac1)) return new Hmac1(hash1, key1, enc1);
                this.Hash = hash1, this.blockSize = hash1.blockSize / 8, this.outSize = hash1.outSize / 8, this.inner = null, this.outer = null, this._init(utils1.toArray(key1, enc1));
            }
            module1.exports = Hmac1, Hmac1.prototype._init = function(key1) {
                key1.length > this.blockSize && (key1 = new this.Hash().update(key1).digest()), assert1(key1.length <= this.blockSize);
                for(var i2 = key1.length; i2 < this.blockSize; i2++)key1.push(0);
                for(i2 = 0; i2 < key1.length; i2++)key1[i2] ^= 0x36;
                for(i2 = 0, this.inner = new this.Hash().update(key1); i2 < key1.length; i2++)key1[i2] ^= 0x6a;
                this.outer = new this.Hash().update(key1);
            }, Hmac1.prototype.update = function(msg1, enc1) {
                return this.inner.update(msg1, enc1), this;
            }, Hmac1.prototype.digest = function(enc1) {
                return this.outer.update(this.inner.digest()), this.outer.digest(enc1);
            };
        },
        2949: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), common1 = __webpack_require__1(5772), rotl321 = utils1.rotl32, sum321 = utils1.sum32, sum32_31 = utils1.sum32_3, sum32_41 = utils1.sum32_4, BlockHash1 = common1.BlockHash;
            function RIPEMD1601() {
                if (!(this instanceof RIPEMD1601)) return new RIPEMD1601();
                BlockHash1.call(this), this.h = [
                    0x67452301,
                    0xefcdab89,
                    0x98badcfe,
                    0x10325476,
                    0xc3d2e1f0
                ], this.endian = 'little';
            }
            function f1(j1, x3, y3, z1) {
                return j1 <= 15 ? x3 ^ y3 ^ z1 : j1 <= 31 ? x3 & y3 | ~x3 & z1 : j1 <= 47 ? (x3 | ~y3) ^ z1 : j1 <= 63 ? x3 & z1 | y3 & ~z1 : x3 ^ (y3 | ~z1);
            }
            function K1(j1) {
                return j1 <= 15 ? 0x00000000 : j1 <= 31 ? 0x5a827999 : j1 <= 47 ? 0x6ed9eba1 : j1 <= 63 ? 0x8f1bbcdc : 0xa953fd4e;
            }
            function Kh1(j1) {
                return j1 <= 15 ? 0x50a28be6 : j1 <= 31 ? 0x5c4dd124 : j1 <= 47 ? 0x6d703ef3 : j1 <= 63 ? 0x7a6d76e9 : 0x00000000;
            }
            utils1.inherits(RIPEMD1601, BlockHash1), exports1.ripemd160 = RIPEMD1601, RIPEMD1601.blockSize = 512, RIPEMD1601.outSize = 160, RIPEMD1601.hmacStrength = 192, RIPEMD1601.padLength = 64, RIPEMD1601.prototype._update = function(msg1, start1) {
                for(var A1 = this.h[0], B1 = this.h[1], C1 = this.h[2], D1 = this.h[3], E1 = this.h[4], Ah1 = A1, Bh1 = B1, Ch1 = C1, Dh1 = D1, Eh1 = E1, j1 = 0; j1 < 80; j1++){
                    var T3 = sum321(rotl321(sum32_41(A1, f1(j1, B1, C1, D1), msg1[r3[j1] + start1], K1(j1)), s3[j1]), E1);
                    A1 = E1, E1 = D1, D1 = rotl321(C1, 10), C1 = B1, B1 = T3, T3 = sum321(rotl321(sum32_41(Ah1, f1(79 - j1, Bh1, Ch1, Dh1), msg1[rh1[j1] + start1], Kh1(j1)), sh1[j1]), Eh1), Ah1 = Eh1, Eh1 = Dh1, Dh1 = rotl321(Ch1, 10), Ch1 = Bh1, Bh1 = T3;
                }
                T3 = sum32_31(this.h[1], C1, Dh1), this.h[1] = sum32_31(this.h[2], D1, Eh1), this.h[2] = sum32_31(this.h[3], E1, Ah1), this.h[3] = sum32_31(this.h[4], A1, Bh1), this.h[4] = sum32_31(this.h[0], B1, Ch1), this.h[0] = T3;
            }, RIPEMD1601.prototype._digest = function(enc1) {
                return 'hex' === enc1 ? utils1.toHex32(this.h, 'little') : utils1.split32(this.h, 'little');
            };
            var r3 = [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                7,
                4,
                13,
                1,
                10,
                6,
                15,
                3,
                12,
                0,
                9,
                5,
                2,
                14,
                11,
                8,
                3,
                10,
                14,
                4,
                9,
                15,
                8,
                1,
                2,
                7,
                0,
                6,
                13,
                11,
                5,
                12,
                1,
                9,
                11,
                10,
                0,
                8,
                12,
                4,
                13,
                3,
                7,
                15,
                14,
                5,
                6,
                2,
                4,
                0,
                5,
                9,
                7,
                12,
                2,
                10,
                14,
                1,
                3,
                8,
                11,
                6,
                15,
                13
            ], rh1 = [
                5,
                14,
                7,
                0,
                9,
                2,
                11,
                4,
                13,
                6,
                15,
                8,
                1,
                10,
                3,
                12,
                6,
                11,
                3,
                7,
                0,
                13,
                5,
                10,
                14,
                15,
                8,
                12,
                4,
                9,
                1,
                2,
                15,
                5,
                1,
                3,
                7,
                14,
                6,
                9,
                11,
                8,
                12,
                2,
                10,
                0,
                4,
                13,
                8,
                6,
                4,
                1,
                3,
                11,
                15,
                0,
                5,
                12,
                2,
                13,
                9,
                7,
                10,
                14,
                12,
                15,
                10,
                4,
                1,
                5,
                8,
                7,
                6,
                2,
                13,
                14,
                0,
                3,
                9,
                11
            ], s3 = [
                11,
                14,
                15,
                12,
                5,
                8,
                7,
                9,
                11,
                13,
                14,
                15,
                6,
                7,
                9,
                8,
                7,
                6,
                8,
                13,
                11,
                9,
                7,
                15,
                7,
                12,
                15,
                9,
                11,
                7,
                13,
                12,
                11,
                13,
                6,
                7,
                14,
                9,
                13,
                15,
                14,
                8,
                13,
                6,
                5,
                12,
                7,
                5,
                11,
                12,
                14,
                15,
                14,
                15,
                9,
                8,
                9,
                14,
                5,
                6,
                8,
                6,
                5,
                12,
                9,
                15,
                5,
                11,
                6,
                8,
                13,
                12,
                5,
                12,
                13,
                14,
                11,
                8,
                5,
                6
            ], sh1 = [
                8,
                9,
                9,
                11,
                13,
                15,
                15,
                5,
                7,
                7,
                8,
                11,
                14,
                14,
                12,
                6,
                9,
                13,
                15,
                7,
                12,
                8,
                9,
                11,
                7,
                7,
                12,
                7,
                6,
                15,
                13,
                11,
                9,
                7,
                15,
                11,
                8,
                6,
                6,
                14,
                12,
                13,
                5,
                14,
                13,
                13,
                7,
                5,
                15,
                5,
                8,
                11,
                14,
                14,
                6,
                14,
                6,
                9,
                12,
                9,
                12,
                5,
                15,
                8,
                8,
                5,
                12,
                9,
                12,
                5,
                14,
                6,
                8,
                13,
                6,
                5,
                15,
                13,
                11,
                11
            ];
        },
        9041: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            exports1.sha1 = __webpack_require__1(4761), exports1.sha224 = __webpack_require__1(799), exports1.sha256 = __webpack_require__1(9344), exports1.sha384 = __webpack_require__1(772), exports1.sha512 = __webpack_require__1(5900);
        },
        4761: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), common1 = __webpack_require__1(5772), shaCommon1 = __webpack_require__1(7038), rotl321 = utils1.rotl32, sum321 = utils1.sum32, sum32_51 = utils1.sum32_5, ft_11 = shaCommon1.ft_1, BlockHash1 = common1.BlockHash, sha1_K1 = [
                0x5A827999,
                0x6ED9EBA1,
                0x8F1BBCDC,
                0xCA62C1D6
            ];
            function SHA11() {
                if (!(this instanceof SHA11)) return new SHA11();
                BlockHash1.call(this), this.h = [
                    0x67452301,
                    0xefcdab89,
                    0x98badcfe,
                    0x10325476,
                    0xc3d2e1f0
                ], this.W = Array(80);
            }
            utils1.inherits(SHA11, BlockHash1), module1.exports = SHA11, SHA11.blockSize = 512, SHA11.outSize = 160, SHA11.hmacStrength = 80, SHA11.padLength = 64, SHA11.prototype._update = function(msg1, start1) {
                for(var W1 = this.W, i2 = 0; i2 < 16; i2++)W1[i2] = msg1[start1 + i2];
                for(; i2 < W1.length; i2++)W1[i2] = rotl321(W1[i2 - 3] ^ W1[i2 - 8] ^ W1[i2 - 14] ^ W1[i2 - 16], 1);
                var a10 = this.h[0], b10 = this.h[1], c5 = this.h[2], d3 = this.h[3], e1 = this.h[4];
                for(i2 = 0; i2 < W1.length; i2++){
                    var s3 = ~~(i2 / 20), t3 = sum32_51(rotl321(a10, 5), ft_11(s3, b10, c5, d3), e1, W1[i2], sha1_K1[s3]);
                    e1 = d3, d3 = c5, c5 = rotl321(b10, 30), b10 = a10, a10 = t3;
                }
                this.h[0] = sum321(this.h[0], a10), this.h[1] = sum321(this.h[1], b10), this.h[2] = sum321(this.h[2], c5), this.h[3] = sum321(this.h[3], d3), this.h[4] = sum321(this.h[4], e1);
            }, SHA11.prototype._digest = function(enc1) {
                return 'hex' === enc1 ? utils1.toHex32(this.h, 'big') : utils1.split32(this.h, 'big');
            };
        },
        799: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), SHA2561 = __webpack_require__1(9344);
            function SHA2241() {
                if (!(this instanceof SHA2241)) return new SHA2241();
                SHA2561.call(this), this.h = [
                    0xc1059ed8,
                    0x367cd507,
                    0x3070dd17,
                    0xf70e5939,
                    0xffc00b31,
                    0x68581511,
                    0x64f98fa7,
                    0xbefa4fa4
                ];
            }
            utils1.inherits(SHA2241, SHA2561), module1.exports = SHA2241, SHA2241.blockSize = 512, SHA2241.outSize = 224, SHA2241.hmacStrength = 192, SHA2241.padLength = 64, SHA2241.prototype._digest = function(enc1) {
                return 'hex' === enc1 ? utils1.toHex32(this.h.slice(0, 7), 'big') : utils1.split32(this.h.slice(0, 7), 'big');
            };
        },
        9344: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), common1 = __webpack_require__1(5772), shaCommon1 = __webpack_require__1(7038), assert1 = __webpack_require__1(9746), sum321 = utils1.sum32, sum32_41 = utils1.sum32_4, sum32_51 = utils1.sum32_5, ch321 = shaCommon1.ch32, maj321 = shaCommon1.maj32, s0_2561 = shaCommon1.s0_256, s1_2561 = shaCommon1.s1_256, g0_2561 = shaCommon1.g0_256, g1_2561 = shaCommon1.g1_256, BlockHash1 = common1.BlockHash, sha256_K1 = [
                0x428a2f98,
                0x71374491,
                0xb5c0fbcf,
                0xe9b5dba5,
                0x3956c25b,
                0x59f111f1,
                0x923f82a4,
                0xab1c5ed5,
                0xd807aa98,
                0x12835b01,
                0x243185be,
                0x550c7dc3,
                0x72be5d74,
                0x80deb1fe,
                0x9bdc06a7,
                0xc19bf174,
                0xe49b69c1,
                0xefbe4786,
                0x0fc19dc6,
                0x240ca1cc,
                0x2de92c6f,
                0x4a7484aa,
                0x5cb0a9dc,
                0x76f988da,
                0x983e5152,
                0xa831c66d,
                0xb00327c8,
                0xbf597fc7,
                0xc6e00bf3,
                0xd5a79147,
                0x06ca6351,
                0x14292967,
                0x27b70a85,
                0x2e1b2138,
                0x4d2c6dfc,
                0x53380d13,
                0x650a7354,
                0x766a0abb,
                0x81c2c92e,
                0x92722c85,
                0xa2bfe8a1,
                0xa81a664b,
                0xc24b8b70,
                0xc76c51a3,
                0xd192e819,
                0xd6990624,
                0xf40e3585,
                0x106aa070,
                0x19a4c116,
                0x1e376c08,
                0x2748774c,
                0x34b0bcb5,
                0x391c0cb3,
                0x4ed8aa4a,
                0x5b9cca4f,
                0x682e6ff3,
                0x748f82ee,
                0x78a5636f,
                0x84c87814,
                0x8cc70208,
                0x90befffa,
                0xa4506ceb,
                0xbef9a3f7,
                0xc67178f2
            ];
            function SHA2561() {
                if (!(this instanceof SHA2561)) return new SHA2561();
                BlockHash1.call(this), this.h = [
                    0x6a09e667,
                    0xbb67ae85,
                    0x3c6ef372,
                    0xa54ff53a,
                    0x510e527f,
                    0x9b05688c,
                    0x1f83d9ab,
                    0x5be0cd19
                ], this.k = sha256_K1, this.W = Array(64);
            }
            utils1.inherits(SHA2561, BlockHash1), module1.exports = SHA2561, SHA2561.blockSize = 512, SHA2561.outSize = 256, SHA2561.hmacStrength = 192, SHA2561.padLength = 64, SHA2561.prototype._update = function(msg1, start1) {
                for(var W1 = this.W, i2 = 0; i2 < 16; i2++)W1[i2] = msg1[start1 + i2];
                for(; i2 < W1.length; i2++)W1[i2] = sum32_41(g1_2561(W1[i2 - 2]), W1[i2 - 7], g0_2561(W1[i2 - 15]), W1[i2 - 16]);
                var a10 = this.h[0], b10 = this.h[1], c5 = this.h[2], d3 = this.h[3], e1 = this.h[4], f1 = this.h[5], g3 = this.h[6], h8 = this.h[7];
                for(assert1(this.k.length === W1.length), i2 = 0; i2 < W1.length; i2++){
                    var T11 = sum32_51(h8, s1_2561(e1), ch321(e1, f1, g3), this.k[i2], W1[i2]), T21 = sum321(s0_2561(a10), maj321(a10, b10, c5));
                    h8 = g3, g3 = f1, f1 = e1, e1 = sum321(d3, T11), d3 = c5, c5 = b10, b10 = a10, a10 = sum321(T11, T21);
                }
                this.h[0] = sum321(this.h[0], a10), this.h[1] = sum321(this.h[1], b10), this.h[2] = sum321(this.h[2], c5), this.h[3] = sum321(this.h[3], d3), this.h[4] = sum321(this.h[4], e1), this.h[5] = sum321(this.h[5], f1), this.h[6] = sum321(this.h[6], g3), this.h[7] = sum321(this.h[7], h8);
            }, SHA2561.prototype._digest = function(enc1) {
                return 'hex' === enc1 ? utils1.toHex32(this.h, 'big') : utils1.split32(this.h, 'big');
            };
        },
        772: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), SHA5121 = __webpack_require__1(5900);
            function SHA3841() {
                if (!(this instanceof SHA3841)) return new SHA3841();
                SHA5121.call(this), this.h = [
                    0xcbbb9d5d,
                    0xc1059ed8,
                    0x629a292a,
                    0x367cd507,
                    0x9159015a,
                    0x3070dd17,
                    0x152fecd8,
                    0xf70e5939,
                    0x67332667,
                    0xffc00b31,
                    0x8eb44a87,
                    0x68581511,
                    0xdb0c2e0d,
                    0x64f98fa7,
                    0x47b5481d,
                    0xbefa4fa4
                ];
            }
            utils1.inherits(SHA3841, SHA5121), module1.exports = SHA3841, SHA3841.blockSize = 1024, SHA3841.outSize = 384, SHA3841.hmacStrength = 192, SHA3841.padLength = 128, SHA3841.prototype._digest = function(enc1) {
                return 'hex' === enc1 ? utils1.toHex32(this.h.slice(0, 12), 'big') : utils1.split32(this.h.slice(0, 12), 'big');
            };
        },
        5900: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var utils1 = __webpack_require__1(6436), common1 = __webpack_require__1(5772), assert1 = __webpack_require__1(9746), rotr64_hi1 = utils1.rotr64_hi, rotr64_lo1 = utils1.rotr64_lo, shr64_hi1 = utils1.shr64_hi, shr64_lo1 = utils1.shr64_lo, sum641 = utils1.sum64, sum64_hi1 = utils1.sum64_hi, sum64_lo1 = utils1.sum64_lo, sum64_4_hi1 = utils1.sum64_4_hi, sum64_4_lo1 = utils1.sum64_4_lo, sum64_5_hi1 = utils1.sum64_5_hi, sum64_5_lo1 = utils1.sum64_5_lo, BlockHash1 = common1.BlockHash, sha512_K1 = [
                0x428a2f98,
                0xd728ae22,
                0x71374491,
                0x23ef65cd,
                0xb5c0fbcf,
                0xec4d3b2f,
                0xe9b5dba5,
                0x8189dbbc,
                0x3956c25b,
                0xf348b538,
                0x59f111f1,
                0xb605d019,
                0x923f82a4,
                0xaf194f9b,
                0xab1c5ed5,
                0xda6d8118,
                0xd807aa98,
                0xa3030242,
                0x12835b01,
                0x45706fbe,
                0x243185be,
                0x4ee4b28c,
                0x550c7dc3,
                0xd5ffb4e2,
                0x72be5d74,
                0xf27b896f,
                0x80deb1fe,
                0x3b1696b1,
                0x9bdc06a7,
                0x25c71235,
                0xc19bf174,
                0xcf692694,
                0xe49b69c1,
                0x9ef14ad2,
                0xefbe4786,
                0x384f25e3,
                0x0fc19dc6,
                0x8b8cd5b5,
                0x240ca1cc,
                0x77ac9c65,
                0x2de92c6f,
                0x592b0275,
                0x4a7484aa,
                0x6ea6e483,
                0x5cb0a9dc,
                0xbd41fbd4,
                0x76f988da,
                0x831153b5,
                0x983e5152,
                0xee66dfab,
                0xa831c66d,
                0x2db43210,
                0xb00327c8,
                0x98fb213f,
                0xbf597fc7,
                0xbeef0ee4,
                0xc6e00bf3,
                0x3da88fc2,
                0xd5a79147,
                0x930aa725,
                0x06ca6351,
                0xe003826f,
                0x14292967,
                0x0a0e6e70,
                0x27b70a85,
                0x46d22ffc,
                0x2e1b2138,
                0x5c26c926,
                0x4d2c6dfc,
                0x5ac42aed,
                0x53380d13,
                0x9d95b3df,
                0x650a7354,
                0x8baf63de,
                0x766a0abb,
                0x3c77b2a8,
                0x81c2c92e,
                0x47edaee6,
                0x92722c85,
                0x1482353b,
                0xa2bfe8a1,
                0x4cf10364,
                0xa81a664b,
                0xbc423001,
                0xc24b8b70,
                0xd0f89791,
                0xc76c51a3,
                0x0654be30,
                0xd192e819,
                0xd6ef5218,
                0xd6990624,
                0x5565a910,
                0xf40e3585,
                0x5771202a,
                0x106aa070,
                0x32bbd1b8,
                0x19a4c116,
                0xb8d2d0c8,
                0x1e376c08,
                0x5141ab53,
                0x2748774c,
                0xdf8eeb99,
                0x34b0bcb5,
                0xe19b48a8,
                0x391c0cb3,
                0xc5c95a63,
                0x4ed8aa4a,
                0xe3418acb,
                0x5b9cca4f,
                0x7763e373,
                0x682e6ff3,
                0xd6b2b8a3,
                0x748f82ee,
                0x5defb2fc,
                0x78a5636f,
                0x43172f60,
                0x84c87814,
                0xa1f0ab72,
                0x8cc70208,
                0x1a6439ec,
                0x90befffa,
                0x23631e28,
                0xa4506ceb,
                0xde82bde9,
                0xbef9a3f7,
                0xb2c67915,
                0xc67178f2,
                0xe372532b,
                0xca273ece,
                0xea26619c,
                0xd186b8c7,
                0x21c0c207,
                0xeada7dd6,
                0xcde0eb1e,
                0xf57d4f7f,
                0xee6ed178,
                0x06f067aa,
                0x72176fba,
                0x0a637dc5,
                0xa2c898a6,
                0x113f9804,
                0xbef90dae,
                0x1b710b35,
                0x131c471b,
                0x28db77f5,
                0x23047d84,
                0x32caab7b,
                0x40c72493,
                0x3c9ebe0a,
                0x15c9bebc,
                0x431d67c4,
                0x9c100d4c,
                0x4cc5d4be,
                0xcb3e42b6,
                0x597f299c,
                0xfc657e2a,
                0x5fcb6fab,
                0x3ad6faec,
                0x6c44198c,
                0x4a475817
            ];
            function SHA5121() {
                if (!(this instanceof SHA5121)) return new SHA5121();
                BlockHash1.call(this), this.h = [
                    0x6a09e667,
                    0xf3bcc908,
                    0xbb67ae85,
                    0x84caa73b,
                    0x3c6ef372,
                    0xfe94f82b,
                    0xa54ff53a,
                    0x5f1d36f1,
                    0x510e527f,
                    0xade682d1,
                    0x9b05688c,
                    0x2b3e6c1f,
                    0x1f83d9ab,
                    0xfb41bd6b,
                    0x5be0cd19,
                    0x137e2179
                ], this.k = sha512_K1, this.W = Array(160);
            }
            function ch64_hi1(xh1, xl1, yh1, yl1, zh1) {
                var r3 = xh1 & yh1 ^ ~xh1 & zh1;
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function ch64_lo1(xh1, xl1, yh1, yl1, zh1, zl1) {
                var r3 = xl1 & yl1 ^ ~xl1 & zl1;
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function maj64_hi1(xh1, xl1, yh1, yl1, zh1) {
                var r3 = xh1 & yh1 ^ xh1 & zh1 ^ yh1 & zh1;
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function maj64_lo1(xh1, xl1, yh1, yl1, zh1, zl1) {
                var r3 = xl1 & yl1 ^ xl1 & zl1 ^ yl1 & zl1;
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function s0_512_hi1(xh1, xl1) {
                var r3 = rotr64_hi1(xh1, xl1, 28) ^ rotr64_hi1(xl1, xh1, 2) ^ rotr64_hi1(xl1, xh1, 7);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function s0_512_lo1(xh1, xl1) {
                var r3 = rotr64_lo1(xh1, xl1, 28) ^ rotr64_lo1(xl1, xh1, 2) ^ rotr64_lo1(xl1, xh1, 7);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function s1_512_hi1(xh1, xl1) {
                var r3 = rotr64_hi1(xh1, xl1, 14) ^ rotr64_hi1(xh1, xl1, 18) ^ rotr64_hi1(xl1, xh1, 9);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function s1_512_lo1(xh1, xl1) {
                var r3 = rotr64_lo1(xh1, xl1, 14) ^ rotr64_lo1(xh1, xl1, 18) ^ rotr64_lo1(xl1, xh1, 9);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function g0_512_hi1(xh1, xl1) {
                var r3 = rotr64_hi1(xh1, xl1, 1) ^ rotr64_hi1(xh1, xl1, 8) ^ shr64_hi1(xh1, xl1, 7);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function g0_512_lo1(xh1, xl1) {
                var r3 = rotr64_lo1(xh1, xl1, 1) ^ rotr64_lo1(xh1, xl1, 8) ^ shr64_lo1(xh1, xl1, 7);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function g1_512_hi1(xh1, xl1) {
                var r3 = rotr64_hi1(xh1, xl1, 19) ^ rotr64_hi1(xl1, xh1, 29) ^ shr64_hi1(xh1, xl1, 6);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            function g1_512_lo1(xh1, xl1) {
                var r3 = rotr64_lo1(xh1, xl1, 19) ^ rotr64_lo1(xl1, xh1, 29) ^ shr64_lo1(xh1, xl1, 6);
                return r3 < 0 && (r3 += 0x100000000), r3;
            }
            utils1.inherits(SHA5121, BlockHash1), module1.exports = SHA5121, SHA5121.blockSize = 1024, SHA5121.outSize = 512, SHA5121.hmacStrength = 192, SHA5121.padLength = 128, SHA5121.prototype._prepareBlock = function(msg1, start1) {
                for(var W1 = this.W, i2 = 0; i2 < 32; i2++)W1[i2] = msg1[start1 + i2];
                for(; i2 < W1.length; i2 += 2){
                    var c0_hi1 = g1_512_hi1(W1[i2 - 4], W1[i2 - 3]), c0_lo1 = g1_512_lo1(W1[i2 - 4], W1[i2 - 3]), c1_hi1 = W1[i2 - 14], c1_lo1 = W1[i2 - 13], c2_hi1 = g0_512_hi1(W1[i2 - 30], W1[i2 - 29]), c2_lo1 = g0_512_lo1(W1[i2 - 30], W1[i2 - 29]), c3_hi1 = W1[i2 - 32], c3_lo1 = W1[i2 - 31];
                    W1[i2] = sum64_4_hi1(c0_hi1, c0_lo1, c1_hi1, c1_lo1, c2_hi1, c2_lo1, c3_hi1, c3_lo1), W1[i2 + 1] = sum64_4_lo1(c0_hi1, c0_lo1, c1_hi1, c1_lo1, c2_hi1, c2_lo1, c3_hi1, c3_lo1);
                }
            }, SHA5121.prototype._update = function(msg1, start1) {
                this._prepareBlock(msg1, start1);
                var W1 = this.W, ah10 = this.h[0], al10 = this.h[1], bh10 = this.h[2], bl10 = this.h[3], ch1 = this.h[4], cl1 = this.h[5], dh1 = this.h[6], dl1 = this.h[7], eh1 = this.h[8], el1 = this.h[9], fh1 = this.h[10], fl1 = this.h[11], gh1 = this.h[12], gl1 = this.h[13], hh1 = this.h[14], hl1 = this.h[15];
                assert1(this.k.length === W1.length);
                for(var i2 = 0; i2 < W1.length; i2 += 2){
                    var c0_hi1 = hh1, c0_lo1 = hl1, c1_hi1 = s1_512_hi1(eh1, el1), c1_lo1 = s1_512_lo1(eh1, el1), c2_hi1 = ch64_hi1(eh1, el1, fh1, fl1, gh1, gl1), c2_lo1 = ch64_lo1(eh1, el1, fh1, fl1, gh1, gl1), c3_hi1 = this.k[i2], c3_lo1 = this.k[i2 + 1], c4_hi1 = W1[i2], c4_lo1 = W1[i2 + 1], T1_hi1 = sum64_5_hi1(c0_hi1, c0_lo1, c1_hi1, c1_lo1, c2_hi1, c2_lo1, c3_hi1, c3_lo1, c4_hi1, c4_lo1), T1_lo1 = sum64_5_lo1(c0_hi1, c0_lo1, c1_hi1, c1_lo1, c2_hi1, c2_lo1, c3_hi1, c3_lo1, c4_hi1, c4_lo1);
                    c0_hi1 = s0_512_hi1(ah10, al10), c0_lo1 = s0_512_lo1(ah10, al10), c1_hi1 = maj64_hi1(ah10, al10, bh10, bl10, ch1, cl1), c1_lo1 = maj64_lo1(ah10, al10, bh10, bl10, ch1, cl1);
                    var T2_hi1 = sum64_hi1(c0_hi1, c0_lo1, c1_hi1, c1_lo1), T2_lo1 = sum64_lo1(c0_hi1, c0_lo1, c1_hi1, c1_lo1);
                    hh1 = gh1, hl1 = gl1, gh1 = fh1, gl1 = fl1, fh1 = eh1, fl1 = el1, eh1 = sum64_hi1(dh1, dl1, T1_hi1, T1_lo1), el1 = sum64_lo1(dl1, dl1, T1_hi1, T1_lo1), dh1 = ch1, dl1 = cl1, ch1 = bh10, cl1 = bl10, bh10 = ah10, bl10 = al10, ah10 = sum64_hi1(T1_hi1, T1_lo1, T2_hi1, T2_lo1), al10 = sum64_lo1(T1_hi1, T1_lo1, T2_hi1, T2_lo1);
                }
                sum641(this.h, 0, ah10, al10), sum641(this.h, 2, bh10, bl10), sum641(this.h, 4, ch1, cl1), sum641(this.h, 6, dh1, dl1), sum641(this.h, 8, eh1, el1), sum641(this.h, 10, fh1, fl1), sum641(this.h, 12, gh1, gl1), sum641(this.h, 14, hh1, hl1);
            }, SHA5121.prototype._digest = function(enc1) {
                return 'hex' === enc1 ? utils1.toHex32(this.h, 'big') : utils1.split32(this.h, 'big');
            };
        },
        7038: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var rotr321 = __webpack_require__1(6436).rotr32;
            function ft_11(s3, x3, y3, z1) {
                return 0 === s3 ? ch321(x3, y3, z1) : 1 === s3 || 3 === s3 ? p321(x3, y3, z1) : 2 === s3 ? maj321(x3, y3, z1) : void 0;
            }
            function ch321(x3, y3, z1) {
                return x3 & y3 ^ ~x3 & z1;
            }
            function maj321(x3, y3, z1) {
                return x3 & y3 ^ x3 & z1 ^ y3 & z1;
            }
            function p321(x3, y3, z1) {
                return x3 ^ y3 ^ z1;
            }
            function s0_2561(x3) {
                return rotr321(x3, 2) ^ rotr321(x3, 13) ^ rotr321(x3, 22);
            }
            function s1_2561(x3) {
                return rotr321(x3, 6) ^ rotr321(x3, 11) ^ rotr321(x3, 25);
            }
            function g0_2561(x3) {
                return rotr321(x3, 7) ^ rotr321(x3, 18) ^ x3 >>> 3;
            }
            function g1_2561(x3) {
                return rotr321(x3, 17) ^ rotr321(x3, 19) ^ x3 >>> 10;
            }
            exports1.ft_1 = ft_11, exports1.ch32 = ch321, exports1.maj32 = maj321, exports1.p32 = p321, exports1.s0_256 = s0_2561, exports1.s1_256 = s1_2561, exports1.g0_256 = g0_2561, exports1.g1_256 = g1_2561;
        },
        6436: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var assert1 = __webpack_require__1(9746), inherits1 = __webpack_require__1(5717);
            function isSurrogatePair1(msg1, i2) {
                return (0xFC00 & msg1.charCodeAt(i2)) == 0xD800 && !(i2 < 0) && !(i2 + 1 >= msg1.length) && (0xFC00 & msg1.charCodeAt(i2 + 1)) == 0xDC00;
            }
            function toArray1(msg1, enc1) {
                if (Array.isArray(msg1)) return msg1.slice();
                if (!msg1) return [];
                var res1 = [];
                if ('string' == typeof msg1) {
                    if (enc1) {
                        if ('hex' === enc1) for((msg1 = msg1.replace(/[^a-z0-9]+/ig, '')).length % 2 != 0 && (msg1 = '0' + msg1), i2 = 0; i2 < msg1.length; i2 += 2)res1.push(parseInt(msg1[i2] + msg1[i2 + 1], 16));
                    } else for(var p3 = 0, i2 = 0; i2 < msg1.length; i2++){
                        var c5 = msg1.charCodeAt(i2);
                        c5 < 128 ? res1[p3++] = c5 : c5 < 2048 ? (res1[p3++] = c5 >> 6 | 192, res1[p3++] = 63 & c5 | 128) : isSurrogatePair1(msg1, i2) ? (c5 = 0x10000 + ((0x03FF & c5) << 10) + (0x03FF & msg1.charCodeAt(++i2)), res1[p3++] = c5 >> 18 | 240, res1[p3++] = c5 >> 12 & 63 | 128, res1[p3++] = c5 >> 6 & 63 | 128, res1[p3++] = 63 & c5 | 128) : (res1[p3++] = c5 >> 12 | 224, res1[p3++] = c5 >> 6 & 63 | 128, res1[p3++] = 63 & c5 | 128);
                    }
                } else for(i2 = 0; i2 < msg1.length; i2++)res1[i2] = 0 | msg1[i2];
                return res1;
            }
            function toHex1(msg1) {
                for(var res1 = '', i2 = 0; i2 < msg1.length; i2++)res1 += zero21(msg1[i2].toString(16));
                return res1;
            }
            function htonl1(w19) {
                return (w19 >>> 24 | w19 >>> 8 & 0xff00 | w19 << 8 & 0xff0000 | (0xff & w19) << 24) >>> 0;
            }
            function toHex321(msg1, endian1) {
                for(var res1 = '', i2 = 0; i2 < msg1.length; i2++){
                    var w19 = msg1[i2];
                    'little' === endian1 && (w19 = htonl1(w19)), res1 += zero81(w19.toString(16));
                }
                return res1;
            }
            function zero21(word1) {
                return 1 === word1.length ? '0' + word1 : word1;
            }
            function zero81(word1) {
                return 7 === word1.length ? '0' + word1 : 6 === word1.length ? '00' + word1 : 5 === word1.length ? '000' + word1 : 4 === word1.length ? '0000' + word1 : 3 === word1.length ? '00000' + word1 : 2 === word1.length ? '000000' + word1 : 1 === word1.length ? '0000000' + word1 : word1;
            }
            function join321(msg1, start1, end1, endian1) {
                var w19, len3 = end1 - start1;
                assert1(len3 % 4 == 0);
                for(var res1 = Array(len3 / 4), i2 = 0, k3 = start1; i2 < res1.length; i2++, k3 += 4)w19 = 'big' === endian1 ? msg1[k3] << 24 | msg1[k3 + 1] << 16 | msg1[k3 + 2] << 8 | msg1[k3 + 3] : msg1[k3 + 3] << 24 | msg1[k3 + 2] << 16 | msg1[k3 + 1] << 8 | msg1[k3], res1[i2] = w19 >>> 0;
                return res1;
            }
            function split321(msg1, endian1) {
                for(var res1 = Array(4 * msg1.length), i2 = 0, k3 = 0; i2 < msg1.length; i2++, k3 += 4){
                    var m1 = msg1[i2];
                    'big' === endian1 ? (res1[k3] = m1 >>> 24, res1[k3 + 1] = m1 >>> 16 & 0xff, res1[k3 + 2] = m1 >>> 8 & 0xff, res1[k3 + 3] = 0xff & m1) : (res1[k3 + 3] = m1 >>> 24, res1[k3 + 2] = m1 >>> 16 & 0xff, res1[k3 + 1] = m1 >>> 8 & 0xff, res1[k3] = 0xff & m1);
                }
                return res1;
            }
            function rotr321(w19, b10) {
                return w19 >>> b10 | w19 << 32 - b10;
            }
            function rotl321(w19, b10) {
                return w19 << b10 | w19 >>> 32 - b10;
            }
            function sum321(a10, b10) {
                return a10 + b10 >>> 0;
            }
            function sum32_31(a10, b10, c5) {
                return a10 + b10 + c5 >>> 0;
            }
            function sum32_41(a10, b10, c5, d3) {
                return a10 + b10 + c5 + d3 >>> 0;
            }
            function sum32_51(a10, b10, c5, d3, e1) {
                return a10 + b10 + c5 + d3 + e1 >>> 0;
            }
            function sum641(buf1, pos1, ah10, al10) {
                var bh10 = buf1[pos1], lo1 = al10 + buf1[pos1 + 1] >>> 0, hi1 = (lo1 < al10 ? 1 : 0) + ah10 + bh10;
                buf1[pos1] = hi1 >>> 0, buf1[pos1 + 1] = lo1;
            }
            function sum64_hi1(ah10, al10, bh10, bl10) {
                return (al10 + bl10 >>> 0 < al10 ? 1 : 0) + ah10 + bh10 >>> 0;
            }
            function sum64_lo1(ah10, al10, bh10, bl10) {
                return al10 + bl10 >>> 0;
            }
            function sum64_4_hi1(ah10, al10, bh10, bl10, ch1, cl1, dh1, dl1) {
                var carry1, lo1 = al10;
                return ah10 + bh10 + ch1 + dh1 + (carry1 = 0 + ((lo1 = lo1 + bl10 >>> 0) < al10 ? 1 : 0) + ((lo1 = lo1 + cl1 >>> 0) < cl1 ? 1 : 0) + ((lo1 = lo1 + dl1 >>> 0) < dl1 ? 1 : 0)) >>> 0;
            }
            function sum64_4_lo1(ah10, al10, bh10, bl10, ch1, cl1, dh1, dl1) {
                return al10 + bl10 + cl1 + dl1 >>> 0;
            }
            function sum64_5_hi1(ah10, al10, bh10, bl10, ch1, cl1, dh1, dl1, eh1, el1) {
                var carry1, lo1 = al10;
                return ah10 + bh10 + ch1 + dh1 + eh1 + (carry1 = 0 + ((lo1 = lo1 + bl10 >>> 0) < al10 ? 1 : 0) + ((lo1 = lo1 + cl1 >>> 0) < cl1 ? 1 : 0) + ((lo1 = lo1 + dl1 >>> 0) < dl1 ? 1 : 0) + ((lo1 = lo1 + el1 >>> 0) < el1 ? 1 : 0)) >>> 0;
            }
            function sum64_5_lo1(ah10, al10, bh10, bl10, ch1, cl1, dh1, dl1, eh1, el1) {
                return al10 + bl10 + cl1 + dl1 + el1 >>> 0;
            }
            function rotr64_hi1(ah10, al10, num1) {
                return (al10 << 32 - num1 | ah10 >>> num1) >>> 0;
            }
            function rotr64_lo1(ah10, al10, num1) {
                return (ah10 << 32 - num1 | al10 >>> num1) >>> 0;
            }
            function shr64_hi1(ah10, al10, num1) {
                return ah10 >>> num1;
            }
            function shr64_lo1(ah10, al10, num1) {
                return (ah10 << 32 - num1 | al10 >>> num1) >>> 0;
            }
            exports1.inherits = inherits1, exports1.toArray = toArray1, exports1.toHex = toHex1, exports1.htonl = htonl1, exports1.toHex32 = toHex321, exports1.zero2 = zero21, exports1.zero8 = zero81, exports1.join32 = join321, exports1.split32 = split321, exports1.rotr32 = rotr321, exports1.rotl32 = rotl321, exports1.sum32 = sum321, exports1.sum32_3 = sum32_31, exports1.sum32_4 = sum32_41, exports1.sum32_5 = sum32_51, exports1.sum64 = sum641, exports1.sum64_hi = sum64_hi1, exports1.sum64_lo = sum64_lo1, exports1.sum64_4_hi = sum64_4_hi1, exports1.sum64_4_lo = sum64_4_lo1, exports1.sum64_5_hi = sum64_5_hi1, exports1.sum64_5_lo = sum64_5_lo1, exports1.rotr64_hi = rotr64_hi1, exports1.rotr64_lo = rotr64_lo1, exports1.shr64_hi = shr64_hi1, exports1.shr64_lo = shr64_lo1;
        },
        2156: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var hash1 = __webpack_require__1(3715), utils1 = __webpack_require__1(4504), assert1 = __webpack_require__1(9746);
            function HmacDRBG1(options1) {
                if (!(this instanceof HmacDRBG1)) return new HmacDRBG1(options1);
                this.hash = options1.hash, this.predResist = !!options1.predResist, this.outLen = this.hash.outSize, this.minEntropy = options1.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
                var entropy1 = utils1.toArray(options1.entropy, options1.entropyEnc || 'hex'), nonce1 = utils1.toArray(options1.nonce, options1.nonceEnc || 'hex'), pers1 = utils1.toArray(options1.pers, options1.persEnc || 'hex');
                assert1(entropy1.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._init(entropy1, nonce1, pers1);
            }
            module1.exports = HmacDRBG1, HmacDRBG1.prototype._init = function(entropy1, nonce1, pers1) {
                var seed1 = entropy1.concat(nonce1).concat(pers1);
                this.K = Array(this.outLen / 8), this.V = Array(this.outLen / 8);
                for(var i2 = 0; i2 < this.V.length; i2++)this.K[i2] = 0x00, this.V[i2] = 0x01;
                this._update(seed1), this._reseed = 1, this.reseedInterval = 0x1000000000000;
            }, HmacDRBG1.prototype._hmac = function() {
                return new hash1.hmac(this.hash, this.K);
            }, HmacDRBG1.prototype._update = function(seed1) {
                var kmac1 = this._hmac().update(this.V).update([
                    0x00
                ]);
                seed1 && (kmac1 = kmac1.update(seed1)), this.K = kmac1.digest(), this.V = this._hmac().update(this.V).digest(), seed1 && (this.K = this._hmac().update(this.V).update([
                    0x01
                ]).update(seed1).digest(), this.V = this._hmac().update(this.V).digest());
            }, HmacDRBG1.prototype.reseed = function(entropy1, entropyEnc1, add1, addEnc1) {
                'string' != typeof entropyEnc1 && (addEnc1 = add1, add1 = entropyEnc1, entropyEnc1 = null), entropy1 = utils1.toArray(entropy1, entropyEnc1), add1 = utils1.toArray(add1, addEnc1), assert1(entropy1.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._update(entropy1.concat(add1 || [])), this._reseed = 1;
            }, HmacDRBG1.prototype.generate = function(len3, enc1, add1, addEnc1) {
                if (this._reseed > this.reseedInterval) throw Error('Reseed is required');
                'string' != typeof enc1 && (addEnc1 = add1, add1 = enc1, enc1 = null), add1 && (add1 = utils1.toArray(add1, addEnc1 || 'hex'), this._update(add1));
                for(var temp1 = []; temp1.length < len3;)this.V = this._hmac().update(this.V).digest(), temp1 = temp1.concat(this.V);
                var res1 = temp1.slice(0, len3);
                return this._update(add1), this._reseed++, utils1.encode(res1, enc1);
            };
        },
        645: function(__unused_webpack_module1, exports1) {
            exports1.read = function(buffer1, offset1, isLE1, mLen1, nBytes1) {
                var e1, m1, eLen1 = 8 * nBytes1 - mLen1 - 1, eMax1 = (1 << eLen1) - 1, eBias1 = eMax1 >> 1, nBits1 = -7, i2 = isLE1 ? nBytes1 - 1 : 0, d3 = isLE1 ? -1 : 1, s3 = buffer1[offset1 + i2];
                for(i2 += d3, e1 = s3 & (1 << -nBits1) - 1, s3 >>= -nBits1, nBits1 += eLen1; nBits1 > 0; e1 = 256 * e1 + buffer1[offset1 + i2], i2 += d3, nBits1 -= 8);
                for(m1 = e1 & (1 << -nBits1) - 1, e1 >>= -nBits1, nBits1 += mLen1; nBits1 > 0; m1 = 256 * m1 + buffer1[offset1 + i2], i2 += d3, nBits1 -= 8);
                if (0 === e1) e1 = 1 - eBias1;
                else {
                    if (e1 === eMax1) return m1 ? NaN : (s3 ? -1 : 1) * (1 / 0);
                    m1 += Math.pow(2, mLen1), e1 -= eBias1;
                }
                return (s3 ? -1 : 1) * m1 * Math.pow(2, e1 - mLen1);
            }, exports1.write = function(buffer1, value1, offset1, isLE1, mLen1, nBytes1) {
                var e1, m1, c5, eLen1 = 8 * nBytes1 - mLen1 - 1, eMax1 = (1 << eLen1) - 1, eBias1 = eMax1 >> 1, rt1 = 23 === mLen1 ? 0.00000005960464477539062 : 0, i2 = isLE1 ? 0 : nBytes1 - 1, d3 = isLE1 ? 1 : -1, s3 = value1 < 0 || 0 === value1 && 1 / value1 < 0 ? 1 : 0;
                for(isNaN(value1 = Math.abs(value1)) || value1 === 1 / 0 ? (m1 = isNaN(value1) ? 1 : 0, e1 = eMax1) : (e1 = Math.floor(Math.log(value1) / Math.LN2), value1 * (c5 = Math.pow(2, -e1)) < 1 && (e1--, c5 *= 2), e1 + eBias1 >= 1 ? value1 += rt1 / c5 : value1 += rt1 * Math.pow(2, 1 - eBias1), value1 * c5 >= 2 && (e1++, c5 /= 2), e1 + eBias1 >= eMax1 ? (m1 = 0, e1 = eMax1) : e1 + eBias1 >= 1 ? (m1 = (value1 * c5 - 1) * Math.pow(2, mLen1), e1 += eBias1) : (m1 = value1 * Math.pow(2, eBias1 - 1) * Math.pow(2, mLen1), e1 = 0)); mLen1 >= 8; buffer1[offset1 + i2] = 0xff & m1, i2 += d3, m1 /= 256, mLen1 -= 8);
                for(e1 = e1 << mLen1 | m1, eLen1 += mLen1; eLen1 > 0; buffer1[offset1 + i2] = 0xff & e1, i2 += d3, e1 /= 256, eLen1 -= 8);
                buffer1[offset1 + i2 - d3] |= 128 * s3;
            };
        },
        5717: function(module1) {
            'function' == typeof Object.create ? module1.exports = function(ctor1, superCtor1) {
                superCtor1 && (ctor1.super_ = superCtor1, ctor1.prototype = Object.create(superCtor1.prototype, {
                    constructor: {
                        value: ctor1,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }));
            } : module1.exports = function(ctor1, superCtor1) {
                if (superCtor1) {
                    ctor1.super_ = superCtor1;
                    var TempCtor1 = function() {};
                    TempCtor1.prototype = superCtor1.prototype, ctor1.prototype = new TempCtor1(), ctor1.prototype.constructor = ctor1;
                }
            };
        },
        2584: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var hasToStringTag1 = __webpack_require__1(6410)(), $toString1 = __webpack_require__1(1924)('Object.prototype.toString'), isStandardArguments1 = function(value1) {
                return (!hasToStringTag1 || !value1 || 'object' != typeof value1 || !(Symbol.toStringTag in value1)) && '[object Arguments]' === $toString1(value1);
            }, isLegacyArguments1 = function(value1) {
                return !!isStandardArguments1(value1) || null !== value1 && 'object' == typeof value1 && 'number' == typeof value1.length && value1.length >= 0 && '[object Array]' !== $toString1(value1) && '[object Function]' === $toString1(value1.callee);
            }, supportsStandardArguments1 = function() {
                return isStandardArguments1(arguments);
            }();
            isStandardArguments1.isLegacyArguments = isLegacyArguments1, module1.exports = supportsStandardArguments1 ? isStandardArguments1 : isLegacyArguments1;
        },
        5320: function(module1) {
            "use strict";
            var badArrayLike1, isCallableMarker1, fnToStr1 = Function.prototype.toString, reflectApply1 = 'object' == typeof Reflect && null !== Reflect && Reflect.apply;
            if ('function' == typeof reflectApply1 && 'function' == typeof Object.defineProperty) try {
                badArrayLike1 = Object.defineProperty({}, 'length', {
                    get: function() {
                        throw isCallableMarker1;
                    }
                }), isCallableMarker1 = {}, reflectApply1(function() {
                    throw 42;
                }, null, badArrayLike1);
            } catch (_1) {
                _1 !== isCallableMarker1 && (reflectApply1 = null);
            }
            else reflectApply1 = null;
            var constructorRegex1 = /^\s*class\b/, isES6ClassFn1 = function(value1) {
                try {
                    var fnStr1 = fnToStr1.call(value1);
                    return constructorRegex1.test(fnStr1);
                } catch (e1) {
                    return !1;
                }
            }, tryFunctionObject1 = function(value1) {
                try {
                    if (isES6ClassFn1(value1)) return !1;
                    return fnToStr1.call(value1), !0;
                } catch (e1) {
                    return !1;
                }
            }, toStr1 = Object.prototype.toString, fnClass1 = '[object Function]', genClass1 = '[object GeneratorFunction]', hasToStringTag1 = 'function' == typeof Symbol && !!Symbol.toStringTag, documentDotAll1 = 'object' == typeof document && void 0 === document.all && void 0 !== document.all ? document.all : {};
            module1.exports = reflectApply1 ? function(value1) {
                if (value1 === documentDotAll1) return !0;
                if (!value1 || 'function' != typeof value1 && 'object' != typeof value1) return !1;
                if ('function' == typeof value1 && !value1.prototype) return !0;
                try {
                    reflectApply1(value1, null, badArrayLike1);
                } catch (e1) {
                    if (e1 !== isCallableMarker1) return !1;
                }
                return !isES6ClassFn1(value1);
            } : function(value1) {
                if (value1 === documentDotAll1) return !0;
                if (!value1 || 'function' != typeof value1 && 'object' != typeof value1) return !1;
                if ('function' == typeof value1 && !value1.prototype) return !0;
                if (hasToStringTag1) return tryFunctionObject1(value1);
                if (isES6ClassFn1(value1)) return !1;
                var strClass1 = toStr1.call(value1);
                return strClass1 === fnClass1 || strClass1 === genClass1;
            };
        },
        8662: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var GeneratorFunction1, toStr1 = Object.prototype.toString, fnToStr1 = Function.prototype.toString, isFnRegex1 = /^\s*(?:function)?\*/, hasToStringTag1 = __webpack_require__1(6410)(), getProto1 = Object.getPrototypeOf, getGeneratorFunc1 = function() {
                if (!hasToStringTag1) return !1;
                try {
                    return Function('return function*() {}')();
                } catch (e1) {}
            };
            module1.exports = function(fn1) {
                if ('function' != typeof fn1) return !1;
                if (isFnRegex1.test(fnToStr1.call(fn1))) return !0;
                if (!hasToStringTag1) return '[object GeneratorFunction]' === toStr1.call(fn1);
                if (!getProto1) return !1;
                if (void 0 === GeneratorFunction1) {
                    var generatorFunc1 = getGeneratorFunc1();
                    GeneratorFunction1 = !!generatorFunc1 && getProto1(generatorFunc1);
                }
                return getProto1(fn1) === GeneratorFunction1;
            };
        },
        5692: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var forEach1 = __webpack_require__1(4029), availableTypedArrays1 = __webpack_require__1(3083), callBound1 = __webpack_require__1(1924), $toString1 = callBound1('Object.prototype.toString'), hasToStringTag1 = __webpack_require__1(6410)(), g3 = 'undefined' == typeof globalThis ? __webpack_require__1.g : globalThis, typedArrays1 = availableTypedArrays1(), $indexOf1 = callBound1('Array.prototype.indexOf', !0) || function(array1, value1) {
                for(var i2 = 0; i2 < array1.length; i2 += 1)if (array1[i2] === value1) return i2;
                return -1;
            }, $slice1 = callBound1('String.prototype.slice'), toStrTags1 = {}, gOPD1 = __webpack_require__1(882), getPrototypeOf1 = Object.getPrototypeOf;
            hasToStringTag1 && gOPD1 && getPrototypeOf1 && forEach1(typedArrays1, function(typedArray1) {
                var arr1 = new g3[typedArray1]();
                if (Symbol.toStringTag in arr1) {
                    var proto1 = getPrototypeOf1(arr1), descriptor1 = gOPD1(proto1, Symbol.toStringTag);
                    descriptor1 || (descriptor1 = gOPD1(getPrototypeOf1(proto1), Symbol.toStringTag)), toStrTags1[typedArray1] = descriptor1.get;
                }
            });
            var tryTypedArrays1 = function(value1) {
                var anyTrue1 = !1;
                return forEach1(toStrTags1, function(getter1, typedArray1) {
                    if (!anyTrue1) try {
                        anyTrue1 = getter1.call(value1) === typedArray1;
                    } catch (e1) {}
                }), anyTrue1;
            };
            module1.exports = function(value1) {
                return !!value1 && 'object' == typeof value1 && (hasToStringTag1 && Symbol.toStringTag in value1 ? !!gOPD1 && tryTypedArrays1(value1) : $indexOf1(typedArrays1, $slice1($toString1(value1), 8, -1)) > -1);
            };
        },
        2023: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__, process = __webpack_require__(3454);
            !function() {
                'use strict';
                var ERROR = 'input is invalid type', WINDOW = 'object' == typeof window, root = WINDOW ? window : {};
                root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
                var WEB_WORKER = !WINDOW && 'object' == typeof self, NODE_JS = !root.JS_SHA256_NO_NODE_JS && 'object' == typeof process && process.versions && process.versions.node;
                NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
                var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && module.exports, AMD = __webpack_require__.amdO, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && 'undefined' != typeof ArrayBuffer, HEX_CHARS = '0123456789abcdef'.split(''), EXTRA = [
                    -2147483648,
                    8388608,
                    32768,
                    128
                ], SHIFT = [
                    24,
                    16,
                    8,
                    0
                ], K = [
                    0x428a2f98,
                    0x71374491,
                    0xb5c0fbcf,
                    0xe9b5dba5,
                    0x3956c25b,
                    0x59f111f1,
                    0x923f82a4,
                    0xab1c5ed5,
                    0xd807aa98,
                    0x12835b01,
                    0x243185be,
                    0x550c7dc3,
                    0x72be5d74,
                    0x80deb1fe,
                    0x9bdc06a7,
                    0xc19bf174,
                    0xe49b69c1,
                    0xefbe4786,
                    0x0fc19dc6,
                    0x240ca1cc,
                    0x2de92c6f,
                    0x4a7484aa,
                    0x5cb0a9dc,
                    0x76f988da,
                    0x983e5152,
                    0xa831c66d,
                    0xb00327c8,
                    0xbf597fc7,
                    0xc6e00bf3,
                    0xd5a79147,
                    0x06ca6351,
                    0x14292967,
                    0x27b70a85,
                    0x2e1b2138,
                    0x4d2c6dfc,
                    0x53380d13,
                    0x650a7354,
                    0x766a0abb,
                    0x81c2c92e,
                    0x92722c85,
                    0xa2bfe8a1,
                    0xa81a664b,
                    0xc24b8b70,
                    0xc76c51a3,
                    0xd192e819,
                    0xd6990624,
                    0xf40e3585,
                    0x106aa070,
                    0x19a4c116,
                    0x1e376c08,
                    0x2748774c,
                    0x34b0bcb5,
                    0x391c0cb3,
                    0x4ed8aa4a,
                    0x5b9cca4f,
                    0x682e6ff3,
                    0x748f82ee,
                    0x78a5636f,
                    0x84c87814,
                    0x8cc70208,
                    0x90befffa,
                    0xa4506ceb,
                    0xbef9a3f7,
                    0xc67178f2
                ], OUTPUT_TYPES = [
                    'hex',
                    'array',
                    'digest',
                    'arrayBuffer'
                ], blocks = [];
                (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(obj1) {
                    return '[object Array]' === Object.prototype.toString.call(obj1);
                }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(obj1) {
                    return 'object' == typeof obj1 && obj1.buffer && obj1.buffer.constructor === ArrayBuffer;
                });
                var createOutputMethod = function(outputType1, is2241) {
                    return function(message1) {
                        return new Sha256(is2241, !0).update(message1)[outputType1]();
                    };
                }, createMethod = function(is2241) {
                    var method1 = createOutputMethod('hex', is2241);
                    NODE_JS && (method1 = nodeWrap(method1, is2241)), method1.create = function() {
                        return new Sha256(is2241);
                    }, method1.update = function(message1) {
                        return method1.create().update(message1);
                    };
                    for(var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2){
                        var type1 = OUTPUT_TYPES[i2];
                        method1[type1] = createOutputMethod(type1, is2241);
                    }
                    return method1;
                }, nodeWrap = function(method, is224) {
                    var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? 'sha224' : 'sha256', nodeMethod = function(message1) {
                        if ('string' == typeof message1) return crypto.createHash(algorithm).update(message1, 'utf8').digest('hex');
                        if (null == message1) throw Error(ERROR);
                        return message1.constructor === ArrayBuffer && (message1 = new Uint8Array(message1)), Array.isArray(message1) || ArrayBuffer.isView(message1) || message1.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(message1)).digest('hex') : method(message1);
                    };
                    return nodeMethod;
                }, createHmacOutputMethod = function(outputType1, is2241) {
                    return function(key1, message1) {
                        return new HmacSha256(key1, is2241, !0).update(message1)[outputType1]();
                    };
                }, createHmacMethod = function(is2241) {
                    var method1 = createHmacOutputMethod('hex', is2241);
                    method1.create = function(key1) {
                        return new HmacSha256(key1, is2241);
                    }, method1.update = function(key1, message1) {
                        return method1.create(key1).update(message1);
                    };
                    for(var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2){
                        var type1 = OUTPUT_TYPES[i2];
                        method1[type1] = createHmacOutputMethod(type1, is2241);
                    }
                    return method1;
                };
                function Sha256(is2241, sharedMemory1) {
                    sharedMemory1 ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], is2241 ? (this.h0 = 0xc1059ed8, this.h1 = 0x367cd507, this.h2 = 0x3070dd17, this.h3 = 0xf70e5939, this.h4 = 0xffc00b31, this.h5 = 0x68581511, this.h6 = 0x64f98fa7, this.h7 = 0xbefa4fa4) : (this.h0 = 0x6a09e667, this.h1 = 0xbb67ae85, this.h2 = 0x3c6ef372, this.h3 = 0xa54ff53a, this.h4 = 0x510e527f, this.h5 = 0x9b05688c, this.h6 = 0x1f83d9ab, this.h7 = 0x5be0cd19), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = is2241;
                }
                function HmacSha256(key1, is2241, sharedMemory1) {
                    var i2, type1 = typeof key1;
                    if ('string' === type1) {
                        var code1, bytes1 = [], length1 = key1.length, index1 = 0;
                        for(i2 = 0; i2 < length1; ++i2)(code1 = key1.charCodeAt(i2)) < 0x80 ? bytes1[index1++] = code1 : code1 < 0x800 ? (bytes1[index1++] = 0xc0 | code1 >> 6, bytes1[index1++] = 0x80 | 0x3f & code1) : code1 < 0xd800 || code1 >= 0xe000 ? (bytes1[index1++] = 0xe0 | code1 >> 12, bytes1[index1++] = 0x80 | code1 >> 6 & 0x3f, bytes1[index1++] = 0x80 | 0x3f & code1) : (code1 = 0x10000 + ((0x3ff & code1) << 10 | 0x3ff & key1.charCodeAt(++i2)), bytes1[index1++] = 0xf0 | code1 >> 18, bytes1[index1++] = 0x80 | code1 >> 12 & 0x3f, bytes1[index1++] = 0x80 | code1 >> 6 & 0x3f, bytes1[index1++] = 0x80 | 0x3f & code1);
                        key1 = bytes1;
                    } else if ('object' === type1) {
                        if (null === key1) throw Error(ERROR);
                        if (ARRAY_BUFFER && key1.constructor === ArrayBuffer) key1 = new Uint8Array(key1);
                        else if (!Array.isArray(key1) && (!ARRAY_BUFFER || !ArrayBuffer.isView(key1))) throw Error(ERROR);
                    } else throw Error(ERROR);
                    key1.length > 64 && (key1 = new Sha256(is2241, !0).update(key1).array());
                    var oKeyPad1 = [], iKeyPad1 = [];
                    for(i2 = 0; i2 < 64; ++i2){
                        var b10 = key1[i2] || 0;
                        oKeyPad1[i2] = 0x5c ^ b10, iKeyPad1[i2] = 0x36 ^ b10;
                    }
                    Sha256.call(this, is2241, sharedMemory1), this.update(iKeyPad1), this.oKeyPad = oKeyPad1, this.inner = !0, this.sharedMemory = sharedMemory1;
                }
                Sha256.prototype.update = function(message1) {
                    if (!this.finalized) {
                        var notString1, type1 = typeof message1;
                        if ('string' !== type1) {
                            if ('object' === type1) {
                                if (null === message1) throw Error(ERROR);
                                if (ARRAY_BUFFER && message1.constructor === ArrayBuffer) message1 = new Uint8Array(message1);
                                else if (!Array.isArray(message1) && (!ARRAY_BUFFER || !ArrayBuffer.isView(message1))) throw Error(ERROR);
                            } else throw Error(ERROR);
                            notString1 = !0;
                        }
                        for(var code1, i2, index1 = 0, length1 = message1.length, blocks1 = this.blocks; index1 < length1;){
                            if (this.hashed && (this.hashed = !1, blocks1[0] = this.block, blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0), notString1) for(i2 = this.start; index1 < length1 && i2 < 64; ++index1)blocks1[i2 >> 2] |= message1[index1] << SHIFT[3 & i2++];
                            else for(i2 = this.start; index1 < length1 && i2 < 64; ++index1)(code1 = message1.charCodeAt(index1)) < 0x80 ? blocks1[i2 >> 2] |= code1 << SHIFT[3 & i2++] : code1 < 0x800 ? (blocks1[i2 >> 2] |= (0xc0 | code1 >> 6) << SHIFT[3 & i2++], blocks1[i2 >> 2] |= (0x80 | 0x3f & code1) << SHIFT[3 & i2++]) : code1 < 0xd800 || code1 >= 0xe000 ? (blocks1[i2 >> 2] |= (0xe0 | code1 >> 12) << SHIFT[3 & i2++], blocks1[i2 >> 2] |= (0x80 | code1 >> 6 & 0x3f) << SHIFT[3 & i2++], blocks1[i2 >> 2] |= (0x80 | 0x3f & code1) << SHIFT[3 & i2++]) : (code1 = 0x10000 + ((0x3ff & code1) << 10 | 0x3ff & message1.charCodeAt(++index1)), blocks1[i2 >> 2] |= (0xf0 | code1 >> 18) << SHIFT[3 & i2++], blocks1[i2 >> 2] |= (0x80 | code1 >> 12 & 0x3f) << SHIFT[3 & i2++], blocks1[i2 >> 2] |= (0x80 | code1 >> 6 & 0x3f) << SHIFT[3 & i2++], blocks1[i2 >> 2] |= (0x80 | 0x3f & code1) << SHIFT[3 & i2++]);
                            this.lastByteIndex = i2, this.bytes += i2 - this.start, i2 >= 64 ? (this.block = blocks1[16], this.start = i2 - 64, this.hash(), this.hashed = !0) : this.start = i2;
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
                    }
                }, Sha256.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var blocks1 = this.blocks, i2 = this.lastByteIndex;
                        blocks1[16] = this.block, blocks1[i2 >> 2] |= EXTRA[3 & i2], this.block = blocks1[16], i2 >= 56 && (this.hashed || this.hash(), blocks1[0] = this.block, blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0), blocks1[14] = this.hBytes << 3 | this.bytes >>> 29, blocks1[15] = this.bytes << 3, this.hash();
                    }
                }, Sha256.prototype.hash = function() {
                    var j1, s01, s11, maj1, t11, t21, ch1, ab1, da1, cd1, bc1, a10 = this.h0, b10 = this.h1, c5 = this.h2, d3 = this.h3, e1 = this.h4, f1 = this.h5, g3 = this.h6, h8 = this.h7, blocks1 = this.blocks;
                    for(j1 = 16; j1 < 64; ++j1)s01 = ((t11 = blocks1[j1 - 15]) >>> 7 | t11 << 25) ^ (t11 >>> 18 | t11 << 14) ^ t11 >>> 3, s11 = ((t11 = blocks1[j1 - 2]) >>> 17 | t11 << 15) ^ (t11 >>> 19 | t11 << 13) ^ t11 >>> 10, blocks1[j1] = blocks1[j1 - 16] + s01 + blocks1[j1 - 7] + s11 << 0;
                    for(j1 = 0, bc1 = b10 & c5; j1 < 64; j1 += 4)this.first ? (this.is224 ? (ab1 = 300032, h8 = (t11 = blocks1[0] - 1413257819) - 150054599 << 0, d3 = t11 + 24177077 << 0) : (ab1 = 704751109, h8 = (t11 = blocks1[0] - 210244248) - 1521486534 << 0, d3 = t11 + 143694565 << 0), this.first = !1) : (s01 = (a10 >>> 2 | a10 << 30) ^ (a10 >>> 13 | a10 << 19) ^ (a10 >>> 22 | a10 << 10), s11 = (e1 >>> 6 | e1 << 26) ^ (e1 >>> 11 | e1 << 21) ^ (e1 >>> 25 | e1 << 7), maj1 = (ab1 = a10 & b10) ^ a10 & c5 ^ bc1, t11 = h8 + s11 + (ch1 = e1 & f1 ^ ~e1 & g3) + K[j1] + blocks1[j1], t21 = s01 + maj1, h8 = d3 + t11 << 0, d3 = t11 + t21 << 0), s01 = (d3 >>> 2 | d3 << 30) ^ (d3 >>> 13 | d3 << 19) ^ (d3 >>> 22 | d3 << 10), s11 = (h8 >>> 6 | h8 << 26) ^ (h8 >>> 11 | h8 << 21) ^ (h8 >>> 25 | h8 << 7), maj1 = (da1 = d3 & a10) ^ d3 & b10 ^ ab1, t11 = g3 + s11 + (ch1 = h8 & e1 ^ ~h8 & f1) + K[j1 + 1] + blocks1[j1 + 1], t21 = s01 + maj1, g3 = c5 + t11 << 0, s01 = ((c5 = t11 + t21 << 0) >>> 2 | c5 << 30) ^ (c5 >>> 13 | c5 << 19) ^ (c5 >>> 22 | c5 << 10), s11 = (g3 >>> 6 | g3 << 26) ^ (g3 >>> 11 | g3 << 21) ^ (g3 >>> 25 | g3 << 7), maj1 = (cd1 = c5 & d3) ^ c5 & a10 ^ da1, t11 = f1 + s11 + (ch1 = g3 & h8 ^ ~g3 & e1) + K[j1 + 2] + blocks1[j1 + 2], t21 = s01 + maj1, f1 = b10 + t11 << 0, s01 = ((b10 = t11 + t21 << 0) >>> 2 | b10 << 30) ^ (b10 >>> 13 | b10 << 19) ^ (b10 >>> 22 | b10 << 10), s11 = (f1 >>> 6 | f1 << 26) ^ (f1 >>> 11 | f1 << 21) ^ (f1 >>> 25 | f1 << 7), maj1 = (bc1 = b10 & c5) ^ b10 & d3 ^ cd1, t11 = e1 + s11 + (ch1 = f1 & g3 ^ ~f1 & h8) + K[j1 + 3] + blocks1[j1 + 3], t21 = s01 + maj1, e1 = a10 + t11 << 0, a10 = t11 + t21 << 0;
                    this.h0 = this.h0 + a10 << 0, this.h1 = this.h1 + b10 << 0, this.h2 = this.h2 + c5 << 0, this.h3 = this.h3 + d3 << 0, this.h4 = this.h4 + e1 << 0, this.h5 = this.h5 + f1 << 0, this.h6 = this.h6 + g3 << 0, this.h7 = this.h7 + h8 << 0;
                }, Sha256.prototype.hex = function() {
                    this.finalize();
                    var h01 = this.h0, h11 = this.h1, h21 = this.h2, h31 = this.h3, h41 = this.h4, h51 = this.h5, h61 = this.h6, h71 = this.h7, hex1 = HEX_CHARS[h01 >> 28 & 0x0F] + HEX_CHARS[h01 >> 24 & 0x0F] + HEX_CHARS[h01 >> 20 & 0x0F] + HEX_CHARS[h01 >> 16 & 0x0F] + HEX_CHARS[h01 >> 12 & 0x0F] + HEX_CHARS[h01 >> 8 & 0x0F] + HEX_CHARS[h01 >> 4 & 0x0F] + HEX_CHARS[0x0F & h01] + HEX_CHARS[h11 >> 28 & 0x0F] + HEX_CHARS[h11 >> 24 & 0x0F] + HEX_CHARS[h11 >> 20 & 0x0F] + HEX_CHARS[h11 >> 16 & 0x0F] + HEX_CHARS[h11 >> 12 & 0x0F] + HEX_CHARS[h11 >> 8 & 0x0F] + HEX_CHARS[h11 >> 4 & 0x0F] + HEX_CHARS[0x0F & h11] + HEX_CHARS[h21 >> 28 & 0x0F] + HEX_CHARS[h21 >> 24 & 0x0F] + HEX_CHARS[h21 >> 20 & 0x0F] + HEX_CHARS[h21 >> 16 & 0x0F] + HEX_CHARS[h21 >> 12 & 0x0F] + HEX_CHARS[h21 >> 8 & 0x0F] + HEX_CHARS[h21 >> 4 & 0x0F] + HEX_CHARS[0x0F & h21] + HEX_CHARS[h31 >> 28 & 0x0F] + HEX_CHARS[h31 >> 24 & 0x0F] + HEX_CHARS[h31 >> 20 & 0x0F] + HEX_CHARS[h31 >> 16 & 0x0F] + HEX_CHARS[h31 >> 12 & 0x0F] + HEX_CHARS[h31 >> 8 & 0x0F] + HEX_CHARS[h31 >> 4 & 0x0F] + HEX_CHARS[0x0F & h31] + HEX_CHARS[h41 >> 28 & 0x0F] + HEX_CHARS[h41 >> 24 & 0x0F] + HEX_CHARS[h41 >> 20 & 0x0F] + HEX_CHARS[h41 >> 16 & 0x0F] + HEX_CHARS[h41 >> 12 & 0x0F] + HEX_CHARS[h41 >> 8 & 0x0F] + HEX_CHARS[h41 >> 4 & 0x0F] + HEX_CHARS[0x0F & h41] + HEX_CHARS[h51 >> 28 & 0x0F] + HEX_CHARS[h51 >> 24 & 0x0F] + HEX_CHARS[h51 >> 20 & 0x0F] + HEX_CHARS[h51 >> 16 & 0x0F] + HEX_CHARS[h51 >> 12 & 0x0F] + HEX_CHARS[h51 >> 8 & 0x0F] + HEX_CHARS[h51 >> 4 & 0x0F] + HEX_CHARS[0x0F & h51] + HEX_CHARS[h61 >> 28 & 0x0F] + HEX_CHARS[h61 >> 24 & 0x0F] + HEX_CHARS[h61 >> 20 & 0x0F] + HEX_CHARS[h61 >> 16 & 0x0F] + HEX_CHARS[h61 >> 12 & 0x0F] + HEX_CHARS[h61 >> 8 & 0x0F] + HEX_CHARS[h61 >> 4 & 0x0F] + HEX_CHARS[0x0F & h61];
                    return this.is224 || (hex1 += HEX_CHARS[h71 >> 28 & 0x0F] + HEX_CHARS[h71 >> 24 & 0x0F] + HEX_CHARS[h71 >> 20 & 0x0F] + HEX_CHARS[h71 >> 16 & 0x0F] + HEX_CHARS[h71 >> 12 & 0x0F] + HEX_CHARS[h71 >> 8 & 0x0F] + HEX_CHARS[h71 >> 4 & 0x0F] + HEX_CHARS[0x0F & h71]), hex1;
                }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
                    this.finalize();
                    var h01 = this.h0, h11 = this.h1, h21 = this.h2, h31 = this.h3, h41 = this.h4, h51 = this.h5, h61 = this.h6, h71 = this.h7, arr1 = [
                        h01 >> 24 & 0xFF,
                        h01 >> 16 & 0xFF,
                        h01 >> 8 & 0xFF,
                        0xFF & h01,
                        h11 >> 24 & 0xFF,
                        h11 >> 16 & 0xFF,
                        h11 >> 8 & 0xFF,
                        0xFF & h11,
                        h21 >> 24 & 0xFF,
                        h21 >> 16 & 0xFF,
                        h21 >> 8 & 0xFF,
                        0xFF & h21,
                        h31 >> 24 & 0xFF,
                        h31 >> 16 & 0xFF,
                        h31 >> 8 & 0xFF,
                        0xFF & h31,
                        h41 >> 24 & 0xFF,
                        h41 >> 16 & 0xFF,
                        h41 >> 8 & 0xFF,
                        0xFF & h41,
                        h51 >> 24 & 0xFF,
                        h51 >> 16 & 0xFF,
                        h51 >> 8 & 0xFF,
                        0xFF & h51,
                        h61 >> 24 & 0xFF,
                        h61 >> 16 & 0xFF,
                        h61 >> 8 & 0xFF,
                        0xFF & h61
                    ];
                    return this.is224 || arr1.push(h71 >> 24 & 0xFF, h71 >> 16 & 0xFF, h71 >> 8 & 0xFF, 0xFF & h71), arr1;
                }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
                    this.finalize();
                    var buffer1 = new ArrayBuffer(this.is224 ? 28 : 32), dataView1 = new DataView(buffer1);
                    return dataView1.setUint32(0, this.h0), dataView1.setUint32(4, this.h1), dataView1.setUint32(8, this.h2), dataView1.setUint32(12, this.h3), dataView1.setUint32(16, this.h4), dataView1.setUint32(20, this.h5), dataView1.setUint32(24, this.h6), this.is224 || dataView1.setUint32(28, this.h7), buffer1;
                }, HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
                    if (Sha256.prototype.finalize.call(this), this.inner) {
                        this.inner = !1;
                        var innerHash1 = this.array();
                        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(innerHash1), Sha256.prototype.finalize.call(this);
                    }
                };
                var exports = createMethod();
                exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224, AMD && void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return exports;
                }).call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }();
        },
        3434: function(module1, exports1, __webpack_require__1) {
            var __WEBPACK_AMD_DEFINE_RESULT__1, process1 = __webpack_require__1(3454);
            !function() {
                'use strict';
                var INPUT_ERROR1 = 'input is invalid type', FINALIZE_ERROR1 = 'finalize already called', WINDOW1 = 'object' == typeof window, root1 = WINDOW1 ? window : {};
                root1.JS_SHA512_NO_WINDOW && (WINDOW1 = !1);
                var WEB_WORKER1 = !WINDOW1 && 'object' == typeof self;
                !root1.JS_SHA512_NO_NODE_JS && 'object' == typeof process1 && process1.versions && process1.versions.node ? root1 = __webpack_require__1.g : WEB_WORKER1 && (root1 = self);
                var COMMON_JS1 = !root1.JS_SHA512_NO_COMMON_JS && module1.exports, AMD1 = __webpack_require__1.amdO, ARRAY_BUFFER1 = !root1.JS_SHA512_NO_ARRAY_BUFFER && 'undefined' != typeof ArrayBuffer, HEX_CHARS1 = '0123456789abcdef'.split(''), EXTRA1 = [
                    -2147483648,
                    8388608,
                    32768,
                    128
                ], SHIFT1 = [
                    24,
                    16,
                    8,
                    0
                ], K1 = [
                    0x428A2F98,
                    0xD728AE22,
                    0x71374491,
                    0x23EF65CD,
                    0xB5C0FBCF,
                    0xEC4D3B2F,
                    0xE9B5DBA5,
                    0x8189DBBC,
                    0x3956C25B,
                    0xF348B538,
                    0x59F111F1,
                    0xB605D019,
                    0x923F82A4,
                    0xAF194F9B,
                    0xAB1C5ED5,
                    0xDA6D8118,
                    0xD807AA98,
                    0xA3030242,
                    0x12835B01,
                    0x45706FBE,
                    0x243185BE,
                    0x4EE4B28C,
                    0x550C7DC3,
                    0xD5FFB4E2,
                    0x72BE5D74,
                    0xF27B896F,
                    0x80DEB1FE,
                    0x3B1696B1,
                    0x9BDC06A7,
                    0x25C71235,
                    0xC19BF174,
                    0xCF692694,
                    0xE49B69C1,
                    0x9EF14AD2,
                    0xEFBE4786,
                    0x384F25E3,
                    0x0FC19DC6,
                    0x8B8CD5B5,
                    0x240CA1CC,
                    0x77AC9C65,
                    0x2DE92C6F,
                    0x592B0275,
                    0x4A7484AA,
                    0x6EA6E483,
                    0x5CB0A9DC,
                    0xBD41FBD4,
                    0x76F988DA,
                    0x831153B5,
                    0x983E5152,
                    0xEE66DFAB,
                    0xA831C66D,
                    0x2DB43210,
                    0xB00327C8,
                    0x98FB213F,
                    0xBF597FC7,
                    0xBEEF0EE4,
                    0xC6E00BF3,
                    0x3DA88FC2,
                    0xD5A79147,
                    0x930AA725,
                    0x06CA6351,
                    0xE003826F,
                    0x14292967,
                    0x0A0E6E70,
                    0x27B70A85,
                    0x46D22FFC,
                    0x2E1B2138,
                    0x5C26C926,
                    0x4D2C6DFC,
                    0x5AC42AED,
                    0x53380D13,
                    0x9D95B3DF,
                    0x650A7354,
                    0x8BAF63DE,
                    0x766A0ABB,
                    0x3C77B2A8,
                    0x81C2C92E,
                    0x47EDAEE6,
                    0x92722C85,
                    0x1482353B,
                    0xA2BFE8A1,
                    0x4CF10364,
                    0xA81A664B,
                    0xBC423001,
                    0xC24B8B70,
                    0xD0F89791,
                    0xC76C51A3,
                    0x0654BE30,
                    0xD192E819,
                    0xD6EF5218,
                    0xD6990624,
                    0x5565A910,
                    0xF40E3585,
                    0x5771202A,
                    0x106AA070,
                    0x32BBD1B8,
                    0x19A4C116,
                    0xB8D2D0C8,
                    0x1E376C08,
                    0x5141AB53,
                    0x2748774C,
                    0xDF8EEB99,
                    0x34B0BCB5,
                    0xE19B48A8,
                    0x391C0CB3,
                    0xC5C95A63,
                    0x4ED8AA4A,
                    0xE3418ACB,
                    0x5B9CCA4F,
                    0x7763E373,
                    0x682E6FF3,
                    0xD6B2B8A3,
                    0x748F82EE,
                    0x5DEFB2FC,
                    0x78A5636F,
                    0x43172F60,
                    0x84C87814,
                    0xA1F0AB72,
                    0x8CC70208,
                    0x1A6439EC,
                    0x90BEFFFA,
                    0x23631E28,
                    0xA4506CEB,
                    0xDE82BDE9,
                    0xBEF9A3F7,
                    0xB2C67915,
                    0xC67178F2,
                    0xE372532B,
                    0xCA273ECE,
                    0xEA26619C,
                    0xD186B8C7,
                    0x21C0C207,
                    0xEADA7DD6,
                    0xCDE0EB1E,
                    0xF57D4F7F,
                    0xEE6ED178,
                    0x06F067AA,
                    0x72176FBA,
                    0x0A637DC5,
                    0xA2C898A6,
                    0x113F9804,
                    0xBEF90DAE,
                    0x1B710B35,
                    0x131C471B,
                    0x28DB77F5,
                    0x23047D84,
                    0x32CAAB7B,
                    0x40C72493,
                    0x3C9EBE0A,
                    0x15C9BEBC,
                    0x431D67C4,
                    0x9C100D4C,
                    0x4CC5D4BE,
                    0xCB3E42B6,
                    0x597F299C,
                    0xFC657E2A,
                    0x5FCB6FAB,
                    0x3AD6FAEC,
                    0x6C44198C,
                    0x4A475817
                ], OUTPUT_TYPES1 = [
                    'hex',
                    'array',
                    'digest',
                    'arrayBuffer'
                ], blocks1 = [];
                (root1.JS_SHA512_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(obj1) {
                    return '[object Array]' === Object.prototype.toString.call(obj1);
                }), ARRAY_BUFFER1 && (root1.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(obj1) {
                    return 'object' == typeof obj1 && obj1.buffer && obj1.buffer.constructor === ArrayBuffer;
                });
                var createOutputMethod1 = function(outputType1, bits1) {
                    return function(message1) {
                        return new Sha5121(bits1, !0).update(message1)[outputType1]();
                    };
                }, createMethod1 = function(bits1) {
                    var method1 = createOutputMethod1('hex', bits1);
                    method1.create = function() {
                        return new Sha5121(bits1);
                    }, method1.update = function(message1) {
                        return method1.create().update(message1);
                    };
                    for(var i2 = 0; i2 < OUTPUT_TYPES1.length; ++i2){
                        var type1 = OUTPUT_TYPES1[i2];
                        method1[type1] = createOutputMethod1(type1, bits1);
                    }
                    return method1;
                }, createHmacOutputMethod1 = function(outputType1, bits1) {
                    return function(key1, message1) {
                        return new HmacSha5121(key1, bits1, !0).update(message1)[outputType1]();
                    };
                }, createHmacMethod1 = function(bits1) {
                    var method1 = createHmacOutputMethod1('hex', bits1);
                    method1.create = function(key1) {
                        return new HmacSha5121(key1, bits1);
                    }, method1.update = function(key1, message1) {
                        return method1.create(key1).update(message1);
                    };
                    for(var i2 = 0; i2 < OUTPUT_TYPES1.length; ++i2){
                        var type1 = OUTPUT_TYPES1[i2];
                        method1[type1] = createHmacOutputMethod1(type1, bits1);
                    }
                    return method1;
                };
                function Sha5121(bits1, sharedMemory1) {
                    sharedMemory1 ? (blocks1[0] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = blocks1[16] = blocks1[17] = blocks1[18] = blocks1[19] = blocks1[20] = blocks1[21] = blocks1[22] = blocks1[23] = blocks1[24] = blocks1[25] = blocks1[26] = blocks1[27] = blocks1[28] = blocks1[29] = blocks1[30] = blocks1[31] = blocks1[32] = 0, this.blocks = blocks1) : this.blocks = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], 384 == bits1 ? (this.h0h = 0xCBBB9D5D, this.h0l = 0xC1059ED8, this.h1h = 0x629A292A, this.h1l = 0x367CD507, this.h2h = 0x9159015A, this.h2l = 0x3070DD17, this.h3h = 0x152FECD8, this.h3l = 0xF70E5939, this.h4h = 0x67332667, this.h4l = 0xFFC00B31, this.h5h = 0x8EB44A87, this.h5l = 0x68581511, this.h6h = 0xDB0C2E0D, this.h6l = 0x64F98FA7, this.h7h = 0x47B5481D, this.h7l = 0xBEFA4FA4) : 256 == bits1 ? (this.h0h = 0x22312194, this.h0l = 0xFC2BF72C, this.h1h = 0x9F555FA3, this.h1l = 0xC84C64C2, this.h2h = 0x2393B86B, this.h2l = 0x6F53B151, this.h3h = 0x96387719, this.h3l = 0x5940EABD, this.h4h = 0x96283EE2, this.h4l = 0xA88EFFE3, this.h5h = 0xBE5E1E25, this.h5l = 0x53863992, this.h6h = 0x2B0199FC, this.h6l = 0x2C85B8AA, this.h7h = 0x0EB72DDC, this.h7l = 0x81C52CA2) : 224 == bits1 ? (this.h0h = 0x8C3D37C8, this.h0l = 0x19544DA2, this.h1h = 0x73E19966, this.h1l = 0x89DCD4D6, this.h2h = 0x1DFAB7AE, this.h2l = 0x32FF9C82, this.h3h = 0x679DD514, this.h3l = 0x582F9FCF, this.h4h = 0x0F6D2B69, this.h4l = 0x7BD44DA8, this.h5h = 0x77E36F73, this.h5l = 0x04C48942, this.h6h = 0x3F9D85A8, this.h6l = 0x6A1D36C8, this.h7h = 0x1112E6AD, this.h7l = 0x91D692A1) : (this.h0h = 0x6A09E667, this.h0l = 0xF3BCC908, this.h1h = 0xBB67AE85, this.h1l = 0x84CAA73B, this.h2h = 0x3C6EF372, this.h2l = 0xFE94F82B, this.h3h = 0xA54FF53A, this.h3l = 0x5F1D36F1, this.h4h = 0x510E527F, this.h4l = 0xADE682D1, this.h5h = 0x9B05688C, this.h5l = 0x2B3E6C1F, this.h6h = 0x1F83D9AB, this.h6l = 0xFB41BD6B, this.h7h = 0x5BE0CD19, this.h7l = 0x137E2179), this.bits = bits1, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1;
                }
                function HmacSha5121(key1, bits1, sharedMemory1) {
                    var notString1, type1 = typeof key1;
                    if ('string' !== type1) {
                        if ('object' === type1) {
                            if (null === key1) throw Error(INPUT_ERROR1);
                            if (ARRAY_BUFFER1 && key1.constructor === ArrayBuffer) key1 = new Uint8Array(key1);
                            else if (!Array.isArray(key1) && (!ARRAY_BUFFER1 || !ArrayBuffer.isView(key1))) throw Error(INPUT_ERROR1);
                        } else throw Error(INPUT_ERROR1);
                        notString1 = !0;
                    }
                    var length1 = key1.length;
                    if (!notString1) {
                        for(var code1, bytes1 = [], length1 = key1.length, index1 = 0, i2 = 0; i2 < length1; ++i2)(code1 = key1.charCodeAt(i2)) < 0x80 ? bytes1[index1++] = code1 : code1 < 0x800 ? (bytes1[index1++] = 0xc0 | code1 >> 6, bytes1[index1++] = 0x80 | 0x3f & code1) : code1 < 0xd800 || code1 >= 0xe000 ? (bytes1[index1++] = 0xe0 | code1 >> 12, bytes1[index1++] = 0x80 | code1 >> 6 & 0x3f, bytes1[index1++] = 0x80 | 0x3f & code1) : (code1 = 0x10000 + ((0x3ff & code1) << 10 | 0x3ff & key1.charCodeAt(++i2)), bytes1[index1++] = 0xf0 | code1 >> 18, bytes1[index1++] = 0x80 | code1 >> 12 & 0x3f, bytes1[index1++] = 0x80 | code1 >> 6 & 0x3f, bytes1[index1++] = 0x80 | 0x3f & code1);
                        key1 = bytes1;
                    }
                    key1.length > 128 && (key1 = new Sha5121(bits1, !0).update(key1).array());
                    for(var oKeyPad1 = [], iKeyPad1 = [], i2 = 0; i2 < 128; ++i2){
                        var b10 = key1[i2] || 0;
                        oKeyPad1[i2] = 0x5c ^ b10, iKeyPad1[i2] = 0x36 ^ b10;
                    }
                    Sha5121.call(this, bits1, sharedMemory1), this.update(iKeyPad1), this.oKeyPad = oKeyPad1, this.inner = !0, this.sharedMemory = sharedMemory1;
                }
                Sha5121.prototype.update = function(message1) {
                    if (this.finalized) throw Error(FINALIZE_ERROR1);
                    var notString1, type1 = typeof message1;
                    if ('string' !== type1) {
                        if ('object' === type1) {
                            if (null === message1) throw Error(INPUT_ERROR1);
                            if (ARRAY_BUFFER1 && message1.constructor === ArrayBuffer) message1 = new Uint8Array(message1);
                            else if (!Array.isArray(message1) && (!ARRAY_BUFFER1 || !ArrayBuffer.isView(message1))) throw Error(INPUT_ERROR1);
                        } else throw Error(INPUT_ERROR1);
                        notString1 = !0;
                    }
                    for(var code1, i2, index1 = 0, length1 = message1.length, blocks1 = this.blocks; index1 < length1;){
                        if (this.hashed && (this.hashed = !1, blocks1[0] = this.block, blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = blocks1[16] = blocks1[17] = blocks1[18] = blocks1[19] = blocks1[20] = blocks1[21] = blocks1[22] = blocks1[23] = blocks1[24] = blocks1[25] = blocks1[26] = blocks1[27] = blocks1[28] = blocks1[29] = blocks1[30] = blocks1[31] = blocks1[32] = 0), notString1) for(i2 = this.start; index1 < length1 && i2 < 128; ++index1)blocks1[i2 >> 2] |= message1[index1] << SHIFT1[3 & i2++];
                        else for(i2 = this.start; index1 < length1 && i2 < 128; ++index1)(code1 = message1.charCodeAt(index1)) < 0x80 ? blocks1[i2 >> 2] |= code1 << SHIFT1[3 & i2++] : code1 < 0x800 ? (blocks1[i2 >> 2] |= (0xc0 | code1 >> 6) << SHIFT1[3 & i2++], blocks1[i2 >> 2] |= (0x80 | 0x3f & code1) << SHIFT1[3 & i2++]) : code1 < 0xd800 || code1 >= 0xe000 ? (blocks1[i2 >> 2] |= (0xe0 | code1 >> 12) << SHIFT1[3 & i2++], blocks1[i2 >> 2] |= (0x80 | code1 >> 6 & 0x3f) << SHIFT1[3 & i2++], blocks1[i2 >> 2] |= (0x80 | 0x3f & code1) << SHIFT1[3 & i2++]) : (code1 = 0x10000 + ((0x3ff & code1) << 10 | 0x3ff & message1.charCodeAt(++index1)), blocks1[i2 >> 2] |= (0xf0 | code1 >> 18) << SHIFT1[3 & i2++], blocks1[i2 >> 2] |= (0x80 | code1 >> 12 & 0x3f) << SHIFT1[3 & i2++], blocks1[i2 >> 2] |= (0x80 | code1 >> 6 & 0x3f) << SHIFT1[3 & i2++], blocks1[i2 >> 2] |= (0x80 | 0x3f & code1) << SHIFT1[3 & i2++]);
                        this.lastByteIndex = i2, this.bytes += i2 - this.start, i2 >= 128 ? (this.block = blocks1[32], this.start = i2 - 128, this.hash(), this.hashed = !0) : this.start = i2;
                    }
                    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
                }, Sha5121.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var blocks1 = this.blocks, i2 = this.lastByteIndex;
                        blocks1[32] = this.block, blocks1[i2 >> 2] |= EXTRA1[3 & i2], this.block = blocks1[32], i2 >= 112 && (this.hashed || this.hash(), blocks1[0] = this.block, blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = blocks1[16] = blocks1[17] = blocks1[18] = blocks1[19] = blocks1[20] = blocks1[21] = blocks1[22] = blocks1[23] = blocks1[24] = blocks1[25] = blocks1[26] = blocks1[27] = blocks1[28] = blocks1[29] = blocks1[30] = blocks1[31] = blocks1[32] = 0), blocks1[30] = this.hBytes << 3 | this.bytes >>> 29, blocks1[31] = this.bytes << 3, this.hash();
                    }
                }, Sha5121.prototype.hash = function() {
                    var j1, s0h1, s0l1, s1h1, s1l1, c11, c21, c31, c41, abh1, abl1, dah1, dal1, cdh1, cdl1, bch1, bcl1, majh1, majl1, t1h1, t1l1, t2h1, t2l1, chh1, chl1, h0h1 = this.h0h, h0l1 = this.h0l, h1h1 = this.h1h, h1l1 = this.h1l, h2h1 = this.h2h, h2l1 = this.h2l, h3h1 = this.h3h, h3l1 = this.h3l, h4h1 = this.h4h, h4l1 = this.h4l, h5h1 = this.h5h, h5l1 = this.h5l, h6h1 = this.h6h, h6l1 = this.h6l, h7h1 = this.h7h, h7l1 = this.h7l, blocks1 = this.blocks;
                    for(j1 = 32; j1 < 160; j1 += 2)s0h1 = ((t1h1 = blocks1[j1 - 30]) >>> 1 | (t1l1 = blocks1[j1 - 29]) << 31) ^ (t1h1 >>> 8 | t1l1 << 24) ^ t1h1 >>> 7, s0l1 = (t1l1 >>> 1 | t1h1 << 31) ^ (t1l1 >>> 8 | t1h1 << 24) ^ (t1l1 >>> 7 | t1h1 << 25), s1h1 = ((t1h1 = blocks1[j1 - 4]) >>> 19 | (t1l1 = blocks1[j1 - 3]) << 13) ^ (t1l1 >>> 29 | t1h1 << 3) ^ t1h1 >>> 6, s1l1 = (t1l1 >>> 19 | t1h1 << 13) ^ (t1h1 >>> 29 | t1l1 << 3) ^ (t1l1 >>> 6 | t1h1 << 26), t1h1 = blocks1[j1 - 32], t1l1 = blocks1[j1 - 31], t2h1 = blocks1[j1 - 14], c11 = (0xFFFF & (t2l1 = blocks1[j1 - 13])) + (0xFFFF & t1l1) + (0xFFFF & s0l1) + (0xFFFF & s1l1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + (0xFFFF & s0h1) + (0xFFFF & s1h1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (s0l1 >>> 16) + (s1l1 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (s0h1 >>> 16) + (s1h1 >>> 16) + (c31 >>> 16), blocks1[j1] = c41 << 16 | 0xFFFF & c31, blocks1[j1 + 1] = c21 << 16 | 0xFFFF & c11;
                    var ah10 = h0h1, al10 = h0l1, bh10 = h1h1, bl10 = h1l1, ch1 = h2h1, cl1 = h2l1, dh1 = h3h1, dl1 = h3l1, eh1 = h4h1, el1 = h4l1, fh1 = h5h1, fl1 = h5l1, gh1 = h6h1, gl1 = h6l1, hh1 = h7h1, hl1 = h7l1;
                    for(j1 = 0, bch1 = bh10 & ch1, bcl1 = bl10 & cl1; j1 < 160; j1 += 8)s0h1 = (ah10 >>> 28 | al10 << 4) ^ (al10 >>> 2 | ah10 << 30) ^ (al10 >>> 7 | ah10 << 25), s0l1 = (al10 >>> 28 | ah10 << 4) ^ (ah10 >>> 2 | al10 << 30) ^ (ah10 >>> 7 | al10 << 25), s1h1 = (eh1 >>> 14 | el1 << 18) ^ (eh1 >>> 18 | el1 << 14) ^ (el1 >>> 9 | eh1 << 23), s1l1 = (el1 >>> 14 | eh1 << 18) ^ (el1 >>> 18 | eh1 << 14) ^ (eh1 >>> 9 | el1 << 23), abh1 = ah10 & bh10, abl1 = al10 & bl10, majh1 = abh1 ^ ah10 & ch1 ^ bch1, majl1 = abl1 ^ al10 & cl1 ^ bcl1, chh1 = eh1 & fh1 ^ ~eh1 & gh1, chl1 = el1 & fl1 ^ ~el1 & gl1, t1h1 = blocks1[j1], t1l1 = blocks1[j1 + 1], t2h1 = K1[j1], c11 = (0xFFFF & (t2l1 = K1[j1 + 1])) + (0xFFFF & t1l1) + (0xFFFF & chl1) + (0xFFFF & s1l1) + (0xFFFF & hl1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + (0xFFFF & chh1) + (0xFFFF & s1h1) + (0xFFFF & hh1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (chl1 >>> 16) + (s1l1 >>> 16) + (hl1 >>> 16) + (c11 >>> 16)) >>> 16), t1h1 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (chh1 >>> 16) + (s1h1 >>> 16) + (hh1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t1l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & majl1) + (0xFFFF & s0l1), c31 = (0xFFFF & majh1) + (0xFFFF & s0h1) + ((c21 = (majl1 >>> 16) + (s0l1 >>> 16) + (c11 >>> 16)) >>> 16), t2h1 = (c41 = (majh1 >>> 16) + (s0h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t2l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & dl1) + (0xFFFF & t1l1), c31 = (0xFFFF & dh1) + (0xFFFF & t1h1) + ((c21 = (dl1 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), hh1 = (c41 = (dh1 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, hl1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & t2l1) + (0xFFFF & t1l1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), s0h1 = ((dh1 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31) >>> 28 | (dl1 = c21 << 16 | 0xFFFF & c11) << 4) ^ (dl1 >>> 2 | dh1 << 30) ^ (dl1 >>> 7 | dh1 << 25), s0l1 = (dl1 >>> 28 | dh1 << 4) ^ (dh1 >>> 2 | dl1 << 30) ^ (dh1 >>> 7 | dl1 << 25), s1h1 = (hh1 >>> 14 | hl1 << 18) ^ (hh1 >>> 18 | hl1 << 14) ^ (hl1 >>> 9 | hh1 << 23), s1l1 = (hl1 >>> 14 | hh1 << 18) ^ (hl1 >>> 18 | hh1 << 14) ^ (hh1 >>> 9 | hl1 << 23), dah1 = dh1 & ah10, dal1 = dl1 & al10, majh1 = dah1 ^ dh1 & bh10 ^ abh1, majl1 = dal1 ^ dl1 & bl10 ^ abl1, chh1 = hh1 & eh1 ^ ~hh1 & fh1, chl1 = hl1 & el1 ^ ~hl1 & fl1, t1h1 = blocks1[j1 + 2], t1l1 = blocks1[j1 + 3], t2h1 = K1[j1 + 2], c11 = (0xFFFF & (t2l1 = K1[j1 + 3])) + (0xFFFF & t1l1) + (0xFFFF & chl1) + (0xFFFF & s1l1) + (0xFFFF & gl1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + (0xFFFF & chh1) + (0xFFFF & s1h1) + (0xFFFF & gh1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (chl1 >>> 16) + (s1l1 >>> 16) + (gl1 >>> 16) + (c11 >>> 16)) >>> 16), t1h1 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (chh1 >>> 16) + (s1h1 >>> 16) + (gh1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t1l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & majl1) + (0xFFFF & s0l1), c31 = (0xFFFF & majh1) + (0xFFFF & s0h1) + ((c21 = (majl1 >>> 16) + (s0l1 >>> 16) + (c11 >>> 16)) >>> 16), t2h1 = (c41 = (majh1 >>> 16) + (s0h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t2l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & cl1) + (0xFFFF & t1l1), c31 = (0xFFFF & ch1) + (0xFFFF & t1h1) + ((c21 = (cl1 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), gh1 = (c41 = (ch1 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, gl1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & t2l1) + (0xFFFF & t1l1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), s0h1 = ((ch1 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31) >>> 28 | (cl1 = c21 << 16 | 0xFFFF & c11) << 4) ^ (cl1 >>> 2 | ch1 << 30) ^ (cl1 >>> 7 | ch1 << 25), s0l1 = (cl1 >>> 28 | ch1 << 4) ^ (ch1 >>> 2 | cl1 << 30) ^ (ch1 >>> 7 | cl1 << 25), s1h1 = (gh1 >>> 14 | gl1 << 18) ^ (gh1 >>> 18 | gl1 << 14) ^ (gl1 >>> 9 | gh1 << 23), s1l1 = (gl1 >>> 14 | gh1 << 18) ^ (gl1 >>> 18 | gh1 << 14) ^ (gh1 >>> 9 | gl1 << 23), cdh1 = ch1 & dh1, cdl1 = cl1 & dl1, majh1 = cdh1 ^ ch1 & ah10 ^ dah1, majl1 = cdl1 ^ cl1 & al10 ^ dal1, chh1 = gh1 & hh1 ^ ~gh1 & eh1, chl1 = gl1 & hl1 ^ ~gl1 & el1, t1h1 = blocks1[j1 + 4], t1l1 = blocks1[j1 + 5], t2h1 = K1[j1 + 4], c11 = (0xFFFF & (t2l1 = K1[j1 + 5])) + (0xFFFF & t1l1) + (0xFFFF & chl1) + (0xFFFF & s1l1) + (0xFFFF & fl1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + (0xFFFF & chh1) + (0xFFFF & s1h1) + (0xFFFF & fh1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (chl1 >>> 16) + (s1l1 >>> 16) + (fl1 >>> 16) + (c11 >>> 16)) >>> 16), t1h1 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (chh1 >>> 16) + (s1h1 >>> 16) + (fh1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t1l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & majl1) + (0xFFFF & s0l1), c31 = (0xFFFF & majh1) + (0xFFFF & s0h1) + ((c21 = (majl1 >>> 16) + (s0l1 >>> 16) + (c11 >>> 16)) >>> 16), t2h1 = (c41 = (majh1 >>> 16) + (s0h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t2l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & bl10) + (0xFFFF & t1l1), c31 = (0xFFFF & bh10) + (0xFFFF & t1h1) + ((c21 = (bl10 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), fh1 = (c41 = (bh10 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, fl1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & t2l1) + (0xFFFF & t1l1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), s0h1 = ((bh10 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31) >>> 28 | (bl10 = c21 << 16 | 0xFFFF & c11) << 4) ^ (bl10 >>> 2 | bh10 << 30) ^ (bl10 >>> 7 | bh10 << 25), s0l1 = (bl10 >>> 28 | bh10 << 4) ^ (bh10 >>> 2 | bl10 << 30) ^ (bh10 >>> 7 | bl10 << 25), s1h1 = (fh1 >>> 14 | fl1 << 18) ^ (fh1 >>> 18 | fl1 << 14) ^ (fl1 >>> 9 | fh1 << 23), s1l1 = (fl1 >>> 14 | fh1 << 18) ^ (fl1 >>> 18 | fh1 << 14) ^ (fh1 >>> 9 | fl1 << 23), bch1 = bh10 & ch1, bcl1 = bl10 & cl1, majh1 = bch1 ^ bh10 & dh1 ^ cdh1, majl1 = bcl1 ^ bl10 & dl1 ^ cdl1, chh1 = fh1 & gh1 ^ ~fh1 & hh1, chl1 = fl1 & gl1 ^ ~fl1 & hl1, t1h1 = blocks1[j1 + 6], t1l1 = blocks1[j1 + 7], t2h1 = K1[j1 + 6], c11 = (0xFFFF & (t2l1 = K1[j1 + 7])) + (0xFFFF & t1l1) + (0xFFFF & chl1) + (0xFFFF & s1l1) + (0xFFFF & el1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + (0xFFFF & chh1) + (0xFFFF & s1h1) + (0xFFFF & eh1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (chl1 >>> 16) + (s1l1 >>> 16) + (el1 >>> 16) + (c11 >>> 16)) >>> 16), t1h1 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (chh1 >>> 16) + (s1h1 >>> 16) + (eh1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t1l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & majl1) + (0xFFFF & s0l1), c31 = (0xFFFF & majh1) + (0xFFFF & s0h1) + ((c21 = (majl1 >>> 16) + (s0l1 >>> 16) + (c11 >>> 16)) >>> 16), t2h1 = (c41 = (majh1 >>> 16) + (s0h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, t2l1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & al10) + (0xFFFF & t1l1), c31 = (0xFFFF & ah10) + (0xFFFF & t1h1) + ((c21 = (al10 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), eh1 = (c41 = (ah10 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, el1 = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & t2l1) + (0xFFFF & t1l1), c31 = (0xFFFF & t2h1) + (0xFFFF & t1h1) + ((c21 = (t2l1 >>> 16) + (t1l1 >>> 16) + (c11 >>> 16)) >>> 16), ah10 = (c41 = (t2h1 >>> 16) + (t1h1 >>> 16) + (c31 >>> 16)) << 16 | 0xFFFF & c31, al10 = c21 << 16 | 0xFFFF & c11;
                    c11 = (0xFFFF & h0l1) + (0xFFFF & al10), c31 = (0xFFFF & h0h1) + (0xFFFF & ah10) + ((c21 = (h0l1 >>> 16) + (al10 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h0h1 >>> 16) + (ah10 >>> 16) + (c31 >>> 16), this.h0h = c41 << 16 | 0xFFFF & c31, this.h0l = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & h1l1) + (0xFFFF & bl10), c31 = (0xFFFF & h1h1) + (0xFFFF & bh10) + ((c21 = (h1l1 >>> 16) + (bl10 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h1h1 >>> 16) + (bh10 >>> 16) + (c31 >>> 16), this.h1h = c41 << 16 | 0xFFFF & c31, this.h1l = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & h2l1) + (0xFFFF & cl1), c31 = (0xFFFF & h2h1) + (0xFFFF & ch1) + ((c21 = (h2l1 >>> 16) + (cl1 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h2h1 >>> 16) + (ch1 >>> 16) + (c31 >>> 16), this.h2h = c41 << 16 | 0xFFFF & c31, this.h2l = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & h3l1) + (0xFFFF & dl1), c31 = (0xFFFF & h3h1) + (0xFFFF & dh1) + ((c21 = (h3l1 >>> 16) + (dl1 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h3h1 >>> 16) + (dh1 >>> 16) + (c31 >>> 16), this.h3h = c41 << 16 | 0xFFFF & c31, this.h3l = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & h4l1) + (0xFFFF & el1), c31 = (0xFFFF & h4h1) + (0xFFFF & eh1) + ((c21 = (h4l1 >>> 16) + (el1 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h4h1 >>> 16) + (eh1 >>> 16) + (c31 >>> 16), this.h4h = c41 << 16 | 0xFFFF & c31, this.h4l = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & h5l1) + (0xFFFF & fl1), c31 = (0xFFFF & h5h1) + (0xFFFF & fh1) + ((c21 = (h5l1 >>> 16) + (fl1 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h5h1 >>> 16) + (fh1 >>> 16) + (c31 >>> 16), this.h5h = c41 << 16 | 0xFFFF & c31, this.h5l = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & h6l1) + (0xFFFF & gl1), c31 = (0xFFFF & h6h1) + (0xFFFF & gh1) + ((c21 = (h6l1 >>> 16) + (gl1 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h6h1 >>> 16) + (gh1 >>> 16) + (c31 >>> 16), this.h6h = c41 << 16 | 0xFFFF & c31, this.h6l = c21 << 16 | 0xFFFF & c11, c11 = (0xFFFF & h7l1) + (0xFFFF & hl1), c31 = (0xFFFF & h7h1) + (0xFFFF & hh1) + ((c21 = (h7l1 >>> 16) + (hl1 >>> 16) + (c11 >>> 16)) >>> 16), c41 = (h7h1 >>> 16) + (hh1 >>> 16) + (c31 >>> 16), this.h7h = c41 << 16 | 0xFFFF & c31, this.h7l = c21 << 16 | 0xFFFF & c11;
                }, Sha5121.prototype.hex = function() {
                    this.finalize();
                    var h0h1 = this.h0h, h0l1 = this.h0l, h1h1 = this.h1h, h1l1 = this.h1l, h2h1 = this.h2h, h2l1 = this.h2l, h3h1 = this.h3h, h3l1 = this.h3l, h4h1 = this.h4h, h4l1 = this.h4l, h5h1 = this.h5h, h5l1 = this.h5l, h6h1 = this.h6h, h6l1 = this.h6l, h7h1 = this.h7h, h7l1 = this.h7l, bits1 = this.bits, hex1 = HEX_CHARS1[h0h1 >> 28 & 0x0F] + HEX_CHARS1[h0h1 >> 24 & 0x0F] + HEX_CHARS1[h0h1 >> 20 & 0x0F] + HEX_CHARS1[h0h1 >> 16 & 0x0F] + HEX_CHARS1[h0h1 >> 12 & 0x0F] + HEX_CHARS1[h0h1 >> 8 & 0x0F] + HEX_CHARS1[h0h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h0h1] + HEX_CHARS1[h0l1 >> 28 & 0x0F] + HEX_CHARS1[h0l1 >> 24 & 0x0F] + HEX_CHARS1[h0l1 >> 20 & 0x0F] + HEX_CHARS1[h0l1 >> 16 & 0x0F] + HEX_CHARS1[h0l1 >> 12 & 0x0F] + HEX_CHARS1[h0l1 >> 8 & 0x0F] + HEX_CHARS1[h0l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h0l1] + HEX_CHARS1[h1h1 >> 28 & 0x0F] + HEX_CHARS1[h1h1 >> 24 & 0x0F] + HEX_CHARS1[h1h1 >> 20 & 0x0F] + HEX_CHARS1[h1h1 >> 16 & 0x0F] + HEX_CHARS1[h1h1 >> 12 & 0x0F] + HEX_CHARS1[h1h1 >> 8 & 0x0F] + HEX_CHARS1[h1h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h1h1] + HEX_CHARS1[h1l1 >> 28 & 0x0F] + HEX_CHARS1[h1l1 >> 24 & 0x0F] + HEX_CHARS1[h1l1 >> 20 & 0x0F] + HEX_CHARS1[h1l1 >> 16 & 0x0F] + HEX_CHARS1[h1l1 >> 12 & 0x0F] + HEX_CHARS1[h1l1 >> 8 & 0x0F] + HEX_CHARS1[h1l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h1l1] + HEX_CHARS1[h2h1 >> 28 & 0x0F] + HEX_CHARS1[h2h1 >> 24 & 0x0F] + HEX_CHARS1[h2h1 >> 20 & 0x0F] + HEX_CHARS1[h2h1 >> 16 & 0x0F] + HEX_CHARS1[h2h1 >> 12 & 0x0F] + HEX_CHARS1[h2h1 >> 8 & 0x0F] + HEX_CHARS1[h2h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h2h1] + HEX_CHARS1[h2l1 >> 28 & 0x0F] + HEX_CHARS1[h2l1 >> 24 & 0x0F] + HEX_CHARS1[h2l1 >> 20 & 0x0F] + HEX_CHARS1[h2l1 >> 16 & 0x0F] + HEX_CHARS1[h2l1 >> 12 & 0x0F] + HEX_CHARS1[h2l1 >> 8 & 0x0F] + HEX_CHARS1[h2l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h2l1] + HEX_CHARS1[h3h1 >> 28 & 0x0F] + HEX_CHARS1[h3h1 >> 24 & 0x0F] + HEX_CHARS1[h3h1 >> 20 & 0x0F] + HEX_CHARS1[h3h1 >> 16 & 0x0F] + HEX_CHARS1[h3h1 >> 12 & 0x0F] + HEX_CHARS1[h3h1 >> 8 & 0x0F] + HEX_CHARS1[h3h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h3h1];
                    return bits1 >= 256 && (hex1 += HEX_CHARS1[h3l1 >> 28 & 0x0F] + HEX_CHARS1[h3l1 >> 24 & 0x0F] + HEX_CHARS1[h3l1 >> 20 & 0x0F] + HEX_CHARS1[h3l1 >> 16 & 0x0F] + HEX_CHARS1[h3l1 >> 12 & 0x0F] + HEX_CHARS1[h3l1 >> 8 & 0x0F] + HEX_CHARS1[h3l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h3l1]), bits1 >= 384 && (hex1 += HEX_CHARS1[h4h1 >> 28 & 0x0F] + HEX_CHARS1[h4h1 >> 24 & 0x0F] + HEX_CHARS1[h4h1 >> 20 & 0x0F] + HEX_CHARS1[h4h1 >> 16 & 0x0F] + HEX_CHARS1[h4h1 >> 12 & 0x0F] + HEX_CHARS1[h4h1 >> 8 & 0x0F] + HEX_CHARS1[h4h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h4h1] + HEX_CHARS1[h4l1 >> 28 & 0x0F] + HEX_CHARS1[h4l1 >> 24 & 0x0F] + HEX_CHARS1[h4l1 >> 20 & 0x0F] + HEX_CHARS1[h4l1 >> 16 & 0x0F] + HEX_CHARS1[h4l1 >> 12 & 0x0F] + HEX_CHARS1[h4l1 >> 8 & 0x0F] + HEX_CHARS1[h4l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h4l1] + HEX_CHARS1[h5h1 >> 28 & 0x0F] + HEX_CHARS1[h5h1 >> 24 & 0x0F] + HEX_CHARS1[h5h1 >> 20 & 0x0F] + HEX_CHARS1[h5h1 >> 16 & 0x0F] + HEX_CHARS1[h5h1 >> 12 & 0x0F] + HEX_CHARS1[h5h1 >> 8 & 0x0F] + HEX_CHARS1[h5h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h5h1] + HEX_CHARS1[h5l1 >> 28 & 0x0F] + HEX_CHARS1[h5l1 >> 24 & 0x0F] + HEX_CHARS1[h5l1 >> 20 & 0x0F] + HEX_CHARS1[h5l1 >> 16 & 0x0F] + HEX_CHARS1[h5l1 >> 12 & 0x0F] + HEX_CHARS1[h5l1 >> 8 & 0x0F] + HEX_CHARS1[h5l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h5l1]), 512 == bits1 && (hex1 += HEX_CHARS1[h6h1 >> 28 & 0x0F] + HEX_CHARS1[h6h1 >> 24 & 0x0F] + HEX_CHARS1[h6h1 >> 20 & 0x0F] + HEX_CHARS1[h6h1 >> 16 & 0x0F] + HEX_CHARS1[h6h1 >> 12 & 0x0F] + HEX_CHARS1[h6h1 >> 8 & 0x0F] + HEX_CHARS1[h6h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h6h1] + HEX_CHARS1[h6l1 >> 28 & 0x0F] + HEX_CHARS1[h6l1 >> 24 & 0x0F] + HEX_CHARS1[h6l1 >> 20 & 0x0F] + HEX_CHARS1[h6l1 >> 16 & 0x0F] + HEX_CHARS1[h6l1 >> 12 & 0x0F] + HEX_CHARS1[h6l1 >> 8 & 0x0F] + HEX_CHARS1[h6l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h6l1] + HEX_CHARS1[h7h1 >> 28 & 0x0F] + HEX_CHARS1[h7h1 >> 24 & 0x0F] + HEX_CHARS1[h7h1 >> 20 & 0x0F] + HEX_CHARS1[h7h1 >> 16 & 0x0F] + HEX_CHARS1[h7h1 >> 12 & 0x0F] + HEX_CHARS1[h7h1 >> 8 & 0x0F] + HEX_CHARS1[h7h1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h7h1] + HEX_CHARS1[h7l1 >> 28 & 0x0F] + HEX_CHARS1[h7l1 >> 24 & 0x0F] + HEX_CHARS1[h7l1 >> 20 & 0x0F] + HEX_CHARS1[h7l1 >> 16 & 0x0F] + HEX_CHARS1[h7l1 >> 12 & 0x0F] + HEX_CHARS1[h7l1 >> 8 & 0x0F] + HEX_CHARS1[h7l1 >> 4 & 0x0F] + HEX_CHARS1[0x0F & h7l1]), hex1;
                }, Sha5121.prototype.toString = Sha5121.prototype.hex, Sha5121.prototype.digest = function() {
                    this.finalize();
                    var h0h1 = this.h0h, h0l1 = this.h0l, h1h1 = this.h1h, h1l1 = this.h1l, h2h1 = this.h2h, h2l1 = this.h2l, h3h1 = this.h3h, h3l1 = this.h3l, h4h1 = this.h4h, h4l1 = this.h4l, h5h1 = this.h5h, h5l1 = this.h5l, h6h1 = this.h6h, h6l1 = this.h6l, h7h1 = this.h7h, h7l1 = this.h7l, bits1 = this.bits, arr1 = [
                        h0h1 >> 24 & 0xFF,
                        h0h1 >> 16 & 0xFF,
                        h0h1 >> 8 & 0xFF,
                        0xFF & h0h1,
                        h0l1 >> 24 & 0xFF,
                        h0l1 >> 16 & 0xFF,
                        h0l1 >> 8 & 0xFF,
                        0xFF & h0l1,
                        h1h1 >> 24 & 0xFF,
                        h1h1 >> 16 & 0xFF,
                        h1h1 >> 8 & 0xFF,
                        0xFF & h1h1,
                        h1l1 >> 24 & 0xFF,
                        h1l1 >> 16 & 0xFF,
                        h1l1 >> 8 & 0xFF,
                        0xFF & h1l1,
                        h2h1 >> 24 & 0xFF,
                        h2h1 >> 16 & 0xFF,
                        h2h1 >> 8 & 0xFF,
                        0xFF & h2h1,
                        h2l1 >> 24 & 0xFF,
                        h2l1 >> 16 & 0xFF,
                        h2l1 >> 8 & 0xFF,
                        0xFF & h2l1,
                        h3h1 >> 24 & 0xFF,
                        h3h1 >> 16 & 0xFF,
                        h3h1 >> 8 & 0xFF,
                        0xFF & h3h1
                    ];
                    return bits1 >= 256 && arr1.push(h3l1 >> 24 & 0xFF, h3l1 >> 16 & 0xFF, h3l1 >> 8 & 0xFF, 0xFF & h3l1), bits1 >= 384 && arr1.push(h4h1 >> 24 & 0xFF, h4h1 >> 16 & 0xFF, h4h1 >> 8 & 0xFF, 0xFF & h4h1, h4l1 >> 24 & 0xFF, h4l1 >> 16 & 0xFF, h4l1 >> 8 & 0xFF, 0xFF & h4l1, h5h1 >> 24 & 0xFF, h5h1 >> 16 & 0xFF, h5h1 >> 8 & 0xFF, 0xFF & h5h1, h5l1 >> 24 & 0xFF, h5l1 >> 16 & 0xFF, h5l1 >> 8 & 0xFF, 0xFF & h5l1), 512 == bits1 && arr1.push(h6h1 >> 24 & 0xFF, h6h1 >> 16 & 0xFF, h6h1 >> 8 & 0xFF, 0xFF & h6h1, h6l1 >> 24 & 0xFF, h6l1 >> 16 & 0xFF, h6l1 >> 8 & 0xFF, 0xFF & h6l1, h7h1 >> 24 & 0xFF, h7h1 >> 16 & 0xFF, h7h1 >> 8 & 0xFF, 0xFF & h7h1, h7l1 >> 24 & 0xFF, h7l1 >> 16 & 0xFF, h7l1 >> 8 & 0xFF, 0xFF & h7l1), arr1;
                }, Sha5121.prototype.array = Sha5121.prototype.digest, Sha5121.prototype.arrayBuffer = function() {
                    this.finalize();
                    var bits1 = this.bits, buffer1 = new ArrayBuffer(bits1 / 8), dataView1 = new DataView(buffer1);
                    return dataView1.setUint32(0, this.h0h), dataView1.setUint32(4, this.h0l), dataView1.setUint32(8, this.h1h), dataView1.setUint32(12, this.h1l), dataView1.setUint32(16, this.h2h), dataView1.setUint32(20, this.h2l), dataView1.setUint32(24, this.h3h), bits1 >= 256 && dataView1.setUint32(28, this.h3l), bits1 >= 384 && (dataView1.setUint32(32, this.h4h), dataView1.setUint32(36, this.h4l), dataView1.setUint32(40, this.h5h), dataView1.setUint32(44, this.h5l)), 512 == bits1 && (dataView1.setUint32(48, this.h6h), dataView1.setUint32(52, this.h6l), dataView1.setUint32(56, this.h7h), dataView1.setUint32(60, this.h7l)), buffer1;
                }, Sha5121.prototype.clone = function() {
                    var hash1 = new Sha5121(this.bits, !1);
                    return this.copyTo(hash1), hash1;
                }, Sha5121.prototype.copyTo = function(hash1) {
                    var i2 = 0, attrs1 = [
                        'h0h',
                        'h0l',
                        'h1h',
                        'h1l',
                        'h2h',
                        'h2l',
                        'h3h',
                        'h3l',
                        'h4h',
                        'h4l',
                        'h5h',
                        'h5l',
                        'h6h',
                        'h6l',
                        'h7h',
                        'h7l',
                        'start',
                        'bytes',
                        'hBytes',
                        'finalized',
                        'hashed',
                        'lastByteIndex'
                    ];
                    for(i2 = 0; i2 < attrs1.length; ++i2)hash1[attrs1[i2]] = this[attrs1[i2]];
                    for(i2 = 0; i2 < this.blocks.length; ++i2)hash1.blocks[i2] = this.blocks[i2];
                }, HmacSha5121.prototype = new Sha5121(), HmacSha5121.prototype.finalize = function() {
                    if (Sha5121.prototype.finalize.call(this), this.inner) {
                        this.inner = !1;
                        var innerHash1 = this.array();
                        Sha5121.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(innerHash1), Sha5121.prototype.finalize.call(this);
                    }
                }, HmacSha5121.prototype.clone = function() {
                    var hash1 = new HmacSha5121([], this.bits, !1);
                    this.copyTo(hash1), hash1.inner = this.inner;
                    for(var i2 = 0; i2 < this.oKeyPad.length; ++i2)hash1.oKeyPad[i2] = this.oKeyPad[i2];
                    return hash1;
                };
                var exports1 = createMethod1(512);
                exports1.sha512 = exports1, exports1.sha384 = createMethod1(384), exports1.sha512_256 = createMethod1(256), exports1.sha512_224 = createMethod1(224), exports1.sha512.hmac = createHmacMethod1(512), exports1.sha384.hmac = createHmacMethod1(384), exports1.sha512_256.hmac = createHmacMethod1(256), exports1.sha512_224.hmac = createHmacMethod1(224), COMMON_JS1 ? module1.exports = exports1 : (root1.sha512 = exports1.sha512, root1.sha384 = exports1.sha384, root1.sha512_256 = exports1.sha512_256, root1.sha512_224 = exports1.sha512_224, AMD1 && void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__1 = (function() {
                    return exports1;
                }).call(exports1, __webpack_require__1, exports1, module1)) && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__1));
            }();
        },
        5548: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            exports1.unsigned = __webpack_require__1(6922), exports1.signed = __webpack_require__1(4927);
        },
        4927: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const Bn1 = __webpack_require__1(3550), Pipe1 = __webpack_require__1(3533);
            function read1(stream1) {
                return readBn1(stream1).toString();
            }
            function readBn1(stream1) {
                let byt1;
                const num1 = new Bn1(0);
                let shift1 = 0;
                for(; byt1 = stream1.read(1)[0], num1.ior(new Bn1(0x7f & byt1).shln(shift1)), shift1 += 7, byt1 >> 7 != 0;);
                return 0x40 & byt1 && num1.setn(shift1), num1.fromTwos(shift1);
            }
            function write1(number1, stream1) {
                let num1 = new Bn1(number1);
                const isNeg1 = num1.isNeg();
                for(isNeg1 && (num1 = num1.toTwos(num1.bitLength() + 8));;){
                    const i2 = num1.maskn(7).toNumber();
                    if (num1.ishrn(7), isNegOne1(num1) && (0x40 & i2) != 0 || num1.isZero() && (0x40 & i2) == 0) {
                        stream1.write([
                            i2
                        ]);
                        break;
                    }
                    stream1.write([
                        0x80 | i2
                    ]);
                }
                function isNegOne1(num1) {
                    return isNeg1 && 0 > num1.toString(2).indexOf('0');
                }
            }
            function encode1(num1) {
                const stream1 = new Pipe1();
                return write1(num1, stream1), stream1.buffer;
            }
            function decode1(buffer1) {
                const stream1 = new Pipe1(buffer1);
                return read1(stream1);
            }
            module1.exports = {
                encode: encode1,
                decode: decode1,
                write: write1,
                read: read1,
                readBn: readBn1
            };
        },
        6922: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const Bn1 = __webpack_require__1(3550), Pipe1 = __webpack_require__1(3533);
            function read1(stream1) {
                return readBn1(stream1).toString();
            }
            function readBn1(stream1) {
                let byt1;
                const num1 = new Bn1(0);
                let shift1 = 0;
                for(; byt1 = stream1.read(1)[0], num1.ior(new Bn1(0x7f & byt1).shln(shift1)), byt1 >> 7 != 0;)shift1 += 7;
                return num1;
            }
            function write1(number1, stream1) {
                const num1 = new Bn1(number1);
                for(;;){
                    const i2 = num1.maskn(7).toNumber();
                    if (num1.ishrn(7), num1.isZero()) {
                        stream1.write([
                            i2
                        ]);
                        break;
                    }
                    stream1.write([
                        0x80 | i2
                    ]);
                }
            }
            function encode1(num1) {
                const stream1 = new Pipe1();
                return write1(num1, stream1), stream1.buffer;
            }
            function decode1(buffer1) {
                const stream1 = new Pipe1(buffer1);
                return read1(stream1);
            }
            module1.exports = {
                encode: encode1,
                decode: decode1,
                read: read1,
                readBn: readBn1,
                write: write1
            };
        },
        1675: function(__unused_webpack_module1, exports1) {
            "use strict";
            exports1.supports = function(...manifests1) {
                const manifest1 = manifests1.reduce((acc1, m1)=>Object.assign(acc1, m1), {});
                return Object.assign(manifest1, {
                    snapshots: manifest1.snapshots || !1,
                    permanence: manifest1.permanence || !1,
                    seek: manifest1.seek || !1,
                    clear: manifest1.clear || !1,
                    getMany: manifest1.getMany || !1,
                    keyIterator: manifest1.keyIterator || !1,
                    valueIterator: manifest1.valueIterator || !1,
                    iteratorNextv: manifest1.iteratorNextv || !1,
                    iteratorAll: manifest1.iteratorAll || !1,
                    status: manifest1.status || !1,
                    createIfMissing: manifest1.createIfMissing || !1,
                    errorIfExists: manifest1.errorIfExists || !1,
                    deferredOpen: manifest1.deferredOpen || !1,
                    promises: manifest1.promises || !1,
                    streams: manifest1.streams || !1,
                    encodings: Object.assign({}, manifest1.encodings),
                    events: Object.assign({}, manifest1.events),
                    additionalMethods: Object.assign({}, manifest1.additionalMethods)
                });
            };
        },
        8499: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const ModuleError1 = __webpack_require__1(4473), encodings1 = __webpack_require__1(8002), { Encoding: Encoding1  } = __webpack_require__1(8266), { BufferFormat: BufferFormat1 , ViewFormat: ViewFormat1 , UTF8Format: UTF8Format1  } = __webpack_require__1(2376), kFormats1 = Symbol('formats'), kEncodings1 = Symbol('encodings'), validFormats1 = new Set([
                'buffer',
                'view',
                'utf8'
            ]);
            class Transcoder1 {
                constructor(formats1){
                    if (Array.isArray(formats1)) {
                        if (!formats1.every((f1)=>validFormats1.has(f1))) throw TypeError("Format must be one of 'buffer', 'view', 'utf8'");
                    } else throw TypeError("The first argument 'formats' must be an array");
                    for(const k3 in this[kEncodings1] = new Map(), this[kFormats1] = new Set(formats1), encodings1)try {
                        this.encoding(k3);
                    } catch (err1) {
                        if ('LEVEL_ENCODING_NOT_SUPPORTED' !== err1.code) throw err1;
                    }
                }
                encodings() {
                    return Array.from(new Set(this[kEncodings1].values()));
                }
                encoding(encoding1) {
                    let resolved1 = this[kEncodings1].get(encoding1);
                    if (void 0 === resolved1) {
                        if ('string' == typeof encoding1 && '' !== encoding1) {
                            if (!(resolved1 = lookup1[encoding1])) throw new ModuleError1(`Encoding '${encoding1}' is not found`, {
                                code: 'LEVEL_ENCODING_NOT_FOUND'
                            });
                        } else if ('object' != typeof encoding1 || null === encoding1) throw TypeError("First argument 'encoding' must be a string or object");
                        else resolved1 = from1(encoding1);
                        const { name: name1 , format: format1  } = resolved1;
                        if (!this[kFormats1].has(format1)) {
                            if (this[kFormats1].has('view')) resolved1 = resolved1.createViewTranscoder();
                            else if (this[kFormats1].has('buffer')) resolved1 = resolved1.createBufferTranscoder();
                            else if (this[kFormats1].has('utf8')) resolved1 = resolved1.createUTF8Transcoder();
                            else throw new ModuleError1(`Encoding '${name1}' cannot be transcoded`, {
                                code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                            });
                        }
                        for (const k3 of [
                            encoding1,
                            name1,
                            resolved1.name,
                            resolved1.commonName
                        ])this[kEncodings1].set(k3, resolved1);
                    }
                    return resolved1;
                }
            }
            function from1(options1) {
                if (options1 instanceof Encoding1) return options1;
                const maybeType1 = 'type' in options1 && 'string' == typeof options1.type ? options1.type : void 0, name1 = options1.name || maybeType1 || `anonymous-${anonymousCount1++}`;
                switch(detectFormat1(options1)){
                    case 'view':
                        return new ViewFormat1({
                            ...options1,
                            name: name1
                        });
                    case 'utf8':
                        return new UTF8Format1({
                            ...options1,
                            name: name1
                        });
                    case 'buffer':
                        return new BufferFormat1({
                            ...options1,
                            name: name1
                        });
                    default:
                        throw TypeError("Format must be one of 'buffer', 'view', 'utf8'");
                }
            }
            function detectFormat1(options1) {
                return 'format' in options1 && void 0 !== options1.format ? options1.format : 'buffer' in options1 && 'boolean' == typeof options1.buffer ? options1.buffer ? 'buffer' : 'utf8' : 'code' in options1 && Number.isInteger(options1.code) ? 'view' : 'buffer';
            }
            exports1.Transcoder = Transcoder1;
            const aliases1 = {
                binary: encodings1.buffer,
                'utf-8': encodings1.utf8
            }, lookup1 = {
                ...encodings1,
                ...aliases1
            };
            let anonymousCount1 = 0;
        },
        8266: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const ModuleError1 = __webpack_require__1(4473), formats1 = new Set([
                'buffer',
                'view',
                'utf8'
            ]);
            class Encoding1 {
                constructor(options1){
                    if (this.encode = options1.encode || this.encode, this.decode = options1.decode || this.decode, this.name = options1.name || this.name, this.format = options1.format || this.format, 'function' != typeof this.encode) throw TypeError("The 'encode' property must be a function");
                    if ('function' != typeof this.decode) throw TypeError("The 'decode' property must be a function");
                    if (this.encode = this.encode.bind(this), this.decode = this.decode.bind(this), 'string' != typeof this.name || '' === this.name) throw TypeError("The 'name' property must be a string");
                    if ('string' != typeof this.format || !formats1.has(this.format)) throw TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
                    options1.createViewTranscoder && (this.createViewTranscoder = options1.createViewTranscoder), options1.createBufferTranscoder && (this.createBufferTranscoder = options1.createBufferTranscoder), options1.createUTF8Transcoder && (this.createUTF8Transcoder = options1.createUTF8Transcoder);
                }
                get commonName() {
                    return this.name.split('+')[0];
                }
                createBufferTranscoder() {
                    throw new ModuleError1(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                }
                createViewTranscoder() {
                    throw new ModuleError1(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                }
                createUTF8Transcoder() {
                    throw new ModuleError1(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                }
            }
            exports1.Encoding = Encoding1;
        },
        8002: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { Buffer: Buffer1  } = __webpack_require__1(8764) || {
                Buffer: {
                    isBuffer: ()=>!1
                }
            }, { textEncoder: textEncoder1 , textDecoder: textDecoder1  } = __webpack_require__1(5850)(), { BufferFormat: BufferFormat1 , ViewFormat: ViewFormat1 , UTF8Format: UTF8Format1  } = __webpack_require__1(2376), identity1 = (v3)=>v3;
            exports1.utf8 = new UTF8Format1({
                encode: function(data1) {
                    return Buffer1.isBuffer(data1) ? data1.toString('utf8') : ArrayBuffer.isView(data1) ? textDecoder1.decode(data1) : String(data1);
                },
                decode: identity1,
                name: 'utf8',
                createViewTranscoder () {
                    return new ViewFormat1({
                        encode: function(data1) {
                            return ArrayBuffer.isView(data1) ? data1 : textEncoder1.encode(data1);
                        },
                        decode: function(data1) {
                            return textDecoder1.decode(data1);
                        },
                        name: `${this.name}+view`
                    });
                },
                createBufferTranscoder () {
                    return new BufferFormat1({
                        encode: function(data1) {
                            return Buffer1.isBuffer(data1) ? data1 : ArrayBuffer.isView(data1) ? Buffer1.from(data1.buffer, data1.byteOffset, data1.byteLength) : Buffer1.from(String(data1), 'utf8');
                        },
                        decode: function(data1) {
                            return data1.toString('utf8');
                        },
                        name: `${this.name}+buffer`
                    });
                }
            }), exports1.json = new UTF8Format1({
                encode: JSON.stringify,
                decode: JSON.parse,
                name: 'json'
            }), exports1.buffer = new BufferFormat1({
                encode: function(data1) {
                    return Buffer1.isBuffer(data1) ? data1 : ArrayBuffer.isView(data1) ? Buffer1.from(data1.buffer, data1.byteOffset, data1.byteLength) : Buffer1.from(String(data1), 'utf8');
                },
                decode: identity1,
                name: 'buffer',
                createViewTranscoder () {
                    return new ViewFormat1({
                        encode: function(data1) {
                            return ArrayBuffer.isView(data1) ? data1 : Buffer1.from(String(data1), 'utf8');
                        },
                        decode: function(data1) {
                            return Buffer1.from(data1.buffer, data1.byteOffset, data1.byteLength);
                        },
                        name: `${this.name}+view`
                    });
                }
            }), exports1.view = new ViewFormat1({
                encode: function(data1) {
                    return ArrayBuffer.isView(data1) ? data1 : textEncoder1.encode(data1);
                },
                decode: identity1,
                name: 'view',
                createBufferTranscoder () {
                    return new BufferFormat1({
                        encode: function(data1) {
                            return Buffer1.isBuffer(data1) ? data1 : ArrayBuffer.isView(data1) ? Buffer1.from(data1.buffer, data1.byteOffset, data1.byteLength) : Buffer1.from(String(data1), 'utf8');
                        },
                        decode: identity1,
                        name: `${this.name}+buffer`
                    });
                }
            }), exports1.hex = new BufferFormat1({
                encode: function(data1) {
                    return Buffer1.isBuffer(data1) ? data1 : Buffer1.from(String(data1), 'hex');
                },
                decode: function(buffer1) {
                    return buffer1.toString('hex');
                },
                name: 'hex'
            }), exports1.base64 = new BufferFormat1({
                encode: function(data1) {
                    return Buffer1.isBuffer(data1) ? data1 : Buffer1.from(String(data1), 'base64');
                },
                decode: function(buffer1) {
                    return buffer1.toString('base64');
                },
                name: 'base64'
            });
        },
        2376: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            const { Buffer: Buffer1  } = __webpack_require__1(8764) || {}, { Encoding: Encoding1  } = __webpack_require__1(8266), textEndec1 = __webpack_require__1(5850);
            class BufferFormat1 extends Encoding1 {
                constructor(options1){
                    super({
                        ...options1,
                        format: 'buffer'
                    });
                }
                createViewTranscoder() {
                    return new ViewFormat1({
                        encode: this.encode,
                        decode: (data1)=>this.decode(Buffer1.from(data1.buffer, data1.byteOffset, data1.byteLength)),
                        name: `${this.name}+view`
                    });
                }
                createBufferTranscoder() {
                    return this;
                }
            }
            class ViewFormat1 extends Encoding1 {
                constructor(options1){
                    super({
                        ...options1,
                        format: 'view'
                    });
                }
                createBufferTranscoder() {
                    return new BufferFormat1({
                        encode: (data1)=>{
                            const view1 = this.encode(data1);
                            return Buffer1.from(view1.buffer, view1.byteOffset, view1.byteLength);
                        },
                        decode: this.decode,
                        name: `${this.name}+buffer`
                    });
                }
                createViewTranscoder() {
                    return this;
                }
            }
            class UTF8Format1 extends Encoding1 {
                constructor(options1){
                    super({
                        ...options1,
                        format: 'utf8'
                    });
                }
                createBufferTranscoder() {
                    return new BufferFormat1({
                        encode: (data1)=>Buffer1.from(this.encode(data1), 'utf8'),
                        decode: (data1)=>this.decode(data1.toString('utf8')),
                        name: `${this.name}+buffer`
                    });
                }
                createViewTranscoder() {
                    const { textEncoder: textEncoder1 , textDecoder: textDecoder1  } = textEndec1();
                    return new ViewFormat1({
                        encode: (data1)=>textEncoder1.encode(this.encode(data1)),
                        decode: (data1)=>this.decode(textDecoder1.decode(data1)),
                        name: `${this.name}+view`
                    });
                }
                createUTF8Transcoder() {
                    return this;
                }
            }
            exports1.BufferFormat = BufferFormat1, exports1.ViewFormat = ViewFormat1, exports1.UTF8Format = UTF8Format1;
        },
        5850: function(module1) {
            "use strict";
            let lazy1 = null;
            module1.exports = function() {
                return null === lazy1 && (lazy1 = {
                    textEncoder: new TextEncoder(),
                    textDecoder: new TextDecoder()
                }), lazy1;
            };
        },
        3145: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            exports1.Level = __webpack_require__1(1708).BrowserLevel;
        },
        8552: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var DataView1 = __webpack_require__1(852)(__webpack_require__1(5639), 'DataView');
            module1.exports = DataView1;
        },
        1989: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var hashClear1 = __webpack_require__1(1789), hashDelete1 = __webpack_require__1(401), hashGet1 = __webpack_require__1(7667), hashHas1 = __webpack_require__1(1327), hashSet1 = __webpack_require__1(1866);
            function Hash1(entries1) {
                var index1 = -1, length1 = null == entries1 ? 0 : entries1.length;
                for(this.clear(); ++index1 < length1;){
                    var entry1 = entries1[index1];
                    this.set(entry1[0], entry1[1]);
                }
            }
            Hash1.prototype.clear = hashClear1, Hash1.prototype.delete = hashDelete1, Hash1.prototype.get = hashGet1, Hash1.prototype.has = hashHas1, Hash1.prototype.set = hashSet1, module1.exports = Hash1;
        },
        8407: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var listCacheClear1 = __webpack_require__1(7040), listCacheDelete1 = __webpack_require__1(4125), listCacheGet1 = __webpack_require__1(2117), listCacheHas1 = __webpack_require__1(7518), listCacheSet1 = __webpack_require__1(4705);
            function ListCache1(entries1) {
                var index1 = -1, length1 = null == entries1 ? 0 : entries1.length;
                for(this.clear(); ++index1 < length1;){
                    var entry1 = entries1[index1];
                    this.set(entry1[0], entry1[1]);
                }
            }
            ListCache1.prototype.clear = listCacheClear1, ListCache1.prototype.delete = listCacheDelete1, ListCache1.prototype.get = listCacheGet1, ListCache1.prototype.has = listCacheHas1, ListCache1.prototype.set = listCacheSet1, module1.exports = ListCache1;
        },
        7071: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Map1 = __webpack_require__1(852)(__webpack_require__1(5639), 'Map');
            module1.exports = Map1;
        },
        3369: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var mapCacheClear1 = __webpack_require__1(4785), mapCacheDelete1 = __webpack_require__1(1285), mapCacheGet1 = __webpack_require__1(6000), mapCacheHas1 = __webpack_require__1(9916), mapCacheSet1 = __webpack_require__1(5265);
            function MapCache1(entries1) {
                var index1 = -1, length1 = null == entries1 ? 0 : entries1.length;
                for(this.clear(); ++index1 < length1;){
                    var entry1 = entries1[index1];
                    this.set(entry1[0], entry1[1]);
                }
            }
            MapCache1.prototype.clear = mapCacheClear1, MapCache1.prototype.delete = mapCacheDelete1, MapCache1.prototype.get = mapCacheGet1, MapCache1.prototype.has = mapCacheHas1, MapCache1.prototype.set = mapCacheSet1, module1.exports = MapCache1;
        },
        3818: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Promise1 = __webpack_require__1(852)(__webpack_require__1(5639), 'Promise');
            module1.exports = Promise1;
        },
        8525: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Set1 = __webpack_require__1(852)(__webpack_require__1(5639), 'Set');
            module1.exports = Set1;
        },
        6384: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var ListCache1 = __webpack_require__1(8407), stackClear1 = __webpack_require__1(7465), stackDelete1 = __webpack_require__1(3779), stackGet1 = __webpack_require__1(7599), stackHas1 = __webpack_require__1(4758), stackSet1 = __webpack_require__1(4309);
            function Stack1(entries1) {
                var data1 = this.__data__ = new ListCache1(entries1);
                this.size = data1.size;
            }
            Stack1.prototype.clear = stackClear1, Stack1.prototype.delete = stackDelete1, Stack1.prototype.get = stackGet1, Stack1.prototype.has = stackHas1, Stack1.prototype.set = stackSet1, module1.exports = Stack1;
        },
        2705: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Symbol1 = __webpack_require__1(5639).Symbol;
            module1.exports = Symbol1;
        },
        1149: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Uint8Array1 = __webpack_require__1(5639).Uint8Array;
            module1.exports = Uint8Array1;
        },
        577: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var WeakMap1 = __webpack_require__1(852)(__webpack_require__1(5639), 'WeakMap');
            module1.exports = WeakMap1;
        },
        7412: function(module1) {
            function arrayEach1(array1, iteratee1) {
                for(var index1 = -1, length1 = null == array1 ? 0 : array1.length; ++index1 < length1 && !1 !== iteratee1(array1[index1], index1, array1););
                return array1;
            }
            module1.exports = arrayEach1;
        },
        4963: function(module1) {
            function arrayFilter1(array1, predicate1) {
                for(var index1 = -1, length1 = null == array1 ? 0 : array1.length, resIndex1 = 0, result1 = []; ++index1 < length1;){
                    var value1 = array1[index1];
                    predicate1(value1, index1, array1) && (result1[resIndex1++] = value1);
                }
                return result1;
            }
            module1.exports = arrayFilter1;
        },
        4636: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseTimes1 = __webpack_require__1(2545), isArguments1 = __webpack_require__1(5694), isArray1 = __webpack_require__1(1469), isBuffer1 = __webpack_require__1(4144), isIndex1 = __webpack_require__1(213), isTypedArray1 = __webpack_require__1(6719), hasOwnProperty1 = Object.prototype.hasOwnProperty;
            function arrayLikeKeys1(value1, inherited1) {
                var isArr1 = isArray1(value1), isArg1 = !isArr1 && isArguments1(value1), isBuff1 = !isArr1 && !isArg1 && isBuffer1(value1), isType1 = !isArr1 && !isArg1 && !isBuff1 && isTypedArray1(value1), skipIndexes1 = isArr1 || isArg1 || isBuff1 || isType1, result1 = skipIndexes1 ? baseTimes1(value1.length, String) : [], length1 = result1.length;
                for(var key1 in value1)(inherited1 || hasOwnProperty1.call(value1, key1)) && !(skipIndexes1 && ('length' == key1 || isBuff1 && ('offset' == key1 || 'parent' == key1) || isType1 && ('buffer' == key1 || 'byteLength' == key1 || 'byteOffset' == key1) || isIndex1(key1, length1))) && result1.push(key1);
                return result1;
            }
            module1.exports = arrayLikeKeys1;
        },
        2488: function(module1) {
            function arrayPush1(array1, values1) {
                for(var index1 = -1, length1 = values1.length, offset1 = array1.length; ++index1 < length1;)array1[offset1 + index1] = values1[index1];
                return array1;
            }
            module1.exports = arrayPush1;
        },
        4865: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseAssignValue1 = __webpack_require__1(9465), eq1 = __webpack_require__1(7813), hasOwnProperty1 = Object.prototype.hasOwnProperty;
            function assignValue1(object1, key1, value1) {
                var objValue1 = object1[key1];
                hasOwnProperty1.call(object1, key1) && eq1(objValue1, value1) && (void 0 !== value1 || key1 in object1) || baseAssignValue1(object1, key1, value1);
            }
            module1.exports = assignValue1;
        },
        8470: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var eq1 = __webpack_require__1(7813);
            function assocIndexOf1(array1, key1) {
                for(var length1 = array1.length; length1--;)if (eq1(array1[length1][0], key1)) return length1;
                return -1;
            }
            module1.exports = assocIndexOf1;
        },
        4037: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var copyObject1 = __webpack_require__1(8363), keys1 = __webpack_require__1(3674);
            function baseAssign1(object1, source1) {
                return object1 && copyObject1(source1, keys1(source1), object1);
            }
            module1.exports = baseAssign1;
        },
        3886: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var copyObject1 = __webpack_require__1(8363), keysIn1 = __webpack_require__1(1704);
            function baseAssignIn1(object1, source1) {
                return object1 && copyObject1(source1, keysIn1(source1), object1);
            }
            module1.exports = baseAssignIn1;
        },
        9465: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var defineProperty1 = __webpack_require__1(8777);
            function baseAssignValue1(object1, key1, value1) {
                '__proto__' == key1 && defineProperty1 ? defineProperty1(object1, key1, {
                    configurable: !0,
                    enumerable: !0,
                    value: value1,
                    writable: !0
                }) : object1[key1] = value1;
            }
            module1.exports = baseAssignValue1;
        },
        5990: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Stack1 = __webpack_require__1(6384), arrayEach1 = __webpack_require__1(7412), assignValue1 = __webpack_require__1(4865), baseAssign1 = __webpack_require__1(4037), baseAssignIn1 = __webpack_require__1(3886), cloneBuffer1 = __webpack_require__1(4626), copyArray1 = __webpack_require__1(278), copySymbols1 = __webpack_require__1(8805), copySymbolsIn1 = __webpack_require__1(1911), getAllKeys1 = __webpack_require__1(8234), getAllKeysIn1 = __webpack_require__1(6904), getTag1 = __webpack_require__1(4160), initCloneArray1 = __webpack_require__1(3824), initCloneByTag1 = __webpack_require__1(9148), initCloneObject1 = __webpack_require__1(8517), isArray1 = __webpack_require__1(1469), isBuffer1 = __webpack_require__1(4144), isMap1 = __webpack_require__1(6688), isObject1 = __webpack_require__1(3218), isSet1 = __webpack_require__1(2928), keys1 = __webpack_require__1(3674), keysIn1 = __webpack_require__1(1704), CLONE_DEEP_FLAG1 = 1, CLONE_FLAT_FLAG1 = 2, CLONE_SYMBOLS_FLAG1 = 4, argsTag1 = '[object Arguments]', arrayTag1 = '[object Array]', boolTag1 = '[object Boolean]', dateTag1 = '[object Date]', errorTag1 = '[object Error]', funcTag1 = '[object Function]', genTag1 = '[object GeneratorFunction]', mapTag1 = '[object Map]', numberTag1 = '[object Number]', objectTag1 = '[object Object]', regexpTag1 = '[object RegExp]', setTag1 = '[object Set]', stringTag1 = '[object String]', symbolTag1 = '[object Symbol]', weakMapTag1 = '[object WeakMap]', arrayBufferTag1 = '[object ArrayBuffer]', dataViewTag1 = '[object DataView]', float32Tag1 = '[object Float32Array]', float64Tag1 = '[object Float64Array]', int8Tag1 = '[object Int8Array]', int16Tag1 = '[object Int16Array]', int32Tag1 = '[object Int32Array]', uint8Tag1 = '[object Uint8Array]', uint8ClampedTag1 = '[object Uint8ClampedArray]', uint16Tag1 = '[object Uint16Array]', uint32Tag1 = '[object Uint32Array]', cloneableTags1 = {};
            function baseClone1(value1, bitmask1, customizer1, key1, object1, stack1) {
                var result1, isDeep1 = bitmask1 & CLONE_DEEP_FLAG1, isFlat1 = bitmask1 & CLONE_FLAT_FLAG1, isFull1 = bitmask1 & CLONE_SYMBOLS_FLAG1;
                if (customizer1 && (result1 = object1 ? customizer1(value1, key1, object1, stack1) : customizer1(value1)), void 0 !== result1) return result1;
                if (!isObject1(value1)) return value1;
                var isArr1 = isArray1(value1);
                if (isArr1) {
                    if (result1 = initCloneArray1(value1), !isDeep1) return copyArray1(value1, result1);
                } else {
                    var tag1 = getTag1(value1), isFunc1 = tag1 == funcTag1 || tag1 == genTag1;
                    if (isBuffer1(value1)) return cloneBuffer1(value1, isDeep1);
                    if (tag1 == objectTag1 || tag1 == argsTag1 || isFunc1 && !object1) {
                        if (result1 = isFlat1 || isFunc1 ? {} : initCloneObject1(value1), !isDeep1) return isFlat1 ? copySymbolsIn1(value1, baseAssignIn1(result1, value1)) : copySymbols1(value1, baseAssign1(result1, value1));
                    } else {
                        if (!cloneableTags1[tag1]) return object1 ? value1 : {};
                        result1 = initCloneByTag1(value1, tag1, isDeep1);
                    }
                }
                stack1 || (stack1 = new Stack1);
                var stacked1 = stack1.get(value1);
                if (stacked1) return stacked1;
                stack1.set(value1, result1), isSet1(value1) ? value1.forEach(function(subValue1) {
                    result1.add(baseClone1(subValue1, bitmask1, customizer1, subValue1, value1, stack1));
                }) : isMap1(value1) && value1.forEach(function(subValue1, key1) {
                    result1.set(key1, baseClone1(subValue1, bitmask1, customizer1, key1, value1, stack1));
                });
                var keysFunc1 = isFull1 ? isFlat1 ? getAllKeysIn1 : getAllKeys1 : isFlat1 ? keysIn1 : keys1, props1 = isArr1 ? void 0 : keysFunc1(value1);
                return arrayEach1(props1 || value1, function(subValue1, key1) {
                    props1 && (subValue1 = value1[key1 = subValue1]), assignValue1(result1, key1, baseClone1(subValue1, bitmask1, customizer1, key1, value1, stack1));
                }), result1;
            }
            cloneableTags1[argsTag1] = cloneableTags1[arrayTag1] = cloneableTags1[arrayBufferTag1] = cloneableTags1[dataViewTag1] = cloneableTags1[boolTag1] = cloneableTags1[dateTag1] = cloneableTags1[float32Tag1] = cloneableTags1[float64Tag1] = cloneableTags1[int8Tag1] = cloneableTags1[int16Tag1] = cloneableTags1[int32Tag1] = cloneableTags1[mapTag1] = cloneableTags1[numberTag1] = cloneableTags1[objectTag1] = cloneableTags1[regexpTag1] = cloneableTags1[setTag1] = cloneableTags1[stringTag1] = cloneableTags1[symbolTag1] = cloneableTags1[uint8Tag1] = cloneableTags1[uint8ClampedTag1] = cloneableTags1[uint16Tag1] = cloneableTags1[uint32Tag1] = !0, cloneableTags1[errorTag1] = cloneableTags1[funcTag1] = cloneableTags1[weakMapTag1] = !1, module1.exports = baseClone1;
        },
        3118: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var isObject1 = __webpack_require__1(3218), objectCreate1 = Object.create, baseCreate1 = function() {
                function object1() {}
                return function(proto1) {
                    if (!isObject1(proto1)) return {};
                    if (objectCreate1) return objectCreate1(proto1);
                    object1.prototype = proto1;
                    var result1 = new object1;
                    return object1.prototype = void 0, result1;
                };
            }();
            module1.exports = baseCreate1;
        },
        8866: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var arrayPush1 = __webpack_require__1(2488), isArray1 = __webpack_require__1(1469);
            function baseGetAllKeys1(object1, keysFunc1, symbolsFunc1) {
                var result1 = keysFunc1(object1);
                return isArray1(object1) ? result1 : arrayPush1(result1, symbolsFunc1(object1));
            }
            module1.exports = baseGetAllKeys1;
        },
        4239: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Symbol1 = __webpack_require__1(2705), getRawTag1 = __webpack_require__1(9607), objectToString1 = __webpack_require__1(2333), nullTag1 = '[object Null]', undefinedTag1 = '[object Undefined]', symToStringTag1 = Symbol1 ? Symbol1.toStringTag : void 0;
            function baseGetTag1(value1) {
                return null == value1 ? void 0 === value1 ? undefinedTag1 : nullTag1 : symToStringTag1 && symToStringTag1 in Object(value1) ? getRawTag1(value1) : objectToString1(value1);
            }
            module1.exports = baseGetTag1;
        },
        9454: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseGetTag1 = __webpack_require__1(4239), isObjectLike1 = __webpack_require__1(7005), argsTag1 = '[object Arguments]';
            function baseIsArguments1(value1) {
                return isObjectLike1(value1) && baseGetTag1(value1) == argsTag1;
            }
            module1.exports = baseIsArguments1;
        },
        5588: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getTag1 = __webpack_require__1(4160), isObjectLike1 = __webpack_require__1(7005), mapTag1 = '[object Map]';
            function baseIsMap1(value1) {
                return isObjectLike1(value1) && getTag1(value1) == mapTag1;
            }
            module1.exports = baseIsMap1;
        },
        8458: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var isFunction1 = __webpack_require__1(3560), isMasked1 = __webpack_require__1(5346), isObject1 = __webpack_require__1(3218), toSource1 = __webpack_require__1(346), reRegExpChar1 = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor1 = /^\[object .+?Constructor\]$/, objectProto1 = Object.prototype, funcToString1 = Function.prototype.toString, hasOwnProperty1 = objectProto1.hasOwnProperty, reIsNative1 = RegExp('^' + funcToString1.call(hasOwnProperty1).replace(reRegExpChar1, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
            function baseIsNative1(value1) {
                return !(!isObject1(value1) || isMasked1(value1)) && (isFunction1(value1) ? reIsNative1 : reIsHostCtor1).test(toSource1(value1));
            }
            module1.exports = baseIsNative1;
        },
        9221: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getTag1 = __webpack_require__1(4160), isObjectLike1 = __webpack_require__1(7005), setTag1 = '[object Set]';
            function baseIsSet1(value1) {
                return isObjectLike1(value1) && getTag1(value1) == setTag1;
            }
            module1.exports = baseIsSet1;
        },
        8749: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseGetTag1 = __webpack_require__1(4239), isLength1 = __webpack_require__1(1780), isObjectLike1 = __webpack_require__1(7005), argsTag1 = '[object Arguments]', arrayTag1 = '[object Array]', boolTag1 = '[object Boolean]', dateTag1 = '[object Date]', errorTag1 = '[object Error]', funcTag1 = '[object Function]', mapTag1 = '[object Map]', numberTag1 = '[object Number]', objectTag1 = '[object Object]', regexpTag1 = '[object RegExp]', setTag1 = '[object Set]', stringTag1 = '[object String]', weakMapTag1 = '[object WeakMap]', arrayBufferTag1 = '[object ArrayBuffer]', dataViewTag1 = '[object DataView]', float64Tag1 = '[object Float64Array]', int8Tag1 = '[object Int8Array]', int16Tag1 = '[object Int16Array]', int32Tag1 = '[object Int32Array]', uint8Tag1 = '[object Uint8Array]', uint8ClampedTag1 = '[object Uint8ClampedArray]', uint16Tag1 = '[object Uint16Array]', uint32Tag1 = '[object Uint32Array]', typedArrayTags1 = {};
            function baseIsTypedArray1(value1) {
                return isObjectLike1(value1) && isLength1(value1.length) && !!typedArrayTags1[baseGetTag1(value1)];
            }
            typedArrayTags1['[object Float32Array]'] = typedArrayTags1[float64Tag1] = typedArrayTags1[int8Tag1] = typedArrayTags1[int16Tag1] = typedArrayTags1[int32Tag1] = typedArrayTags1[uint8Tag1] = typedArrayTags1[uint8ClampedTag1] = typedArrayTags1[uint16Tag1] = typedArrayTags1[uint32Tag1] = !0, typedArrayTags1[argsTag1] = typedArrayTags1[arrayTag1] = typedArrayTags1[arrayBufferTag1] = typedArrayTags1[boolTag1] = typedArrayTags1[dataViewTag1] = typedArrayTags1[dateTag1] = typedArrayTags1[errorTag1] = typedArrayTags1[funcTag1] = typedArrayTags1[mapTag1] = typedArrayTags1[numberTag1] = typedArrayTags1[objectTag1] = typedArrayTags1[regexpTag1] = typedArrayTags1[setTag1] = typedArrayTags1[stringTag1] = typedArrayTags1[weakMapTag1] = !1, module1.exports = baseIsTypedArray1;
        },
        280: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var isPrototype1 = __webpack_require__1(5726), nativeKeys1 = __webpack_require__1(6916), hasOwnProperty1 = Object.prototype.hasOwnProperty;
            function baseKeys1(object1) {
                if (!isPrototype1(object1)) return nativeKeys1(object1);
                var result1 = [];
                for(var key1 in Object(object1))hasOwnProperty1.call(object1, key1) && 'constructor' != key1 && result1.push(key1);
                return result1;
            }
            module1.exports = baseKeys1;
        },
        313: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var isObject1 = __webpack_require__1(3218), isPrototype1 = __webpack_require__1(5726), nativeKeysIn1 = __webpack_require__1(3498), hasOwnProperty1 = Object.prototype.hasOwnProperty;
            function baseKeysIn1(object1) {
                if (!isObject1(object1)) return nativeKeysIn1(object1);
                var isProto1 = isPrototype1(object1), result1 = [];
                for(var key1 in object1)'constructor' == key1 && (isProto1 || !hasOwnProperty1.call(object1, key1)) || result1.push(key1);
                return result1;
            }
            module1.exports = baseKeysIn1;
        },
        2545: function(module1) {
            function baseTimes1(n2, iteratee1) {
                for(var index1 = -1, result1 = Array(n2); ++index1 < n2;)result1[index1] = iteratee1(index1);
                return result1;
            }
            module1.exports = baseTimes1;
        },
        1717: function(module1) {
            function baseUnary1(func1) {
                return function(value1) {
                    return func1(value1);
                };
            }
            module1.exports = baseUnary1;
        },
        4318: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Uint8Array1 = __webpack_require__1(1149);
            function cloneArrayBuffer1(arrayBuffer1) {
                var result1 = new arrayBuffer1.constructor(arrayBuffer1.byteLength);
                return new Uint8Array1(result1).set(new Uint8Array1(arrayBuffer1)), result1;
            }
            module1.exports = cloneArrayBuffer1;
        },
        4626: function(module1, exports1, __webpack_require__1) {
            module1 = __webpack_require__1.nmd(module1);
            var root1 = __webpack_require__1(5639), freeExports1 = exports1 && !exports1.nodeType && exports1, freeModule1 = freeExports1 && module1 && !module1.nodeType && module1, Buffer1 = freeModule1 && freeModule1.exports === freeExports1 ? root1.Buffer : void 0, allocUnsafe1 = Buffer1 ? Buffer1.allocUnsafe : void 0;
            function cloneBuffer1(buffer1, isDeep1) {
                if (isDeep1) return buffer1.slice();
                var length1 = buffer1.length, result1 = allocUnsafe1 ? allocUnsafe1(length1) : new buffer1.constructor(length1);
                return buffer1.copy(result1), result1;
            }
            module1.exports = cloneBuffer1;
        },
        7157: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var cloneArrayBuffer1 = __webpack_require__1(4318);
            function cloneDataView1(dataView1, isDeep1) {
                var buffer1 = isDeep1 ? cloneArrayBuffer1(dataView1.buffer) : dataView1.buffer;
                return new dataView1.constructor(buffer1, dataView1.byteOffset, dataView1.byteLength);
            }
            module1.exports = cloneDataView1;
        },
        3147: function(module1) {
            var reFlags1 = /\w*$/;
            function cloneRegExp1(regexp1) {
                var result1 = new regexp1.constructor(regexp1.source, reFlags1.exec(regexp1));
                return result1.lastIndex = regexp1.lastIndex, result1;
            }
            module1.exports = cloneRegExp1;
        },
        419: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Symbol1 = __webpack_require__1(2705), symbolProto1 = Symbol1 ? Symbol1.prototype : void 0, symbolValueOf1 = symbolProto1 ? symbolProto1.valueOf : void 0;
            function cloneSymbol1(symbol1) {
                return symbolValueOf1 ? Object(symbolValueOf1.call(symbol1)) : {};
            }
            module1.exports = cloneSymbol1;
        },
        7133: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var cloneArrayBuffer1 = __webpack_require__1(4318);
            function cloneTypedArray1(typedArray1, isDeep1) {
                var buffer1 = isDeep1 ? cloneArrayBuffer1(typedArray1.buffer) : typedArray1.buffer;
                return new typedArray1.constructor(buffer1, typedArray1.byteOffset, typedArray1.length);
            }
            module1.exports = cloneTypedArray1;
        },
        278: function(module1) {
            function copyArray1(source1, array1) {
                var index1 = -1, length1 = source1.length;
                for(array1 || (array1 = Array(length1)); ++index1 < length1;)array1[index1] = source1[index1];
                return array1;
            }
            module1.exports = copyArray1;
        },
        8363: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var assignValue1 = __webpack_require__1(4865), baseAssignValue1 = __webpack_require__1(9465);
            function copyObject1(source1, props1, object1, customizer1) {
                var isNew1 = !object1;
                object1 || (object1 = {});
                for(var index1 = -1, length1 = props1.length; ++index1 < length1;){
                    var key1 = props1[index1], newValue1 = customizer1 ? customizer1(object1[key1], source1[key1], key1, object1, source1) : void 0;
                    void 0 === newValue1 && (newValue1 = source1[key1]), isNew1 ? baseAssignValue1(object1, key1, newValue1) : assignValue1(object1, key1, newValue1);
                }
                return object1;
            }
            module1.exports = copyObject1;
        },
        8805: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var copyObject1 = __webpack_require__1(8363), getSymbols1 = __webpack_require__1(9551);
            function copySymbols1(source1, object1) {
                return copyObject1(source1, getSymbols1(source1), object1);
            }
            module1.exports = copySymbols1;
        },
        1911: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var copyObject1 = __webpack_require__1(8363), getSymbolsIn1 = __webpack_require__1(1442);
            function copySymbolsIn1(source1, object1) {
                return copyObject1(source1, getSymbolsIn1(source1), object1);
            }
            module1.exports = copySymbolsIn1;
        },
        4429: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var coreJsData1 = __webpack_require__1(5639)['__core-js_shared__'];
            module1.exports = coreJsData1;
        },
        8777: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getNative1 = __webpack_require__1(852), defineProperty1 = function() {
                try {
                    var func1 = getNative1(Object, 'defineProperty');
                    return func1({}, '', {}), func1;
                } catch (e1) {}
            }();
            module1.exports = defineProperty1;
        },
        1957: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var freeGlobal1 = 'object' == typeof __webpack_require__1.g && __webpack_require__1.g && __webpack_require__1.g.Object === Object && __webpack_require__1.g;
            module1.exports = freeGlobal1;
        },
        8234: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseGetAllKeys1 = __webpack_require__1(8866), getSymbols1 = __webpack_require__1(9551), keys1 = __webpack_require__1(3674);
            function getAllKeys1(object1) {
                return baseGetAllKeys1(object1, keys1, getSymbols1);
            }
            module1.exports = getAllKeys1;
        },
        6904: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseGetAllKeys1 = __webpack_require__1(8866), getSymbolsIn1 = __webpack_require__1(1442), keysIn1 = __webpack_require__1(1704);
            function getAllKeysIn1(object1) {
                return baseGetAllKeys1(object1, keysIn1, getSymbolsIn1);
            }
            module1.exports = getAllKeysIn1;
        },
        5050: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var isKeyable1 = __webpack_require__1(7019);
            function getMapData1(map1, key1) {
                var data1 = map1.__data__;
                return isKeyable1(key1) ? data1['string' == typeof key1 ? 'string' : 'hash'] : data1.map;
            }
            module1.exports = getMapData1;
        },
        852: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseIsNative1 = __webpack_require__1(8458), getValue1 = __webpack_require__1(7801);
            function getNative1(object1, key1) {
                var value1 = getValue1(object1, key1);
                return baseIsNative1(value1) ? value1 : void 0;
            }
            module1.exports = getNative1;
        },
        5924: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getPrototype1 = __webpack_require__1(5569)(Object.getPrototypeOf, Object);
            module1.exports = getPrototype1;
        },
        9607: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Symbol1 = __webpack_require__1(2705), objectProto1 = Object.prototype, hasOwnProperty1 = objectProto1.hasOwnProperty, nativeObjectToString1 = objectProto1.toString, symToStringTag1 = Symbol1 ? Symbol1.toStringTag : void 0;
            function getRawTag1(value1) {
                var isOwn1 = hasOwnProperty1.call(value1, symToStringTag1), tag1 = value1[symToStringTag1];
                try {
                    value1[symToStringTag1] = void 0;
                    var unmasked1 = !0;
                } catch (e1) {}
                var result1 = nativeObjectToString1.call(value1);
                return unmasked1 && (isOwn1 ? value1[symToStringTag1] = tag1 : delete value1[symToStringTag1]), result1;
            }
            module1.exports = getRawTag1;
        },
        9551: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var arrayFilter1 = __webpack_require__1(4963), stubArray1 = __webpack_require__1(479), propertyIsEnumerable1 = Object.prototype.propertyIsEnumerable, nativeGetSymbols1 = Object.getOwnPropertySymbols, getSymbols1 = nativeGetSymbols1 ? function(object1) {
                return null == object1 ? [] : arrayFilter1(nativeGetSymbols1(object1 = Object(object1)), function(symbol1) {
                    return propertyIsEnumerable1.call(object1, symbol1);
                });
            } : stubArray1;
            module1.exports = getSymbols1;
        },
        1442: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var arrayPush1 = __webpack_require__1(2488), getPrototype1 = __webpack_require__1(5924), getSymbols1 = __webpack_require__1(9551), stubArray1 = __webpack_require__1(479), getSymbolsIn1 = Object.getOwnPropertySymbols ? function(object1) {
                for(var result1 = []; object1;)arrayPush1(result1, getSymbols1(object1)), object1 = getPrototype1(object1);
                return result1;
            } : stubArray1;
            module1.exports = getSymbolsIn1;
        },
        4160: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var DataView1 = __webpack_require__1(8552), Map1 = __webpack_require__1(7071), Promise1 = __webpack_require__1(3818), Set1 = __webpack_require__1(8525), WeakMap1 = __webpack_require__1(577), baseGetTag1 = __webpack_require__1(4239), toSource1 = __webpack_require__1(346), mapTag1 = '[object Map]', objectTag1 = '[object Object]', promiseTag1 = '[object Promise]', setTag1 = '[object Set]', weakMapTag1 = '[object WeakMap]', dataViewTag1 = '[object DataView]', dataViewCtorString1 = toSource1(DataView1), mapCtorString1 = toSource1(Map1), promiseCtorString1 = toSource1(Promise1), setCtorString1 = toSource1(Set1), weakMapCtorString1 = toSource1(WeakMap1), getTag1 = baseGetTag1;
            (DataView1 && getTag1(new DataView1(new ArrayBuffer(1))) != dataViewTag1 || Map1 && getTag1(new Map1) != mapTag1 || Promise1 && getTag1(Promise1.resolve()) != promiseTag1 || Set1 && getTag1(new Set1) != setTag1 || WeakMap1 && getTag1(new WeakMap1) != weakMapTag1) && (getTag1 = function(value1) {
                var result1 = baseGetTag1(value1), Ctor1 = result1 == objectTag1 ? value1.constructor : void 0, ctorString1 = Ctor1 ? toSource1(Ctor1) : '';
                if (ctorString1) switch(ctorString1){
                    case dataViewCtorString1:
                        return dataViewTag1;
                    case mapCtorString1:
                        return mapTag1;
                    case promiseCtorString1:
                        return promiseTag1;
                    case setCtorString1:
                        return setTag1;
                    case weakMapCtorString1:
                        return weakMapTag1;
                }
                return result1;
            }), module1.exports = getTag1;
        },
        7801: function(module1) {
            function getValue1(object1, key1) {
                return null == object1 ? void 0 : object1[key1];
            }
            module1.exports = getValue1;
        },
        1789: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var nativeCreate1 = __webpack_require__1(4536);
            function hashClear1() {
                this.__data__ = nativeCreate1 ? nativeCreate1(null) : {}, this.size = 0;
            }
            module1.exports = hashClear1;
        },
        401: function(module1) {
            function hashDelete1(key1) {
                var result1 = this.has(key1) && delete this.__data__[key1];
                return this.size -= result1 ? 1 : 0, result1;
            }
            module1.exports = hashDelete1;
        },
        7667: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var nativeCreate1 = __webpack_require__1(4536), HASH_UNDEFINED1 = '__lodash_hash_undefined__', hasOwnProperty1 = Object.prototype.hasOwnProperty;
            function hashGet1(key1) {
                var data1 = this.__data__;
                if (nativeCreate1) {
                    var result1 = data1[key1];
                    return result1 === HASH_UNDEFINED1 ? void 0 : result1;
                }
                return hasOwnProperty1.call(data1, key1) ? data1[key1] : void 0;
            }
            module1.exports = hashGet1;
        },
        1327: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var nativeCreate1 = __webpack_require__1(4536), hasOwnProperty1 = Object.prototype.hasOwnProperty;
            function hashHas1(key1) {
                var data1 = this.__data__;
                return nativeCreate1 ? void 0 !== data1[key1] : hasOwnProperty1.call(data1, key1);
            }
            module1.exports = hashHas1;
        },
        1866: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var nativeCreate1 = __webpack_require__1(4536), HASH_UNDEFINED1 = '__lodash_hash_undefined__';
            function hashSet1(key1, value1) {
                var data1 = this.__data__;
                return this.size += this.has(key1) ? 0 : 1, data1[key1] = nativeCreate1 && void 0 === value1 ? HASH_UNDEFINED1 : value1, this;
            }
            module1.exports = hashSet1;
        },
        3824: function(module1) {
            var hasOwnProperty1 = Object.prototype.hasOwnProperty;
            function initCloneArray1(array1) {
                var length1 = array1.length, result1 = new array1.constructor(length1);
                return length1 && 'string' == typeof array1[0] && hasOwnProperty1.call(array1, 'index') && (result1.index = array1.index, result1.input = array1.input), result1;
            }
            module1.exports = initCloneArray1;
        },
        9148: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var cloneArrayBuffer1 = __webpack_require__1(4318), cloneDataView1 = __webpack_require__1(7157), cloneRegExp1 = __webpack_require__1(3147), cloneSymbol1 = __webpack_require__1(419), cloneTypedArray1 = __webpack_require__1(7133), boolTag1 = '[object Boolean]', dateTag1 = '[object Date]', mapTag1 = '[object Map]', numberTag1 = '[object Number]', regexpTag1 = '[object RegExp]', setTag1 = '[object Set]', stringTag1 = '[object String]', symbolTag1 = '[object Symbol]', arrayBufferTag1 = '[object ArrayBuffer]', dataViewTag1 = '[object DataView]', float32Tag1 = '[object Float32Array]', float64Tag1 = '[object Float64Array]', int8Tag1 = '[object Int8Array]', int16Tag1 = '[object Int16Array]', int32Tag1 = '[object Int32Array]', uint8Tag1 = '[object Uint8Array]', uint8ClampedTag1 = '[object Uint8ClampedArray]', uint16Tag1 = '[object Uint16Array]', uint32Tag1 = '[object Uint32Array]';
            function initCloneByTag1(object1, tag1, isDeep1) {
                var Ctor1 = object1.constructor;
                switch(tag1){
                    case arrayBufferTag1:
                        return cloneArrayBuffer1(object1);
                    case boolTag1:
                    case dateTag1:
                        return new Ctor1(+object1);
                    case dataViewTag1:
                        return cloneDataView1(object1, isDeep1);
                    case float32Tag1:
                    case float64Tag1:
                    case int8Tag1:
                    case int16Tag1:
                    case int32Tag1:
                    case uint8Tag1:
                    case uint8ClampedTag1:
                    case uint16Tag1:
                    case uint32Tag1:
                        return cloneTypedArray1(object1, isDeep1);
                    case mapTag1:
                        return new Ctor1;
                    case numberTag1:
                    case stringTag1:
                        return new Ctor1(object1);
                    case regexpTag1:
                        return cloneRegExp1(object1);
                    case setTag1:
                        return new Ctor1;
                    case symbolTag1:
                        return cloneSymbol1(object1);
                }
            }
            module1.exports = initCloneByTag1;
        },
        8517: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseCreate1 = __webpack_require__1(3118), getPrototype1 = __webpack_require__1(5924), isPrototype1 = __webpack_require__1(5726);
            function initCloneObject1(object1) {
                return 'function' != typeof object1.constructor || isPrototype1(object1) ? {} : baseCreate1(getPrototype1(object1));
            }
            module1.exports = initCloneObject1;
        },
        213: function(module1) {
            var MAX_SAFE_INTEGER1 = 9007199254740991, reIsUint1 = /^(?:0|[1-9]\d*)$/;
            function isIndex1(value1, length1) {
                var type1 = typeof value1;
                return !!(length1 = null == length1 ? MAX_SAFE_INTEGER1 : length1) && ('number' == type1 || 'symbol' != type1 && reIsUint1.test(value1)) && value1 > -1 && value1 % 1 == 0 && value1 < length1;
            }
            module1.exports = isIndex1;
        },
        7019: function(module1) {
            function isKeyable1(value1) {
                var type1 = typeof value1;
                return 'string' == type1 || 'number' == type1 || 'symbol' == type1 || 'boolean' == type1 ? '__proto__' !== value1 : null === value1;
            }
            module1.exports = isKeyable1;
        },
        5346: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var coreJsData1 = __webpack_require__1(4429), maskSrcKey1 = function() {
                var uid1 = /[^.]+$/.exec(coreJsData1 && coreJsData1.keys && coreJsData1.keys.IE_PROTO || '');
                return uid1 ? 'Symbol(src)_1.' + uid1 : '';
            }();
            function isMasked1(func1) {
                return !!maskSrcKey1 && maskSrcKey1 in func1;
            }
            module1.exports = isMasked1;
        },
        5726: function(module1) {
            var objectProto1 = Object.prototype;
            function isPrototype1(value1) {
                var Ctor1 = value1 && value1.constructor, proto1 = 'function' == typeof Ctor1 && Ctor1.prototype || objectProto1;
                return value1 === proto1;
            }
            module1.exports = isPrototype1;
        },
        7040: function(module1) {
            function listCacheClear1() {
                this.__data__ = [], this.size = 0;
            }
            module1.exports = listCacheClear1;
        },
        4125: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var assocIndexOf1 = __webpack_require__1(8470), splice1 = Array.prototype.splice;
            function listCacheDelete1(key1) {
                var data1 = this.__data__, index1 = assocIndexOf1(data1, key1);
                return !(index1 < 0) && (index1 == data1.length - 1 ? data1.pop() : splice1.call(data1, index1, 1), --this.size, !0);
            }
            module1.exports = listCacheDelete1;
        },
        2117: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var assocIndexOf1 = __webpack_require__1(8470);
            function listCacheGet1(key1) {
                var data1 = this.__data__, index1 = assocIndexOf1(data1, key1);
                return index1 < 0 ? void 0 : data1[index1][1];
            }
            module1.exports = listCacheGet1;
        },
        7518: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var assocIndexOf1 = __webpack_require__1(8470);
            function listCacheHas1(key1) {
                return assocIndexOf1(this.__data__, key1) > -1;
            }
            module1.exports = listCacheHas1;
        },
        4705: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var assocIndexOf1 = __webpack_require__1(8470);
            function listCacheSet1(key1, value1) {
                var data1 = this.__data__, index1 = assocIndexOf1(data1, key1);
                return index1 < 0 ? (++this.size, data1.push([
                    key1,
                    value1
                ])) : data1[index1][1] = value1, this;
            }
            module1.exports = listCacheSet1;
        },
        4785: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Hash1 = __webpack_require__1(1989), ListCache1 = __webpack_require__1(8407), Map1 = __webpack_require__1(7071);
            function mapCacheClear1() {
                this.size = 0, this.__data__ = {
                    hash: new Hash1,
                    map: new (Map1 || ListCache1),
                    string: new Hash1
                };
            }
            module1.exports = mapCacheClear1;
        },
        1285: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getMapData1 = __webpack_require__1(5050);
            function mapCacheDelete1(key1) {
                var result1 = getMapData1(this, key1).delete(key1);
                return this.size -= result1 ? 1 : 0, result1;
            }
            module1.exports = mapCacheDelete1;
        },
        6000: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getMapData1 = __webpack_require__1(5050);
            function mapCacheGet1(key1) {
                return getMapData1(this, key1).get(key1);
            }
            module1.exports = mapCacheGet1;
        },
        9916: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getMapData1 = __webpack_require__1(5050);
            function mapCacheHas1(key1) {
                return getMapData1(this, key1).has(key1);
            }
            module1.exports = mapCacheHas1;
        },
        5265: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var getMapData1 = __webpack_require__1(5050);
            function mapCacheSet1(key1, value1) {
                var data1 = getMapData1(this, key1), size1 = data1.size;
                return data1.set(key1, value1), this.size += data1.size == size1 ? 0 : 1, this;
            }
            module1.exports = mapCacheSet1;
        },
        4536: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var nativeCreate1 = __webpack_require__1(852)(Object, 'create');
            module1.exports = nativeCreate1;
        },
        6916: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var nativeKeys1 = __webpack_require__1(5569)(Object.keys, Object);
            module1.exports = nativeKeys1;
        },
        3498: function(module1) {
            function nativeKeysIn1(object1) {
                var result1 = [];
                if (null != object1) for(var key1 in Object(object1))result1.push(key1);
                return result1;
            }
            module1.exports = nativeKeysIn1;
        },
        1167: function(module1, exports1, __webpack_require__1) {
            module1 = __webpack_require__1.nmd(module1);
            var freeGlobal1 = __webpack_require__1(1957), freeExports1 = exports1 && !exports1.nodeType && exports1, freeModule1 = freeExports1 && module1 && !module1.nodeType && module1, freeProcess1 = freeModule1 && freeModule1.exports === freeExports1 && freeGlobal1.process, nodeUtil1 = function() {
                try {
                    var types1 = freeModule1 && freeModule1.require && freeModule1.require('util').types;
                    if (types1) return types1;
                    return freeProcess1 && freeProcess1.binding && freeProcess1.binding('util');
                } catch (e1) {}
            }();
            module1.exports = nodeUtil1;
        },
        2333: function(module1) {
            var nativeObjectToString1 = Object.prototype.toString;
            function objectToString1(value1) {
                return nativeObjectToString1.call(value1);
            }
            module1.exports = objectToString1;
        },
        5569: function(module1) {
            function overArg1(func1, transform1) {
                return function(arg4) {
                    return func1(transform1(arg4));
                };
            }
            module1.exports = overArg1;
        },
        5639: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var freeGlobal1 = __webpack_require__1(1957), freeSelf1 = 'object' == typeof self && self && self.Object === Object && self, root1 = freeGlobal1 || freeSelf1 || Function('return this')();
            module1.exports = root1;
        },
        7465: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var ListCache1 = __webpack_require__1(8407);
            function stackClear1() {
                this.__data__ = new ListCache1, this.size = 0;
            }
            module1.exports = stackClear1;
        },
        3779: function(module1) {
            function stackDelete1(key1) {
                var data1 = this.__data__, result1 = data1.delete(key1);
                return this.size = data1.size, result1;
            }
            module1.exports = stackDelete1;
        },
        7599: function(module1) {
            function stackGet1(key1) {
                return this.__data__.get(key1);
            }
            module1.exports = stackGet1;
        },
        4758: function(module1) {
            function stackHas1(key1) {
                return this.__data__.has(key1);
            }
            module1.exports = stackHas1;
        },
        4309: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var ListCache1 = __webpack_require__1(8407), Map1 = __webpack_require__1(7071), MapCache1 = __webpack_require__1(3369), LARGE_ARRAY_SIZE1 = 200;
            function stackSet1(key1, value1) {
                var data1 = this.__data__;
                if (data1 instanceof ListCache1) {
                    var pairs1 = data1.__data__;
                    if (!Map1 || pairs1.length < LARGE_ARRAY_SIZE1 - 1) return pairs1.push([
                        key1,
                        value1
                    ]), this.size = ++data1.size, this;
                    data1 = this.__data__ = new MapCache1(pairs1);
                }
                return data1.set(key1, value1), this.size = data1.size, this;
            }
            module1.exports = stackSet1;
        },
        346: function(module1) {
            var funcToString1 = Function.prototype.toString;
            function toSource1(func1) {
                if (null != func1) {
                    try {
                        return funcToString1.call(func1);
                    } catch (e1) {}
                    try {
                        return func1 + '';
                    } catch (e1) {}
                }
                return '';
            }
            module1.exports = toSource1;
        },
        361: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseClone1 = __webpack_require__1(5990), CLONE_DEEP_FLAG1 = 1, CLONE_SYMBOLS_FLAG1 = 4;
            function cloneDeep1(value1) {
                return baseClone1(value1, CLONE_DEEP_FLAG1 | CLONE_SYMBOLS_FLAG1);
            }
            module1.exports = cloneDeep1;
        },
        7813: function(module1) {
            function eq1(value1, other1) {
                return value1 === other1 || value1 != value1 && other1 != other1;
            }
            module1.exports = eq1;
        },
        5694: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseIsArguments1 = __webpack_require__1(9454), isObjectLike1 = __webpack_require__1(7005), objectProto1 = Object.prototype, hasOwnProperty1 = objectProto1.hasOwnProperty, propertyIsEnumerable1 = objectProto1.propertyIsEnumerable, isArguments1 = baseIsArguments1(function() {
                return arguments;
            }()) ? baseIsArguments1 : function(value1) {
                return isObjectLike1(value1) && hasOwnProperty1.call(value1, 'callee') && !propertyIsEnumerable1.call(value1, 'callee');
            };
            module1.exports = isArguments1;
        },
        1469: function(module1) {
            var isArray1 = Array.isArray;
            module1.exports = isArray1;
        },
        1240: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var isFunction1 = __webpack_require__1(3560), isLength1 = __webpack_require__1(1780);
            function isArrayLike1(value1) {
                return null != value1 && isLength1(value1.length) && !isFunction1(value1);
            }
            module1.exports = isArrayLike1;
        },
        4144: function(module1, exports1, __webpack_require__1) {
            module1 = __webpack_require__1.nmd(module1);
            var root1 = __webpack_require__1(5639), stubFalse1 = __webpack_require__1(5062), freeExports1 = exports1 && !exports1.nodeType && exports1, freeModule1 = freeExports1 && module1 && !module1.nodeType && module1, Buffer1 = freeModule1 && freeModule1.exports === freeExports1 ? root1.Buffer : void 0, isBuffer1 = (Buffer1 ? Buffer1.isBuffer : void 0) || stubFalse1;
            module1.exports = isBuffer1;
        },
        3560: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseGetTag1 = __webpack_require__1(4239), isObject1 = __webpack_require__1(3218), asyncTag1 = '[object AsyncFunction]', funcTag1 = '[object Function]', genTag1 = '[object GeneratorFunction]', proxyTag1 = '[object Proxy]';
            function isFunction1(value1) {
                if (!isObject1(value1)) return !1;
                var tag1 = baseGetTag1(value1);
                return tag1 == funcTag1 || tag1 == genTag1 || tag1 == asyncTag1 || tag1 == proxyTag1;
            }
            module1.exports = isFunction1;
        },
        1780: function(module1) {
            var MAX_SAFE_INTEGER1 = 9007199254740991;
            function isLength1(value1) {
                return 'number' == typeof value1 && value1 > -1 && value1 % 1 == 0 && value1 <= MAX_SAFE_INTEGER1;
            }
            module1.exports = isLength1;
        },
        6688: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseIsMap1 = __webpack_require__1(5588), baseUnary1 = __webpack_require__1(1717), nodeUtil1 = __webpack_require__1(1167), nodeIsMap1 = nodeUtil1 && nodeUtil1.isMap, isMap1 = nodeIsMap1 ? baseUnary1(nodeIsMap1) : baseIsMap1;
            module1.exports = isMap1;
        },
        3218: function(module1) {
            function isObject1(value1) {
                var type1 = typeof value1;
                return null != value1 && ('object' == type1 || 'function' == type1);
            }
            module1.exports = isObject1;
        },
        7005: function(module1) {
            function isObjectLike1(value1) {
                return null != value1 && 'object' == typeof value1;
            }
            module1.exports = isObjectLike1;
        },
        2928: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseIsSet1 = __webpack_require__1(9221), baseUnary1 = __webpack_require__1(1717), nodeUtil1 = __webpack_require__1(1167), nodeIsSet1 = nodeUtil1 && nodeUtil1.isSet, isSet1 = nodeIsSet1 ? baseUnary1(nodeIsSet1) : baseIsSet1;
            module1.exports = isSet1;
        },
        6719: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var baseIsTypedArray1 = __webpack_require__1(8749), baseUnary1 = __webpack_require__1(1717), nodeUtil1 = __webpack_require__1(1167), nodeIsTypedArray1 = nodeUtil1 && nodeUtil1.isTypedArray, isTypedArray1 = nodeIsTypedArray1 ? baseUnary1(nodeIsTypedArray1) : baseIsTypedArray1;
            module1.exports = isTypedArray1;
        },
        3674: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var arrayLikeKeys1 = __webpack_require__1(4636), baseKeys1 = __webpack_require__1(280), isArrayLike1 = __webpack_require__1(1240);
            function keys1(object1) {
                return isArrayLike1(object1) ? arrayLikeKeys1(object1) : baseKeys1(object1);
            }
            module1.exports = keys1;
        },
        1704: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var arrayLikeKeys1 = __webpack_require__1(4636), baseKeysIn1 = __webpack_require__1(313), isArrayLike1 = __webpack_require__1(1240);
            function keysIn1(object1) {
                return isArrayLike1(object1) ? arrayLikeKeys1(object1, !0) : baseKeysIn1(object1);
            }
            module1.exports = keysIn1;
        },
        479: function(module1) {
            function stubArray1() {
                return [];
            }
            module1.exports = stubArray1;
        },
        5062: function(module1) {
            function stubFalse1() {
                return !1;
            }
            module1.exports = stubFalse1;
        },
        1271: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            __webpack_require__1(3454);
            const { AbstractLevel: AbstractLevel1 , AbstractIterator: AbstractIterator1 , AbstractKeyIterator: AbstractKeyIterator1 , AbstractValueIterator: AbstractValueIterator1  } = __webpack_require__1(875), ModuleError1 = __webpack_require__1(4473), createRBT1 = __webpack_require__1(4977), rangeOptions1 = new Set([
                'gt',
                'gte',
                'lt',
                'lte'
            ]), kNone1 = Symbol('none'), kTree1 = Symbol('tree'), kIterator1 = Symbol('iterator'), kLowerBound1 = Symbol('lowerBound'), kUpperBound1 = Symbol('upperBound'), kOutOfRange1 = Symbol('outOfRange'), kReverse1 = Symbol('reverse'), kOptions1 = Symbol('options'), kTest1 = Symbol('test'), kAdvance1 = Symbol('advance'), kInit1 = Symbol('init');
            function compare1(a10, b10) {
                if ('string' == typeof a10) return a10 < b10 ? -1 : a10 > b10 ? 1 : 0;
                const length1 = Math.min(a10.byteLength, b10.byteLength);
                for(let i2 = 0; i2 < length1; i2++){
                    const cmp1 = a10[i2] - b10[i2];
                    if (0 !== cmp1) return cmp1;
                }
                return a10.byteLength - b10.byteLength;
            }
            function gt1(value1) {
                return compare1(value1, this[kUpperBound1]) > 0;
            }
            function gte1(value1) {
                return compare1(value1, this[kUpperBound1]) >= 0;
            }
            function lt1(value1) {
                return 0 > compare1(value1, this[kUpperBound1]);
            }
            function lte1(value1) {
                return 0 >= compare1(value1, this[kUpperBound1]);
            }
            class MemoryIterator1 extends AbstractIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kInit1](db1[kTree1], options1);
                }
                _next(callback1) {
                    if (!this[kIterator1].valid) return this.nextTick(callback1);
                    const key1 = this[kIterator1].key, value1 = this[kIterator1].value;
                    if (!this[kTest1](key1)) return this.nextTick(callback1);
                    this[kIterator1][this[kAdvance1]](), this.nextTick(callback1, null, key1, value1);
                }
                _nextv(size1, options1, callback1) {
                    const it1 = this[kIterator1], entries1 = [];
                    for(; it1.valid && entries1.length < size1 && this[kTest1](it1.key);)entries1.push([
                        it1.key,
                        it1.value
                    ]), it1[this[kAdvance1]]();
                    this.nextTick(callback1, null, entries1);
                }
                _all(options1, callback1) {
                    const size1 = this.limit - this.count, it1 = this[kIterator1], entries1 = [];
                    for(; it1.valid && entries1.length < size1 && this[kTest1](it1.key);)entries1.push([
                        it1.key,
                        it1.value
                    ]), it1[this[kAdvance1]]();
                    this.nextTick(callback1, null, entries1);
                }
            }
            class MemoryKeyIterator1 extends AbstractKeyIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kInit1](db1[kTree1], options1);
                }
                _next(callback1) {
                    if (!this[kIterator1].valid) return this.nextTick(callback1);
                    const key1 = this[kIterator1].key;
                    if (!this[kTest1](key1)) return this.nextTick(callback1);
                    this[kIterator1][this[kAdvance1]](), this.nextTick(callback1, null, key1);
                }
                _nextv(size1, options1, callback1) {
                    const it1 = this[kIterator1], keys1 = [];
                    for(; it1.valid && keys1.length < size1 && this[kTest1](it1.key);)keys1.push(it1.key), it1[this[kAdvance1]]();
                    this.nextTick(callback1, null, keys1);
                }
                _all(options1, callback1) {
                    const size1 = this.limit - this.count, it1 = this[kIterator1], keys1 = [];
                    for(; it1.valid && keys1.length < size1 && this[kTest1](it1.key);)keys1.push(it1.key), it1[this[kAdvance1]]();
                    this.nextTick(callback1, null, keys1);
                }
            }
            class MemoryValueIterator1 extends AbstractValueIterator1 {
                constructor(db1, options1){
                    super(db1, options1), this[kInit1](db1[kTree1], options1);
                }
                _next(callback1) {
                    if (!this[kIterator1].valid) return this.nextTick(callback1);
                    const key1 = this[kIterator1].key, value1 = this[kIterator1].value;
                    if (!this[kTest1](key1)) return this.nextTick(callback1);
                    this[kIterator1][this[kAdvance1]](), this.nextTick(callback1, null, value1);
                }
                _nextv(size1, options1, callback1) {
                    const it1 = this[kIterator1], values1 = [];
                    for(; it1.valid && values1.length < size1 && this[kTest1](it1.key);)values1.push(it1.value), it1[this[kAdvance1]]();
                    this.nextTick(callback1, null, values1);
                }
                _all(options1, callback1) {
                    const size1 = this.limit - this.count, it1 = this[kIterator1], values1 = [];
                    for(; it1.valid && values1.length < size1 && this[kTest1](it1.key);)values1.push(it1.value), it1[this[kAdvance1]]();
                    this.nextTick(callback1, null, values1);
                }
            }
            for (const Ctor1 of [
                MemoryIterator1,
                MemoryKeyIterator1,
                MemoryValueIterator1
            ])Ctor1.prototype[kInit1] = function(tree1, options1) {
                this[kReverse1] = options1.reverse, this[kOptions1] = options1, this[kReverse1] ? (this[kAdvance1] = 'prev', this[kLowerBound1] = 'lte' in options1 ? options1.lte : 'lt' in options1 ? options1.lt : kNone1, this[kUpperBound1] = 'gte' in options1 ? options1.gte : 'gt' in options1 ? options1.gt : kNone1, this[kLowerBound1] === kNone1 ? this[kIterator1] = tree1.end : 'lte' in options1 ? this[kIterator1] = tree1.le(this[kLowerBound1]) : this[kIterator1] = tree1.lt(this[kLowerBound1]), this[kUpperBound1] !== kNone1 && (this[kTest1] = 'gte' in options1 ? gte1 : gt1)) : (this[kAdvance1] = 'next', this[kLowerBound1] = 'gte' in options1 ? options1.gte : 'gt' in options1 ? options1.gt : kNone1, this[kUpperBound1] = 'lte' in options1 ? options1.lte : 'lt' in options1 ? options1.lt : kNone1, this[kLowerBound1] === kNone1 ? this[kIterator1] = tree1.begin : 'gte' in options1 ? this[kIterator1] = tree1.ge(this[kLowerBound1]) : this[kIterator1] = tree1.gt(this[kLowerBound1]), this[kUpperBound1] !== kNone1 && (this[kTest1] = 'lte' in options1 ? lte1 : lt1));
            }, Ctor1.prototype[kTest1] = function() {
                return !0;
            }, Ctor1.prototype[kOutOfRange1] = function(target1) {
                return !this[kTest1](target1) || this[kLowerBound1] !== kNone1 && (this[kReverse1] ? 'lte' in this[kOptions1] ? compare1(target1, this[kLowerBound1]) > 0 : compare1(target1, this[kLowerBound1]) >= 0 : 'gte' in this[kOptions1] ? 0 > compare1(target1, this[kLowerBound1]) : 0 >= compare1(target1, this[kLowerBound1]));
            }, Ctor1.prototype._seek = function(target1, options1) {
                this[kOutOfRange1](target1) ? (this[kIterator1] = this[kIterator1].tree.end, this[kIterator1].next()) : this[kReverse1] ? this[kIterator1] = this[kIterator1].tree.le(target1) : this[kIterator1] = this[kIterator1].tree.ge(target1);
            };
            class MemoryLevel1 extends AbstractLevel1 {
                constructor(location1, options1, _1){
                    if ('object' == typeof location1 && null !== location1 && (options1 = location1), 'function' == typeof location1 || 'function' == typeof options1 || 'function' == typeof _1) throw new ModuleError1('The levelup-style callback argument has been removed', {
                        code: 'LEVEL_LEGACY'
                    });
                    let { storeEncoding: storeEncoding1 , ...forward1 } = options1 || {};
                    if (![
                        'buffer',
                        'view',
                        'utf8'
                    ].includes(storeEncoding1 = storeEncoding1 || 'buffer')) throw new ModuleError1("The storeEncoding option must be 'buffer', 'view' or 'utf8'", {
                        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                    });
                    super({
                        seek: !0,
                        permanence: !1,
                        createIfMissing: !1,
                        errorIfExists: !1,
                        encodings: {
                            [storeEncoding1]: !0
                        }
                    }, forward1), this[kTree1] = createRBT1(compare1);
                }
                _put(key1, value1, options1, callback1) {
                    const it1 = this[kTree1].find(key1);
                    it1.valid ? this[kTree1] = it1.update(value1) : this[kTree1] = this[kTree1].insert(key1, value1), this.nextTick(callback1);
                }
                _get(key1, options1, callback1) {
                    const value1 = this[kTree1].get(key1);
                    if (void 0 === value1) return this.nextTick(callback1, Error('NotFound'));
                    this.nextTick(callback1, null, value1);
                }
                _getMany(keys1, options1, callback1) {
                    this.nextTick(callback1, null, keys1.map((key1)=>this[kTree1].get(key1)));
                }
                _del(key1, options1, callback1) {
                    this[kTree1] = this[kTree1].remove(key1), this.nextTick(callback1);
                }
                _batch(operations1, options1, callback1) {
                    let tree1 = this[kTree1];
                    for (const op1 of operations1){
                        const key1 = op1.key, it1 = tree1.find(key1);
                        tree1 = 'put' === op1.type ? it1.valid ? it1.update(op1.value) : tree1.insert(key1, op1.value) : it1.remove();
                    }
                    this[kTree1] = tree1, this.nextTick(callback1);
                }
                _clear(options1, callback1) {
                    if (-1 === options1.limit && !Object.keys(options1).some(isRangeOption1)) return this[kTree1] = createRBT1(compare1), this.nextTick(callback1);
                    const iterator1 = this._keys({
                        ...options1
                    }), limit1 = iterator1.limit;
                    let count1 = 0;
                    const loop1 = ()=>{
                        for(let i2 = 0; i2 < 500; i2++){
                            if (++count1 > limit1 || !iterator1[kIterator1].valid || !iterator1[kTest1](iterator1[kIterator1].key)) return callback1();
                            this[kTree1] = this[kTree1].remove(iterator1[kIterator1].key), iterator1[kIterator1][iterator1[kAdvance1]]();
                        }
                        this.nextTick(loop1);
                    };
                    this.nextTick(loop1);
                }
                _iterator(options1) {
                    return new MemoryIterator1(this, options1);
                }
                _keys(options1) {
                    return new MemoryKeyIterator1(this, options1);
                }
                _values(options1) {
                    return new MemoryValueIterator1(this, options1);
                }
            }
            function isRangeOption1(k3) {
                return rangeOptions1.has(k3);
            }
            exports1.MemoryLevel = MemoryLevel1;
        },
        9746: function(module1) {
            function assert1(val1, msg1) {
                if (!val1) throw Error(msg1 || 'Assertion failed');
            }
            module1.exports = assert1, assert1.equal = function(l1, r3, msg1) {
                if (l1 != r3) throw Error(msg1 || 'Assertion failed: ' + l1 + ' != ' + r3);
            };
        },
        4504: function(__unused_webpack_module1, exports1) {
            "use strict";
            var utils1 = exports1;
            function toArray1(msg1, enc1) {
                if (Array.isArray(msg1)) return msg1.slice();
                if (!msg1) return [];
                var res1 = [];
                if ('string' != typeof msg1) {
                    for(var i2 = 0; i2 < msg1.length; i2++)res1[i2] = 0 | msg1[i2];
                    return res1;
                }
                if ('hex' === enc1) {
                    (msg1 = msg1.replace(/[^a-z0-9]+/ig, '')).length % 2 != 0 && (msg1 = '0' + msg1);
                    for(var i2 = 0; i2 < msg1.length; i2 += 2)res1.push(parseInt(msg1[i2] + msg1[i2 + 1], 16));
                } else for(var i2 = 0; i2 < msg1.length; i2++){
                    var c5 = msg1.charCodeAt(i2), hi1 = c5 >> 8, lo1 = 0xff & c5;
                    hi1 ? res1.push(hi1, lo1) : res1.push(lo1);
                }
                return res1;
            }
            function zero21(word1) {
                return 1 === word1.length ? '0' + word1 : word1;
            }
            function toHex1(msg1) {
                for(var res1 = '', i2 = 0; i2 < msg1.length; i2++)res1 += zero21(msg1[i2].toString(16));
                return res1;
            }
            utils1.toArray = toArray1, utils1.zero2 = zero21, utils1.toHex = toHex1, utils1.encode = function(arr1, enc1) {
                return 'hex' === enc1 ? toHex1(arr1) : arr1;
            };
        },
        4473: function(module1) {
            "use strict";
            module1.exports = class extends Error {
                constructor(message1, options1){
                    super(message1 || ''), 'object' == typeof options1 && null !== options1 && (options1.code && (this.code = String(options1.code)), options1.expected && (this.expected = !0), options1.transient && (this.transient = !0), options1.cause && (this.cause = options1.cause)), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
                }
            };
        },
        3454: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var ref2, ref11;
            module1.exports = (null == (ref2 = __webpack_require__1.g.process) ? void 0 : ref2.env) && "object" == typeof (null == (ref11 = __webpack_require__1.g.process) ? void 0 : ref11.env) ? __webpack_require__1.g.process : __webpack_require__1(7663);
        },
        7663: function(module1) {
            var __dirname1 = "/";
            !function() {
                var e1 = {
                    308: function(e1) {
                        var r3, n2, u3, t3 = e1.exports = {};
                        function defaultSetTimout1() {
                            throw Error("setTimeout has not been defined");
                        }
                        function defaultClearTimeout1() {
                            throw Error("clearTimeout has not been defined");
                        }
                        function runTimeout1(e1) {
                            if (r3 === setTimeout) return setTimeout(e1, 0);
                            if ((r3 === defaultSetTimout1 || !r3) && setTimeout) return r3 = setTimeout, setTimeout(e1, 0);
                            try {
                                return r3(e1, 0);
                            } catch (t3) {
                                try {
                                    return r3.call(null, e1, 0);
                                } catch (t3) {
                                    return r3.call(this, e1, 0);
                                }
                            }
                        }
                        function runClearTimeout1(e1) {
                            if (n2 === clearTimeout) return clearTimeout(e1);
                            if ((n2 === defaultClearTimeout1 || !n2) && clearTimeout) return n2 = clearTimeout, clearTimeout(e1);
                            try {
                                return n2(e1);
                            } catch (t3) {
                                try {
                                    return n2.call(null, e1);
                                } catch (t3) {
                                    return n2.call(this, e1);
                                }
                            }
                        }
                        !function() {
                            try {
                                r3 = "function" == typeof setTimeout ? setTimeout : defaultSetTimout1;
                            } catch (e1) {
                                r3 = defaultSetTimout1;
                            }
                            try {
                                n2 = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout1;
                            } catch (e1) {
                                n2 = defaultClearTimeout1;
                            }
                        }();
                        var i2 = [], o1 = !1, a10 = -1;
                        function cleanUpNextTick1() {
                            o1 && u3 && (o1 = !1, u3.length ? i2 = u3.concat(i2) : a10 = -1, i2.length && drainQueue1());
                        }
                        function drainQueue1() {
                            if (!o1) {
                                var e1 = runTimeout1(cleanUpNextTick1);
                                o1 = !0;
                                for(var t3 = i2.length; t3;){
                                    for(u3 = i2, i2 = []; ++a10 < t3;)u3 && u3[a10].run();
                                    a10 = -1, t3 = i2.length;
                                }
                                u3 = null, o1 = !1, runClearTimeout1(e1);
                            }
                        }
                        function Item1(e1, t3) {
                            this.fun = e1, this.array = t3;
                        }
                        function noop1() {}
                        t3.nextTick = function(e1) {
                            var t3 = Array(arguments.length - 1);
                            if (arguments.length > 1) for(var r3 = 1; r3 < arguments.length; r3++)t3[r3 - 1] = arguments[r3];
                            i2.push(new Item1(e1, t3)), 1 !== i2.length || o1 || runTimeout1(drainQueue1);
                        }, Item1.prototype.run = function() {
                            this.fun.apply(null, this.array);
                        }, t3.title = "browser", t3.browser = !0, t3.env = {}, t3.argv = [], t3.version = "", t3.versions = {}, t3.on = noop1, t3.addListener = noop1, t3.once = noop1, t3.off = noop1, t3.removeListener = noop1, t3.removeAllListeners = noop1, t3.emit = noop1, t3.prependListener = noop1, t3.prependOnceListener = noop1, t3.listeners = function(e1) {
                            return [];
                        }, t3.binding = function(e1) {
                            throw Error("process.binding is not supported");
                        }, t3.cwd = function() {
                            return "/";
                        }, t3.chdir = function(e1) {
                            throw Error("process.chdir is not supported");
                        }, t3.umask = function() {
                            return 0;
                        };
                    }
                }, t3 = {};
                function __nccwpck_require__1(r3) {
                    var n2 = t3[r3];
                    if (void 0 !== n2) return n2.exports;
                    var i2 = t3[r3] = {
                        exports: {}
                    }, o1 = !0;
                    try {
                        e1[r3](i2, i2.exports, __nccwpck_require__1), o1 = !1;
                    } finally{
                        o1 && delete t3[r3];
                    }
                    return i2.exports;
                }
                __nccwpck_require__1.ab = __dirname1 + "/";
                var r3 = __nccwpck_require__1(308);
                module1.exports = r3;
            }();
        },
        9681: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var __dirname1 = "/", process1 = __webpack_require__1(3454);
            !function() {
                var e1 = {
                    140: function(e1) {
                        "function" == typeof Object.create ? e1.exports = function(e1, t3) {
                            t3 && (e1.super_ = t3, e1.prototype = Object.create(t3.prototype, {
                                constructor: {
                                    value: e1,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }));
                        } : e1.exports = function(e1, t3) {
                            if (t3) {
                                e1.super_ = t3;
                                var TempCtor1 = function() {};
                                TempCtor1.prototype = t3.prototype, e1.prototype = new TempCtor1, e1.prototype.constructor = e1;
                            }
                        };
                    },
                    349: function(e1) {
                        "use strict";
                        const t3 = {};
                        function createErrorType1(e1, r3, n2) {
                            function getMessage1(e1, t3, n2) {
                                return "string" == typeof r3 ? r3 : r3(e1, t3, n2);
                            }
                            n2 || (n2 = Error);
                            class NodeError1 extends n2 {
                                constructor(e1, t3, r3){
                                    super(getMessage1(e1, t3, r3));
                                }
                            }
                            NodeError1.prototype.name = n2.name, NodeError1.prototype.code = e1, t3[e1] = NodeError1;
                        }
                        function oneOf1(e1, t3) {
                            if (!Array.isArray(e1)) return `of ${t3} ${String(e1)}`;
                            {
                                const r3 = e1.length;
                                return (e1 = e1.map((e1)=>String(e1)), r3 > 2) ? `one of ${t3} ${e1.slice(0, r3 - 1).join(", ")}, or ` + e1[r3 - 1] : 2 === r3 ? `one of ${t3} ${e1[0]} or ${e1[1]}` : `of ${t3} ${e1[0]}`;
                            }
                        }
                        function startsWith1(e1, t3, r3) {
                            return e1.substr(!r3 || r3 < 0 ? 0 : +r3, t3.length) === t3;
                        }
                        function endsWith1(e1, t3, r3) {
                            return (void 0 === r3 || r3 > e1.length) && (r3 = e1.length), e1.substring(r3 - t3.length, r3) === t3;
                        }
                        function includes1(e1, t3, r3) {
                            return "number" != typeof r3 && (r3 = 0), !(r3 + t3.length > e1.length) && -1 !== e1.indexOf(t3, r3);
                        }
                        createErrorType1("ERR_INVALID_OPT_VALUE", function(e1, t3) {
                            return 'The value "' + t3 + '" is invalid for option "' + e1 + '"';
                        }, TypeError), createErrorType1("ERR_INVALID_ARG_TYPE", function(e1, t3, r3) {
                            let n2, i2;
                            if ("string" == typeof t3 && startsWith1(t3, "not ") ? (n2 = "must not be", t3 = t3.replace(/^not /, "")) : n2 = "must be", endsWith1(e1, " argument")) i2 = `The ${e1} ${n2} ${oneOf1(t3, "type")}`;
                            else {
                                const r3 = includes1(e1, ".") ? "property" : "argument";
                                i2 = `The "${e1}" ${r3} ${n2} ${oneOf1(t3, "type")}`;
                            }
                            return i2 + `. Received type ${typeof r3}`;
                        }, TypeError), createErrorType1("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), createErrorType1("ERR_METHOD_NOT_IMPLEMENTED", function(e1) {
                            return "The " + e1 + " method is not implemented";
                        }), createErrorType1("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), createErrorType1("ERR_STREAM_DESTROYED", function(e1) {
                            return "Cannot call " + e1 + " after a stream was destroyed";
                        }), createErrorType1("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), createErrorType1("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), createErrorType1("ERR_STREAM_WRITE_AFTER_END", "write after end"), createErrorType1("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), createErrorType1("ERR_UNKNOWN_ENCODING", function(e1) {
                            return "Unknown encoding: " + e1;
                        }, TypeError), createErrorType1("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e1.exports.q = t3;
                    },
                    716: function(e1, t3, r3) {
                        "use strict";
                        var n2 = Object.keys || function(e1) {
                            var t3 = [];
                            for(var r3 in e1)t3.push(r3);
                            return t3;
                        };
                        e1.exports = Duplex1;
                        var i2 = r3(787), a10 = r3(513);
                        r3(140)(Duplex1, i2);
                        for(var o1 = n2(a10.prototype), s3 = 0; s3 < o1.length; s3++){
                            var f1 = o1[s3];
                            Duplex1.prototype[f1] || (Duplex1.prototype[f1] = a10.prototype[f1]);
                        }
                        function Duplex1(e1) {
                            if (!(this instanceof Duplex1)) return new Duplex1(e1);
                            i2.call(this, e1), a10.call(this, e1), this.allowHalfOpen = !0, e1 && (!1 === e1.readable && (this.readable = !1), !1 === e1.writable && (this.writable = !1), !1 === e1.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", onend1)));
                        }
                        function onend1() {
                            this._writableState.ended || process1.nextTick(onEndNT1, this);
                        }
                        function onEndNT1(e1) {
                            e1.end();
                        }
                        Object.defineProperty(Duplex1.prototype, "writableHighWaterMark", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.highWaterMark;
                            }
                        }), Object.defineProperty(Duplex1.prototype, "writableBuffer", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState && this._writableState.getBuffer();
                            }
                        }), Object.defineProperty(Duplex1.prototype, "writableLength", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.length;
                            }
                        }), Object.defineProperty(Duplex1.prototype, "destroyed", {
                            enumerable: !1,
                            get: function() {
                                return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
                            },
                            set: function(e1) {
                                void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e1, this._writableState.destroyed = e1);
                            }
                        });
                    },
                    788: function(e1, t3, r3) {
                        "use strict";
                        e1.exports = PassThrough1;
                        var n2 = r3(551);
                        function PassThrough1(e1) {
                            if (!(this instanceof PassThrough1)) return new PassThrough1(e1);
                            n2.call(this, e1);
                        }
                        r3(140)(PassThrough1, n2), PassThrough1.prototype._transform = function(e1, t3, r3) {
                            r3(null, e1);
                        };
                    },
                    787: function(e1, t3, r3) {
                        "use strict";
                        e1.exports = Readable1, Readable1.ReadableState = ReadableState1, r3(361).EventEmitter;
                        var n2, u3, w19, m1, S1, a10 = function(e1, t3) {
                            return e1.listeners(t3).length;
                        }, o1 = r3(455), s3 = r3(300).Buffer, f1 = __webpack_require__1.g.Uint8Array || function() {};
                        function _uint8ArrayToBuffer1(e1) {
                            return s3.from(e1);
                        }
                        function _isUint8Array1(e1) {
                            return s3.isBuffer(e1) || e1 instanceof f1;
                        }
                        var l1 = r3(837);
                        u3 = l1 && l1.debuglog ? l1.debuglog("stream") : function() {};
                        var d3 = r3(41), c5 = r3(289), p3 = r3(483).getHighWaterMark, b10 = r3(349).q, g3 = b10.ERR_INVALID_ARG_TYPE, y3 = b10.ERR_STREAM_PUSH_AFTER_EOF, _1 = b10.ERR_METHOD_NOT_IMPLEMENTED, v3 = b10.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
                        r3(140)(Readable1, o1);
                        var R1 = c5.errorOrDestroy, E1 = [
                            "error",
                            "close",
                            "destroy",
                            "pause",
                            "resume"
                        ];
                        function prependListener1(e1, t3, r3) {
                            if ("function" == typeof e1.prependListener) return e1.prependListener(t3, r3);
                            e1._events && e1._events[t3] ? Array.isArray(e1._events[t3]) ? e1._events[t3].unshift(r3) : e1._events[t3] = [
                                r3,
                                e1._events[t3]
                            ] : e1.on(t3, r3);
                        }
                        function ReadableState1(e1, t3, i2) {
                            n2 = n2 || r3(716), e1 = e1 || {}, "boolean" != typeof i2 && (i2 = t3 instanceof n2), this.objectMode = !!e1.objectMode, i2 && (this.objectMode = this.objectMode || !!e1.readableObjectMode), this.highWaterMark = p3(this, e1, "readableHighWaterMark", i2), this.buffer = new d3, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e1.emitClose, this.autoDestroy = !!e1.autoDestroy, this.destroyed = !1, this.defaultEncoding = e1.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e1.encoding && (w19 || (w19 = r3(862).s), this.decoder = new w19(e1.encoding), this.encoding = e1.encoding);
                        }
                        function Readable1(e1) {
                            if (n2 = n2 || r3(716), !(this instanceof Readable1)) return new Readable1(e1);
                            var t3 = this instanceof n2;
                            this._readableState = new ReadableState1(e1, this, t3), this.readable = !0, e1 && ("function" == typeof e1.read && (this._read = e1.read), "function" == typeof e1.destroy && (this._destroy = e1.destroy)), o1.call(this);
                        }
                        function readableAddChunk1(e1, t3, r3, n2, i2) {
                            u3("readableAddChunk", t3);
                            var o1, a10 = e1._readableState;
                            if (null === t3) a10.reading = !1, onEofChunk1(e1, a10);
                            else if (i2 || (o1 = chunkInvalid1(a10, t3)), o1) R1(e1, o1);
                            else if (a10.objectMode || t3 && t3.length > 0) {
                                if ("string" == typeof t3 || a10.objectMode || Object.getPrototypeOf(t3) === s3.prototype || (t3 = _uint8ArrayToBuffer1(t3)), n2) a10.endEmitted ? R1(e1, new v3) : addChunk1(e1, a10, t3, !0);
                                else if (a10.ended) R1(e1, new y3);
                                else {
                                    if (a10.destroyed) return !1;
                                    a10.reading = !1, a10.decoder && !r3 ? (t3 = a10.decoder.write(t3), a10.objectMode || 0 !== t3.length ? addChunk1(e1, a10, t3, !1) : maybeReadMore1(e1, a10)) : addChunk1(e1, a10, t3, !1);
                                }
                            } else n2 || (a10.reading = !1, maybeReadMore1(e1, a10));
                            return !a10.ended && (a10.length < a10.highWaterMark || 0 === a10.length);
                        }
                        function addChunk1(e1, t3, r3, n2) {
                            t3.flowing && 0 === t3.length && !t3.sync ? (t3.awaitDrain = 0, e1.emit("data", r3)) : (t3.length += t3.objectMode ? 1 : r3.length, n2 ? t3.buffer.unshift(r3) : t3.buffer.push(r3), t3.needReadable && emitReadable1(e1)), maybeReadMore1(e1, t3);
                        }
                        function chunkInvalid1(e1, t3) {
                            var r3;
                            return _isUint8Array1(t3) || "string" == typeof t3 || void 0 === t3 || e1.objectMode || (r3 = new g3("chunk", [
                                "string",
                                "Buffer",
                                "Uint8Array"
                            ], t3)), r3;
                        }
                        Object.defineProperty(Readable1.prototype, "destroyed", {
                            enumerable: !1,
                            get: function() {
                                return void 0 !== this._readableState && this._readableState.destroyed;
                            },
                            set: function(e1) {
                                this._readableState && (this._readableState.destroyed = e1);
                            }
                        }), Readable1.prototype.destroy = c5.destroy, Readable1.prototype._undestroy = c5.undestroy, Readable1.prototype._destroy = function(e1, t3) {
                            t3(e1);
                        }, Readable1.prototype.push = function(e1, t3) {
                            var n2, r3 = this._readableState;
                            return r3.objectMode ? n2 = !0 : "string" == typeof e1 && ((t3 = t3 || r3.defaultEncoding) !== r3.encoding && (e1 = s3.from(e1, t3), t3 = ""), n2 = !0), readableAddChunk1(this, e1, t3, !1, n2);
                        }, Readable1.prototype.unshift = function(e1) {
                            return readableAddChunk1(this, e1, null, !0, !1);
                        }, Readable1.prototype.isPaused = function() {
                            return !1 === this._readableState.flowing;
                        }, Readable1.prototype.setEncoding = function(e1) {
                            w19 || (w19 = r3(862).s);
                            var t3 = new w19(e1);
                            this._readableState.decoder = t3, this._readableState.encoding = this._readableState.decoder.encoding;
                            for(var n2 = this._readableState.buffer.head, i2 = ""; null !== n2;)i2 += t3.write(n2.data), n2 = n2.next;
                            return this._readableState.buffer.clear(), "" !== i2 && this._readableState.buffer.push(i2), this._readableState.length = i2.length, this;
                        };
                        var T3 = 1073741824;
                        function computeNewHighWaterMark1(e1) {
                            return e1 >= T3 ? e1 = T3 : (e1--, e1 |= e1 >>> 1, e1 |= e1 >>> 2, e1 |= e1 >>> 4, e1 |= e1 >>> 8, e1 |= e1 >>> 16, e1++), e1;
                        }
                        function howMuchToRead1(e1, t3) {
                            return e1 <= 0 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e1 != e1 ? t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length : (e1 > t3.highWaterMark && (t3.highWaterMark = computeNewHighWaterMark1(e1)), e1 <= t3.length) ? e1 : t3.ended ? t3.length : (t3.needReadable = !0, 0);
                        }
                        function onEofChunk1(e1, t3) {
                            if (u3("onEofChunk"), !t3.ended) {
                                if (t3.decoder) {
                                    var r3 = t3.decoder.end();
                                    r3 && r3.length && (t3.buffer.push(r3), t3.length += t3.objectMode ? 1 : r3.length);
                                }
                                t3.ended = !0, t3.sync ? emitReadable1(e1) : (t3.needReadable = !1, t3.emittedReadable || (t3.emittedReadable = !0, emitReadable_1(e1)));
                            }
                        }
                        function emitReadable1(e1) {
                            var t3 = e1._readableState;
                            u3("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = !1, t3.emittedReadable || (u3("emitReadable", t3.flowing), t3.emittedReadable = !0, process1.nextTick(emitReadable_1, e1));
                        }
                        function emitReadable_1(e1) {
                            var t3 = e1._readableState;
                            u3("emitReadable_", t3.destroyed, t3.length, t3.ended), !t3.destroyed && (t3.length || t3.ended) && (e1.emit("readable"), t3.emittedReadable = !1), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, flow1(e1);
                        }
                        function maybeReadMore1(e1, t3) {
                            t3.readingMore || (t3.readingMore = !0, process1.nextTick(maybeReadMore_1, e1, t3));
                        }
                        function maybeReadMore_1(e1, t3) {
                            for(; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length);){
                                var r3 = t3.length;
                                if (u3("maybeReadMore read 0"), e1.read(0), r3 === t3.length) break;
                            }
                            t3.readingMore = !1;
                        }
                        function pipeOnDrain1(e1) {
                            return function() {
                                var t3 = e1._readableState;
                                u3("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && a10(e1, "data") && (t3.flowing = !0, flow1(e1));
                            };
                        }
                        function updateReadableListening1(e1) {
                            var t3 = e1._readableState;
                            t3.readableListening = e1.listenerCount("readable") > 0, t3.resumeScheduled && !t3.paused ? t3.flowing = !0 : e1.listenerCount("data") > 0 && e1.resume();
                        }
                        function nReadingNextTick1(e1) {
                            u3("readable nexttick read 0"), e1.read(0);
                        }
                        function resume1(e1, t3) {
                            t3.resumeScheduled || (t3.resumeScheduled = !0, process1.nextTick(resume_1, e1, t3));
                        }
                        function resume_1(e1, t3) {
                            u3("resume", t3.reading), t3.reading || e1.read(0), t3.resumeScheduled = !1, e1.emit("resume"), flow1(e1), t3.flowing && !t3.reading && e1.read(0);
                        }
                        function flow1(e1) {
                            var t3 = e1._readableState;
                            for(u3("flow", t3.flowing); t3.flowing && null !== e1.read(););
                        }
                        function fromList1(e1, t3) {
                            var r3;
                            return 0 === t3.length ? null : (t3.objectMode ? r3 = t3.buffer.shift() : !e1 || e1 >= t3.length ? (r3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : r3 = t3.buffer.consume(e1, t3.decoder), r3);
                        }
                        function endReadable1(e1) {
                            var t3 = e1._readableState;
                            u3("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = !0, process1.nextTick(endReadableNT1, t3, e1));
                        }
                        function endReadableNT1(e1, t3) {
                            if (u3("endReadableNT", e1.endEmitted, e1.length), !e1.endEmitted && 0 === e1.length && (e1.endEmitted = !0, t3.readable = !1, t3.emit("end"), e1.autoDestroy)) {
                                var r3 = t3._writableState;
                                (!r3 || r3.autoDestroy && r3.finished) && t3.destroy();
                            }
                        }
                        function indexOf1(e1, t3) {
                            for(var r3 = 0, n2 = e1.length; r3 < n2; r3++)if (e1[r3] === t3) return r3;
                            return -1;
                        }
                        Readable1.prototype.read = function(e1) {
                            u3("read", e1), e1 = parseInt(e1, 10);
                            var i2, t3 = this._readableState, r3 = e1;
                            if (0 !== e1 && (t3.emittedReadable = !1), 0 === e1 && t3.needReadable && ((0 !== t3.highWaterMark ? t3.length >= t3.highWaterMark : t3.length > 0) || t3.ended)) return u3("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? endReadable1(this) : emitReadable1(this), null;
                            if (0 === (e1 = howMuchToRead1(e1, t3)) && t3.ended) return 0 === t3.length && endReadable1(this), null;
                            var n2 = t3.needReadable;
                            return u3("need readable", n2), (0 === t3.length || t3.length - e1 < t3.highWaterMark) && u3("length less than watermark", n2 = !0), t3.ended || t3.reading ? u3("reading or ended", n2 = !1) : n2 && (u3("do read"), t3.reading = !0, t3.sync = !0, 0 === t3.length && (t3.needReadable = !0), this._read(t3.highWaterMark), t3.sync = !1, t3.reading || (e1 = howMuchToRead1(r3, t3))), null === (i2 = e1 > 0 ? fromList1(e1, t3) : null) ? (t3.needReadable = t3.length <= t3.highWaterMark, e1 = 0) : (t3.length -= e1, t3.awaitDrain = 0), 0 === t3.length && (t3.ended || (t3.needReadable = !0), r3 !== e1 && t3.ended && endReadable1(this)), null !== i2 && this.emit("data", i2), i2;
                        }, Readable1.prototype._read = function(e1) {
                            R1(this, new _1("_read()"));
                        }, Readable1.prototype.pipe = function(e1, t3) {
                            var r3 = this, n2 = this._readableState;
                            switch(n2.pipesCount){
                                case 0:
                                    n2.pipes = e1;
                                    break;
                                case 1:
                                    n2.pipes = [
                                        n2.pipes,
                                        e1
                                    ];
                                    break;
                                default:
                                    n2.pipes.push(e1);
                            }
                            n2.pipesCount += 1, u3("pipe count=%d opts=%j", n2.pipesCount, t3);
                            var o1 = t3 && !1 === t3.end || e1 === process1.stdout || e1 === process1.stderr ? unpipe1 : onend1;
                            function onunpipe1(e1, t3) {
                                u3("onunpipe"), e1 === r3 && t3 && !1 === t3.hasUnpiped && (t3.hasUnpiped = !0, cleanup1());
                            }
                            function onend1() {
                                u3("onend"), e1.end();
                            }
                            n2.endEmitted ? process1.nextTick(o1) : r3.once("end", o1), e1.on("unpipe", onunpipe1);
                            var s3 = pipeOnDrain1(r3);
                            e1.on("drain", s3);
                            var f1 = !1;
                            function cleanup1() {
                                u3("cleanup"), e1.removeListener("close", onclose1), e1.removeListener("finish", onfinish1), e1.removeListener("drain", s3), e1.removeListener("error", onerror1), e1.removeListener("unpipe", onunpipe1), r3.removeListener("end", onend1), r3.removeListener("end", unpipe1), r3.removeListener("data", ondata1), f1 = !0, n2.awaitDrain && (!e1._writableState || e1._writableState.needDrain) && s3();
                            }
                            function ondata1(t3) {
                                u3("ondata");
                                var i2 = e1.write(t3);
                                u3("dest.write", i2), !1 === i2 && ((1 === n2.pipesCount && n2.pipes === e1 || n2.pipesCount > 1 && -1 !== indexOf1(n2.pipes, e1)) && !f1 && (u3("false write response, pause", n2.awaitDrain), n2.awaitDrain++), r3.pause());
                            }
                            function onerror1(t3) {
                                u3("onerror", t3), unpipe1(), e1.removeListener("error", onerror1), 0 === a10(e1, "error") && R1(e1, t3);
                            }
                            function onclose1() {
                                e1.removeListener("finish", onfinish1), unpipe1();
                            }
                            function onfinish1() {
                                u3("onfinish"), e1.removeListener("close", onclose1), unpipe1();
                            }
                            function unpipe1() {
                                u3("unpipe"), r3.unpipe(e1);
                            }
                            return r3.on("data", ondata1), prependListener1(e1, "error", onerror1), e1.once("close", onclose1), e1.once("finish", onfinish1), e1.emit("pipe", r3), n2.flowing || (u3("pipe resume"), r3.resume()), e1;
                        }, Readable1.prototype.unpipe = function(e1) {
                            var t3 = this._readableState, r3 = {
                                hasUnpiped: !1
                            };
                            if (0 === t3.pipesCount) return this;
                            if (1 === t3.pipesCount) return e1 && e1 !== t3.pipes || (e1 || (e1 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = !1, e1 && e1.emit("unpipe", this, r3)), this;
                            if (!e1) {
                                var n2 = t3.pipes, i2 = t3.pipesCount;
                                t3.pipes = null, t3.pipesCount = 0, t3.flowing = !1;
                                for(var a10 = 0; a10 < i2; a10++)n2[a10].emit("unpipe", this, {
                                    hasUnpiped: !1
                                });
                                return this;
                            }
                            var o1 = indexOf1(t3.pipes, e1);
                            return -1 === o1 || (t3.pipes.splice(o1, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e1.emit("unpipe", this, r3)), this;
                        }, Readable1.prototype.on = function(e1, t3) {
                            var r3 = o1.prototype.on.call(this, e1, t3), n2 = this._readableState;
                            return "data" === e1 ? (n2.readableListening = this.listenerCount("readable") > 0, !1 !== n2.flowing && this.resume()) : "readable" !== e1 || n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = !0, n2.flowing = !1, n2.emittedReadable = !1, u3("on readable", n2.length, n2.reading), n2.length ? emitReadable1(this) : n2.reading || process1.nextTick(nReadingNextTick1, this)), r3;
                        }, Readable1.prototype.addListener = Readable1.prototype.on, Readable1.prototype.removeListener = function(e1, t3) {
                            var r3 = o1.prototype.removeListener.call(this, e1, t3);
                            return "readable" === e1 && process1.nextTick(updateReadableListening1, this), r3;
                        }, Readable1.prototype.removeAllListeners = function(e1) {
                            var t3 = o1.prototype.removeAllListeners.apply(this, arguments);
                            return ("readable" === e1 || void 0 === e1) && process1.nextTick(updateReadableListening1, this), t3;
                        }, Readable1.prototype.resume = function() {
                            var e1 = this._readableState;
                            return e1.flowing || (u3("resume"), e1.flowing = !e1.readableListening, resume1(this, e1)), e1.paused = !1, this;
                        }, Readable1.prototype.pause = function() {
                            return u3("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (u3("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
                        }, Readable1.prototype.wrap = function(e1) {
                            var t3 = this, r3 = this._readableState, n2 = !1;
                            for(var i2 in e1.on("end", function() {
                                if (u3("wrapped end"), r3.decoder && !r3.ended) {
                                    var e1 = r3.decoder.end();
                                    e1 && e1.length && t3.push(e1);
                                }
                                t3.push(null);
                            }), e1.on("data", function(i2) {
                                u3("wrapped data"), r3.decoder && (i2 = r3.decoder.write(i2)), (!r3.objectMode || null != i2) && (r3.objectMode || i2 && i2.length) && (t3.push(i2) || (n2 = !0, e1.pause()));
                            }), e1)void 0 === this[i2] && "function" == typeof e1[i2] && (this[i2] = function(t3) {
                                return function() {
                                    return e1[t3].apply(e1, arguments);
                                };
                            }(i2));
                            for(var a10 = 0; a10 < E1.length; a10++)e1.on(E1[a10], this.emit.bind(this, E1[a10]));
                            return this._read = function(t3) {
                                u3("wrapped _read", t3), n2 && (n2 = !1, e1.resume());
                            }, this;
                        }, "function" == typeof Symbol && (Readable1.prototype[Symbol.asyncIterator] = function() {
                            return void 0 === m1 && (m1 = r3(224)), m1(this);
                        }), Object.defineProperty(Readable1.prototype, "readableHighWaterMark", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState.highWaterMark;
                            }
                        }), Object.defineProperty(Readable1.prototype, "readableBuffer", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState && this._readableState.buffer;
                            }
                        }), Object.defineProperty(Readable1.prototype, "readableFlowing", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState.flowing;
                            },
                            set: function(e1) {
                                this._readableState && (this._readableState.flowing = e1);
                            }
                        }), Readable1._fromList = fromList1, Object.defineProperty(Readable1.prototype, "readableLength", {
                            enumerable: !1,
                            get: function() {
                                return this._readableState.length;
                            }
                        }), "function" == typeof Symbol && (Readable1.from = function(e1, t3) {
                            return void 0 === S1 && (S1 = r3(720)), S1(Readable1, e1, t3);
                        });
                    },
                    551: function(e1, t3, r3) {
                        "use strict";
                        e1.exports = Transform1;
                        var n2 = r3(349).q, i2 = n2.ERR_METHOD_NOT_IMPLEMENTED, a10 = n2.ERR_MULTIPLE_CALLBACK, o1 = n2.ERR_TRANSFORM_ALREADY_TRANSFORMING, s3 = n2.ERR_TRANSFORM_WITH_LENGTH_0, f1 = r3(716);
                        function afterTransform1(e1, t3) {
                            var r3 = this._transformState;
                            r3.transforming = !1;
                            var n2 = r3.writecb;
                            if (null === n2) return this.emit("error", new a10);
                            r3.writechunk = null, r3.writecb = null, null != t3 && this.push(t3), n2(e1);
                            var i2 = this._readableState;
                            i2.reading = !1, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
                        }
                        function Transform1(e1) {
                            if (!(this instanceof Transform1)) return new Transform1(e1);
                            f1.call(this, e1), this._transformState = {
                                afterTransform: afterTransform1.bind(this),
                                needTransform: !1,
                                transforming: !1,
                                writecb: null,
                                writechunk: null,
                                writeencoding: null
                            }, this._readableState.needReadable = !0, this._readableState.sync = !1, e1 && ("function" == typeof e1.transform && (this._transform = e1.transform), "function" == typeof e1.flush && (this._flush = e1.flush)), this.on("prefinish", prefinish1);
                        }
                        function prefinish1() {
                            var e1 = this;
                            "function" != typeof this._flush || this._readableState.destroyed ? done1(this, null, null) : this._flush(function(t3, r3) {
                                done1(e1, t3, r3);
                            });
                        }
                        function done1(e1, t3, r3) {
                            if (t3) return e1.emit("error", t3);
                            if (null != r3 && e1.push(r3), e1._writableState.length) throw new s3;
                            if (e1._transformState.transforming) throw new o1;
                            return e1.push(null);
                        }
                        r3(140)(Transform1, f1), Transform1.prototype.push = function(e1, t3) {
                            return this._transformState.needTransform = !1, f1.prototype.push.call(this, e1, t3);
                        }, Transform1.prototype._transform = function(e1, t3, r3) {
                            r3(new i2("_transform()"));
                        }, Transform1.prototype._write = function(e1, t3, r3) {
                            var n2 = this._transformState;
                            if (n2.writecb = r3, n2.writechunk = e1, n2.writeencoding = t3, !n2.transforming) {
                                var i2 = this._readableState;
                                (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
                            }
                        }, Transform1.prototype._read = function(e1) {
                            var t3 = this._transformState;
                            null === t3.writechunk || t3.transforming ? t3.needTransform = !0 : (t3.transforming = !0, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform));
                        }, Transform1.prototype._destroy = function(e1, t3) {
                            f1.prototype._destroy.call(this, e1, function(e1) {
                                t3(e1);
                            });
                        };
                    },
                    513: function(e1, t3, r3) {
                        "use strict";
                        function CorkedRequest1(e1) {
                            var t3 = this;
                            this.next = null, this.entry = null, this.finish = function() {
                                onCorkedFinish1(t3, e1);
                            };
                        }
                        e1.exports = Writable1, Writable1.WritableState = WritableState1;
                        var n2, m1, i2 = {
                            deprecate: r3(777)
                        }, a10 = r3(455), o1 = r3(300).Buffer, s3 = __webpack_require__1.g.Uint8Array || function() {};
                        function _uint8ArrayToBuffer1(e1) {
                            return o1.from(e1);
                        }
                        function _isUint8Array1(e1) {
                            return o1.isBuffer(e1) || e1 instanceof s3;
                        }
                        var f1 = r3(289), u3 = r3(483).getHighWaterMark, d3 = r3(349).q, c5 = d3.ERR_INVALID_ARG_TYPE, h8 = d3.ERR_METHOD_NOT_IMPLEMENTED, p3 = d3.ERR_MULTIPLE_CALLBACK, b10 = d3.ERR_STREAM_CANNOT_PIPE, g3 = d3.ERR_STREAM_DESTROYED, y3 = d3.ERR_STREAM_NULL_VALUES, _1 = d3.ERR_STREAM_WRITE_AFTER_END, v3 = d3.ERR_UNKNOWN_ENCODING, w19 = f1.errorOrDestroy;
                        function nop1() {}
                        function WritableState1(e1, t3, i2) {
                            n2 = n2 || r3(716), e1 = e1 || {}, "boolean" != typeof i2 && (i2 = t3 instanceof n2), this.objectMode = !!e1.objectMode, i2 && (this.objectMode = this.objectMode || !!e1.writableObjectMode), this.highWaterMark = u3(this, e1, "writableHighWaterMark", i2), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
                            var a10 = !1 === e1.decodeStrings;
                            this.decodeStrings = !a10, this.defaultEncoding = e1.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e1) {
                                onwrite1(t3, e1);
                            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== e1.emitClose, this.autoDestroy = !!e1.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest1(this);
                        }
                        function Writable1(e1) {
                            var t3 = this instanceof (n2 = n2 || r3(716));
                            if (!t3 && !m1.call(Writable1, this)) return new Writable1(e1);
                            this._writableState = new WritableState1(e1, this, t3), this.writable = !0, e1 && ("function" == typeof e1.write && (this._write = e1.write), "function" == typeof e1.writev && (this._writev = e1.writev), "function" == typeof e1.destroy && (this._destroy = e1.destroy), "function" == typeof e1.final && (this._final = e1.final)), a10.call(this);
                        }
                        function writeAfterEnd1(e1, t3) {
                            var r3 = new _1;
                            w19(e1, r3), process1.nextTick(t3, r3);
                        }
                        function validChunk1(e1, t3, r3, n2) {
                            var i2;
                            return null === r3 ? i2 = new y3 : "string" == typeof r3 || t3.objectMode || (i2 = new c5("chunk", [
                                "string",
                                "Buffer"
                            ], r3)), !i2 || (w19(e1, i2), process1.nextTick(n2, i2), !1);
                        }
                        function decodeChunk1(e1, t3, r3) {
                            return e1.objectMode || !1 === e1.decodeStrings || "string" != typeof t3 || (t3 = o1.from(t3, r3)), t3;
                        }
                        function writeOrBuffer1(e1, t3, r3, n2, i2, a10) {
                            if (!r3) {
                                var o1 = decodeChunk1(t3, n2, i2);
                                n2 !== o1 && (r3 = !0, i2 = "buffer", n2 = o1);
                            }
                            var s3 = t3.objectMode ? 1 : n2.length;
                            t3.length += s3;
                            var f1 = t3.length < t3.highWaterMark;
                            if (f1 || (t3.needDrain = !0), t3.writing || t3.corked) {
                                var l1 = t3.lastBufferedRequest;
                                t3.lastBufferedRequest = {
                                    chunk: n2,
                                    encoding: i2,
                                    isBuf: r3,
                                    callback: a10,
                                    next: null
                                }, l1 ? l1.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
                            } else doWrite1(e1, t3, !1, s3, n2, i2, a10);
                            return f1;
                        }
                        function doWrite1(e1, t3, r3, n2, i2, a10, o1) {
                            t3.writelen = n2, t3.writecb = o1, t3.writing = !0, t3.sync = !0, t3.destroyed ? t3.onwrite(new g3("write")) : r3 ? e1._writev(i2, t3.onwrite) : e1._write(i2, a10, t3.onwrite), t3.sync = !1;
                        }
                        function onwriteError1(e1, t3, r3, n2, i2) {
                            --t3.pendingcb, r3 ? (process1.nextTick(i2, n2), process1.nextTick(finishMaybe1, e1, t3), e1._writableState.errorEmitted = !0, w19(e1, n2)) : (i2(n2), e1._writableState.errorEmitted = !0, w19(e1, n2), finishMaybe1(e1, t3));
                        }
                        function onwriteStateUpdate1(e1) {
                            e1.writing = !1, e1.writecb = null, e1.length -= e1.writelen, e1.writelen = 0;
                        }
                        function onwrite1(e1, t3) {
                            var r3 = e1._writableState, n2 = r3.sync, i2 = r3.writecb;
                            if ("function" != typeof i2) throw new p3;
                            if (onwriteStateUpdate1(r3), t3) onwriteError1(e1, r3, n2, t3, i2);
                            else {
                                var a10 = needFinish1(r3) || e1.destroyed;
                                a10 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || clearBuffer1(e1, r3), n2 ? process1.nextTick(afterWrite1, e1, r3, a10, i2) : afterWrite1(e1, r3, a10, i2);
                            }
                        }
                        function afterWrite1(e1, t3, r3, n2) {
                            r3 || onwriteDrain1(e1, t3), t3.pendingcb--, n2(), finishMaybe1(e1, t3);
                        }
                        function onwriteDrain1(e1, t3) {
                            0 === t3.length && t3.needDrain && (t3.needDrain = !1, e1.emit("drain"));
                        }
                        function clearBuffer1(e1, t3) {
                            t3.bufferProcessing = !0;
                            var r3 = t3.bufferedRequest;
                            if (e1._writev && r3 && r3.next) {
                                var i2 = Array(t3.bufferedRequestCount), a10 = t3.corkedRequestsFree;
                                a10.entry = r3;
                                for(var o1 = 0, s3 = !0; r3;)i2[o1] = r3, r3.isBuf || (s3 = !1), r3 = r3.next, o1 += 1;
                                i2.allBuffers = s3, doWrite1(e1, t3, !0, t3.length, i2, "", a10.finish), t3.pendingcb++, t3.lastBufferedRequest = null, a10.next ? (t3.corkedRequestsFree = a10.next, a10.next = null) : t3.corkedRequestsFree = new CorkedRequest1(t3), t3.bufferedRequestCount = 0;
                            } else {
                                for(; r3;){
                                    var f1 = r3.chunk, l1 = r3.encoding, u3 = r3.callback, d3 = t3.objectMode ? 1 : f1.length;
                                    if (doWrite1(e1, t3, !1, d3, f1, l1, u3), r3 = r3.next, t3.bufferedRequestCount--, t3.writing) break;
                                }
                                null === r3 && (t3.lastBufferedRequest = null);
                            }
                            t3.bufferedRequest = r3, t3.bufferProcessing = !1;
                        }
                        function needFinish1(e1) {
                            return e1.ending && 0 === e1.length && null === e1.bufferedRequest && !e1.finished && !e1.writing;
                        }
                        function callFinal1(e1, t3) {
                            e1._final(function(r3) {
                                t3.pendingcb--, r3 && w19(e1, r3), t3.prefinished = !0, e1.emit("prefinish"), finishMaybe1(e1, t3);
                            });
                        }
                        function prefinish1(e1, t3) {
                            t3.prefinished || t3.finalCalled || ("function" != typeof e1._final || t3.destroyed ? (t3.prefinished = !0, e1.emit("prefinish")) : (t3.pendingcb++, t3.finalCalled = !0, process1.nextTick(callFinal1, e1, t3)));
                        }
                        function finishMaybe1(e1, t3) {
                            var r3 = needFinish1(t3);
                            if (r3 && (prefinish1(e1, t3), 0 === t3.pendingcb && (t3.finished = !0, e1.emit("finish"), t3.autoDestroy))) {
                                var n2 = e1._readableState;
                                (!n2 || n2.autoDestroy && n2.endEmitted) && e1.destroy();
                            }
                            return r3;
                        }
                        function endWritable1(e1, t3, r3) {
                            t3.ending = !0, finishMaybe1(e1, t3), r3 && (t3.finished ? process1.nextTick(r3) : e1.once("finish", r3)), t3.ended = !0, e1.writable = !1;
                        }
                        function onCorkedFinish1(e1, t3, r3) {
                            var n2 = e1.entry;
                            for(e1.entry = null; n2;){
                                var i2 = n2.callback;
                                t3.pendingcb--, i2(r3), n2 = n2.next;
                            }
                            t3.corkedRequestsFree.next = e1;
                        }
                        r3(140)(Writable1, a10), WritableState1.prototype.getBuffer = function() {
                            for(var e1 = this.bufferedRequest, t3 = []; e1;)t3.push(e1), e1 = e1.next;
                            return t3;
                        }, function() {
                            try {
                                Object.defineProperty(WritableState1.prototype, "buffer", {
                                    get: i2.deprecate(function() {
                                        return this.getBuffer();
                                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                                });
                            } catch (e1) {}
                        }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (m1 = Function.prototype[Symbol.hasInstance], Object.defineProperty(Writable1, Symbol.hasInstance, {
                            value: function(e1) {
                                return !!m1.call(this, e1) || this === Writable1 && e1 && e1._writableState instanceof WritableState1;
                            }
                        })) : m1 = function(e1) {
                            return e1 instanceof this;
                        }, Writable1.prototype.pipe = function() {
                            w19(this, new b10);
                        }, Writable1.prototype.write = function(e1, t3, r3) {
                            var n2 = this._writableState, i2 = !1, a10 = !n2.objectMode && _isUint8Array1(e1);
                            return a10 && !o1.isBuffer(e1) && (e1 = _uint8ArrayToBuffer1(e1)), "function" == typeof t3 && (r3 = t3, t3 = null), a10 ? t3 = "buffer" : t3 || (t3 = n2.defaultEncoding), "function" != typeof r3 && (r3 = nop1), n2.ending ? writeAfterEnd1(this, r3) : (a10 || validChunk1(this, n2, e1, r3)) && (n2.pendingcb++, i2 = writeOrBuffer1(this, n2, a10, e1, t3, r3)), i2;
                        }, Writable1.prototype.cork = function() {
                            this._writableState.corked++;
                        }, Writable1.prototype.uncork = function() {
                            var e1 = this._writableState;
                            !e1.corked || (e1.corked--, e1.writing || e1.corked || e1.bufferProcessing || !e1.bufferedRequest || clearBuffer1(this, e1));
                        }, Writable1.prototype.setDefaultEncoding = function(e1) {
                            if ("string" == typeof e1 && (e1 = e1.toLowerCase()), !([
                                "hex",
                                "utf8",
                                "utf-8",
                                "ascii",
                                "binary",
                                "base64",
                                "ucs2",
                                "ucs-2",
                                "utf16le",
                                "utf-16le",
                                "raw"
                            ].indexOf((e1 + "").toLowerCase()) > -1)) throw new v3(e1);
                            return this._writableState.defaultEncoding = e1, this;
                        }, Object.defineProperty(Writable1.prototype, "writableBuffer", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState && this._writableState.getBuffer();
                            }
                        }), Object.defineProperty(Writable1.prototype, "writableHighWaterMark", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.highWaterMark;
                            }
                        }), Writable1.prototype._write = function(e1, t3, r3) {
                            r3(new h8("_write()"));
                        }, Writable1.prototype._writev = null, Writable1.prototype.end = function(e1, t3, r3) {
                            var n2 = this._writableState;
                            return "function" == typeof e1 ? (r3 = e1, e1 = null, t3 = null) : "function" == typeof t3 && (r3 = t3, t3 = null), null != e1 && this.write(e1, t3), n2.corked && (n2.corked = 1, this.uncork()), n2.ending || endWritable1(this, n2, r3), this;
                        }, Object.defineProperty(Writable1.prototype, "writableLength", {
                            enumerable: !1,
                            get: function() {
                                return this._writableState.length;
                            }
                        }), Object.defineProperty(Writable1.prototype, "destroyed", {
                            enumerable: !1,
                            get: function() {
                                return void 0 !== this._writableState && this._writableState.destroyed;
                            },
                            set: function(e1) {
                                this._writableState && (this._writableState.destroyed = e1);
                            }
                        }), Writable1.prototype.destroy = f1.destroy, Writable1.prototype._undestroy = f1.undestroy, Writable1.prototype._destroy = function(e1, t3) {
                            t3(e1);
                        };
                    },
                    224: function(e1, t3, r3) {
                        "use strict";
                        function _defineProperty1(e1, t3, r3) {
                            return t3 in e1 ? Object.defineProperty(e1, t3, {
                                value: r3,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : e1[t3] = r3, e1;
                        }
                        var n2, i2 = r3(7), a10 = Symbol("lastResolve"), o1 = Symbol("lastReject"), s3 = Symbol("error"), f1 = Symbol("ended"), l1 = Symbol("lastPromise"), u3 = Symbol("handlePromise"), d3 = Symbol("stream");
                        function createIterResult1(e1, t3) {
                            return {
                                value: e1,
                                done: t3
                            };
                        }
                        function readAndResolve1(e1) {
                            var t3 = e1[a10];
                            if (null !== t3) {
                                var r3 = e1[d3].read();
                                null !== r3 && (e1[l1] = null, e1[a10] = null, e1[o1] = null, t3(createIterResult1(r3, !1)));
                            }
                        }
                        function onReadable1(e1) {
                            process1.nextTick(readAndResolve1, e1);
                        }
                        function wrapForNext1(e1, t3) {
                            return function(r3, n2) {
                                e1.then(function() {
                                    if (t3[f1]) {
                                        r3(createIterResult1(void 0, !0));
                                        return;
                                    }
                                    t3[u3](r3, n2);
                                }, n2);
                            };
                        }
                        var c5 = Object.getPrototypeOf(function() {}), h8 = Object.setPrototypeOf((_defineProperty1(n2 = {
                            get stream () {
                                return this[d3];
                            },
                            next: function() {
                                var n2, e1 = this, t3 = this[s3];
                                if (null !== t3) return Promise.reject(t3);
                                if (this[f1]) return Promise.resolve(createIterResult1(void 0, !0));
                                if (this[d3].destroyed) return new Promise(function(t3, r3) {
                                    process1.nextTick(function() {
                                        e1[s3] ? r3(e1[s3]) : t3(createIterResult1(void 0, !0));
                                    });
                                });
                                var r3 = this[l1];
                                if (r3) n2 = new Promise(wrapForNext1(r3, this));
                                else {
                                    var i2 = this[d3].read();
                                    if (null !== i2) return Promise.resolve(createIterResult1(i2, !1));
                                    n2 = new Promise(this[u3]);
                                }
                                return this[l1] = n2, n2;
                            }
                        }, Symbol.asyncIterator, function() {
                            return this;
                        }), _defineProperty1(n2, "return", function() {
                            var e1 = this;
                            return new Promise(function(t3, r3) {
                                e1[d3].destroy(null, function(e1) {
                                    if (e1) {
                                        r3(e1);
                                        return;
                                    }
                                    t3(createIterResult1(void 0, !0));
                                });
                            });
                        }), n2), c5), p3 = function(e1) {
                            var t3, r3 = Object.create(h8, (_defineProperty1(t3 = {}, d3, {
                                value: e1,
                                writable: !0
                            }), _defineProperty1(t3, a10, {
                                value: null,
                                writable: !0
                            }), _defineProperty1(t3, o1, {
                                value: null,
                                writable: !0
                            }), _defineProperty1(t3, s3, {
                                value: null,
                                writable: !0
                            }), _defineProperty1(t3, f1, {
                                value: e1._readableState.endEmitted,
                                writable: !0
                            }), _defineProperty1(t3, u3, {
                                value: function(e1, t3) {
                                    var n2 = r3[d3].read();
                                    n2 ? (r3[l1] = null, r3[a10] = null, r3[o1] = null, e1(createIterResult1(n2, !1))) : (r3[a10] = e1, r3[o1] = t3);
                                },
                                writable: !0
                            }), t3));
                            return r3[l1] = null, i2(e1, function(e1) {
                                if (e1 && "ERR_STREAM_PREMATURE_CLOSE" !== e1.code) {
                                    var t3 = r3[o1];
                                    null !== t3 && (r3[l1] = null, r3[a10] = null, r3[o1] = null, t3(e1)), r3[s3] = e1;
                                    return;
                                }
                                var n2 = r3[a10];
                                null !== n2 && (r3[l1] = null, r3[a10] = null, r3[o1] = null, n2(createIterResult1(void 0, !0))), r3[f1] = !0;
                            }), e1.on("readable", onReadable1.bind(null, r3)), r3;
                        };
                        e1.exports = p3;
                    },
                    41: function(e1, t3, r3) {
                        "use strict";
                        function ownKeys1(e1, t3) {
                            var r3 = Object.keys(e1);
                            if (Object.getOwnPropertySymbols) {
                                var n2 = Object.getOwnPropertySymbols(e1);
                                t3 && (n2 = n2.filter(function(t3) {
                                    return Object.getOwnPropertyDescriptor(e1, t3).enumerable;
                                })), r3.push.apply(r3, n2);
                            }
                            return r3;
                        }
                        function _objectSpread1(e1) {
                            for(var t3 = 1; t3 < arguments.length; t3++){
                                var r3 = null != arguments[t3] ? arguments[t3] : {};
                                t3 % 2 ? ownKeys1(Object(r3), !0).forEach(function(t3) {
                                    _defineProperty1(e1, t3, r3[t3]);
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(r3)) : ownKeys1(Object(r3)).forEach(function(t3) {
                                    Object.defineProperty(e1, t3, Object.getOwnPropertyDescriptor(r3, t3));
                                });
                            }
                            return e1;
                        }
                        function _defineProperty1(e1, t3, r3) {
                            return t3 in e1 ? Object.defineProperty(e1, t3, {
                                value: r3,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : e1[t3] = r3, e1;
                        }
                        function _classCallCheck1(e1, t3) {
                            if (!(e1 instanceof t3)) throw TypeError("Cannot call a class as a function");
                        }
                        function _defineProperties1(e1, t3) {
                            for(var r3 = 0; r3 < t3.length; r3++){
                                var n2 = t3[r3];
                                n2.enumerable = n2.enumerable || !1, n2.configurable = !0, "value" in n2 && (n2.writable = !0), Object.defineProperty(e1, n2.key, n2);
                            }
                        }
                        function _createClass1(e1, t3, r3) {
                            return t3 && _defineProperties1(e1.prototype, t3), r3 && _defineProperties1(e1, r3), e1;
                        }
                        var i2 = r3(300).Buffer, o1 = r3(837).inspect, s3 = o1 && o1.custom || "inspect";
                        function copyBuffer1(e1, t3, r3) {
                            i2.prototype.copy.call(e1, t3, r3);
                        }
                        e1.exports = function() {
                            function BufferList1() {
                                _classCallCheck1(this, BufferList1), this.head = null, this.tail = null, this.length = 0;
                            }
                            return _createClass1(BufferList1, [
                                {
                                    key: "push",
                                    value: function(e1) {
                                        var t3 = {
                                            data: e1,
                                            next: null
                                        };
                                        this.length > 0 ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
                                    }
                                },
                                {
                                    key: "unshift",
                                    value: function(e1) {
                                        var t3 = {
                                            data: e1,
                                            next: this.head
                                        };
                                        0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
                                    }
                                },
                                {
                                    key: "shift",
                                    value: function() {
                                        if (0 !== this.length) {
                                            var e1 = this.head.data;
                                            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e1;
                                        }
                                    }
                                },
                                {
                                    key: "clear",
                                    value: function() {
                                        this.head = this.tail = null, this.length = 0;
                                    }
                                },
                                {
                                    key: "join",
                                    value: function(e1) {
                                        if (0 === this.length) return "";
                                        for(var t3 = this.head, r3 = "" + t3.data; t3 = t3.next;)r3 += e1 + t3.data;
                                        return r3;
                                    }
                                },
                                {
                                    key: "concat",
                                    value: function(e1) {
                                        if (0 === this.length) return i2.alloc(0);
                                        for(var t3 = i2.allocUnsafe(e1 >>> 0), r3 = this.head, n2 = 0; r3;)copyBuffer1(r3.data, t3, n2), n2 += r3.data.length, r3 = r3.next;
                                        return t3;
                                    }
                                },
                                {
                                    key: "consume",
                                    value: function(e1, t3) {
                                        var r3;
                                        return e1 < this.head.data.length ? (r3 = this.head.data.slice(0, e1), this.head.data = this.head.data.slice(e1)) : r3 = e1 === this.head.data.length ? this.shift() : t3 ? this._getString(e1) : this._getBuffer(e1), r3;
                                    }
                                },
                                {
                                    key: "first",
                                    value: function() {
                                        return this.head.data;
                                    }
                                },
                                {
                                    key: "_getString",
                                    value: function(e1) {
                                        var t3 = this.head, r3 = 1, n2 = t3.data;
                                        for(e1 -= n2.length; t3 = t3.next;){
                                            var i2 = t3.data, a10 = e1 > i2.length ? i2.length : e1;
                                            if (a10 === i2.length ? n2 += i2 : n2 += i2.slice(0, e1), 0 == (e1 -= a10)) {
                                                a10 === i2.length ? (++r3, t3.next ? this.head = t3.next : this.head = this.tail = null) : (this.head = t3, t3.data = i2.slice(a10));
                                                break;
                                            }
                                            ++r3;
                                        }
                                        return this.length -= r3, n2;
                                    }
                                },
                                {
                                    key: "_getBuffer",
                                    value: function(e1) {
                                        var t3 = i2.allocUnsafe(e1), r3 = this.head, n2 = 1;
                                        for(r3.data.copy(t3), e1 -= r3.data.length; r3 = r3.next;){
                                            var a10 = r3.data, o1 = e1 > a10.length ? a10.length : e1;
                                            if (a10.copy(t3, t3.length - e1, 0, o1), 0 == (e1 -= o1)) {
                                                o1 === a10.length ? (++n2, r3.next ? this.head = r3.next : this.head = this.tail = null) : (this.head = r3, r3.data = a10.slice(o1));
                                                break;
                                            }
                                            ++n2;
                                        }
                                        return this.length -= n2, t3;
                                    }
                                },
                                {
                                    key: s3,
                                    value: function(e1, t3) {
                                        return o1(this, _objectSpread1({}, t3, {
                                            depth: 0,
                                            customInspect: !1
                                        }));
                                    }
                                }
                            ]), BufferList1;
                        }();
                    },
                    289: function(e1) {
                        "use strict";
                        function destroy1(e1, t3) {
                            var r3 = this, n2 = this._readableState && this._readableState.destroyed, i2 = this._writableState && this._writableState.destroyed;
                            return n2 || i2 ? (t3 ? t3(e1) : e1 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process1.nextTick(emitErrorNT1, this, e1)) : process1.nextTick(emitErrorNT1, this, e1)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e1 || null, function(e1) {
                                !t3 && e1 ? r3._writableState ? r3._writableState.errorEmitted ? process1.nextTick(emitCloseNT1, r3) : (r3._writableState.errorEmitted = !0, process1.nextTick(emitErrorAndCloseNT1, r3, e1)) : process1.nextTick(emitErrorAndCloseNT1, r3, e1) : t3 ? (process1.nextTick(emitCloseNT1, r3), t3(e1)) : process1.nextTick(emitCloseNT1, r3);
                            }), this);
                        }
                        function emitErrorAndCloseNT1(e1, t3) {
                            emitErrorNT1(e1, t3), emitCloseNT1(e1);
                        }
                        function emitCloseNT1(e1) {
                            (!e1._writableState || e1._writableState.emitClose) && (!e1._readableState || e1._readableState.emitClose) && e1.emit("close");
                        }
                        function undestroy1() {
                            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
                        }
                        function emitErrorNT1(e1, t3) {
                            e1.emit("error", t3);
                        }
                        function errorOrDestroy1(e1, t3) {
                            var r3 = e1._readableState, n2 = e1._writableState;
                            r3 && r3.autoDestroy || n2 && n2.autoDestroy ? e1.destroy(t3) : e1.emit("error", t3);
                        }
                        e1.exports = {
                            destroy: destroy1,
                            undestroy: undestroy1,
                            errorOrDestroy: errorOrDestroy1
                        };
                    },
                    7: function(e1, t3, r3) {
                        "use strict";
                        var n2 = r3(349).q.ERR_STREAM_PREMATURE_CLOSE;
                        function once1(e1) {
                            var t3 = !1;
                            return function() {
                                if (!t3) {
                                    t3 = !0;
                                    for(var r3 = arguments.length, n2 = Array(r3), i2 = 0; i2 < r3; i2++)n2[i2] = arguments[i2];
                                    e1.apply(this, n2);
                                }
                            };
                        }
                        function noop1() {}
                        function isRequest1(e1) {
                            return e1.setHeader && "function" == typeof e1.abort;
                        }
                        function eos1(e1, t3, r3) {
                            if ("function" == typeof t3) return eos1(e1, null, t3);
                            t3 || (t3 = {}), r3 = once1(r3 || noop1);
                            var i2 = t3.readable || !1 !== t3.readable && e1.readable, a10 = t3.writable || !1 !== t3.writable && e1.writable, o1 = function() {
                                e1.writable || f1();
                            }, s3 = e1._writableState && e1._writableState.finished, f1 = function() {
                                a10 = !1, s3 = !0, i2 || r3.call(e1);
                            }, l1 = e1._readableState && e1._readableState.endEmitted, u3 = function() {
                                i2 = !1, l1 = !0, a10 || r3.call(e1);
                            }, d3 = function(t3) {
                                r3.call(e1, t3);
                            }, c5 = function() {
                                var t3;
                                return i2 && !l1 ? (e1._readableState && e1._readableState.ended || (t3 = new n2), r3.call(e1, t3)) : a10 && !s3 ? (e1._writableState && e1._writableState.ended || (t3 = new n2), r3.call(e1, t3)) : void 0;
                            }, h8 = function() {
                                e1.req.on("finish", f1);
                            };
                            return isRequest1(e1) ? (e1.on("complete", f1), e1.on("abort", c5), e1.req ? h8() : e1.on("request", h8)) : a10 && !e1._writableState && (e1.on("end", o1), e1.on("close", o1)), e1.on("end", u3), e1.on("finish", f1), !1 !== t3.error && e1.on("error", d3), e1.on("close", c5), function() {
                                e1.removeListener("complete", f1), e1.removeListener("abort", c5), e1.removeListener("request", h8), e1.req && e1.req.removeListener("finish", f1), e1.removeListener("end", o1), e1.removeListener("close", o1), e1.removeListener("finish", f1), e1.removeListener("end", u3), e1.removeListener("error", d3), e1.removeListener("close", c5);
                            };
                        }
                        e1.exports = eos1;
                    },
                    720: function(e1, t3, r3) {
                        "use strict";
                        function asyncGeneratorStep1(e1, t3, r3, n2, i2, a10, o1) {
                            try {
                                var s3 = e1[a10](o1), f1 = s3.value;
                            } catch (e1) {
                                r3(e1);
                                return;
                            }
                            s3.done ? t3(f1) : Promise.resolve(f1).then(n2, i2);
                        }
                        function _asyncToGenerator1(e1) {
                            return function() {
                                var t3 = this, r3 = arguments;
                                return new Promise(function(n2, i2) {
                                    var a10 = e1.apply(t3, r3);
                                    function _next1(e1) {
                                        asyncGeneratorStep1(a10, n2, i2, _next1, _throw1, "next", e1);
                                    }
                                    function _throw1(e1) {
                                        asyncGeneratorStep1(a10, n2, i2, _next1, _throw1, "throw", e1);
                                    }
                                    _next1(void 0);
                                });
                            };
                        }
                        function ownKeys1(e1, t3) {
                            var r3 = Object.keys(e1);
                            if (Object.getOwnPropertySymbols) {
                                var n2 = Object.getOwnPropertySymbols(e1);
                                t3 && (n2 = n2.filter(function(t3) {
                                    return Object.getOwnPropertyDescriptor(e1, t3).enumerable;
                                })), r3.push.apply(r3, n2);
                            }
                            return r3;
                        }
                        function _objectSpread1(e1) {
                            for(var t3 = 1; t3 < arguments.length; t3++){
                                var r3 = null != arguments[t3] ? arguments[t3] : {};
                                t3 % 2 ? ownKeys1(Object(r3), !0).forEach(function(t3) {
                                    _defineProperty1(e1, t3, r3[t3]);
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(r3)) : ownKeys1(Object(r3)).forEach(function(t3) {
                                    Object.defineProperty(e1, t3, Object.getOwnPropertyDescriptor(r3, t3));
                                });
                            }
                            return e1;
                        }
                        function _defineProperty1(e1, t3, r3) {
                            return t3 in e1 ? Object.defineProperty(e1, t3, {
                                value: r3,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : e1[t3] = r3, e1;
                        }
                        var n2 = r3(349).q.ERR_INVALID_ARG_TYPE;
                        function from1(e1, t3, r3) {
                            if (t3 && "function" == typeof t3.next) i2 = t3;
                            else if (t3 && t3[Symbol.asyncIterator]) i2 = t3[Symbol.asyncIterator]();
                            else if (t3 && t3[Symbol.iterator]) i2 = t3[Symbol.iterator]();
                            else throw new n2("iterable", [
                                "Iterable"
                            ], t3);
                            var i2, a10 = new e1(_objectSpread1({
                                objectMode: !0
                            }, r3)), o1 = !1;
                            function next1() {
                                return _next21.apply(this, arguments);
                            }
                            function _next21() {
                                return (_next21 = _asyncToGenerator1(function*() {
                                    try {
                                        var e1 = yield i2.next(), t3 = e1.value;
                                        e1.done ? a10.push(null) : a10.push((yield t3)) ? next1() : o1 = !1;
                                    } catch (e1) {
                                        a10.destroy(e1);
                                    }
                                })).apply(this, arguments);
                            }
                            return a10._read = function() {
                                o1 || (o1 = !0, next1());
                            }, a10;
                        }
                        e1.exports = from1;
                    },
                    522: function(e1, t3, r3) {
                        "use strict";
                        function once1(e1) {
                            var t3 = !1;
                            return function() {
                                t3 || (t3 = !0, e1.apply(void 0, arguments));
                            };
                        }
                        var n2, i2 = r3(349).q, a10 = i2.ERR_MISSING_ARGS, o1 = i2.ERR_STREAM_DESTROYED;
                        function noop1(e1) {
                            if (e1) throw e1;
                        }
                        function isRequest1(e1) {
                            return e1.setHeader && "function" == typeof e1.abort;
                        }
                        function destroyer1(e1, t3, i2, a10) {
                            a10 = once1(a10);
                            var s3 = !1;
                            e1.on("close", function() {
                                s3 = !0;
                            }), void 0 === n2 && (n2 = r3(7)), n2(e1, {
                                readable: t3,
                                writable: i2
                            }, function(e1) {
                                if (e1) return a10(e1);
                                s3 = !0, a10();
                            });
                            var f1 = !1;
                            return function(t3) {
                                if (!s3 && !f1) {
                                    if (f1 = !0, isRequest1(e1)) return e1.abort();
                                    if ("function" == typeof e1.destroy) return e1.destroy();
                                    a10(t3 || new o1("pipe"));
                                }
                            };
                        }
                        function call1(e1) {
                            e1();
                        }
                        function pipe1(e1, t3) {
                            return e1.pipe(t3);
                        }
                        function popCallback1(e1) {
                            return e1.length && "function" == typeof e1[e1.length - 1] ? e1.pop() : noop1;
                        }
                        function pipeline1() {
                            for(var i2, e1 = arguments.length, t3 = Array(e1), r3 = 0; r3 < e1; r3++)t3[r3] = arguments[r3];
                            var n2 = popCallback1(t3);
                            if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2) throw new a10("streams");
                            var o1 = t3.map(function(e1, r3) {
                                var a10 = r3 < t3.length - 1;
                                return destroyer1(e1, a10, r3 > 0, function(e1) {
                                    i2 || (i2 = e1), e1 && o1.forEach(call1), a10 || (o1.forEach(call1), n2(i2));
                                });
                            });
                            return t3.reduce(pipe1);
                        }
                        e1.exports = pipeline1;
                    },
                    483: function(e1, t3, r3) {
                        "use strict";
                        var n2 = r3(349).q.ERR_INVALID_OPT_VALUE;
                        function highWaterMarkFrom1(e1, t3, r3) {
                            return null != e1.highWaterMark ? e1.highWaterMark : t3 ? e1[r3] : null;
                        }
                        function getHighWaterMark1(e1, t3, r3, i2) {
                            var a10 = highWaterMarkFrom1(t3, i2, r3);
                            if (null != a10) {
                                if (!(isFinite(a10) && Math.floor(a10) === a10) || a10 < 0) {
                                    var o1 = i2 ? r3 : "highWaterMark";
                                    throw new n2(o1, a10);
                                }
                                return Math.floor(a10);
                            }
                            return e1.objectMode ? 16 : 16384;
                        }
                        e1.exports = {
                            getHighWaterMark: getHighWaterMark1
                        };
                    },
                    455: function(e1, t3, r3) {
                        e1.exports = r3(781);
                    },
                    207: function(e1, t3, r3) {
                        var n2 = r3(300), i2 = n2.Buffer;
                        function copyProps1(e1, t3) {
                            for(var r3 in e1)t3[r3] = e1[r3];
                        }
                        function SafeBuffer1(e1, t3, r3) {
                            return i2(e1, t3, r3);
                        }
                        i2.from && i2.alloc && i2.allocUnsafe && i2.allocUnsafeSlow ? e1.exports = n2 : (copyProps1(n2, t3), t3.Buffer = SafeBuffer1), SafeBuffer1.prototype = Object.create(i2.prototype), copyProps1(i2, SafeBuffer1), SafeBuffer1.from = function(e1, t3, r3) {
                            if ("number" == typeof e1) throw TypeError("Argument must not be a number");
                            return i2(e1, t3, r3);
                        }, SafeBuffer1.alloc = function(e1, t3, r3) {
                            if ("number" != typeof e1) throw TypeError("Argument must be a number");
                            var n2 = i2(e1);
                            return void 0 !== t3 ? "string" == typeof r3 ? n2.fill(t3, r3) : n2.fill(t3) : n2.fill(0), n2;
                        }, SafeBuffer1.allocUnsafe = function(e1) {
                            if ("number" != typeof e1) throw TypeError("Argument must be a number");
                            return i2(e1);
                        }, SafeBuffer1.allocUnsafeSlow = function(e1) {
                            if ("number" != typeof e1) throw TypeError("Argument must be a number");
                            return n2.SlowBuffer(e1);
                        };
                    },
                    552: function(e1, t3, r3) {
                        e1.exports = Stream1;
                        var n2 = r3(361).EventEmitter;
                        function Stream1() {
                            n2.call(this);
                        }
                        r3(140)(Stream1, n2), Stream1.Readable = r3(787), Stream1.Writable = r3(513), Stream1.Duplex = r3(716), Stream1.Transform = r3(551), Stream1.PassThrough = r3(788), Stream1.finished = r3(7), Stream1.pipeline = r3(522), Stream1.Stream = Stream1, Stream1.prototype.pipe = function(e1, t3) {
                            var r3 = this;
                            function ondata1(t3) {
                                e1.writable && !1 === e1.write(t3) && r3.pause && r3.pause();
                            }
                            function ondrain1() {
                                r3.readable && r3.resume && r3.resume();
                            }
                            r3.on("data", ondata1), e1.on("drain", ondrain1), e1._isStdio || t3 && !1 === t3.end || (r3.on("end", onend1), r3.on("close", onclose1));
                            var i2 = !1;
                            function onend1() {
                                i2 || (i2 = !0, e1.end());
                            }
                            function onclose1() {
                                i2 || (i2 = !0, "function" == typeof e1.destroy && e1.destroy());
                            }
                            function onerror1(e1) {
                                if (cleanup1(), 0 === n2.listenerCount(this, "error")) throw e1;
                            }
                            function cleanup1() {
                                r3.removeListener("data", ondata1), e1.removeListener("drain", ondrain1), r3.removeListener("end", onend1), r3.removeListener("close", onclose1), r3.removeListener("error", onerror1), e1.removeListener("error", onerror1), r3.removeListener("end", cleanup1), r3.removeListener("close", cleanup1), e1.removeListener("close", cleanup1);
                            }
                            return r3.on("error", onerror1), e1.on("error", onerror1), r3.on("end", cleanup1), r3.on("close", cleanup1), e1.on("close", cleanup1), e1.emit("pipe", r3), e1;
                        };
                    },
                    862: function(e1, t3, r3) {
                        "use strict";
                        var n2 = r3(207).Buffer, i2 = n2.isEncoding || function(e1) {
                            switch((e1 = "" + e1) && e1.toLowerCase()){
                                case "hex":
                                case "utf8":
                                case "utf-8":
                                case "ascii":
                                case "binary":
                                case "base64":
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                case "raw":
                                    return !0;
                                default:
                                    return !1;
                            }
                        };
                        function _normalizeEncoding1(e1) {
                            var t3;
                            if (!e1) return "utf8";
                            for(;;)switch(e1){
                                case "utf8":
                                case "utf-8":
                                    return "utf8";
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    return "utf16le";
                                case "latin1":
                                case "binary":
                                    return "latin1";
                                case "base64":
                                case "ascii":
                                case "hex":
                                    return e1;
                                default:
                                    if (t3) return;
                                    e1 = ("" + e1).toLowerCase(), t3 = !0;
                            }
                        }
                        function normalizeEncoding1(e1) {
                            var t3 = _normalizeEncoding1(e1);
                            if ("string" != typeof t3 && (n2.isEncoding === i2 || !i2(e1))) throw Error("Unknown encoding: " + e1);
                            return t3 || e1;
                        }
                        function StringDecoder1(e1) {
                            var t3;
                            switch(this.encoding = normalizeEncoding1(e1), this.encoding){
                                case "utf16le":
                                    this.text = utf16Text1, this.end = utf16End1, t3 = 4;
                                    break;
                                case "utf8":
                                    this.fillLast = utf8FillLast1, t3 = 4;
                                    break;
                                case "base64":
                                    this.text = base64Text1, this.end = base64End1, t3 = 3;
                                    break;
                                default:
                                    this.write = simpleWrite1, this.end = simpleEnd1;
                                    return;
                            }
                            this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n2.allocUnsafe(t3);
                        }
                        function utf8CheckByte1(e1) {
                            return e1 <= 127 ? 0 : e1 >> 5 == 6 ? 2 : e1 >> 4 == 14 ? 3 : e1 >> 3 == 30 ? 4 : e1 >> 6 == 2 ? -1 : -2;
                        }
                        function utf8CheckIncomplete1(e1, t3, r3) {
                            var n2 = t3.length - 1;
                            if (n2 < r3) return 0;
                            var i2 = utf8CheckByte1(t3[n2]);
                            return i2 >= 0 ? (i2 > 0 && (e1.lastNeed = i2 - 1), i2) : --n2 < r3 || -2 === i2 ? 0 : (i2 = utf8CheckByte1(t3[n2])) >= 0 ? (i2 > 0 && (e1.lastNeed = i2 - 2), i2) : --n2 < r3 || -2 === i2 ? 0 : (i2 = utf8CheckByte1(t3[n2])) >= 0 ? (i2 > 0 && (2 === i2 ? i2 = 0 : e1.lastNeed = i2 - 3), i2) : 0;
                        }
                        function utf8CheckExtraBytes1(e1, t3, r3) {
                            if ((192 & t3[0]) != 128) return e1.lastNeed = 0, "�";
                            if (e1.lastNeed > 1 && t3.length > 1) {
                                if ((192 & t3[1]) != 128) return e1.lastNeed = 1, "�";
                                if (e1.lastNeed > 2 && t3.length > 2 && (192 & t3[2]) != 128) return e1.lastNeed = 2, "�";
                            }
                        }
                        function utf8FillLast1(e1) {
                            var t3 = this.lastTotal - this.lastNeed, r3 = utf8CheckExtraBytes1(this, e1, t3);
                            return void 0 !== r3 ? r3 : this.lastNeed <= e1.length ? (e1.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e1.copy(this.lastChar, t3, 0, e1.length), this.lastNeed -= e1.length);
                        }
                        function utf8Text1(e1, t3) {
                            var r3 = utf8CheckIncomplete1(this, e1, t3);
                            if (!this.lastNeed) return e1.toString("utf8", t3);
                            this.lastTotal = r3;
                            var n2 = e1.length - (r3 - this.lastNeed);
                            return e1.copy(this.lastChar, 0, n2), e1.toString("utf8", t3, n2);
                        }
                        function utf8End1(e1) {
                            var t3 = e1 && e1.length ? this.write(e1) : "";
                            return this.lastNeed ? t3 + "�" : t3;
                        }
                        function utf16Text1(e1, t3) {
                            if ((e1.length - t3) % 2 == 0) {
                                var r3 = e1.toString("utf16le", t3);
                                if (r3) {
                                    var n2 = r3.charCodeAt(r3.length - 1);
                                    if (n2 >= 55296 && n2 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e1[e1.length - 2], this.lastChar[1] = e1[e1.length - 1], r3.slice(0, -1);
                                }
                                return r3;
                            }
                            return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e1[e1.length - 1], e1.toString("utf16le", t3, e1.length - 1);
                        }
                        function utf16End1(e1) {
                            var t3 = e1 && e1.length ? this.write(e1) : "";
                            if (this.lastNeed) {
                                var r3 = this.lastTotal - this.lastNeed;
                                return t3 + this.lastChar.toString("utf16le", 0, r3);
                            }
                            return t3;
                        }
                        function base64Text1(e1, t3) {
                            var r3 = (e1.length - t3) % 3;
                            return 0 === r3 ? e1.toString("base64", t3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 === r3 ? this.lastChar[0] = e1[e1.length - 1] : (this.lastChar[0] = e1[e1.length - 2], this.lastChar[1] = e1[e1.length - 1]), e1.toString("base64", t3, e1.length - r3));
                        }
                        function base64End1(e1) {
                            var t3 = e1 && e1.length ? this.write(e1) : "";
                            return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
                        }
                        function simpleWrite1(e1) {
                            return e1.toString(this.encoding);
                        }
                        function simpleEnd1(e1) {
                            return e1 && e1.length ? this.write(e1) : "";
                        }
                        t3.s = StringDecoder1, StringDecoder1.prototype.write = function(e1) {
                            var t3, r3;
                            if (0 === e1.length) return "";
                            if (this.lastNeed) {
                                if (void 0 === (t3 = this.fillLast(e1))) return "";
                                r3 = this.lastNeed, this.lastNeed = 0;
                            } else r3 = 0;
                            return r3 < e1.length ? t3 ? t3 + this.text(e1, r3) : this.text(e1, r3) : t3 || "";
                        }, StringDecoder1.prototype.end = utf8End1, StringDecoder1.prototype.text = utf8Text1, StringDecoder1.prototype.fillLast = function(e1) {
                            if (this.lastNeed <= e1.length) return e1.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
                            e1.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e1.length), this.lastNeed -= e1.length;
                        };
                    },
                    777: function(e1) {
                        function deprecate1(e1, t3) {
                            if (config3("noDeprecation")) return e1;
                            var r3 = !1;
                            return function() {
                                if (!r3) {
                                    if (config3("throwDeprecation")) throw Error(t3);
                                    config3("traceDeprecation") ? console.trace(t3) : console.warn(t3), r3 = !0;
                                }
                                return e1.apply(this, arguments);
                            };
                        }
                        function config3(e1) {
                            try {
                                if (!__webpack_require__1.g.localStorage) return !1;
                            } catch (e1) {
                                return !1;
                            }
                            var t3 = __webpack_require__1.g.localStorage[e1];
                            return null != t3 && "true" === String(t3).toLowerCase();
                        }
                        e1.exports = deprecate1;
                    },
                    300: function(e1) {
                        "use strict";
                        e1.exports = __webpack_require__1(8764);
                    },
                    361: function(e1) {
                        "use strict";
                        e1.exports = __webpack_require__1(7187);
                    },
                    781: function(e1) {
                        "use strict";
                        e1.exports = __webpack_require__1(7187).EventEmitter;
                    },
                    837: function(e1) {
                        "use strict";
                        e1.exports = __webpack_require__1(9539);
                    }
                }, t3 = {};
                function __nccwpck_require__1(r3) {
                    var n2 = t3[r3];
                    if (void 0 !== n2) return n2.exports;
                    var i2 = t3[r3] = {
                        exports: {}
                    }, a10 = !0;
                    try {
                        e1[r3](i2, i2.exports, __nccwpck_require__1), a10 = !1;
                    } finally{
                        a10 && delete t3[r3];
                    }
                    return i2.exports;
                }
                __nccwpck_require__1.ab = __dirname1 + "/";
                var r3 = __nccwpck_require__1(552);
                module1.exports = r3;
            }();
        },
        1951: function(module) {
            var __dirname = "/";
            !function() {
                var __webpack_modules__ = {
                    965: function(__unused_webpack_module, exports) {
                        var indexOf = function(e1, t3) {
                            if (e1.indexOf) return e1.indexOf(t3);
                            for(var r3 = 0; r3 < e1.length; r3++)if (e1[r3] === t3) return r3;
                            return -1;
                        }, Object_keys = function(e1) {
                            if (Object.keys) return Object.keys(e1);
                            var t3 = [];
                            for(var r3 in e1)t3.push(r3);
                            return t3;
                        }, forEach = function(e1, t3) {
                            if (e1.forEach) return e1.forEach(t3);
                            for(var r3 = 0; r3 < e1.length; r3++)t3(e1[r3], r3, e1);
                        }, defineProp = function() {
                            try {
                                return Object.defineProperty({}, "_", {}), function(e1, t3, r3) {
                                    Object.defineProperty(e1, t3, {
                                        writable: !0,
                                        enumerable: !1,
                                        configurable: !0,
                                        value: r3
                                    });
                                };
                            } catch (e1) {
                                return function(e1, t3, r3) {
                                    e1[t3] = r3;
                                };
                            }
                        }(), globals = [
                            "Array",
                            "Boolean",
                            "Date",
                            "Error",
                            "EvalError",
                            "Function",
                            "Infinity",
                            "JSON",
                            "Math",
                            "NaN",
                            "Number",
                            "Object",
                            "RangeError",
                            "ReferenceError",
                            "RegExp",
                            "String",
                            "SyntaxError",
                            "TypeError",
                            "URIError",
                            "decodeURI",
                            "decodeURIComponent",
                            "encodeURI",
                            "encodeURIComponent",
                            "escape",
                            "eval",
                            "isFinite",
                            "isNaN",
                            "parseFloat",
                            "parseInt",
                            "undefined",
                            "unescape"
                        ];
                        function Context() {}
                        Context.prototype = {};
                        var Script = exports.Script = function(e1) {
                            if (!(this instanceof Script)) return new Script(e1);
                            this.code = e1;
                        };
                        Script.prototype.runInContext = function(e1) {
                            if (!(e1 instanceof Context)) throw TypeError("needs a 'context' argument.");
                            var t3 = document.createElement("iframe");
                            t3.style || (t3.style = {}), t3.style.display = "none", document.body.appendChild(t3);
                            var r3 = t3.contentWindow, n2 = r3.eval, o1 = r3.execScript;
                            !n2 && o1 && (o1.call(r3, "null"), n2 = r3.eval), forEach(Object_keys(e1), function(t3) {
                                r3[t3] = e1[t3];
                            }), forEach(globals, function(t3) {
                                e1[t3] && (r3[t3] = e1[t3]);
                            });
                            var c5 = Object_keys(r3), i2 = n2.call(r3, this.code);
                            return forEach(Object_keys(r3), function(t3) {
                                (t3 in e1 || -1 === indexOf(c5, t3)) && (e1[t3] = r3[t3]);
                            }), forEach(globals, function(t3) {
                                t3 in e1 || defineProp(e1, t3, r3[t3]);
                            }), document.body.removeChild(t3), i2;
                        }, Script.prototype.runInThisContext = function() {
                            return eval(this.code);
                        }, Script.prototype.runInNewContext = function(e1) {
                            var t3 = Script.createContext(e1), r3 = this.runInContext(t3);
                            return e1 && forEach(Object_keys(t3), function(r3) {
                                e1[r3] = t3[r3];
                            }), r3;
                        }, forEach(Object_keys(Script.prototype), function(e1) {
                            exports[e1] = Script[e1] = function(t3) {
                                var r3 = Script(t3);
                                return r3[e1].apply(r3, [].slice.call(arguments, 1));
                            };
                        }), exports.isContext = function(e1) {
                            return e1 instanceof Context;
                        }, exports.createScript = function(e1) {
                            return exports.Script(e1);
                        }, exports.createContext = Script.createContext = function(e1) {
                            var t3 = new Context;
                            return "object" == typeof e1 && forEach(Object_keys(e1), function(r3) {
                                t3[r3] = e1[r3];
                            }), t3;
                        };
                    }
                };
                "undefined" != typeof __nccwpck_require__ && (__nccwpck_require__.ab = __dirname + "/");
                var __webpack_exports__ = {};
                __webpack_modules__[965](0, __webpack_exports__), module.exports = __webpack_exports__;
            }();
        },
        4375: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            let promise1;
            module1.exports = 'function' == typeof queueMicrotask ? queueMicrotask.bind('undefined' != typeof window ? window : __webpack_require__1.g) : (cb1)=>(promise1 || (promise1 = Promise.resolve())).then(cb1).catch((err1)=>setTimeout(()=>{
                        throw err1;
                    }, 0));
        },
        9180: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            window.global = window, __webpack_require__1.g.fetch = window.fetch, module1.exports.Buffer = __webpack_require__1(8764).Buffer;
        },
        497: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            exports1.wasm2json = __webpack_require__1(3195), exports1.json2wasm = __webpack_require__1(4747), exports1.text2json = __webpack_require__1(9837), exports1.Iterator = __webpack_require__1(3804);
        },
        3804: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const Buffer1 = __webpack_require__1(1415).Buffer, leb1281 = __webpack_require__1(5548).unsigned, wasm2json1 = __webpack_require__1(3195), Pipe1 = __webpack_require__1(825), SECTIONS1 = [
                'custom',
                'type',
                'import',
                'function',
                'table',
                'memory',
                'global',
                'export',
                'start',
                'element',
                'code',
                'data'
            ];
            module1.exports = class {
                constructor(wasm1){
                    this._wasm = wasm1, this._sections = [], this._modified = !1;
                }
                get wasm() {
                    return this._modified && (this._wasm = Buffer1.concat(this._sections.concat(this._pipe.buffer)), this._modified = !1), this._wasm;
                }
                *[Symbol.iterator]() {
                    for(this._pipe = new Pipe1(this._wasm), this._sections = [
                        this._pipe.read(8)
                    ]; !this._pipe.end;){
                        const start1 = this._pipe.bytesRead, sectionType1 = this._pipe.read(1)[0], size1 = Number(leb1281.read(this._pipe)), body1 = this._pipe.read(size1), end1 = this._pipe.bytesRead, section1 = this._wasm.slice(start1, end1), index1 = this._sections.push(section1) - 1;
                        yield new Section1(sectionType1, body1, this, index1);
                    }
                }
                _update(index1, data1) {
                    this._modified = !0, this._sections[index1] = data1;
                }
            };
            class Section1 {
                constructor(sectionType1, section1, it1, index1){
                    this._it = it1, this._index = index1, this.type = SECTIONS1[sectionType1], this._type = sectionType1, this._section = section1;
                    const pipe1 = new Pipe1(section1);
                    'custom' !== this.type && (this.count = Number(leb1281.read(pipe1))), this._body = pipe1.buffer;
                }
                toJSON() {
                    return wasm2json1.sectionParsers[this.type](new Pipe1(this._section));
                }
                appendEntries(entries1) {
                    this.count += entries1.length, this._body = Buffer1.concat([
                        this._body
                    ].concat(entries1));
                    const bodyAndCount1 = Buffer1.concat([
                        leb1281.encode(this.count),
                        this._body
                    ]);
                    this._it._update(this._index, Buffer1.concat([
                        Buffer1.from([
                            this._type
                        ]),
                        leb1281.encode(bodyAndCount1.length),
                        bodyAndCount1
                    ]));
                }
            }
        },
        4747: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const Buffer1 = __webpack_require__1(1415).Buffer, leb1 = __webpack_require__1(5548), Stream1 = __webpack_require__1(825), OP_IMMEDIATES1 = __webpack_require__1(8575), _exports1 = module1.exports = (json1)=>_exports1.generate(json1).buffer, LANGUAGE_TYPES1 = _exports1.LANGUAGE_TYPES = {
                i32: 0x7f,
                i64: 0x7e,
                f32: 0x7d,
                f64: 0x7c,
                anyFunc: 0x70,
                func: 0x60,
                block_type: 0x40
            }, EXTERNAL_KIND1 = _exports1.EXTERNAL_KIND = {
                function: 0,
                table: 1,
                memory: 2,
                global: 3
            }, SECTION_IDS1 = _exports1.SECTION_IDS = {
                custom: 0,
                type: 1,
                import: 2,
                function: 3,
                table: 4,
                memory: 5,
                global: 6,
                export: 7,
                start: 8,
                element: 9,
                code: 10,
                data: 11
            }, OPCODES1 = _exports1.OPCODES = {
                unreachable: 0x0,
                nop: 0x1,
                block: 0x2,
                loop: 0x3,
                if: 0x4,
                else: 0x5,
                end: 0xb,
                br: 0xc,
                br_if: 0xd,
                br_table: 0xe,
                return: 0xf,
                call: 0x10,
                call_indirect: 0x11,
                drop: 0x1a,
                select: 0x1b,
                get_local: 0x20,
                set_local: 0x21,
                tee_local: 0x22,
                get_global: 0x23,
                set_global: 0x24,
                'i32.load': 0x28,
                'i64.load': 0x29,
                'f32.load': 0x2a,
                'f64.load': 0x2b,
                'i32.load8_s': 0x2c,
                'i32.load8_u': 0x2d,
                'i32.load16_s': 0x2e,
                'i32.load16_u': 0x2f,
                'i64.load8_s': 0x30,
                'i64.load8_u': 0x31,
                'i64.load16_s': 0x32,
                'i64.load16_u': 0x33,
                'i64.load32_s': 0x34,
                'i64.load32_u': 0x35,
                'i32.store': 0x36,
                'i64.store': 0x37,
                'f32.store': 0x38,
                'f64.store': 0x39,
                'i32.store8': 0x3a,
                'i32.store16': 0x3b,
                'i64.store8': 0x3c,
                'i64.store16': 0x3d,
                'i64.store32': 0x3e,
                current_memory: 0x3f,
                grow_memory: 0x40,
                'i32.const': 0x41,
                'i64.const': 0x42,
                'f32.const': 0x43,
                'f64.const': 0x44,
                'i32.eqz': 0x45,
                'i32.eq': 0x46,
                'i32.ne': 0x47,
                'i32.lt_s': 0x48,
                'i32.lt_u': 0x49,
                'i32.gt_s': 0x4a,
                'i32.gt_u': 0x4b,
                'i32.le_s': 0x4c,
                'i32.le_u': 0x4d,
                'i32.ge_s': 0x4e,
                'i32.ge_u': 0x4f,
                'i64.eqz': 0x50,
                'i64.eq': 0x51,
                'i64.ne': 0x52,
                'i64.lt_s': 0x53,
                'i64.lt_u': 0x54,
                'i64.gt_s': 0x55,
                'i64.gt_u': 0x56,
                'i64.le_s': 0x57,
                'i64.le_u': 0x58,
                'i64.ge_s': 0x59,
                'i64.ge_u': 0x5a,
                'f32.eq': 0x5b,
                'f32.ne': 0x5c,
                'f32.lt': 0x5d,
                'f32.gt': 0x5e,
                'f32.le': 0x5f,
                'f32.ge': 0x60,
                'f64.eq': 0x61,
                'f64.ne': 0x62,
                'f64.lt': 0x63,
                'f64.gt': 0x64,
                'f64.le': 0x65,
                'f64.ge': 0x66,
                'i32.clz': 0x67,
                'i32.ctz': 0x68,
                'i32.popcnt': 0x69,
                'i32.add': 0x6a,
                'i32.sub': 0x6b,
                'i32.mul': 0x6c,
                'i32.div_s': 0x6d,
                'i32.div_u': 0x6e,
                'i32.rem_s': 0x6f,
                'i32.rem_u': 0x70,
                'i32.and': 0x71,
                'i32.or': 0x72,
                'i32.xor': 0x73,
                'i32.shl': 0x74,
                'i32.shr_s': 0x75,
                'i32.shr_u': 0x76,
                'i32.rotl': 0x77,
                'i32.rotr': 0x78,
                'i64.clz': 0x79,
                'i64.ctz': 0x7a,
                'i64.popcnt': 0x7b,
                'i64.add': 0x7c,
                'i64.sub': 0x7d,
                'i64.mul': 0x7e,
                'i64.div_s': 0x7f,
                'i64.div_u': 0x80,
                'i64.rem_s': 0x81,
                'i64.rem_u': 0x82,
                'i64.and': 0x83,
                'i64.or': 0x84,
                'i64.xor': 0x85,
                'i64.shl': 0x86,
                'i64.shr_s': 0x87,
                'i64.shr_u': 0x88,
                'i64.rotl': 0x89,
                'i64.rotr': 0x8a,
                'f32.abs': 0x8b,
                'f32.neg': 0x8c,
                'f32.ceil': 0x8d,
                'f32.floor': 0x8e,
                'f32.trunc': 0x8f,
                'f32.nearest': 0x90,
                'f32.sqrt': 0x91,
                'f32.add': 0x92,
                'f32.sub': 0x93,
                'f32.mul': 0x94,
                'f32.div': 0x95,
                'f32.min': 0x96,
                'f32.max': 0x97,
                'f32.copysign': 0x98,
                'f64.abs': 0x99,
                'f64.neg': 0x9a,
                'f64.ceil': 0x9b,
                'f64.floor': 0x9c,
                'f64.trunc': 0x9d,
                'f64.nearest': 0x9e,
                'f64.sqrt': 0x9f,
                'f64.add': 0xa0,
                'f64.sub': 0xa1,
                'f64.mul': 0xa2,
                'f64.div': 0xa3,
                'f64.min': 0xa4,
                'f64.max': 0xa5,
                'f64.copysign': 0xa6,
                'i32.wrap/i64': 0xa7,
                'i32.trunc_s/f32': 0xa8,
                'i32.trunc_u/f32': 0xa9,
                'i32.trunc_s/f64': 0xaa,
                'i32.trunc_u/f64': 0xab,
                'i64.extend_s/i32': 0xac,
                'i64.extend_u/i32': 0xad,
                'i64.trunc_s/f32': 0xae,
                'i64.trunc_u/f32': 0xaf,
                'i64.trunc_s/f64': 0xb0,
                'i64.trunc_u/f64': 0xb1,
                'f32.convert_s/i32': 0xb2,
                'f32.convert_u/i32': 0xb3,
                'f32.convert_s/i64': 0xb4,
                'f32.convert_u/i64': 0xb5,
                'f32.demote/f64': 0xb6,
                'f64.convert_s/i32': 0xb7,
                'f64.convert_u/i32': 0xb8,
                'f64.convert_s/i64': 0xb9,
                'f64.convert_u/i64': 0xba,
                'f64.promote/f32': 0xbb,
                'i32.reinterpret/f32': 0xbc,
                'i64.reinterpret/f64': 0xbd,
                'f32.reinterpret/i32': 0xbe,
                'f64.reinterpret/i64': 0xbf
            };
            _exports1.typeGenerators = {
                function: (json1, stream1)=>{
                    leb1.unsigned.write(json1, stream1);
                },
                table: (json1, stream1)=>{
                    stream1.write([
                        LANGUAGE_TYPES1[json1.elementType]
                    ]), _exports1.typeGenerators.memory(json1.limits, stream1);
                },
                global: (json1, stream1)=>{
                    stream1.write([
                        LANGUAGE_TYPES1[json1.contentType]
                    ]), stream1.write([
                        json1.mutability
                    ]);
                },
                memory: (json1, stream1)=>{
                    leb1.unsigned.write(Number(void 0 !== json1.maximum), stream1), leb1.unsigned.write(json1.intial, stream1), void 0 !== json1.maximum && leb1.unsigned.write(json1.maximum, stream1);
                },
                initExpr: (json1, stream1)=>{
                    _exports1.generateOp(json1, stream1), _exports1.generateOp({
                        name: 'end',
                        type: 'void'
                    }, stream1);
                }
            }, _exports1.immediataryGenerators = {
                varuint1: (json1, stream1)=>(stream1.write([
                        json1
                    ]), stream1),
                varuint32: (json1, stream1)=>(leb1.unsigned.write(json1, stream1), stream1),
                varint32: (json1, stream1)=>(leb1.signed.write(json1, stream1), stream1),
                varint64: (json1, stream1)=>(leb1.signed.write(json1, stream1), stream1),
                uint32: (json1, stream1)=>(stream1.write(json1), stream1),
                uint64: (json1, stream1)=>(stream1.write(json1), stream1),
                block_type: (json1, stream1)=>(stream1.write([
                        LANGUAGE_TYPES1[json1]
                    ]), stream1),
                br_table: (json1, stream1)=>{
                    for (let target1 of (leb1.unsigned.write(json1.targets.length, stream1), json1.targets))leb1.unsigned.write(target1, stream1);
                    return leb1.unsigned.write(json1.defaultTarget, stream1), stream1;
                },
                call_indirect: (json1, stream1)=>(leb1.unsigned.write(json1.index, stream1), stream1.write([
                        json1.reserved
                    ]), stream1),
                memory_immediate: (json1, stream1)=>(leb1.unsigned.write(json1.flags, stream1), leb1.unsigned.write(json1.offset, stream1), stream1)
            };
            const entryGenerators1 = {
                type: (entry1, stream1 = new Stream1())=>{
                    stream1.write([
                        LANGUAGE_TYPES1[entry1.form]
                    ]);
                    const len3 = entry1.params.length;
                    return leb1.unsigned.write(len3, stream1), 0 !== len3 && stream1.write(entry1.params.map((type1)=>LANGUAGE_TYPES1[type1])), stream1.write([
                        entry1.return_type ? 1 : 0
                    ]), entry1.return_type && stream1.write([
                        LANGUAGE_TYPES1[entry1.return_type]
                    ]), stream1.buffer;
                },
                import: (entry1, stream1 = new Stream1())=>{
                    leb1.unsigned.write(entry1.moduleStr.length, stream1), stream1.write(entry1.moduleStr), leb1.unsigned.write(entry1.fieldStr.length, stream1), stream1.write(entry1.fieldStr), stream1.write([
                        EXTERNAL_KIND1[entry1.kind]
                    ]), _exports1.typeGenerators[entry1.kind](entry1.type, stream1);
                },
                function: (entry1, stream1 = new Stream1())=>(leb1.unsigned.write(entry1, stream1), stream1.buffer),
                table: _exports1.typeGenerators.table,
                global: (entry1, stream1 = new Stream1())=>(_exports1.typeGenerators.global(entry1.type, stream1), _exports1.typeGenerators.initExpr(entry1.init, stream1), stream1),
                memory: _exports1.typeGenerators.memory,
                export: (entry1, stream1 = new Stream1())=>{
                    const fieldStr1 = Buffer1.from(entry1.field_str), strLen1 = fieldStr1.length;
                    return leb1.unsigned.write(strLen1, stream1), stream1.write(fieldStr1), stream1.write([
                        EXTERNAL_KIND1[entry1.kind]
                    ]), leb1.unsigned.write(entry1.index, stream1), stream1;
                },
                element: (entry1, stream1 = new Stream1())=>{
                    for (let elem1 of (leb1.unsigned.write(entry1.index, stream1), _exports1.typeGenerators.initExpr(entry1.offset, stream1), leb1.unsigned.write(entry1.elements.length, stream1), entry1.elements))leb1.unsigned.write(elem1, stream1);
                    return stream1;
                },
                code: (entry1, stream1 = new Stream1())=>{
                    let codeStream1 = new Stream1();
                    for (let local1 of (leb1.unsigned.write(entry1.locals.length, codeStream1), entry1.locals))leb1.unsigned.write(local1.count, codeStream1), codeStream1.write([
                        LANGUAGE_TYPES1[local1.type]
                    ]);
                    for (let op1 of entry1.code)_exports1.generateOp(op1, codeStream1);
                    return leb1.unsigned.write(codeStream1.bytesWrote, stream1), stream1.write(codeStream1.buffer), stream1;
                },
                data: (entry1, stream1 = new Stream1())=>(leb1.unsigned.write(entry1.index, stream1), _exports1.typeGenerators.initExpr(entry1.offset, stream1), leb1.unsigned.write(entry1.data.length, stream1), stream1.write(entry1.data), stream1)
            };
            _exports1.entryGenerators = entryGenerators1, _exports1.generateSection = function(json1, stream1 = new Stream1()) {
                const name1 = json1.name, payload1 = new Stream1();
                if (stream1.write([
                    SECTION_IDS1[name1]
                ]), 'custom' === name1) leb1.unsigned.write(json1.sectionName.length, payload1), payload1.write(json1.sectionName), payload1.write(json1.payload);
                else if ('start' === name1) leb1.unsigned.write(json1.index, payload1);
                else for (let entry1 of (leb1.unsigned.write(json1.entries.length, payload1), json1.entries))entryGenerators1[name1](entry1, payload1);
                return leb1.unsigned.write(payload1.bytesWrote, stream1), stream1.write(payload1.buffer), stream1;
            }, _exports1.generate = (json1, stream1 = new Stream1())=>{
                const [preamble1, ...rest1] = json1;
                for (let item1 of (_exports1.generatePreramble(preamble1, stream1), rest1))_exports1.generateSection(item1, stream1);
                return stream1;
            }, _exports1.generatePreramble = (json1, stream1 = new Stream1())=>(stream1.write(json1.magic), stream1.write(json1.version), stream1), _exports1.generateOp = (json1, stream1 = new Stream1())=>{
                let name1 = json1.name;
                void 0 !== json1.return_type && (name1 = json1.return_type + '.' + name1), stream1.write([
                    OPCODES1[name1]
                ]);
                const immediates1 = OP_IMMEDIATES1['const' === json1.name ? json1.return_type : json1.name];
                return immediates1 && _exports1.immediataryGenerators[immediates1](json1.immediates, stream1), stream1;
            };
        },
        825: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const Buffer1 = __webpack_require__1(9509).Buffer;
            module1.exports = class {
                constructor(buf1 = Buffer1.from([])){
                    this.buffer = buf1, this._bytesRead = 0, this._bytesWrote = 0;
                }
                read(num1) {
                    this._bytesRead += num1;
                    const data1 = this.buffer.slice(0, num1);
                    return this.buffer = this.buffer.slice(num1), data1;
                }
                write(buf1) {
                    buf1 = Buffer1.from(buf1), this._bytesWrote += buf1.length, this.buffer = Buffer1.concat([
                        this.buffer,
                        buf1
                    ]);
                }
                get end() {
                    return !this.buffer.length;
                }
                get bytesRead() {
                    return this._bytesRead;
                }
                get bytesWrote() {
                    return this._bytesWrote;
                }
            };
        },
        1415: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            __webpack_require__1.g.fetch = window.fetch, __webpack_require__1(8764).Buffer;
        },
        9837: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            const immediates1 = __webpack_require__1(8575);
            function immediataryParser1(type1, txt1) {
                const json1 = {};
                switch(type1){
                    case 'br_table':
                        const dests1 = [];
                        for(;;){
                            let dest1 = txt1[0];
                            if (isNaN(dest1)) break;
                            txt1.shift(), dests1.push(dest1);
                        }
                        return dests1;
                    case 'call_indirect':
                        return json1.index = txt1.shift(), json1.reserved = 0, json1;
                    case 'memory_immediate':
                        return json1.flags = txt1.shift(), json1.offset = txt1.shift(), json1;
                    default:
                        return txt1.shift();
                }
            }
            module1.exports = (text1)=>{
                const json1 = [], textArray1 = text1.split(/\s|\n/);
                for(; textArray1.length;){
                    const textOp1 = textArray1.shift(), jsonOp1 = {};
                    let [type1, name1] = textOp1.split('.');
                    void 0 === name1 ? name1 = type1 : jsonOp1.return_type = type1, jsonOp1.name = name1;
                    const immediate1 = immediates1['const' === jsonOp1.name ? jsonOp1.return_type : jsonOp1.name];
                    immediate1 && (jsonOp1.immediates = immediataryParser1(immediate1, textArray1)), json1.push(jsonOp1);
                }
                return json1;
            };
        },
        3195: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            var Buffer1 = __webpack_require__1(8764).Buffer;
            const leb1 = __webpack_require__1(5548), Stream1 = __webpack_require__1(825), OP_IMMEDIATES1 = __webpack_require__1(8575), _exports1 = module1.exports = (buf1, filter1)=>{
                const stream1 = new Stream1(buf1);
                return _exports1.parse(stream1, filter1);
            }, LANGUAGE_TYPES1 = _exports1.LANGUAGE_TYPES = {
                0x7f: 'i32',
                0x7e: 'i64',
                0x7d: 'f32',
                0x7c: 'f64',
                0x70: 'anyFunc',
                0x60: 'func',
                0x40: 'block_type'
            }, EXTERNAL_KIND1 = _exports1.EXTERNAL_KIND = {
                0: 'function',
                1: 'table',
                2: 'memory',
                3: 'global'
            };
            _exports1.parsePreramble = (stream1)=>{
                const obj1 = {};
                return obj1.name = 'preramble', obj1.magic = [
                    ...stream1.read(4)
                ], obj1.version = [
                    ...stream1.read(4)
                ], obj1;
            }, _exports1.parseSectionHeader = (stream1)=>{
                const id1 = stream1.read(1)[0], size1 = leb1.unsigned.readBn(stream1).toNumber();
                return {
                    id: id1,
                    name: SECTION_IDS1[id1],
                    size: size1
                };
            };
            const OPCODES1 = _exports1.OPCODES = {
                0x0: 'unreachable',
                0x1: 'nop',
                0x2: 'block',
                0x3: 'loop',
                0x4: 'if',
                0x5: 'else',
                0xb: 'end',
                0xc: 'br',
                0xd: 'br_if',
                0xe: 'br_table',
                0xf: 'return',
                0x10: 'call',
                0x11: 'call_indirect',
                0x1a: 'drop',
                0x1b: 'select',
                0x20: 'get_local',
                0x21: 'set_local',
                0x22: 'tee_local',
                0x23: 'get_global',
                0x24: 'set_global',
                0x28: 'i32.load',
                0x29: 'i64.load',
                0x2a: 'f32.load',
                0x2b: 'f64.load',
                0x2c: 'i32.load8_s',
                0x2d: 'i32.load8_u',
                0x2e: 'i32.load16_s',
                0x2f: 'i32.load16_u',
                0x30: 'i64.load8_s',
                0x31: 'i64.load8_u',
                0x32: 'i64.load16_s',
                0x33: 'i64.load16_u',
                0x34: 'i64.load32_s',
                0x35: 'i64.load32_u',
                0x36: 'i32.store',
                0x37: 'i64.store',
                0x38: 'f32.store',
                0x39: 'f64.store',
                0x3a: 'i32.store8',
                0x3b: 'i32.store16',
                0x3c: 'i64.store8',
                0x3d: 'i64.store16',
                0x3e: 'i64.store32',
                0x3f: 'current_memory',
                0x40: 'grow_memory',
                0x41: 'i32.const',
                0x42: 'i64.const',
                0x43: 'f32.const',
                0x44: 'f64.const',
                0x45: 'i32.eqz',
                0x46: 'i32.eq',
                0x47: 'i32.ne',
                0x48: 'i32.lt_s',
                0x49: 'i32.lt_u',
                0x4a: 'i32.gt_s',
                0x4b: 'i32.gt_u',
                0x4c: 'i32.le_s',
                0x4d: 'i32.le_u',
                0x4e: 'i32.ge_s',
                0x4f: 'i32.ge_u',
                0x50: 'i64.eqz',
                0x51: 'i64.eq',
                0x52: 'i64.ne',
                0x53: 'i64.lt_s',
                0x54: 'i64.lt_u',
                0x55: 'i64.gt_s',
                0x56: 'i64.gt_u',
                0x57: 'i64.le_s',
                0x58: 'i64.le_u',
                0x59: 'i64.ge_s',
                0x5a: 'i64.ge_u',
                0x5b: 'f32.eq',
                0x5c: 'f32.ne',
                0x5d: 'f32.lt',
                0x5e: 'f32.gt',
                0x5f: 'f32.le',
                0x60: 'f32.ge',
                0x61: 'f64.eq',
                0x62: 'f64.ne',
                0x63: 'f64.lt',
                0x64: 'f64.gt',
                0x65: 'f64.le',
                0x66: 'f64.ge',
                0x67: 'i32.clz',
                0x68: 'i32.ctz',
                0x69: 'i32.popcnt',
                0x6a: 'i32.add',
                0x6b: 'i32.sub',
                0x6c: 'i32.mul',
                0x6d: 'i32.div_s',
                0x6e: 'i32.div_u',
                0x6f: 'i32.rem_s',
                0x70: 'i32.rem_u',
                0x71: 'i32.and',
                0x72: 'i32.or',
                0x73: 'i32.xor',
                0x74: 'i32.shl',
                0x75: 'i32.shr_s',
                0x76: 'i32.shr_u',
                0x77: 'i32.rotl',
                0x78: 'i32.rotr',
                0x79: 'i64.clz',
                0x7a: 'i64.ctz',
                0x7b: 'i64.popcnt',
                0x7c: 'i64.add',
                0x7d: 'i64.sub',
                0x7e: 'i64.mul',
                0x7f: 'i64.div_s',
                0x80: 'i64.div_u',
                0x81: 'i64.rem_s',
                0x82: 'i64.rem_u',
                0x83: 'i64.and',
                0x84: 'i64.or',
                0x85: 'i64.xor',
                0x86: 'i64.shl',
                0x87: 'i64.shr_s',
                0x88: 'i64.shr_u',
                0x89: 'i64.rotl',
                0x8a: 'i64.rotr',
                0x8b: 'f32.abs',
                0x8c: 'f32.neg',
                0x8d: 'f32.ceil',
                0x8e: 'f32.floor',
                0x8f: 'f32.trunc',
                0x90: 'f32.nearest',
                0x91: 'f32.sqrt',
                0x92: 'f32.add',
                0x93: 'f32.sub',
                0x94: 'f32.mul',
                0x95: 'f32.div',
                0x96: 'f32.min',
                0x97: 'f32.max',
                0x98: 'f32.copysign',
                0x99: 'f64.abs',
                0x9a: 'f64.neg',
                0x9b: 'f64.ceil',
                0x9c: 'f64.floor',
                0x9d: 'f64.trunc',
                0x9e: 'f64.nearest',
                0x9f: 'f64.sqrt',
                0xa0: 'f64.add',
                0xa1: 'f64.sub',
                0xa2: 'f64.mul',
                0xa3: 'f64.div',
                0xa4: 'f64.min',
                0xa5: 'f64.max',
                0xa6: 'f64.copysign',
                0xa7: 'i32.wrap/i64',
                0xa8: 'i32.trunc_s/f32',
                0xa9: 'i32.trunc_u/f32',
                0xaa: 'i32.trunc_s/f64',
                0xab: 'i32.trunc_u/f64',
                0xac: 'i64.extend_s/i32',
                0xad: 'i64.extend_u/i32',
                0xae: 'i64.trunc_s/f32',
                0xaf: 'i64.trunc_u/f32',
                0xb0: 'i64.trunc_s/f64',
                0xb1: 'i64.trunc_u/f64',
                0xb2: 'f32.convert_s/i32',
                0xb3: 'f32.convert_u/i32',
                0xb4: 'f32.convert_s/i64',
                0xb5: 'f32.convert_u/i64',
                0xb6: 'f32.demote/f64',
                0xb7: 'f64.convert_s/i32',
                0xb8: 'f64.convert_u/i32',
                0xb9: 'f64.convert_s/i64',
                0xba: 'f64.convert_u/i64',
                0xbb: 'f64.promote/f32',
                0xbc: 'i32.reinterpret/f32',
                0xbd: 'i64.reinterpret/f64',
                0xbe: 'f32.reinterpret/i32',
                0xbf: 'f64.reinterpret/i64'
            }, SECTION_IDS1 = _exports1.SECTION_IDS = {
                0: 'custom',
                1: 'type',
                2: 'import',
                3: 'function',
                4: 'table',
                5: 'memory',
                6: 'global',
                7: 'export',
                8: 'start',
                9: 'element',
                10: 'code',
                11: 'data'
            };
            _exports1.immediataryParsers = {
                varuint1: (stream1)=>{
                    const int11 = stream1.read(1)[0];
                    return int11;
                },
                varuint32: (stream1)=>{
                    const int321 = leb1.unsigned.read(stream1);
                    return int321;
                },
                varint32: (stream1)=>{
                    const int321 = leb1.signed.read(stream1);
                    return int321;
                },
                varint64: (stream1)=>{
                    const int641 = leb1.signed.read(stream1);
                    return int641;
                },
                uint32: (stream1)=>[
                        ...stream1.read(4)
                    ],
                uint64: (stream1)=>[
                        ...stream1.read(8)
                    ],
                block_type: (stream1)=>{
                    const type1 = stream1.read(1)[0];
                    return LANGUAGE_TYPES1[type1];
                },
                br_table: (stream1)=>{
                    const json1 = {
                        targets: []
                    }, num1 = leb1.unsigned.readBn(stream1).toNumber();
                    for(let i2 = 0; i2 < num1; i2++){
                        const target1 = leb1.unsigned.readBn(stream1).toNumber();
                        json1.targets.push(target1);
                    }
                    return json1.defaultTarget = leb1.unsigned.readBn(stream1).toNumber(), json1;
                },
                call_indirect: (stream1)=>{
                    const json1 = {};
                    return json1.index = leb1.unsigned.readBn(stream1).toNumber(), json1.reserved = stream1.read(1)[0], json1;
                },
                memory_immediate: (stream1)=>{
                    const json1 = {};
                    return json1.flags = leb1.unsigned.readBn(stream1).toNumber(), json1.offset = leb1.unsigned.readBn(stream1).toNumber(), json1;
                }
            }, _exports1.typeParsers = {
                function: (stream1)=>leb1.unsigned.readBn(stream1).toNumber(),
                table: (stream1)=>{
                    const entry1 = {}, type1 = stream1.read(1)[0];
                    return entry1.elementType = LANGUAGE_TYPES1[type1], entry1.limits = _exports1.typeParsers.memory(stream1), entry1;
                },
                global: (stream1)=>{
                    const global1 = {};
                    let type1 = stream1.read(1)[0];
                    return global1.contentType = LANGUAGE_TYPES1[type1], global1.mutability = stream1.read(1)[0], global1;
                },
                memory: (stream1)=>{
                    const limits1 = {};
                    return limits1.flags = leb1.unsigned.readBn(stream1).toNumber(), limits1.intial = leb1.unsigned.readBn(stream1).toNumber(), 1 === limits1.flags && (limits1.maximum = leb1.unsigned.readBn(stream1).toNumber()), limits1;
                },
                initExpr: (stream1)=>{
                    const op1 = _exports1.parseOp(stream1);
                    return stream1.read(1), op1;
                }
            };
            const sectionParsers1 = _exports1.sectionParsers = {
                custom: (stream1, header1)=>{
                    const json1 = {
                        name: 'custom'
                    }, section1 = new Stream1(stream1.read(header1.size)), nameLen1 = leb1.unsigned.readBn(section1).toNumber(), name1 = section1.read(nameLen1);
                    return json1.sectionName = Buffer1.from(name1).toString(), json1.payload = [
                        ...section1.buffer
                    ], json1;
                },
                type: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'type',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        let type1 = stream1.read(1)[0];
                        const entry1 = {
                            form: LANGUAGE_TYPES1[type1],
                            params: []
                        }, paramCount1 = leb1.unsigned.readBn(stream1).toNumber();
                        for(let q3 = 0; q3 < paramCount1; q3++){
                            const type1 = stream1.read(1)[0];
                            entry1.params.push(LANGUAGE_TYPES1[type1]);
                        }
                        const numOfReturns1 = leb1.unsigned.readBn(stream1).toNumber();
                        numOfReturns1 && (type1 = stream1.read(1)[0], entry1.return_type = LANGUAGE_TYPES1[type1]), json1.entries.push(entry1);
                    }
                    return json1;
                },
                import: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'import',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const entry1 = {}, moduleLen1 = leb1.unsigned.readBn(stream1).toNumber();
                        entry1.moduleStr = Buffer1.from(stream1.read(moduleLen1)).toString();
                        const fieldLen1 = leb1.unsigned.readBn(stream1).toNumber();
                        entry1.fieldStr = Buffer1.from(stream1.read(fieldLen1)).toString();
                        const kind1 = stream1.read(1)[0];
                        entry1.kind = EXTERNAL_KIND1[kind1], entry1.type = _exports1.typeParsers[entry1.kind](stream1), json1.entries.push(entry1);
                    }
                    return json1;
                },
                function: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'function',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const entry1 = leb1.unsigned.readBn(stream1).toNumber();
                        json1.entries.push(entry1);
                    }
                    return json1;
                },
                table: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'table',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const entry1 = _exports1.typeParsers.table(stream1);
                        json1.entries.push(entry1);
                    }
                    return json1;
                },
                memory: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'memory',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const entry1 = _exports1.typeParsers.memory(stream1);
                        json1.entries.push(entry1);
                    }
                    return json1;
                },
                global: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'global',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const entry1 = {};
                        entry1.type = _exports1.typeParsers.global(stream1), entry1.init = _exports1.typeParsers.initExpr(stream1), json1.entries.push(entry1);
                    }
                    return json1;
                },
                export: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'export',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const strLength1 = leb1.unsigned.readBn(stream1).toNumber(), entry1 = {};
                        entry1.field_str = Buffer1.from(stream1.read(strLength1)).toString();
                        const kind1 = stream1.read(1)[0];
                        entry1.kind = EXTERNAL_KIND1[kind1], entry1.index = leb1.unsigned.readBn(stream1).toNumber(), json1.entries.push(entry1);
                    }
                    return json1;
                },
                start: (stream1)=>{
                    const json1 = {
                        name: 'start'
                    };
                    return json1.index = leb1.unsigned.readBn(stream1).toNumber(), json1;
                },
                element: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'element',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const entry1 = {
                            elements: []
                        };
                        entry1.index = leb1.unsigned.readBn(stream1).toNumber(), entry1.offset = _exports1.typeParsers.initExpr(stream1);
                        const numElem1 = leb1.unsigned.readBn(stream1).toNumber();
                        for(let i2 = 0; i2 < numElem1; i2++){
                            const elem1 = leb1.unsigned.readBn(stream1).toNumber();
                            entry1.elements.push(elem1);
                        }
                        json1.entries.push(entry1);
                    }
                    return json1;
                },
                code: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'code',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const codeBody1 = {
                            locals: [],
                            code: []
                        };
                        let bodySize1 = leb1.unsigned.readBn(stream1).toNumber();
                        const endBytes1 = stream1.bytesRead + bodySize1, localCount1 = leb1.unsigned.readBn(stream1).toNumber();
                        for(let q3 = 0; q3 < localCount1; q3++){
                            const local1 = {};
                            local1.count = leb1.unsigned.readBn(stream1).toNumber();
                            const type1 = stream1.read(1)[0];
                            local1.type = LANGUAGE_TYPES1[type1], codeBody1.locals.push(local1);
                        }
                        for(; stream1.bytesRead < endBytes1;){
                            const op1 = _exports1.parseOp(stream1);
                            codeBody1.code.push(op1);
                        }
                        json1.entries.push(codeBody1);
                    }
                    return json1;
                },
                data: (stream1)=>{
                    const numberOfEntries1 = leb1.unsigned.readBn(stream1).toNumber(), json1 = {
                        name: 'data',
                        entries: []
                    };
                    for(let i2 = 0; i2 < numberOfEntries1; i2++){
                        const entry1 = {};
                        entry1.index = leb1.unsigned.readBn(stream1).toNumber(), entry1.offset = _exports1.typeParsers.initExpr(stream1);
                        const segmentSize1 = leb1.unsigned.readBn(stream1).toNumber();
                        entry1.data = [
                            ...stream1.read(segmentSize1)
                        ], json1.entries.push(entry1);
                    }
                    return json1;
                }
            };
            _exports1.parseOp = (stream1)=>{
                const json1 = {}, op1 = stream1.read(1)[0], fullName1 = OPCODES1[op1];
                let [type1, name1] = fullName1.split('.');
                void 0 === name1 ? name1 = type1 : json1.return_type = type1, json1.name = name1;
                const immediates1 = OP_IMMEDIATES1['const' === name1 ? type1 : name1];
                return immediates1 && (json1.immediates = _exports1.immediataryParsers[immediates1](stream1)), json1;
            }, _exports1.parse = (stream1, filter1)=>{
                const preramble1 = _exports1.parsePreramble(stream1), json1 = [
                    preramble1
                ];
                for(; !stream1.end;){
                    const header1 = _exports1.parseSectionHeader(stream1);
                    json1.push(sectionParsers1[header1.name](stream1, header1));
                }
                return json1;
            };
        },
        8060: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            const toolkit1 = __webpack_require__1(497), text2json1 = toolkit1.text2json, SECTION_IDS1 = __webpack_require__1(4747).SECTION_IDS, defaultCostTable1 = __webpack_require__1(5936);
            function getCost1(json1, costTable1 = {}, defaultCost1 = 0) {
                let cost1 = 0;
                if (defaultCost1 = void 0 !== costTable1.DEFAULT ? costTable1.DEFAULT : 0, Array.isArray(json1)) json1.forEach((el1)=>{
                    cost1 += getCost1(el1, costTable1);
                });
                else if ('object' == typeof json1) for(const propName1 in json1){
                    const propCost1 = costTable1[propName1];
                    propCost1 && (cost1 += getCost1(json1[propName1], propCost1, defaultCost1));
                }
                else cost1 = void 0 === costTable1[json1] ? defaultCost1 : costTable1[json1];
                return cost1;
            }
            function meterCodeEntry1(entry1, costTable1, meterFuncIndex1, meterType1, cost1) {
                function meteringStatement1(cost1, meteringImportIndex1) {
                    return text2json1(`${meterType1}.const ${cost1} call ${meteringImportIndex1}`);
                }
                function remapOp1(op1, funcIndex1) {
                    'call' === op1.name && op1.immediates >= funcIndex1 && (op1.immediates = (++op1.immediates).toString());
                }
                function meterTheMeteringStatement1() {
                    const code1 = meteringStatement1(0, 0);
                    return code1.reduce((sum1, op1)=>sum1 + getCost1(op1.name, costTable1.code), 0);
                }
                const branchingOps1 = new Set([
                    'grow_memory',
                    'end',
                    'br',
                    'br_table',
                    'br_if',
                    'if',
                    'else',
                    'return',
                    'loop'
                ]), meteringOverHead1 = meterTheMeteringStatement1();
                let code1 = entry1.code.slice(), meteredCode1 = [];
                for(cost1 += getCost1(entry1.locals, costTable1.local); code1.length;){
                    let i2 = 0;
                    for(;;){
                        const op1 = code1[i2++];
                        if (remapOp1(op1, meterFuncIndex1), cost1 += getCost1(op1.name, costTable1.code), branchingOps1.has(op1.name)) break;
                    }
                    0 !== cost1 && (cost1 += meteringOverHead1, meteredCode1 = meteredCode1.concat(meteringStatement1(cost1, meterFuncIndex1))), meteredCode1 = meteredCode1.concat(code1.slice(0, i2)), code1 = code1.slice(i2), cost1 = 0;
                }
                return entry1.code = meteredCode1, entry1;
            }
            exports1.meterJSON = (json1, opts1)=>{
                let functionModule1, typeModule1;
                function findSection1(module1, sectionName1) {
                    return module1.find((section1)=>section1.name === sectionName1);
                }
                function createSection1(module1, name1) {
                    const newSectionId1 = SECTION_IDS1[name1];
                    for(let index1 in module1){
                        const section1 = module1[index1], sectionId1 = SECTION_IDS1[section1.name];
                        if (sectionId1 && newSectionId1 < sectionId1) {
                            module1.splice(index1, 0, {
                                name: name1,
                                entries: []
                            });
                            return;
                        }
                    }
                }
                let funcIndex1 = 0, { costTable: costTable1 , moduleStr: moduleStr1 , fieldStr: fieldStr1 , meterType: meterType1  } = opts1;
                costTable1 || (costTable1 = defaultCostTable1), moduleStr1 || (moduleStr1 = 'metering'), fieldStr1 || (fieldStr1 = 'usegas'), meterType1 || (meterType1 = 'i32'), findSection1(json1, 'type') || createSection1(json1, 'type'), findSection1(json1, 'import') || createSection1(json1, 'import');
                const importJson1 = {
                    moduleStr: moduleStr1,
                    fieldStr: fieldStr1,
                    kind: 'function'
                }, importType1 = {
                    form: 'func',
                    params: [
                        meterType1
                    ]
                };
                for (let section1 of json1 = json1.slice(0))switch((section1 = Object.assign(section1)).name){
                    case 'type':
                        importJson1.type = section1.entries.push(importType1) - 1, typeModule1 = section1;
                        break;
                    case 'function':
                        functionModule1 = section1;
                        break;
                    case 'import':
                        for (const entry1 of section1.entries){
                            if (entry1.moduleStr === moduleStr1 && entry1.fieldStr === fieldStr1) throw Error('importing metering function is not allowed');
                            'function' === entry1.kind && funcIndex1++;
                        }
                        section1.entries.push(importJson1);
                        break;
                    case 'export':
                        for (const entry1 of section1.entries)'function' === entry1.kind && entry1.index >= funcIndex1 && entry1.index++;
                        break;
                    case 'element':
                        for (const entry1 of section1.entries)entry1.elements = entry1.elements.map((el1)=>el1 >= funcIndex1 ? ++el1 : el1);
                        break;
                    case 'start':
                        section1.index >= funcIndex1 && section1.index++;
                        break;
                    case 'code':
                        for(const i2 in section1.entries){
                            const entry1 = section1.entries[i2], typeIndex1 = functionModule1.entries[i2], type1 = typeModule1.entries[typeIndex1], cost1 = getCost1(type1, costTable1.type);
                            meterCodeEntry1(entry1, costTable1.code, funcIndex1, meterType1, cost1);
                        }
                }
                return json1;
            }, exports1.meterWASM = (wasm1, opts1 = {})=>{
                let json1 = toolkit1.wasm2json(wasm1);
                return json1 = exports1.meterJSON(json1, opts1), toolkit1.json2wasm(json1);
            };
        },
        9967: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            module1.exports = runParallelLimit1;
            const queueMicrotask1 = __webpack_require__1(4375);
            function runParallelLimit1(tasks1, limit1, cb1) {
                let results1, len3, pending1, keys1, isErrored1, next1;
                if ('number' != typeof limit1) throw Error('second argument must be a Number');
                let isSync1 = !0;
                function done1(err1) {
                    function end1() {
                        cb1 && cb1(err1, results1), cb1 = null;
                    }
                    isSync1 ? queueMicrotask1(end1) : end1();
                }
                function each1(i2, err1, result1) {
                    if (results1[i2] = result1, err1 && (isErrored1 = !0), 0 == --pending1 || err1) done1(err1);
                    else if (!isErrored1 && next1 < len3) {
                        let key1;
                        keys1 ? (key1 = keys1[next1], next1 += 1, tasks1[key1](function(err1, result1) {
                            each1(key1, err1, result1);
                        })) : (key1 = next1, next1 += 1, tasks1[key1](function(err1, result1) {
                            each1(key1, err1, result1);
                        }));
                    }
                }
                Array.isArray(tasks1) ? (results1 = [], pending1 = len3 = tasks1.length) : (keys1 = Object.keys(tasks1), results1 = {}, pending1 = len3 = keys1.length), next1 = limit1, pending1 ? keys1 ? keys1.some(function(key1, i2) {
                    return tasks1[key1](function(err1, result1) {
                        each1(key1, err1, result1);
                    }), i2 === limit1 - 1;
                }) : tasks1.some(function(task1, i2) {
                    return task1(function(err1, result1) {
                        each1(i2, err1, result1);
                    }), i2 === limit1 - 1;
                }) : done1(null), isSync1 = !1;
            }
        },
        9509: function(module1, exports1, __webpack_require__1) {
            var buffer1 = __webpack_require__1(8764), Buffer1 = buffer1.Buffer;
            function copyProps1(src1, dst1) {
                for(var key1 in src1)dst1[key1] = src1[key1];
            }
            function SafeBuffer1(arg4, encodingOrOffset1, length1) {
                return Buffer1(arg4, encodingOrOffset1, length1);
            }
            Buffer1.from && Buffer1.alloc && Buffer1.allocUnsafe && Buffer1.allocUnsafeSlow ? module1.exports = buffer1 : (copyProps1(buffer1, exports1), exports1.Buffer = SafeBuffer1), SafeBuffer1.prototype = Object.create(Buffer1.prototype), copyProps1(Buffer1, SafeBuffer1), SafeBuffer1.from = function(arg4, encodingOrOffset1, length1) {
                if ('number' == typeof arg4) throw TypeError('Argument must not be a number');
                return Buffer1(arg4, encodingOrOffset1, length1);
            }, SafeBuffer1.alloc = function(size1, fill1, encoding1) {
                if ('number' != typeof size1) throw TypeError('Argument must be a number');
                var buf1 = Buffer1(size1);
                return void 0 !== fill1 ? 'string' == typeof encoding1 ? buf1.fill(fill1, encoding1) : buf1.fill(fill1) : buf1.fill(0), buf1;
            }, SafeBuffer1.allocUnsafe = function(size1) {
                if ('number' != typeof size1) throw TypeError('Argument must be a number');
                return Buffer1(size1);
            }, SafeBuffer1.allocUnsafeSlow = function(size1) {
                if ('number' != typeof size1) throw TypeError('Argument must be a number');
                return buffer1.SlowBuffer(size1);
            };
        },
        7668: function(module1, exports1) {
            "use strict";
            const stringify1 = configure1();
            stringify1.configure = configure1, stringify1.stringify = stringify1, stringify1.default = stringify1, exports1.stringify = stringify1, exports1.configure = configure1, module1.exports = stringify1;
            const strEscapeSequencesRegExp1 = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/, strEscapeSequencesReplacer1 = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g, meta1 = [
                '\\u0000',
                '\\u0001',
                '\\u0002',
                '\\u0003',
                '\\u0004',
                '\\u0005',
                '\\u0006',
                '\\u0007',
                '\\b',
                '\\t',
                '\\n',
                '\\u000b',
                '\\f',
                '\\r',
                '\\u000e',
                '\\u000f',
                '\\u0010',
                '\\u0011',
                '\\u0012',
                '\\u0013',
                '\\u0014',
                '\\u0015',
                '\\u0016',
                '\\u0017',
                '\\u0018',
                '\\u0019',
                '\\u001a',
                '\\u001b',
                '\\u001c',
                '\\u001d',
                '\\u001e',
                '\\u001f',
                '',
                '',
                '\\"',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '\\\\'
            ];
            function escapeFn1(str1) {
                if (2 === str1.length) {
                    const charCode1 = str1.charCodeAt(1);
                    return `${str1[0]}\\u${charCode1.toString(16)}`;
                }
                const charCode1 = str1.charCodeAt(0);
                return meta1.length > charCode1 ? meta1[charCode1] : `\\u${charCode1.toString(16)}`;
            }
            function strEscape1(str1) {
                if (str1.length < 5000 && !strEscapeSequencesRegExp1.test(str1)) return str1;
                if (str1.length > 100) return str1.replace(strEscapeSequencesReplacer1, escapeFn1);
                let result1 = '', last1 = 0;
                for(let i2 = 0; i2 < str1.length; i2++){
                    const point1 = str1.charCodeAt(i2);
                    if (34 === point1 || 92 === point1 || point1 < 32) result1 += `${str1.slice(last1, i2)}${meta1[point1]}`, last1 = i2 + 1;
                    else if (point1 >= 0xd800 && point1 <= 0xdfff) {
                        if (point1 <= 0xdbff && i2 + 1 < str1.length) {
                            const point1 = str1.charCodeAt(i2 + 1);
                            if (point1 >= 0xdc00 && point1 <= 0xdfff) {
                                i2++;
                                continue;
                            }
                        }
                        result1 += `${str1.slice(last1, i2)}${`\\u${point1.toString(16)}`}`, last1 = i2 + 1;
                    }
                }
                return result1 + str1.slice(last1);
            }
            function insertSort1(array1) {
                if (array1.length > 2e2) return array1.sort();
                for(let i2 = 1; i2 < array1.length; i2++){
                    const currentValue1 = array1[i2];
                    let position1 = i2;
                    for(; 0 !== position1 && array1[position1 - 1] > currentValue1;)array1[position1] = array1[position1 - 1], position1--;
                    array1[position1] = currentValue1;
                }
                return array1;
            }
            const typedArrayPrototypeGetSymbolToStringTag1 = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;
            function isTypedArrayWithEntries1(value1) {
                return void 0 !== typedArrayPrototypeGetSymbolToStringTag1.call(value1) && 0 !== value1.length;
            }
            function stringifyTypedArray1(array1, separator1, maximumBreadth1) {
                array1.length < maximumBreadth1 && (maximumBreadth1 = array1.length);
                const whitespace1 = ',' === separator1 ? '' : ' ';
                let res1 = `"0":${whitespace1}${array1[0]}`;
                for(let i2 = 1; i2 < maximumBreadth1; i2++)res1 += `${separator1}"${i2}":${whitespace1}${array1[i2]}`;
                return res1;
            }
            function getCircularValueOption1(options1) {
                if (options1 && Object.prototype.hasOwnProperty.call(options1, 'circularValue')) {
                    var circularValue1 = options1.circularValue;
                    if ('string' == typeof circularValue1) return `"${circularValue1}"`;
                    if (null == circularValue1) return circularValue1;
                    if (circularValue1 === Error || circularValue1 === TypeError) return {
                        toString () {
                            throw TypeError('Converting circular structure to JSON');
                        }
                    };
                    throw TypeError('The "circularValue" argument must be of type string or the value null or undefined');
                }
                return '"[Circular]"';
            }
            function getBooleanOption1(options1, key1) {
                if (options1 && Object.prototype.hasOwnProperty.call(options1, key1)) {
                    var value1 = options1[key1];
                    if ('boolean' != typeof value1) throw TypeError(`The "${key1}" argument must be of type boolean`);
                }
                return void 0 === value1 || value1;
            }
            function getPositiveIntegerOption1(options1, key1) {
                if (options1 && Object.prototype.hasOwnProperty.call(options1, key1)) {
                    var value1 = options1[key1];
                    if ('number' != typeof value1) throw TypeError(`The "${key1}" argument must be of type number`);
                    if (!Number.isInteger(value1)) throw TypeError(`The "${key1}" argument must be an integer`);
                    if (value1 < 1) throw RangeError(`The "${key1}" argument must be >= 1`);
                }
                return void 0 === value1 ? 1 / 0 : value1;
            }
            function getItemCount1(number1) {
                return 1 === number1 ? '1 item' : `${number1} items`;
            }
            function getUniqueReplacerSet1(replacerArray1) {
                const replacerSet1 = new Set();
                for (const value1 of replacerArray1)'string' == typeof value1 ? replacerSet1.add(value1) : 'number' == typeof value1 && replacerSet1.add(String(value1));
                return replacerSet1;
            }
            function configure1(options1) {
                const circularValue1 = getCircularValueOption1(options1), bigint1 = getBooleanOption1(options1, 'bigint'), deterministic1 = getBooleanOption1(options1, 'deterministic'), maximumDepth1 = getPositiveIntegerOption1(options1, 'maximumDepth'), maximumBreadth1 = getPositiveIntegerOption1(options1, 'maximumBreadth');
                function stringifyFnReplacer1(key1, parent1, stack1, replacer1, spacer1, indentation1) {
                    let value1 = parent1[key1];
                    switch('object' == typeof value1 && null !== value1 && 'function' == typeof value1.toJSON && (value1 = value1.toJSON(key1)), typeof (value1 = replacer1.call(parent1, key1, value1))){
                        case 'string':
                            return `"${strEscape1(value1)}"`;
                        case 'object':
                            {
                                if (null === value1) return 'null';
                                if (-1 !== stack1.indexOf(value1)) return circularValue1;
                                let res1 = '', join1 = ',';
                                const originalIndentation1 = indentation1;
                                if (Array.isArray(value1)) {
                                    if (0 === value1.length) return '[]';
                                    if (maximumDepth1 < stack1.length + 1) return '"[Array]"';
                                    stack1.push(value1), '' !== spacer1 && (indentation1 += spacer1, res1 += `\n${indentation1}`, join1 = `,\n${indentation1}`);
                                    const maximumValuesToStringify1 = Math.min(value1.length, maximumBreadth1);
                                    let i2 = 0;
                                    for(; i2 < maximumValuesToStringify1 - 1; i2++){
                                        const tmp1 = stringifyFnReplacer1(i2, value1, stack1, replacer1, spacer1, indentation1);
                                        res1 += (void 0 !== tmp1 ? tmp1 : 'null') + join1;
                                    }
                                    const tmp1 = stringifyFnReplacer1(i2, value1, stack1, replacer1, spacer1, indentation1);
                                    if (res1 += void 0 !== tmp1 ? tmp1 : 'null', value1.length - 1 > maximumBreadth1) {
                                        const removedKeys1 = value1.length - maximumBreadth1 - 1;
                                        res1 += `${join1}"... ${getItemCount1(removedKeys1)} not stringified"`;
                                    }
                                    return '' !== spacer1 && (res1 += `\n${originalIndentation1}`), stack1.pop(), `[${res1}]`;
                                }
                                let keys1 = Object.keys(value1);
                                const keyLength1 = keys1.length;
                                if (0 === keyLength1) return '{}';
                                if (maximumDepth1 < stack1.length + 1) return '"[Object]"';
                                let whitespace1 = '', separator1 = '';
                                '' !== spacer1 && (indentation1 += spacer1, join1 = `,\n${indentation1}`, whitespace1 = ' ');
                                let maximumPropertiesToStringify1 = Math.min(keyLength1, maximumBreadth1);
                                isTypedArrayWithEntries1(value1) && (res1 += stringifyTypedArray1(value1, join1, maximumBreadth1), keys1 = keys1.slice(value1.length), maximumPropertiesToStringify1 -= value1.length, separator1 = join1), deterministic1 && (keys1 = insertSort1(keys1)), stack1.push(value1);
                                for(let i2 = 0; i2 < maximumPropertiesToStringify1; i2++){
                                    const key1 = keys1[i2], tmp1 = stringifyFnReplacer1(key1, value1, stack1, replacer1, spacer1, indentation1);
                                    void 0 !== tmp1 && (res1 += `${separator1}"${strEscape1(key1)}":${whitespace1}${tmp1}`, separator1 = join1);
                                }
                                if (keyLength1 > maximumBreadth1) {
                                    const removedKeys1 = keyLength1 - maximumBreadth1;
                                    res1 += `${separator1}"...":${whitespace1}"${getItemCount1(removedKeys1)} not stringified"`, separator1 = join1;
                                }
                                return '' !== spacer1 && separator1.length > 1 && (res1 = `\n${indentation1}${res1}\n${originalIndentation1}`), stack1.pop(), `{${res1}}`;
                            }
                        case 'number':
                            return isFinite(value1) ? String(value1) : 'null';
                        case 'boolean':
                            return !0 === value1 ? 'true' : 'false';
                        case 'bigint':
                            return bigint1 ? String(value1) : void 0;
                    }
                }
                function stringifyArrayReplacer1(key1, value1, stack1, replacer1, spacer1, indentation1) {
                    switch('object' == typeof value1 && null !== value1 && 'function' == typeof value1.toJSON && (value1 = value1.toJSON(key1)), typeof value1){
                        case 'string':
                            return `"${strEscape1(value1)}"`;
                        case 'object':
                            {
                                if (null === value1) return 'null';
                                if (-1 !== stack1.indexOf(value1)) return circularValue1;
                                const originalIndentation1 = indentation1;
                                let res1 = '', join1 = ',';
                                if (Array.isArray(value1)) {
                                    if (0 === value1.length) return '[]';
                                    if (maximumDepth1 < stack1.length + 1) return '"[Array]"';
                                    stack1.push(value1), '' !== spacer1 && (indentation1 += spacer1, res1 += `\n${indentation1}`, join1 = `,\n${indentation1}`);
                                    const maximumValuesToStringify1 = Math.min(value1.length, maximumBreadth1);
                                    let i2 = 0;
                                    for(; i2 < maximumValuesToStringify1 - 1; i2++){
                                        const tmp1 = stringifyArrayReplacer1(i2, value1[i2], stack1, replacer1, spacer1, indentation1);
                                        res1 += (void 0 !== tmp1 ? tmp1 : 'null') + join1;
                                    }
                                    const tmp1 = stringifyArrayReplacer1(i2, value1[i2], stack1, replacer1, spacer1, indentation1);
                                    if (res1 += void 0 !== tmp1 ? tmp1 : 'null', value1.length - 1 > maximumBreadth1) {
                                        const removedKeys1 = value1.length - maximumBreadth1 - 1;
                                        res1 += `${join1}"... ${getItemCount1(removedKeys1)} not stringified"`;
                                    }
                                    return '' !== spacer1 && (res1 += `\n${originalIndentation1}`), stack1.pop(), `[${res1}]`;
                                }
                                if (0 === replacer1.size) return '{}';
                                stack1.push(value1);
                                let whitespace1 = '';
                                '' !== spacer1 && (indentation1 += spacer1, join1 = `,\n${indentation1}`, whitespace1 = ' ');
                                let separator1 = '';
                                for (const key1 of replacer1){
                                    const tmp1 = stringifyArrayReplacer1(key1, value1[key1], stack1, replacer1, spacer1, indentation1);
                                    void 0 !== tmp1 && (res1 += `${separator1}"${strEscape1(key1)}":${whitespace1}${tmp1}`, separator1 = join1);
                                }
                                return '' !== spacer1 && separator1.length > 1 && (res1 = `\n${indentation1}${res1}\n${originalIndentation1}`), stack1.pop(), `{${res1}}`;
                            }
                        case 'number':
                            return isFinite(value1) ? String(value1) : 'null';
                        case 'boolean':
                            return !0 === value1 ? 'true' : 'false';
                        case 'bigint':
                            return bigint1 ? String(value1) : void 0;
                    }
                }
                function stringifyIndent1(key1, value1, stack1, spacer1, indentation1) {
                    switch(typeof value1){
                        case 'string':
                            return `"${strEscape1(value1)}"`;
                        case 'object':
                            {
                                if (null === value1) return 'null';
                                if ('function' == typeof value1.toJSON) {
                                    if ('object' != typeof (value1 = value1.toJSON(key1))) return stringifyIndent1(key1, value1, stack1, spacer1, indentation1);
                                    if (null === value1) return 'null';
                                }
                                if (-1 !== stack1.indexOf(value1)) return circularValue1;
                                const originalIndentation1 = indentation1;
                                if (Array.isArray(value1)) {
                                    if (0 === value1.length) return '[]';
                                    if (maximumDepth1 < stack1.length + 1) return '"[Array]"';
                                    stack1.push(value1);
                                    let res1 = `\n${indentation1 += spacer1}`;
                                    const join1 = `,\n${indentation1}`, maximumValuesToStringify1 = Math.min(value1.length, maximumBreadth1);
                                    let i2 = 0;
                                    for(; i2 < maximumValuesToStringify1 - 1; i2++){
                                        const tmp1 = stringifyIndent1(i2, value1[i2], stack1, spacer1, indentation1);
                                        res1 += (void 0 !== tmp1 ? tmp1 : 'null') + join1;
                                    }
                                    const tmp1 = stringifyIndent1(i2, value1[i2], stack1, spacer1, indentation1);
                                    if (res1 += void 0 !== tmp1 ? tmp1 : 'null', value1.length - 1 > maximumBreadth1) {
                                        const removedKeys1 = value1.length - maximumBreadth1 - 1;
                                        res1 += `${join1}"... ${getItemCount1(removedKeys1)} not stringified"`;
                                    }
                                    return res1 += `\n${originalIndentation1}`, stack1.pop(), `[${res1}]`;
                                }
                                let keys1 = Object.keys(value1);
                                const keyLength1 = keys1.length;
                                if (0 === keyLength1) return '{}';
                                if (maximumDepth1 < stack1.length + 1) return '"[Object]"';
                                indentation1 += spacer1;
                                const join1 = `,\n${indentation1}`;
                                let res1 = '', separator1 = '', maximumPropertiesToStringify1 = Math.min(keyLength1, maximumBreadth1);
                                isTypedArrayWithEntries1(value1) && (res1 += stringifyTypedArray1(value1, join1, maximumBreadth1), keys1 = keys1.slice(value1.length), maximumPropertiesToStringify1 -= value1.length, separator1 = join1), deterministic1 && (keys1 = insertSort1(keys1)), stack1.push(value1);
                                for(let i2 = 0; i2 < maximumPropertiesToStringify1; i2++){
                                    const key1 = keys1[i2], tmp1 = stringifyIndent1(key1, value1[key1], stack1, spacer1, indentation1);
                                    void 0 !== tmp1 && (res1 += `${separator1}"${strEscape1(key1)}": ${tmp1}`, separator1 = join1);
                                }
                                if (keyLength1 > maximumBreadth1) {
                                    const removedKeys1 = keyLength1 - maximumBreadth1;
                                    res1 += `${separator1}"...": "${getItemCount1(removedKeys1)} not stringified"`, separator1 = join1;
                                }
                                return '' !== separator1 && (res1 = `\n${indentation1}${res1}\n${originalIndentation1}`), stack1.pop(), `{${res1}}`;
                            }
                        case 'number':
                            return isFinite(value1) ? String(value1) : 'null';
                        case 'boolean':
                            return !0 === value1 ? 'true' : 'false';
                        case 'bigint':
                            return bigint1 ? String(value1) : void 0;
                    }
                }
                function stringifySimple1(key1, value1, stack1) {
                    switch(typeof value1){
                        case 'string':
                            return `"${strEscape1(value1)}"`;
                        case 'object':
                            {
                                if (null === value1) return 'null';
                                if ('function' == typeof value1.toJSON) {
                                    if ('object' != typeof (value1 = value1.toJSON(key1))) return stringifySimple1(key1, value1, stack1);
                                    if (null === value1) return 'null';
                                }
                                if (-1 !== stack1.indexOf(value1)) return circularValue1;
                                let res1 = '';
                                if (Array.isArray(value1)) {
                                    if (0 === value1.length) return '[]';
                                    if (maximumDepth1 < stack1.length + 1) return '"[Array]"';
                                    stack1.push(value1);
                                    const maximumValuesToStringify1 = Math.min(value1.length, maximumBreadth1);
                                    let i2 = 0;
                                    for(; i2 < maximumValuesToStringify1 - 1; i2++){
                                        const tmp1 = stringifySimple1(i2, value1[i2], stack1);
                                        res1 += (void 0 !== tmp1 ? tmp1 : 'null') + ',';
                                    }
                                    const tmp1 = stringifySimple1(i2, value1[i2], stack1);
                                    if (res1 += void 0 !== tmp1 ? tmp1 : 'null', value1.length - 1 > maximumBreadth1) {
                                        const removedKeys1 = value1.length - maximumBreadth1 - 1;
                                        res1 += `,"... ${getItemCount1(removedKeys1)} not stringified"`;
                                    }
                                    return stack1.pop(), `[${res1}]`;
                                }
                                let keys1 = Object.keys(value1);
                                const keyLength1 = keys1.length;
                                if (0 === keyLength1) return '{}';
                                if (maximumDepth1 < stack1.length + 1) return '"[Object]"';
                                let separator1 = '', maximumPropertiesToStringify1 = Math.min(keyLength1, maximumBreadth1);
                                isTypedArrayWithEntries1(value1) && (res1 += stringifyTypedArray1(value1, ',', maximumBreadth1), keys1 = keys1.slice(value1.length), maximumPropertiesToStringify1 -= value1.length, separator1 = ','), deterministic1 && (keys1 = insertSort1(keys1)), stack1.push(value1);
                                for(let i2 = 0; i2 < maximumPropertiesToStringify1; i2++){
                                    const key1 = keys1[i2], tmp1 = stringifySimple1(key1, value1[key1], stack1);
                                    void 0 !== tmp1 && (res1 += `${separator1}"${strEscape1(key1)}":${tmp1}`, separator1 = ',');
                                }
                                if (keyLength1 > maximumBreadth1) {
                                    const removedKeys1 = keyLength1 - maximumBreadth1;
                                    res1 += `${separator1}"...":"${getItemCount1(removedKeys1)} not stringified"`;
                                }
                                return stack1.pop(), `{${res1}}`;
                            }
                        case 'number':
                            return isFinite(value1) ? String(value1) : 'null';
                        case 'boolean':
                            return !0 === value1 ? 'true' : 'false';
                        case 'bigint':
                            return bigint1 ? String(value1) : void 0;
                    }
                }
                return function(value1, replacer1, space1) {
                    if (arguments.length > 1) {
                        let spacer1 = '';
                        if ('number' == typeof space1 ? spacer1 = ' '.repeat(Math.min(space1, 10)) : 'string' == typeof space1 && (spacer1 = space1.slice(0, 10)), null != replacer1) {
                            if ('function' == typeof replacer1) return stringifyFnReplacer1('', {
                                '': value1
                            }, [], replacer1, spacer1, '');
                            if (Array.isArray(replacer1)) return stringifyArrayReplacer1('', value1, [], getUniqueReplacerSet1(replacer1), spacer1, '');
                        }
                        if (0 !== spacer1.length) return stringifyIndent1('', value1, [], spacer1, '');
                    }
                    return stringifySimple1('', value1, []);
                };
            }
        },
        2399: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var key1, process1 = __webpack_require__1(3454), buffer1 = __webpack_require__1(8764), Buffer1 = buffer1.Buffer, safer1 = {};
            for(key1 in buffer1)buffer1.hasOwnProperty(key1) && 'SlowBuffer' !== key1 && 'Buffer' !== key1 && (safer1[key1] = buffer1[key1]);
            var Safer1 = safer1.Buffer = {};
            for(key1 in Buffer1)Buffer1.hasOwnProperty(key1) && 'allocUnsafe' !== key1 && 'allocUnsafeSlow' !== key1 && (Safer1[key1] = Buffer1[key1]);
            if (safer1.Buffer.prototype = Buffer1.prototype, Safer1.from && Safer1.from !== Uint8Array.from || (Safer1.from = function(value1, encodingOrOffset1, length1) {
                if ('number' == typeof value1) throw TypeError('The "value" argument must not be of type number. Received type ' + typeof value1);
                if (value1 && void 0 === value1.length) throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value1);
                return Buffer1(value1, encodingOrOffset1, length1);
            }), Safer1.alloc || (Safer1.alloc = function(size1, fill1, encoding1) {
                if ('number' != typeof size1) throw TypeError('The "size" argument must be of type number. Received type ' + typeof size1);
                if (size1 < 0 || size1 >= 2 * 1073741824) throw RangeError('The value "' + size1 + '" is invalid for option "size"');
                var buf1 = Buffer1(size1);
                return fill1 && 0 !== fill1.length ? 'string' == typeof encoding1 ? buf1.fill(fill1, encoding1) : buf1.fill(fill1) : buf1.fill(0), buf1;
            }), !safer1.kStringMaxLength) try {
                safer1.kStringMaxLength = process1.binding('buffer').kStringMaxLength;
            } catch (e1) {}
            !safer1.constants && (safer1.constants = {
                MAX_LENGTH: safer1.kMaxLength
            }, safer1.kStringMaxLength && (safer1.constants.MAX_STRING_LENGTH = safer1.kStringMaxLength)), module1.exports = safer1;
        },
        2553: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(9509).Buffer, isEncoding1 = Buffer1.isEncoding || function(encoding1) {
                switch((encoding1 = '' + encoding1) && encoding1.toLowerCase()){
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                    case 'raw':
                        return !0;
                    default:
                        return !1;
                }
            };
            function _normalizeEncoding1(enc1) {
                var retried1;
                if (!enc1) return 'utf8';
                for(;;)switch(enc1){
                    case 'utf8':
                    case 'utf-8':
                        return 'utf8';
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return 'utf16le';
                    case 'latin1':
                    case 'binary':
                        return 'latin1';
                    case 'base64':
                    case 'ascii':
                    case 'hex':
                        return enc1;
                    default:
                        if (retried1) return;
                        enc1 = ('' + enc1).toLowerCase(), retried1 = !0;
                }
            }
            function normalizeEncoding1(enc1) {
                var nenc1 = _normalizeEncoding1(enc1);
                if ('string' != typeof nenc1 && (Buffer1.isEncoding === isEncoding1 || !isEncoding1(enc1))) throw Error('Unknown encoding: ' + enc1);
                return nenc1 || enc1;
            }
            function StringDecoder1(encoding1) {
                var nb1;
                switch(this.encoding = normalizeEncoding1(encoding1), this.encoding){
                    case 'utf16le':
                        this.text = utf16Text1, this.end = utf16End1, nb1 = 4;
                        break;
                    case 'utf8':
                        this.fillLast = utf8FillLast1, nb1 = 4;
                        break;
                    case 'base64':
                        this.text = base64Text1, this.end = base64End1, nb1 = 3;
                        break;
                    default:
                        this.write = simpleWrite1, this.end = simpleEnd1;
                        return;
                }
                this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer1.allocUnsafe(nb1);
            }
            function utf8CheckByte1(byte1) {
                return byte1 <= 0x7F ? 0 : byte1 >> 5 == 0x06 ? 2 : byte1 >> 4 == 0x0E ? 3 : byte1 >> 3 == 0x1E ? 4 : byte1 >> 6 == 0x02 ? -1 : -2;
            }
            function utf8CheckIncomplete1(self1, buf1, i2) {
                var j1 = buf1.length - 1;
                if (j1 < i2) return 0;
                var nb1 = utf8CheckByte1(buf1[j1]);
                return nb1 >= 0 ? (nb1 > 0 && (self1.lastNeed = nb1 - 1), nb1) : --j1 < i2 || -2 === nb1 ? 0 : (nb1 = utf8CheckByte1(buf1[j1])) >= 0 ? (nb1 > 0 && (self1.lastNeed = nb1 - 2), nb1) : --j1 < i2 || -2 === nb1 ? 0 : (nb1 = utf8CheckByte1(buf1[j1])) >= 0 ? (nb1 > 0 && (2 === nb1 ? nb1 = 0 : self1.lastNeed = nb1 - 3), nb1) : 0;
            }
            function utf8CheckExtraBytes1(self1, buf1, p3) {
                if ((0xC0 & buf1[0]) != 0x80) return self1.lastNeed = 0, '\ufffd';
                if (self1.lastNeed > 1 && buf1.length > 1) {
                    if ((0xC0 & buf1[1]) != 0x80) return self1.lastNeed = 1, '\ufffd';
                    if (self1.lastNeed > 2 && buf1.length > 2 && (0xC0 & buf1[2]) != 0x80) return self1.lastNeed = 2, '\ufffd';
                }
            }
            function utf8FillLast1(buf1) {
                var p3 = this.lastTotal - this.lastNeed, r3 = utf8CheckExtraBytes1(this, buf1, p3);
                return void 0 !== r3 ? r3 : this.lastNeed <= buf1.length ? (buf1.copy(this.lastChar, p3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (buf1.copy(this.lastChar, p3, 0, buf1.length), this.lastNeed -= buf1.length);
            }
            function utf8Text1(buf1, i2) {
                var total1 = utf8CheckIncomplete1(this, buf1, i2);
                if (!this.lastNeed) return buf1.toString('utf8', i2);
                this.lastTotal = total1;
                var end1 = buf1.length - (total1 - this.lastNeed);
                return buf1.copy(this.lastChar, 0, end1), buf1.toString('utf8', i2, end1);
            }
            function utf8End1(buf1) {
                var r3 = buf1 && buf1.length ? this.write(buf1) : '';
                return this.lastNeed ? r3 + '\ufffd' : r3;
            }
            function utf16Text1(buf1, i2) {
                if ((buf1.length - i2) % 2 == 0) {
                    var r3 = buf1.toString('utf16le', i2);
                    if (r3) {
                        var c5 = r3.charCodeAt(r3.length - 1);
                        if (c5 >= 0xD800 && c5 <= 0xDBFF) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf1[buf1.length - 2], this.lastChar[1] = buf1[buf1.length - 1], r3.slice(0, -1);
                    }
                    return r3;
                }
                return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf1[buf1.length - 1], buf1.toString('utf16le', i2, buf1.length - 1);
            }
            function utf16End1(buf1) {
                var r3 = buf1 && buf1.length ? this.write(buf1) : '';
                if (this.lastNeed) {
                    var end1 = this.lastTotal - this.lastNeed;
                    return r3 + this.lastChar.toString('utf16le', 0, end1);
                }
                return r3;
            }
            function base64Text1(buf1, i2) {
                var n2 = (buf1.length - i2) % 3;
                return 0 === n2 ? buf1.toString('base64', i2) : (this.lastNeed = 3 - n2, this.lastTotal = 3, 1 === n2 ? this.lastChar[0] = buf1[buf1.length - 1] : (this.lastChar[0] = buf1[buf1.length - 2], this.lastChar[1] = buf1[buf1.length - 1]), buf1.toString('base64', i2, buf1.length - n2));
            }
            function base64End1(buf1) {
                var r3 = buf1 && buf1.length ? this.write(buf1) : '';
                return this.lastNeed ? r3 + this.lastChar.toString('base64', 0, 3 - this.lastNeed) : r3;
            }
            function simpleWrite1(buf1) {
                return buf1.toString(this.encoding);
            }
            function simpleEnd1(buf1) {
                return buf1 && buf1.length ? this.write(buf1) : '';
            }
            exports1.StringDecoder = StringDecoder1, StringDecoder1.prototype.write = function(buf1) {
                var r3, i2;
                if (0 === buf1.length) return '';
                if (this.lastNeed) {
                    if (void 0 === (r3 = this.fillLast(buf1))) return '';
                    i2 = this.lastNeed, this.lastNeed = 0;
                } else i2 = 0;
                return i2 < buf1.length ? r3 ? r3 + this.text(buf1, i2) : this.text(buf1, i2) : r3 || '';
            }, StringDecoder1.prototype.end = utf8End1, StringDecoder1.prototype.text = utf8Text1, StringDecoder1.prototype.fillLast = function(buf1) {
                if (this.lastNeed <= buf1.length) return buf1.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
                buf1.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf1.length), this.lastNeed -= buf1.length;
            };
        },
        3931: function(module1, __webpack_exports__1, __webpack_require__1) {
            "use strict";
            __webpack_require__1.r(__webpack_exports__1), __webpack_require__1.d(__webpack_exports__1, {
                HTTPRangeReader: function() {
                    return HTTPRangeReader1;
                },
                cleanup: function() {
                    return cleanup$11;
                },
                setOptions: function() {
                    return setOptions$11;
                },
                unzip: function() {
                    return unzip1;
                },
                unzipRaw: function() {
                    return unzipRaw1;
                }
            }), module1 = __webpack_require__1.hmd(module1);
            var process1 = __webpack_require__1(3454);
            function readBlobAsArrayBuffer1(blob1) {
                return blob1.arrayBuffer ? blob1.arrayBuffer() : new Promise((resolve1, reject1)=>{
                    const reader1 = new FileReader();
                    reader1.addEventListener('loadend', ()=>{
                        resolve1(reader1.result);
                    }), reader1.addEventListener('error', reject1), reader1.readAsArrayBuffer(blob1);
                });
            }
            async function readBlobAsUint8Array1(blob1) {
                const arrayBuffer1 = await readBlobAsArrayBuffer1(blob1);
                return new Uint8Array(arrayBuffer1);
            }
            function isBlob1(v3) {
                return 'undefined' != typeof Blob && v3 instanceof Blob;
            }
            function isSharedArrayBuffer1(b10) {
                return 'undefined' != typeof SharedArrayBuffer && b10 instanceof SharedArrayBuffer;
            }
            const isNode1 = void 0 !== process1 && process1.versions && void 0 !== process1.versions.node && void 0 === process1.versions.electron;
            function isTypedArraySameAsArrayBuffer1(typedArray1) {
                return 0 === typedArray1.byteOffset && typedArray1.byteLength === typedArray1.buffer.byteLength;
            }
            class ArrayBufferReader1 {
                constructor(arrayBufferOrView1){
                    this.typedArray = arrayBufferOrView1 instanceof ArrayBuffer || isSharedArrayBuffer1(arrayBufferOrView1) ? new Uint8Array(arrayBufferOrView1) : new Uint8Array(arrayBufferOrView1.buffer, arrayBufferOrView1.byteOffset, arrayBufferOrView1.byteLength);
                }
                async getLength() {
                    return this.typedArray.byteLength;
                }
                async read(offset1, length1) {
                    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset1, length1);
                }
            }
            class BlobReader1 {
                constructor(blob1){
                    this.blob = blob1;
                }
                async getLength() {
                    return this.blob.size;
                }
                async read(offset1, length1) {
                    const blob1 = this.blob.slice(offset1, offset1 + length1), arrayBuffer1 = await readBlobAsArrayBuffer1(blob1);
                    return new Uint8Array(arrayBuffer1);
                }
                async sliceAsBlob(offset1, length1, type1 = '') {
                    return this.blob.slice(offset1, offset1 + length1, type1);
                }
            }
            class HTTPRangeReader1 {
                constructor(url1){
                    this.url = url1;
                }
                async getLength() {
                    if (void 0 === this.length) {
                        const req1 = await fetch(this.url, {
                            method: 'HEAD'
                        });
                        if (!req1.ok) throw Error(`failed http request ${this.url}, status: ${req1.status}: ${req1.statusText}`);
                        if (this.length = parseInt(req1.headers.get('content-length')), Number.isNaN(this.length)) throw Error('could not get length');
                    }
                    return this.length;
                }
                async read(offset1, size1) {
                    if (0 === size1) return new Uint8Array(0);
                    const req1 = await fetch(this.url, {
                        headers: {
                            Range: `bytes=${offset1}-${offset1 + size1 - 1}`
                        }
                    });
                    if (!req1.ok) throw Error(`failed http request ${this.url}, status: ${req1.status} offset: ${offset1} size: ${size1}: ${req1.statusText}`);
                    const buffer1 = await req1.arrayBuffer();
                    return new Uint8Array(buffer1);
                }
            }
            function inflate1(data1, buf1) {
                var lmap1, dmap1, u81 = Uint8Array;
                if (3 == data1[0] && 0 == data1[1]) return buf1 || new u81(0);
                var bitsF1 = _bitsF1, bitsE1 = _bitsE1, decodeTiny1 = _decodeTiny1, get171 = _get171, noBuf1 = null == buf1;
                noBuf1 && (buf1 = new u81(data1.length >>> 2 << 3));
                for(var BFINAL1 = 0, BTYPE1 = 0, HLIT1 = 0, HDIST1 = 0, HCLEN1 = 0, ML1 = 0, MD1 = 0, off1 = 0, pos1 = 0; 0 == BFINAL1;){
                    if (BFINAL1 = bitsF1(data1, pos1, 1), BTYPE1 = bitsF1(data1, pos1 + 1, 2), pos1 += 3, 0 == BTYPE1) {
                        (7 & pos1) != 0 && (pos1 += 8 - (7 & pos1));
                        var p81 = (pos1 >>> 3) + 4, len3 = data1[p81 - 4] | data1[p81 - 3] << 8;
                        noBuf1 && (buf1 = _check1(buf1, off1 + len3)), buf1.set(new u81(data1.buffer, data1.byteOffset + p81, len3), off1), pos1 = p81 + len3 << 3, off1 += len3;
                        continue;
                    }
                    if (noBuf1 && (buf1 = _check1(buf1, off1 + 131072)), 1 == BTYPE1 && (lmap1 = U1.flmap, dmap1 = U1.fdmap, ML1 = 511, MD1 = 31), 2 == BTYPE1) {
                        HLIT1 = bitsE1(data1, pos1, 5) + 257, HDIST1 = bitsE1(data1, pos1 + 5, 5) + 1, HCLEN1 = bitsE1(data1, pos1 + 10, 4) + 4, pos1 += 14;
                        for(var i2 = 0; i2 < 38; i2 += 2)U1.itree[i2] = 0, U1.itree[i2 + 1] = 0;
                        for(var tl1 = 1, i2 = 0; i2 < HCLEN1; i2++){
                            var l1 = bitsE1(data1, pos1 + 3 * i2, 3);
                            U1.itree[(U1.ordr[i2] << 1) + 1] = l1, l1 > tl1 && (tl1 = l1);
                        }
                        pos1 += 3 * HCLEN1, makeCodes1(U1.itree, tl1), codes2map1(U1.itree, tl1, U1.imap), lmap1 = U1.lmap, dmap1 = U1.dmap, pos1 = decodeTiny1(U1.imap, (1 << tl1) - 1, HLIT1 + HDIST1, data1, pos1, U1.ttree);
                        var mx01 = _copyOut1(U1.ttree, 0, HLIT1, U1.ltree);
                        ML1 = (1 << mx01) - 1;
                        var mx11 = _copyOut1(U1.ttree, HLIT1, HDIST1, U1.dtree);
                        MD1 = (1 << mx11) - 1, makeCodes1(U1.ltree, mx01), codes2map1(U1.ltree, mx01, lmap1), makeCodes1(U1.dtree, mx11), codes2map1(U1.dtree, mx11, dmap1);
                    }
                    for(;;){
                        var code1 = lmap1[get171(data1, pos1) & ML1];
                        pos1 += 15 & code1;
                        var lit1 = code1 >>> 4;
                        if (lit1 >>> 8 == 0) buf1[off1++] = lit1;
                        else if (256 == lit1) break;
                        else {
                            var end1 = off1 + lit1 - 254;
                            if (lit1 > 264) {
                                var ebs1 = U1.ldef[lit1 - 257];
                                end1 = off1 + (ebs1 >>> 3) + bitsE1(data1, pos1, 7 & ebs1), pos1 += 7 & ebs1;
                            }
                            var dcode1 = dmap1[get171(data1, pos1) & MD1];
                            pos1 += 15 & dcode1;
                            var dlit1 = dcode1 >>> 4, dbs1 = U1.ddef[dlit1], dst1 = (dbs1 >>> 4) + bitsF1(data1, pos1, 15 & dbs1);
                            for(pos1 += 15 & dbs1, noBuf1 && (buf1 = _check1(buf1, off1 + 131072)); off1 < end1;)buf1[off1] = buf1[off1++ - dst1], buf1[off1] = buf1[off1++ - dst1], buf1[off1] = buf1[off1++ - dst1], buf1[off1] = buf1[off1++ - dst1];
                            off1 = end1;
                        }
                    }
                }
                return buf1.length == off1 ? buf1 : buf1.slice(0, off1);
            }
            function _check1(buf1, len3) {
                var bl10 = buf1.length;
                if (len3 <= bl10) return buf1;
                var nbuf1 = new Uint8Array(Math.max(bl10 << 1, len3));
                return nbuf1.set(buf1, 0), nbuf1;
            }
            function _decodeTiny1(lmap1, LL1, len3, data1, pos1, tree1) {
                for(var bitsE1 = _bitsE1, get171 = _get171, i2 = 0; i2 < len3;){
                    var code1 = lmap1[get171(data1, pos1) & LL1];
                    pos1 += 15 & code1;
                    var lit1 = code1 >>> 4;
                    if (lit1 <= 15) tree1[i2] = lit1, i2++;
                    else {
                        var ll1 = 0, n2 = 0;
                        16 == lit1 ? (n2 = 3 + bitsE1(data1, pos1, 2), pos1 += 2, ll1 = tree1[i2 - 1]) : 17 == lit1 ? (n2 = 3 + bitsE1(data1, pos1, 3), pos1 += 3) : 18 == lit1 && (n2 = 11 + bitsE1(data1, pos1, 7), pos1 += 7);
                        for(var ni1 = i2 + n2; i2 < ni1;)tree1[i2] = ll1, i2++;
                    }
                }
                return pos1;
            }
            function _copyOut1(src1, off1, len3, tree1) {
                for(var mx2 = 0, i2 = 0, tl1 = tree1.length >>> 1; i2 < len3;){
                    var v3 = src1[i2 + off1];
                    tree1[i2 << 1] = 0, tree1[(i2 << 1) + 1] = v3, v3 > mx2 && (mx2 = v3), i2++;
                }
                for(; i2 < tl1;)tree1[i2 << 1] = 0, tree1[(i2 << 1) + 1] = 0, i2++;
                return mx2;
            }
            function makeCodes1(tree1, MAX_BITS1) {
                for(var code1, bits1, n2, i2, len3, max_code1 = tree1.length, bl_count1 = U1.bl_count, i2 = 0; i2 <= MAX_BITS1; i2++)bl_count1[i2] = 0;
                for(i2 = 1; i2 < max_code1; i2 += 2)bl_count1[tree1[i2]]++;
                var next_code1 = U1.next_code;
                for(bits1 = 1, code1 = 0, bl_count1[0] = 0; bits1 <= MAX_BITS1; bits1++)code1 = code1 + bl_count1[bits1 - 1] << 1, next_code1[bits1] = code1;
                for(n2 = 0; n2 < max_code1; n2 += 2)0 != (len3 = tree1[n2 + 1]) && (tree1[n2] = next_code1[len3], next_code1[len3]++);
            }
            function codes2map1(tree1, MAX_BITS1, map1) {
                for(var max_code1 = tree1.length, r151 = U1.rev15, i2 = 0; i2 < max_code1; i2 += 2)if (0 != tree1[i2 + 1]) for(var lit1 = i2 >> 1, cl1 = tree1[i2 + 1], val1 = lit1 << 4 | cl1, rest1 = MAX_BITS1 - cl1, i01 = tree1[i2] << rest1, i11 = i01 + (1 << rest1); i01 != i11;)map1[r151[i01] >>> 15 - MAX_BITS1] = val1, i01++;
            }
            function revCodes1(tree1, MAX_BITS1) {
                for(var r151 = U1.rev15, imb1 = 15 - MAX_BITS1, i2 = 0; i2 < tree1.length; i2 += 2){
                    var i01 = tree1[i2] << MAX_BITS1 - tree1[i2 + 1];
                    tree1[i2] = r151[i01] >>> imb1;
                }
            }
            function _bitsE1(dt1, pos1, length1) {
                return (dt1[pos1 >>> 3] | dt1[(pos1 >>> 3) + 1] << 8) >>> (7 & pos1) & (1 << length1) - 1;
            }
            function _bitsF1(dt1, pos1, length1) {
                return (dt1[pos1 >>> 3] | dt1[(pos1 >>> 3) + 1] << 8 | dt1[(pos1 >>> 3) + 2] << 16) >>> (7 & pos1) & (1 << length1) - 1;
            }
            function _get171(dt1, pos1) {
                return (dt1[pos1 >>> 3] | dt1[(pos1 >>> 3) + 1] << 8 | dt1[(pos1 >>> 3) + 2] << 16) >>> (7 & pos1);
            }
            const U1 = function() {
                var u161 = Uint16Array, u321 = Uint32Array;
                return {
                    next_code: new u161(16),
                    bl_count: new u161(16),
                    ordr: [
                        16,
                        17,
                        18,
                        0,
                        8,
                        7,
                        9,
                        6,
                        10,
                        5,
                        11,
                        4,
                        12,
                        3,
                        13,
                        2,
                        14,
                        1,
                        15
                    ],
                    of0: [
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        13,
                        15,
                        17,
                        19,
                        23,
                        27,
                        31,
                        35,
                        43,
                        51,
                        59,
                        67,
                        83,
                        99,
                        115,
                        131,
                        163,
                        195,
                        227,
                        258,
                        999,
                        999,
                        999
                    ],
                    exb: [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1,
                        1,
                        1,
                        1,
                        2,
                        2,
                        2,
                        2,
                        3,
                        3,
                        3,
                        3,
                        4,
                        4,
                        4,
                        4,
                        5,
                        5,
                        5,
                        5,
                        0,
                        0,
                        0,
                        0
                    ],
                    ldef: new u161(32),
                    df0: [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        9,
                        13,
                        17,
                        25,
                        33,
                        49,
                        65,
                        97,
                        129,
                        193,
                        257,
                        385,
                        513,
                        769,
                        1025,
                        1537,
                        2049,
                        3073,
                        4097,
                        6145,
                        8193,
                        12289,
                        16385,
                        24577,
                        65535,
                        65535
                    ],
                    dxb: [
                        0,
                        0,
                        0,
                        0,
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5,
                        6,
                        6,
                        7,
                        7,
                        8,
                        8,
                        9,
                        9,
                        10,
                        10,
                        11,
                        11,
                        12,
                        12,
                        13,
                        13,
                        0,
                        0
                    ],
                    ddef: new u321(32),
                    flmap: new u161(512),
                    fltree: [],
                    fdmap: new u161(32),
                    fdtree: [],
                    lmap: new u161(32768),
                    ltree: [],
                    ttree: [],
                    dmap: new u161(32768),
                    dtree: [],
                    imap: new u161(512),
                    itree: [],
                    rev15: new u161(32768),
                    lhst: new u321(286),
                    dhst: new u321(30),
                    ihst: new u321(19),
                    lits: new u321(15000),
                    strt: new u161(65536),
                    prev: new u161(32768)
                };
            }();
            !function() {
                for(var len3 = 32768, i2 = 0; i2 < len3; i2++){
                    var x3 = i2;
                    x3 = (0xff00ff00 & (x3 = (0xf0f0f0f0 & (x3 = (0xcccccccc & (x3 = (0xaaaaaaaa & x3) >>> 1 | (0x55555555 & x3) << 1)) >>> 2 | (0x33333333 & x3) << 2)) >>> 4 | (0x0f0f0f0f & x3) << 4)) >>> 8 | (0x00ff00ff & x3) << 8, U1.rev15[i2] = (x3 >>> 16 | x3 << 16) >>> 17;
                }
                function pushV1(tgt1, n2, sv1) {
                    for(; 0 != n2--;)tgt1.push(0, sv1);
                }
                for(var i2 = 0; i2 < 32; i2++)U1.ldef[i2] = U1.of0[i2] << 3 | U1.exb[i2], U1.ddef[i2] = U1.df0[i2] << 4 | U1.dxb[i2];
                pushV1(U1.fltree, 144, 8), pushV1(U1.fltree, 112, 9), pushV1(U1.fltree, 24, 7), pushV1(U1.fltree, 8, 8), makeCodes1(U1.fltree, 9), codes2map1(U1.fltree, 9, U1.flmap), revCodes1(U1.fltree, 9), pushV1(U1.fdtree, 32, 5), makeCodes1(U1.fdtree, 5), codes2map1(U1.fdtree, 5, U1.fdmap), revCodes1(U1.fdtree, 5), pushV1(U1.itree, 19, 0), pushV1(U1.ltree, 286, 0), pushV1(U1.dtree, 30, 0), pushV1(U1.ttree, 320, 0);
            }();
            const crc1 = {
                table: function() {
                    for(var tab1 = new Uint32Array(256), n2 = 0; n2 < 256; n2++){
                        for(var c5 = n2, k3 = 0; k3 < 8; k3++)1 & c5 ? c5 = 0xedb88320 ^ c5 >>> 1 : c5 >>>= 1;
                        tab1[n2] = c5;
                    }
                    return tab1;
                }(),
                update: function(c5, buf1, off1, len3) {
                    for(var i2 = 0; i2 < len3; i2++)c5 = crc1.table[(c5 ^ buf1[off1 + i2]) & 0xff] ^ c5 >>> 8;
                    return c5;
                },
                crc: function(b10, o1, l1) {
                    return 0xffffffff ^ crc1.update(0xffffffff, b10, o1, l1);
                }
            };
            function inflateRaw1(file1, buf1) {
                return inflate1(file1, buf1);
            }
            const config3 = {
                numWorkers: 1,
                workerURL: '',
                useWorkers: !1
            };
            let nextId1 = 0, numWorkers1 = 0, canUseWorkers1 = !0;
            const workers1 = [], availableWorkers1 = [], waitingForWorkerQueue1 = [], currentlyProcessingIdToRequestMap1 = new Map();
            function handleResult1(e1) {
                makeWorkerAvailable1(e1.target);
                const { id: id1 , error: error1 , data: data1  } = e1.data, request1 = currentlyProcessingIdToRequestMap1.get(id1);
                currentlyProcessingIdToRequestMap1.delete(id1), error1 ? request1.reject(error1) : request1.resolve(data1);
            }
            function startWorker1(url1) {
                return new Promise((resolve1, reject1)=>{
                    const worker1 = new Worker(url1);
                    worker1.onmessage = (e1)=>{
                        'start' === e1.data ? (worker1.onerror = void 0, worker1.onmessage = void 0, resolve1(worker1)) : reject1(Error(`unexpected message: ${e1.data}`));
                    }, worker1.onerror = reject1;
                });
            }
            function dynamicRequire1(mod1, request1) {
                return mod1.require(request1);
            }
            const workerHelper1 = function() {
                if (!isNode1) return {
                    async createWorker (url1) {
                        let text1;
                        try {
                            const worker1 = await startWorker1(url1);
                            return worker1;
                        } catch (e1) {
                            console.warn('could not load worker:', url1);
                        }
                        try {
                            const req1 = await fetch(url1, {
                                mode: 'cors'
                            });
                            if (!req1.ok) throw Error(`could not load: ${url1}`);
                            text1 = await req1.text(), url1 = URL.createObjectURL(new Blob([
                                text1
                            ], {
                                type: 'application/javascript'
                            }));
                            const worker1 = await startWorker1(url1);
                            return config3.workerURL = url1, worker1;
                        } catch (e1) {
                            console.warn('could not load worker via fetch:', url1);
                        }
                        if (void 0 !== text1) try {
                            url1 = `data:application/javascript;base64,${btoa(text1)}`;
                            const worker1 = await startWorker1(url1);
                            return config3.workerURL = url1, worker1;
                        } catch (e1) {
                            console.warn('could not load worker via dataURI');
                        }
                        throw console.warn('workers will not be used'), Error('can not start workers');
                    },
                    addEventListener (worker1, fn1) {
                        worker1.addEventListener('message', fn1);
                    },
                    async terminate (worker1) {
                        worker1.terminate();
                    }
                };
                {
                    const { Worker: Worker1  } = dynamicRequire1(module1, 'worker_threads');
                    return {
                        createWorker: async (url1)=>new Worker1(url1),
                        addEventListener (worker1, fn1) {
                            worker1.on('message', (data1)=>{
                                fn1({
                                    target: worker1,
                                    data: data1
                                });
                            });
                        },
                        async terminate (worker1) {
                            await worker1.terminate();
                        }
                    };
                }
            }();
            function makeWorkerAvailable1(worker1) {
                availableWorkers1.push(worker1), processWaitingForWorkerQueue1();
            }
            async function getAvailableWorker1() {
                if (0 === availableWorkers1.length && numWorkers1 < config3.numWorkers) {
                    ++numWorkers1;
                    try {
                        const worker1 = await workerHelper1.createWorker(config3.workerURL);
                        workers1.push(worker1), availableWorkers1.push(worker1), workerHelper1.addEventListener(worker1, handleResult1);
                    } catch (e1) {
                        canUseWorkers1 = !1;
                    }
                }
                return availableWorkers1.pop();
            }
            function inflateRawLocal1(src1, uncompressedSize1, type1, resolve1) {
                const dst1 = new Uint8Array(uncompressedSize1);
                inflateRaw1(src1, dst1), resolve1(type1 ? new Blob([
                    dst1
                ], {
                    type: type1
                }) : dst1.buffer);
            }
            async function processWaitingForWorkerQueue1() {
                if (0 !== waitingForWorkerQueue1.length) {
                    if (config3.useWorkers && canUseWorkers1) {
                        const worker1 = await getAvailableWorker1();
                        if (canUseWorkers1) {
                            if (worker1) {
                                if (0 === waitingForWorkerQueue1.length) {
                                    makeWorkerAvailable1(worker1);
                                    return;
                                }
                                const { id: id1 , src: src1 , uncompressedSize: uncompressedSize1 , type: type1 , resolve: resolve1 , reject: reject1  } = waitingForWorkerQueue1.shift();
                                currentlyProcessingIdToRequestMap1.set(id1, {
                                    id: id1,
                                    resolve: resolve1,
                                    reject: reject1
                                });
                                const transferables1 = [];
                                worker1.postMessage({
                                    type: 'inflate',
                                    data: {
                                        id: id1,
                                        type: type1,
                                        src: src1,
                                        uncompressedSize: uncompressedSize1
                                    }
                                }, transferables1);
                            }
                            return;
                        }
                    }
                    for(; waitingForWorkerQueue1.length;){
                        const { src: src1 , uncompressedSize: uncompressedSize1 , type: type1 , resolve: resolve1  } = waitingForWorkerQueue1.shift();
                        let data1 = src1;
                        isBlob1(src1) && (data1 = await readBlobAsUint8Array1(src1)), inflateRawLocal1(data1, uncompressedSize1, type1, resolve1);
                    }
                }
            }
            function setOptions1(options1) {
                config3.workerURL = options1.workerURL || config3.workerURL, options1.workerURL && (config3.useWorkers = !0), config3.useWorkers = void 0 !== options1.useWorkers ? options1.useWorkers : config3.useWorkers, config3.numWorkers = options1.numWorkers || config3.numWorkers;
            }
            function inflateRawAsync1(src1, uncompressedSize1, type1) {
                return new Promise((resolve1, reject1)=>{
                    waitingForWorkerQueue1.push({
                        src: src1,
                        uncompressedSize: uncompressedSize1,
                        type: type1,
                        resolve: resolve1,
                        reject: reject1,
                        id: nextId1++
                    }), processWaitingForWorkerQueue1();
                });
            }
            function clearArray1(arr1) {
                arr1.splice(0, arr1.length);
            }
            async function cleanup1() {
                for (const worker1 of workers1)await workerHelper1.terminate(worker1);
                clearArray1(workers1), clearArray1(availableWorkers1), clearArray1(waitingForWorkerQueue1), currentlyProcessingIdToRequestMap1.clear(), numWorkers1 = 0, canUseWorkers1 = !0;
            }
            function dosDateTimeToDate1(date1, time1) {
                const day1 = 0x1f & date1, month1 = (date1 >> 5 & 0xf) - 1, year1 = (date1 >> 9 & 0x7f) + 1980, millisecond1 = 0, second1 = (0x1f & time1) * 2, minute1 = time1 >> 5 & 0x3f, hour1 = time1 >> 11 & 0x1f;
                return new Date(year1, month1, day1, hour1, minute1, second1, millisecond1);
            }
            class ZipEntry1 {
                constructor(reader1, rawEntry1){
                    this._reader = reader1, this._rawEntry = rawEntry1, this.name = rawEntry1.name, this.nameBytes = rawEntry1.nameBytes, this.size = rawEntry1.uncompressedSize, this.compressedSize = rawEntry1.compressedSize, this.comment = rawEntry1.comment, this.commentBytes = rawEntry1.commentBytes, this.compressionMethod = rawEntry1.compressionMethod, this.lastModDate = dosDateTimeToDate1(rawEntry1.lastModFileDate, rawEntry1.lastModFileTime), this.isDirectory = 0 === rawEntry1.uncompressedSize && rawEntry1.name.endsWith('/'), this.encrypted = !!(0x1 & rawEntry1.generalPurposeBitFlag), this.externalFileAttributes = rawEntry1.externalFileAttributes, this.versionMadeBy = rawEntry1.versionMadeBy;
                }
                async blob(type1 = 'application/octet-stream') {
                    return await readEntryDataAsBlob1(this._reader, this._rawEntry, type1);
                }
                async arrayBuffer() {
                    return await readEntryDataAsArrayBuffer1(this._reader, this._rawEntry);
                }
                async text() {
                    const buffer1 = await this.arrayBuffer();
                    return decodeBuffer1(new Uint8Array(buffer1));
                }
                async json() {
                    const text1 = await this.text();
                    return JSON.parse(text1);
                }
            }
            const EOCDR_WITHOUT_COMMENT_SIZE1 = 22, MAX_COMMENT_SIZE1 = 0xffff, EOCDR_SIGNATURE1 = 0x06054b50, ZIP64_EOCDR_SIGNATURE1 = 0x06064b50;
            async function readAs1(reader1, offset1, length1) {
                return await reader1.read(offset1, length1);
            }
            async function readAsBlobOrTypedArray1(reader1, offset1, length1, type1) {
                return reader1.sliceAsBlob ? await reader1.sliceAsBlob(offset1, length1, type1) : await reader1.read(offset1, length1);
            }
            const crc$11 = {
                unsigned: ()=>0
            };
            function getUint16LE1(uint8View1, offset1) {
                return uint8View1[offset1] + 0x100 * uint8View1[offset1 + 1];
            }
            function getUint32LE1(uint8View1, offset1) {
                return uint8View1[offset1] + 0x100 * uint8View1[offset1 + 1] + 0x10000 * uint8View1[offset1 + 2] + 0x1000000 * uint8View1[offset1 + 3];
            }
            function getUint64LE1(uint8View1, offset1) {
                return getUint32LE1(uint8View1, offset1) + 0x100000000 * getUint32LE1(uint8View1, offset1 + 4);
            }
            const utf8Decoder1 = new TextDecoder();
            function decodeBuffer1(uint8View1, isUTF81) {
                return isSharedArrayBuffer1(uint8View1.buffer) && (uint8View1 = new Uint8Array(uint8View1)), utf8Decoder1.decode(uint8View1);
            }
            async function findEndOfCentralDirector1(reader1, totalLength1) {
                const size1 = Math.min(EOCDR_WITHOUT_COMMENT_SIZE1 + MAX_COMMENT_SIZE1, totalLength1), readStart1 = totalLength1 - size1, data1 = await readAs1(reader1, readStart1, size1);
                for(let i2 = size1 - EOCDR_WITHOUT_COMMENT_SIZE1; i2 >= 0; --i2){
                    if (getUint32LE1(data1, i2) !== EOCDR_SIGNATURE1) continue;
                    const eocdr1 = new Uint8Array(data1.buffer, data1.byteOffset + i2, data1.byteLength - i2), diskNumber1 = getUint16LE1(eocdr1, 4);
                    if (0 !== diskNumber1) throw Error(`multi-volume zip files are not supported. This is volume: ${diskNumber1}`);
                    const entryCount1 = getUint16LE1(eocdr1, 10), centralDirectorySize1 = getUint32LE1(eocdr1, 12), centralDirectoryOffset1 = getUint32LE1(eocdr1, 16), commentLength1 = getUint16LE1(eocdr1, 20), expectedCommentLength1 = eocdr1.length - EOCDR_WITHOUT_COMMENT_SIZE1;
                    if (commentLength1 !== expectedCommentLength1) throw Error(`invalid comment length. expected: ${expectedCommentLength1}, actual: ${commentLength1}`);
                    const commentBytes1 = new Uint8Array(eocdr1.buffer, eocdr1.byteOffset + 22, commentLength1), comment1 = decodeBuffer1(commentBytes1);
                    if (0xffff === entryCount1 || 0xffffffff === centralDirectoryOffset1) return await readZip64CentralDirectory1(reader1, readStart1 + i2, comment1, commentBytes1);
                    return await readEntries1(reader1, centralDirectoryOffset1, centralDirectorySize1, entryCount1, comment1, commentBytes1);
                }
                throw Error('could not find end of central directory. maybe not zip file');
            }
            const END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE1 = 0x07064b50;
            async function readZip64CentralDirectory1(reader1, offset1, comment1, commentBytes1) {
                const zip64EocdlOffset1 = offset1 - 20, eocdl1 = await readAs1(reader1, zip64EocdlOffset1, 20);
                if (getUint32LE1(eocdl1, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE1) throw Error('invalid zip64 end of central directory locator signature');
                const zip64EocdrOffset1 = getUint64LE1(eocdl1, 8), zip64Eocdr1 = await readAs1(reader1, zip64EocdrOffset1, 56);
                if (getUint32LE1(zip64Eocdr1, 0) !== ZIP64_EOCDR_SIGNATURE1) throw Error('invalid zip64 end of central directory record signature');
                const entryCount1 = getUint64LE1(zip64Eocdr1, 32), centralDirectorySize1 = getUint64LE1(zip64Eocdr1, 40), centralDirectoryOffset1 = getUint64LE1(zip64Eocdr1, 48);
                return readEntries1(reader1, centralDirectoryOffset1, centralDirectorySize1, entryCount1, comment1, commentBytes1);
            }
            const CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE1 = 0x02014b50;
            async function readEntries1(reader1, centralDirectoryOffset1, centralDirectorySize1, rawEntryCount1, comment1, commentBytes1) {
                let readEntryCursor1 = 0;
                const allEntriesBuffer1 = await readAs1(reader1, centralDirectoryOffset1, centralDirectorySize1), rawEntries1 = [];
                for(let e1 = 0; e1 < rawEntryCount1; ++e1){
                    const buffer1 = allEntriesBuffer1.subarray(readEntryCursor1, readEntryCursor1 + 46), signature1 = getUint32LE1(buffer1, 0);
                    if (signature1 !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE1) throw Error(`invalid central directory file header signature: 0x${signature1.toString(16)}`);
                    const rawEntry1 = {
                        versionMadeBy: getUint16LE1(buffer1, 4),
                        versionNeededToExtract: getUint16LE1(buffer1, 6),
                        generalPurposeBitFlag: getUint16LE1(buffer1, 8),
                        compressionMethod: getUint16LE1(buffer1, 10),
                        lastModFileTime: getUint16LE1(buffer1, 12),
                        lastModFileDate: getUint16LE1(buffer1, 14),
                        crc32: getUint32LE1(buffer1, 16),
                        compressedSize: getUint32LE1(buffer1, 20),
                        uncompressedSize: getUint32LE1(buffer1, 24),
                        fileNameLength: getUint16LE1(buffer1, 28),
                        extraFieldLength: getUint16LE1(buffer1, 30),
                        fileCommentLength: getUint16LE1(buffer1, 32),
                        internalFileAttributes: getUint16LE1(buffer1, 36),
                        externalFileAttributes: getUint32LE1(buffer1, 38),
                        relativeOffsetOfLocalHeader: getUint32LE1(buffer1, 42)
                    };
                    if (0x40 & rawEntry1.generalPurposeBitFlag) throw Error('strong encryption is not supported');
                    readEntryCursor1 += 46;
                    const data1 = allEntriesBuffer1.subarray(readEntryCursor1, readEntryCursor1 + rawEntry1.fileNameLength + rawEntry1.extraFieldLength + rawEntry1.fileCommentLength);
                    rawEntry1.nameBytes = data1.slice(0, rawEntry1.fileNameLength), rawEntry1.name = decodeBuffer1(rawEntry1.nameBytes);
                    const fileCommentStart1 = rawEntry1.fileNameLength + rawEntry1.extraFieldLength, extraFieldBuffer1 = data1.slice(rawEntry1.fileNameLength, fileCommentStart1);
                    rawEntry1.extraFields = [];
                    let i2 = 0;
                    for(; i2 < extraFieldBuffer1.length - 3;){
                        const headerId1 = getUint16LE1(extraFieldBuffer1, i2 + 0), dataSize1 = getUint16LE1(extraFieldBuffer1, i2 + 2), dataStart1 = i2 + 4, dataEnd1 = dataStart1 + dataSize1;
                        if (dataEnd1 > extraFieldBuffer1.length) throw Error('extra field length exceeds extra field buffer size');
                        rawEntry1.extraFields.push({
                            id: headerId1,
                            data: extraFieldBuffer1.slice(dataStart1, dataEnd1)
                        }), i2 = dataEnd1;
                    }
                    if (rawEntry1.commentBytes = data1.slice(fileCommentStart1, fileCommentStart1 + rawEntry1.fileCommentLength), rawEntry1.comment = decodeBuffer1(rawEntry1.commentBytes), readEntryCursor1 += data1.length, 0xffffffff === rawEntry1.uncompressedSize || 0xffffffff === rawEntry1.compressedSize || 0xffffffff === rawEntry1.relativeOffsetOfLocalHeader) {
                        const zip64ExtraField1 = rawEntry1.extraFields.find((e1)=>0x0001 === e1.id);
                        if (!zip64ExtraField1) throw Error('expected zip64 extended information extra field');
                        const zip64EiefBuffer1 = zip64ExtraField1.data;
                        let index1 = 0;
                        if (0xffffffff === rawEntry1.uncompressedSize) {
                            if (index1 + 8 > zip64EiefBuffer1.length) throw Error('zip64 extended information extra field does not include uncompressed size');
                            rawEntry1.uncompressedSize = getUint64LE1(zip64EiefBuffer1, index1), index1 += 8;
                        }
                        if (0xffffffff === rawEntry1.compressedSize) {
                            if (index1 + 8 > zip64EiefBuffer1.length) throw Error('zip64 extended information extra field does not include compressed size');
                            rawEntry1.compressedSize = getUint64LE1(zip64EiefBuffer1, index1), index1 += 8;
                        }
                        if (0xffffffff === rawEntry1.relativeOffsetOfLocalHeader) {
                            if (index1 + 8 > zip64EiefBuffer1.length) throw Error('zip64 extended information extra field does not include relative header offset');
                            rawEntry1.relativeOffsetOfLocalHeader = getUint64LE1(zip64EiefBuffer1, index1), index1 += 8;
                        }
                    }
                    const nameField1 = rawEntry1.extraFields.find((e1)=>0x7075 === e1.id && e1.data.length >= 6 && 1 === e1.data[0] && getUint32LE1(e1.data, 1), crc$11.unsigned(rawEntry1.nameBytes));
                    if (nameField1 && (rawEntry1.fileName = decodeBuffer1(nameField1.data.slice(5))), 0 === rawEntry1.compressionMethod) {
                        let expectedCompressedSize1 = rawEntry1.uncompressedSize;
                        if ((0x1 & rawEntry1.generalPurposeBitFlag) != 0 && (expectedCompressedSize1 += 12), rawEntry1.compressedSize !== expectedCompressedSize1) throw Error(`compressed size mismatch for stored file: ${rawEntry1.compressedSize} != ${expectedCompressedSize1}`);
                    }
                    rawEntries1.push(rawEntry1);
                }
                const zip1 = {
                    comment: comment1,
                    commentBytes: commentBytes1
                };
                return {
                    zip: zip1,
                    entries: rawEntries1.map((e1)=>new ZipEntry1(reader1, e1))
                };
            }
            async function readEntryDataHeader1(reader1, rawEntry1) {
                let decompress1;
                if (0x1 & rawEntry1.generalPurposeBitFlag) throw Error('encrypted entries not supported');
                const buffer1 = await readAs1(reader1, rawEntry1.relativeOffsetOfLocalHeader, 30), totalLength1 = await reader1.getLength(), signature1 = getUint32LE1(buffer1, 0);
                if (0x04034b50 !== signature1) throw Error(`invalid local file header signature: 0x${signature1.toString(16)}`);
                const fileNameLength1 = getUint16LE1(buffer1, 26), extraFieldLength1 = getUint16LE1(buffer1, 28), localFileHeaderEnd1 = rawEntry1.relativeOffsetOfLocalHeader + buffer1.length + fileNameLength1 + extraFieldLength1;
                if (0 === rawEntry1.compressionMethod) decompress1 = !1;
                else if (8 === rawEntry1.compressionMethod) decompress1 = !0;
                else throw Error(`unsupported compression method: ${rawEntry1.compressionMethod}`);
                const fileDataStart1 = localFileHeaderEnd1, fileDataEnd1 = fileDataStart1 + rawEntry1.compressedSize;
                if (0 !== rawEntry1.compressedSize && fileDataEnd1 > totalLength1) throw Error(`file data overflows file bounds: ${fileDataStart1} +  ${rawEntry1.compressedSize}  > ${totalLength1}`);
                return {
                    decompress: decompress1,
                    fileDataStart: fileDataStart1
                };
            }
            async function readEntryDataAsArrayBuffer1(reader1, rawEntry1) {
                const { decompress: decompress1 , fileDataStart: fileDataStart1  } = await readEntryDataHeader1(reader1, rawEntry1);
                if (!decompress1) {
                    const dataView1 = await readAs1(reader1, fileDataStart1, rawEntry1.compressedSize);
                    return isTypedArraySameAsArrayBuffer1(dataView1) ? dataView1.buffer : dataView1.slice().buffer;
                }
                const typedArrayOrBlob1 = await readAsBlobOrTypedArray1(reader1, fileDataStart1, rawEntry1.compressedSize), result1 = await inflateRawAsync1(typedArrayOrBlob1, rawEntry1.uncompressedSize);
                return result1;
            }
            async function readEntryDataAsBlob1(reader1, rawEntry1, type1) {
                const { decompress: decompress1 , fileDataStart: fileDataStart1  } = await readEntryDataHeader1(reader1, rawEntry1);
                if (!decompress1) {
                    const typedArrayOrBlob1 = await readAsBlobOrTypedArray1(reader1, fileDataStart1, rawEntry1.compressedSize, type1);
                    return isBlob1(typedArrayOrBlob1) ? typedArrayOrBlob1 : new Blob([
                        isSharedArrayBuffer1(typedArrayOrBlob1.buffer) ? new Uint8Array(typedArrayOrBlob1) : typedArrayOrBlob1
                    ], {
                        type: type1
                    });
                }
                const typedArrayOrBlob1 = await readAsBlobOrTypedArray1(reader1, fileDataStart1, rawEntry1.compressedSize), result1 = await inflateRawAsync1(typedArrayOrBlob1, rawEntry1.uncompressedSize, type1);
                return result1;
            }
            function setOptions$11(options1) {
                setOptions1(options1);
            }
            async function unzipRaw1(source1) {
                let reader1;
                if ('undefined' != typeof Blob && source1 instanceof Blob) reader1 = new BlobReader1(source1);
                else if (source1 instanceof ArrayBuffer || source1 && source1.buffer && source1.buffer instanceof ArrayBuffer) reader1 = new ArrayBufferReader1(source1);
                else if (isSharedArrayBuffer1(source1) || isSharedArrayBuffer1(source1.buffer)) reader1 = new ArrayBufferReader1(source1);
                else if ('string' == typeof source1) {
                    const req1 = await fetch(source1);
                    if (!req1.ok) throw Error(`failed http request ${source1}, status: ${req1.status}: ${req1.statusText}`);
                    const blob1 = await req1.blob();
                    reader1 = new BlobReader1(blob1);
                } else if ('function' == typeof source1.getLength && 'function' == typeof source1.read) reader1 = source1;
                else throw Error('unsupported source type');
                const totalLength1 = await reader1.getLength();
                if (totalLength1 > Number.MAX_SAFE_INTEGER) throw Error(`file too large. size: ${totalLength1}. Only file sizes up 4503599627370496 bytes are supported`);
                return await findEndOfCentralDirector1(reader1, totalLength1);
            }
            async function unzip1(source1) {
                const { zip: zip1 , entries: entries1  } = await unzipRaw1(source1);
                return {
                    zip: zip1,
                    entries: Object.fromEntries(entries1.map((v3)=>[
                            v3.name,
                            v3
                        ]))
                };
            }
            function cleanup$11() {
                cleanup1();
            }
        },
        384: function(module1) {
            module1.exports = function(arg4) {
                return arg4 && 'object' == typeof arg4 && 'function' == typeof arg4.copy && 'function' == typeof arg4.fill && 'function' == typeof arg4.readUInt8;
            };
        },
        5955: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var isArgumentsObject1 = __webpack_require__1(2584), isGeneratorFunction1 = __webpack_require__1(8662), whichTypedArray1 = __webpack_require__1(6430), isTypedArray1 = __webpack_require__1(5692);
            function uncurryThis1(f1) {
                return f1.call.bind(f1);
            }
            var BigIntSupported1 = 'undefined' != typeof BigInt, SymbolSupported1 = 'undefined' != typeof Symbol, ObjectToString1 = uncurryThis1(Object.prototype.toString), numberValue1 = uncurryThis1(Number.prototype.valueOf), stringValue1 = uncurryThis1(String.prototype.valueOf), booleanValue1 = uncurryThis1(Boolean.prototype.valueOf);
            if (BigIntSupported1) var bigIntValue1 = uncurryThis1(BigInt.prototype.valueOf);
            if (SymbolSupported1) var symbolValue1 = uncurryThis1(Symbol.prototype.valueOf);
            function checkBoxedPrimitive1(value1, prototypeValueOf1) {
                if ('object' != typeof value1) return !1;
                try {
                    return prototypeValueOf1(value1), !0;
                } catch (e1) {
                    return !1;
                }
            }
            function isPromise1(input1) {
                return 'undefined' != typeof Promise && input1 instanceof Promise || null !== input1 && 'object' == typeof input1 && 'function' == typeof input1.then && 'function' == typeof input1.catch;
            }
            function isArrayBufferView1(value1) {
                return 'undefined' != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(value1) : isTypedArray1(value1) || isDataView1(value1);
            }
            function isUint8Array1(value1) {
                return 'Uint8Array' === whichTypedArray1(value1);
            }
            function isUint8ClampedArray1(value1) {
                return 'Uint8ClampedArray' === whichTypedArray1(value1);
            }
            function isUint16Array1(value1) {
                return 'Uint16Array' === whichTypedArray1(value1);
            }
            function isUint32Array1(value1) {
                return 'Uint32Array' === whichTypedArray1(value1);
            }
            function isInt8Array1(value1) {
                return 'Int8Array' === whichTypedArray1(value1);
            }
            function isInt16Array1(value1) {
                return 'Int16Array' === whichTypedArray1(value1);
            }
            function isInt32Array1(value1) {
                return 'Int32Array' === whichTypedArray1(value1);
            }
            function isFloat32Array1(value1) {
                return 'Float32Array' === whichTypedArray1(value1);
            }
            function isFloat64Array1(value1) {
                return 'Float64Array' === whichTypedArray1(value1);
            }
            function isBigInt64Array1(value1) {
                return 'BigInt64Array' === whichTypedArray1(value1);
            }
            function isBigUint64Array1(value1) {
                return 'BigUint64Array' === whichTypedArray1(value1);
            }
            function isMapToString1(value1) {
                return '[object Map]' === ObjectToString1(value1);
            }
            function isMap1(value1) {
                return 'undefined' != typeof Map && (isMapToString1.working ? isMapToString1(value1) : value1 instanceof Map);
            }
            function isSetToString1(value1) {
                return '[object Set]' === ObjectToString1(value1);
            }
            function isSet1(value1) {
                return 'undefined' != typeof Set && (isSetToString1.working ? isSetToString1(value1) : value1 instanceof Set);
            }
            function isWeakMapToString1(value1) {
                return '[object WeakMap]' === ObjectToString1(value1);
            }
            function isWeakMap1(value1) {
                return 'undefined' != typeof WeakMap && (isWeakMapToString1.working ? isWeakMapToString1(value1) : value1 instanceof WeakMap);
            }
            function isWeakSetToString1(value1) {
                return '[object WeakSet]' === ObjectToString1(value1);
            }
            function isWeakSet1(value1) {
                return isWeakSetToString1(value1);
            }
            function isArrayBufferToString1(value1) {
                return '[object ArrayBuffer]' === ObjectToString1(value1);
            }
            function isArrayBuffer1(value1) {
                return 'undefined' != typeof ArrayBuffer && (isArrayBufferToString1.working ? isArrayBufferToString1(value1) : value1 instanceof ArrayBuffer);
            }
            function isDataViewToString1(value1) {
                return '[object DataView]' === ObjectToString1(value1);
            }
            function isDataView1(value1) {
                return 'undefined' != typeof DataView && (isDataViewToString1.working ? isDataViewToString1(value1) : value1 instanceof DataView);
            }
            exports1.isArgumentsObject = isArgumentsObject1, exports1.isGeneratorFunction = isGeneratorFunction1, exports1.isTypedArray = isTypedArray1, exports1.isPromise = isPromise1, exports1.isArrayBufferView = isArrayBufferView1, exports1.isUint8Array = isUint8Array1, exports1.isUint8ClampedArray = isUint8ClampedArray1, exports1.isUint16Array = isUint16Array1, exports1.isUint32Array = isUint32Array1, exports1.isInt8Array = isInt8Array1, exports1.isInt16Array = isInt16Array1, exports1.isInt32Array = isInt32Array1, exports1.isFloat32Array = isFloat32Array1, exports1.isFloat64Array = isFloat64Array1, exports1.isBigInt64Array = isBigInt64Array1, exports1.isBigUint64Array = isBigUint64Array1, isMapToString1.working = 'undefined' != typeof Map && isMapToString1(new Map()), exports1.isMap = isMap1, isSetToString1.working = 'undefined' != typeof Set && isSetToString1(new Set()), exports1.isSet = isSet1, isWeakMapToString1.working = 'undefined' != typeof WeakMap && isWeakMapToString1(new WeakMap()), exports1.isWeakMap = isWeakMap1, isWeakSetToString1.working = 'undefined' != typeof WeakSet && isWeakSetToString1(new WeakSet()), exports1.isWeakSet = isWeakSet1, isArrayBufferToString1.working = 'undefined' != typeof ArrayBuffer && isArrayBufferToString1(new ArrayBuffer()), exports1.isArrayBuffer = isArrayBuffer1, isDataViewToString1.working = 'undefined' != typeof ArrayBuffer && 'undefined' != typeof DataView && isDataViewToString1(new DataView(new ArrayBuffer(1), 0, 1)), exports1.isDataView = isDataView1;
            var SharedArrayBufferCopy1 = 'undefined' != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
            function isSharedArrayBufferToString1(value1) {
                return '[object SharedArrayBuffer]' === ObjectToString1(value1);
            }
            function isSharedArrayBuffer1(value1) {
                return void 0 !== SharedArrayBufferCopy1 && (void 0 === isSharedArrayBufferToString1.working && (isSharedArrayBufferToString1.working = isSharedArrayBufferToString1(new SharedArrayBufferCopy1())), isSharedArrayBufferToString1.working ? isSharedArrayBufferToString1(value1) : value1 instanceof SharedArrayBufferCopy1);
            }
            function isAsyncFunction1(value1) {
                return '[object AsyncFunction]' === ObjectToString1(value1);
            }
            function isMapIterator1(value1) {
                return '[object Map Iterator]' === ObjectToString1(value1);
            }
            function isSetIterator1(value1) {
                return '[object Set Iterator]' === ObjectToString1(value1);
            }
            function isGeneratorObject1(value1) {
                return '[object Generator]' === ObjectToString1(value1);
            }
            function isWebAssemblyCompiledModule1(value1) {
                return '[object WebAssembly.Module]' === ObjectToString1(value1);
            }
            function isNumberObject1(value1) {
                return checkBoxedPrimitive1(value1, numberValue1);
            }
            function isStringObject1(value1) {
                return checkBoxedPrimitive1(value1, stringValue1);
            }
            function isBooleanObject1(value1) {
                return checkBoxedPrimitive1(value1, booleanValue1);
            }
            function isBigIntObject1(value1) {
                return BigIntSupported1 && checkBoxedPrimitive1(value1, bigIntValue1);
            }
            function isSymbolObject1(value1) {
                return SymbolSupported1 && checkBoxedPrimitive1(value1, symbolValue1);
            }
            function isBoxedPrimitive1(value1) {
                return isNumberObject1(value1) || isStringObject1(value1) || isBooleanObject1(value1) || isBigIntObject1(value1) || isSymbolObject1(value1);
            }
            function isAnyArrayBuffer1(value1) {
                return 'undefined' != typeof Uint8Array && (isArrayBuffer1(value1) || isSharedArrayBuffer1(value1));
            }
            exports1.isSharedArrayBuffer = isSharedArrayBuffer1, exports1.isAsyncFunction = isAsyncFunction1, exports1.isMapIterator = isMapIterator1, exports1.isSetIterator = isSetIterator1, exports1.isGeneratorObject = isGeneratorObject1, exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule1, exports1.isNumberObject = isNumberObject1, exports1.isStringObject = isStringObject1, exports1.isBooleanObject = isBooleanObject1, exports1.isBigIntObject = isBigIntObject1, exports1.isSymbolObject = isSymbolObject1, exports1.isBoxedPrimitive = isBoxedPrimitive1, exports1.isAnyArrayBuffer = isAnyArrayBuffer1, [
                'isProxy',
                'isExternal',
                'isModuleNamespaceObject'
            ].forEach(function(method1) {
                Object.defineProperty(exports1, method1, {
                    enumerable: !1,
                    value: function() {
                        throw Error(method1 + ' is not supported in userland');
                    }
                });
            });
        },
        9539: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            var process1 = __webpack_require__1(3454), getOwnPropertyDescriptors1 = Object.getOwnPropertyDescriptors || function(obj1) {
                for(var keys1 = Object.keys(obj1), descriptors1 = {}, i2 = 0; i2 < keys1.length; i2++)descriptors1[keys1[i2]] = Object.getOwnPropertyDescriptor(obj1, keys1[i2]);
                return descriptors1;
            }, formatRegExp1 = /%[sdj%]/g;
            exports1.format = function(f1) {
                if (!isString1(f1)) {
                    for(var objects1 = [], i2 = 0; i2 < arguments.length; i2++)objects1.push(inspect1(arguments[i2]));
                    return objects1.join(' ');
                }
                for(var i2 = 1, args1 = arguments, len3 = args1.length, str1 = String(f1).replace(formatRegExp1, function(x3) {
                    if ('%%' === x3) return '%';
                    if (i2 >= len3) return x3;
                    switch(x3){
                        case '%s':
                            return String(args1[i2++]);
                        case '%d':
                            return Number(args1[i2++]);
                        case '%j':
                            try {
                                return JSON.stringify(args1[i2++]);
                            } catch (_1) {
                                return '[Circular]';
                            }
                        default:
                            return x3;
                    }
                }), x3 = args1[i2]; i2 < len3; x3 = args1[++i2])isNull1(x3) || !isObject1(x3) ? str1 += ' ' + x3 : str1 += ' ' + inspect1(x3);
                return str1;
            }, exports1.deprecate = function(fn1, msg1) {
                if (void 0 !== process1 && !0 === process1.noDeprecation) return fn1;
                if (void 0 === process1) return function() {
                    return exports1.deprecate(fn1, msg1).apply(this, arguments);
                };
                var warned1 = !1;
                return function() {
                    if (!warned1) {
                        if (process1.throwDeprecation) throw Error(msg1);
                        process1.traceDeprecation ? console.trace(msg1) : console.error(msg1), warned1 = !0;
                    }
                    return fn1.apply(this, arguments);
                };
            };
            var debugs1 = {}, debugEnvRegex1 = /^$/;
            if (process1.env.NODE_DEBUG) {
                var debugEnv1 = process1.env.NODE_DEBUG;
                debugEnvRegex1 = RegExp('^' + (debugEnv1 = debugEnv1.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase()) + '$', 'i');
            }
            function inspect1(obj1, opts1) {
                var ctx1 = {
                    seen: [],
                    stylize: stylizeNoColor1
                };
                return arguments.length >= 3 && (ctx1.depth = arguments[2]), arguments.length >= 4 && (ctx1.colors = arguments[3]), isBoolean1(opts1) ? ctx1.showHidden = opts1 : opts1 && exports1._extend(ctx1, opts1), isUndefined1(ctx1.showHidden) && (ctx1.showHidden = !1), isUndefined1(ctx1.depth) && (ctx1.depth = 2), isUndefined1(ctx1.colors) && (ctx1.colors = !1), isUndefined1(ctx1.customInspect) && (ctx1.customInspect = !0), ctx1.colors && (ctx1.stylize = stylizeWithColor1), formatValue1(ctx1, obj1, ctx1.depth);
            }
            function stylizeWithColor1(str1, styleType1) {
                var style1 = inspect1.styles[styleType1];
                return style1 ? '\u001b[' + inspect1.colors[style1][0] + 'm' + str1 + '\u001b[' + inspect1.colors[style1][1] + 'm' : str1;
            }
            function stylizeNoColor1(str1, styleType1) {
                return str1;
            }
            function arrayToHash1(array1) {
                var hash1 = {};
                return array1.forEach(function(val1, idx1) {
                    hash1[val1] = !0;
                }), hash1;
            }
            function formatValue1(ctx1, value1, recurseTimes1) {
                if (ctx1.customInspect && value1 && isFunction1(value1.inspect) && value1.inspect !== exports1.inspect && !(value1.constructor && value1.constructor.prototype === value1)) {
                    var output1, ret1 = value1.inspect(recurseTimes1, ctx1);
                    return isString1(ret1) || (ret1 = formatValue1(ctx1, ret1, recurseTimes1)), ret1;
                }
                var primitive1 = formatPrimitive1(ctx1, value1);
                if (primitive1) return primitive1;
                var keys1 = Object.keys(value1), visibleKeys1 = arrayToHash1(keys1);
                if (ctx1.showHidden && (keys1 = Object.getOwnPropertyNames(value1)), isError1(value1) && (keys1.indexOf('message') >= 0 || keys1.indexOf('description') >= 0)) return formatError1(value1);
                if (0 === keys1.length) {
                    if (isFunction1(value1)) {
                        var name1 = value1.name ? ': ' + value1.name : '';
                        return ctx1.stylize('[Function' + name1 + ']', 'special');
                    }
                    if (isRegExp1(value1)) return ctx1.stylize(RegExp.prototype.toString.call(value1), 'regexp');
                    if (isDate1(value1)) return ctx1.stylize(Date.prototype.toString.call(value1), 'date');
                    if (isError1(value1)) return formatError1(value1);
                }
                var base1 = '', array1 = !1, braces1 = [
                    '{',
                    '}'
                ];
                return (isArray1(value1) && (array1 = !0, braces1 = [
                    '[',
                    ']'
                ]), isFunction1(value1) && (base1 = ' [Function' + (value1.name ? ': ' + value1.name : '') + ']'), isRegExp1(value1) && (base1 = ' ' + RegExp.prototype.toString.call(value1)), isDate1(value1) && (base1 = ' ' + Date.prototype.toUTCString.call(value1)), isError1(value1) && (base1 = ' ' + formatError1(value1)), 0 !== keys1.length || array1 && 0 != value1.length) ? recurseTimes1 < 0 ? isRegExp1(value1) ? ctx1.stylize(RegExp.prototype.toString.call(value1), 'regexp') : ctx1.stylize('[Object]', 'special') : (ctx1.seen.push(value1), output1 = array1 ? formatArray1(ctx1, value1, recurseTimes1, visibleKeys1, keys1) : keys1.map(function(key1) {
                    return formatProperty1(ctx1, value1, recurseTimes1, visibleKeys1, key1, array1);
                }), ctx1.seen.pop(), reduceToSingleString1(output1, base1, braces1)) : braces1[0] + base1 + braces1[1];
            }
            function formatPrimitive1(ctx1, value1) {
                if (isUndefined1(value1)) return ctx1.stylize('undefined', 'undefined');
                if (isString1(value1)) {
                    var simple1 = '\'' + JSON.stringify(value1).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                    return ctx1.stylize(simple1, 'string');
                }
                return isNumber1(value1) ? ctx1.stylize('' + value1, 'number') : isBoolean1(value1) ? ctx1.stylize('' + value1, 'boolean') : isNull1(value1) ? ctx1.stylize('null', 'null') : void 0;
            }
            function formatError1(value1) {
                return '[' + Error.prototype.toString.call(value1) + ']';
            }
            function formatArray1(ctx1, value1, recurseTimes1, visibleKeys1, keys1) {
                for(var output1 = [], i2 = 0, l1 = value1.length; i2 < l1; ++i2)hasOwnProperty1(value1, String(i2)) ? output1.push(formatProperty1(ctx1, value1, recurseTimes1, visibleKeys1, String(i2), !0)) : output1.push('');
                return keys1.forEach(function(key1) {
                    key1.match(/^\d+$/) || output1.push(formatProperty1(ctx1, value1, recurseTimes1, visibleKeys1, key1, !0));
                }), output1;
            }
            function formatProperty1(ctx1, value1, recurseTimes1, visibleKeys1, key1, array1) {
                var name1, str1, desc1;
                if ((desc1 = Object.getOwnPropertyDescriptor(value1, key1) || {
                    value: value1[key1]
                }).get ? str1 = desc1.set ? ctx1.stylize('[Getter/Setter]', 'special') : ctx1.stylize('[Getter]', 'special') : desc1.set && (str1 = ctx1.stylize('[Setter]', 'special')), hasOwnProperty1(visibleKeys1, key1) || (name1 = '[' + key1 + ']'), !str1 && (0 > ctx1.seen.indexOf(desc1.value) ? (str1 = isNull1(recurseTimes1) ? formatValue1(ctx1, desc1.value, null) : formatValue1(ctx1, desc1.value, recurseTimes1 - 1)).indexOf('\n') > -1 && (str1 = array1 ? str1.split('\n').map(function(line1) {
                    return '  ' + line1;
                }).join('\n').substr(2) : '\n' + str1.split('\n').map(function(line1) {
                    return '   ' + line1;
                }).join('\n')) : str1 = ctx1.stylize('[Circular]', 'special')), isUndefined1(name1)) {
                    if (array1 && key1.match(/^\d+$/)) return str1;
                    (name1 = JSON.stringify('' + key1)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name1 = name1.substr(1, name1.length - 2), name1 = ctx1.stylize(name1, 'name')) : (name1 = name1.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name1 = ctx1.stylize(name1, 'string'));
                }
                return name1 + ': ' + str1;
            }
            function reduceToSingleString1(output1, base1, braces1) {
                var numLinesEst1 = 0;
                return output1.reduce(function(prev1, cur1) {
                    return numLinesEst1++, cur1.indexOf('\n') >= 0 && numLinesEst1++, prev1 + cur1.replace(/\u001b\[\d\d?m/g, '').length + 1;
                }, 0) > 60 ? braces1[0] + ('' === base1 ? '' : base1 + '\n ') + ' ' + output1.join(',\n  ') + ' ' + braces1[1] : braces1[0] + base1 + ' ' + output1.join(', ') + ' ' + braces1[1];
            }
            function isArray1(ar1) {
                return Array.isArray(ar1);
            }
            function isBoolean1(arg4) {
                return 'boolean' == typeof arg4;
            }
            function isNull1(arg4) {
                return null === arg4;
            }
            function isNullOrUndefined1(arg4) {
                return null == arg4;
            }
            function isNumber1(arg4) {
                return 'number' == typeof arg4;
            }
            function isString1(arg4) {
                return 'string' == typeof arg4;
            }
            function isSymbol1(arg4) {
                return 'symbol' == typeof arg4;
            }
            function isUndefined1(arg4) {
                return void 0 === arg4;
            }
            function isRegExp1(re1) {
                return isObject1(re1) && '[object RegExp]' === objectToString1(re1);
            }
            function isObject1(arg4) {
                return 'object' == typeof arg4 && null !== arg4;
            }
            function isDate1(d3) {
                return isObject1(d3) && '[object Date]' === objectToString1(d3);
            }
            function isError1(e1) {
                return isObject1(e1) && ('[object Error]' === objectToString1(e1) || e1 instanceof Error);
            }
            function isFunction1(arg4) {
                return 'function' == typeof arg4;
            }
            function isPrimitive1(arg4) {
                return null === arg4 || 'boolean' == typeof arg4 || 'number' == typeof arg4 || 'string' == typeof arg4 || 'symbol' == typeof arg4 || void 0 === arg4;
            }
            function objectToString1(o1) {
                return Object.prototype.toString.call(o1);
            }
            function pad1(n2) {
                return n2 < 10 ? '0' + n2.toString(10) : n2.toString(10);
            }
            exports1.debuglog = function(set1) {
                if (!debugs1[set1 = set1.toUpperCase()]) {
                    if (debugEnvRegex1.test(set1)) {
                        var pid1 = process1.pid;
                        debugs1[set1] = function() {
                            var msg1 = exports1.format.apply(exports1, arguments);
                            console.error('%s %d: %s', set1, pid1, msg1);
                        };
                    } else debugs1[set1] = function() {};
                }
                return debugs1[set1];
            }, exports1.inspect = inspect1, inspect1.colors = {
                bold: [
                    1,
                    22
                ],
                italic: [
                    3,
                    23
                ],
                underline: [
                    4,
                    24
                ],
                inverse: [
                    7,
                    27
                ],
                white: [
                    37,
                    39
                ],
                grey: [
                    90,
                    39
                ],
                black: [
                    30,
                    39
                ],
                blue: [
                    34,
                    39
                ],
                cyan: [
                    36,
                    39
                ],
                green: [
                    32,
                    39
                ],
                magenta: [
                    35,
                    39
                ],
                red: [
                    31,
                    39
                ],
                yellow: [
                    33,
                    39
                ]
            }, inspect1.styles = {
                special: 'cyan',
                number: 'yellow',
                boolean: 'yellow',
                undefined: 'grey',
                null: 'bold',
                string: 'green',
                date: 'magenta',
                regexp: 'red'
            }, exports1.types = __webpack_require__1(5955), exports1.isArray = isArray1, exports1.isBoolean = isBoolean1, exports1.isNull = isNull1, exports1.isNullOrUndefined = isNullOrUndefined1, exports1.isNumber = isNumber1, exports1.isString = isString1, exports1.isSymbol = isSymbol1, exports1.isUndefined = isUndefined1, exports1.isRegExp = isRegExp1, exports1.types.isRegExp = isRegExp1, exports1.isObject = isObject1, exports1.isDate = isDate1, exports1.types.isDate = isDate1, exports1.isError = isError1, exports1.types.isNativeError = isError1, exports1.isFunction = isFunction1, exports1.isPrimitive = isPrimitive1, exports1.isBuffer = __webpack_require__1(384);
            var months1 = [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'
            ];
            function timestamp1() {
                var d3 = new Date(), time1 = [
                    pad1(d3.getHours()),
                    pad1(d3.getMinutes()),
                    pad1(d3.getSeconds())
                ].join(':');
                return [
                    d3.getDate(),
                    months1[d3.getMonth()],
                    time1
                ].join(' ');
            }
            function hasOwnProperty1(obj1, prop1) {
                return Object.prototype.hasOwnProperty.call(obj1, prop1);
            }
            exports1.log = function() {
                console.log('%s - %s', timestamp1(), exports1.format.apply(exports1, arguments));
            }, exports1.inherits = __webpack_require__1(5717), exports1._extend = function(origin1, add1) {
                if (!add1 || !isObject1(add1)) return origin1;
                for(var keys1 = Object.keys(add1), i2 = keys1.length; i2--;)origin1[keys1[i2]] = add1[keys1[i2]];
                return origin1;
            };
            var kCustomPromisifiedSymbol1 = 'undefined' != typeof Symbol ? Symbol('util.promisify.custom') : void 0;
            function callbackifyOnRejected1(reason1, cb1) {
                if (!reason1) {
                    var newReason1 = Error('Promise was rejected with a falsy value');
                    newReason1.reason = reason1, reason1 = newReason1;
                }
                return cb1(reason1);
            }
            function callbackify1(original1) {
                if ('function' != typeof original1) throw TypeError('The "original" argument must be of type Function');
                function callbackified1() {
                    for(var args1 = [], i2 = 0; i2 < arguments.length; i2++)args1.push(arguments[i2]);
                    var maybeCb1 = args1.pop();
                    if ('function' != typeof maybeCb1) throw TypeError('The last argument must be of type Function');
                    var self1 = this, cb1 = function() {
                        return maybeCb1.apply(self1, arguments);
                    };
                    original1.apply(this, args1).then(function(ret1) {
                        process1.nextTick(cb1.bind(null, null, ret1));
                    }, function(rej1) {
                        process1.nextTick(callbackifyOnRejected1.bind(null, rej1, cb1));
                    });
                }
                return Object.setPrototypeOf(callbackified1, Object.getPrototypeOf(original1)), Object.defineProperties(callbackified1, getOwnPropertyDescriptors1(original1)), callbackified1;
            }
            exports1.promisify = function(original1) {
                if ('function' != typeof original1) throw TypeError('The "original" argument must be of type Function');
                if (kCustomPromisifiedSymbol1 && original1[kCustomPromisifiedSymbol1]) {
                    var fn1 = original1[kCustomPromisifiedSymbol1];
                    if ('function' != typeof fn1) throw TypeError('The "util.promisify.custom" argument must be of type Function');
                    return Object.defineProperty(fn1, kCustomPromisifiedSymbol1, {
                        value: fn1,
                        enumerable: !1,
                        writable: !1,
                        configurable: !0
                    }), fn1;
                }
                function fn1() {
                    for(var promiseResolve1, promiseReject1, promise1 = new Promise(function(resolve1, reject1) {
                        promiseResolve1 = resolve1, promiseReject1 = reject1;
                    }), args1 = [], i2 = 0; i2 < arguments.length; i2++)args1.push(arguments[i2]);
                    args1.push(function(err1, value1) {
                        err1 ? promiseReject1(err1) : promiseResolve1(value1);
                    });
                    try {
                        original1.apply(this, args1);
                    } catch (err1) {
                        promiseReject1(err1);
                    }
                    return promise1;
                }
                return Object.setPrototypeOf(fn1, Object.getPrototypeOf(original1)), kCustomPromisifiedSymbol1 && Object.defineProperty(fn1, kCustomPromisifiedSymbol1, {
                    value: fn1,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }), Object.defineProperties(fn1, getOwnPropertyDescriptors1(original1));
            }, exports1.promisify.custom = kCustomPromisifiedSymbol1, exports1.callbackify = callbackify1;
        },
        345: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.SortKeyCacheResult = exports1.CacheKey = void 0;
            class CacheKey1 {
                constructor(contractTxId1, sortKey1){
                    this.contractTxId = contractTxId1, this.sortKey = sortKey1;
                }
            }
            exports1.CacheKey = CacheKey1;
            class SortKeyCacheResult1 {
                constructor(sortKey1, cachedValue1){
                    this.sortKey = sortKey1, this.cachedValue = cachedValue1;
                }
            }
            exports1.SortKeyCacheResult = SortKeyCacheResult1;
        },
        7563: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.LevelDbCache = void 0;
            const level_11 = __webpack_require__1(3145), memory_level_11 = __webpack_require__1(1271), LoggerFactory_11 = __webpack_require__1(5913);
            class LevelDbCache1 {
                constructor(cacheOptions1){
                    if (this.logger = LoggerFactory_11.LoggerFactory.INST.create('LevelDbCache'), cacheOptions1.inMemory) this.db = new memory_level_11.MemoryLevel({
                        valueEncoding: 'json'
                    });
                    else {
                        if (!cacheOptions1.dbLocation) throw Error('LevelDb cache configuration error - no db location specified');
                        const dbLocation1 = cacheOptions1.dbLocation;
                        this.logger.info(`Using location ${dbLocation1}`), this.db = new level_11.Level(dbLocation1, {
                            valueEncoding: 'json'
                        });
                    }
                }
                async get(contractTxId1, sortKey1, returnDeepCopy1) {
                    const contractCache1 = this.db.sublevel(contractTxId1, {
                        valueEncoding: 'json'
                    });
                    try {
                        const result1 = await contractCache1.get(sortKey1);
                        return {
                            sortKey: sortKey1,
                            cachedValue: result1
                        };
                    } catch (e1) {
                        if ('LEVEL_NOT_FOUND' == e1.code) return null;
                        throw e1;
                    }
                }
                async getLast(contractTxId1) {
                    const contractCache1 = this.db.sublevel(contractTxId1, {
                        valueEncoding: 'json'
                    }), keys1 = await contractCache1.keys({
                        reverse: !0,
                        limit: 1
                    }).all();
                    return keys1.length ? {
                        sortKey: keys1[0],
                        cachedValue: await contractCache1.get(keys1[0])
                    } : null;
                }
                async getLessOrEqual(contractTxId1, sortKey1) {
                    const contractCache1 = this.db.sublevel(contractTxId1, {
                        valueEncoding: 'json'
                    }), keys1 = await contractCache1.keys({
                        reverse: !0,
                        lte: sortKey1,
                        limit: 1
                    }).all();
                    return keys1.length ? {
                        sortKey: keys1[0],
                        cachedValue: await contractCache1.get(keys1[0])
                    } : null;
                }
                async put(stateCacheKey1, value1) {
                    const contractCache1 = this.db.sublevel(stateCacheKey1.contractTxId, {
                        valueEncoding: 'json'
                    });
                    await contractCache1.open(), await contractCache1.put(stateCacheKey1.sortKey, value1);
                }
                close() {
                    return this.db.close();
                }
                async dump() {
                    const result1 = await this.db.iterator().all();
                    return result1;
                }
                async getLastSortKey() {
                    let lastSortKey1 = '';
                    const keys1 = await this.db.keys().all();
                    for (const key1 of keys1){
                        const sortKey1 = key1.substring(45);
                        sortKey1.localeCompare(lastSortKey1) > 0 && (lastSortKey1 = sortKey1);
                    }
                    return '' == lastSortKey1 ? null : lastSortKey1;
                }
                async allContracts() {
                    const keys1 = await this.db.keys().all(), result1 = new Set();
                    return keys1.forEach((k3)=>result1.add(k3.substring(1, 44))), Array.from(result1);
                }
            }
            exports1.LevelDbCache = LevelDbCache1;
        },
        1200: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.MemCache = void 0;
            class MemCache1 {
                constructor(){
                    this.storage = {};
                }
                clearAll() {
                    Object.keys(this.storage).forEach((key1)=>{
                        delete this.storage[key1];
                    });
                }
                contains(key1) {
                    return Object.prototype.hasOwnProperty.call(this.storage, key1);
                }
                get(key1) {
                    return this.storage[key1];
                }
                put(key1, value1) {
                    this.storage[key1] = value1;
                }
                remove(key1) {
                    delete this.storage[key1];
                }
            }
            exports1.MemCache = MemCache1;
        },
        8469: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        9692: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            }, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.HandlerBasedContract = void 0;
            const safe_stable_stringify_11 = __importDefault1(__webpack_require__1(7668)), crypto1 = __importStar1(__webpack_require__1(1087)), ContractCallStack_11 = __webpack_require__1(5614), LexicographicalInteractionsSorter_11 = __webpack_require__1(1967), StateEvaluator_11 = __webpack_require__1(7462), SmartWeaveTags_11 = __webpack_require__1(7312), create_interaction_tx_11 = __webpack_require__1(40), Benchmark_11 = __webpack_require__1(9106), LoggerFactory_11 = __webpack_require__1(5913), Evolve_11 = __webpack_require__1(2491), ArweaveWrapper_11 = __webpack_require__1(9360), utils_11 = __webpack_require__1(5082), CreateContract_11 = __webpack_require__1(3611), SourceImpl_11 = __webpack_require__1(4217), InnerWritesEvaluator_11 = __webpack_require__1(8102);
            class HandlerBasedContract1 {
                constructor(_contractTxId1, warp1, _parentContract1 = null, _callingInteraction1 = null){
                    if (this._contractTxId = _contractTxId1, this.warp = warp1, this._parentContract = _parentContract1, this._callingInteraction = _callingInteraction1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('HandlerBasedContract'), this._evaluationOptions = new StateEvaluator_11.DefaultEvaluationOptions(), this._innerWritesEvaluator = new InnerWritesEvaluator_11.InnerWritesEvaluator(), this._benchmarkStats = null, this.waitForConfirmation = this.waitForConfirmation.bind(this), this._arweaveWrapper = new ArweaveWrapper_11.ArweaveWrapper(warp1.arweave), this._sorter = new LexicographicalInteractionsSorter_11.LexicographicalInteractionsSorter(warp1.arweave), null != _parentContract1) {
                        this._evaluationOptions = _parentContract1.evaluationOptions(), this._callDepth = _parentContract1.callDepth() + 1;
                        const interaction1 = _parentContract1.getCallStack().getInteraction(_callingInteraction1.id);
                        if (this._callDepth > this._evaluationOptions.maxCallDepth) throw Error(`Max call depth of ${this._evaluationOptions.maxCallDepth} has been exceeded for interaction ${JSON.stringify(interaction1.interactionInput)}`);
                        this.logger.debug('Calling interaction', {
                            id: _callingInteraction1.id,
                            sortKey: _callingInteraction1.sortKey
                        });
                        const callStack1 = new ContractCallStack_11.ContractCallStack(_contractTxId1, this._callDepth);
                        interaction1.interactionInput.foreignContractCalls.set(_contractTxId1, callStack1), this._callStack = callStack1, this._rootSortKey = _parentContract1.rootSortKey;
                    } else this._callDepth = 0, this._callStack = new ContractCallStack_11.ContractCallStack(_contractTxId1, 0), this._rootSortKey = null;
                }
                async readState(sortKeyOrBlockHeight1, currentTx1, interactions1) {
                    var _a1, _b1, _c1;
                    this.logger.info('Read state for', {
                        contractTxId: this._contractTxId,
                        currentTx: currentTx1,
                        sortKeyOrBlockHeight: sortKeyOrBlockHeight1
                    });
                    const initBenchmark1 = Benchmark_11.Benchmark.measure();
                    if (this.maybeResetRootContract(), null != this._parentContract && null == sortKeyOrBlockHeight1) throw Error('SortKey MUST be always set for non-root contract calls');
                    const { stateEvaluator: stateEvaluator1  } = this.warp, sortKey1 = 'number' == typeof sortKeyOrBlockHeight1 ? this._sorter.generateLastSortKey(sortKeyOrBlockHeight1) : sortKeyOrBlockHeight1, executionContext1 = await this.createExecutionContext(this._contractTxId, sortKey1, !1, interactions1);
                    this.logger.info('Execution Context', {
                        srcTxId: null === (_a1 = executionContext1.contractDefinition) || void 0 === _a1 ? void 0 : _a1.srcTxId,
                        missingInteractions: null === (_b1 = executionContext1.sortedInteractions) || void 0 === _b1 ? void 0 : _b1.length,
                        cachedSortKey: null === (_c1 = executionContext1.cachedState) || void 0 === _c1 ? void 0 : _c1.sortKey
                    }), initBenchmark1.stop();
                    const stateBenchmark1 = Benchmark_11.Benchmark.measure(), result1 = await stateEvaluator1.eval(executionContext1, currentTx1 || []);
                    stateBenchmark1.stop();
                    const total1 = initBenchmark1.elapsed(!0) + stateBenchmark1.elapsed(!0);
                    return this._benchmarkStats = {
                        gatewayCommunication: initBenchmark1.elapsed(!0),
                        stateEvaluation: stateBenchmark1.elapsed(!0),
                        total: total1
                    }, this.logger.info('Benchmark', {
                        'Gateway communication  ': initBenchmark1.elapsed(),
                        'Contract evaluation    ': stateBenchmark1.elapsed(),
                        'Total:                 ': `${total1.toFixed(0)}ms`
                    }), result1;
                }
                async viewState(input1, tags1 = [], transfer1 = CreateContract_11.emptyTransfer) {
                    return this.logger.info('View state for', this._contractTxId), await this.callContract(input1, void 0, void 0, tags1, transfer1);
                }
                async viewStateForTx(input1, interactionTx1) {
                    return this.logger.info(`View state for ${this._contractTxId}`, interactionTx1), await this.callContractForTx(input1, interactionTx1);
                }
                async dryWrite(input1, caller1, tags1, transfer1) {
                    return this.logger.info('Dry-write for', this._contractTxId), await this.callContract(input1, caller1, void 0, tags1, transfer1);
                }
                async dryWriteFromTx(input1, transaction1, currentTx1) {
                    return this.logger.info(`Dry-write from transaction ${transaction1.id} for ${this._contractTxId}`), await this.callContractForTx(input1, transaction1, currentTx1 || []);
                }
                async writeInteraction(input1, options1) {
                    if (this.logger.info('Write interaction', {
                        input: input1,
                        options: options1
                    }), !this.signer) throw Error("Wallet not connected. Use 'connect' method first.");
                    const { arweave: arweave1 , interactionsLoader: interactionsLoader1  } = this.warp, effectiveTags1 = (null == options1 ? void 0 : options1.tags) || [], effectiveTransfer1 = (null == options1 ? void 0 : options1.transfer) || CreateContract_11.emptyTransfer, effectiveStrict1 = (null == options1 ? void 0 : options1.strict) === !0, effectiveVrf1 = (null == options1 ? void 0 : options1.vrf) === !0, effectiveDisableBundling1 = (null == options1 ? void 0 : options1.disableBundling) === !0, effectiveReward1 = null == options1 ? void 0 : options1.reward, bundleInteraction1 = 'warp' == interactionsLoader1.type() && !effectiveDisableBundling1;
                    if (bundleInteraction1 && effectiveTransfer1.target != CreateContract_11.emptyTransfer.target && effectiveTransfer1.winstonQty != CreateContract_11.emptyTransfer.winstonQty) throw Error('Ar Transfers are not allowed for bundled interactions');
                    if (effectiveVrf1 && !bundleInteraction1) throw Error('Vrf generation is only available for bundle interaction');
                    if (bundleInteraction1) return await this.bundleInteraction(input1, {
                        tags: effectiveTags1,
                        strict: effectiveStrict1,
                        vrf: effectiveVrf1
                    });
                    {
                        const interactionTx1 = await this.createInteraction(input1, effectiveTags1, effectiveTransfer1, effectiveStrict1, !1, !1, effectiveReward1), response1 = await arweave1.transactions.post(interactionTx1);
                        if (200 !== response1.status) return this.logger.error('Error while posting transaction', response1), null;
                        if (this._evaluationOptions.waitForConfirmation) {
                            this.logger.info('Waiting for confirmation of', interactionTx1.id);
                            const benchmark1 = Benchmark_11.Benchmark.measure();
                            await this.waitForConfirmation(interactionTx1.id), this.logger.info('Transaction confirmed after', benchmark1.elapsed());
                        }
                        return 'local' == this.warp.environment && this._evaluationOptions.mineArLocalBlocks && await this.warp.testing.mineBlock(), {
                            originalTxId: interactionTx1.id
                        };
                    }
                }
                async bundleInteraction(input1, options1) {
                    this.logger.info('Bundle interaction input', input1);
                    const interactionTx1 = await this.createInteraction(input1, options1.tags, CreateContract_11.emptyTransfer, options1.strict, !0, options1.vrf), response1 = await fetch(`${this._evaluationOptions.bundlerUrl}gateway/sequencer/register`, {
                        method: 'POST',
                        body: JSON.stringify(interactionTx1),
                        headers: {
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Content-Type': 'application/json',
                            Accept: 'application/json'
                        }
                    }).then((res1)=>(this.logger.debug(res1), res1.ok ? res1.json() : Promise.reject(res1))).catch((error1)=>{
                        var _a1;
                        throw this.logger.error(error1), (null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message) && this.logger.error(error1.body.message), Error(`Unable to bundle interaction: ${JSON.stringify(error1)}`);
                    });
                    return {
                        bundlrResponse: response1,
                        originalTxId: interactionTx1.id
                    };
                }
                async createInteraction(input1, tags1, transfer1, strict1, bundle1 = !1, vrf1 = !1, reward1) {
                    if (this._evaluationOptions.internalWrites) {
                        const handlerResult1 = await this.callContract(input1, void 0, void 0, tags1, transfer1);
                        if (strict1 && 'ok' !== handlerResult1.type) throw Error(`Cannot create interaction: ${handlerResult1.errorMessage}`);
                        const callStack1 = this.getCallStack(), innerWrites1 = this._innerWritesEvaluator.eval(callStack1);
                        this.logger.debug('Input', input1), this.logger.debug('Callstack', callStack1.print()), innerWrites1.forEach((contractTxId1)=>{
                            tags1.push({
                                name: SmartWeaveTags_11.SmartWeaveTags.INTERACT_WRITE,
                                value: contractTxId1
                            });
                        }), this.logger.debug('Tags with inner calls', tags1);
                    } else if (strict1) {
                        const handlerResult1 = await this.callContract(input1, void 0, void 0, tags1, transfer1);
                        if ('ok' !== handlerResult1.type) throw Error(`Cannot create interaction: ${handlerResult1.errorMessage}`);
                    }
                    vrf1 && tags1.push({
                        name: SmartWeaveTags_11.SmartWeaveTags.REQUEST_VRF,
                        value: 'true'
                    });
                    const interactionTx1 = await (0, create_interaction_tx_11.createInteractionTx)(this.warp.arweave, this.signer, this._contractTxId, input1, tags1, transfer1.target, transfer1.winstonQty, bundle1, reward1);
                    return interactionTx1;
                }
                txId() {
                    return this._contractTxId;
                }
                getCallStack() {
                    return this._callStack;
                }
                connect(signer1) {
                    return 'function' == typeof signer1 ? this.signer = signer1 : this.signer = async (tx1)=>{
                        await this.warp.arweave.transactions.sign(tx1, signer1);
                    }, this;
                }
                setEvaluationOptions(options1) {
                    return this._evaluationOptions = {
                        ...this._evaluationOptions,
                        ...options1
                    }, this;
                }
                async waitForConfirmation(transactionId1) {
                    const { arweave: arweave1  } = this.warp, status1 = await arweave1.transactions.getStatus(transactionId1);
                    if (null !== status1.confirmed) return this.logger.info(`Transaction ${transactionId1} confirmed`, status1), status1;
                    this.logger.info(`Transaction ${transactionId1} not yet confirmed. Waiting another 20 seconds before next check.`), await (0, utils_11.sleep)(20000), await this.waitForConfirmation(transactionId1);
                }
                async createExecutionContext(contractTxId1, upToSortKey1, forceDefinitionLoad1 = !1, interactions1) {
                    var _a1;
                    let handler1, contractDefinition1, sortedInteractions1;
                    const { definitionLoader: definitionLoader1 , interactionsLoader: interactionsLoader1 , executorFactory: executorFactory1 , stateEvaluator: stateEvaluator1  } = this.warp, benchmark1 = Benchmark_11.Benchmark.measure(), cachedState1 = await stateEvaluator1.latestAvailableState(contractTxId1, upToSortKey1);
                    this.logger.debug('cache lookup', benchmark1.elapsed()), benchmark1.reset();
                    const evolvedSrcTxId1 = Evolve_11.Evolve.evolvedSrcTxId(null === (_a1 = null == cachedState1 ? void 0 : cachedState1.cachedValue) || void 0 === _a1 ? void 0 : _a1.state);
                    return this.logger.debug('Cached state', cachedState1, upToSortKey1), cachedState1 && cachedState1.sortKey == upToSortKey1 ? (this.logger.debug('State fully cached, not loading interactions.'), (forceDefinitionLoad1 || evolvedSrcTxId1) && (contractDefinition1 = await definitionLoader1.load(contractTxId1, evolvedSrcTxId1), handler1 = await executorFactory1.create(contractDefinition1, this._evaluationOptions))) : ([contractDefinition1, sortedInteractions1] = await Promise.all([
                        definitionLoader1.load(contractTxId1, evolvedSrcTxId1),
                        interactions1 ? Promise.resolve(interactions1) : await interactionsLoader1.load(contractTxId1, null == cachedState1 ? void 0 : cachedState1.sortKey, this.getToSortKey(upToSortKey1), this._evaluationOptions)
                    ]), (null == cachedState1 ? void 0 : cachedState1.sortKey) && (sortedInteractions1 = sortedInteractions1.filter((i2)=>i2.sortKey.localeCompare(null == cachedState1 ? void 0 : cachedState1.sortKey) > 0)), upToSortKey1 && (sortedInteractions1 = sortedInteractions1.filter((i2)=>0 >= i2.sortKey.localeCompare(upToSortKey1))), this.logger.debug('contract and interactions load', benchmark1.elapsed()), null == this._parentContract && sortedInteractions1.length && (this._rootSortKey = sortedInteractions1[sortedInteractions1.length - 1].sortKey), handler1 = await executorFactory1.create(contractDefinition1, this._evaluationOptions)), {
                        warp: this.warp,
                        contract: this,
                        contractDefinition: contractDefinition1,
                        sortedInteractions: sortedInteractions1,
                        evaluationOptions: this._evaluationOptions,
                        handler: handler1,
                        cachedState: cachedState1,
                        requestedSortKey: upToSortKey1
                    };
                }
                getToSortKey(upToSortKey1) {
                    var _a1;
                    return null !== (_a1 = this._parentContract) && void 0 !== _a1 && _a1.rootSortKey ? upToSortKey1 ? this._parentContract.rootSortKey.localeCompare(upToSortKey1) > 0 ? this._parentContract.rootSortKey : upToSortKey1 : this._parentContract.rootSortKey : upToSortKey1;
                }
                async createExecutionContextFromTx(contractTxId1, transaction1) {
                    const caller1 = transaction1.owner.address, sortKey1 = transaction1.sortKey, baseContext1 = await this.createExecutionContext(contractTxId1, sortKey1, !0);
                    return {
                        ...baseContext1,
                        caller: caller1
                    };
                }
                maybeResetRootContract() {
                    null == this._parentContract && (this.logger.debug('Clearing call stack for the root contract'), this._callStack = new ContractCallStack_11.ContractCallStack(this.txId(), 0), this._rootSortKey = null, this.warp.interactionsLoader.clearCache());
                }
                async callContract(input1, caller1, sortKey1, tags1 = [], transfer1 = CreateContract_11.emptyTransfer) {
                    let effectiveCaller1;
                    this.logger.info('Call contract input', input1), this.maybeResetRootContract(), this.signer || this.logger.warn('Wallet not set.');
                    const { arweave: arweave1 , stateEvaluator: stateEvaluator1  } = this.warp;
                    let executionContext1 = await this.createExecutionContext(this._contractTxId, sortKey1, !0);
                    const currentBlockData1 = 'mainnet' == this.warp.environment ? await this._arweaveWrapper.warpGwBlock() : await arweave1.blocks.getCurrent();
                    if (caller1) effectiveCaller1 = caller1;
                    else if (this.signer) {
                        const dummyTx1 = await arweave1.createTransaction({
                            data: Math.random().toString().slice(-4),
                            reward: '72600854',
                            last_tx: 'p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO'
                        });
                        await this.signer(dummyTx1), effectiveCaller1 = await arweave1.wallets.ownerToAddress(dummyTx1.owner);
                    } else effectiveCaller1 = '';
                    this.logger.info('effectiveCaller', effectiveCaller1), executionContext1 = {
                        ...executionContext1,
                        caller: effectiveCaller1
                    };
                    const evalStateResult1 = await stateEvaluator1.eval(executionContext1, []);
                    this.logger.info('Current state', evalStateResult1.cachedValue.state);
                    const interaction1 = {
                        input: input1,
                        caller: executionContext1.caller
                    };
                    this.logger.debug('interaction', interaction1);
                    const tx1 = await (0, create_interaction_tx_11.createInteractionTx)(arweave1, this.signer, this._contractTxId, input1, tags1, transfer1.target, transfer1.winstonQty, !0), dummyTx1 = (0, create_interaction_tx_11.createDummyTx)(tx1, executionContext1.caller, currentBlockData1);
                    this.logger.debug('Creating sortKey for', {
                        blockId: dummyTx1.block.id,
                        id: dummyTx1.id,
                        height: dummyTx1.block.height
                    }), dummyTx1.sortKey = await this._sorter.createSortKey(dummyTx1.block.id, dummyTx1.id, dummyTx1.block.height, !0);
                    const handleResult1 = await this.evalInteraction({
                        interaction: interaction1,
                        interactionTx: dummyTx1,
                        currentTx: []
                    }, executionContext1, evalStateResult1.cachedValue);
                    return 'ok' !== handleResult1.type && this.logger.fatal('Error while interacting with contract', {
                        type: handleResult1.type,
                        error: handleResult1.errorMessage
                    }), handleResult1;
                }
                async callContractForTx(input1, interactionTx1, currentTx1) {
                    this.maybeResetRootContract();
                    const executionContext1 = await this.createExecutionContextFromTx(this._contractTxId, interactionTx1), evalStateResult1 = await this.warp.stateEvaluator.eval(executionContext1, currentTx1);
                    this.logger.debug('callContractForTx - evalStateResult', {
                        result: evalStateResult1.cachedValue.state,
                        txId: this._contractTxId
                    });
                    const interaction1 = {
                        input: input1,
                        caller: this._parentContract.txId()
                    }, interactionData1 = {
                        interaction: interaction1,
                        interactionTx: interactionTx1,
                        currentTx: currentTx1
                    }, result1 = await this.evalInteraction(interactionData1, executionContext1, evalStateResult1.cachedValue);
                    return result1.originalValidity = evalStateResult1.cachedValue.validity, result1.originalErrorMessages = evalStateResult1.cachedValue.errorMessages, result1;
                }
                async evalInteraction(interactionData1, executionContext1, evalStateResult1) {
                    const interactionCall1 = this.getCallStack().addInteractionData(interactionData1), benchmark1 = Benchmark_11.Benchmark.measure(), result1 = await executionContext1.handler.handle(executionContext1, evalStateResult1, interactionData1);
                    return interactionCall1.update({
                        cacheHit: !1,
                        outputState: this._evaluationOptions.stackTrace.saveState ? result1.state : void 0,
                        executionTime: benchmark1.elapsed(!0),
                        valid: 'ok' === result1.type,
                        errorMessage: result1.errorMessage,
                        gasUsed: result1.gasUsed
                    }), result1;
                }
                parent() {
                    return this._parentContract;
                }
                callDepth() {
                    return this._callDepth;
                }
                evaluationOptions() {
                    return this._evaluationOptions;
                }
                lastReadStateStats() {
                    return this._benchmarkStats;
                }
                stateHash(state1) {
                    const jsonState1 = (0, safe_stable_stringify_11.default)(state1), hash1 = crypto1.createHash('sha256');
                    return hash1.update(jsonState1), hash1.digest('hex');
                }
                async syncState(externalUrl1, params1) {
                    const { stateEvaluator: stateEvaluator1  } = this.warp, response1 = await fetch(`${externalUrl1}?${new URLSearchParams({
                        id: this._contractTxId,
                        ...params1
                    })}`).then((res1)=>res1.ok ? res1.json() : Promise.reject(res1)).catch((error1)=>{
                        var _a1, _b1;
                        throw (null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message) && this.logger.error(error1.body.message), Error(`Unable to retrieve state. ${error1.status}: ${null === (_b1 = error1.body) || void 0 === _b1 ? void 0 : _b1.message}`);
                    });
                    return await stateEvaluator1.syncState(this._contractTxId, response1.sortKey, response1.state, response1.validity), this;
                }
                async evolve(newSrcTxId1, options1) {
                    return await this.writeInteraction({
                        function: 'evolve',
                        value: newSrcTxId1
                    }, options1);
                }
                async save(sourceData1) {
                    if (!this.signer) throw Error("Wallet not connected. Use 'connect' method first.");
                    const { arweave: arweave1  } = this.warp, source1 = new SourceImpl_11.SourceImpl(arweave1), srcTx1 = await source1.save(sourceData1, this.signer);
                    return srcTx1.id;
                }
                get callingInteraction() {
                    return this._callingInteraction;
                }
                get rootSortKey() {
                    return this._rootSortKey;
                }
            }
            exports1.HandlerBasedContract = HandlerBasedContract1;
        },
        8102: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.InnerWritesEvaluator = void 0;
            class InnerWritesEvaluator1 {
                eval(callStack1) {
                    const result1 = [];
                    return callStack1.interactions.forEach((interaction1)=>{
                        this.evalForeignCalls(callStack1.contractTxId, interaction1, result1);
                    }), result1;
                }
                evalForeignCalls(rootContractTxId1, interaction1, result1) {
                    interaction1.interactionInput.foreignContractCalls.forEach((foreignContractCall1)=>{
                        foreignContractCall1.interactions.forEach((foreignInteraction1)=>{
                            foreignInteraction1.interactionInput.dryWrite && !result1.includes(foreignContractCall1.contractTxId) && rootContractTxId1 !== foreignContractCall1.contractTxId && result1.push(foreignContractCall1.contractTxId), this.evalForeignCalls(rootContractTxId1, foreignInteraction1, result1);
                        });
                    });
                }
            }
            exports1.InnerWritesEvaluator = InnerWritesEvaluator1;
        },
        7665: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        7819: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.PstContractImpl = void 0;
            const HandlerBasedContract_11 = __webpack_require__1(9692);
            class PstContractImpl1 extends HandlerBasedContract_11.HandlerBasedContract {
                async currentBalance(target1) {
                    const interactionResult1 = await this.viewState({
                        function: 'balance',
                        target: target1
                    });
                    if ('ok' !== interactionResult1.type) throw Error(interactionResult1.errorMessage);
                    return interactionResult1.result;
                }
                async currentState() {
                    return (await super.readState()).cachedValue.state;
                }
                async transfer(transfer1, options1) {
                    return await this.writeInteraction({
                        function: 'transfer',
                        ...transfer1
                    }, options1);
                }
            }
            exports1.PstContractImpl = PstContractImpl1;
        },
        3611: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.emptyTransfer = void 0, exports1.emptyTransfer = {
                target: '',
                winstonQty: '0'
            };
        },
        4722: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        5731: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.DefaultCreateContract = void 0;
            const SmartWeaveTags_11 = __webpack_require__1(7312), WarpFactory_11 = __webpack_require__1(8479), LoggerFactory_11 = __webpack_require__1(5913), SourceImpl_11 = __webpack_require__1(4217);
            class DefaultCreateContract1 {
                constructor(arweave1, warp1){
                    this.arweave = arweave1, this.warp = warp1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('DefaultCreateContract'), this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
                }
                async deploy(contractData1, disableBundling1) {
                    const { wallet: wallet1 , initState: initState1 , tags: tags1 , transfer: transfer1 , data: data1  } = contractData1, effectiveUseBundler1 = void 0 == disableBundling1 ? 'warp' == this.warp.definitionLoader.type() : !disableBundling1, source1 = new SourceImpl_11.SourceImpl(this.arweave), srcTx1 = await source1.save(contractData1, wallet1, effectiveUseBundler1);
                    return this.logger.debug('Creating new contract'), await this.deployFromSourceTx({
                        srcTxId: srcTx1.id,
                        wallet: wallet1,
                        initState: initState1,
                        tags: tags1,
                        transfer: transfer1,
                        data: data1
                    }, !effectiveUseBundler1, srcTx1);
                }
                async deployFromSourceTx(contractData1, disableBundling1, srcTx1 = null) {
                    let responseOk1, response1;
                    this.logger.debug('Creating new contract from src tx');
                    const { wallet: wallet1 , srcTxId: srcTxId1 , initState: initState1 , tags: tags1 , transfer: transfer1 , data: data1  } = contractData1, effectiveUseBundler1 = void 0 == disableBundling1 ? 'warp' == this.warp.definitionLoader.type() : !disableBundling1;
                    let contractTX1 = await this.arweave.createTransaction({
                        data: (null == data1 ? void 0 : data1.body) || initState1
                    }, wallet1);
                    if (+(null == transfer1 ? void 0 : transfer1.winstonQty) > 0 && transfer1.target.length && (this.logger.debug('Creating additional transaction with AR transfer', transfer1), contractTX1 = await this.arweave.createTransaction({
                        data: (null == data1 ? void 0 : data1.body) || initState1,
                        target: transfer1.target,
                        quantity: transfer1.winstonQty
                    }, wallet1)), null == tags1 ? void 0 : tags1.length) for (const tag1 of tags1)contractTX1.addTag(tag1.name.toString(), tag1.value.toString());
                    if (contractTX1.addTag(SmartWeaveTags_11.SmartWeaveTags.APP_NAME, 'SmartWeaveContract'), contractTX1.addTag(SmartWeaveTags_11.SmartWeaveTags.APP_VERSION, '0.3.0'), contractTX1.addTag(SmartWeaveTags_11.SmartWeaveTags.CONTRACT_SRC_TX_ID, srcTxId1), contractTX1.addTag(SmartWeaveTags_11.SmartWeaveTags.SDK, 'RedStone'), data1 ? (contractTX1.addTag(SmartWeaveTags_11.SmartWeaveTags.CONTENT_TYPE, data1['Content-Type']), contractTX1.addTag(SmartWeaveTags_11.SmartWeaveTags.INIT_STATE, initState1)) : contractTX1.addTag(SmartWeaveTags_11.SmartWeaveTags.CONTENT_TYPE, 'application/json'), await this.arweave.transactions.sign(contractTX1, wallet1), effectiveUseBundler1) {
                        const result1 = await this.post(contractTX1, srcTx1);
                        this.logger.debug(result1), responseOk1 = !0;
                    } else responseOk1 = 200 === (response1 = await this.arweave.transactions.post(contractTX1)).status || 208 === response1.status;
                    if (responseOk1) return {
                        contractTxId: contractTX1.id,
                        srcTxId: srcTxId1
                    };
                    throw Error(`Unable to write Contract. Arweave responded with status ${response1.status}: ${response1.statusText}`);
                }
                async post(contractTx1, srcTx1 = null) {
                    let body1 = {
                        contractTx: contractTx1
                    };
                    srcTx1 && (body1 = {
                        ...body1,
                        srcTx: srcTx1
                    });
                    const response1 = await fetch(`${WarpFactory_11.WARP_GW_URL}/gateway/contracts/deploy`, {
                        method: 'POST',
                        body: JSON.stringify(body1),
                        headers: {
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Content-Type': 'application/json',
                            Accept: 'application/json'
                        }
                    });
                    if (response1.ok) return response1.json();
                    throw Error(`Error while posting contract. Sequencer responded with status ${response1.status} ${response1.statusText}`);
                }
            }
            exports1.DefaultCreateContract = DefaultCreateContract1;
        },
        4217: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(8764).Buffer, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.SourceImpl = void 0;
            const redstone_wasm_metering_11 = __importDefault1(__webpack_require__1(8060)), go_wasm_imports_11 = __webpack_require__1(7170), fs_11 = __importDefault1(__webpack_require__1(9827)), wasm_bindgen_tools_11 = __webpack_require__1(4742), SmartWeaveTags_11 = __webpack_require__1(7312), LoggerFactory_11 = __webpack_require__1(5913), wasmTypeMapping1 = new Map([
                [
                    1,
                    'assemblyscript'
                ],
                [
                    2,
                    'rust'
                ],
                [
                    3,
                    'go'
                ]
            ]);
            class SourceImpl1 {
                constructor(arweave1){
                    this.arweave = arweave1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('Source');
                }
                async save(contractData1, signer1, useBundler1 = !1) {
                    let srcTx1, response1;
                    this.logger.debug('Creating new contract source');
                    const { src: src1 , wasmSrcCodeDir: wasmSrcCodeDir1 , wasmGlueCode: wasmGlueCode1  } = contractData1, contractType1 = src1 instanceof Buffer1 ? 'wasm' : 'js';
                    let wasmLang1 = null, wasmVersion1 = null;
                    const metadata1 = {}, data1 = [];
                    if ('wasm' == contractType1) {
                        let lang1;
                        const meteredWasmBinary1 = redstone_wasm_metering_11.default.meterWASM(src1, {
                            meterType: 'i32'
                        });
                        data1.push(meteredWasmBinary1);
                        const wasmModule1 = await WebAssembly.compile(src1), moduleImports1 = WebAssembly.Module.imports(wasmModule1);
                        if (this.isGoModule(moduleImports1)) {
                            const go1 = new go_wasm_imports_11.Go(null), module1 = new WebAssembly.Instance(wasmModule1, go1.importObject);
                            go1.run(module1), lang1 = go1.exports.lang(), wasmVersion1 = go1.exports.version();
                        } else {
                            const module1 = await WebAssembly.instantiate(src1, dummyImports1(moduleImports1));
                            if (!module1.instance.exports.lang) throw Error('No info about source type in wasm binary. Did you forget to export "lang" function?');
                            if (lang1 = module1.instance.exports.lang(), wasmVersion1 = module1.instance.exports.version(), !wasmTypeMapping1.has(lang1)) throw Error(`Unknown wasm source type ${lang1}`);
                        }
                        if (wasmLang1 = wasmTypeMapping1.get(lang1), null == wasmSrcCodeDir1) throw Error('No path to original wasm contract source code');
                        const zippedSourceCode1 = await this.zipContents(wasmSrcCodeDir1);
                        if (data1.push(zippedSourceCode1), 'rust' == wasmLang1) {
                            if (!wasmGlueCode1) throw Error('No path to generated wasm-bindgen js code');
                            const wasmBindgenSrc1 = fs_11.default.readFileSync(wasmGlueCode1, 'utf-8'), dtor1 = (0, wasm_bindgen_tools_11.matchMutClosureDtor)(wasmBindgenSrc1);
                            metadata1.dtor = parseInt(dtor1), data1.push(Buffer1.from(wasmBindgenSrc1));
                        }
                    }
                    const allData1 = 'wasm' == contractType1 ? this.joinBuffers(data1) : src1;
                    (srcTx1 = 'function' == typeof signer1 ? await this.arweave.createTransaction({
                        data: allData1
                    }) : await this.arweave.createTransaction({
                        data: allData1
                    }, signer1)).addTag(SmartWeaveTags_11.SmartWeaveTags.APP_NAME, 'SmartWeaveContractSource'), srcTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.APP_VERSION, '0.3.0'), srcTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.SDK, 'Warp'), srcTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.CONTENT_TYPE, 'js' == contractType1 ? 'application/javascript' : 'application/wasm'), 'wasm' == contractType1 && (srcTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.WASM_LANG, wasmLang1), srcTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.WASM_LANG_VERSION, wasmVersion1), srcTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.WASM_META, JSON.stringify(metadata1))), 'function' == typeof signer1 ? await signer1(srcTx1) : await this.arweave.transactions.sign(srcTx1, signer1), this.logger.debug('Posting transaction with source');
                    let responseOk1 = !0;
                    if (useBundler1 || (responseOk1 = 200 === (response1 = await this.arweave.transactions.post(srcTx1)).status || 208 === response1.status), responseOk1) return srcTx1;
                    throw Error(`Unable to write Contract Source. Arweave responded with status ${response1.status}: ${response1.statusText}`);
                }
                isGoModule(moduleImports1) {
                    return moduleImports1.some((moduleImport1)=>'env' == moduleImport1.module && moduleImport1.name.startsWith('syscall/js'));
                }
                joinBuffers(buffers1) {
                    const length1 = buffers1.length, result1 = [];
                    return result1.push(Buffer1.from(length1.toString())), result1.push(Buffer1.from('|')), buffers1.forEach((b10)=>{
                        result1.push(Buffer1.from(b10.length.toString())), result1.push(Buffer1.from('|'));
                    }), result1.push(...buffers1), result1.reduce((prev1, b10)=>Buffer1.concat([
                            prev1,
                            b10
                        ]));
                }
                async zipContents(source1) {
                    const archiver1 = __webpack_require__1(1445), streamBuffers1 = __webpack_require__1(4034), outputStreamBuffer1 = new streamBuffers1.WritableStreamBuffer({
                        initialSize: 1024000,
                        incrementAmount: 1024000
                    }), archive1 = archiver1('zip', {
                        zlib: {
                            level: 9
                        }
                    });
                    return archive1.on('error', function(err1) {
                        throw err1;
                    }), archive1.pipe(outputStreamBuffer1), archive1.directory(source1.toString(), source1.toString()), await archive1.finalize(), outputStreamBuffer1.end(), outputStreamBuffer1.getContents();
                }
            }
            function dummyImports1(moduleImports1) {
                const imports1 = {};
                return moduleImports1.forEach((moduleImport1)=>{
                    Object.prototype.hasOwnProperty.call(imports1, moduleImport1.module) || (imports1[moduleImport1.module] = {}), imports1[moduleImport1.module][moduleImport1.name] = function() {};
                }), imports1;
            }
            exports1.SourceImpl = SourceImpl1;
        },
        3667: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.MigrationTool = void 0;
            const LexicographicalInteractionsSorter_11 = __webpack_require__1(1967), StateEvaluator_11 = __webpack_require__1(7462), knex_11 = __importDefault1(__webpack_require__1(771)), LoggerFactory_11 = __webpack_require__1(5913);
            class MigrationTool1 {
                constructor(arweave1, levelDb1){
                    this.arweave = arweave1, this.levelDb = levelDb1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('MigrationTool'), this.sorter = new LexicographicalInteractionsSorter_11.LexicographicalInteractionsSorter(arweave1);
                }
                async migrateSqlite(sqlitePath1) {
                    this.logger.info(`Migrating from sqlite ${sqlitePath1} to leveldb.`);
                    const knexDb1 = (0, knex_11.default)({
                        client: 'sqlite3',
                        connection: {
                            filename: sqlitePath1
                        },
                        useNullAsDefault: !0
                    }), cache1 = await knexDb1.select([
                        'contract_id',
                        'height',
                        'state'
                    ]).from('states').max('height').groupBy([
                        'contract_id'
                    ]);
                    this.logger.info(`Migrating ${null == cache1 ? void 0 : cache1.length} contracts' state`);
                    const result1 = [];
                    for (const entry1 of cache1){
                        const contractTxId1 = entry1.contract_id, height1 = entry1.height, state1 = JSON.parse(entry1.state), sortKey1 = this.sorter.generateLastSortKey(parseInt(height1));
                        this.logger.debug(`Migrating ${contractTxId1} at height ${height1}: ${sortKey1}`), await this.levelDb.put({
                            contractTxId: contractTxId1,
                            sortKey: sortKey1
                        }, new StateEvaluator_11.EvalStateResult(state1.state, state1.validity, {})), result1.push({
                            contractTxId: contractTxId1,
                            height: height1,
                            sortKey: sortKey1
                        });
                    }
                    return this.logger.info("Migration done."), result1;
                }
            }
            exports1.MigrationTool = MigrationTool1;
        },
        4464: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.Testing = void 0;
            class Testing1 {
                constructor(arweave1){
                    this.arweave = arweave1;
                }
                async mineBlock() {
                    this.validateEnv(), await this.arweave.api.get('mine');
                }
                async generateWallet() {
                    this.validateEnv();
                    const wallet1 = await this.arweave.wallets.generate();
                    return await this.addFunds(wallet1), wallet1;
                }
                async addFunds(wallet1) {
                    const walletAddress1 = await this.arweave.wallets.getAddress(wallet1);
                    await this.arweave.api.get(`/mint/${walletAddress1}/1000000000000000`);
                }
                validateEnv() {
                    if (this.arweave.api.getConfig().host.includes('arweave')) throw Error('Testing features are not available in a non testing environment');
                }
            }
            exports1.Testing = Testing1;
        },
        5614: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.InteractionOutput = exports1.InteractionInput = exports1.InteractionCall = exports1.ContractCallStack = void 0;
            const utils_11 = __webpack_require__1(5082);
            class ContractCallStack1 {
                constructor(contractTxId1, depth1, label1 = ''){
                    this.contractTxId = contractTxId1, this.depth = depth1, this.label = label1, this.interactions = new Map();
                }
                addInteractionData(interactionData1) {
                    const { interaction: interaction1 , interactionTx: interactionTx1  } = interactionData1, interactionCall1 = InteractionCall1.create(new InteractionInput1(interactionTx1.id, interactionTx1.sortKey, interactionTx1.block.height, interactionTx1.block.timestamp, null == interaction1 ? void 0 : interaction1.caller, null == interaction1 ? void 0 : interaction1.input.function, null == interaction1 ? void 0 : interaction1.input, interactionTx1.dry, new Map()));
                    return this.interactions.set(interactionTx1.id, interactionCall1), interactionCall1;
                }
                getInteraction(txId1) {
                    return this.interactions.get(txId1);
                }
                print() {
                    return JSON.stringify(this, utils_11.mapReplacer);
                }
            }
            exports1.ContractCallStack = ContractCallStack1;
            class InteractionCall1 {
                constructor(interactionInput1){
                    this.interactionInput = interactionInput1;
                }
                static create(interactionInput1) {
                    return new InteractionCall1(interactionInput1);
                }
                update(interactionOutput1) {
                    this.interactionOutput = interactionOutput1;
                }
            }
            exports1.InteractionCall = InteractionCall1;
            class InteractionInput1 {
                constructor(txId1, sortKey1, blockHeight1, blockTimestamp1, caller1, functionName1, functionArguments1, dryWrite1, foreignContractCalls1 = new Map()){
                    this.txId = txId1, this.sortKey = sortKey1, this.blockHeight = blockHeight1, this.blockTimestamp = blockTimestamp1, this.caller = caller1, this.functionName = functionName1, this.functionArguments = functionArguments1, this.dryWrite = dryWrite1, this.foreignContractCalls = foreignContractCalls1;
                }
            }
            exports1.InteractionInput = InteractionInput1;
            class InteractionOutput1 {
                constructor(cacheHit1, outputState1, executionTime1, valid1, errorMessage1 = '', gasUsed1){
                    this.cacheHit = cacheHit1, this.outputState = outputState1, this.executionTime = executionTime1, this.valid = valid1, this.errorMessage = errorMessage1, this.gasUsed = gasUsed1;
                }
            }
            exports1.InteractionOutput = InteractionOutput1;
        },
        9305: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.ContractMetadata = void 0;
            class ContractMetadata1 {
            }
            exports1.ContractMetadata = ContractMetadata1;
        },
        4805: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        8632: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        7312: function(__unused_webpack_module1, exports1) {
            "use strict";
            var SmartWeaveTags1;
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.SmartWeaveTags = void 0, function(SmartWeaveTags1) {
                SmartWeaveTags1.APP_NAME = "App-Name", SmartWeaveTags1.APP_VERSION = "App-Version", SmartWeaveTags1.CONTRACT_TX_ID = "Contract", SmartWeaveTags1.INPUT = "Input", SmartWeaveTags1.CONTENT_TYPE = "Content-Type", SmartWeaveTags1.CONTRACT_SRC_TX_ID = "Contract-Src", SmartWeaveTags1.SDK = "SDK", SmartWeaveTags1.MIN_FEE = "Min-Fee", SmartWeaveTags1.INIT_STATE = "Init-State", SmartWeaveTags1.INIT_STATE_TX = "Init-State-TX", SmartWeaveTags1.INTERACT_WRITE = "Interact-Write", SmartWeaveTags1.WASM_LANG = "Wasm-Lang", SmartWeaveTags1.WASM_LANG_VERSION = "Wasm-Lang-Version", SmartWeaveTags1.WASM_META = "Wasm-Meta", SmartWeaveTags1.REQUEST_VRF = "Request-Vrf";
            }(SmartWeaveTags1 = exports1.SmartWeaveTags || (exports1.SmartWeaveTags = {}));
        },
        2009: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.Warp = void 0;
            const DefaultCreateContract_11 = __webpack_require__1(5731), HandlerBasedContract_11 = __webpack_require__1(9692), PstContractImpl_11 = __webpack_require__1(7819), MigrationTool_11 = __webpack_require__1(3667), Testing_11 = __webpack_require__1(4464), WarpBuilder_11 = __webpack_require__1(9689);
            class Warp1 {
                constructor(arweave1, levelDb1, definitionLoader1, interactionsLoader1, executorFactory1, stateEvaluator1, environment1 = 'custom'){
                    this.arweave = arweave1, this.levelDb = levelDb1, this.definitionLoader = definitionLoader1, this.interactionsLoader = interactionsLoader1, this.executorFactory = executorFactory1, this.stateEvaluator = stateEvaluator1, this.environment = environment1, this.createContract = new DefaultCreateContract_11.DefaultCreateContract(arweave1, this), this.migrationTool = new MigrationTool_11.MigrationTool(arweave1, levelDb1), this.testing = new Testing_11.Testing(arweave1);
                }
                static builder(arweave1, cache1, environment1) {
                    return new WarpBuilder_11.WarpBuilder(arweave1, cache1, environment1);
                }
                contract(contractTxId1, callingContract1, callingInteraction1) {
                    return new HandlerBasedContract_11.HandlerBasedContract(contractTxId1, this, callingContract1, callingInteraction1);
                }
                pst(contractTxId1) {
                    return new PstContractImpl_11.PstContractImpl(contractTxId1, this);
                }
            }
            exports1.Warp = Warp1;
        },
        9689: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.WarpBuilder = void 0;
            const MemCache_11 = __webpack_require__1(1200), DebuggableExecutorFactor_11 = __webpack_require__1(4481), ArweaveGatewayInteractionsLoader_11 = __webpack_require__1(9564), CacheableInteractionsLoader_11 = __webpack_require__1(7346), ContractDefinitionLoader_11 = __webpack_require__1(7089), WarpGatewayContractDefinitionLoader_11 = __webpack_require__1(3187), WarpGatewayInteractionsLoader_11 = __webpack_require__1(1533), Warp_11 = __webpack_require__1(2009);
            class WarpBuilder1 {
                constructor(_arweave1, _cache1, _environment1 = 'custom'){
                    this._arweave = _arweave1, this._cache = _cache1, this._environment = _environment1;
                }
                setDefinitionLoader(value1) {
                    return this._definitionLoader = value1, this;
                }
                setInteractionsLoader(value1) {
                    return this._interactionsLoader = value1, this;
                }
                setExecutorFactory(value1) {
                    return this._executorFactory = value1, this;
                }
                setStateEvaluator(value1) {
                    return this._stateEvaluator = value1, this;
                }
                overwriteSource(sourceCode1) {
                    if (null == this._executorFactory) throw Error('Set base ExecutorFactory first');
                    return this._executorFactory = new DebuggableExecutorFactor_11.DebuggableExecutorFactory(this._executorFactory, sourceCode1), this.build();
                }
                useWarpGateway(gatewayOptions1) {
                    return this._interactionsLoader = new CacheableInteractionsLoader_11.CacheableInteractionsLoader(new WarpGatewayInteractionsLoader_11.WarpGatewayInteractionsLoader(gatewayOptions1.address, gatewayOptions1.confirmationStatus, gatewayOptions1.source)), this._definitionLoader = new WarpGatewayContractDefinitionLoader_11.WarpGatewayContractDefinitionLoader(gatewayOptions1.address, this._arweave, new MemCache_11.MemCache()), this;
                }
                useArweaveGateway() {
                    return this._definitionLoader = new ContractDefinitionLoader_11.ContractDefinitionLoader(this._arweave, new MemCache_11.MemCache()), this._interactionsLoader = new CacheableInteractionsLoader_11.CacheableInteractionsLoader(new ArweaveGatewayInteractionsLoader_11.ArweaveGatewayInteractionsLoader(this._arweave)), this;
                }
                build() {
                    return new Warp_11.Warp(this._arweave, this._cache, this._definitionLoader, this._interactionsLoader, this._executorFactory, this._stateEvaluator, this._environment);
                }
            }
            exports1.WarpBuilder = WarpBuilder1;
        },
        8479: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.WarpFactory = exports1.defaultCacheOptions = exports1.DEFAULT_LEVEL_DB_LOCATION = exports1.defaultWarpGwOptions = exports1.WARP_GW_URL = void 0;
            const arweave_11 = __importDefault1(__webpack_require__1(7386)), LevelDbCache_11 = __webpack_require__1(7563), MemCache_11 = __webpack_require__1(1200), CacheableExecutorFactory_11 = __webpack_require__1(7794), Evolve_11 = __webpack_require__1(2491), CacheableStateEvaluator_11 = __webpack_require__1(4286), HandlerExecutorFactory_11 = __webpack_require__1(9174), Warp_11 = __webpack_require__1(2009);
            exports1.WARP_GW_URL = 'https://d1o5nlqr4okus2.cloudfront.net', exports1.defaultWarpGwOptions = {
                confirmationStatus: {
                    notCorrupted: !0
                },
                source: null,
                address: exports1.WARP_GW_URL
            }, exports1.DEFAULT_LEVEL_DB_LOCATION = './cache/warp', exports1.defaultCacheOptions = {
                inMemory: !1,
                dbLocation: exports1.DEFAULT_LEVEL_DB_LOCATION
            };
            class WarpFactory1 {
                static forLocal(port1 = 1984, arweave1 = arweave_11.default.init({
                    host: 'localhost',
                    port: port1,
                    protocol: 'http'
                }), cacheOptions1 = {
                    ...exports1.defaultCacheOptions,
                    inMemory: !0
                }) {
                    return this.customArweaveGw(arweave1, cacheOptions1, 'local');
                }
                static forTestnet(arweave1 = arweave_11.default.init({
                    host: 'testnet.redstone.tools',
                    port: 443,
                    protocol: 'https'
                }), cacheOptions1 = exports1.defaultCacheOptions) {
                    return this.customArweaveGw(arweave1, cacheOptions1, 'testnet');
                }
                static forMainnet(cacheOptions1 = exports1.defaultCacheOptions, useArweaveGw1 = !1, arweave1 = arweave_11.default.init({
                    host: 'arweave.net',
                    port: 443,
                    protocol: 'https'
                })) {
                    return useArweaveGw1 ? this.customArweaveGw(arweave1, cacheOptions1, 'mainnet') : (console.log(exports1.defaultWarpGwOptions), this.customWarpGw(arweave1, exports1.defaultWarpGwOptions, cacheOptions1, 'mainnet'));
                }
                static custom(arweave1, cacheOptions1, environment1) {
                    const cache1 = new LevelDbCache_11.LevelDbCache({
                        ...cacheOptions1,
                        dbLocation: `${cacheOptions1.dbLocation}/state`
                    }), executorFactory1 = new CacheableExecutorFactory_11.CacheableExecutorFactory(arweave1, new HandlerExecutorFactory_11.HandlerExecutorFactory(arweave1), new MemCache_11.MemCache()), stateEvaluator1 = new CacheableStateEvaluator_11.CacheableStateEvaluator(arweave1, cache1, [
                        new Evolve_11.Evolve()
                    ]);
                    return Warp_11.Warp.builder(arweave1, cache1, environment1).setExecutorFactory(executorFactory1).setStateEvaluator(stateEvaluator1);
                }
                static customArweaveGw(arweave1, cacheOptions1 = exports1.defaultCacheOptions, environment1) {
                    return this.custom(arweave1, cacheOptions1, environment1).useArweaveGateway().build();
                }
                static customWarpGw(arweave1, gatewayOptions1 = exports1.defaultWarpGwOptions, cacheOptions1 = exports1.defaultCacheOptions, environment1) {
                    return this.custom(arweave1, cacheOptions1, environment1).useWarpGateway(gatewayOptions1).build();
                }
            }
            exports1.WarpFactory = WarpFactory1;
        },
        2656: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        5368: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        5765: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        6769: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        7462: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.DefaultEvaluationOptions = exports1.EvalStateResult = void 0;
            class EvalStateResult1 {
                constructor(state1, validity1, errorMessages1){
                    this.state = state1, this.validity = validity1, this.errorMessages = errorMessages1;
                }
            }
            exports1.EvalStateResult = EvalStateResult1;
            class DefaultEvaluationOptions1 {
                constructor(){
                    this.ignoreExceptions = !0, this.waitForConfirmation = !1, this.updateCacheForEachInteraction = !1, this.internalWrites = !1, this.maxCallDepth = 7, this.maxInteractionEvaluationTimeSeconds = 60, this.stackTrace = {
                        saveState: !1
                    }, this.bundlerUrl = "https://d1o5nlqr4okus2.cloudfront.net/", this.gasLimit = Number.MAX_SAFE_INTEGER, this.useFastCopy = !0, this.useVM2 = !1, this.allowUnsafeClient = !1, this.allowBigInt = !1, this.walletBalanceUrl = 'http://nyc-1.dev.arweave.net:1984/', this.mineArLocalBlocks = !0;
                }
            }
            exports1.DefaultEvaluationOptions = DefaultEvaluationOptions1;
        },
        9564: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.ArweaveGatewayInteractionsLoader = exports1.bundledTxsFilter = void 0;
            const SmartWeaveTags_11 = __webpack_require__1(7312), Benchmark_11 = __webpack_require__1(9106), LoggerFactory_11 = __webpack_require__1(5913), ArweaveWrapper_11 = __webpack_require__1(9360), utils_11 = __webpack_require__1(5082), LexicographicalInteractionsSorter_11 = __webpack_require__1(1967), MAX_REQUEST1 = 100;
            function bundledTxsFilter1(tx1) {
                var _a1, _b1;
                return !(null === (_a1 = tx1.node.parent) || void 0 === _a1 ? void 0 : _a1.id) && !(null === (_b1 = tx1.node.bundledIn) || void 0 === _b1 ? void 0 : _b1.id);
            }
            exports1.bundledTxsFilter = bundledTxsFilter1;
            class ArweaveGatewayInteractionsLoader1 {
                constructor(arweave1){
                    this.arweave = arweave1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('ArweaveGatewayInteractionsLoader'), this.arweaveWrapper = new ArweaveWrapper_11.ArweaveWrapper(arweave1), this.sorter = new LexicographicalInteractionsSorter_11.LexicographicalInteractionsSorter(arweave1);
                }
                async load(contractId1, fromSortKey1, toSortKey1, evaluationOptions1) {
                    this.logger.debug('Loading interactions for', {
                        contractId: contractId1,
                        fromSortKey: fromSortKey1,
                        toSortKey: toSortKey1
                    });
                    const fromBlockHeight1 = this.sorter.extractBlockHeight(fromSortKey1), toBlockHeight1 = this.sorter.extractBlockHeight(toSortKey1), mainTransactionsVariables1 = {
                        tags: [
                            {
                                name: SmartWeaveTags_11.SmartWeaveTags.APP_NAME,
                                values: [
                                    'SmartWeaveAction'
                                ]
                            },
                            {
                                name: SmartWeaveTags_11.SmartWeaveTags.CONTRACT_TX_ID,
                                values: [
                                    contractId1
                                ]
                            }
                        ],
                        blockFilter: {
                            min: fromBlockHeight1,
                            max: toBlockHeight1
                        },
                        first: MAX_REQUEST1
                    }, loadingBenchmark1 = Benchmark_11.Benchmark.measure();
                    let interactions1 = await this.loadPages(mainTransactionsVariables1);
                    if (loadingBenchmark1.stop(), evaluationOptions1.internalWrites) {
                        const innerWritesVariables1 = {
                            tags: [
                                {
                                    name: SmartWeaveTags_11.SmartWeaveTags.INTERACT_WRITE,
                                    values: [
                                        contractId1
                                    ]
                                }
                            ],
                            blockFilter: {
                                min: fromBlockHeight1,
                                max: toBlockHeight1
                            },
                            first: MAX_REQUEST1
                        }, innerWritesInteractions1 = await this.loadPages(innerWritesVariables1);
                        this.logger.debug('Inner writes interactions length:', innerWritesInteractions1.length), interactions1 = interactions1.concat(innerWritesInteractions1);
                    }
                    interactions1 = interactions1.filter((i2)=>i2.node.block && i2.node.block.id && i2.node.block.height);
                    let sortedInteractions1 = await this.sorter.sort(interactions1);
                    return fromSortKey1 && toSortKey1 ? sortedInteractions1 = sortedInteractions1.filter((i2)=>i2.node.sortKey.localeCompare(fromSortKey1) > 0 && 0 >= i2.node.sortKey.localeCompare(toSortKey1)) : fromSortKey1 && !toSortKey1 ? sortedInteractions1 = sortedInteractions1.filter((i2)=>i2.node.sortKey.localeCompare(fromSortKey1) > 0) : !fromSortKey1 && toSortKey1 && (sortedInteractions1 = sortedInteractions1.filter((i2)=>0 >= i2.node.sortKey.localeCompare(toSortKey1))), this.logger.debug('All loaded interactions:', {
                        from: fromSortKey1,
                        to: toSortKey1,
                        loaded: sortedInteractions1.length,
                        time: loadingBenchmark1.elapsed()
                    }), sortedInteractions1.map((i2)=>i2.node);
                }
                async loadPages(variables1) {
                    let transactions1 = await this.getNextPage(variables1);
                    const txInfos1 = transactions1.edges.filter((tx1)=>bundledTxsFilter1(tx1));
                    for(; transactions1.pageInfo.hasNextPage;){
                        const cursor1 = transactions1.edges[MAX_REQUEST1 - 1].cursor;
                        variables1 = {
                            ...variables1,
                            after: cursor1
                        }, transactions1 = await this.getNextPage(variables1), txInfos1.push(...transactions1.edges.filter((tx1)=>bundledTxsFilter1(tx1)));
                    }
                    return txInfos1;
                }
                async getNextPage(variables1) {
                    const benchmark1 = Benchmark_11.Benchmark.measure();
                    let response1 = await this.arweaveWrapper.gql(ArweaveGatewayInteractionsLoader1.query, variables1);
                    for(this.logger.debug('GQL page load:', benchmark1.elapsed()); 403 === response1.status;)this.logger.warn(`GQL rate limiting, waiting ${ArweaveGatewayInteractionsLoader1._30seconds}ms before next try.`), await (0, utils_11.sleep)(ArweaveGatewayInteractionsLoader1._30seconds), response1 = await this.arweaveWrapper.gql(ArweaveGatewayInteractionsLoader1.query, variables1);
                    if (200 !== response1.status) throw Error(`Unable to retrieve transactions. Arweave gateway responded with status ${response1.status}.`);
                    if (response1.data.errors) throw this.logger.error(response1.data.errors), Error('Error while loading interaction transactions');
                    const data1 = response1.data, txs1 = data1.data.transactions;
                    return txs1;
                }
                type() {
                    return 'arweave';
                }
                clearCache() {}
            }
            exports1.ArweaveGatewayInteractionsLoader = ArweaveGatewayInteractionsLoader1, ArweaveGatewayInteractionsLoader1.query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {
    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {
      pageInfo {
        hasNextPage
      }
      edges {
        node {
          id
          owner { address }
          recipient
          tags {
            name
            value
          }
          block {
            height
            id
            timestamp
          }
          fee { winston }
          quantity { winston }
          parent { id }
          bundledIn { id }
        }
        cursor
      }
    }
  }`, ArweaveGatewayInteractionsLoader1._30seconds = 30000;
        },
        7346: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.CacheableInteractionsLoader = void 0;
            const LoggerFactory_11 = __webpack_require__1(5913);
            class CacheableInteractionsLoader1 {
                constructor(delegate1){
                    this.delegate = delegate1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('CacheableInteractionsLoader'), this.interactionsCache = new Map();
                }
                async load(contractTxId1, fromSortKey1, toSortKey1, evaluationOptions1) {
                    if (this.logger.debug("Loading interactions for", {
                        contractTxId: contractTxId1,
                        fromSortKey: fromSortKey1,
                        toSortKey: toSortKey1
                    }), this.interactionsCache.has(contractTxId1)) {
                        const cachedInteractions1 = this.interactionsCache.get(contractTxId1);
                        if (null == cachedInteractions1 ? void 0 : cachedInteractions1.length) {
                            const lastCachedKey1 = cachedInteractions1[cachedInteractions1.length - 1].sortKey;
                            if (0 > lastCachedKey1.localeCompare(toSortKey1)) {
                                const missingInteractions1 = await this.delegate.load(contractTxId1, lastCachedKey1, toSortKey1, evaluationOptions1), allInteractions1 = cachedInteractions1.concat(missingInteractions1);
                                return this.interactionsCache.set(contractTxId1, allInteractions1), allInteractions1;
                            }
                        }
                        return cachedInteractions1;
                    }
                    {
                        const interactions1 = await this.delegate.load(contractTxId1, fromSortKey1, toSortKey1, evaluationOptions1);
                        return interactions1.length && this.interactionsCache.set(contractTxId1, interactions1), interactions1;
                    }
                }
                type() {
                    return this.delegate.type();
                }
                clearCache() {
                    this.interactionsCache.clear();
                }
            }
            exports1.CacheableInteractionsLoader = CacheableInteractionsLoader1;
        },
        4286: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.CacheableStateEvaluator = void 0;
            const SortKeyCache_11 = __webpack_require__1(345), LoggerFactory_11 = __webpack_require__1(5913), utils_11 = __webpack_require__1(5082), StateEvaluator_11 = __webpack_require__1(7462), DefaultStateEvaluator_11 = __webpack_require__1(4929), LexicographicalInteractionsSorter_11 = __webpack_require__1(1967);
            class CacheableStateEvaluator1 extends DefaultStateEvaluator_11.DefaultStateEvaluator {
                constructor(arweave1, cache1, executionContextModifiers1 = []){
                    super(arweave1, executionContextModifiers1), this.cache = cache1, this.cLogger = LoggerFactory_11.LoggerFactory.INST.create('CacheableStateEvaluator');
                }
                async eval(executionContext1, currentTx1) {
                    var _a1, _b1, _c1, _d1;
                    const cachedState1 = executionContext1.cachedState;
                    if (cachedState1 && cachedState1.sortKey == executionContext1.requestedSortKey) return this.cLogger.info(`Exact cache hit for sortKey ${null === (_a1 = null == executionContext1 ? void 0 : executionContext1.contractDefinition) || void 0 === _a1 ? void 0 : _a1.txId}:${cachedState1.sortKey}`), null === (_b1 = executionContext1.handler) || void 0 === _b1 || _b1.initState(cachedState1.cachedValue.state), cachedState1;
                    const missingInteractions1 = executionContext1.sortedInteractions, contractTxId1 = executionContext1.contractDefinition.txId;
                    if (!contractTxId1) throw Error('Contract tx id not set in the execution context');
                    for (const entry1 of currentTx1 || [])if (entry1.contractTxId === executionContext1.contractDefinition.txId) {
                        const index1 = missingInteractions1.findIndex((tx1)=>tx1.id === entry1.interactionTxId);
                        -1 !== index1 && (this.cLogger.debug('Inf. Loop fix - removing interaction', {
                            height: missingInteractions1[index1].block.height,
                            contractTxId: entry1.contractTxId,
                            interactionTxId: entry1.interactionTxId,
                            sortKey: missingInteractions1[index1].sortKey
                        }), missingInteractions1.splice(index1));
                    }
                    if (0 == missingInteractions1.length) {
                        if (this.cLogger.info(`No missing interactions ${contractTxId1}`), cachedState1) return null === (_c1 = executionContext1.handler) || void 0 === _c1 || _c1.initState(cachedState1.cachedValue.state), cachedState1;
                        {
                            null === (_d1 = executionContext1.handler) || void 0 === _d1 || _d1.initState(executionContext1.contractDefinition.initState), this.cLogger.debug('Inserting initial state into cache');
                            const stateToCache1 = new StateEvaluator_11.EvalStateResult(executionContext1.contractDefinition.initState, {}, {});
                            return await this.cache.put(new SortKeyCache_11.CacheKey(contractTxId1, LexicographicalInteractionsSorter_11.genesisSortKey), stateToCache1), new SortKeyCache_11.SortKeyCacheResult(LexicographicalInteractionsSorter_11.genesisSortKey, stateToCache1);
                        }
                    }
                    const baseState1 = null == cachedState1 ? executionContext1.contractDefinition.initState : cachedState1.cachedValue.state, baseValidity1 = null == cachedState1 ? {} : cachedState1.cachedValue.validity, baseErrorMessages1 = null == cachedState1 ? {} : cachedState1.cachedValue.errorMessages;
                    return this.cLogger.debug('Base state', baseState1), await this.doReadState(missingInteractions1, new StateEvaluator_11.EvalStateResult(baseState1, baseValidity1, baseErrorMessages1 || {}), executionContext1, currentTx1);
                }
                async onStateEvaluated(transaction1, executionContext1, state1) {
                    const contractTxId1 = executionContext1.contractDefinition.txId;
                    this.cLogger.debug(`${(0, utils_11.indent)(executionContext1.contract.callDepth())}onStateEvaluated: cache update for contract ${contractTxId1} [${transaction1.sortKey}]`), await this.putInCache(contractTxId1, transaction1, state1);
                }
                async onStateUpdate(transaction1, executionContext1, state1, force1 = !1) {
                    (executionContext1.evaluationOptions.updateCacheForEachInteraction || force1) && (this.cLogger.debug(`onStateUpdate: cache update for contract ${executionContext1.contractDefinition.txId} [${transaction1.sortKey}]`, {
                        contract: executionContext1.contractDefinition.txId,
                        state: state1.state,
                        sortKey: transaction1.sortKey
                    }), await this.putInCache(executionContext1.contractDefinition.txId, transaction1, state1));
                }
                async latestAvailableState(contractTxId1, sortKey1) {
                    if (this.cLogger.debug('Searching for', {
                        contractTxId: contractTxId1,
                        sortKey: sortKey1
                    }), !sortKey1) return await this.cache.getLast(contractTxId1);
                    {
                        const stateCache1 = await this.cache.getLessOrEqual(contractTxId1, sortKey1);
                        return stateCache1 && this.cLogger.debug(`Latest available state at ${contractTxId1}: ${stateCache1.sortKey}`), stateCache1;
                    }
                }
                async onInternalWriteStateUpdate(transaction1, contractTxId1, state1) {
                    this.cLogger.debug('Internal write state update:', {
                        sortKey: transaction1.sortKey,
                        dry: transaction1.dry,
                        contractTxId: contractTxId1,
                        state: state1.state
                    }), await this.putInCache(contractTxId1, transaction1, state1);
                }
                async onContractCall(transaction1, executionContext1, state1) {
                    var _a1;
                    if ((null === (_a1 = executionContext1.sortedInteractions) || void 0 === _a1 ? void 0 : _a1.length) == 0) return;
                    const txIndex1 = executionContext1.sortedInteractions.indexOf(transaction1);
                    txIndex1 < 1 || await this.putInCache(executionContext1.contractDefinition.txId, executionContext1.sortedInteractions[txIndex1 - 1], state1);
                }
                async putInCache(contractTxId1, transaction1, state1) {
                    if (transaction1.dry || void 0 !== transaction1.confirmationStatus && 'confirmed' !== transaction1.confirmationStatus) return;
                    const stateToCache1 = new StateEvaluator_11.EvalStateResult(state1.state, state1.validity, state1.errorMessages || {});
                    this.cLogger.debug('Putting into cache', {
                        contractTxId: contractTxId1,
                        transaction: transaction1.id,
                        sortKey: transaction1.sortKey,
                        dry: transaction1.dry,
                        state: stateToCache1.state,
                        validity: stateToCache1.validity
                    }), await this.cache.put(new SortKeyCache_11.CacheKey(contractTxId1, transaction1.sortKey), stateToCache1);
                }
                async syncState(contractTxId1, sortKey1, state1, validity1) {
                    const stateToCache1 = new StateEvaluator_11.EvalStateResult(state1, validity1, {});
                    await this.cache.put(new SortKeyCache_11.CacheKey(contractTxId1, sortKey1), stateToCache1);
                }
                async dumpCache() {
                    return await this.cache.dump();
                }
                async internalWriteState(contractTxId1, sortKey1) {
                    return await this.cache.get(contractTxId1, sortKey1);
                }
                async hasContractCached(contractTxId1) {
                    return await this.cache.getLast(contractTxId1) != null;
                }
                async lastCachedSortKey() {
                    return await this.cache.getLastSortKey();
                }
                async allCachedContracts() {
                    return await this.cache.allContracts();
                }
            }
            exports1.CacheableStateEvaluator = CacheableStateEvaluator1;
        },
        7089: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.ContractDefinitionLoader = void 0;
            const SmartWeaveTags_11 = __webpack_require__1(7312), utils_11 = __webpack_require__1(3633), Benchmark_11 = __webpack_require__1(9106), LoggerFactory_11 = __webpack_require__1(5913), ArweaveWrapper_11 = __webpack_require__1(9360), WasmSrc_11 = __webpack_require__1(6105), supportedSrcContentTypes1 = [
                'application/javascript',
                'application/wasm'
            ];
            class ContractDefinitionLoader1 {
                constructor(arweave1, cache1){
                    this.arweave = arweave1, this.cache = cache1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('ContractDefinitionLoader'), this.arweaveWrapper = new ArweaveWrapper_11.ArweaveWrapper(arweave1);
                }
                async load(contractTxId1, evolvedSrcTxId1) {
                    var _a1, _b1, _c1;
                    if (!evolvedSrcTxId1 && (null === (_a1 = this.cache) || void 0 === _a1 ? void 0 : _a1.contains(contractTxId1))) return this.logger.debug('ContractDefinitionLoader: Hit from cache!'), Promise.resolve(null === (_b1 = this.cache) || void 0 === _b1 ? void 0 : _b1.get(contractTxId1));
                    const benchmark1 = Benchmark_11.Benchmark.measure(), contract1 = await this.doLoad(contractTxId1, evolvedSrcTxId1);
                    return this.logger.info(`Contract definition loaded in: ${benchmark1.elapsed()}`), null === (_c1 = this.cache) || void 0 === _c1 || _c1.put(contractTxId1, contract1), contract1;
                }
                async doLoad(contractTxId1, forcedSrcTxId1) {
                    const benchmark1 = Benchmark_11.Benchmark.measure(), contractTx1 = await this.arweaveWrapper.tx(contractTxId1), owner1 = await this.arweave.wallets.ownerToAddress(contractTx1.owner);
                    this.logger.debug('Contract tx and owner', benchmark1.elapsed()), benchmark1.reset();
                    const contractSrcTxId1 = forcedSrcTxId1 || (0, utils_11.getTag)(contractTx1, SmartWeaveTags_11.SmartWeaveTags.CONTRACT_SRC_TX_ID), minFee1 = (0, utils_11.getTag)(contractTx1, SmartWeaveTags_11.SmartWeaveTags.MIN_FEE);
                    this.logger.debug('Tags decoding', benchmark1.elapsed()), benchmark1.reset();
                    const s3 = await this.evalInitialState(contractTx1);
                    this.logger.debug('init state', s3);
                    const initState1 = JSON.parse(await this.evalInitialState(contractTx1));
                    this.logger.debug('Parsing src and init state', benchmark1.elapsed());
                    const { src: src1 , srcBinary: srcBinary1 , srcWasmLang: srcWasmLang1 , contractType: contractType1 , metadata: metadata1 , srcTx: srcTx1  } = await this.loadContractSource(contractSrcTxId1);
                    return {
                        txId: contractTxId1,
                        srcTxId: contractSrcTxId1,
                        src: src1,
                        srcBinary: srcBinary1,
                        srcWasmLang: srcWasmLang1,
                        initState: initState1,
                        minFee: minFee1,
                        owner: owner1,
                        contractType: contractType1,
                        metadata: metadata1,
                        contractTx: contractTx1.toJSON(),
                        srcTx: srcTx1
                    };
                }
                async loadContractSource(contractSrcTxId1) {
                    let srcWasmLang1, wasmSrc1, srcMetaData1;
                    const benchmark1 = Benchmark_11.Benchmark.measure(), contractSrcTx1 = await this.arweaveWrapper.tx(contractSrcTxId1), srcContentType1 = (0, utils_11.getTag)(contractSrcTx1, SmartWeaveTags_11.SmartWeaveTags.CONTENT_TYPE);
                    if (!supportedSrcContentTypes1.includes(srcContentType1)) throw Error(`Contract source content type ${srcContentType1} not supported`);
                    const contractType1 = 'application/javascript' == srcContentType1 ? 'js' : 'wasm', src1 = 'js' == contractType1 ? await this.arweaveWrapper.txDataString(contractSrcTxId1) : await this.arweaveWrapper.txData(contractSrcTxId1);
                    if ('wasm' == contractType1) {
                        if (wasmSrc1 = new WasmSrc_11.WasmSrc(src1), !(srcWasmLang1 = (0, utils_11.getTag)(contractSrcTx1, SmartWeaveTags_11.SmartWeaveTags.WASM_LANG))) throw Error(`Wasm lang not set for wasm contract src ${contractSrcTxId1}`);
                        srcMetaData1 = JSON.parse((0, utils_11.getTag)(contractSrcTx1, SmartWeaveTags_11.SmartWeaveTags.WASM_META));
                    }
                    return this.logger.debug('Contract src tx load', benchmark1.elapsed()), benchmark1.reset(), {
                        src: 'js' == contractType1 ? src1 : null,
                        srcBinary: 'wasm' == contractType1 ? wasmSrc1.wasmBinary() : null,
                        srcWasmLang: srcWasmLang1,
                        contractType: contractType1,
                        metadata: srcMetaData1,
                        srcTx: contractSrcTx1.toJSON()
                    };
                }
                async evalInitialState(contractTx1) {
                    if ((0, utils_11.getTag)(contractTx1, SmartWeaveTags_11.SmartWeaveTags.INIT_STATE)) return (0, utils_11.getTag)(contractTx1, SmartWeaveTags_11.SmartWeaveTags.INIT_STATE);
                    if (!(0, utils_11.getTag)(contractTx1, SmartWeaveTags_11.SmartWeaveTags.INIT_STATE_TX)) return this.arweaveWrapper.txDataString(contractTx1.id);
                    {
                        const stateTX1 = (0, utils_11.getTag)(contractTx1, SmartWeaveTags_11.SmartWeaveTags.INIT_STATE_TX);
                        return this.arweaveWrapper.txDataString(stateTX1);
                    }
                }
                type() {
                    return 'arweave';
                }
            }
            exports1.ContractDefinitionLoader = ContractDefinitionLoader1;
        },
        4929: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.DefaultStateEvaluator = void 0;
            const vrf_js_11 = __webpack_require__1(8161), elliptic_11 = __importDefault1(__webpack_require__1(6266)), SortKeyCache_11 = __webpack_require__1(345), Benchmark_11 = __webpack_require__1(9106), LoggerFactory_11 = __webpack_require__1(5913), utils_11 = __webpack_require__1(5082), StateEvaluator_11 = __webpack_require__1(7462), StateCache_11 = __webpack_require__1(2138), TagsParser_11 = __webpack_require__1(8996), EC1 = new elliptic_11.default.ec('secp256k1');
            class DefaultStateEvaluator1 {
                constructor(arweave1, executionContextModifiers1 = []){
                    this.arweave = arweave1, this.executionContextModifiers = executionContextModifiers1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('DefaultStateEvaluator'), this.tagsParser = new TagsParser_11.TagsParser();
                }
                async eval(executionContext1, currentTx1) {
                    return this.doReadState(executionContext1.sortedInteractions, new StateEvaluator_11.EvalStateResult(executionContext1.contractDefinition.initState, {}, {}), executionContext1, currentTx1);
                }
                async doReadState(missingInteractions1, baseState1, executionContext1, currentTx1) {
                    var _a1;
                    const { ignoreExceptions: ignoreExceptions1 , stackTrace: stackTrace1 , internalWrites: internalWrites1  } = executionContext1.evaluationOptions, { contract: contract1 , contractDefinition: contractDefinition1 , sortedInteractions: sortedInteractions1  } = executionContext1;
                    let currentState1 = baseState1.state, currentSortKey1 = null;
                    const validity1 = baseState1.validity, errorMessages1 = baseState1.errorMessages;
                    null == executionContext1 || executionContext1.handler.initState(currentState1);
                    const depth1 = executionContext1.contract.callDepth();
                    this.logger.info(`${(0, utils_11.indent)(depth1)}Evaluating state for ${contractDefinition1.txId} [${missingInteractions1.length} non-cached of ${sortedInteractions1.length} all]`);
                    let errorMessage1 = null, lastConfirmedTxState1 = null;
                    const missingInteractionsLength1 = missingInteractions1.length;
                    executionContext1.handler.initState(currentState1);
                    for(let i2 = 0; i2 < missingInteractionsLength1; i2++){
                        const missingInteraction1 = missingInteractions1[i2], singleInteractionBenchmark1 = Benchmark_11.Benchmark.measure();
                        if (currentSortKey1 = missingInteraction1.sortKey, missingInteraction1.vrf && !this.verifyVrf(missingInteraction1.vrf, missingInteraction1.sortKey, this.arweave)) throw Error('Vrf verification failed.');
                        this.logger.debug(`${(0, utils_11.indent)(depth1)}[${contractDefinition1.txId}][${missingInteraction1.id}][${missingInteraction1.block.height}]: ${missingInteractions1.indexOf(missingInteraction1) + 1}/${missingInteractions1.length} [of all:${sortedInteractions1.length}]`);
                        const isInteractWrite1 = this.tagsParser.isInteractWrite(missingInteraction1, contractDefinition1.txId);
                        if (isInteractWrite1 && internalWrites1) {
                            const writingContractTxId1 = this.tagsParser.getContractTag(missingInteraction1);
                            this.logger.debug(`${(0, utils_11.indent)(depth1)}Internal Write - Loading writing contract`, writingContractTxId1);
                            const interactionCall1 = contract1.getCallStack().addInteractionData({
                                interaction: null,
                                interactionTx: missingInteraction1,
                                currentTx: currentTx1
                            }), writingContract1 = executionContext1.warp.contract(writingContractTxId1, executionContext1.contract, missingInteraction1);
                            await this.onContractCall(missingInteraction1, executionContext1, new StateEvaluator_11.EvalStateResult(currentState1, validity1, errorMessages1)), this.logger.debug(`${(0, utils_11.indent)(depth1)}Reading state of the calling contract at`, missingInteraction1.sortKey), await writingContract1.readState(missingInteraction1.sortKey, [
                                ...currentTx1 || [],
                                {
                                    contractTxId: contractDefinition1.txId,
                                    interactionTxId: missingInteraction1.id
                                }
                            ]);
                            const newState1 = await this.internalWriteState(contractDefinition1.txId, missingInteraction1.sortKey);
                            if (null !== newState1) {
                                currentState1 = newState1.cachedValue.state, null == executionContext1 || executionContext1.handler.initState(currentState1), validity1[missingInteraction1.id] = newState1.cachedValue.validity[missingInteraction1.id], (null === (_a1 = newState1.cachedValue.errorMessages) || void 0 === _a1 ? void 0 : _a1[missingInteraction1.id]) && (errorMessages1[missingInteraction1.id] = newState1.cachedValue.errorMessages[missingInteraction1.id]);
                                const toCache1 = new StateEvaluator_11.EvalStateResult(currentState1, validity1, errorMessages1);
                                await this.onStateUpdate(missingInteraction1, executionContext1, toCache1), (0, StateCache_11.canBeCached)(missingInteraction1) && (lastConfirmedTxState1 = {
                                    tx: missingInteraction1,
                                    state: toCache1
                                });
                            } else validity1[missingInteraction1.id] = !1;
                            interactionCall1.update({
                                cacheHit: !1,
                                outputState: stackTrace1.saveState ? currentState1 : void 0,
                                executionTime: singleInteractionBenchmark1.elapsed(!0),
                                valid: validity1[missingInteraction1.id],
                                errorMessage: errorMessage1,
                                gasUsed: 0
                            });
                        } else {
                            const inputTag1 = this.tagsParser.getInputTag(missingInteraction1, executionContext1.contractDefinition.txId);
                            if (!inputTag1) {
                                this.logger.error(`${(0, utils_11.indent)(depth1)}Skipping tx - Input tag not found for ${missingInteraction1.id}`);
                                continue;
                            }
                            const input1 = this.parseInput(inputTag1);
                            if (!input1) {
                                this.logger.error(`${(0, utils_11.indent)(depth1)}Skipping tx - invalid Input tag - ${missingInteraction1.id}`);
                                continue;
                            }
                            const interaction1 = {
                                input: input1,
                                caller: missingInteraction1.owner.address
                            }, interactionData1 = {
                                interaction: interaction1,
                                interactionTx: missingInteraction1,
                                currentTx: currentTx1
                            };
                            this.logger.debug(`${(0, utils_11.indent)(depth1)}Interaction:`, interaction1);
                            const interactionCall1 = contract1.getCallStack().addInteractionData(interactionData1), result1 = await executionContext1.handler.handle(executionContext1, new StateEvaluator_11.EvalStateResult(currentState1, validity1, errorMessages1), interactionData1);
                            if (errorMessage1 = result1.errorMessage, 'ok' !== result1.type && (errorMessages1[missingInteraction1.id] = errorMessage1), this.logResult(result1, missingInteraction1, executionContext1), this.logger.debug(`${(0, utils_11.indent)(depth1)}Interaction evaluation`, singleInteractionBenchmark1.elapsed()), interactionCall1.update({
                                cacheHit: !1,
                                outputState: stackTrace1.saveState ? currentState1 : void 0,
                                executionTime: singleInteractionBenchmark1.elapsed(!0),
                                valid: validity1[missingInteraction1.id],
                                errorMessage: errorMessage1,
                                gasUsed: result1.gasUsed
                            }), 'exception' === result1.type && !0 !== ignoreExceptions1) throw Error(`Exception while processing ${JSON.stringify(interaction1)}:\n${result1.errorMessage}`);
                            validity1[missingInteraction1.id] = 'ok' === result1.type, currentState1 = result1.state;
                            const toCache1 = new StateEvaluator_11.EvalStateResult(currentState1, validity1, errorMessages1);
                            (0, StateCache_11.canBeCached)(missingInteraction1) && (lastConfirmedTxState1 = {
                                tx: missingInteraction1,
                                state: toCache1
                            }), await this.onStateUpdate(missingInteraction1, executionContext1, toCache1);
                        }
                        for (const { modify: modify1  } of this.executionContextModifiers)executionContext1 = await modify1(currentState1, executionContext1);
                    }
                    const evalStateResult1 = new StateEvaluator_11.EvalStateResult(currentState1, validity1, errorMessages1);
                    return null !== lastConfirmedTxState1 && await this.onStateEvaluated(lastConfirmedTxState1.tx, executionContext1, lastConfirmedTxState1.state), new SortKeyCache_11.SortKeyCacheResult(currentSortKey1, evalStateResult1);
                }
                verifyVrf(vrf1, sortKey1, arweave1) {
                    let hash1;
                    const keys1 = EC1.keyFromPublic(vrf1.pubkey, 'hex');
                    try {
                        hash1 = (0, vrf_js_11.ProofHoHash)(keys1.getPublic(), arweave1.utils.stringToBuffer(sortKey1), arweave1.utils.b64UrlToBuffer(vrf1.proof));
                    } catch (e1) {
                        return !1;
                    }
                    return arweave1.utils.bufferTob64Url(hash1) == vrf1.index;
                }
                logResult(result1, currentTx1, executionContext1) {
                    'exception' === result1.type && this.logger.error(`Executing of interaction: [${executionContext1.contractDefinition.txId} -> ${currentTx1.id}] threw exception:`, `${result1.errorMessage}`), 'error' === result1.type && this.logger.warn(`Executing of interaction: [${executionContext1.contractDefinition.txId} -> ${currentTx1.id}] returned error:`, result1.errorMessage);
                }
                parseInput(inputTag1) {
                    try {
                        return JSON.parse(inputTag1.value);
                    } catch (e1) {
                        return this.logger.error(e1), null;
                    }
                }
            }
            exports1.DefaultStateEvaluator = DefaultStateEvaluator1;
        },
        9174: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __setModuleDefault1 = this && this.__setModuleDefault || (Object.create ? function(o1, v3) {
                Object.defineProperty(o1, "default", {
                    enumerable: !0,
                    value: v3
                });
            } : function(o1, v3) {
                o1.default = v3;
            }), __importStar1 = this && this.__importStar || function(mod1) {
                if (mod1 && mod1.__esModule) return mod1;
                var result1 = {};
                if (null != mod1) for(var k3 in mod1)"default" !== k3 && Object.prototype.hasOwnProperty.call(mod1, k3) && __createBinding1(result1, mod1, k3);
                return __setModuleDefault1(result1, mod1), result1;
            }, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.HandlerExecutorFactory = void 0;
            const loader_11 = __importDefault1(__webpack_require__1(7605)), as_wasm_imports_11 = __webpack_require__1(1692), rust_wasm_imports_11 = __webpack_require__1(6505), go_wasm_imports_11 = __webpack_require__1(7170), bignumber_js_11 = __importDefault1(__webpack_require__1(4431)), vm21 = __importStar1(__webpack_require__1(7840)), smartweave_global_11 = __webpack_require__1(8563), Benchmark_11 = __webpack_require__1(9106), LoggerFactory_11 = __webpack_require__1(5913), JsHandlerApi_11 = __webpack_require__1(1515), WasmHandlerApi_11 = __webpack_require__1(3425), normalize_source_11 = __webpack_require__1(4965), MemCache_11 = __webpack_require__1(1200);
            class ContractError1 extends Error {
                constructor(message1){
                    super(message1), this.name = 'ContractError';
                }
            }
            class HandlerExecutorFactory1 {
                constructor(arweave1){
                    this.arweave = arweave1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('HandlerExecutorFactory'), this.cache = new MemCache_11.MemCache();
                }
                async create(contractDefinition1, evaluationOptions1) {
                    const swGlobal1 = new smartweave_global_11.SmartWeaveGlobal(this.arweave, {
                        id: contractDefinition1.txId,
                        owner: contractDefinition1.owner
                    }, evaluationOptions1);
                    if ('wasm' == contractDefinition1.contractType) {
                        let wasmInstance1;
                        this.logger.info('Creating handler for wasm contract', contractDefinition1.txId);
                        const benchmark1 = Benchmark_11.Benchmark.measure();
                        let jsExports1 = null;
                        const wasmResponse1 = generateResponse1(contractDefinition1.srcBinary);
                        switch(contractDefinition1.srcWasmLang){
                            case 'assemblyscript':
                                {
                                    const wasmInstanceExports1 = {
                                        exports: null
                                    };
                                    wasmInstance1 = await loader_11.default.instantiateStreaming(wasmResponse1, (0, as_wasm_imports_11.asWasmImports)(swGlobal1, wasmInstanceExports1)), wasmInstanceExports1.exports = wasmInstance1.exports;
                                    break;
                                }
                            case 'rust':
                                {
                                    const wasmInstanceExports1 = {
                                        exports: null,
                                        modifiedExports: {
                                            wasm_bindgen__convert__closures__invoke2_mut__: null,
                                            _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__: null
                                        }
                                    }, wasmModule1 = await getWasmModule1(wasmResponse1, contractDefinition1.srcBinary), moduleImports1 = WebAssembly.Module.imports(wasmModule1), wbindgenImports1 = moduleImports1.filter((imp1)=>'__wbindgen_placeholder__' === imp1.module).map((imp1)=>imp1.name), { imports: imports1 , exports: exports1  } = (0, rust_wasm_imports_11.rustWasmImports)(swGlobal1, wbindgenImports1, wasmInstanceExports1, contractDefinition1.metadata.dtor);
                                    jsExports1 = exports1, wasmInstance1 = await WebAssembly.instantiate(wasmModule1, imports1), wasmInstanceExports1.exports = wasmInstance1.exports;
                                    const moduleExports1 = Object.keys(wasmInstance1.exports);
                                    moduleExports1.forEach((moduleExport1)=>{
                                        moduleExport1.startsWith('wasm_bindgen__convert__closures__invoke2_mut__') && (wasmInstanceExports1.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__ = wasmInstance1.exports[moduleExport1]), moduleExport1.startsWith('_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__') && (wasmInstanceExports1.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ = wasmInstance1.exports[moduleExport1]);
                                    });
                                    break;
                                }
                            case 'go':
                                {
                                    const go1 = new go_wasm_imports_11.Go(swGlobal1);
                                    go1.importObject.metering = {
                                        usegas: function(value1) {
                                            swGlobal1.useGas(value1);
                                        }
                                    };
                                    const wasmModule1 = await getWasmModule1(wasmResponse1, contractDefinition1.srcBinary);
                                    wasmInstance1 = await WebAssembly.instantiate(wasmModule1, go1.importObject), go1.run(wasmInstance1), jsExports1 = go1.exports;
                                    break;
                                }
                            default:
                                throw Error(`Support for ${contractDefinition1.srcWasmLang} not implemented yet.`);
                        }
                        return this.logger.info(`WASM ${contractDefinition1.srcWasmLang} handler created in ${benchmark1.elapsed()}`), new WasmHandlerApi_11.WasmHandlerApi(swGlobal1, contractDefinition1, jsExports1 || wasmInstance1.exports);
                    }
                    {
                        this.logger.info('Creating handler for js contract', contractDefinition1.txId);
                        const normalizedSource1 = (0, normalize_source_11.normalizeContractSource)(contractDefinition1.src, evaluationOptions1.useVM2);
                        if (!evaluationOptions1.allowUnsafeClient && normalizedSource1.includes('SmartWeave.unsafeClient')) throw Error('Using unsafeClient is not allowed by default. Use EvaluationOptions.allowUnsafeClient flag.');
                        if (!evaluationOptions1.allowBigInt && normalizedSource1.includes('BigInt')) throw Error('Using BigInt is not allowed by default. Use EvaluationOptions.allowBigInt flag.');
                        if (evaluationOptions1.useVM2) {
                            const vmScript1 = new vm21.VMScript(normalizedSource1), vm1 = new vm21.NodeVM({
                                console: 'off',
                                sandbox: {
                                    SmartWeave: swGlobal1,
                                    BigNumber: bignumber_js_11.default,
                                    logger: this.logger,
                                    ContractError: ContractError1,
                                    ContractAssert: function(cond1, message1) {
                                        if (!cond1) throw new ContractError1(message1);
                                    }
                                },
                                compiler: 'javascript',
                                eval: !1,
                                wasm: !1,
                                allowAsync: !0,
                                wrapper: 'commonjs'
                            });
                            return new JsHandlerApi_11.JsHandlerApi(swGlobal1, contractDefinition1, vm1.run(vmScript1));
                        }
                        {
                            const contractFunction1 = Function(normalizedSource1), handler1 = contractFunction1(swGlobal1, bignumber_js_11.default, LoggerFactory_11.LoggerFactory.INST.create(swGlobal1.contract.id));
                            return new JsHandlerApi_11.JsHandlerApi(swGlobal1, contractDefinition1, handler1);
                        }
                    }
                }
            }
            function generateResponse1(wasmBinary1) {
                const init1 = {
                    status: 200,
                    statusText: 'OK',
                    headers: {
                        'Content-Type': 'application/wasm'
                    }
                };
                return new Response(wasmBinary1, init1);
            }
            async function getWasmModule1(wasmResponse1, binary1) {
                return WebAssembly.compileStreaming ? await WebAssembly.compileStreaming(wasmResponse1) : await WebAssembly.compile(binary1);
            }
            exports1.HandlerExecutorFactory = HandlerExecutorFactory1;
        },
        1967: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.LexicographicalInteractionsSorter = exports1.genesisSortKey = exports1.sortingLast = exports1.sortingFirst = void 0;
            const utils_11 = __webpack_require__1(3633), LoggerFactory_11 = __webpack_require__1(5913), WarpGatewayInteractionsLoader_11 = __webpack_require__1(1533), firstSortKeyMs1 = ''.padEnd(13, '0'), lastSortKeyMs1 = ''.padEnd(13, '9'), defaultArweaveMs1 = ''.padEnd(13, '0');
            exports1.sortingFirst = ''.padEnd(64, '0'), exports1.sortingLast = ''.padEnd(64, 'z'), exports1.genesisSortKey = `${''.padStart(12, '0')},${firstSortKeyMs1},${exports1.sortingFirst}`;
            class LexicographicalInteractionsSorter1 {
                constructor(arweave1){
                    this.arweave = arweave1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('LexicographicalInteractionsSorter');
                }
                async sort(transactions1) {
                    const copy1 = [
                        ...transactions1
                    ], addKeysFuncs1 = copy1.map((tx1)=>this.addSortKey(tx1));
                    return await Promise.all(addKeysFuncs1), copy1.sort((a10, b10)=>a10.node.sortKey.localeCompare(b10.node.sortKey));
                }
                async createSortKey(blockId1, transactionId1, blockHeight1, dummy1 = !1) {
                    const blockHashBytes1 = this.arweave.utils.b64UrlToBuffer(blockId1), txIdBytes1 = this.arweave.utils.b64UrlToBuffer(transactionId1), concatenated1 = this.arweave.utils.concatBuffers([
                        blockHashBytes1,
                        txIdBytes1
                    ]), hashed1 = (0, utils_11.arrayToHex)(await this.arweave.crypto.hash(concatenated1)), blockHeightString1 = `${blockHeight1}`.padStart(12, '0'), arweaveMs1 = dummy1 ? lastSortKeyMs1 : defaultArweaveMs1;
                    return `${blockHeightString1},${arweaveMs1},${hashed1}`;
                }
                extractBlockHeight(sortKey1) {
                    return sortKey1 ? parseInt(sortKey1.split(',')[0]) : null;
                }
                async addSortKey(txInfo1) {
                    const { node: node1  } = txInfo1;
                    void 0 !== txInfo1.node.sortKey && txInfo1.node.source == WarpGatewayInteractionsLoader_11.SourceType.WARP_SEQUENCER ? this.logger.debug('Using sortKey from sequencer', txInfo1.node.sortKey) : txInfo1.node.sortKey = await this.createSortKey(node1.block.id, node1.id, node1.block.height);
                }
                generateLastSortKey(blockHeight1) {
                    const blockHeightString1 = `${blockHeight1}`.padStart(12, '0');
                    return `${blockHeightString1},${lastSortKeyMs1},${exports1.sortingLast}`;
                }
            }
            exports1.LexicographicalInteractionsSorter = LexicographicalInteractionsSorter1;
        },
        2138: function(__unused_webpack_module1, exports1) {
            "use strict";
            function canBeCached1(tx1) {
                return void 0 === tx1.confirmationStatus || 'confirmed' === tx1.confirmationStatus;
            }
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.canBeCached = void 0, exports1.canBeCached = canBeCached1;
        },
        8996: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.TagsParser = void 0;
            const SmartWeaveTags_11 = __webpack_require__1(7312), LoggerFactory_11 = __webpack_require__1(5913);
            class TagsParser1 {
                constructor(){
                    this.logger = LoggerFactory_11.LoggerFactory.INST.create('TagsParser');
                }
                getInputTag(interactionTransaction1, contractTxId1) {
                    if (!TagsParser1.hasMultipleInteractions(interactionTransaction1)) return interactionTransaction1.tags.find((tag1)=>tag1.name === SmartWeaveTags_11.SmartWeaveTags.INPUT);
                    {
                        this.logger.debug('Interaction transaction is using multiple input tx tag format.');
                        const contractTagIndex1 = interactionTransaction1.tags.findIndex((tag1)=>tag1.name === SmartWeaveTags_11.SmartWeaveTags.CONTRACT_TX_ID && tag1.value === contractTxId1);
                        if (interactionTransaction1.tags.length - 1 === contractTagIndex1) {
                            this.logger.warn("Wrong tags format: 'Contract' is the last tag");
                            return;
                        }
                        const inputTag1 = interactionTransaction1.tags[contractTagIndex1 + 1];
                        if (inputTag1.name !== SmartWeaveTags_11.SmartWeaveTags.INPUT) {
                            this.logger.warn(`No 'Input' tag found after 'Contract' tag. Instead ${inputTag1.name} was found`);
                            return;
                        }
                        return inputTag1;
                    }
                }
                isInteractWrite(interactionTransaction1, contractTxId1) {
                    return interactionTransaction1.tags.some((tag1)=>tag1.name === SmartWeaveTags_11.SmartWeaveTags.INTERACT_WRITE && tag1.value === contractTxId1);
                }
                getInteractWritesContracts(interactionTransaction1) {
                    return interactionTransaction1.tags.filter((tag1)=>tag1.name === SmartWeaveTags_11.SmartWeaveTags.INTERACT_WRITE).map((t3)=>t3.value);
                }
                getContractTag(interactionTransaction1) {
                    var _a1;
                    return null === (_a1 = interactionTransaction1.tags.find((tag1)=>tag1.name === SmartWeaveTags_11.SmartWeaveTags.CONTRACT_TX_ID)) || void 0 === _a1 ? void 0 : _a1.value;
                }
                getContractsWithInputs(interactionTransaction1) {
                    const result1 = new Map(), contractTags1 = interactionTransaction1.tags.filter((tag1)=>tag1.name === SmartWeaveTags_11.SmartWeaveTags.CONTRACT_TX_ID);
                    return contractTags1.forEach((contractTag1)=>{
                        result1.set(contractTag1.value, this.getInputTag(interactionTransaction1, contractTag1.value));
                    }), result1;
                }
                static hasMultipleInteractions(interactionTransaction1) {
                    return interactionTransaction1.tags.filter((tag1)=>tag1.name === SmartWeaveTags_11.SmartWeaveTags.CONTRACT_TX_ID).length > 1;
                }
            }
            exports1.TagsParser = TagsParser1;
        },
        3187: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var Buffer1 = __webpack_require__1(8764).Buffer, __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.WarpGatewayContractDefinitionLoader = void 0;
            const ContractDefinitionLoader_11 = __webpack_require__1(7089);
            __webpack_require__1(9180);
            const WasmSrc_11 = __webpack_require__1(6105), transaction_11 = __importDefault1(__webpack_require__1(7241)), SmartWeaveTags_11 = __webpack_require__1(7312), utils_11 = __webpack_require__1(3633), Benchmark_11 = __webpack_require__1(9106), LoggerFactory_11 = __webpack_require__1(5913), ArweaveWrapper_11 = __webpack_require__1(9360), utils_21 = __webpack_require__1(5082);
            class WarpGatewayContractDefinitionLoader1 {
                constructor(baseUrl1, arweave1, cache1){
                    this.baseUrl = baseUrl1, this.cache = cache1, this.rLogger = LoggerFactory_11.LoggerFactory.INST.create('WarpGatewayContractDefinitionLoader'), this.baseUrl = (0, utils_21.stripTrailingSlash)(baseUrl1), this.contractDefinitionLoader = new ContractDefinitionLoader_11.ContractDefinitionLoader(arweave1, cache1), this.arweaveWrapper = new ArweaveWrapper_11.ArweaveWrapper(arweave1);
                }
                async load(contractTxId1, evolvedSrcTxId1) {
                    var _a1, _b1, _c1;
                    if (!evolvedSrcTxId1 && (null === (_a1 = this.cache) || void 0 === _a1 ? void 0 : _a1.contains(contractTxId1))) return this.rLogger.debug('WarpGatewayContractDefinitionLoader: Hit from cache!'), Promise.resolve(null === (_b1 = this.cache) || void 0 === _b1 ? void 0 : _b1.get(contractTxId1));
                    const benchmark1 = Benchmark_11.Benchmark.measure(), contract1 = await this.doLoad(contractTxId1, evolvedSrcTxId1);
                    return this.rLogger.info(`Contract definition loaded in: ${benchmark1.elapsed()}`), null === (_c1 = this.cache) || void 0 === _c1 || _c1.put(contractTxId1, contract1), contract1;
                }
                async doLoad(contractTxId1, forcedSrcTxId1) {
                    try {
                        const result1 = await fetch(`${this.baseUrl}/gateway/contract?txId=${contractTxId1}${forcedSrcTxId1 ? `&srcTxId=${forcedSrcTxId1}` : ''}`).then((res1)=>res1.ok ? res1.json() : Promise.reject(res1)).catch((error1)=>{
                            var _a1, _b1;
                            throw (null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message) && this.rLogger.error(error1.body.message), Error(`Unable to retrieve contract data. Warp gateway responded with status ${error1.status}:${null === (_b1 = error1.body) || void 0 === _b1 ? void 0 : _b1.message}`);
                        });
                        if (null == result1.srcBinary || result1.srcBinary instanceof Buffer1 || (result1.srcBinary = Buffer1.from(result1.srcBinary.data)), result1.srcBinary) {
                            let sourceTx1;
                            const wasmSrc1 = new WasmSrc_11.WasmSrc(result1.srcBinary);
                            result1.srcBinary = wasmSrc1.wasmBinary(), sourceTx1 = result1.srcTx ? new transaction_11.default({
                                ...result1.srcTx
                            }) : await this.arweaveWrapper.tx(result1.srcTxId);
                            const srcMetaData1 = JSON.parse((0, utils_11.getTag)(sourceTx1, SmartWeaveTags_11.SmartWeaveTags.WASM_META));
                            result1.metadata = srcMetaData1;
                        }
                        return result1.contractType = result1.src ? 'js' : 'wasm', result1;
                    } catch (e1) {
                        return this.rLogger.warn('Falling back to default contracts loader', e1), await this.contractDefinitionLoader.doLoad(contractTxId1, forcedSrcTxId1);
                    }
                }
                async loadContractSource(contractSrcTxId1) {
                    return await this.contractDefinitionLoader.loadContractSource(contractSrcTxId1);
                }
                type() {
                    return 'warp';
                }
            }
            exports1.WarpGatewayContractDefinitionLoader = WarpGatewayContractDefinitionLoader1;
        },
        1533: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var SourceType1;
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.WarpGatewayInteractionsLoader = exports1.SourceType = void 0;
            const Benchmark_11 = __webpack_require__1(9106), LoggerFactory_11 = __webpack_require__1(5913);
            __webpack_require__1(9180);
            const utils_11 = __webpack_require__1(5082);
            !function(SourceType1) {
                SourceType1.ARWEAVE = "arweave", SourceType1.WARP_SEQUENCER = "redstone-sequencer";
            }(SourceType1 = exports1.SourceType || (exports1.SourceType = {}));
            class WarpGatewayInteractionsLoader1 {
                constructor(baseUrl1, confirmationStatus1 = null, source1 = null){
                    this.baseUrl = baseUrl1, this.confirmationStatus = confirmationStatus1, this.source = source1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('WarpGatewayInteractionsLoader'), this.baseUrl = (0, utils_11.stripTrailingSlash)(baseUrl1), Object.assign(this, confirmationStatus1), this.source = source1;
                }
                async load(contractId1, fromSortKey1, toSortKey1, evaluationOptions1) {
                    this.logger.debug('Loading interactions: for ', {
                        contractId: contractId1,
                        fromSortKey: fromSortKey1,
                        toSortKey: toSortKey1
                    });
                    const interactions1 = [];
                    let page1 = 0, limit1 = 0, items1 = 0;
                    const benchmarkTotalTime1 = Benchmark_11.Benchmark.measure();
                    do {
                        const benchmarkRequestTime1 = Benchmark_11.Benchmark.measure(), url1 = `${this.baseUrl}/gateway/v2/interactions-sort-key`, response1 = await fetch(`${url1}?${new URLSearchParams({
                            contractId: contractId1,
                            ...fromSortKey1 ? {
                                from: fromSortKey1
                            } : '',
                            ...toSortKey1 ? {
                                to: toSortKey1
                            } : '',
                            page: (++page1).toString(),
                            fromSdk: 'true',
                            ...this.confirmationStatus && this.confirmationStatus.confirmed ? {
                                confirmationStatus: 'confirmed'
                            } : '',
                            ...this.confirmationStatus && this.confirmationStatus.notCorrupted ? {
                                confirmationStatus: 'not_corrupted'
                            } : '',
                            ...this.source ? {
                                source: this.source
                            } : ''
                        })}`).then((res1)=>res1.ok ? res1.json() : Promise.reject(res1)).catch((error1)=>{
                            var _a1;
                            throw (null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message) && this.logger.error(error1.body.message), Error(`Unable to retrieve transactions. Warp gateway responded with status ${error1.status}.`);
                        });
                        this.logger.debug(`Loading interactions: page ${page1} loaded in ${benchmarkRequestTime1.elapsed()}`), interactions1.push(...response1.interactions), limit1 = response1.paging.limit, items1 = response1.paging.items, this.logger.debug(`Loaded interactions length: ${interactions1.length}, from: ${fromSortKey1}, to: ${toSortKey1}`);
                    }while (items1 == limit1)
                    return this.logger.debug('All loaded interactions:', {
                        from: fromSortKey1,
                        to: toSortKey1,
                        loaded: interactions1.length,
                        time: benchmarkTotalTime1.elapsed()
                    }), interactions1;
                }
                type() {
                    return 'warp';
                }
                clearCache() {}
            }
            exports1.WarpGatewayInteractionsLoader = WarpGatewayInteractionsLoader1;
        },
        3233: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.AbstractContractHandler = void 0;
            const LoggerFactory_11 = __webpack_require__1(5913), utils_11 = __webpack_require__1(5082);
            class AbstractContractHandler1 {
                constructor(swGlobal1, contractDefinition1){
                    this.swGlobal = swGlobal1, this.contractDefinition = contractDefinition1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('ContractHandler'), this.assignReadContractState = this.assignReadContractState.bind(this), this.assignViewContractState = this.assignViewContractState.bind(this), this.assignWrite = this.assignWrite.bind(this), this.assignRefreshState = this.assignRefreshState.bind(this);
                }
                async dispose() {}
                assignWrite(executionContext1, currentTx1) {
                    this.swGlobal.contracts.write = async (contractTxId1, input1)=>{
                        if (!executionContext1.evaluationOptions.internalWrites) throw Error("Internal writes feature switched off. Change EvaluationOptions.internalWrites flag to 'true'");
                        this.logger.debug('swGlobal.write call:', {
                            from: this.contractDefinition.txId,
                            to: contractTxId1,
                            input: input1
                        });
                        const calleeContract1 = executionContext1.warp.contract(contractTxId1, executionContext1.contract, this.swGlobal._activeTx), result1 = await calleeContract1.dryWriteFromTx(input1, this.swGlobal._activeTx, [
                            ...currentTx1 || [],
                            {
                                contractTxId: this.contractDefinition.txId,
                                interactionTxId: this.swGlobal.transaction.id
                            }
                        ]);
                        return this.logger.debug('Cache result?:', !this.swGlobal._activeTx.dry), await executionContext1.warp.stateEvaluator.onInternalWriteStateUpdate(this.swGlobal._activeTx, contractTxId1, {
                            state: result1.state,
                            validity: {
                                ...result1.originalValidity,
                                [this.swGlobal._activeTx.id]: 'ok' == result1.type
                            },
                            errorMessages: {
                                ...result1.originalErrorMessages,
                                [this.swGlobal._activeTx.id]: result1.errorMessage
                            }
                        }), result1;
                    };
                }
                assignViewContractState(executionContext1) {
                    this.swGlobal.contracts.viewContractState = async (contractTxId1, input1)=>{
                        this.logger.debug('swGlobal.viewContractState call:', {
                            from: this.contractDefinition.txId,
                            to: contractTxId1,
                            input: input1
                        });
                        const childContract1 = executionContext1.warp.contract(contractTxId1, executionContext1.contract, this.swGlobal._activeTx);
                        return await childContract1.viewStateForTx(input1, this.swGlobal._activeTx);
                    };
                }
                assignReadContractState(executionContext1, currentTx1, currentResult1, interactionTx1) {
                    this.swGlobal.contracts.readContractState = async (contractTxId1, returnValidity1)=>{
                        this.logger.debug('swGlobal.readContractState call:', {
                            from: this.contractDefinition.txId,
                            to: contractTxId1,
                            sortKey: interactionTx1.sortKey,
                            transaction: this.swGlobal.transaction.id
                        });
                        const { stateEvaluator: stateEvaluator1  } = executionContext1.warp, childContract1 = executionContext1.warp.contract(contractTxId1, executionContext1.contract, interactionTx1);
                        await stateEvaluator1.onContractCall(interactionTx1, executionContext1, currentResult1);
                        const stateWithValidity1 = await childContract1.readState(interactionTx1.sortKey, [
                            ...currentTx1 || [],
                            {
                                contractTxId: this.contractDefinition.txId,
                                interactionTxId: this.swGlobal.transaction.id
                            }
                        ]);
                        return returnValidity1 ? (0, utils_11.deepCopy)(stateWithValidity1) : (0, utils_11.deepCopy)(stateWithValidity1.cachedValue.state);
                    };
                }
                assignRefreshState(executionContext1) {
                    this.swGlobal.contracts.refreshState = async ()=>{
                        const stateEvaluator1 = executionContext1.warp.stateEvaluator, result1 = await stateEvaluator1.latestAvailableState(this.swGlobal.contract.id, this.swGlobal._activeTx.sortKey);
                        return null == result1 ? void 0 : result1.cachedValue.state;
                    };
                }
            }
            exports1.AbstractContractHandler = AbstractContractHandler1;
        },
        1515: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.JsHandlerApi = void 0;
            const utils_11 = __webpack_require__1(5082), AbstractContractHandler_11 = __webpack_require__1(3233);
            class JsHandlerApi1 extends AbstractContractHandler_11.AbstractContractHandler {
                constructor(swGlobal1, contractDefinition1, contractFunction1){
                    super(swGlobal1, contractDefinition1), this.contractFunction = contractFunction1;
                }
                async handle(executionContext1, currentResult1, interactionData1) {
                    const { timeoutId: timeoutId1 , timeoutPromise: timeoutPromise1  } = (0, utils_11.timeout)(executionContext1.evaluationOptions.maxInteractionEvaluationTimeSeconds);
                    try {
                        const { interaction: interaction1 , interactionTx: interactionTx1 , currentTx: currentTx1  } = interactionData1, stateCopy1 = (0, utils_11.deepCopy)(currentResult1.state, executionContext1.evaluationOptions.useFastCopy);
                        this.swGlobal._activeTx = interactionTx1, this.swGlobal.caller = interaction1.caller, this.assignReadContractState(executionContext1, currentTx1, currentResult1, interactionTx1), this.assignViewContractState(executionContext1), this.assignWrite(executionContext1, currentTx1), this.assignRefreshState(executionContext1);
                        const handlerResult1 = await Promise.race([
                            timeoutPromise1,
                            this.contractFunction(stateCopy1, interaction1)
                        ]);
                        if (handlerResult1 && (void 0 !== handlerResult1.state || void 0 !== handlerResult1.result)) return {
                            type: 'ok',
                            result: handlerResult1.result,
                            state: handlerResult1.state || currentResult1.state
                        };
                        throw Error(`Unexpected result from contract: ${JSON.stringify(handlerResult1)}`);
                    } catch (err1) {
                        if ('ContractError' === err1.name) return {
                            type: 'error',
                            errorMessage: err1.message,
                            state: currentResult1.state,
                            result: null
                        };
                        return {
                            type: 'exception',
                            errorMessage: `${err1 && err1.stack || err1 && err1.message || err1}`,
                            state: currentResult1.state,
                            result: null
                        };
                    } finally{
                        null !== timeoutId1 && clearTimeout(timeoutId1);
                    }
                }
                initState(state1) {}
            }
            exports1.JsHandlerApi = JsHandlerApi1;
        },
        3425: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.WasmHandlerApi = void 0;
            const safe_stable_stringify_11 = __importDefault1(__webpack_require__1(7668)), AbstractContractHandler_11 = __webpack_require__1(3233);
            class WasmHandlerApi1 extends AbstractContractHandler_11.AbstractContractHandler {
                constructor(swGlobal1, contractDefinition1, wasmExports1){
                    super(swGlobal1, contractDefinition1), this.wasmExports = wasmExports1;
                }
                async handle(executionContext1, currentResult1, interactionData1) {
                    try {
                        const { interaction: interaction1 , interactionTx: interactionTx1 , currentTx: currentTx1  } = interactionData1;
                        this.swGlobal._activeTx = interactionTx1, this.swGlobal.caller = interaction1.caller, this.swGlobal.gasLimit = executionContext1.evaluationOptions.gasLimit, this.swGlobal.gasUsed = 0, this.assignReadContractState(executionContext1, currentTx1, currentResult1, interactionTx1), this.assignWrite(executionContext1, currentTx1);
                        const handlerResult1 = await this.doHandle(interaction1);
                        return {
                            type: 'ok',
                            result: handlerResult1,
                            state: this.doGetCurrentState(),
                            gasUsed: this.swGlobal.gasUsed
                        };
                    } catch (e1) {
                        const result1 = {
                            errorMessage: e1.message,
                            state: currentResult1.state,
                            result: null
                        };
                        if (e1.message.startsWith('[RE:')) return this.logger.fatal(e1), {
                            ...result1,
                            type: 'exception'
                        };
                        return {
                            ...result1,
                            type: 'error'
                        };
                    }
                }
                initState(state1) {
                    switch(this.contractDefinition.srcWasmLang){
                        case 'assemblyscript':
                            {
                                const statePtr1 = this.wasmExports.__newString((0, safe_stable_stringify_11.default)(state1));
                                this.wasmExports.initState(statePtr1);
                                break;
                            }
                        case 'rust':
                            this.wasmExports.initState(state1);
                            break;
                        case 'go':
                            this.wasmExports.initState((0, safe_stable_stringify_11.default)(state1));
                            break;
                        default:
                            throw Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
                    }
                }
                async doHandle(action1) {
                    switch(this.contractDefinition.srcWasmLang){
                        case 'assemblyscript':
                            {
                                const actionPtr1 = this.wasmExports.__newString((0, safe_stable_stringify_11.default)(action1.input)), resultPtr1 = this.wasmExports.handle(actionPtr1), result1 = this.wasmExports.__getString(resultPtr1);
                                return JSON.parse(result1);
                            }
                        case 'rust':
                            {
                                let handleResult1 = await this.wasmExports.handle(action1.input);
                                if (!handleResult1) return;
                                if (Object.prototype.hasOwnProperty.call(handleResult1, 'Ok')) return handleResult1.Ok;
                                {
                                    let errorKey1;
                                    this.logger.debug('Error from rust', handleResult1.Err);
                                    let errorArgs1 = '';
                                    if ('string' == typeof handleResult1.Err || handleResult1.Err instanceof String ? errorKey1 = handleResult1.Err : (errorKey1 = Object.keys(handleResult1.Err)[0], errorArgs1 = ' ' + handleResult1.Err[errorKey1]), 'RuntimeError' == errorKey1) throw Error(`[RE:RE]${errorArgs1}`);
                                    throw Error(`[CE:${errorKey1}${errorArgs1}]`);
                                }
                            }
                        case 'go':
                            {
                                const result1 = await this.wasmExports.handle((0, safe_stable_stringify_11.default)(action1.input));
                                return JSON.parse(result1);
                            }
                        default:
                            throw Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
                    }
                }
                doGetCurrentState() {
                    switch(this.contractDefinition.srcWasmLang){
                        case 'assemblyscript':
                            {
                                const currentStatePtr1 = this.wasmExports.currentState();
                                return JSON.parse(this.wasmExports.__getString(currentStatePtr1));
                            }
                        case 'rust':
                            return this.wasmExports.currentState();
                        case 'go':
                            {
                                const result1 = this.wasmExports.currentState();
                                return JSON.parse(result1);
                            }
                        default:
                            throw Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
                    }
                }
            }
            exports1.WasmHandlerApi = WasmHandlerApi1;
        },
        4965: function(__unused_webpack_module1, exports1) {
            "use strict";
            function normalizeContractSource1(contractSrc1, useVM21) {
                const lines1 = contractSrc1.trim().split('\n'), first1 = lines1[0], last1 = lines1[lines1.length - 1];
                return ((/\(\s*\(\)\s*=>\s*{/g.test(first1) || /\s*\(\s*function\s*\(\)\s*{/g.test(first1)) && /}\s*\)\s*\(\)\s*;/g.test(last1) && (lines1.shift(), lines1.pop(), contractSrc1 = lines1.join('\n')), contractSrc1 = contractSrc1.replace(/export\s+async\s+function\s+handle/gmu, 'async function handle').replace(/export\s+function\s+handle/gmu, 'function handle'), useVM21) ? `
    ${contractSrc1}
    module.exports = handle;` : `
    const [SmartWeave, BigNumber, logger] = arguments;
    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };
    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };
    ${contractSrc1};
    return handle;
  `;
            }
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.normalizeContractSource = void 0, exports1.normalizeContractSource = normalizeContractSource1;
        },
        6105: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.WasmSrc = void 0;
            const unzipit_11 = __webpack_require__1(3931), redstone_isomorphic_11 = __webpack_require__1(9180), LoggerFactory_11 = __webpack_require__1(5913);
            class WasmSrc1 {
                constructor(src1){
                    this.src = src1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('WasmSrc'), this.splitted = this.splitBuffer(src1), this.logger.debug(`Buffer splitted into ${this.splitted.length} parts`);
                }
                wasmBinary() {
                    return this.splitted[0];
                }
                async sourceCode() {
                    const { entries: entries1  } = await (0, unzipit_11.unzip)(this.splitted[1]), result1 = new Map();
                    for (const [name1, entry1] of Object.entries(entries1)){
                        if (entry1.isDirectory) continue;
                        const content1 = await entry1.text();
                        result1.set(name1, content1);
                    }
                    return result1;
                }
                additionalCode() {
                    return 2 == this.splitted.length ? null : this.splitted[2].toString();
                }
                splitBuffer(inputBuffer1) {
                    let header1 = '';
                    const elements1 = parseInt(inputBuffer1.toString('utf8', 0, 1));
                    this.logger.debug(`Number of elements: ${elements1}`);
                    const l1 = inputBuffer1.length;
                    let delimiters1 = 0, dataStart1 = 0;
                    for(let i2 = 2; i2 < l1; i2++){
                        const element1 = inputBuffer1.toString('utf8', i2, i2 + 1);
                        if ('|' == element1 && delimiters1++, delimiters1 == elements1) {
                            dataStart1 = i2 + 1;
                            break;
                        }
                        header1 += element1;
                    }
                    this.logger.debug("Parsed:", {
                        header: header1,
                        dataStart: dataStart1
                    });
                    const lengths1 = header1.split('|').map((l1)=>parseInt(l1));
                    this.logger.debug('Lengths', lengths1);
                    const result1 = [];
                    for (const length1 of lengths1){
                        const buffer1 = redstone_isomorphic_11.Buffer.alloc(length1), end1 = dataStart1 + length1;
                        inputBuffer1.copy(buffer1, 0, dataStart1, end1), dataStart1 = end1, result1.push(buffer1);
                    }
                    return result1;
                }
            }
            exports1.WasmSrc = WasmSrc1;
        },
        1692: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.asWasmImports = void 0;
            const LoggerFactory_11 = __webpack_require__1(5913), asWasmImports1 = (swGlobal1, wasmInstance1)=>{
                const wasmLogger1 = LoggerFactory_11.LoggerFactory.INST.create('WASM:AS');
                return {
                    metering: {
                        usegas: swGlobal1.useGas
                    },
                    console: {
                        'console.log': function(msgPtr1) {
                            wasmLogger1.debug(`${swGlobal1.contract.id}: ${wasmInstance1.exports.__getString(msgPtr1)}`);
                        },
                        'console.logO': function(msgPtr1, objPtr1) {
                            wasmLogger1.debug(`${swGlobal1.contract.id}: ${wasmInstance1.exports.__getString(msgPtr1)}`, JSON.parse(wasmInstance1.exports.__getString(objPtr1)));
                        }
                    },
                    block: {
                        'Block.height': function() {
                            return swGlobal1.block.height;
                        },
                        'Block.indep_hash': function() {
                            return wasmInstance1.exports.__newString(swGlobal1.block.indep_hash);
                        },
                        'Block.timestamp': function() {
                            return swGlobal1.block.timestamp;
                        }
                    },
                    transaction: {
                        'Transaction.id': function() {
                            return wasmInstance1.exports.__newString(swGlobal1.transaction.id);
                        },
                        'Transaction.owner': function() {
                            return wasmInstance1.exports.__newString(swGlobal1.transaction.owner);
                        },
                        'Transaction.target': function() {
                            return wasmInstance1.exports.__newString(swGlobal1.transaction.target);
                        }
                    },
                    contract: {
                        'Contract.id': function() {
                            return wasmInstance1.exports.__newString(swGlobal1.contract.id);
                        },
                        'Contract.owner': function() {
                            return wasmInstance1.exports.__newString(swGlobal1.contract.owner);
                        }
                    },
                    api: {
                        _readContractState: (fnIndex1, contractTxIdPtr1)=>{
                            const contractTxId1 = wasmInstance1.exports.__getString(contractTxIdPtr1), callbackFn1 = getFn1(fnIndex1);
                            return console.log('Simulating read state of', contractTxId1), setTimeout(()=>{
                                console.log('calling callback'), callbackFn1(wasmInstance1.exports.__newString(JSON.stringify({
                                    contractTxId: contractTxId1
                                })));
                            }, 1000);
                        },
                        clearTimeout
                    },
                    env: {
                        abort (messagePtr1, fileNamePtr1, line1, column1) {
                            const message1 = wasmInstance1.exports.__getString(messagePtr1);
                            throw wasmLogger1.error('--------------------- Error message from AssemblyScript ----------------------\n'), wasmLogger1.error('  ' + message1), wasmLogger1.error('    In file "' + wasmInstance1.exports.__getString(fileNamePtr1) + '"'), wasmLogger1.error(`    on line ${line1}, column ${column1}.`), wasmLogger1.error('------------------------------------------------------------------------------\n'), Error(message1);
                        }
                    }
                };
                function getFn1(idx1) {
                    return wasmInstance1.exports.table.get(idx1);
                }
            };
            exports1.asWasmImports = asWasmImports1;
        },
        7170: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            let globalJsModule1;
            var process1 = __webpack_require__1(3957);
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.Go = void 0;
            const LoggerFactory_11 = __webpack_require__1(5913), encoder1 = new TextEncoder(), decoder1 = new TextDecoder('utf-8');
            let logLine1 = [];
            (function(global1) {
                (globalJsModule1 = global1).redstone = {
                    go: {}
                };
            }).call(this, void 0 !== __webpack_require__1.g ? __webpack_require__1.g : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : {});
            class Go1 {
                constructor(swGlobal1){
                    this._callbackTimeouts = new Map(), this._nextCallbackTimeoutID = 1;
                    const wasmLogger1 = LoggerFactory_11.LoggerFactory.INST.create('WASM:Go');
                    let go1 = this;
                    globalJsModule1.redstone.go = {
                        WasmModule: {
                            registerWasmModule: function(moduleId1) {
                                go1._id = moduleId1, go1.exports = globalJsModule1[moduleId1], delete globalJsModule1[moduleId1], globalJsModule1.redstone.go[moduleId1] = {}, globalJsModule1.redstone.go[moduleId1].imports = {
                                    console: {
                                        log: function(...args1) {
                                            wasmLogger1.debug(args1[0], ...args1.slice(1));
                                        }
                                    },
                                    Transaction: {
                                        id: function() {
                                            return swGlobal1.transaction.id;
                                        },
                                        owner: function() {
                                            return swGlobal1.transaction.owner;
                                        },
                                        target: function() {
                                            return swGlobal1.transaction.target;
                                        }
                                    },
                                    Block: {
                                        indep_hash: function() {
                                            return swGlobal1.block.indep_hash;
                                        },
                                        height: function() {
                                            return swGlobal1.block.height;
                                        },
                                        timestamp: function() {
                                            return swGlobal1.block.timestamp;
                                        }
                                    },
                                    Contract: {
                                        id: function() {
                                            return swGlobal1.contract.id;
                                        },
                                        owner: function() {
                                            return swGlobal1.contract.owner;
                                        }
                                    },
                                    SmartWeave: {
                                        readContractState: async function(contractTxId1) {
                                            return await swGlobal1.contracts.readContractState(contractTxId1);
                                        }
                                    }
                                };
                            }
                        }
                    };
                    const mem1 = ()=>new DataView(this._inst.exports.memory.buffer), setInt641 = (addr1, v3)=>{
                        mem1().setUint32(addr1 + 0, v3, !0), mem1().setUint32(addr1 + 4, Math.floor(v3 / 4294967296), !0);
                    }, loadValue1 = (addr1)=>{
                        const f1 = mem1().getFloat64(addr1, !0);
                        if (0 === f1) return;
                        if (!isNaN(f1)) return f1;
                        const id1 = mem1().getUint32(addr1, !0);
                        return this._values[id1];
                    }, storeValue1 = (addr1, v3)=>{
                        const nanHead1 = 0x7ff80000;
                        if ('number' == typeof v3) {
                            if (isNaN(v3)) {
                                mem1().setUint32(addr1 + 4, nanHead1, !0), mem1().setUint32(addr1, 0, !0);
                                return;
                            }
                            if (0 === v3) {
                                mem1().setUint32(addr1 + 4, nanHead1, !0), mem1().setUint32(addr1, 1, !0);
                                return;
                            }
                            mem1().setFloat64(addr1, v3, !0);
                            return;
                        }
                        switch(v3){
                            case void 0:
                                mem1().setFloat64(addr1, 0, !0);
                                return;
                            case null:
                                mem1().setUint32(addr1 + 4, nanHead1, !0), mem1().setUint32(addr1, 2, !0);
                                return;
                            case !0:
                                mem1().setUint32(addr1 + 4, nanHead1, !0), mem1().setUint32(addr1, 3, !0);
                                return;
                            case !1:
                                mem1().setUint32(addr1 + 4, nanHead1, !0), mem1().setUint32(addr1, 4, !0);
                                return;
                        }
                        let id1 = this._ids.get(v3);
                        void 0 === id1 && (void 0 === (id1 = this._idPool.pop()) && (id1 = this._values.length), this._values[id1] = v3, this._goRefCounts[id1] = 0, this._ids.set(v3, id1)), this._goRefCounts[id1]++;
                        let typeFlag1 = 1;
                        switch(typeof v3){
                            case 'string':
                                typeFlag1 = 2;
                                break;
                            case 'symbol':
                                typeFlag1 = 3;
                                break;
                            case 'function':
                                typeFlag1 = 4;
                        }
                        mem1().setUint32(addr1 + 4, nanHead1 | typeFlag1, !0), mem1().setUint32(addr1, id1, !0);
                    }, loadSlice1 = (array1, len3, cap1 = null)=>new Uint8Array(this._inst.exports.memory.buffer, array1, len3), loadSliceOfValues1 = (array1, len3, cap1)=>{
                        const a10 = Array(len3);
                        for(let i2 = 0; i2 < len3; i2++)a10[i2] = loadValue1(array1 + 8 * i2);
                        return a10;
                    }, loadString1 = (ptr1, len3)=>decoder1.decode(new DataView(this._inst.exports.memory.buffer, ptr1, len3)), timeOrigin1 = Date.now() - performance.now();
                    this.importObject = {
                        wasi_snapshot_preview1: {
                            fd_write: function(fd1, iovs_ptr1, iovs_len1, nwritten_ptr1) {
                                let nwritten1 = 0;
                                if (1 == fd1) for(let iovs_i1 = 0; iovs_i1 < iovs_len1; iovs_i1++){
                                    let iov_ptr1 = iovs_ptr1 + 8 * iovs_i1, ptr1 = mem1().getUint32(iov_ptr1 + 0, !0), len3 = mem1().getUint32(iov_ptr1 + 4, !0);
                                    nwritten1 += len3;
                                    for(let i2 = 0; i2 < len3; i2++){
                                        let c5 = mem1().getUint8(ptr1 + i2);
                                        if (13 == c5) ;
                                        else if (10 == c5) {
                                            let line1 = decoder1.decode(new Uint8Array(logLine1));
                                            logLine1 = [], console.log(line1);
                                        } else logLine1.push(c5);
                                    }
                                }
                                else console.error('invalid file descriptor:', fd1);
                                return mem1().setUint32(nwritten_ptr1, nwritten1, !0), 0;
                            },
                            fd_close: ()=>0,
                            fd_fdstat_get: ()=>0,
                            fd_seek: ()=>0,
                            proc_exit: (code1)=>{
                                if (__webpack_require__1.g.process) process1.exit(code1);
                                else throw 'trying to exit with code ' + code1;
                            },
                            random_get: (bufPtr1, bufLen1)=>(crypto.getRandomValues(loadSlice1(bufPtr1, bufLen1, null)), 0)
                        },
                        env: {
                            'runtime.ticks': ()=>timeOrigin1 + performance.now(),
                            'runtime.sleepTicks': (timeout1)=>{
                                setTimeout(this._inst.exports.go_scheduler, timeout1);
                            },
                            'syscall/js.finalizeRef': (v_addr1)=>{
                                const id1 = mem1().getUint32(v_addr1, !0);
                                if (this._goRefCounts[id1]--, 0 === this._goRefCounts[id1]) {
                                    const v3 = this._values[id1];
                                    this._values[id1] = null, this._ids.delete(v3), this._idPool.push(id1);
                                }
                            },
                            'syscall/js.stringVal': (ret_ptr1, value_ptr1, value_len1)=>{
                                const s3 = loadString1(value_ptr1, value_len1);
                                storeValue1(ret_ptr1, s3);
                            },
                            'syscall/js.valueGet': (retval1, v_addr1, p_ptr1, p_len1)=>{
                                let prop1 = loadString1(p_ptr1, p_len1), value1 = loadValue1(v_addr1);
                                storeValue1(retval1, Reflect.get(value1, prop1));
                            },
                            'syscall/js.valueSet': (v_addr1, p_ptr1, p_len1, x_addr1)=>{
                                const v3 = loadValue1(v_addr1), p3 = loadString1(p_ptr1, p_len1), x3 = loadValue1(x_addr1);
                                Reflect.set(v3, p3, x3);
                            },
                            'syscall/js.valueDelete': (v_addr1, p_ptr1, p_len1)=>{
                                const v3 = loadValue1(v_addr1), p3 = loadString1(p_ptr1, p_len1);
                                Reflect.deleteProperty(v3, p3);
                            },
                            'syscall/js.valueIndex': (ret_addr1, v_addr1, i2)=>{
                                storeValue1(ret_addr1, Reflect.get(loadValue1(v_addr1), i2));
                            },
                            'syscall/js.valueSetIndex': (v_addr1, i2, x_addr1)=>{
                                Reflect.set(loadValue1(v_addr1), i2, loadValue1(x_addr1));
                            },
                            'syscall/js.valueCall': (ret_addr1, v_addr1, m_ptr1, m_len1, args_ptr1, args_len1, args_cap1)=>{
                                const v3 = loadValue1(v_addr1), name1 = loadString1(m_ptr1, m_len1), args1 = loadSliceOfValues1(args_ptr1, args_len1, args_cap1);
                                try {
                                    const m1 = Reflect.get(v3, name1);
                                    storeValue1(ret_addr1, Reflect.apply(m1, v3, args1)), mem1().setUint8(ret_addr1 + 8, 1);
                                } catch (err1) {
                                    storeValue1(ret_addr1, err1), mem1().setUint8(ret_addr1 + 8, 0);
                                }
                            },
                            'syscall/js.valueInvoke': (ret_addr1, v_addr1, args_ptr1, args_len1, args_cap1)=>{
                                try {
                                    const v3 = loadValue1(v_addr1), args1 = loadSliceOfValues1(args_ptr1, args_len1, args_cap1);
                                    storeValue1(ret_addr1, Reflect.apply(v3, void 0, args1)), mem1().setUint8(ret_addr1 + 8, 1);
                                } catch (err1) {
                                    storeValue1(ret_addr1, err1), mem1().setUint8(ret_addr1 + 8, 0);
                                }
                            },
                            'syscall/js.valueNew': (ret_addr1, v_addr1, args_ptr1, args_len1, args_cap1)=>{
                                const v3 = loadValue1(v_addr1), args1 = loadSliceOfValues1(args_ptr1, args_len1, args_cap1);
                                try {
                                    storeValue1(ret_addr1, Reflect.construct(v3, args1)), mem1().setUint8(ret_addr1 + 8, 1);
                                } catch (err1) {
                                    storeValue1(ret_addr1, err1), mem1().setUint8(ret_addr1 + 8, 0);
                                }
                            },
                            'syscall/js.valueLength': (v_addr1)=>loadValue1(v_addr1).length,
                            'syscall/js.valuePrepareString': (ret_addr1, v_addr1)=>{
                                const s3 = String(loadValue1(v_addr1)), str1 = encoder1.encode(s3);
                                storeValue1(ret_addr1, str1), setInt641(ret_addr1 + 8, str1.length);
                            },
                            'syscall/js.valueLoadString': (v_addr1, slice_ptr1, slice_len1, slice_cap1)=>{
                                const str1 = loadValue1(v_addr1);
                                loadSlice1(slice_ptr1, slice_len1, slice_cap1).set(str1);
                            },
                            'syscall/js.valueInstanceOf': (v_addr1, t_addr1)=>loadValue1(v_addr1) instanceof loadValue1(t_addr1),
                            'syscall/js.copyBytesToGo': (ret_addr1, dest_addr1, dest_len1, dest_cap1, source_addr1)=>{
                                let num_bytes_copied_addr1 = ret_addr1, returned_status_addr1 = ret_addr1 + 4;
                                const dst1 = loadSlice1(dest_addr1, dest_len1), src1 = loadValue1(source_addr1);
                                if (!(src1 instanceof Uint8Array)) {
                                    mem1().setUint8(returned_status_addr1, 0);
                                    return;
                                }
                                const toCopy1 = src1.subarray(0, dst1.length);
                                dst1.set(toCopy1), setInt641(num_bytes_copied_addr1, toCopy1.length), mem1().setUint8(returned_status_addr1, 1);
                            },
                            'syscall/js.copyBytesToJS': (ret_addr1, dest_addr1, source_addr1, source_len1, source_cap1)=>{
                                let num_bytes_copied_addr1 = ret_addr1, returned_status_addr1 = ret_addr1 + 4;
                                const dst1 = loadValue1(dest_addr1), src1 = loadSlice1(source_addr1, source_len1);
                                if (!(dst1 instanceof Uint8Array)) {
                                    mem1().setUint8(returned_status_addr1, 0);
                                    return;
                                }
                                const toCopy1 = src1.subarray(0, dst1.length);
                                dst1.set(toCopy1), setInt641(num_bytes_copied_addr1, toCopy1.length), mem1().setUint8(returned_status_addr1, 1);
                            }
                        }
                    };
                }
                async run(instance1) {
                    for(this._inst = instance1, this._values = [
                        NaN,
                        0,
                        null,
                        !0,
                        !1,
                        __webpack_require__1.g,
                        this
                    ], this._goRefCounts = [], this._ids = new Map(), this._idPool = [], this.exited = !1, new DataView(this._inst.exports.memory.buffer);;){
                        const callbackPromise1 = new Promise((resolve1)=>{
                            this._resolveCallbackPromise = ()=>{
                                if (this.exited) throw Error('bad callback: Go program has already exited');
                                setTimeout(resolve1, 0);
                            };
                        });
                        if (this._inst.exports._start(), this.exited) break;
                        await callbackPromise1;
                    }
                }
                _resume() {
                    if (this.exited) throw Error('Go program has already exited');
                    this._inst.exports.resume(), this.exited && this._resolveExitPromise();
                }
                _makeFuncWrapper(id1) {
                    const go1 = this;
                    return function() {
                        const event1 = {
                            id: id1,
                            this: this,
                            args: arguments
                        };
                        return go1._pendingEvent = event1, go1._resume(), event1.result;
                    };
                }
                _resolveExitPromise() {}
            }
            exports1.Go = Go1;
        },
        6505: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.rustWasmImports = void 0;
            const LoggerFactory_11 = __webpack_require__1(5913), rustWasmImports1 = (swGlobal1, wbindgenImports1, wasmInstance1, dtorValue1)=>{
                const wasmLogger1 = LoggerFactory_11.LoggerFactory.INST.create('WASM:Rust'), rawImports1 = {
                    metering: {
                        usegas: swGlobal1.useGas
                    },
                    console: {
                        log: function(value1) {
                            wasmLogger1.debug(`${swGlobal1.contract.id}: ${value1}`);
                        }
                    },
                    Block: {
                        height: function() {
                            return swGlobal1.block.height;
                        },
                        indep_hash: function() {
                            return swGlobal1.block.indep_hash;
                        },
                        timestamp: function() {
                            return swGlobal1.block.timestamp;
                        }
                    },
                    Transaction: {
                        id: function() {
                            return swGlobal1.transaction.id;
                        },
                        owner: function() {
                            return swGlobal1.transaction.owner;
                        },
                        target: function() {
                            return swGlobal1.transaction.target;
                        }
                    },
                    Contract: {
                        id: function() {
                            return swGlobal1.contract.id;
                        },
                        owner: function() {
                            return swGlobal1.contract.owner;
                        }
                    },
                    SmartWeave: {
                        caller: function() {
                            return swGlobal1.caller;
                        },
                        readContractState: async function(contractTxId1) {
                            return await swGlobal1.contracts.readContractState(contractTxId1);
                        },
                        write: async function(contractId1, input1) {
                            return await swGlobal1.contracts.write(contractId1, input1);
                        }
                    },
                    Vrf: {
                        value: function() {
                            return swGlobal1.vrf.value;
                        },
                        randomInt: function(maxValue1) {
                            return swGlobal1.vrf.randomInt(maxValue1);
                        }
                    }
                }, baseImports1 = {
                    __wbg_log_: function(arg01, arg11) {
                        rawImports1.console.log(getStringFromWasm01(arg01, arg11));
                    },
                    __wbindgen_json_parse: function(arg01, arg11) {
                        return addHeapObject1(JSON.parse(getStringFromWasm01(arg01, arg11)));
                    },
                    __wbindgen_json_serialize: function(arg01, arg11) {
                        const obj1 = getObject1(arg11);
                        var ptr01 = passStringToWasm01(JSON.stringify(void 0 === obj1 ? null : obj1), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbindgen_object_drop_ref: function(arg01) {
                        takeObject1(arg01);
                    },
                    __wbindgen_cb_drop: function(arg01) {
                        const obj1 = takeObject1(arg01).original;
                        return 1 == obj1.cnt-- && (obj1.a = 0, !0);
                    },
                    __wbg_readContractState: function(arg01, arg11) {
                        return addHeapObject1(rawImports1.SmartWeave.readContractState(getStringFromWasm01(arg01, arg11)));
                    },
                    __wbg_viewContractState: function(arg01, arg11) {},
                    __wbg_caller: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.SmartWeave.caller(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_write: function(arg01, arg11, arg21) {
                        return addHeapObject1(rawImports1.SmartWeave.write(getStringFromWasm01(arg01, arg11), takeObject1(arg21)));
                    },
                    __wbg_refreshState: function(arg01, arg11) {},
                    __wbg_indephash: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.Block.indep_hash(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_height: function() {
                        return rawImports1.Block.height();
                    },
                    __wbg_timestamp: function() {
                        return rawImports1.Block.timestamp();
                    },
                    __wbg_id: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.Transaction.id(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_contractOwner: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.Contract.owner(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_contractId: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.Contract.id(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_owner: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.Transaction.owner(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_target: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.Transaction.target(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_call: function() {
                        return handleError1(function(arg01, arg11, arg21) {
                            return addHeapObject1(getObject1(arg01).call(getObject1(arg11), getObject1(arg21)));
                        }, arguments);
                    },
                    __wbg_new: function(arg01, arg11) {
                        try {
                            var state01 = {
                                a: arg01,
                                b: arg11
                            }, cb01 = (arg01, arg11)=>{
                                const a10 = state01.a;
                                state01.a = 0;
                                try {
                                    return __wbg_adapter_421(a10, state01.b, arg01, arg11);
                                } finally{
                                    state01.a = a10;
                                }
                            }, ret1 = new Promise(cb01);
                            return addHeapObject1(ret1);
                        } finally{
                            state01.a = state01.b = 0;
                        }
                    },
                    __wbg_resolve: function(arg01) {
                        return addHeapObject1(Promise.resolve(getObject1(arg01)));
                    },
                    __wbg_then_a: function(arg01, arg11) {
                        return addHeapObject1(getObject1(arg01).then(getObject1(arg11)));
                    },
                    __wbg_then_5: function(arg01, arg11, arg21) {
                        return addHeapObject1(getObject1(arg01).then(getObject1(arg11), getObject1(arg21)));
                    },
                    __wbindgen_debug_string: function(arg01, arg11) {
                        var ptr01 = passStringToWasm01(debugString1(getObject1(arg11)), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbindgen_throw: function(arg01, arg11) {
                        throw Error(getStringFromWasm01(arg01, arg11));
                    },
                    __wbindgen_closure_wrapper: function(arg01, arg11, arg21) {
                        return addHeapObject1(makeMutClosure1(arg01, arg11, dtorValue1, __wbg_adapter_141));
                    },
                    __wbindgen_string_new: function(arg01, arg11) {
                        return addHeapObject1(getStringFromWasm01(arg01, arg11));
                    },
                    __wbg_value: function(arg01) {
                        var ptr01 = passStringToWasm01(rawImports1.Vrf.value(), wasmInstance1.exports.__wbindgen_malloc, wasmInstance1.exports.__wbindgen_realloc), len01 = WASM_VECTOR_LEN1;
                        getInt32Memory01()[arg01 / 4 + 1] = len01, getInt32Memory01()[arg01 / 4 + 0] = ptr01;
                    },
                    __wbg_randomInt: function(arg01, arg11) {
                        return rawImports1.Vrf.randomInt(arg11);
                    }
                }, baseImportsKeys1 = Object.keys(baseImports1);
                let module1 = wbindgenImports1.reduce((acc1, wbindgenKey1)=>{
                    const baseImportsKey1 = baseImportsKeys1.find((key1)=>wbindgenKey1.startsWith(key1));
                    if (void 0 === baseImportsKey1) throw Error(`Cannot find import mapping for ${wbindgenKey1}`);
                    return acc1[wbindgenKey1] = baseImports1[baseImportsKey1], acc1;
                }, {}), imports1 = {};
                imports1.__wbindgen_placeholder__ = module1;
                let cachedTextDecoder1 = new TextDecoder('utf-8', {
                    ignoreBOM: !0,
                    fatal: !0
                });
                cachedTextDecoder1.decode();
                let cachegetUint8Memory01 = null;
                function getUint8Memory01() {
                    return (null === cachegetUint8Memory01 || cachegetUint8Memory01.buffer !== wasmInstance1.exports.memory.buffer) && (cachegetUint8Memory01 = new Uint8Array(wasmInstance1.exports.memory.buffer)), cachegetUint8Memory01;
                }
                function getStringFromWasm01(ptr1, len3) {
                    return cachedTextDecoder1.decode(getUint8Memory01().subarray(ptr1, ptr1 + len3));
                }
                const heap1 = Array(32).fill(void 0);
                heap1.push(void 0, null, !0, !1);
                let heap_next1 = heap1.length;
                function addHeapObject1(obj1) {
                    heap_next1 === heap1.length && heap1.push(heap1.length + 1);
                    const idx1 = heap_next1;
                    return heap_next1 = heap1[idx1], heap1[idx1] = obj1, idx1;
                }
                function getObject1(idx1) {
                    return heap1[idx1];
                }
                let WASM_VECTOR_LEN1 = 0, cachedTextEncoder1 = new TextEncoder('utf-8');
                const encodeString1 = 'function' == typeof cachedTextEncoder1.encodeInto ? function(arg4, view1) {
                    return cachedTextEncoder1.encodeInto(arg4, view1);
                } : function(arg4, view1) {
                    const buf1 = cachedTextEncoder1.encode(arg4);
                    return view1.set(buf1), {
                        read: arg4.length,
                        written: buf1.length
                    };
                };
                function passStringToWasm01(arg4, malloc1, realloc1) {
                    if (void 0 === realloc1) {
                        const buf1 = cachedTextEncoder1.encode(arg4), ptr1 = malloc1(buf1.length);
                        return getUint8Memory01().subarray(ptr1, ptr1 + buf1.length).set(buf1), WASM_VECTOR_LEN1 = buf1.length, ptr1;
                    }
                    let len3 = arg4.length, ptr1 = malloc1(len3);
                    const mem1 = getUint8Memory01();
                    let offset1 = 0;
                    for(; offset1 < len3; offset1++){
                        const code1 = arg4.charCodeAt(offset1);
                        if (code1 > 0x7f) break;
                        mem1[ptr1 + offset1] = code1;
                    }
                    if (offset1 !== len3) {
                        0 !== offset1 && (arg4 = arg4.slice(offset1)), ptr1 = realloc1(ptr1, len3, len3 = offset1 + 3 * arg4.length);
                        const view1 = getUint8Memory01().subarray(ptr1 + offset1, ptr1 + len3), ret1 = encodeString1(arg4, view1);
                        offset1 += ret1.written;
                    }
                    return WASM_VECTOR_LEN1 = offset1, ptr1;
                }
                let cachegetInt32Memory01 = null;
                function getInt32Memory01() {
                    return (null === cachegetInt32Memory01 || cachegetInt32Memory01.buffer !== wasmInstance1.exports.memory.buffer) && (cachegetInt32Memory01 = new Int32Array(wasmInstance1.exports.memory.buffer)), cachegetInt32Memory01;
                }
                function dropObject1(idx1) {
                    idx1 < 36 || (heap1[idx1] = heap_next1, heap_next1 = idx1);
                }
                function takeObject1(idx1) {
                    const ret1 = getObject1(idx1);
                    return dropObject1(idx1), ret1;
                }
                function debugString1(val1) {
                    let className1;
                    const type1 = typeof val1;
                    if ('number' == type1 || 'boolean' == type1 || null == val1) return `${val1}`;
                    if ('string' == type1) return `"${val1}"`;
                    if ('symbol' == type1) {
                        const description1 = val1.description;
                        return null == description1 ? 'Symbol' : `Symbol(${description1})`;
                    }
                    if ('function' == type1) {
                        const name1 = val1.name;
                        return 'string' == typeof name1 && name1.length > 0 ? `Function(${name1})` : 'Function';
                    }
                    if (Array.isArray(val1)) {
                        const length1 = val1.length;
                        let debug1 = '[';
                        length1 > 0 && (debug1 += debugString1(val1[0]));
                        for(let i2 = 1; i2 < length1; i2++)debug1 += ', ' + debugString1(val1[i2]);
                        return debug1 + ']';
                    }
                    const builtInMatches1 = /\[object ([^\]]+)\]/.exec(toString.call(val1));
                    if (!(builtInMatches1.length > 1)) return toString.call(val1);
                    if ('Object' == (className1 = builtInMatches1[1])) try {
                        return 'Object(' + JSON.stringify(val1) + ')';
                    } catch (_1) {
                        return 'Object';
                    }
                    return val1 instanceof Error ? `${val1.name}: ${val1.message}\n${val1.stack}` : className1;
                }
                function makeMutClosure1(arg01, arg11, dtor1, f1) {
                    const state1 = {
                        a: arg01,
                        b: arg11,
                        cnt: 1,
                        dtor: dtor1
                    }, real1 = (...args1)=>{
                        state1.cnt++;
                        const a10 = state1.a;
                        state1.a = 0;
                        try {
                            return f1(a10, state1.b, ...args1);
                        } finally{
                            0 == --state1.cnt ? wasmInstance1.exports.__wbindgen_export_2.get(state1.dtor)(a10, state1.b) : state1.a = a10;
                        }
                    };
                    return real1.original = state1, real1;
                }
                function __wbg_adapter_141(arg01, arg11, arg21) {
                    wasmInstance1.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__(arg01, arg11, addHeapObject1(arg21));
                }
                module1.handle = function(interaction1) {
                    return takeObject1(wasmInstance1.exports.handle(addHeapObject1(interaction1)));
                };
                let stack_pointer1 = 32;
                function addBorrowedObject1(obj1) {
                    if (1 == stack_pointer1) throw Error('out of js stack');
                    return heap1[--stack_pointer1] = obj1, stack_pointer1;
                }
                function handleError1(f1, args1) {
                    try {
                        return f1.apply(this, args1);
                    } catch (e1) {
                        wasmInstance1.exports.__wbindgen_exn_store(addHeapObject1(e1));
                    }
                }
                function __wbg_adapter_421(arg01, arg11, arg21, arg31) {
                    wasmInstance1.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__(arg01, arg11, addHeapObject1(arg21), addHeapObject1(arg31));
                }
                module1.initState = function(state1) {
                    try {
                        wasmInstance1.exports.initState(addBorrowedObject1(state1));
                    } finally{
                        heap1[stack_pointer1++] = void 0;
                    }
                }, module1.currentState = function() {
                    return takeObject1(wasmInstance1.exports.currentState());
                }, module1.lang = function() {
                    try {
                        const retptr1 = wasmInstance1.exports.__wbindgen_add_to_stack_pointer(-16);
                        wasmInstance1.exports.lang(retptr1);
                        var r01 = getInt32Memory01()[retptr1 / 4 + 0], r11 = getInt32Memory01()[retptr1 / 4 + 1];
                        return getStringFromWasm01(r01, r11);
                    } finally{
                        wasmInstance1.exports.__wbindgen_add_to_stack_pointer(16), wasmInstance1.exports.__wbindgen_free(r01, r11);
                    }
                }, module1.type = function() {
                    return wasmInstance1.exports.type();
                };
                class StateWrapper1 {
                    __destroy_into_raw() {
                        const ptr1 = this.ptr;
                        return this.ptr = 0, ptr1;
                    }
                    free() {
                        const ptr1 = this.__destroy_into_raw();
                        wasmInstance1.exports.__wbg_statewrapper_free(ptr1);
                    }
                }
                return module1.StateWrapper = StateWrapper1, imports1.metering = rawImports1.metering, {
                    imports: imports1,
                    exports: module1
                };
            };
            exports1.rustWasmImports = rustWasmImports1;
        },
        4742: function(__unused_webpack_module1, exports1) {
            "use strict";
            function matchMutClosureDtor1(source1) {
                const regexp1 = /var ret = makeMutClosure\(arg0, arg1, (\d+?), __wbg_adapter/, match1 = source1.match(regexp1);
                return match1[1];
            }
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.matchMutClosureDtor = void 0, exports1.matchMutClosureDtor = matchMutClosureDtor1;
        },
        702: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __createBinding1 = this && this.__createBinding || (Object.create ? function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3);
                var desc1 = Object.getOwnPropertyDescriptor(m1, k3);
                (!desc1 || ("get" in desc1 ? !m1.__esModule : desc1.writable || desc1.configurable)) && (desc1 = {
                    enumerable: !0,
                    get: function() {
                        return m1[k3];
                    }
                }), Object.defineProperty(o1, k21, desc1);
            } : function(o1, m1, k3, k21) {
                void 0 === k21 && (k21 = k3), o1[k21] = m1[k3];
            }), __exportStar1 = this && this.__exportStar || function(m1, exports1) {
                for(var p3 in m1)"default" === p3 || Object.prototype.hasOwnProperty.call(exports1, p3) || __createBinding1(exports1, m1, p3);
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), __exportStar1(__webpack_require__1(183), exports1), __exportStar1(__webpack_require__1(4089), exports1), __exportStar1(__webpack_require__1(2393), exports1), __exportStar1(__webpack_require__1(5913), exports1), __exportStar1(__webpack_require__1(5629), exports1), __exportStar1(__webpack_require__1(9106), exports1), __exportStar1(__webpack_require__1(2656), exports1), __exportStar1(__webpack_require__1(5368), exports1), __exportStar1(__webpack_require__1(5765), exports1), __exportStar1(__webpack_require__1(6769), exports1), __exportStar1(__webpack_require__1(7462), exports1), __exportStar1(__webpack_require__1(7089), exports1), __exportStar1(__webpack_require__1(3187), exports1), __exportStar1(__webpack_require__1(9564), exports1), __exportStar1(__webpack_require__1(1533), exports1), __exportStar1(__webpack_require__1(7346), exports1), __exportStar1(__webpack_require__1(4929), exports1), __exportStar1(__webpack_require__1(4286), exports1), __exportStar1(__webpack_require__1(9174), exports1), __exportStar1(__webpack_require__1(1967), exports1), __exportStar1(__webpack_require__1(8996), exports1), __exportStar1(__webpack_require__1(4965), exports1), __exportStar1(__webpack_require__1(2138), exports1), __exportStar1(__webpack_require__1(6105), exports1), __exportStar1(__webpack_require__1(3233), exports1), __exportStar1(__webpack_require__1(1515), exports1), __exportStar1(__webpack_require__1(3425), exports1), __exportStar1(__webpack_require__1(8632), exports1), __exportStar1(__webpack_require__1(7312), exports1), __exportStar1(__webpack_require__1(4805), exports1), __exportStar1(__webpack_require__1(9305), exports1), __exportStar1(__webpack_require__1(5614), exports1), __exportStar1(__webpack_require__1(8479), exports1), __exportStar1(__webpack_require__1(2009), exports1), __exportStar1(__webpack_require__1(9689), exports1), __exportStar1(__webpack_require__1(8469), exports1), __exportStar1(__webpack_require__1(9692), exports1), __exportStar1(__webpack_require__1(7665), exports1), __exportStar1(__webpack_require__1(7819), exports1), __exportStar1(__webpack_require__1(8102), exports1), __exportStar1(__webpack_require__1(4722), exports1), __exportStar1(__webpack_require__1(4217), exports1), __exportStar1(__webpack_require__1(5731), exports1), __exportStar1(__webpack_require__1(3611), exports1), __exportStar1(__webpack_require__1(4708), exports1), __exportStar1(__webpack_require__1(8563), exports1), __exportStar1(__webpack_require__1(9925), exports1), __exportStar1(__webpack_require__1(3633), exports1), __exportStar1(__webpack_require__1(40), exports1), __exportStar1(__webpack_require__1(5082), exports1), __exportStar1(__webpack_require__1(9360), exports1);
        },
        40: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.unpackTags = exports1.createDummyTx = exports1.createInteractionTx = void 0;
            const SmartWeaveTags_11 = __webpack_require__1(7312);
            async function createInteractionTx1(arweave1, signer1, contractId1, input1, tags1, target1 = '', winstonQty1 = '0', dummy1 = !1, reward1) {
                const options1 = {
                    data: Math.random().toString().slice(-4)
                };
                target1 && target1.length && (options1.target = target1.toString(), winstonQty1 && +winstonQty1 > 0 && (options1.quantity = winstonQty1.toString())), dummy1 && (options1.reward = '72600854', options1.last_tx = 'p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO'), reward1 && reward1.length && (options1.reward = reward1);
                const interactionTx1 = await arweave1.createTransaction(options1);
                if (!input1) throw Error(`Input should be a truthy value: ${JSON.stringify(input1)}`);
                if (tags1 && tags1.length) for (const tag1 of tags1)interactionTx1.addTag(tag1.name.toString(), tag1.value.toString());
                return interactionTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.APP_NAME, 'SmartWeaveAction'), interactionTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.APP_VERSION, '0.3.0'), interactionTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.SDK, 'Warp'), interactionTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.CONTRACT_TX_ID, contractId1), interactionTx1.addTag(SmartWeaveTags_11.SmartWeaveTags.INPUT, JSON.stringify(input1)), signer1 && await signer1(interactionTx1), interactionTx1;
            }
            function createDummyTx1(tx1, from1, block1) {
                const decodedTags1 = unpackTags1(tx1);
                return {
                    id: tx1.id,
                    owner: {
                        address: from1,
                        key: ''
                    },
                    recipient: tx1.target,
                    tags: decodedTags1,
                    fee: {
                        winston: tx1.reward,
                        ar: ''
                    },
                    quantity: {
                        winston: tx1.quantity,
                        ar: ''
                    },
                    block: {
                        id: block1.indep_hash,
                        height: block1.height,
                        timestamp: block1.timestamp,
                        previous: null
                    },
                    dry: !0,
                    anchor: null,
                    signature: null,
                    data: null,
                    parent: null,
                    bundledIn: null
                };
            }
            function unpackTags1(tx1) {
                const tags1 = tx1.get('tags'), result1 = [];
                for (const tag1 of tags1)try {
                    const name1 = tag1.get('name', {
                        decode: !0,
                        string: !0
                    }), value1 = tag1.get('value', {
                        decode: !0,
                        string: !0
                    });
                    result1.push({
                        name: name1,
                        value: value1
                    });
                } catch (e1) {}
                return result1;
            }
            exports1.createInteractionTx = createInteractionTx1, exports1.createDummyTx = createDummyTx1, exports1.unpackTags = unpackTags1;
        },
        9925: function(__unused_webpack_module1, exports1) {
            "use strict";
            var SmartWeaveErrorType1;
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.SmartWeaveError = exports1.SmartWeaveErrorType = void 0, function(SmartWeaveErrorType1) {
                SmartWeaveErrorType1.CONTRACT_NOT_FOUND = "CONTRACT_NOT_FOUND";
            }(SmartWeaveErrorType1 = exports1.SmartWeaveErrorType || (exports1.SmartWeaveErrorType = {}));
            class SmartWeaveError1 extends Error {
                constructor(type1, optional1 = {}){
                    optional1.message ? super(optional1.message) : super(), this.type = type1, this.otherInfo = optional1;
                }
                getType() {
                    return this.type;
                }
            }
            exports1.SmartWeaveError = SmartWeaveError1;
        },
        4708: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        8563: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.SmartWeaveGlobal = void 0;
            class SmartWeaveGlobal1 {
                constructor(arweave1, contract1, evaluationOptions1){
                    this.gasUsed = 0, this.gasLimit = Number.MAX_SAFE_INTEGER, this.unsafeClient = arweave1, this.arweave = {
                        ar: arweave1.ar,
                        utils: arweave1.utils,
                        wallets: arweave1.wallets,
                        crypto: arweave1.crypto
                    }, this.evaluationOptions = evaluationOptions1, this.contract = contract1, this.transaction = new Transaction1(this), this.block = new Block1(this), this.contracts = {
                        readContractState: (contractId1, height1, returnValidity1)=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        },
                        viewContractState: (contractId1, input1)=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        },
                        write: (contractId1, input1)=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        },
                        refreshState: ()=>{
                            throw Error('Not implemented - should be set by HandlerApi implementor');
                        }
                    }, this.vrf = new Vrf1(this), this.useGas = this.useGas.bind(this), this.getBalance = this.getBalance.bind(this);
                }
                useGas(gas1) {
                    if (gas1 < 0) throw Error("[RE:GNE] Gas number exception - gas < 0.");
                    if (this.gasUsed += gas1, this.gasUsed > this.gasLimit) throw Error(`[RE:OOG] Out of gas! Used: ${this.gasUsed}, limit: ${this.gasLimit}`);
                }
                async getBalance(address1, height1) {
                    if (!this._activeTx) throw Error('Cannot read balance - active tx is not set.');
                    if (!this.block.height) throw Error('Cannot read balance - block height not set.');
                    const effectiveHeight1 = height1 || this.block.height;
                    return await fetch(`${this.evaluationOptions.walletBalanceUrl}block/height/${effectiveHeight1}/wallet/${address1}/balance`).then((res1)=>res1.ok ? res1.text() : Promise.reject(res1)).catch((error1)=>{
                        var _a1;
                        throw Error(`Unable to read wallet balance. ${error1.status}. ${null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message}`);
                    });
                }
            }
            exports1.SmartWeaveGlobal = SmartWeaveGlobal1;
            class Transaction1 {
                constructor(smartWeaveGlobal1){
                    this.smartWeaveGlobal = smartWeaveGlobal1;
                }
                get id() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.id;
                }
                get owner() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.owner.address;
                }
                get target() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.recipient;
                }
                get tags() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.tags;
                }
                get quantity() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.quantity.winston;
                }
                get reward() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.fee.winston;
                }
            }
            class Block1 {
                constructor(smartWeaveGlobal1){
                    this.smartWeaveGlobal = smartWeaveGlobal1;
                }
                get height() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.block.height;
                }
                get indep_hash() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current Tx');
                    return this.smartWeaveGlobal._activeTx.block.id;
                }
                get timestamp() {
                    if (!this.smartWeaveGlobal._activeTx) throw Error('No current tx');
                    return this.smartWeaveGlobal._activeTx.block.timestamp;
                }
            }
            class Vrf1 {
                constructor(smartWeaveGlobal1){
                    this.smartWeaveGlobal = smartWeaveGlobal1;
                }
                get data() {
                    return this.smartWeaveGlobal._activeTx.vrf;
                }
                get value() {
                    return this.smartWeaveGlobal._activeTx.vrf.bigint;
                }
                randomInt(maxValue1) {
                    if (!Number.isInteger(maxValue1)) throw Error('Integer max value required for random integer generation');
                    const result1 = BigInt(this.smartWeaveGlobal._activeTx.vrf.bigint) % BigInt(maxValue1) + BigInt(1);
                    if (result1 > Number.MAX_SAFE_INTEGER || result1 < Number.MIN_SAFE_INTEGER) throw Error('Random int cannot be cast to number');
                    return Number(result1);
                }
            }
        },
        3633: function(__unused_webpack_module1, exports1) {
            "use strict";
            function getTag1(tx1, name1) {
                const tags1 = tx1.get('tags');
                for (const tag1 of tags1)try {
                    if (tag1.get('name', {
                        decode: !0,
                        string: !0
                    }) === name1) return tag1.get('value', {
                        decode: !0,
                        string: !0
                    });
                } catch (e1) {}
                return !1;
            }
            function arrayToHex1(arr1) {
                let str1 = '';
                for (const a10 of arr1)str1 += ('0' + a10.toString(16)).slice(-2);
                return str1;
            }
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.arrayToHex = exports1.getTag = void 0, exports1.getTag = getTag1, exports1.arrayToHex = arrayToHex1;
        },
        9106: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.Benchmark = void 0;
            class Benchmark1 {
                constructor(){
                    this.start = Date.now(), this.end = null;
                }
                static measure() {
                    return new Benchmark1();
                }
                reset() {
                    this.start = Date.now(), this.end = null;
                }
                stop() {
                    this.end = Date.now();
                }
                elapsed(rawValue1 = !1) {
                    null === this.end && (this.end = Date.now());
                    const result1 = this.end - this.start;
                    return rawValue1 ? result1 : `${(this.end - this.start).toFixed(0)}ms`;
                }
            }
            exports1.Benchmark = Benchmark1;
        },
        5913: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.LoggerFactory = void 0;
            const ConsoleLoggerFactory_11 = __webpack_require__1(4089);
            class LoggerFactory1 {
                constructor(){}
                setOptions(newOptions1, moduleName1) {
                    LoggerFactory1.INST.setOptions(newOptions1, moduleName1);
                }
                getOptions(moduleName1) {
                    return LoggerFactory1.INST.getOptions(moduleName1);
                }
                logLevel(level1, moduleName1) {
                    LoggerFactory1.INST.logLevel(level1, moduleName1);
                }
                create(moduleName1) {
                    return LoggerFactory1.INST.create(moduleName1);
                }
                static use(logger1) {
                    LoggerFactory1.INST = logger1;
                }
            }
            exports1.LoggerFactory = LoggerFactory1, LoggerFactory1.INST = new ConsoleLoggerFactory_11.ConsoleLoggerFactory();
        },
        5629: function(__unused_webpack_module1, exports1) {
            "use strict";
            function lvlToOrder1(logLevel1) {
                return exports1.LogLevelOrder[logLevel1];
            }
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.lvlToOrder = exports1.LogLevelOrder = void 0, exports1.LogLevelOrder = {
                silly: 0,
                trace: 1,
                debug: 2,
                info: 3,
                warn: 4,
                error: 5,
                fatal: 6
            }, exports1.lvlToOrder = lvlToOrder1;
        },
        2393: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            });
        },
        183: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.ConsoleLogger = void 0;
            const LoggerSettings_11 = __webpack_require__1(5629);
            class ConsoleLogger1 {
                constructor(moduleName1, settings1){
                    this.moduleName = moduleName1, this.settings = settings1;
                }
                trace(message1, ...optionalParams1) {
                    this.shouldLog('trace') && console.debug(this.message('trace', message1), optionalParams1);
                }
                error(message1, ...optionalParams1) {
                    this.shouldLog('error') && console.error(this.message('error', message1), optionalParams1);
                }
                info(message1, ...optionalParams1) {
                    this.shouldLog('info') && console.info(this.message('info', message1), optionalParams1);
                }
                silly(message1, ...optionalParams1) {
                    this.shouldLog('silly') && console.debug(this.message('silly', message1), optionalParams1);
                }
                debug(message1, ...optionalParams1) {
                    this.shouldLog('debug') && console.debug(this.message('debug', message1), optionalParams1);
                }
                warn(message1, ...optionalParams1) {
                    this.shouldLog('warn') && console.warn(this.message('warn', message1), optionalParams1);
                }
                log(message1, ...optionalParams1) {
                    this.shouldLog('info') && console.info(this.message('info', message1), optionalParams1);
                }
                fatal(message1, ...optionalParams1) {
                    this.shouldLog('fatal') && console.error(this.message('fatal', message1), optionalParams1);
                }
                shouldLog(logLevel1) {
                    return (0, LoggerSettings_11.lvlToOrder)(logLevel1) >= (0, LoggerSettings_11.lvlToOrder)(this.settings.minLevel);
                }
                setSettings(settings1) {
                    this.settings = settings1;
                }
                message(lvl1, message1) {
                    return `${new Date().toISOString()} ${lvl1.toUpperCase()} [${this.moduleName}] ${message1}`;
                }
            }
            exports1.ConsoleLogger = ConsoleLogger1;
        },
        4089: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.ConsoleLoggerFactory = void 0;
            const ConsoleLogger_11 = __webpack_require__1(183);
            class ConsoleLoggerFactory1 {
                constructor(){
                    this.registeredLoggers = {}, this.registeredOptions = {}, this.defOptions = {
                        minLevel: 'info'
                    }, this.setOptions = this.setOptions.bind(this), this.getOptions = this.getOptions.bind(this), this.create = this.create.bind(this), this.logLevel = this.logLevel.bind(this);
                }
                setOptions(newOptions1, moduleName1) {
                    moduleName1 ? this.registeredLoggers[moduleName1] ? this.registeredLoggers[moduleName1].setSettings({
                        ...this.registeredLoggers[moduleName1].settings,
                        ...newOptions1
                    }) : this.registeredOptions[moduleName1] = {
                        ...this.defOptions,
                        ...newOptions1
                    } : (this.defOptions = newOptions1, Object.keys(this.registeredLoggers).forEach((key1)=>{
                        this.registeredLoggers[key1].setSettings({
                            ...this.registeredLoggers[key1].settings,
                            ...newOptions1
                        });
                    }));
                }
                getOptions(moduleName1) {
                    return moduleName1 ? this.registeredLoggers[moduleName1] ? this.registeredLoggers[moduleName1].settings : this.registeredOptions[moduleName1] ? this.registeredOptions[moduleName1] : this.defOptions : this.defOptions;
                }
                logLevel(level1, moduleName1) {
                    this.setOptions({
                        minLevel: level1
                    }, moduleName1);
                }
                create(moduleName1 = 'SWC') {
                    return Object.prototype.hasOwnProperty.call(this.registeredLoggers, moduleName1) || (this.registeredLoggers[moduleName1] = new ConsoleLogger_11.ConsoleLogger(moduleName1, this.getOptions(moduleName1))), this.registeredLoggers[moduleName1];
                }
            }
            exports1.ConsoleLoggerFactory = ConsoleLoggerFactory1;
        },
        7794: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.CacheableExecutorFactory = void 0;
            const LoggerFactory_11 = __webpack_require__1(5913);
            class CacheableExecutorFactory1 {
                constructor(arweave1, baseImplementation1, cache1){
                    this.arweave = arweave1, this.baseImplementation = baseImplementation1, this.cache = cache1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('CacheableExecutorFactory');
                }
                async create(contractDefinition1, evaluationOptions1) {
                    return await this.baseImplementation.create(contractDefinition1, evaluationOptions1);
                }
            }
            exports1.CacheableExecutorFactory = CacheableExecutorFactory1;
        },
        4481: function(__unused_webpack_module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.DebuggableExecutorFactory = void 0;
            class DebuggableExecutorFactory1 {
                constructor(baseImplementation1, sourceCode1){
                    this.baseImplementation = baseImplementation1, this.sourceCode = sourceCode1;
                }
                async create(contractDefinition1, evaluationOptions1) {
                    return Object.prototype.hasOwnProperty.call(this.sourceCode, contractDefinition1.txId) && (contractDefinition1 = {
                        ...contractDefinition1,
                        src: this.sourceCode[contractDefinition1.txId]
                    }), await this.baseImplementation.create(contractDefinition1, evaluationOptions1);
                }
            }
            exports1.DebuggableExecutorFactory = DebuggableExecutorFactory1;
        },
        2491: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.Evolve = void 0;
            const LoggerFactory_11 = __webpack_require__1(5913), errors_11 = __webpack_require__1(9925);
            function isEvolveCompatible1(state1) {
                if (!state1) return !1;
                const settings1 = evalSettings1(state1);
                return void 0 !== state1.evolve || settings1.has('evolve');
            }
            class Evolve1 {
                constructor(){
                    this.logger = LoggerFactory_11.LoggerFactory.INST.create('Evolve'), this.modify = this.modify.bind(this);
                }
                async modify(state1, executionContext1) {
                    const { definitionLoader: definitionLoader1 , executorFactory: executorFactory1  } = executionContext1.warp, contractTxId1 = executionContext1.contractDefinition.txId, evolvedSrcTxId1 = Evolve1.evolvedSrcTxId(state1), currentSrcTxId1 = executionContext1.contractDefinition.srcTxId;
                    if (evolvedSrcTxId1 && (this.logger.debug('Checking evolve:', {
                        current: currentSrcTxId1,
                        evolvedSrcTxId: evolvedSrcTxId1
                    }), currentSrcTxId1 !== evolvedSrcTxId1)) try {
                        this.logger.info('Evolving to: ', evolvedSrcTxId1);
                        const newContractDefinition1 = await definitionLoader1.load(contractTxId1, evolvedSrcTxId1), newHandler1 = await executorFactory1.create(newContractDefinition1, executionContext1.evaluationOptions);
                        executionContext1.contractDefinition = newContractDefinition1, executionContext1.handler = newHandler1, executionContext1.handler.initState(state1), this.logger.debug('evolved to:', {
                            evolve: evolvedSrcTxId1,
                            newSrcTxId: executionContext1.contractDefinition.srcTxId,
                            current: currentSrcTxId1,
                            txId: executionContext1.contractDefinition.txId
                        });
                    } catch (e1) {
                        throw new errors_11.SmartWeaveError(errors_11.SmartWeaveErrorType.CONTRACT_NOT_FOUND, {
                            message: `Contract having txId: ${contractTxId1} not found`,
                            requestedTxId: contractTxId1
                        });
                    }
                    return executionContext1;
                }
                static evolvedSrcTxId(state1) {
                    if (!isEvolveCompatible1(state1)) return;
                    const settings1 = evalSettings1(state1), evolve1 = state1.evolve || settings1.get('evolve');
                    let canEvolve1 = state1.canEvolve || settings1.get('canEvolve');
                    if (null == canEvolve1 && (canEvolve1 = !0), evolve1 && /[a-z0-9_-]{43}/i.test(evolve1) && canEvolve1) return evolve1;
                }
            }
            function evalSettings1(state1) {
                let settings1 = new Map();
                return state1.settings && (isIterable1(state1.settings) ? settings1 = new Map(state1.settings) : isObject1(state1.settings) && (settings1 = new Map(Object.entries(state1.settings)))), settings1;
            }
            function isIterable1(obj1) {
                return null != obj1 && 'function' == typeof obj1[Symbol.iterator];
            }
            function isObject1(obj1) {
                return 'object' == typeof obj1 && null !== obj1 && !Array.isArray(obj1);
            }
            exports1.Evolve = Evolve1;
        },
        9360: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.ArweaveWrapper = void 0;
            const arweave_11 = __importDefault1(__webpack_require__1(7386)), transaction_11 = __importDefault1(__webpack_require__1(7241)), redstone_isomorphic_11 = __webpack_require__1(9180), WarpFactory_11 = __webpack_require__1(8479), LoggerFactory_11 = __webpack_require__1(5913);
            class ArweaveWrapper1 {
                constructor(arweave1){
                    this.arweave = arweave1, this.logger = LoggerFactory_11.LoggerFactory.INST.create('ArweaveWrapper'), this.baseUrl = `${arweave1.api.config.protocol}://${arweave1.api.config.host}:${arweave1.api.config.port}`, this.logger.debug('baseurl', this.baseUrl);
                }
                async warpGwInfo() {
                    return await this.doFetchInfo(`${WarpFactory_11.WARP_GW_URL}/gateway/arweave/info`);
                }
                async warpGwBlock() {
                    return this.logger.debug('Calling warp gw block info'), await this.doFetchInfo(`${WarpFactory_11.WARP_GW_URL}/gateway/arweave/block`);
                }
                async info() {
                    return await this.doFetchInfo(`${this.baseUrl}/info`);
                }
                async gql(query1, variables1) {
                    try {
                        const data1 = JSON.stringify({
                            query: query1,
                            variables: variables1
                        }), response1 = await fetch(`${this.baseUrl}/graphql`, {
                            method: 'POST',
                            body: data1,
                            headers: {
                                'Accept-Encoding': 'gzip, deflate, br',
                                'Content-Type': 'application/json',
                                Accept: 'application/json'
                            }
                        }).then((res1)=>res1.ok ? res1.json() : Promise.reject(res1)).catch((error1)=>{
                            var _a1, _b1;
                            throw (null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message) && this.logger.error(error1.body.message), Error(`Unable to retrieve gql page. ${error1.status}: ${null === (_b1 = error1.body) || void 0 === _b1 ? void 0 : _b1.message}`);
                        });
                        return {
                            data: response1,
                            status: 200
                        };
                    } catch (e1) {
                        throw this.logger.error('Error while loading gql', e1), e1;
                    }
                }
                async tx(id1) {
                    const response1 = await fetch(`${this.baseUrl}/tx/${id1}`).then((res1)=>res1.ok ? res1.json() : Promise.reject(res1)).catch((error1)=>{
                        var _a1, _b1;
                        throw (null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message) && this.logger.error(error1.body.message), Error(`Unable to retrieve tx ${id1}. ${error1.status}. ${null === (_b1 = error1.body) || void 0 === _b1 ? void 0 : _b1.message}`);
                    });
                    return new transaction_11.default({
                        ...response1
                    });
                }
                async txData(id1) {
                    const response1 = await fetch(`${this.baseUrl}/${id1}`);
                    if (response1.ok) {
                        const buffer1 = await response1.arrayBuffer();
                        return redstone_isomorphic_11.Buffer.from(buffer1);
                    }
                    {
                        this.logger.warn(`Unable to load data from arweave.net/${id1} endpoint, falling back to arweave.js`);
                        const txData1 = await this.arweave.transactions.getData(id1, {
                            decode: !0
                        });
                        return redstone_isomorphic_11.Buffer.from(txData1);
                    }
                }
                async txDataString(id1) {
                    const buffer1 = await this.txData(id1);
                    return arweave_11.default.utils.bufferToString(buffer1);
                }
                async doFetchInfo(url1) {
                    try {
                        const response1 = await fetch(url1).then((res1)=>res1.ok ? res1.json() : Promise.reject(res1)).catch((error1)=>{
                            var _a1, _b1;
                            throw (null === (_a1 = error1.body) || void 0 === _a1 ? void 0 : _a1.message) && this.logger.error(error1.body.message), Error(`Unable to retrieve info. ${error1.status}: ${null === (_b1 = error1.body) || void 0 === _b1 ? void 0 : _b1.message}`);
                        });
                        return response1;
                    } catch (e1) {
                        throw this.logger.error('Error while loading info', e1), e1;
                    }
                }
            }
            exports1.ArweaveWrapper = ArweaveWrapper1;
        },
        5082: function(__unused_webpack_module1, exports1, __webpack_require__1) {
            "use strict";
            var __importDefault1 = this && this.__importDefault || function(mod1) {
                return mod1 && mod1.__esModule ? mod1 : {
                    default: mod1
                };
            };
            Object.defineProperty(exports1, "__esModule", {
                value: !0
            }), exports1.indent = exports1.stripTrailingSlash = exports1.timeout = exports1.descS = exports1.desc = exports1.ascS = exports1.asc = exports1.mapReviver = exports1.mapReplacer = exports1.deepCopy = exports1.sleep = void 0;
            const cloneDeep_11 = __importDefault1(__webpack_require__1(361)), fast_copy_11 = __importDefault1(__webpack_require__1(3346)), sleep1 = (ms1)=>new Promise((resolve1)=>setTimeout(resolve1, ms1));
            exports1.sleep = sleep1;
            const deepCopy1 = (input1, useFastCopy1 = !1)=>useFastCopy1 ? (0, fast_copy_11.default)(input1) : (0, cloneDeep_11.default)(input1);
            exports1.deepCopy = deepCopy1;
            const mapReplacer1 = (key1, value1)=>value1 instanceof Map ? {
                    dataType: 'Map',
                    value: Array.from(value1.entries())
                } : value1;
            exports1.mapReplacer = mapReplacer1;
            const mapReviver1 = (key1, value1)=>'object' == typeof value1 && null !== value1 && 'Map' === value1.dataType ? new Map(value1.value) : value1;
            exports1.mapReviver = mapReviver1;
            const asc1 = (a10, b10)=>a10 - b10;
            exports1.asc = asc1;
            const ascS1 = (a10, b10)=>+a10 - +b10;
            exports1.ascS = ascS1;
            const desc1 = (a10, b10)=>b10 - a10;
            exports1.desc = desc1;
            const descS1 = (a10, b10)=>+b10 - +a10;
            function timeout1(s3) {
                let timeoutId1 = null;
                const timeoutPromise1 = new Promise((resolve1, reject1)=>{
                    timeoutId1 = setTimeout(()=>{
                        clearTimeout(timeoutId1), reject1('timeout');
                    }, 1000 * s3);
                });
                return {
                    timeoutId: timeoutId1,
                    timeoutPromise: timeoutPromise1
                };
            }
            function stripTrailingSlash1(str1) {
                return str1.endsWith('/') ? str1.slice(0, -1) : str1;
            }
            function indent1(callDepth1) {
                return ''.padEnd(2 * callDepth1, ' ');
            }
            exports1.descS = descS1, exports1.timeout = timeout1, exports1.stripTrailingSlash = stripTrailingSlash1, exports1.indent = indent1;
        },
        6430: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var forEach1 = __webpack_require__1(4029), availableTypedArrays1 = __webpack_require__1(3083), callBound1 = __webpack_require__1(1924), $toString1 = callBound1('Object.prototype.toString'), hasToStringTag1 = __webpack_require__1(6410)(), g3 = 'undefined' == typeof globalThis ? __webpack_require__1.g : globalThis, typedArrays1 = availableTypedArrays1(), $slice1 = callBound1('String.prototype.slice'), toStrTags1 = {}, gOPD1 = __webpack_require__1(882), getPrototypeOf1 = Object.getPrototypeOf;
            hasToStringTag1 && gOPD1 && getPrototypeOf1 && forEach1(typedArrays1, function(typedArray1) {
                if ('function' == typeof g3[typedArray1]) {
                    var arr1 = new g3[typedArray1]();
                    if (Symbol.toStringTag in arr1) {
                        var proto1 = getPrototypeOf1(arr1), descriptor1 = gOPD1(proto1, Symbol.toStringTag);
                        descriptor1 || (descriptor1 = gOPD1(getPrototypeOf1(proto1), Symbol.toStringTag)), toStrTags1[typedArray1] = descriptor1.get;
                    }
                }
            });
            var tryTypedArrays1 = function(value1) {
                var foundName1 = !1;
                return forEach1(toStrTags1, function(getter1, typedArray1) {
                    if (!foundName1) try {
                        var name1 = getter1.call(value1);
                        name1 === typedArray1 && (foundName1 = name1);
                    } catch (e1) {}
                }), foundName1;
            }, isTypedArray1 = __webpack_require__1(5692);
            module1.exports = function(value1) {
                return !!isTypedArray1(value1) && (hasToStringTag1 && Symbol.toStringTag in value1 ? tryTypedArrays1(value1) : $slice1($toString1(value1), 8, -1));
            };
        },
        7605: function(module1, exports1) {
            var __WEBPACK_AMD_DEFINE_RESULT__1, loader1 = function(exports1) {
                "use strict";
                Object.defineProperty(exports1, "__esModule", {
                    value: !0
                }), exports1.default = void 0, exports1.demangle = demangle1, exports1.instantiate = instantiate1, exports1.instantiateStreaming = instantiateStreaming1, exports1.instantiateSync = instantiateSync1;
                const ID_OFFSET1 = -8, SIZE_OFFSET1 = -4, ARRAYBUFFER_ID1 = 0, STRING_ID1 = 1, ARRAYBUFFERVIEW1 = 1, ARRAY1 = 2, STATICARRAY1 = 4, VAL_ALIGN_OFFSET1 = 6, VAL_SIGNED1 = 2048, VAL_FLOAT1 = 4096, VAL_MANAGED1 = 16384, ARRAYBUFFERVIEW_BUFFER_OFFSET1 = 0, ARRAYBUFFERVIEW_DATASTART_OFFSET1 = 4, ARRAYBUFFERVIEW_BYTELENGTH_OFFSET1 = 8, ARRAYBUFFERVIEW_SIZE1 = 12, ARRAY_LENGTH_OFFSET1 = 12, ARRAY_SIZE1 = 16, E_NO_EXPORT_TABLE1 = "Operation requires compiling with --exportTable", E_NO_EXPORT_RUNTIME1 = "Operation requires compiling with --exportRuntime", F_NO_EXPORT_RUNTIME1 = ()=>{
                    throw Error(E_NO_EXPORT_RUNTIME1);
                }, BIGINT1 = "undefined" != typeof BigUint64Array, THIS1 = Symbol(), STRING_SMALLSIZE1 = 192, STRING_CHUNKSIZE1 = 1024, utf161 = new TextDecoder("utf-16le", {
                    fatal: !0
                });
                function getStringImpl1(buffer1, ptr1) {
                    let len3 = new Uint32Array(buffer1)[ptr1 + SIZE_OFFSET1 >>> 2] >>> 1;
                    const wtf161 = new Uint16Array(buffer1, ptr1, len3);
                    if (len3 <= STRING_SMALLSIZE1) return String.fromCharCode(...wtf161);
                    try {
                        return utf161.decode(wtf161);
                    } catch  {
                        let str1 = "", off1 = 0;
                        for(; len3 - off1 > STRING_CHUNKSIZE1;)str1 += String.fromCharCode(...wtf161.subarray(off1, off1 += STRING_CHUNKSIZE1));
                        return str1 + String.fromCharCode(...wtf161.subarray(off1));
                    }
                }
                function preInstantiate1(imports1) {
                    const extendedExports1 = {};
                    function getString1(memory1, ptr1) {
                        return memory1 ? getStringImpl1(memory1.buffer, ptr1) : "<yet unknown>";
                    }
                    const env1 = imports1.env = imports1.env || {};
                    return env1.abort = env1.abort || function(msg1, file1, line1, colm1) {
                        const memory1 = extendedExports1.memory || env1.memory;
                        throw Error(`abort: ${getString1(memory1, msg1)} at ${getString1(memory1, file1)}:${line1}:${colm1}`);
                    }, env1.trace = env1.trace || function(msg1, n2, ...args1) {
                        const memory1 = extendedExports1.memory || env1.memory;
                        console.log(`trace: ${getString1(memory1, msg1)}${n2 ? " " : ""}${args1.slice(0, n2).join(", ")}`);
                    }, env1.seed = env1.seed || Date.now, imports1.Math = imports1.Math || Math, imports1.Date = imports1.Date || Date, extendedExports1;
                }
                function postInstantiate1(extendedExports1, instance1) {
                    const exports1 = instance1.exports, memory1 = exports1.memory, table1 = exports1.table, __new1 = exports1.__new || F_NO_EXPORT_RUNTIME1, __pin1 = exports1.__pin || F_NO_EXPORT_RUNTIME1, __unpin1 = exports1.__unpin || F_NO_EXPORT_RUNTIME1, __collect1 = exports1.__collect || F_NO_EXPORT_RUNTIME1, __rtti_base1 = exports1.__rtti_base, getRttiCount1 = __rtti_base1 ? (arr1)=>arr1[__rtti_base1 >>> 2] : F_NO_EXPORT_RUNTIME1;
                    function getRttInfo1(id1) {
                        const U321 = new Uint32Array(memory1.buffer);
                        if ((id1 >>>= 0) >= getRttiCount1(U321)) throw Error(`invalid id: ${id1}`);
                        return U321[(__rtti_base1 + 4 >>> 2) + (id1 << 1)];
                    }
                    function getRttBase1(id1) {
                        const U321 = new Uint32Array(memory1.buffer);
                        if ((id1 >>>= 0) >= getRttiCount1(U321)) throw Error(`invalid id: ${id1}`);
                        return U321[(__rtti_base1 + 4 >>> 2) + (id1 << 1) + 1];
                    }
                    function getArrayInfo1(id1) {
                        const info1 = getRttInfo1(id1);
                        if (!(info1 & (ARRAYBUFFERVIEW1 | ARRAY1 | STATICARRAY1))) throw Error(`not an array: ${id1}, flags=${info1}`);
                        return info1;
                    }
                    function getValueAlign1(info1) {
                        return 31 - Math.clz32(info1 >>> VAL_ALIGN_OFFSET1 & 31);
                    }
                    function __newString1(str1) {
                        if (null == str1) return 0;
                        const length1 = str1.length, ptr1 = __new1(length1 << 1, STRING_ID1), U161 = new Uint16Array(memory1.buffer);
                        for(var i2 = 0, p3 = ptr1 >>> 1; i2 < length1; ++i2)U161[p3 + i2] = str1.charCodeAt(i2);
                        return ptr1;
                    }
                    function __newArrayBuffer1(buf1) {
                        if (null == buf1) return 0;
                        const bufview1 = new Uint8Array(buf1), ptr1 = __new1(bufview1.length, ARRAYBUFFER_ID1), U81 = new Uint8Array(memory1.buffer);
                        return U81.set(bufview1, ptr1), ptr1;
                    }
                    function __getString1(ptr1) {
                        if (!ptr1) return null;
                        const buffer1 = memory1.buffer, id1 = new Uint32Array(buffer1)[ptr1 + ID_OFFSET1 >>> 2];
                        if (id1 !== STRING_ID1) throw Error(`not a string: ${ptr1}`);
                        return getStringImpl1(buffer1, ptr1);
                    }
                    function getView1(alignLog21, signed1, float1) {
                        const buffer1 = memory1.buffer;
                        if (float1) switch(alignLog21){
                            case 2:
                                return new Float32Array(buffer1);
                            case 3:
                                return new Float64Array(buffer1);
                        }
                        else switch(alignLog21){
                            case 0:
                                return new (signed1 ? Int8Array : Uint8Array)(buffer1);
                            case 1:
                                return new (signed1 ? Int16Array : Uint16Array)(buffer1);
                            case 2:
                                return new (signed1 ? Int32Array : Uint32Array)(buffer1);
                            case 3:
                                return new (signed1 ? BigInt64Array : BigUint64Array)(buffer1);
                        }
                        throw Error(`unsupported align: ${alignLog21}`);
                    }
                    function __newArray1(id1, valuesOrCapacity1 = 0) {
                        let result1;
                        const input1 = valuesOrCapacity1, info1 = getArrayInfo1(id1), align1 = getValueAlign1(info1), isArrayLike1 = "number" != typeof input1, length1 = isArrayLike1 ? input1.length : input1, buf1 = __new1(length1 << align1, info1 & STATICARRAY1 ? id1 : ARRAYBUFFER_ID1);
                        if (info1 & STATICARRAY1) result1 = buf1;
                        else {
                            __pin1(buf1);
                            const arr1 = __new1(info1 & ARRAY1 ? ARRAY_SIZE1 : ARRAYBUFFERVIEW_SIZE1, id1);
                            __unpin1(buf1);
                            const U321 = new Uint32Array(memory1.buffer);
                            U321[arr1 + ARRAYBUFFERVIEW_BUFFER_OFFSET1 >>> 2] = buf1, U321[arr1 + ARRAYBUFFERVIEW_DATASTART_OFFSET1 >>> 2] = buf1, U321[arr1 + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET1 >>> 2] = length1 << align1, info1 & ARRAY1 && (U321[arr1 + ARRAY_LENGTH_OFFSET1 >>> 2] = length1), result1 = arr1;
                        }
                        if (isArrayLike1) {
                            const view1 = getView1(align1, info1 & VAL_SIGNED1, info1 & VAL_FLOAT1), start1 = buf1 >>> align1;
                            if (info1 & VAL_MANAGED1) for(let i2 = 0; i2 < length1; ++i2)view1[start1 + i2] = input1[i2];
                            else view1.set(input1, start1);
                        }
                        return result1;
                    }
                    function __getArrayView1(arr1) {
                        const U321 = new Uint32Array(memory1.buffer), id1 = U321[arr1 + ID_OFFSET1 >>> 2], info1 = getArrayInfo1(id1), align1 = getValueAlign1(info1);
                        let buf1 = info1 & STATICARRAY1 ? arr1 : U321[arr1 + ARRAYBUFFERVIEW_DATASTART_OFFSET1 >>> 2];
                        const length1 = info1 & ARRAY1 ? U321[arr1 + ARRAY_LENGTH_OFFSET1 >>> 2] : U321[buf1 + SIZE_OFFSET1 >>> 2] >>> align1;
                        return getView1(align1, info1 & VAL_SIGNED1, info1 & VAL_FLOAT1).subarray(buf1 >>>= align1, buf1 + length1);
                    }
                    function __getArray1(arr1) {
                        const input1 = __getArrayView1(arr1), len3 = input1.length, out1 = Array(len3);
                        for(let i2 = 0; i2 < len3; i2++)out1[i2] = input1[i2];
                        return out1;
                    }
                    function __getArrayBuffer1(ptr1) {
                        const buffer1 = memory1.buffer, length1 = new Uint32Array(buffer1)[ptr1 + SIZE_OFFSET1 >>> 2];
                        return buffer1.slice(ptr1, ptr1 + length1);
                    }
                    function __getFunction1(ptr1) {
                        if (!table1) throw Error(E_NO_EXPORT_TABLE1);
                        const index1 = new Uint32Array(memory1.buffer)[ptr1 >>> 2];
                        return table1.get(index1);
                    }
                    function getTypedArray1(Type1, alignLog21, ptr1) {
                        return new Type1(getTypedArrayView1(Type1, alignLog21, ptr1));
                    }
                    function getTypedArrayView1(Type1, alignLog21, ptr1) {
                        const buffer1 = memory1.buffer, U321 = new Uint32Array(buffer1);
                        return new Type1(buffer1, U321[ptr1 + ARRAYBUFFERVIEW_DATASTART_OFFSET1 >>> 2], U321[ptr1 + ARRAYBUFFERVIEW_BYTELENGTH_OFFSET1 >>> 2] >>> alignLog21);
                    }
                    function attachTypedArrayFunctions1(ctor1, name1, align1) {
                        extendedExports1[`__get${name1}`] = getTypedArray1.bind(null, ctor1, align1), extendedExports1[`__get${name1}View`] = getTypedArrayView1.bind(null, ctor1, align1);
                    }
                    function __instanceof1(ptr1, baseId1) {
                        const U321 = new Uint32Array(memory1.buffer);
                        let id1 = U321[ptr1 + ID_OFFSET1 >>> 2];
                        if (id1 <= getRttiCount1(U321)) do {
                            if (id1 == baseId1) return !0;
                            id1 = getRttBase1(id1);
                        }while (id1)
                        return !1;
                    }
                    return extendedExports1.__new = __new1, extendedExports1.__pin = __pin1, extendedExports1.__unpin = __unpin1, extendedExports1.__collect = __collect1, extendedExports1.__newString = __newString1, extendedExports1.__newArrayBuffer = __newArrayBuffer1, extendedExports1.__getString = __getString1, extendedExports1.__newArray = __newArray1, extendedExports1.__getArrayView = __getArrayView1, extendedExports1.__getArray = __getArray1, extendedExports1.__getArrayBuffer = __getArrayBuffer1, extendedExports1.__getFunction = __getFunction1, [
                        Int8Array,
                        Uint8Array,
                        Uint8ClampedArray,
                        Int16Array,
                        Uint16Array,
                        Int32Array,
                        Uint32Array,
                        Float32Array,
                        Float64Array
                    ].forEach((ctor1)=>{
                        attachTypedArrayFunctions1(ctor1, ctor1.name, 31 - Math.clz32(ctor1.BYTES_PER_ELEMENT));
                    }), BIGINT1 && [
                        BigUint64Array,
                        BigInt64Array
                    ].forEach((ctor1)=>{
                        attachTypedArrayFunctions1(ctor1, ctor1.name.slice(3), 3);
                    }), extendedExports1.__instanceof = __instanceof1, extendedExports1.memory = extendedExports1.memory || memory1, extendedExports1.table = extendedExports1.table || table1, demangle1(exports1, extendedExports1);
                }
                function isResponse1(src1) {
                    return "undefined" != typeof Response && src1 instanceof Response;
                }
                function isModule1(src1) {
                    return src1 instanceof WebAssembly.Module;
                }
                async function instantiate1(source1, imports1 = {}) {
                    if (isResponse1(source1 = await source1)) return instantiateStreaming1(source1, imports1);
                    const module1 = isModule1(source1) ? source1 : await WebAssembly.compile(source1), extended1 = preInstantiate1(imports1), instance1 = await WebAssembly.instantiate(module1, imports1), exports1 = postInstantiate1(extended1, instance1);
                    return {
                        module: module1,
                        instance: instance1,
                        exports: exports1
                    };
                }
                function instantiateSync1(source1, imports1 = {}) {
                    const module1 = isModule1(source1) ? source1 : new WebAssembly.Module(source1), extended1 = preInstantiate1(imports1), instance1 = new WebAssembly.Instance(module1, imports1), exports1 = postInstantiate1(extended1, instance1);
                    return {
                        module: module1,
                        instance: instance1,
                        exports: exports1
                    };
                }
                async function instantiateStreaming1(source1, imports1 = {}) {
                    if (!WebAssembly.instantiateStreaming) return instantiate1(isResponse1(source1 = await source1) ? source1.arrayBuffer() : source1, imports1);
                    const extended1 = preInstantiate1(imports1), result1 = await WebAssembly.instantiateStreaming(source1, imports1), exports1 = postInstantiate1(extended1, result1.instance);
                    return {
                        ...result1,
                        exports: exports1
                    };
                }
                function demangle1(exports1, extendedExports1 = {}) {
                    const setArgumentsLength1 = exports1.__argumentsLength ? (length1)=>{
                        exports1.__argumentsLength.value = length1;
                    } : exports1.__setArgumentsLength || exports1.__setargc || (()=>{});
                    for (let internalName1 of Object.keys(exports1)){
                        const elem1 = exports1[internalName1];
                        let parts1 = internalName1.split("."), curr1 = extendedExports1;
                        for(; parts1.length > 1;){
                            let part1 = parts1.shift();
                            Object.hasOwn(curr1, part1) || (curr1[part1] = {}), curr1 = curr1[part1];
                        }
                        let name1 = parts1[0], hash1 = name1.indexOf("#");
                        if (hash1 >= 0) {
                            const className1 = name1.substring(0, hash1), classElem1 = curr1[className1];
                            if (void 0 === classElem1 || !classElem1.prototype) {
                                const ctor1 = function(...args1) {
                                    return ctor1.wrap(ctor1.prototype.constructor(0, ...args1));
                                };
                                ctor1.prototype = {
                                    valueOf () {
                                        return this[THIS1];
                                    }
                                }, ctor1.wrap = function(thisValue1) {
                                    return Object.create(ctor1.prototype, {
                                        [THIS1]: {
                                            value: thisValue1,
                                            writable: !1
                                        }
                                    });
                                }, classElem1 && Object.getOwnPropertyNames(classElem1).forEach((name1)=>Object.defineProperty(ctor1, name1, Object.getOwnPropertyDescriptor(classElem1, name1))), curr1[className1] = ctor1;
                            }
                            if (name1 = name1.substring(hash1 + 1), curr1 = curr1[className1].prototype, /^(get|set):/.test(name1)) {
                                if (!Object.hasOwn(curr1, name1 = name1.substring(4))) {
                                    let getter1 = exports1[internalName1.replace("set:", "get:")], setter1 = exports1[internalName1.replace("get:", "set:")];
                                    Object.defineProperty(curr1, name1, {
                                        get () {
                                            return getter1(this[THIS1]);
                                        },
                                        set (value1) {
                                            setter1(this[THIS1], value1);
                                        },
                                        enumerable: !0
                                    });
                                }
                            } else 'constructor' === name1 ? (curr1[name1] = function(...args1) {
                                return setArgumentsLength1(args1.length), elem1(...args1);
                            }).original = elem1 : (curr1[name1] = function(...args1) {
                                return setArgumentsLength1(args1.length), elem1(this[THIS1], ...args1);
                            }).original = elem1;
                        } else /^(get|set):/.test(name1) ? Object.hasOwn(curr1, name1 = name1.substring(4)) || Object.defineProperty(curr1, name1, {
                            get: exports1[internalName1.replace("set:", "get:")],
                            set: exports1[internalName1.replace("get:", "set:")],
                            enumerable: !0
                        }) : "function" == typeof elem1 && elem1 !== setArgumentsLength1 ? (curr1[name1] = (...args1)=>(setArgumentsLength1(args1.length), elem1(...args1))).original = elem1 : curr1[name1] = elem1;
                    }
                    return extendedExports1;
                }
                Object.hasOwn = Object.hasOwn || function(obj1, prop1) {
                    return Object.prototype.hasOwnProperty.call(obj1, prop1);
                };
                var _default1 = {
                    instantiate: instantiate1,
                    instantiateSync: instantiateSync1,
                    instantiateStreaming: instantiateStreaming1,
                    demangle: demangle1
                };
                return exports1.default = _default1, "default" in exports1 ? exports1.default : exports1;
            }({});
            void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__1 = (function() {
                return loader1;
            }).apply(exports1, [])) && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__1);
        },
        3083: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var possibleNames1 = [
                'BigInt64Array',
                'BigUint64Array',
                'Float32Array',
                'Float64Array',
                'Int16Array',
                'Int32Array',
                'Int8Array',
                'Uint16Array',
                'Uint32Array',
                'Uint8Array',
                'Uint8ClampedArray'
            ], g3 = 'undefined' == typeof globalThis ? __webpack_require__1.g : globalThis;
            module1.exports = function() {
                for(var out1 = [], i2 = 0; i2 < possibleNames1.length; i2++)'function' == typeof g3[possibleNames1[i2]] && (out1[out1.length] = possibleNames1[i2]);
                return out1;
            };
        },
        882: function(module1, __unused_webpack_exports1, __webpack_require__1) {
            "use strict";
            var $gOPD1 = __webpack_require__1(210)('%Object.getOwnPropertyDescriptor%', !0);
            if ($gOPD1) try {
                $gOPD1([], 'length');
            } catch (e1) {
                $gOPD1 = null;
            }
            module1.exports = $gOPD1;
        },
        7568: function(__unused_webpack___webpack_module__1, __webpack_exports__1, __webpack_require__1) {
            "use strict";
            function asyncGeneratorStep1(gen1, resolve1, reject1, _next1, _throw1, key1, arg4) {
                try {
                    var info1 = gen1[key1](arg4), value1 = info1.value;
                } catch (error1) {
                    reject1(error1);
                    return;
                }
                info1.done ? resolve1(value1) : Promise.resolve(value1).then(_next1, _throw1);
            }
            function _asyncToGenerator1(fn1) {
                return function() {
                    var self1 = this, args1 = arguments;
                    return new Promise(function(resolve1, reject1) {
                        var gen1 = fn1.apply(self1, args1);
                        function _next1(value1) {
                            asyncGeneratorStep1(gen1, resolve1, reject1, _next1, _throw1, "next", value1);
                        }
                        function _throw1(err1) {
                            asyncGeneratorStep1(gen1, resolve1, reject1, _next1, _throw1, "throw", err1);
                        }
                        _next1(void 0);
                    });
                };
            }
            __webpack_require__1.d(__webpack_exports__1, {
                Z: function() {
                    return _asyncToGenerator1;
                }
            });
        },
        9396: function(__unused_webpack___webpack_module__1, __webpack_exports__1, __webpack_require__1) {
            "use strict";
            function ownKeys1(object1, enumerableOnly1) {
                var keys1 = Object.keys(object1);
                if (Object.getOwnPropertySymbols) {
                    var symbols1 = Object.getOwnPropertySymbols(object1);
                    enumerableOnly1 && (symbols1 = symbols1.filter(function(sym1) {
                        return Object.getOwnPropertyDescriptor(object1, sym1).enumerable;
                    })), keys1.push.apply(keys1, symbols1);
                }
                return keys1;
            }
            function _objectSpreadProps1(target1, source1) {
                return source1 = null != source1 ? source1 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target1, Object.getOwnPropertyDescriptors(source1)) : ownKeys1(Object(source1)).forEach(function(key1) {
                    Object.defineProperty(target1, key1, Object.getOwnPropertyDescriptor(source1, key1));
                }), target1;
            }
            __webpack_require__1.d(__webpack_exports__1, {
                Z: function() {
                    return _objectSpreadProps1;
                }
            });
        },
        8597: function(module1) {
            "use strict";
            module1.exports = {
                i8: "6.5.4"
            };
        },
        2454: function(module1) {
            "use strict";
            module1.exports = JSON.parse('{"O_RDONLY":0,"O_WRONLY":1,"O_RDWR":2,"S_IFMT":61440,"S_IFREG":32768,"S_IFDIR":16384,"S_IFCHR":8192,"S_IFBLK":24576,"S_IFIFO":4096,"S_IFLNK":40960,"S_IFSOCK":49152,"O_CREAT":512,"O_EXCL":2048,"O_NOCTTY":131072,"O_TRUNC":1024,"O_APPEND":8,"O_DIRECTORY":1048576,"O_NOFOLLOW":256,"O_SYNC":128,"O_SYMLINK":2097152,"O_NONBLOCK":4,"S_IRWXU":448,"S_IRUSR":256,"S_IWUSR":128,"S_IXUSR":64,"S_IRWXG":56,"S_IRGRP":32,"S_IWGRP":16,"S_IXGRP":8,"S_IRWXO":7,"S_IROTH":4,"S_IWOTH":2,"S_IXOTH":1,"E2BIG":7,"EACCES":13,"EADDRINUSE":48,"EADDRNOTAVAIL":49,"EAFNOSUPPORT":47,"EAGAIN":35,"EALREADY":37,"EBADF":9,"EBADMSG":94,"EBUSY":16,"ECANCELED":89,"ECHILD":10,"ECONNABORTED":53,"ECONNREFUSED":61,"ECONNRESET":54,"EDEADLK":11,"EDESTADDRREQ":39,"EDOM":33,"EDQUOT":69,"EEXIST":17,"EFAULT":14,"EFBIG":27,"EHOSTUNREACH":65,"EIDRM":90,"EILSEQ":92,"EINPROGRESS":36,"EINTR":4,"EINVAL":22,"EIO":5,"EISCONN":56,"EISDIR":21,"ELOOP":62,"EMFILE":24,"EMLINK":31,"EMSGSIZE":40,"EMULTIHOP":95,"ENAMETOOLONG":63,"ENETDOWN":50,"ENETRESET":52,"ENETUNREACH":51,"ENFILE":23,"ENOBUFS":55,"ENODATA":96,"ENODEV":19,"ENOENT":2,"ENOEXEC":8,"ENOLCK":77,"ENOLINK":97,"ENOMEM":12,"ENOMSG":91,"ENOPROTOOPT":42,"ENOSPC":28,"ENOSR":98,"ENOSTR":99,"ENOSYS":78,"ENOTCONN":57,"ENOTDIR":20,"ENOTEMPTY":66,"ENOTSOCK":38,"ENOTSUP":45,"ENOTTY":25,"ENXIO":6,"EOPNOTSUPP":102,"EOVERFLOW":84,"EPERM":1,"EPIPE":32,"EPROTO":100,"EPROTONOSUPPORT":43,"EPROTOTYPE":41,"ERANGE":34,"EROFS":30,"ESPIPE":29,"ESRCH":3,"ESTALE":70,"ETIME":101,"ETIMEDOUT":60,"ETXTBSY":26,"EWOULDBLOCK":35,"EXDEV":18,"SIGHUP":1,"SIGINT":2,"SIGQUIT":3,"SIGILL":4,"SIGTRAP":5,"SIGABRT":6,"SIGIOT":6,"SIGBUS":10,"SIGFPE":8,"SIGKILL":9,"SIGUSR1":30,"SIGSEGV":11,"SIGUSR2":31,"SIGPIPE":13,"SIGALRM":14,"SIGTERM":15,"SIGCHLD":20,"SIGCONT":19,"SIGSTOP":17,"SIGTSTP":18,"SIGTTIN":21,"SIGTTOU":22,"SIGURG":16,"SIGXCPU":24,"SIGXFSZ":25,"SIGVTALRM":26,"SIGPROF":27,"SIGWINCH":28,"SIGIO":23,"SIGSYS":12,"SSL_OP_ALL":2147486719,"SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION":262144,"SSL_OP_CIPHER_SERVER_PREFERENCE":4194304,"SSL_OP_CISCO_ANYCONNECT":32768,"SSL_OP_COOKIE_EXCHANGE":8192,"SSL_OP_CRYPTOPRO_TLSEXT_BUG":2147483648,"SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS":2048,"SSL_OP_EPHEMERAL_RSA":0,"SSL_OP_LEGACY_SERVER_CONNECT":4,"SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER":32,"SSL_OP_MICROSOFT_SESS_ID_BUG":1,"SSL_OP_MSIE_SSLV2_RSA_PADDING":0,"SSL_OP_NETSCAPE_CA_DN_BUG":536870912,"SSL_OP_NETSCAPE_CHALLENGE_BUG":2,"SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG":1073741824,"SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG":8,"SSL_OP_NO_COMPRESSION":131072,"SSL_OP_NO_QUERY_MTU":4096,"SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION":65536,"SSL_OP_NO_SSLv2":16777216,"SSL_OP_NO_SSLv3":33554432,"SSL_OP_NO_TICKET":16384,"SSL_OP_NO_TLSv1":67108864,"SSL_OP_NO_TLSv1_1":268435456,"SSL_OP_NO_TLSv1_2":134217728,"SSL_OP_PKCS1_CHECK_1":0,"SSL_OP_PKCS1_CHECK_2":0,"SSL_OP_SINGLE_DH_USE":1048576,"SSL_OP_SINGLE_ECDH_USE":524288,"SSL_OP_SSLEAY_080_CLIENT_DH_BUG":128,"SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG":0,"SSL_OP_TLS_BLOCK_PADDING_BUG":512,"SSL_OP_TLS_D5_BUG":256,"SSL_OP_TLS_ROLLBACK_BUG":8388608,"ENGINE_METHOD_DSA":2,"ENGINE_METHOD_DH":4,"ENGINE_METHOD_RAND":8,"ENGINE_METHOD_ECDH":16,"ENGINE_METHOD_ECDSA":32,"ENGINE_METHOD_CIPHERS":64,"ENGINE_METHOD_DIGESTS":128,"ENGINE_METHOD_STORE":256,"ENGINE_METHOD_PKEY_METHS":512,"ENGINE_METHOD_PKEY_ASN1_METHS":1024,"ENGINE_METHOD_ALL":65535,"ENGINE_METHOD_NONE":0,"DH_CHECK_P_NOT_SAFE_PRIME":2,"DH_CHECK_P_NOT_PRIME":1,"DH_UNABLE_TO_CHECK_GENERATOR":4,"DH_NOT_SUITABLE_GENERATOR":8,"NPN_ENABLED":1,"RSA_PKCS1_PADDING":1,"RSA_SSLV23_PADDING":2,"RSA_NO_PADDING":3,"RSA_PKCS1_OAEP_PADDING":4,"RSA_X931_PADDING":5,"RSA_PKCS1_PSS_PADDING":6,"POINT_CONVERSION_COMPRESSED":2,"POINT_CONVERSION_UNCOMPRESSED":4,"POINT_CONVERSION_HYBRID":6,"F_OK":0,"R_OK":4,"W_OK":2,"X_OK":1,"UV_UDP_REUSEADDR":4}');
        },
        8575: function(module1) {
            "use strict";
            module1.exports = JSON.parse('{"block":"block_type","loop":"block_type","if":"block_type","br":"varuint32","br_if":"varuint32","br_table":"br_table","call":"varuint32","call_indirect":"call_indirect","get_local":"varuint32","set_local":"varuint32","tee_local":"varuint32","get_global":"varuint32","set_global":"varuint32","load":"memory_immediate","load8_s":"memory_immediate","load8_u":"memory_immediate","load16_s":"memory_immediate","load16_u":"memory_immediate","load32_s":"memory_immediate","load32_u":"memory_immediate","store":"memory_immediate","store8":"memory_immediate","store16":"memory_immediate","store32":"memory_immediate","current_memory":"varuint1","grow_memory":"varuint1","i32":"varint32","i64":"varint64","f32":"uint32","f64":"uint64"}');
        },
        5936: function(module1) {
            "use strict";
            module1.exports = JSON.parse('{"start":0,"type":{"params":{"DEFAULT":0},"return_type":{"DEFAULT":0}},"import":0,"code":{"locals":{"DEFAULT":1},"code":{"get_local":120,"set_local":120,"tee_local":120,"get_global":120,"set_global":120,"load8_s":120,"load8_u":120,"load16_s":120,"load16_u":120,"load32_s":120,"load32_u":120,"load":120,"store8":120,"store16":120,"store32":120,"store":120,"grow_memory":10000,"current_memory":100,"nop":1,"block":1,"loop":1,"if":1,"then":90,"else":90,"br":90,"br_if":90,"br_table":120,"return":90,"call":90,"call_indirect":10000,"const":1,"add":45,"sub":45,"mul":45,"div_s":36000,"div_u":36000,"rem_s":36000,"rem_u":36000,"and":45,"or":45,"xor":45,"shl":67,"shr_u":67,"shr_s":67,"rotl":90,"rotr":90,"eq":45,"eqz":45,"ne":45,"lt_s":45,"lt_u":45,"le_s":45,"le_u":45,"gt_s":45,"gt_u":45,"ge_s":45,"ge_u":45,"clz":45,"ctz":45,"popcnt":45,"drop":120,"select":120,"unreachable":1}},"data":0}');
        }
    }
]);
